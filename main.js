/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/excalibur/build/esm/excalibur.js":
/*!*******************************************************!*\
  !*** ./node_modules/excalibur/build/esm/excalibur.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActionContext": () => (/* binding */ __webpack_exports__ActionContext),
/* harmony export */   "ActionQueue": () => (/* binding */ __webpack_exports__ActionQueue),
/* harmony export */   "ActionsComponent": () => (/* binding */ __webpack_exports__ActionsComponent),
/* harmony export */   "ActionsSystem": () => (/* binding */ __webpack_exports__ActionsSystem),
/* harmony export */   "ActivateEvent": () => (/* binding */ __webpack_exports__ActivateEvent),
/* harmony export */   "Actor": () => (/* binding */ __webpack_exports__Actor),
/* harmony export */   "AddedComponent": () => (/* binding */ __webpack_exports__AddedComponent),
/* harmony export */   "AddedEntity": () => (/* binding */ __webpack_exports__AddedEntity),
/* harmony export */   "Animation": () => (/* binding */ __webpack_exports__Animation),
/* harmony export */   "AnimationDirection": () => (/* binding */ __webpack_exports__AnimationDirection),
/* harmony export */   "AnimationStrategy": () => (/* binding */ __webpack_exports__AnimationStrategy),
/* harmony export */   "ArcadeSolver": () => (/* binding */ __webpack_exports__ArcadeSolver),
/* harmony export */   "AudioContextFactory": () => (/* binding */ __webpack_exports__AudioContextFactory),
/* harmony export */   "Axis": () => (/* binding */ __webpack_exports__Axis),
/* harmony export */   "BaseAlign": () => (/* binding */ __webpack_exports__BaseAlign),
/* harmony export */   "BinaryTreeNode": () => (/* binding */ __webpack_exports__BinaryTreeNode),
/* harmony export */   "Blink": () => (/* binding */ __webpack_exports__Blink),
/* harmony export */   "BodyComponent": () => (/* binding */ __webpack_exports__BodyComponent),
/* harmony export */   "BoundingBox": () => (/* binding */ __webpack_exports__BoundingBox),
/* harmony export */   "BroadphaseStrategy": () => (/* binding */ __webpack_exports__BroadphaseStrategy),
/* harmony export */   "BrowserComponent": () => (/* binding */ __webpack_exports__BrowserComponent),
/* harmony export */   "BrowserEvents": () => (/* binding */ __webpack_exports__BrowserEvents),
/* harmony export */   "Camera": () => (/* binding */ __webpack_exports__Camera),
/* harmony export */   "Canvas": () => (/* binding */ __webpack_exports__Canvas),
/* harmony export */   "Cell": () => (/* binding */ __webpack_exports__Cell),
/* harmony export */   "Circle": () => (/* binding */ __webpack_exports__Circle),
/* harmony export */   "CircleCollider": () => (/* binding */ __webpack_exports__CircleCollider),
/* harmony export */   "Class": () => (/* binding */ __webpack_exports__Class),
/* harmony export */   "ClosestLine": () => (/* binding */ __webpack_exports__ClosestLine),
/* harmony export */   "ClosestLineJumpTable": () => (/* binding */ __webpack_exports__ClosestLineJumpTable),
/* harmony export */   "Collider": () => (/* binding */ __webpack_exports__Collider),
/* harmony export */   "ColliderComponent": () => (/* binding */ __webpack_exports__ColliderComponent),
/* harmony export */   "CollisionContact": () => (/* binding */ __webpack_exports__CollisionContact),
/* harmony export */   "CollisionEndEvent": () => (/* binding */ __webpack_exports__CollisionEndEvent),
/* harmony export */   "CollisionGroup": () => (/* binding */ __webpack_exports__CollisionGroup),
/* harmony export */   "CollisionGroupManager": () => (/* binding */ __webpack_exports__CollisionGroupManager),
/* harmony export */   "CollisionJumpTable": () => (/* binding */ __webpack_exports__CollisionJumpTable),
/* harmony export */   "CollisionPostSolveEvent": () => (/* binding */ __webpack_exports__CollisionPostSolveEvent),
/* harmony export */   "CollisionPreSolveEvent": () => (/* binding */ __webpack_exports__CollisionPreSolveEvent),
/* harmony export */   "CollisionResolutionStrategy": () => (/* binding */ __webpack_exports__CollisionResolutionStrategy),
/* harmony export */   "CollisionSolver": () => (/* binding */ __webpack_exports__CollisionSolver),
/* harmony export */   "CollisionStartEvent": () => (/* binding */ __webpack_exports__CollisionStartEvent),
/* harmony export */   "CollisionSystem": () => (/* binding */ __webpack_exports__CollisionSystem),
/* harmony export */   "CollisionType": () => (/* binding */ __webpack_exports__CollisionType),
/* harmony export */   "Color": () => (/* binding */ __webpack_exports__Color),
/* harmony export */   "ColorBlindCorrector": () => (/* binding */ __webpack_exports__ColorBlindCorrector),
/* harmony export */   "ColorBlindFlags": () => (/* binding */ __webpack_exports__ColorBlindFlags),
/* harmony export */   "ColorBlindness": () => (/* binding */ __webpack_exports__ColorBlindness),
/* harmony export */   "Component": () => (/* binding */ __webpack_exports__Component),
/* harmony export */   "CompositeCollider": () => (/* binding */ __webpack_exports__CompositeCollider),
/* harmony export */   "Configurable": () => (/* binding */ __webpack_exports__Configurable),
/* harmony export */   "ConsoleAppender": () => (/* binding */ __webpack_exports__ConsoleAppender),
/* harmony export */   "ContactConstraintPoint": () => (/* binding */ __webpack_exports__ContactConstraintPoint),
/* harmony export */   "ContactEndEvent": () => (/* binding */ __webpack_exports__ContactEndEvent),
/* harmony export */   "ContactStartEvent": () => (/* binding */ __webpack_exports__ContactStartEvent),
/* harmony export */   "CoordPlane": () => (/* binding */ __webpack_exports__CoordPlane),
/* harmony export */   "CullingBox": () => (/* binding */ __webpack_exports__CullingBox),
/* harmony export */   "DeactivateEvent": () => (/* binding */ __webpack_exports__DeactivateEvent),
/* harmony export */   "Debug": () => (/* binding */ __webpack_exports__Debug),
/* harmony export */   "DebugSystem": () => (/* binding */ __webpack_exports__DebugSystem),
/* harmony export */   "DebugText": () => (/* binding */ __webpack_exports__DebugText),
/* harmony export */   "DegreeOfFreedom": () => (/* binding */ __webpack_exports__DegreeOfFreedom),
/* harmony export */   "Detector": () => (/* binding */ __webpack_exports__Detector),
/* harmony export */   "Die": () => (/* binding */ __webpack_exports__Die),
/* harmony export */   "Direction": () => (/* binding */ __webpack_exports__Direction),
/* harmony export */   "DisplayMode": () => (/* binding */ __webpack_exports__DisplayMode),
/* harmony export */   "DynamicTree": () => (/* binding */ __webpack_exports__DynamicTree),
/* harmony export */   "DynamicTreeCollisionProcessor": () => (/* binding */ __webpack_exports__DynamicTreeCollisionProcessor),
/* harmony export */   "EX_VERSION": () => (/* binding */ __webpack_exports__EX_VERSION),
/* harmony export */   "EaseTo": () => (/* binding */ __webpack_exports__EaseTo),
/* harmony export */   "EasingFunctions": () => (/* binding */ __webpack_exports__EasingFunctions),
/* harmony export */   "EdgeCollider": () => (/* binding */ __webpack_exports__EdgeCollider),
/* harmony export */   "ElasticToActorStrategy": () => (/* binding */ __webpack_exports__ElasticToActorStrategy),
/* harmony export */   "EmitterType": () => (/* binding */ __webpack_exports__EmitterType),
/* harmony export */   "Engine": () => (/* binding */ __webpack_exports__Engine),
/* harmony export */   "EnterTriggerEvent": () => (/* binding */ __webpack_exports__EnterTriggerEvent),
/* harmony export */   "EnterViewPortEvent": () => (/* binding */ __webpack_exports__EnterViewPortEvent),
/* harmony export */   "Entity": () => (/* binding */ __webpack_exports__Entity),
/* harmony export */   "EntityManager": () => (/* binding */ __webpack_exports__EntityManager),
/* harmony export */   "EventDispatcher": () => (/* binding */ __webpack_exports__EventDispatcher),
/* harmony export */   "EventTypes": () => (/* binding */ __webpack_exports__EventTypes),
/* harmony export */   "Events": () => (/* binding */ __webpack_exports__Events),
/* harmony export */   "ExResponse": () => (/* binding */ __webpack_exports__ExResponse),
/* harmony export */   "ExcaliburGraphicsContext2DCanvas": () => (/* binding */ __webpack_exports__ExcaliburGraphicsContext2DCanvas),
/* harmony export */   "ExcaliburGraphicsContextWebGL": () => (/* binding */ __webpack_exports__ExcaliburGraphicsContextWebGL),
/* harmony export */   "ExitTriggerEvent": () => (/* binding */ __webpack_exports__ExitTriggerEvent),
/* harmony export */   "ExitViewPortEvent": () => (/* binding */ __webpack_exports__ExitViewPortEvent),
/* harmony export */   "Experiments": () => (/* binding */ __webpack_exports__Experiments),
/* harmony export */   "Fade": () => (/* binding */ __webpack_exports__Fade),
/* harmony export */   "Flags": () => (/* binding */ __webpack_exports__Flags),
/* harmony export */   "Follow": () => (/* binding */ __webpack_exports__Follow),
/* harmony export */   "Font": () => (/* binding */ __webpack_exports__Font),
/* harmony export */   "FontStyle": () => (/* binding */ __webpack_exports__FontStyle),
/* harmony export */   "FontUnit": () => (/* binding */ __webpack_exports__FontUnit),
/* harmony export */   "FrameStats": () => (/* binding */ __webpack_exports__FrameStats),
/* harmony export */   "GameEvent": () => (/* binding */ __webpack_exports__GameEvent),
/* harmony export */   "GameStartEvent": () => (/* binding */ __webpack_exports__GameStartEvent),
/* harmony export */   "GameStopEvent": () => (/* binding */ __webpack_exports__GameStopEvent),
/* harmony export */   "GamepadAxisEvent": () => (/* binding */ __webpack_exports__GamepadAxisEvent),
/* harmony export */   "GamepadButtonEvent": () => (/* binding */ __webpack_exports__GamepadButtonEvent),
/* harmony export */   "GamepadConnectEvent": () => (/* binding */ __webpack_exports__GamepadConnectEvent),
/* harmony export */   "GamepadDisconnectEvent": () => (/* binding */ __webpack_exports__GamepadDisconnectEvent),
/* harmony export */   "Gif": () => (/* binding */ __webpack_exports__Gif),
/* harmony export */   "GlobalCoordinates": () => (/* binding */ __webpack_exports__GlobalCoordinates),
/* harmony export */   "Graphic": () => (/* binding */ __webpack_exports__Graphic),
/* harmony export */   "GraphicsComponent": () => (/* binding */ __webpack_exports__GraphicsComponent),
/* harmony export */   "GraphicsGroup": () => (/* binding */ __webpack_exports__GraphicsGroup),
/* harmony export */   "GraphicsLayer": () => (/* binding */ __webpack_exports__GraphicsLayer),
/* harmony export */   "GraphicsLayers": () => (/* binding */ __webpack_exports__GraphicsLayers),
/* harmony export */   "GraphicsSystem": () => (/* binding */ __webpack_exports__GraphicsSystem),
/* harmony export */   "HiddenEvent": () => (/* binding */ __webpack_exports__HiddenEvent),
/* harmony export */   "ImageSource": () => (/* binding */ __webpack_exports__ImageSource),
/* harmony export */   "InitializeEvent": () => (/* binding */ __webpack_exports__InitializeEvent),
/* harmony export */   "Input": () => (/* binding */ __webpack_exports__Input),
/* harmony export */   "Integrator": () => (/* binding */ __webpack_exports__Integrator),
/* harmony export */   "KillEvent": () => (/* binding */ __webpack_exports__KillEvent),
/* harmony export */   "Label": () => (/* binding */ __webpack_exports__Label),
/* harmony export */   "Legacy": () => (/* binding */ __webpack_exports__Legacy),
/* harmony export */   "LegacyDrawing": () => (/* binding */ __webpack_exports__LegacyDrawing),
/* harmony export */   "LimitCameraBoundsStrategy": () => (/* binding */ __webpack_exports__LimitCameraBoundsStrategy),
/* harmony export */   "Line": () => (/* binding */ __webpack_exports__Line),
/* harmony export */   "Loader": () => (/* binding */ __webpack_exports__Loader),
/* harmony export */   "LockCameraToActorAxisStrategy": () => (/* binding */ __webpack_exports__LockCameraToActorAxisStrategy),
/* harmony export */   "LockCameraToActorStrategy": () => (/* binding */ __webpack_exports__LockCameraToActorStrategy),
/* harmony export */   "LogLevel": () => (/* binding */ __webpack_exports__LogLevel),
/* harmony export */   "Logger": () => (/* binding */ __webpack_exports__Logger),
/* harmony export */   "Matrix": () => (/* binding */ __webpack_exports__Matrix),
/* harmony export */   "MatrixLocations": () => (/* binding */ __webpack_exports__MatrixLocations),
/* harmony export */   "MediaEvent": () => (/* binding */ __webpack_exports__MediaEvent),
/* harmony export */   "Meet": () => (/* binding */ __webpack_exports__Meet),
/* harmony export */   "MockedElement": () => (/* binding */ __webpack_exports__MockedElement),
/* harmony export */   "MotionComponent": () => (/* binding */ __webpack_exports__MotionComponent),
/* harmony export */   "MotionSystem": () => (/* binding */ __webpack_exports__MotionSystem),
/* harmony export */   "MoveBy": () => (/* binding */ __webpack_exports__MoveBy),
/* harmony export */   "MoveTo": () => (/* binding */ __webpack_exports__MoveTo),
/* harmony export */   "NativeSoundEvent": () => (/* binding */ __webpack_exports__NativeSoundEvent),
/* harmony export */   "NativeSoundProcessedEvent": () => (/* binding */ __webpack_exports__NativeSoundProcessedEvent),
/* harmony export */   "Observable": () => (/* binding */ __webpack_exports__Observable),
/* harmony export */   "Pair": () => (/* binding */ __webpack_exports__Pair),
/* harmony export */   "ParseGif": () => (/* binding */ __webpack_exports__ParseGif),
/* harmony export */   "Particle": () => (/* binding */ __webpack_exports__Particle),
/* harmony export */   "ParticleEmitter": () => (/* binding */ __webpack_exports__ParticleEmitter),
/* harmony export */   "Physics": () => (/* binding */ __webpack_exports__Physics),
/* harmony export */   "PhysicsStats": () => (/* binding */ __webpack_exports__PhysicsStats),
/* harmony export */   "Polygon": () => (/* binding */ __webpack_exports__Polygon),
/* harmony export */   "PolygonCollider": () => (/* binding */ __webpack_exports__PolygonCollider),
/* harmony export */   "Pool": () => (/* binding */ __webpack_exports__Pool),
/* harmony export */   "PostCollisionEvent": () => (/* binding */ __webpack_exports__PostCollisionEvent),
/* harmony export */   "PostDebugDrawEvent": () => (/* binding */ __webpack_exports__PostDebugDrawEvent),
/* harmony export */   "PostDrawEvent": () => (/* binding */ __webpack_exports__PostDrawEvent),
/* harmony export */   "PostFrameEvent": () => (/* binding */ __webpack_exports__PostFrameEvent),
/* harmony export */   "PostKillEvent": () => (/* binding */ __webpack_exports__PostKillEvent),
/* harmony export */   "PostUpdateEvent": () => (/* binding */ __webpack_exports__PostUpdateEvent),
/* harmony export */   "PreCollisionEvent": () => (/* binding */ __webpack_exports__PreCollisionEvent),
/* harmony export */   "PreDebugDrawEvent": () => (/* binding */ __webpack_exports__PreDebugDrawEvent),
/* harmony export */   "PreDrawEvent": () => (/* binding */ __webpack_exports__PreDrawEvent),
/* harmony export */   "PreFrameEvent": () => (/* binding */ __webpack_exports__PreFrameEvent),
/* harmony export */   "PreKillEvent": () => (/* binding */ __webpack_exports__PreKillEvent),
/* harmony export */   "PreUpdateEvent": () => (/* binding */ __webpack_exports__PreUpdateEvent),
/* harmony export */   "Projection": () => (/* binding */ __webpack_exports__Projection),
/* harmony export */   "Promise": () => (/* binding */ __webpack_exports__Promise),
/* harmony export */   "PromiseState": () => (/* binding */ __webpack_exports__PromiseState),
/* harmony export */   "Query": () => (/* binding */ __webpack_exports__Query),
/* harmony export */   "QueryManager": () => (/* binding */ __webpack_exports__QueryManager),
/* harmony export */   "RadiusAroundActorStrategy": () => (/* binding */ __webpack_exports__RadiusAroundActorStrategy),
/* harmony export */   "Random": () => (/* binding */ __webpack_exports__Random),
/* harmony export */   "Raster": () => (/* binding */ __webpack_exports__Raster),
/* harmony export */   "Ray": () => (/* binding */ __webpack_exports__Ray),
/* harmony export */   "RealisticSolver": () => (/* binding */ __webpack_exports__RealisticSolver),
/* harmony export */   "Rectangle": () => (/* binding */ __webpack_exports__Rectangle),
/* harmony export */   "RemovedComponent": () => (/* binding */ __webpack_exports__RemovedComponent),
/* harmony export */   "RemovedEntity": () => (/* binding */ __webpack_exports__RemovedEntity),
/* harmony export */   "Repeat": () => (/* binding */ __webpack_exports__Repeat),
/* harmony export */   "RepeatForever": () => (/* binding */ __webpack_exports__RepeatForever),
/* harmony export */   "Resolution": () => (/* binding */ __webpack_exports__Resolution),
/* harmony export */   "Resource": () => (/* binding */ __webpack_exports__Resource),
/* harmony export */   "RotateBy": () => (/* binding */ __webpack_exports__RotateBy),
/* harmony export */   "RotateTo": () => (/* binding */ __webpack_exports__RotateTo),
/* harmony export */   "RotationType": () => (/* binding */ __webpack_exports__RotationType),
/* harmony export */   "ScaleBy": () => (/* binding */ __webpack_exports__ScaleBy),
/* harmony export */   "ScaleTo": () => (/* binding */ __webpack_exports__ScaleTo),
/* harmony export */   "Scene": () => (/* binding */ __webpack_exports__Scene),
/* harmony export */   "Screen": () => (/* binding */ __webpack_exports__Screen),
/* harmony export */   "ScreenAppender": () => (/* binding */ __webpack_exports__ScreenAppender),
/* harmony export */   "ScreenElement": () => (/* binding */ __webpack_exports__ScreenElement),
/* harmony export */   "ScrollPreventionMode": () => (/* binding */ __webpack_exports__ScrollPreventionMode),
/* harmony export */   "Shape": () => (/* binding */ __webpack_exports__Shape),
/* harmony export */   "Side": () => (/* binding */ __webpack_exports__Side),
/* harmony export */   "SortedList": () => (/* binding */ __webpack_exports__SortedList),
/* harmony export */   "Sound": () => (/* binding */ __webpack_exports__Sound),
/* harmony export */   "Sprite": () => (/* binding */ __webpack_exports__Sprite),
/* harmony export */   "SpriteFont": () => (/* binding */ __webpack_exports__SpriteFont),
/* harmony export */   "SpriteSheet": () => (/* binding */ __webpack_exports__SpriteSheet),
/* harmony export */   "StrategyContainer": () => (/* binding */ __webpack_exports__StrategyContainer),
/* harmony export */   "Stream": () => (/* binding */ __webpack_exports__Stream),
/* harmony export */   "SubscribeEvent": () => (/* binding */ __webpack_exports__SubscribeEvent),
/* harmony export */   "System": () => (/* binding */ __webpack_exports__System),
/* harmony export */   "SystemManager": () => (/* binding */ __webpack_exports__SystemManager),
/* harmony export */   "SystemType": () => (/* binding */ __webpack_exports__SystemType),
/* harmony export */   "TagComponent": () => (/* binding */ __webpack_exports__TagComponent),
/* harmony export */   "Text": () => (/* binding */ __webpack_exports__Text),
/* harmony export */   "TextAlign": () => (/* binding */ __webpack_exports__TextAlign),
/* harmony export */   "TileMap": () => (/* binding */ __webpack_exports__TileMap),
/* harmony export */   "Timer": () => (/* binding */ __webpack_exports__Timer),
/* harmony export */   "Traits": () => (/* binding */ __webpack_exports__Traits),
/* harmony export */   "TransformComponent": () => (/* binding */ __webpack_exports__TransformComponent),
/* harmony export */   "TreeNode": () => (/* binding */ __webpack_exports__TreeNode),
/* harmony export */   "Trigger": () => (/* binding */ __webpack_exports__Trigger),
/* harmony export */   "UnsubscribeEvent": () => (/* binding */ __webpack_exports__UnsubscribeEvent),
/* harmony export */   "Util": () => (/* binding */ __webpack_exports__Util),
/* harmony export */   "Vector": () => (/* binding */ __webpack_exports__Vector),
/* harmony export */   "VectorView": () => (/* binding */ __webpack_exports__VectorView),
/* harmony export */   "VisibleEvent": () => (/* binding */ __webpack_exports__VisibleEvent),
/* harmony export */   "WebAudioInstance": () => (/* binding */ __webpack_exports__WebAudioInstance),
/* harmony export */   "World": () => (/* binding */ __webpack_exports__World),
/* harmony export */   "canonicalizeAngle": () => (/* binding */ __webpack_exports__canonicalizeAngle),
/* harmony export */   "clamp": () => (/* binding */ __webpack_exports__clamp),
/* harmony export */   "createId": () => (/* binding */ __webpack_exports__createId),
/* harmony export */   "hasGraphicsTick": () => (/* binding */ __webpack_exports__hasGraphicsTick),
/* harmony export */   "hasOnInitialize": () => (/* binding */ __webpack_exports__hasOnInitialize),
/* harmony export */   "hasOnPostUpdate": () => (/* binding */ __webpack_exports__hasOnPostUpdate),
/* harmony export */   "hasOnPreUpdate": () => (/* binding */ __webpack_exports__hasOnPreUpdate),
/* harmony export */   "hasPostDraw": () => (/* binding */ __webpack_exports__hasPostDraw),
/* harmony export */   "hasPreDraw": () => (/* binding */ __webpack_exports__hasPreDraw),
/* harmony export */   "has_initialize": () => (/* binding */ __webpack_exports__has_initialize),
/* harmony export */   "has_postupdate": () => (/* binding */ __webpack_exports__has_postupdate),
/* harmony export */   "has_preupdate": () => (/* binding */ __webpack_exports__has_preupdate),
/* harmony export */   "isAddedComponent": () => (/* binding */ __webpack_exports__isAddedComponent),
/* harmony export */   "isAddedSystemEntity": () => (/* binding */ __webpack_exports__isAddedSystemEntity),
/* harmony export */   "isRemoveSystemEntity": () => (/* binding */ __webpack_exports__isRemoveSystemEntity),
/* harmony export */   "isRemovedComponent": () => (/* binding */ __webpack_exports__isRemovedComponent),
/* harmony export */   "maxMessages": () => (/* binding */ __webpack_exports__maxMessages),
/* harmony export */   "obsolete": () => (/* binding */ __webpack_exports__obsolete),
/* harmony export */   "randomInRange": () => (/* binding */ __webpack_exports__randomInRange),
/* harmony export */   "randomIntInRange": () => (/* binding */ __webpack_exports__randomIntInRange),
/* harmony export */   "range": () => (/* binding */ __webpack_exports__range),
/* harmony export */   "resetObsoleteCounter": () => (/* binding */ __webpack_exports__resetObsoleteCounter),
/* harmony export */   "toDegrees": () => (/* binding */ __webpack_exports__toDegrees),
/* harmony export */   "toRadians": () => (/* binding */ __webpack_exports__toRadians),
/* harmony export */   "vec": () => (/* binding */ __webpack_exports__vec)
/* harmony export */ });
/*!
 * excalibur - 0.25.1 - 2021-11-5
 * https://github.com/excaliburjs/Excalibur
 * Copyright (c) 2021 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>
 * Licensed BSD-2-Clause
 * @preserve
 */
/******/ var __webpack_modules__ = ({

/***/ 4662:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_315__) => {

__nested_webpack_require_315__(3430);
var entryUnbind = __nested_webpack_require_315__(8791);

module.exports = entryUnbind('Array', 'sort');


/***/ }),

/***/ 8343:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_529__) => {

__nested_webpack_require_529__(4769);
var path = __nested_webpack_require_529__(9276);

module.exports = path.Object.keys;


/***/ }),

/***/ 7111:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_724__) => {

var isCallable = __nested_webpack_require_724__(6733);
var tryToString = __nested_webpack_require_724__(9821);

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 1176:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1102__) => {

var isObject = __nested_webpack_require_1102__(5052);

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw TypeError(String(argument) + ' is not an object');
};


/***/ }),

/***/ 9540:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1421__) => {

var toIndexedObject = __nested_webpack_require_1421__(905);
var toLength = __nested_webpack_require_1421__(4237);
var toAbsoluteIndex = __nested_webpack_require_1421__(3231);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 6038:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_2769__) => {


var fails = __nested_webpack_require_2769__(4229);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ 3867:
/***/ ((module) => {

// TODO: use something more complex like timsort?
var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(
    mergeSort(array.slice(0, middle), comparefn),
    mergeSort(array.slice(middle), comparefn),
    comparefn
  );
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  } return array;
};

var merge = function (left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;
  var result = [];

  while (lindex < llength || rindex < rlength) {
    if (lindex < llength && rindex < rlength) {
      result.push(comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]);
    } else {
      result.push(lindex < llength ? left[lindex++] : right[rindex++]);
    }
  } return result;
};

module.exports = mergeSort;


/***/ }),

/***/ 7079:
/***/ ((module) => {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ 1589:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_4580__) => {

var TO_STRING_TAG_SUPPORT = __nested_webpack_require_4580__(1601);
var isCallable = __nested_webpack_require_4580__(6733);
var classofRaw = __nested_webpack_require_4580__(7079);
var wellKnownSymbol = __nested_webpack_require_4580__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7081:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_5670__) => {

var has = __nested_webpack_require_5670__(816);
var ownKeys = __nested_webpack_require_5670__(4826);
var getOwnPropertyDescriptorModule = __nested_webpack_require_5670__(7933);
var definePropertyModule = __nested_webpack_require_5670__(1787);

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ 5762:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_6316__) => {

var DESCRIPTORS = __nested_webpack_require_6316__(7400);
var definePropertyModule = __nested_webpack_require_6316__(1787);
var createPropertyDescriptor = __nested_webpack_require_6316__(5358);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 5358:
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 7400:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_7012__) => {

var fails = __nested_webpack_require_7012__(4229);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 2635:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_7410__) => {

var global = __nested_webpack_require_7410__(9859);
var isObject = __nested_webpack_require_7410__(5052);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 2671:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_7831__) => {

var userAgent = __nested_webpack_require_7831__(598);

var firefox = userAgent.match(/firefox\/(\d+)/i);

module.exports = !!firefox && +firefox[1];


/***/ }),

/***/ 8506:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_8062__) => {

var UA = __nested_webpack_require_8062__(598);

module.exports = /MSIE|Trident/.test(UA);


/***/ }),

/***/ 598:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_8233__) => {

var getBuiltIn = __nested_webpack_require_8233__(1333);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 6358:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_8433__) => {

var global = __nested_webpack_require_8433__(9859);
var userAgent = __nested_webpack_require_8433__(598);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] < 4 ? 1 : match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ 9811:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_9100__) => {

var userAgent = __nested_webpack_require_9100__(598);

var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

module.exports = !!webkit && +webkit[1];


/***/ }),

/***/ 8791:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_9333__) => {

var global = __nested_webpack_require_9333__(9859);
var bind = __nested_webpack_require_9333__(7636);

var call = Function.call;

module.exports = function (CONSTRUCTOR, METHOD, length) {
  return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);
};


/***/ }),

/***/ 3837:
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 3103:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_9887__) => {

var global = __nested_webpack_require_9887__(9859);
var getOwnPropertyDescriptor = __nested_webpack_require_9887__(7933).f;
var createNonEnumerableProperty = __nested_webpack_require_9887__(5762);
var redefine = __nested_webpack_require_9887__(7487);
var setGlobal = __nested_webpack_require_9887__(2079);
var copyConstructorProperties = __nested_webpack_require_9887__(7081);
var isForced = __nested_webpack_require_9887__(6541);

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 4229:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 7636:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_12617__) => {

var aCallable = __nested_webpack_require_12617__(7111);

// optional / simple context binding
module.exports = function (fn, that, length) {
  aCallable(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 1805:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_13301__) => {

var DESCRIPTORS = __nested_webpack_require_13301__(7400);
var has = __nested_webpack_require_13301__(816);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = has(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 1333:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_14074__) => {

var global = __nested_webpack_require_14074__(9859);
var isCallable = __nested_webpack_require_14074__(6733);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 5300:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_14511__) => {

var aCallable = __nested_webpack_require_14511__(7111);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ 9859:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_14835__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __nested_webpack_require_14835__.g == 'object' && __nested_webpack_require_14835__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 816:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_15548__) => {

var toObject = __nested_webpack_require_15548__(2991);

var hasOwnProperty = {}.hasOwnProperty;

module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty.call(toObject(it), key);
};


/***/ }),

/***/ 5977:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 4394:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_15907__) => {

var DESCRIPTORS = __nested_webpack_require_15907__(7400);
var fails = __nested_webpack_require_15907__(4229);
var createElement = __nested_webpack_require_15907__(2635);

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 9337:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_16424__) => {

var fails = __nested_webpack_require_16424__(4229);
var classof = __nested_webpack_require_16424__(7079);

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ 8511:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_17015__) => {

var isCallable = __nested_webpack_require_17015__(6733);
var store = __nested_webpack_require_17015__(5353);

var functionToString = Function.toString;

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 6407:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_17480__) => {

var NATIVE_WEAK_MAP = __nested_webpack_require_17480__(8694);
var global = __nested_webpack_require_17480__(9859);
var isObject = __nested_webpack_require_17480__(5052);
var createNonEnumerableProperty = __nested_webpack_require_17480__(5762);
var objectHas = __nested_webpack_require_17480__(816);
var shared = __nested_webpack_require_17480__(5353);
var sharedKey = __nested_webpack_require_17480__(4399);
var hiddenKeys = __nested_webpack_require_17480__(5977);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 6733:
/***/ ((module) => {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument === 'function';
};


/***/ }),

/***/ 6541:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_19613__) => {

var fails = __nested_webpack_require_19613__(4229);
var isCallable = __nested_webpack_require_19613__(6733);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 5052:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_20311__) => {

var isCallable = __nested_webpack_require_20311__(6733);

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 4231:
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ 9395:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_20621__) => {

var isCallable = __nested_webpack_require_20621__(6733);
var getBuiltIn = __nested_webpack_require_20621__(1333);
var USE_SYMBOL_AS_UID = __nested_webpack_require_20621__(6969);

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && Object(it) instanceof $Symbol;
};


/***/ }),

/***/ 3839:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_21064__) => {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __nested_webpack_require_21064__(6358);
var fails = __nested_webpack_require_21064__(4229);

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 8694:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_21847__) => {

var global = __nested_webpack_require_21847__(9859);
var isCallable = __nested_webpack_require_21847__(6733);
var inspectSource = __nested_webpack_require_21847__(8511);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 1787:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_22188__) => {

var DESCRIPTORS = __nested_webpack_require_22188__(7400);
var IE8_DOM_DEFINE = __nested_webpack_require_22188__(4394);
var anObject = __nested_webpack_require_22188__(1176);
var toPropertyKey = __nested_webpack_require_22188__(9310);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7933:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_23085__) => {

var DESCRIPTORS = __nested_webpack_require_23085__(7400);
var propertyIsEnumerableModule = __nested_webpack_require_23085__(9195);
var createPropertyDescriptor = __nested_webpack_require_23085__(5358);
var toIndexedObject = __nested_webpack_require_23085__(905);
var toPropertyKey = __nested_webpack_require_23085__(9310);
var has = __nested_webpack_require_23085__(816);
var IE8_DOM_DEFINE = __nested_webpack_require_23085__(4394);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ 8151:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_24123__) => {

var internalObjectKeys = __nested_webpack_require_24123__(140);
var enumBugKeys = __nested_webpack_require_24123__(3837);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 894:
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 140:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_24849__) => {

var has = __nested_webpack_require_24849__(816);
var toIndexedObject = __nested_webpack_require_24849__(905);
var indexOf = __nested_webpack_require_24849__(9540).indexOf;
var hiddenKeys = __nested_webpack_require_24849__(5977);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ 5632:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_25482__) => {

var internalObjectKeys = __nested_webpack_require_25482__(140);
var enumBugKeys = __nested_webpack_require_25482__(3837);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 9195:
/***/ ((__unused_webpack_module, exports) => {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 2914:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_26596__) => {

var isCallable = __nested_webpack_require_26596__(6733);
var isObject = __nested_webpack_require_26596__(5052);

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = fn.call(input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 4826:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_27294__) => {

var getBuiltIn = __nested_webpack_require_27294__(1333);
var getOwnPropertyNamesModule = __nested_webpack_require_27294__(8151);
var getOwnPropertySymbolsModule = __nested_webpack_require_27294__(894);
var anObject = __nested_webpack_require_27294__(1176);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 9276:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_27926__) => {

var global = __nested_webpack_require_27926__(9859);

module.exports = global;


/***/ }),

/***/ 7487:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_28086__) => {

var global = __nested_webpack_require_28086__(9859);
var isCallable = __nested_webpack_require_28086__(6733);
var has = __nested_webpack_require_28086__(816);
var createNonEnumerableProperty = __nested_webpack_require_28086__(5762);
var setGlobal = __nested_webpack_require_28086__(2079);
var inspectSource = __nested_webpack_require_28086__(8511);
var InternalStateModule = __nested_webpack_require_28086__(6407);
var CONFIGURABLE_FUNCTION_NAME = __nested_webpack_require_28086__(1805).CONFIGURABLE;

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var name = options && options.name !== undefined ? options.name : key;
  var state;
  if (isCallable(value)) {
    if (String(name).slice(0, 7) === 'Symbol(') {
      name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
    }
    if (!has(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
      createNonEnumerableProperty(value, 'name', name);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ 8885:
/***/ ((module) => {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 2079:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_30300__) => {

var global = __nested_webpack_require_30300__(9859);

module.exports = function (key, value) {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 4399:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_30712__) => {

var shared = __nested_webpack_require_30712__(3036);
var uid = __nested_webpack_require_30712__(1441);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5353:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_30995__) => {

var global = __nested_webpack_require_30995__(9859);
var setGlobal = __nested_webpack_require_30995__(2079);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ 3036:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_31286__) => {

var IS_PURE = __nested_webpack_require_31286__(4231);
var store = __nested_webpack_require_31286__(5353);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.18.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ 3231:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_31715__) => {

var toInteger = __nested_webpack_require_31715__(6051);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 905:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_32238__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __nested_webpack_require_32238__(9337);
var requireObjectCoercible = __nested_webpack_require_32238__(8885);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 6051:
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ 4237:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_32877__) => {

var toInteger = __nested_webpack_require_32877__(6051);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 2991:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_33259__) => {

var requireObjectCoercible = __nested_webpack_require_33259__(8885);

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2066:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_33577__) => {

var isObject = __nested_webpack_require_33577__(5052);
var isSymbol = __nested_webpack_require_33577__(9395);
var getMethod = __nested_webpack_require_33577__(5300);
var ordinaryToPrimitive = __nested_webpack_require_33577__(2914);
var wellKnownSymbol = __nested_webpack_require_33577__(95);

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = exoticToPrim.call(input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 9310:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_34529__) => {

var toPrimitive = __nested_webpack_require_34529__(2066);
var isSymbol = __nested_webpack_require_34529__(9395);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : String(key);
};


/***/ }),

/***/ 1601:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_34926__) => {

var wellKnownSymbol = __nested_webpack_require_34926__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 3326:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_35212__) => {

var classof = __nested_webpack_require_35212__(1589);

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String(argument);
};


/***/ }),

/***/ 9821:
/***/ ((module) => {

module.exports = function (argument) {
  try {
    return String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 1441:
/***/ ((module) => {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ 6969:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_35912__) => {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __nested_webpack_require_35912__(3839);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 95:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_36200__) => {

var global = __nested_webpack_require_36200__(9859);
var shared = __nested_webpack_require_36200__(3036);
var has = __nested_webpack_require_36200__(816);
var uid = __nested_webpack_require_36200__(1441);
var NATIVE_SYMBOL = __nested_webpack_require_36200__(3839);
var USE_SYMBOL_AS_UID = __nested_webpack_require_36200__(6969);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 3430:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_37114__) => {


var $ = __nested_webpack_require_37114__(3103);
var aCallable = __nested_webpack_require_37114__(7111);
var toObject = __nested_webpack_require_37114__(2991);
var toLength = __nested_webpack_require_37114__(4237);
var toString = __nested_webpack_require_37114__(3326);
var fails = __nested_webpack_require_37114__(4229);
var internalSort = __nested_webpack_require_37114__(3867);
var arrayMethodIsStrict = __nested_webpack_require_37114__(6038);
var FF = __nested_webpack_require_37114__(2671);
var IE_OR_EDGE = __nested_webpack_require_37114__(8506);
var V8 = __nested_webpack_require_37114__(6358);
var WEBKIT = __nested_webpack_require_37114__(9811);

var test = [];
var nativeSort = test.sort;

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var STABLE_SORT = !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;

  var result = '';
  var code, chr, value, index;

  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66: case 69: case 70: case 72: value = 3; break;
      case 68: case 71: value = 4; break;
      default: value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({ k: chr + index, v: value });
    }
  }

  test.sort(function (a, b) { return b.v - a.v; });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString(x) > toString(y) ? 1 : -1;
  };
};

// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);

    var array = toObject(this);

    if (STABLE_SORT) return comparefn === undefined ? nativeSort.call(array) : nativeSort.call(array, comparefn);

    var items = [];
    var arrayLength = toLength(array.length);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) items.push(array[index]);
    }

    items = internalSort(items, getSortCompare(comparefn));
    itemsLength = items.length;
    index = 0;

    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) delete array[index++];

    return array;
  }
});


/***/ }),

/***/ 4769:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_40120__) => {

var $ = __nested_webpack_require_40120__(3103);
var toObject = __nested_webpack_require_40120__(2991);
var nativeKeys = __nested_webpack_require_40120__(5632);
var fails = __nested_webpack_require_40120__(4229);

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ 1388:
/***/ ((module, __webpack_exports__, __nested_webpack_require_40644__) => {

/* harmony export */ __nested_webpack_require_40644__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_40644__(272);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_40644__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_40644__(2609);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_40644__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition: background 250ms ease-in-out, transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n", "",{"version":3,"sources":["webpack://./Loader.css"],"names":[],"mappings":"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF","sourcesContent":["/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition: background 250ms ease-in-out, transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 2609:
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var _i = 0; _i < this.length; _i++) {
        var id = this[_i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i2 = 0; _i2 < modules.length; _i2++) {
      var item = [].concat(modules[_i2]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ 272:
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __nested_webpack_require_51441__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_51441__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_51441__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__nested_webpack_require_51441__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__nested_webpack_require_51441__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__nested_webpack_require_51441__.o(definition, key) && !__nested_webpack_require_51441__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__nested_webpack_require_51441__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__nested_webpack_require_51441__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_51441__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXPORTS
__nested_webpack_require_51441__.d(__webpack_exports__, {
  "fWn": () => (/* reexport */ ActionContext),
  "Ia8": () => (/* reexport */ ActionQueue),
  "hLI": () => (/* reexport */ ActionsComponent),
  "yyv": () => (/* reexport */ ActionsSystem),
  "tX5": () => (/* reexport */ ActivateEvent),
  "vtX": () => (/* reexport */ Actor),
  "r7K": () => (/* reexport */ AddedComponent),
  "lCh": () => (/* reexport */ AddedEntity),
  "fwF": () => (/* reexport */ Animation),
  "sce": () => (/* reexport */ AnimationDirection),
  "_c7": () => (/* reexport */ AnimationStrategy),
  "KUs": () => (/* reexport */ ArcadeSolver),
  "Ajp": () => (/* reexport */ AudioContextFactory),
  "RDh": () => (/* reexport */ Axis),
  "_H9": () => (/* reexport */ BaseAlign),
  "Ulf": () => (/* reexport */ BinaryTreeNode),
  "mxs": () => (/* reexport */ Blink),
  "OmD": () => (/* reexport */ BodyComponent),
  "kBf": () => (/* reexport */ BoundingBox),
  "C4F": () => (/* reexport */ BroadphaseStrategy),
  "NQt": () => (/* reexport */ BrowserComponent),
  "JjN": () => (/* reexport */ BrowserEvents),
  "V1s": () => (/* reexport */ Camera),
  "Xz7": () => (/* reexport */ Canvas),
  "bLd": () => (/* reexport */ Cell),
  "Cdc": () => (/* reexport */ Circle),
  "FKn": () => (/* reexport */ CircleCollider),
  "wTW": () => (/* reexport */ Class),
  "ab2": () => (/* reexport */ ClosestLine),
  "GfZ": () => (/* reexport */ ClosestLineJumpTable),
  "YMS": () => (/* reexport */ Collider),
  "oyv": () => (/* reexport */ ColliderComponent),
  "aUb": () => (/* reexport */ CollisionContact),
  "SdD": () => (/* reexport */ CollisionEndEvent),
  "JUv": () => (/* reexport */ CollisionGroup),
  "jEj": () => (/* reexport */ CollisionGroupManager),
  "TFq": () => (/* reexport */ CollisionJumpTable),
  "HDU": () => (/* reexport */ CollisionPostSolveEvent),
  "R_y": () => (/* reexport */ CollisionPreSolveEvent),
  "ydN": () => (/* reexport */ CollisionResolutionStrategy),
  "_N2": () => (/* reexport */ CollisionSolver),
  "t50": () => (/* reexport */ CollisionStartEvent),
  "s$$": () => (/* reexport */ CollisionSystem),
  "v2G": () => (/* reexport */ CollisionType),
  "Ilk": () => (/* reexport */ Color),
  "H_9": () => (/* reexport */ ColorBlindCorrector),
  "s9i": () => (/* reexport */ ColorBlindFlags),
  "ksl": () => (/* reexport */ ColorBlindness),
  "wA2": () => (/* reexport */ Component),
  "R_p": () => (/* reexport */ CompositeCollider),
  "IQ$": () => (/* reexport */ Configurable),
  "I5F": () => (/* reexport */ ConsoleAppender),
  "X8$": () => (/* reexport */ ContactConstraintPoint),
  "FR6": () => (/* reexport */ ContactEndEvent),
  "U8o": () => (/* reexport */ ContactStartEvent),
  "kbG": () => (/* reexport */ CoordPlane),
  "oeJ": () => (/* reexport */ CullingBox),
  "iS_": () => (/* reexport */ DeactivateEvent),
  "cGG": () => (/* reexport */ Debug),
  "skb": () => (/* reexport */ DebugSystem),
  "SLU": () => (/* reexport */ DebugText),
  "RdJ": () => (/* reexport */ DegreeOfFreedom),
  "gU7": () => (/* reexport */ Detector),
  "LSk": () => (/* reexport */ Die),
  "Nmp": () => (/* reexport */ Direction),
  "d1Y": () => (/* reexport */ DisplayMode),
  "xrL": () => (/* reexport */ DynamicTree),
  "sRW": () => (/* reexport */ DynamicTreeCollisionProcessor),
  "cmV": () => (/* binding */ EX_VERSION),
  "N0Q": () => (/* reexport */ EaseTo),
  "q8b": () => (/* reexport */ EasingFunctions),
  "ynB": () => (/* reexport */ EdgeCollider),
  "jT9": () => (/* reexport */ ElasticToActorStrategy),
  "wAz": () => (/* reexport */ EmitterType),
  "D4V": () => (/* reexport */ Engine),
  "N6H": () => (/* reexport */ EnterTriggerEvent),
  "W1A": () => (/* reexport */ EnterViewPortEvent),
  "JHW": () => (/* reexport */ Entity),
  "v2K": () => (/* reexport */ EntityManager),
  "pBf": () => (/* reexport */ EventDispatcher),
  "GMl": () => (/* reexport */ EventTypes),
  "zW2": () => (/* reexport */ Events_namespaceObject),
  "B0K": () => (/* reexport */ ExResponse),
  "Nv7": () => (/* reexport */ ExcaliburGraphicsContext2DCanvas),
  "C_p": () => (/* reexport */ ExcaliburGraphicsContextWebGL),
  "MUA": () => (/* reexport */ ExitTriggerEvent),
  "xqU": () => (/* reexport */ ExitViewPortEvent),
  "peG": () => (/* reexport */ Experiments),
  "pTp": () => (/* reexport */ Fade),
  "vUK": () => (/* reexport */ Flags),
  "j9l": () => (/* reexport */ Follow),
  "Zxw": () => (/* reexport */ Font),
  "Hdx": () => (/* reexport */ FontStyle),
  "Z$d": () => (/* reexport */ FontUnit),
  "o$7": () => (/* reexport */ FrameStats),
  "Zm$": () => (/* reexport */ GameEvent),
  "$QH": () => (/* reexport */ GameStartEvent),
  "i78": () => (/* reexport */ GameStopEvent),
  "h6u": () => (/* reexport */ GamepadAxisEvent),
  "hts": () => (/* reexport */ GamepadButtonEvent),
  "j88": () => (/* reexport */ GamepadConnectEvent),
  "VME": () => (/* reexport */ GamepadDisconnectEvent),
  "nt": () => (/* reexport */ Gif),
  "Ukr": () => (/* reexport */ GlobalCoordinates),
  "zsu": () => (/* reexport */ Graphic),
  "oA6": () => (/* reexport */ GraphicsComponent),
  "TVh": () => (/* reexport */ GraphicsGroup),
  "TwZ": () => (/* reexport */ GraphicsLayer),
  "GTT": () => (/* reexport */ GraphicsLayers),
  "xxj": () => (/* reexport */ GraphicsSystem),
  "XdK": () => (/* reexport */ HiddenEvent),
  "cXo": () => (/* reexport */ ImageSource),
  "Dm5": () => (/* reexport */ InitializeEvent),
  "IIB": () => (/* reexport */ Input_Index_namespaceObject),
  "zI0": () => (/* reexport */ Integrator),
  "SKZ": () => (/* reexport */ KillEvent),
  "__J": () => (/* reexport */ Label_Label),
  "Dvr": () => (/* reexport */ Legacy),
  "Tf9": () => (/* reexport */ Drawing_Index_namespaceObject),
  "RI$": () => (/* reexport */ LimitCameraBoundsStrategy),
  "x12": () => (/* reexport */ Line),
  "aNw": () => (/* reexport */ Loader),
  "xwn": () => (/* reexport */ LockCameraToActorAxisStrategy),
  "dNK": () => (/* reexport */ LockCameraToActorStrategy),
  "ini": () => (/* reexport */ LogLevel),
  "YdH": () => (/* reexport */ Logger),
  "y3G": () => (/* reexport */ Matrix),
  "l57": () => (/* reexport */ MatrixLocations),
  "xn0": () => (/* reexport */ MediaEvent),
  "t2V": () => (/* reexport */ Meet),
  "ZyS": () => (/* reexport */ MockedElement),
  "uxB": () => (/* reexport */ MotionComponent),
  "cpd": () => (/* reexport */ MotionSystem),
  "fiy": () => (/* reexport */ MoveBy),
  "$XZ": () => (/* reexport */ MoveTo),
  "uqK": () => (/* reexport */ NativeSoundEvent),
  "STE": () => (/* reexport */ NativeSoundProcessedEvent),
  "y$z": () => (/* reexport */ Observable),
  "sOq": () => (/* reexport */ Pair),
  "Sqs": () => (/* reexport */ ParseGif),
  "hpZ": () => (/* reexport */ Particle),
  "Vol": () => (/* reexport */ ParticleEmitter),
  "wIZ": () => (/* reexport */ Physics),
  "cBi": () => (/* reexport */ PhysicsStats),
  "mgq": () => (/* reexport */ Polygon_Polygon),
  "YVA": () => (/* reexport */ PolygonCollider),
  "Kgp": () => (/* reexport */ Pool),
  "HH$": () => (/* reexport */ PostCollisionEvent),
  "M_d": () => (/* reexport */ PostDebugDrawEvent),
  "rgh": () => (/* reexport */ PostDrawEvent),
  "Ra6": () => (/* reexport */ PostFrameEvent),
  "KhR": () => (/* reexport */ PostKillEvent),
  "BS5": () => (/* reexport */ PostUpdateEvent),
  "xhz": () => (/* reexport */ PreCollisionEvent),
  "xOq": () => (/* reexport */ PreDebugDrawEvent),
  "a9j": () => (/* reexport */ PreDrawEvent),
  "bHk": () => (/* reexport */ PreFrameEvent),
  "CgK": () => (/* reexport */ PreKillEvent),
  "cuY": () => (/* reexport */ PreUpdateEvent),
  "kvE": () => (/* reexport */ Projection),
  "JDb": () => (/* reexport */ Promises_Promise),
  "Cbi": () => (/* reexport */ PromiseState),
  "AE_": () => (/* reexport */ Query),
  "ctO": () => (/* reexport */ QueryManager),
  "OLH": () => (/* reexport */ RadiusAroundActorStrategy),
  "kky": () => (/* reexport */ Random),
  "nSF": () => (/* reexport */ Raster),
  "zHn": () => (/* reexport */ Ray),
  "zwx": () => (/* reexport */ RealisticSolver),
  "AeJ": () => (/* reexport */ Rectangle),
  "hLz": () => (/* reexport */ RemovedComponent),
  "D9g": () => (/* reexport */ RemovedEntity),
  "wA": () => (/* reexport */ Repeat),
  "jhr": () => (/* reexport */ RepeatForever),
  "GVs": () => (/* reexport */ Resolution),
  "_zO": () => (/* reexport */ Resource),
  "w6$": () => (/* reexport */ RotateBy),
  "mhV": () => (/* reexport */ RotateTo),
  "MOD": () => (/* reexport */ RotationType),
  "kwd": () => (/* reexport */ ScaleBy),
  "Lmr": () => (/* reexport */ ScaleTo),
  "xsS": () => (/* reexport */ Scene),
  "lLr": () => (/* reexport */ Screen),
  "Z$r": () => (/* reexport */ ScreenAppender),
  "IXb": () => (/* reexport */ ScreenElement_ScreenElement),
  "SMj": () => (/* reexport */ ScrollPreventionMode),
  "bnF": () => (/* reexport */ Shape),
  "MFA": () => (/* reexport */ Side),
  "$XC": () => (/* reexport */ SortedList),
  "$uU": () => (/* reexport */ Sound),
  "jyi": () => (/* reexport */ Sprite),
  "E03": () => (/* reexport */ SpriteFont_SpriteFont),
  "V6q": () => (/* reexport */ SpriteSheet),
  "nVo": () => (/* reexport */ StrategyContainer),
  "F6N": () => (/* reexport */ Stream),
  "ad3": () => (/* reexport */ SubscribeEvent),
  "xP7": () => (/* reexport */ System),
  "Odq": () => (/* reexport */ SystemManager),
  "Zif": () => (/* reexport */ SystemType),
  "ZGJ": () => (/* reexport */ TagComponent),
  "xvT": () => (/* reexport */ Text),
  "PHM": () => (/* reexport */ TextAlign),
  "KwO": () => (/* reexport */ TileMap),
  "B7y": () => (/* reexport */ Timer),
  "SFp": () => (/* reexport */ Traits_Index_namespaceObject),
  "Uvn": () => (/* reexport */ TransformComponent),
  "OFT": () => (/* reexport */ TreeNode),
  "xzN": () => (/* reexport */ Trigger_Trigger),
  "H6j": () => (/* reexport */ UnsubscribeEvent),
  "ZrN": () => (/* reexport */ Util_Index_namespaceObject),
  "OWs": () => (/* reexport */ Vector),
  "dF9": () => (/* reexport */ VectorView),
  "VHo": () => (/* reexport */ VisibleEvent),
  "R$E": () => (/* reexport */ WebAudioInstance),
  "q3I": () => (/* reexport */ World),
  "Pab": () => (/* reexport */ canonicalizeAngle),
  "uZ5": () => (/* reexport */ clamp),
  "McK": () => (/* reexport */ createId),
  "k0b": () => (/* reexport */ hasGraphicsTick),
  "hnT": () => (/* reexport */ hasOnInitialize),
  "RSJ": () => (/* reexport */ hasOnPostUpdate),
  "Mku": () => (/* reexport */ hasOnPreUpdate),
  "h90": () => (/* reexport */ hasPostDraw),
  "rms": () => (/* reexport */ hasPreDraw),
  "ErP": () => (/* reexport */ has_initialize),
  "aVg": () => (/* reexport */ has_postupdate),
  "lPc": () => (/* reexport */ has_preupdate),
  "Z8E": () => (/* reexport */ isAddedComponent),
  "NNA": () => (/* reexport */ isAddedSystemEntity),
  "yFn": () => (/* reexport */ isRemoveSystemEntity),
  "lNv": () => (/* reexport */ isRemovedComponent),
  "MZQ": () => (/* reexport */ maxMessages),
  "FUM": () => (/* reexport */ obsolete),
  "vdf": () => (/* reexport */ randomInRange),
  "iaL": () => (/* reexport */ randomIntInRange),
  "w6H": () => (/* reexport */ range),
  "Q4c": () => (/* reexport */ resetObsoleteCounter),
  "Uxb": () => (/* reexport */ toDegrees),
  "Yr5": () => (/* reexport */ toRadians),
  "Bhw": () => (/* reexport */ vec)
});

// NAMESPACE OBJECT: ./Events.ts
var Events_namespaceObject = {};
__nested_webpack_require_51441__.r(Events_namespaceObject);
__nested_webpack_require_51441__.d(Events_namespaceObject, {
  "ActivateEvent": () => (ActivateEvent),
  "CollisionEndEvent": () => (CollisionEndEvent),
  "CollisionPostSolveEvent": () => (CollisionPostSolveEvent),
  "CollisionPreSolveEvent": () => (CollisionPreSolveEvent),
  "CollisionStartEvent": () => (CollisionStartEvent),
  "ContactEndEvent": () => (ContactEndEvent),
  "ContactStartEvent": () => (ContactStartEvent),
  "DeactivateEvent": () => (DeactivateEvent),
  "EnterTriggerEvent": () => (EnterTriggerEvent),
  "EnterViewPortEvent": () => (EnterViewPortEvent),
  "EventTypes": () => (EventTypes),
  "ExitTriggerEvent": () => (ExitTriggerEvent),
  "ExitViewPortEvent": () => (ExitViewPortEvent),
  "GameEvent": () => (GameEvent),
  "GameStartEvent": () => (GameStartEvent),
  "GameStopEvent": () => (GameStopEvent),
  "GamepadAxisEvent": () => (GamepadAxisEvent),
  "GamepadButtonEvent": () => (GamepadButtonEvent),
  "GamepadConnectEvent": () => (GamepadConnectEvent),
  "GamepadDisconnectEvent": () => (GamepadDisconnectEvent),
  "HiddenEvent": () => (HiddenEvent),
  "InitializeEvent": () => (InitializeEvent),
  "KillEvent": () => (KillEvent),
  "PostCollisionEvent": () => (PostCollisionEvent),
  "PostDebugDrawEvent": () => (PostDebugDrawEvent),
  "PostDrawEvent": () => (PostDrawEvent),
  "PostFrameEvent": () => (PostFrameEvent),
  "PostKillEvent": () => (PostKillEvent),
  "PostUpdateEvent": () => (PostUpdateEvent),
  "PreCollisionEvent": () => (PreCollisionEvent),
  "PreDebugDrawEvent": () => (PreDebugDrawEvent),
  "PreDrawEvent": () => (PreDrawEvent),
  "PreFrameEvent": () => (PreFrameEvent),
  "PreKillEvent": () => (PreKillEvent),
  "PreUpdateEvent": () => (PreUpdateEvent),
  "SubscribeEvent": () => (SubscribeEvent),
  "UnsubscribeEvent": () => (UnsubscribeEvent),
  "VisibleEvent": () => (VisibleEvent)
});

// NAMESPACE OBJECT: ./Drawing/SpriteEffects.ts
var SpriteEffects_namespaceObject = {};
__nested_webpack_require_51441__.r(SpriteEffects_namespaceObject);
__nested_webpack_require_51441__.d(SpriteEffects_namespaceObject, {
  "Colorize": () => (Colorize),
  "Darken": () => (Darken),
  "Desaturate": () => (Desaturate),
  "Fill": () => (Fill),
  "Grayscale": () => (Grayscale),
  "Invert": () => (Invert),
  "Lighten": () => (Lighten),
  "Opacity": () => (Opacity),
  "Saturate": () => (Saturate)
});

// NAMESPACE OBJECT: ./Util/DrawUtil.ts
var DrawUtil_namespaceObject = {};
__nested_webpack_require_51441__.r(DrawUtil_namespaceObject);
__nested_webpack_require_51441__.d(DrawUtil_namespaceObject, {
  "circle": () => (circle),
  "line": () => (line),
  "point": () => (point),
  "roundRect": () => (roundRect),
  "vector": () => (vector)
});

// NAMESPACE OBJECT: ./Drawing/Index.ts
var Drawing_Index_namespaceObject = {};
__nested_webpack_require_51441__.r(Drawing_Index_namespaceObject);
__nested_webpack_require_51441__.d(Drawing_Index_namespaceObject, {
  "Animation": () => (Animation_Animation),
  "CanvasDrawComponent": () => (CanvasDrawComponent),
  "CanvasDrawingSystem": () => (CanvasDrawingSystem),
  "Effects": () => (SpriteEffects_namespaceObject),
  "Polygon": () => (Polygon),
  "Sprite": () => (Sprite_Sprite),
  "SpriteFont": () => (SpriteFont),
  "SpriteSheet": () => (SpriteSheet_SpriteSheet),
  "Texture": () => (Texture)
});

// NAMESPACE OBJECT: ./Input/Index.ts
var Input_Index_namespaceObject = {};
__nested_webpack_require_51441__.r(Input_Index_namespaceObject);
__nested_webpack_require_51441__.d(Input_Index_namespaceObject, {
  "Axes": () => (Axes),
  "Buttons": () => (Buttons),
  "Gamepad": () => (Gamepad),
  "Gamepads": () => (Gamepads),
  "KeyEvent": () => (KeyEvent),
  "Keyboard": () => (Keyboard),
  "Keys": () => (Keys),
  "NativePointerButton": () => (NativePointerButton),
  "Pointer": () => (Pointer),
  "PointerButton": () => (PointerButton),
  "PointerCancelEvent": () => (PointerCancelEvent),
  "PointerDownEvent": () => (PointerDownEvent),
  "PointerDragEvent": () => (PointerDragEvent),
  "PointerEnterEvent": () => (PointerEnterEvent),
  "PointerEvent": () => (PointerEvent),
  "PointerEventFactory": () => (PointerEventFactory),
  "PointerLeaveEvent": () => (PointerLeaveEvent),
  "PointerMoveEvent": () => (PointerMoveEvent),
  "PointerScope": () => (PointerScope),
  "PointerType": () => (PointerType),
  "PointerUpEvent": () => (PointerUpEvent),
  "Pointers": () => (Pointers),
  "WheelDeltaMode": () => (WheelDeltaMode),
  "WheelEvent": () => (WheelEvent),
  "createPointerEventByName": () => (createPointerEventByName)
});

// NAMESPACE OBJECT: ./Traits/Index.ts
var Traits_Index_namespaceObject = {};
__nested_webpack_require_51441__.r(Traits_Index_namespaceObject);
__nested_webpack_require_51441__.d(Traits_Index_namespaceObject, {
  "CapturePointer": () => (CapturePointer),
  "OffscreenCulling": () => (OffscreenCulling)
});

// NAMESPACE OBJECT: ./Util/Index.ts
var Util_Index_namespaceObject = {};
__nested_webpack_require_51441__.r(Util_Index_namespaceObject);
__nested_webpack_require_51441__.d(Util_Index_namespaceObject, {
  "Collection": () => (Collection),
  "ConsoleAppender": () => (ConsoleAppender),
  "DrawUtil": () => (DrawUtil_namespaceObject),
  "EasingFunctions": () => (EasingFunctions),
  "LogLevel": () => (LogLevel),
  "Logger": () => (Logger),
  "Observable": () => (Observable),
  "ScreenAppender": () => (ScreenAppender),
  "TwoPI": () => (TwoPI),
  "addItemToArray": () => (addItemToArray),
  "base64Encode": () => (base64Encode),
  "canonicalizeAngle": () => (canonicalizeAngle),
  "clamp": () => (clamp),
  "contains": () => (contains),
  "delay": () => (delay),
  "extend": () => (extend),
  "fail": () => (fail),
  "getOppositeSide": () => (getOppositeSide),
  "getPosition": () => (getPosition),
  "getSideFromDirection": () => (getSideFromDirection),
  "nullish": () => (nullish),
  "randomInRange": () => (randomInRange),
  "randomIntInRange": () => (randomIntInRange),
  "range": () => (range),
  "removeItemFromArray": () => (removeItemFromArray),
  "toDegrees": () => (toDegrees),
  "toRadians": () => (toRadians)
});

// EXTERNAL MODULE: ../../node_modules/core-js/es/array/sort.js
var sort = __nested_webpack_require_51441__(4662);
// EXTERNAL MODULE: ../../node_modules/core-js/es/object/keys.js
var keys = __nested_webpack_require_51441__(8343);
;// CONCATENATED MODULE: ./Polyfill.ts


/**
 * Polyfill adding function
 */
function polyfill() {
    /* istanbul ignore next */
    if (typeof window === 'undefined') {
        window = {
            audioContext: function () {
                return;
            }
        };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.requestAnimationFrame) {
        window.requestAnimationFrame =
            window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setInterval(callback, 1000 / 60);
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {
        window.cancelAnimationFrame =
            window.webkitCancelAnimationFrame ||
                window.mozCancelAnimationFrame ||
                function () {
                    return;
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.AudioContext) {
        if (window.webkitAudioContext) {
            const ctx = window.webkitAudioContext;
            const replaceMe = ctx.prototype.decodeAudioData;
            window.webkitAudioContext.prototype.decodeAudioData = function (arrayBuffer) {
                return new Promise((resolve, reject) => {
                    replaceMe.call(this, arrayBuffer, resolve, reject);
                });
            };
        }
        window.AudioContext =
            window.AudioContext ||
                window.webkitAudioContext ||
                window.mozAudioContext ||
                window.msAudioContext ||
                window.oAudioContext;
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.devicePixelRatio) {
        window.devicePixelRatio = window.devicePixelRatio || 1;
    }
}

;// CONCATENATED MODULE: ./Flags.ts
/**
 * Features in preview
 */
var Experiments;
(function (Experiments) {
    Experiments["WebGL"] = "use-webgl";
})(Experiments || (Experiments = {}));
/**
 * Legacy features that will go away
 */
var Legacy;
(function (Legacy) {
    Legacy["Canvas"] = "use-canvas-context";
    Legacy["LegacyDrawing"] = "use-legacy-drawing";
})(Legacy || (Legacy = {}));
/**
 * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**
 * after which they are frozen and are read-only.
 *
 * Flags are used to enable experimental or preview features in Excalibur.
 */
class Flags {
    /**
     * Freeze all flag modifications making them readonly
     */
    static freeze() {
        Flags._FROZEN = true;
    }
    /**
     * Resets internal flag state, not meant to be called by users. Only used for testing.
     *
     * Calling this in your game is UNSUPPORTED
     * @internal
     */
    static _reset() {
        Flags._FROZEN = false;
        Flags._FLAGS = {};
    }
    /**
     * Turn on webgl support
     */
    static useWebGL() {
        Flags.enable(Experiments.WebGL);
    }
    static useCanvasGraphicsContext() {
        Flags.enable(Legacy.Canvas);
    }
    /**
     * @deprecated Recommended not to use legacy drawing, going away in v0.26.0
     */
    static useLegacyDrawing() {
        Flags.enable(Legacy.LegacyDrawing);
    }
    /**
     * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static enable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be enabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = true;
    }
    /**
     * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static disable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be disabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = false;
    }
    /**
     * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned
     * @param flagName
     */
    static isEnabled(flagName) {
        return !!Flags._FLAGS[flagName];
    }
    /**
     * Show a list of currently known flags
     */
    static show() {
        return Object.keys(Flags._FLAGS);
    }
}
Flags._FROZEN = false;
Flags._FLAGS = {};

;// CONCATENATED MODULE: ./Id.ts
/**
 *
 */
function createId(type, value) {
    return { type, value };
}
;

;// CONCATENATED MODULE: ./Util/Log.ts
/* eslint-disable no-console */
/**
 * Logging level that Excalibur will tag
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
})(LogLevel || (LogLevel = {}));
/**
 * Static singleton that represents the logging facility for Excalibur.
 * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].
 * Derive from [[Appender]] to create your own logging appenders.
 */
class Logger {
    constructor() {
        this._appenders = [];
        /**
         * Gets or sets the default logging level. Excalibur will only log
         * messages if equal to or above this level. Default: [[LogLevel.Info]]
         */
        this.defaultLevel = LogLevel.Info;
        if (Logger._INSTANCE) {
            throw new Error('Logger is a singleton');
        }
        Logger._INSTANCE = this;
        // Default console appender
        Logger._INSTANCE.addAppender(new ConsoleAppender());
        return Logger._INSTANCE;
    }
    /**
     * Gets the current static instance of Logger
     */
    static getInstance() {
        if (Logger._INSTANCE == null) {
            Logger._INSTANCE = new Logger();
        }
        return Logger._INSTANCE;
    }
    /**
     * Adds a new [[Appender]] to the list of appenders to write to
     */
    addAppender(appender) {
        this._appenders.push(appender);
    }
    /**
     * Clears all appenders from the logger
     */
    clearAppenders() {
        this._appenders.length = 0;
    }
    /**
     * Logs a message at a given LogLevel
     * @param level  The LogLevel`to log the message at
     * @param args   An array of arguments to write to an appender
     */
    _log(level, args) {
        if (level == null) {
            level = this.defaultLevel;
        }
        const len = this._appenders.length;
        for (let i = 0; i < len; i++) {
            if (level >= this.defaultLevel) {
                this._appenders[i].log(level, args);
            }
        }
    }
    /**
     * Writes a log message at the [[LogLevel.Debug]] level
     * @param args  Accepts any number of arguments
     */
    debug(...args) {
        this._log(LogLevel.Debug, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Info]] level
     * @param args  Accepts any number of arguments
     */
    info(...args) {
        this._log(LogLevel.Info, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Warn]] level
     * @param args  Accepts any number of arguments
     */
    warn(...args) {
        this._log(LogLevel.Warn, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Error]] level
     * @param args  Accepts any number of arguments
     */
    error(...args) {
        this._log(LogLevel.Error, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Fatal]] level
     * @param args  Accepts any number of arguments
     */
    fatal(...args) {
        this._log(LogLevel.Fatal, args);
    }
}
Logger._INSTANCE = null;
/**
 * Console appender for browsers (i.e. `console.log`)
 */
class ConsoleAppender {
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        // Check for console support
        if (!console && !console.log && console.warn && console.error) {
            // todo maybe do something better than nothing
            return;
        }
        // Create a new console args array
        const consoleArgs = [];
        consoleArgs.unshift.apply(consoleArgs, args);
        consoleArgs.unshift('[' + LogLevel[level] + '] : ');
        if (level < LogLevel.Warn) {
            // Call .log for Debug/Info
            if (console.log.apply) {
                // this is required on some older browsers that don't support apply on console.log :(
                console.log.apply(console, consoleArgs);
            }
            else {
                console.log(consoleArgs.join(' '));
            }
        }
        else if (level < LogLevel.Error) {
            // Call .warn for Warn
            if (console.warn.apply) {
                console.warn.apply(console, consoleArgs);
            }
            else {
                console.warn(consoleArgs.join(' '));
            }
        }
        else {
            // Call .error for Error/Fatal
            if (console.error.apply) {
                console.error.apply(console, consoleArgs);
            }
            else {
                console.error(consoleArgs.join(' '));
            }
        }
    }
}
/**
 * On-screen (canvas) appender
 */
class ScreenAppender {
    /**
     * @param width   Width of the screen appender in pixels
     * @param height  Height of the screen appender in pixels
     */
    constructor(width, height) {
        // @todo Clean this up
        this._messages = [];
        this._canvas = document.createElement('canvas');
        this._canvas.width = width || window.innerWidth;
        this._canvas.height = height || window.innerHeight;
        this._canvas.style.position = 'absolute';
        // eslint-disable-next-line
        this._ctx = this._canvas.getContext('2d'); // eslint-disable-line
        document.body.appendChild(this._canvas);
    }
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        const message = args.join(',');
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
        let pos = 10;
        let opacity = 1.0;
        for (let i = 0; i < this._messages.length; i++) {
            this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
            this._ctx.fillText(this._messages[i], 200, pos);
            pos += 10;
            opacity = opacity > 0 ? opacity - 0.05 : 0;
        }
    }
}

;// CONCATENATED MODULE: ./Math/Random.ts
/**
 * @module
 * Pseudo-Random Utility
 *
 * A pseudo-random utility to add seeded random support for help in
 * generating things like terrain or reproducible randomness. Uses the
 * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.
 */
/**
 * 32-bit mask
 */
const BITMASK32 = 0xffffffff;
/**
 * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence
 * of numbers each time it is called.
 * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.
 * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
 *
 * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs
 */
class Random {
    /**
     * If no seed is specified, the Date.now() is used
     */
    constructor(seed) {
        this.seed = seed;
        // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1
        this._lowerMask = 0x7fffffff; // 31 bits same as _r
        this._upperMask = 0x80000000; // 34 high bits
        // Word size, 64 bits
        this._w = 32;
        // Degree of recurrence
        this._n = 624;
        // Middle word, an offset used in the recurrence defining the series x, 1<=m<n
        this._m = 397;
        // coefficients of teh rational normal form twist matrix
        this._a = 0x9908b0df;
        // tempering bit shifts and masks
        this._u = 11;
        this._s = 7;
        this._b = 0x9d2c5680;
        this._t = 15;
        this._c = 0xefc60000;
        this._l = 18;
        this._f = 1812433253;
        this._mt = new Array(this._n);
        // need to mask to support higher bit machines
        this._mt[0] = (seed || Date.now()) >>> 0;
        for (let i = 1; i < this._n; i++) {
            const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));
            // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits
            this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;
        }
        this._index = this._n;
    }
    /**
     * Apply the twist
     */
    _twist() {
        const mag01 = [0x0, this._a];
        let y = 0, i = 0;
        for (; i < this._n - this._m; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        for (; i < this._n - 1; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);
        this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        this._index = 0;
    }
    /**
     * Return next 32 bit integer number in sequence
     */
    nextInt() {
        if (this._index >= this._n) {
            this._twist();
        }
        let y = this._mt[this._index++];
        y ^= y >>> this._u;
        y ^= (y << this._s) & this._b;
        y ^= (y << this._t) & this._c;
        y ^= y >>> this._l;
        return y >>> 0;
    }
    /**
     * Return a random floating point number between [0, 1)
     */
    next() {
        return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32
    }
    /**
     * Return a random floating point in range [min, max) min is included, max is not included
     */
    floating(min, max) {
        return (max - min) * this.next() + min;
    }
    /**
     * Return a random integer in range [min, max] min is included, max is included.
     * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
     */
    integer(min, max) {
        return Math.floor((max - min + 1) * this.next() + min);
    }
    /**
     * Returns true or false randomly with 50/50 odds by default.
     * By default the likelihood of returning a true is .5 (50%).
     * @param likelihood takes values between [0, 1]
     */
    bool(likelihood = 0.5) {
        return this.next() <= likelihood;
    }
    /**
     * Returns one element from an array at random
     */
    pickOne(array) {
        return array[this.integer(0, array.length - 1)];
    }
    /**
     * Returns a new array random picking elements from the original
     * @param array Original array to pick from
     * @param numPicks can be any positive number
     * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
     * just that it is possible)
     */
    pickSet(array, numPicks, allowDuplicates = false) {
        if (allowDuplicates) {
            return this._pickSetWithDuplicates(array, numPicks);
        }
        else {
            return this._pickSetWithoutDuplicates(array, numPicks);
        }
    }
    /**
     * Returns a new array randomly picking elements in the original (not reused)
     * @param array Array to pick elements out of
     * @param numPicks must be less than or equal to the number of elements in the array.
     */
    _pickSetWithoutDuplicates(array, numPicks) {
        if (numPicks > array.length || numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');
        }
        if (numPicks === array.length) {
            return array;
        }
        const result = new Array(numPicks);
        let currentPick = 0;
        const tempArray = array.slice(0);
        while (currentPick < numPicks) {
            const index = this.integer(0, tempArray.length - 1);
            result[currentPick++] = tempArray[index];
            tempArray.splice(index, 1);
        }
        return result;
    }
    /**
     * Returns a new array random picking elements from the original allowing duplicates
     * @param array Array to pick elements out of
     * @param numPicks can be any positive number
     */
    _pickSetWithDuplicates(array, numPicks) {
        // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)
        if (numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');
        }
        const result = new Array(numPicks);
        for (let i = 0; i < numPicks; i++) {
            result[i] = this.pickOne(array);
        }
        return result;
    }
    /**
     * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
     * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    shuffle(array) {
        const tempArray = array.slice(0);
        let swap = null;
        for (let i = 0; i < tempArray.length - 2; i++) {
            const randomIndex = this.integer(i, tempArray.length - 1);
            swap = tempArray[i];
            tempArray[i] = tempArray[randomIndex];
            tempArray[randomIndex] = swap;
        }
        return tempArray;
    }
    /**
     * Generate a list of random integer numbers
     * @param length the length of the final array
     * @param min the minimum integer number to generate inclusive
     * @param max the maximum integer number to generate inclusive
     */
    range(length, min, max) {
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.integer(min, max);
        }
        return result;
    }
    /**
     * Returns the result of a d4 dice roll
     */
    d4() {
        return this.integer(1, 4);
    }
    /**
     * Returns the result of a d6 dice roll
     */
    d6() {
        return this.integer(1, 6);
    }
    /**
     * Returns the result of a d8 dice roll
     */
    d8() {
        return this.integer(1, 8);
    }
    /**
     * Returns the result of a d10 dice roll
     */
    d10() {
        return this.integer(1, 10);
    }
    /**
     * Returns the result of a d12 dice roll
     */
    d12() {
        return this.integer(1, 12);
    }
    /**
     * Returns the result of a d20 dice roll
     */
    d20() {
        return this.integer(1, 20);
    }
}

;// CONCATENATED MODULE: ./Collision/Side.ts

/**
 * An enum that describes the sides of an axis aligned box for collision
 */
var Side;
(function (Side) {
    Side["None"] = "None";
    Side["Top"] = "Top";
    Side["Bottom"] = "Bottom";
    Side["Left"] = "Left";
    Side["Right"] = "Right";
})(Side || (Side = {}));
(function (Side) {
    /**
     * Returns the opposite side from the current
     */
    function getOpposite(side) {
        if (side === Side.Top) {
            return Side.Bottom;
        }
        if (side === Side.Bottom) {
            return Side.Top;
        }
        if (side === Side.Left) {
            return Side.Right;
        }
        if (side === Side.Right) {
            return Side.Left;
        }
        return Side.None;
    }
    Side.getOpposite = getOpposite;
    /**
     * Given a vector, return the Side most in that direction (via dot product)
     */
    function fromDirection(direction) {
        const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];
        const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];
        let max = -Number.MAX_VALUE;
        let maxIndex = -1;
        for (let i = 0; i < directions.length; i++) {
            if (directions[i].dot(direction) > max) {
                max = directions[i].dot(direction);
                maxIndex = i;
            }
        }
        return directionEnum[maxIndex];
    }
    Side.fromDirection = fromDirection;
})(Side || (Side = {}));

;// CONCATENATED MODULE: ./Util/Util.ts



/**
 * Two PI constant
 */
const TwoPI = Math.PI * 2;
/**
 * Merges one or more objects into a single target object
 *
 * @returns Merged object with properties from other objects
 * @credit https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
 */
function extend() {
    const extended = {};
    let deep = false;
    let i = 0;
    const length = arguments.length;
    // Check if a deep merge
    if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
        deep = arguments[0];
        i++;
    }
    // Merge the object into the extended object
    const assignExists = typeof Object.assign === 'function';
    let merge = null;
    if (!assignExists) {
        merge = function (obj) {
            for (const prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    // If deep merge and property is an object, merge properties
                    if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                        extended[prop] = extend(true, extended[prop], obj[prop]);
                    }
                    else {
                        extended[prop] = obj[prop];
                    }
                }
            }
        };
    }
    else {
        merge = Object.assign;
    }
    // Loop through each object and conduct a merge
    for (; i < length; i++) {
        const obj = arguments[i];
        if (!assignExists) {
            merge(obj);
        }
        else {
            merge(extended, obj);
        }
    }
    return extended;
}
/**
 * Encode a string in base64
 * @deprecated This will be removed in v0.26.0
 */
function base64Encode(inputStr) {
    const b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    let outputStr = '';
    let i = 0;
    while (i < inputStr.length) {
        //all three "& 0xff" added below are there to fix a known bug
        //with bytes returned by xhr.responseText
        const byte1 = inputStr.charCodeAt(i++) & 0xff;
        const byte2 = inputStr.charCodeAt(i++) & 0xff;
        const byte3 = inputStr.charCodeAt(i++) & 0xff;
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        let enc3, enc4;
        if (isNaN(byte2)) {
            enc3 = enc4 = 64;
        }
        else {
            enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
            if (isNaN(byte3)) {
                enc4 = 64;
            }
            else {
                enc4 = byte3 & 63;
            }
        }
        outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
    }
    return outputStr;
}
/**
 * Sugar that will use `nullishVal` if it's not null or undefined. Simulates the `??` operator
 * @param nullishVal
 * @param defaultVal
 */
function nullish(nullishVal, defaultVal) {
    return nullishVal !== null && nullishVal !== undefined ? nullishVal : defaultVal;
}
/**
 * Clamps a value between a min and max inclusive
 */
function clamp(val, min, max) {
    return Math.min(Math.max(min, val), max);
}
/**
 * Find a random floating point number in range
 */
function randomInRange(min, max, random = new Random()) {
    return random ? random.floating(min, max) : min + Math.random() * (max - min);
}
/**
 * Find a random integer in a range
 */
function randomIntInRange(min, max, random = new Random()) {
    return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
}
/**
 * Convert an angle to be the equivalent in the range [0, 2PI]
 */
function canonicalizeAngle(angle) {
    let tmpAngle = angle;
    if (angle > TwoPI) {
        while (tmpAngle > TwoPI) {
            tmpAngle -= TwoPI;
        }
    }
    if (angle < 0) {
        while (tmpAngle < 0) {
            tmpAngle += TwoPI;
        }
    }
    return tmpAngle;
}
/**
 * Convert radians to degrees
 */
function toDegrees(radians) {
    return (180 / Math.PI) * radians;
}
/**
 * Convert degrees to radians
 */
function toRadians(degrees) {
    return (degrees / 180) * Math.PI;
}
/**
 * Find the screen position of an HTML element
 */
function getPosition(el) {
    let oLeft = 0, oTop = 0;
    const calcOffsetLeft = (parent) => {
        oLeft += parent.offsetLeft;
        if (parent.offsetParent) {
            calcOffsetLeft(parent.offsetParent);
        }
    };
    const calcOffsetTop = (parent) => {
        oTop += parent.offsetTop;
        if (parent.offsetParent) {
            calcOffsetTop(parent.offsetParent);
        }
    };
    calcOffsetLeft(el);
    calcOffsetTop(el);
    return new Vector(oLeft, oTop);
}
/**
 * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.
 * @deprecated Will be removed in v0.26.0
 */
function addItemToArray(item, array) {
    if (array.indexOf(item) === -1) {
        array.push(item);
        return true;
    }
    return false;
}
/**
 * Remove an item from an list
 * @deprecated Will be removed in v0.26.0
 */
function removeItemFromArray(item, array) {
    let index = -1;
    if ((index = array.indexOf(item)) > -1) {
        array.splice(index, 1);
        return true;
    }
    return false;
}
/**
 * See if an array contains something
 */
function contains(array, obj) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === obj) {
            return true;
        }
    }
    return false;
}
/**
 * Get the opposit side
 * TODO: Move to Side type
 * @deprecated Will be removed in v0.26.0
 */
function getOppositeSide(side) {
    if (side === Side.Top) {
        return Side.Bottom;
    }
    if (side === Side.Bottom) {
        return Side.Top;
    }
    if (side === Side.Left) {
        return Side.Right;
    }
    if (side === Side.Right) {
        return Side.Left;
    }
    return Side.None;
}
/**
 * Returns the side in the direction of the vector supplied
 * @param direction Vector to check
 * @deprecated
 * TODO: Move to Side type
 */
function getSideFromDirection(direction) {
    const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];
    const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];
    let max = -Number.MAX_VALUE;
    let maxIndex = -1;
    for (let i = 0; i < directions.length; i++) {
        if (directions[i].dot(direction) > max) {
            max = directions[i].dot(direction);
            maxIndex = i;
        }
    }
    return directionEnum[maxIndex];
}
/**
 * Excalibur's dynamically resizing collection
 * @deprecated Will be removed v0.26.0
 */
class Collection {
    /**
     * @param initialSize  Initial size of the internal backing array
     */
    constructor(initialSize = Collection.DefaultSize) {
        this._internalArray = null;
        this._endPointer = 0;
        this._internalArray = new Array(initialSize);
    }
    _resize() {
        const newSize = this._internalArray.length * 2;
        const newArray = new Array(newSize);
        const count = this.count();
        for (let i = 0; i < count; i++) {
            newArray[i] = this._internalArray[i];
        }
        delete this._internalArray;
        this._internalArray = newArray;
    }
    /**
     * Push elements to the end of the collection
     */
    push(element) {
        if (this._endPointer === this._internalArray.length) {
            this._resize();
        }
        return (this._internalArray[this._endPointer++] = element);
    }
    /**
     * Removes elements from the end of the collection
     */
    pop() {
        this._endPointer = this._endPointer - 1 < 0 ? 0 : this._endPointer - 1;
        return this._internalArray[this._endPointer];
    }
    /**
     * Returns the count of the collection
     */
    count() {
        return this._endPointer;
    }
    /**
     * Empties the collection
     */
    clear() {
        this._endPointer = 0;
    }
    /**
     * Returns the size of the internal backing array
     */
    internalSize() {
        return this._internalArray.length;
    }
    /**
     * Returns an element at a specific index
     * @param index  Index of element to retrieve
     */
    elementAt(index) {
        if (index >= this.count()) {
            //Logger.getInstance().error('Invalid parameter: ' + index);
            throw new Error('Invalid index ' + index);
        }
        return this._internalArray[index];
    }
    /**
     * Inserts an element at a specific index
     * @param index  Index to insert the element
     * @param value  Element to insert
     */
    insert(index, value) {
        if (index >= this.count()) {
            this._resize();
        }
        return (this._internalArray[index] = value);
    }
    /**
     * Removes an element at a specific index
     * @param index  Index of element to remove
     */
    remove(index) {
        const count = this.count();
        if (count === 0) {
            //Logger.getInstance().error('Invalid parameter: ' + index);
            throw new Error('Invalid parameter ' + index);
        }
        // O(n) Shift
        const removed = this._internalArray[index];
        for (let i = index; i < count; i++) {
            this._internalArray[i] = this._internalArray[i + 1];
        }
        this._endPointer--;
        return removed;
    }
    /**
     * Removes an element by reference
     * @param element  Element to retrieve
     */
    removeElement(element) {
        const index = this._internalArray.indexOf(element);
        this.remove(index);
    }
    /**
     * Returns a array representing the collection
     */
    toArray() {
        return this._internalArray.slice(0, this._endPointer);
    }
    /**
     * Iterate over every element in the collection
     * @param func  Callback to call for each element passing a reference to the element and its index, returned values are ignored
     */
    forEach(func) {
        let i = 0;
        const count = this.count();
        for (i; i < count; i++) {
            func.call(this, this._internalArray[i], i);
        }
    }
    /**
     * Mutate every element in the collection
     * @param func  Callback to call for each element passing a reference to the element and its index, any values returned mutate
     * the collection
     */
    map(func) {
        const count = this.count();
        for (let i = 0; i < count; i++) {
            this._internalArray[i] = func.call(this, this._internalArray[i], i);
        }
    }
}
/**
 * Default collection size
 */
Collection.DefaultSize = 200;
/**
 * Used for exhaustive checks at compile time
 */
function fail(message) {
    throw new Error(message);
}
/**
 * Generate a range of numbers
 * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]
 * @param from inclusive
 * @param to inclusive
 */
const range = (from, to) => Array.from(new Array(to - from + 1), (_x, i) => i + from);
/**
 * Create a promise that resolves after a certain number of milliseconds
 * @param milliseconds
 */
function delay(milliseconds) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve();
        }, milliseconds);
    });
}

;// CONCATENATED MODULE: ./Util/Decorators.ts



const maxMessages = 5;
const obsoleteMessage = {};
const resetObsoleteCounter = () => {
    for (const message in obsoleteMessage) {
        obsoleteMessage[message] = 0;
    }
};
const logMessage = (message, options) => {
    const suppressObsoleteMessages = Flags.isEnabled('suppress-obsolete-message');
    if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {
        Logger.getInstance().warn(message);
        // tslint:disable-next-line: no-console
        if (console.trace && options.showStackTrace) {
            // tslint:disable-next-line: no-console
            console.trace();
        }
    }
    obsoleteMessage[message]++;
};
/**
 * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement
 * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js
 */
function obsolete(options) {
    options = extend({}, {
        message: 'This feature will be removed in future versions of Excalibur.',
        alternateMethod: null,
        showStackTrack: false
    }, options);
    return function (target, property, descriptor) {
        if (descriptor &&
            !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')) {
            throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');
        }
        const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;
        const message = `${methodSignature} is marked obsolete: ${options.message}` +
            (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');
        if (!obsoleteMessage[message]) {
            obsoleteMessage[message] = 0;
        }
        // If descriptor is null it is a class
        const method = descriptor ? Object.assign({}, descriptor) : target;
        if (!descriptor) {
            // with es2015 classes we need to change our decoration tactic
            class DecoratedClass extends method {
                constructor(...args) {
                    logMessage(message, options);
                    super(...args);
                }
            }
            return DecoratedClass;
        }
        if (descriptor && descriptor.value) {
            method.value = function () {
                logMessage(message, options);
                return descriptor.value.apply(this, arguments);
            };
            return method;
        }
        if (descriptor && descriptor.get) {
            method.get = function () {
                logMessage(message, options);
                return descriptor.get.apply(this, arguments);
            };
        }
        if (descriptor && descriptor.set) {
            method.set = function () {
                logMessage(message, options);
                return descriptor.set.apply(this, arguments);
            };
        }
        return method;
    };
}

;// CONCATENATED MODULE: ./Math/vector.ts
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * A 2D vector on a plane.
 */
class Vector {
    /**
     * @param x  X component of the Vector
     * @param y  Y component of the Vector
     */
    constructor(x, y) {
        this._x = 0;
        this._y = 0;
        this._x = x;
        this._y = y;
    }
    /**
     * A (0, 0) vector
     */
    static get Zero() {
        return new Vector(0, 0);
    }
    /**
     * A (1, 1) vector
     */
    static get One() {
        return new Vector(1, 1);
    }
    /**
     * A (0.5, 0.5) vector
     */
    static get Half() {
        return new Vector(0.5, 0.5);
    }
    /**
     * A unit vector pointing up (0, -1)
     */
    static get Up() {
        return new Vector(0, -1);
    }
    /**
     * A unit vector pointing down (0, 1)
     */
    static get Down() {
        return new Vector(0, 1);
    }
    /**
     * A unit vector pointing left (-1, 0)
     */
    static get Left() {
        return new Vector(-1, 0);
    }
    /**
     * A unit vector pointing right (1, 0)
     */
    static get Right() {
        return new Vector(1, 0);
    }
    /**
     * Returns a vector of unit length in the direction of the specified angle in Radians.
     * @param angle The angle to generate the vector
     */
    static fromAngle(angle) {
        return new Vector(Math.cos(angle), Math.sin(angle));
    }
    /**
     * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
     */
    static isValid(vec) {
        if (vec === null || vec === undefined) {
            return false;
        }
        if (isNaN(vec.x) || isNaN(vec.y)) {
            return false;
        }
        if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {
            return false;
        }
        return true;
    }
    /**
     * Calculates distance between two Vectors
     * @param vec1
     * @param vec2
     */
    static distance(vec1, vec2) {
        return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
    }
    /**
     * Get the x component of the vector
     */
    get x() {
        return this._x;
    }
    /**
     * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set x(val) {
        this._x = val;
    }
    /**
     * Get the y component of the vector
     */
    get y() {
        return this._y;
    }
    /**
     * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set y(val) {
        this._y = val;
    }
    /**
     * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.
     *
     * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**
     */
    setTo(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * Compares this point against another and tests for equality
     * @param vector The other point to compare to
     * @param tolerance Amount of euclidean distance off we are willing to tolerate
     */
    equals(vector, tolerance = 0.001) {
        return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;
    }
    /**
     * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].
     * @param v  The other vector. Leave blank to use origin vector.
     */
    distance(v) {
        if (!v) {
            v = Vector.Zero;
        }
        return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
    }
    squareDistance(v) {
        if (!v) {
            v = Vector.Zero;
        }
        return Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2);
    }
    /**
     * The magnitude (size) of the Vector
     * @deprecated magnitude will be removed in favour of '.size' in version 0.25.0
     */
    magnitude() {
        return this.distance();
    }
    /**
     * The size (magnitude) of the Vector
     */
    get size() {
        return this.distance();
    }
    /**
     * Setting the size mutates the current vector
     *
     * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
     */
    set size(newLength) {
        const v = this.normalize().scale(newLength);
        this.setTo(v.x, v.y);
    }
    /**
     * Normalizes a vector to have a magnitude of 1.
     */
    normalize() {
        const d = this.distance();
        if (d > 0) {
            return new Vector(this.x / d, this.y / d);
        }
        else {
            return new Vector(0, 1);
        }
    }
    /**
     * Returns the average (midpoint) between the current point and the specified
     */
    average(vec) {
        return this.add(vec).scale(0.5);
    }
    scale(sizeOrScale) {
        if (sizeOrScale instanceof Vector) {
            return new Vector(this.x * sizeOrScale.x, this.y * sizeOrScale.y);
        }
        else {
            return new Vector(this.x * sizeOrScale, this.y * sizeOrScale);
        }
    }
    /**
     * Adds one vector to another
     * @param v The vector to add
     */
    add(v) {
        return new Vector(this.x + v.x, this.y + v.y);
    }
    /**
     * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B
     * @param v The vector to subtract
     */
    sub(v) {
        return new Vector(this.x - v.x, this.y - v.y);
    }
    /**
     * Adds one vector to this one modifying the original
     * @param v The vector to add
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    addEqual(v) {
        this.setTo(this.x + v.x, this.y + v.y);
        return this;
    }
    /**
     * Subtracts a vector from this one modifying the original
     * @param v The vector to subtract
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    subEqual(v) {
        this.setTo(this.x - v.x, this.y - v.y);
        return this;
    }
    /**
     * Scales this vector by a factor of size and modifies the original
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    scaleEqual(size) {
        this.setTo(this.x * size, this.y * size);
        return this;
    }
    /**
     * Performs a dot product with another vector
     * @param v  The vector to dot
     */
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        if (v instanceof Vector) {
            return this.x * v.y - this.y * v.x;
        }
        else if (typeof v === 'number') {
            return new Vector(v * this.y, -v * this.x);
        }
    }
    static cross(num, vec) {
        return new Vector(-num * vec.y, num * vec.x);
    }
    /**
     * Returns the perpendicular vector to this one
     */
    perpendicular() {
        return new Vector(this.y, -this.x);
    }
    /**
     * Returns the normal vector to this one, same as the perpendicular of length 1
     */
    normal() {
        return this.perpendicular().normalize();
    }
    /**
     * Negate the current vector
     */
    negate() {
        return this.scale(-1);
    }
    /**
     * Returns the angle of this vector.
     */
    toAngle() {
        return Math.atan2(this.y, this.x);
    }
    /**
     * Rotates the current vector around a point by a certain number of
     * degrees in radians
     */
    rotate(angle, anchor) {
        if (!anchor) {
            anchor = new Vector(0, 0);
        }
        const sinAngle = Math.sin(angle);
        const cosAngle = Math.cos(angle);
        const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
        const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
        return new Vector(x, y);
    }
    /**
     * Creates new vector that has the same values as the previous.
     */
    clone() {
        return new Vector(this.x, this.y);
    }
    /**
     * Returns a string representation of the vector.
     */
    toString(fixed) {
        if (fixed) {
            return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;
        }
        return `(${this.x}, ${this.y})`;
    }
}
__decorate([
    obsolete({ message: 'will be removed in favour of `.size` in version 0.25.0' })
], Vector.prototype, "magnitude", null);
/**
 * Shorthand for creating new Vectors - returns a new Vector instance with the
 * provided X and Y components.
 *
 * @param x  X component of the Vector
 * @param y  Y component of the Vector
 */
function vec(x, y) {
    return new Vector(x, y);
}

;// CONCATENATED MODULE: ./Color.ts
var Color_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Provides standard colors (e.g. [[Color.Black]])
 * but you can also create custom colors using RGB, HSL, or Hex. Also provides
 * useful color operations like [[Color.lighten]], [[Color.darken]], and more.
 */
class Color {
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    constructor(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a != null ? a : 1;
    }
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    static fromRGB(r, g, b, a) {
        return new Color(r, g, b, a);
    }
    /**
     * Creates a new instance of Color from a rgb string
     *
     * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)
     */
    static fromRGBString(string) {
        const rgbaRegEx = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i;
        let match = null;
        if ((match = string.match(rgbaRegEx))) {
            const r = parseInt(match[1], 10);
            const g = parseInt(match[2], 10);
            const b = parseInt(match[3], 10);
            let a = 1;
            if (match[4]) {
                a = parseFloat(match[4]);
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid rgb/a string: ' + string);
        }
    }
    /**
     * Creates a new instance of Color from a hex string
     *
     * @param hex  CSS color string of the form #ffffff, the alpha component is optional
     */
    static fromHex(hex) {
        const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
        let match = null;
        if ((match = hex.match(hexRegEx))) {
            const r = parseInt(match[1], 16);
            const g = parseInt(match[2], 16);
            const b = parseInt(match[3], 16);
            let a = 1;
            if (match[4]) {
                a = parseInt(match[4], 16) / 255;
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid hex string: ' + hex);
        }
    }
    /**
     * Creates a new instance of Color from hsla values
     *
     * @param h  Hue is represented [0-1]
     * @param s  Saturation is represented [0-1]
     * @param l  Luminance is represented [0-1]
     * @param a  Alpha is represented [0-1]
     */
    static fromHSL(h, s, l, a = 1.0) {
        const temp = new HSLColor(h, s, l, a);
        return temp.toRGBA();
    }
    /**
     * Lightens the current color by a specified amount
     *
     * @param factor  The amount to lighten by [0-1]
     */
    lighten(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l += (1 - temp.l) * factor;
        return temp.toRGBA();
    }
    /**
     * Darkens the current color by a specified amount
     *
     * @param factor  The amount to darken by [0-1]
     */
    darken(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l -= temp.l * factor;
        return temp.toRGBA();
    }
    /**
     * Saturates the current color by a specified amount
     *
     * @param factor  The amount to saturate by [0-1]
     */
    saturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s += temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Desaturates the current color by a specified amount
     *
     * @param factor  The amount to desaturate by [0-1]
     */
    desaturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s -= temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Multiplies a color by another, results in a darker color
     *
     * @param color  The other color
     */
    multiply(color) {
        const newR = (((color.r / 255) * this.r) / 255) * 255;
        const newG = (((color.g / 255) * this.g) / 255) * 255;
        const newB = (((color.b / 255) * this.b) / 255) * 255;
        const newA = color.a * this.a;
        return new Color(newR, newG, newB, newA);
    }
    /**
     * Multiplies a color by another, results in a darker color
     * @param color
     * @deprecated Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0
     */
    mulitiply(color) {
        return this.multiply(color);
    }
    /**
     * Screens a color by another, results in a lighter color
     *
     * @param color  The other color
     */
    screen(color) {
        const color1 = color.invert();
        const color2 = color.invert();
        return color1.multiply(color2).invert();
    }
    /**
     * Inverts the current color
     */
    invert() {
        return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);
    }
    /**
     * Averages the current color with another
     *
     * @param color  The other color
     */
    average(color) {
        const newR = (color.r + this.r) / 2;
        const newG = (color.g + this.g) / 2;
        const newB = (color.b + this.b) / 2;
        const newA = (color.a + this.a) / 2;
        return new Color(newR, newG, newB, newA);
    }
    equal(color) {
        return this.toString() === color.toString();
    }
    /**
     * Returns a CSS string representation of a color.
     *
     * @param format Color representation, accepts: rgb, hsl, or hex
     */
    toString(format = 'rgb') {
        switch (format) {
            case 'rgb':
                return this.toRGBA();
            case 'hsl':
                return this.toHSLA();
            case 'hex':
                return this.toHex();
            default:
                throw new Error('Invalid Color format');
        }
    }
    /**
     * Returns Hex Value of a color component
     * @param c color component
     * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     */
    _componentToHex(c) {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
    /**
     * Return Hex representation of a color.
     */
    toHex() {
        return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
    }
    /**
     * Return RGBA representation of a color.
     */
    toRGBA() {
        const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));
        if (this.a !== undefined || this.a !== null) {
            return 'rgba(' + result + ', ' + String(this.a) + ')';
        }
        return 'rgb(' + result + ')';
    }
    /**
     * Return HSLA representation of a color.
     */
    toHSLA() {
        return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
    }
    /**
     * Returns a CSS string representation of a color.
     */
    fillStyle() {
        return this.toString();
    }
    /**
     * Returns a clone of the current color.
     */
    clone() {
        return new Color(this.r, this.g, this.b, this.a);
    }
    /**
     * Black (#000000)
     */
    static get Black() {
        return Color.fromHex('#000000');
    }
    /**
     * White (#FFFFFF)
     */
    static get White() {
        return Color.fromHex('#FFFFFF');
    }
    /**
     * Gray (#808080)
     */
    static get Gray() {
        return Color.fromHex('#808080');
    }
    /**
     * Light gray (#D3D3D3)
     */
    static get LightGray() {
        return Color.fromHex('#D3D3D3');
    }
    /**
     * Dark gray (#A9A9A9)
     */
    static get DarkGray() {
        return Color.fromHex('#A9A9A9');
    }
    /**
     * Yellow (#FFFF00)
     */
    static get Yellow() {
        return Color.fromHex('#FFFF00');
    }
    /**
     * Orange (#FFA500)
     */
    static get Orange() {
        return Color.fromHex('#FFA500');
    }
    /**
     * Red (#FF0000)
     */
    static get Red() {
        return Color.fromHex('#FF0000');
    }
    /**
     * Vermilion (#FF5B31)
     */
    static get Vermilion() {
        return Color.fromHex('#FF5B31');
    }
    /**
     * Vermilion (#FF5B31)
     * @deprecated Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0
     */
    static get Vermillion() {
        return Color.Vermilion;
    }
    /**
     * Rose (#FF007F)
     */
    static get Rose() {
        return Color.fromHex('#FF007F');
    }
    /**
     * Magenta (#FF00FF)
     */
    static get Magenta() {
        return Color.fromHex('#FF00FF');
    }
    /**
     * Violet (#7F00FF)
     */
    static get Violet() {
        return Color.fromHex('#7F00FF');
    }
    /**
     * Blue (#0000FF)
     */
    static get Blue() {
        return Color.fromHex('#0000FF');
    }
    /**
     * Azure (#007FFF)
     */
    static get Azure() {
        return Color.fromHex('#007FFF');
    }
    /**
     * Cyan (#00FFFF)
     */
    static get Cyan() {
        return Color.fromHex('#00FFFF');
    }
    /**
     * Viridian (#59978F)
     */
    static get Viridian() {
        return Color.fromHex('#59978F');
    }
    /**
     * Green (#00FF00)
     */
    static get Green() {
        return Color.fromHex('#00FF00');
    }
    /**
     * Chartreuse (#7FFF00)
     */
    static get Chartreuse() {
        return Color.fromHex('#7FFF00');
    }
    /**
     * Transparent (#FFFFFF00)
     */
    static get Transparent() {
        return Color.fromHex('#FFFFFF00');
    }
    /**
     * ExcaliburBlue (#176BAA)
     */
    static get ExcaliburBlue() {
        return Color.fromHex('#176BAA');
    }
}
Color_decorate([
    obsolete({ message: 'Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0' })
], Color.prototype, "mulitiply", null);
Color_decorate([
    obsolete({
        message: 'Alias for incorrect spelling used in older versions',
        alternateMethod: 'Vermilion'
    })
], Color, "Vermillion", null);
/**
 * Internal HSL Color representation
 *
 * http://en.wikipedia.org/wiki/HSL_and_HSV
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 */
class HSLColor {
    constructor(h, s, l, a) {
        this.h = h;
        this.s = s;
        this.l = l;
        this.a = a;
    }
    static hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
    }
    static fromRGBA(r, g, b, a) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s;
        const l = (max + min) / 2;
        if (max === min) {
            h = s = 0; // achromatic
        }
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return new HSLColor(h, s, l, a);
    }
    toRGBA() {
        let r, g, b;
        if (this.s === 0) {
            r = g = b = this.l; // achromatic
        }
        else {
            const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
            const p = 2 * this.l - q;
            r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
            g = HSLColor.hue2rgb(p, q, this.h);
            b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
        }
        return new Color(r * 255, g * 255, b * 255, this.a);
    }
    toString() {
        const h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
        return `hsla(${h}, ${s}, ${l}, ${a})`;
    }
}

;// CONCATENATED MODULE: ./Collision/BoundingBox.ts



/**
 * Axis Aligned collision primitive for Excalibur.
 */
class BoundingBox {
    /**
     * Constructor allows passing of either an object with all coordinate components,
     * or the coordinate components passed separately.
     * @param leftOrOptions    Either x coordinate of the left edge or an options object
     * containing the four coordinate components.
     * @param top     y coordinate of the top edge
     * @param right   x coordinate of the right edge
     * @param bottom  y coordinate of the bottom edge
     */
    constructor(leftOrOptions = 0, top = 0, right = 0, bottom = 0) {
        if (typeof leftOrOptions === 'object') {
            this.left = leftOrOptions.left;
            this.top = leftOrOptions.top;
            this.right = leftOrOptions.right;
            this.bottom = leftOrOptions.bottom;
        }
        else if (typeof leftOrOptions === 'number') {
            this.left = leftOrOptions;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
    }
    /**
     * Given bounding box A & B, returns the side relative to A when intersection is performed.
     * @param intersection Intersection vector between 2 bounding boxes
     */
    static getSideFromIntersection(intersection) {
        if (!intersection) {
            return Side.None;
        }
        if (intersection) {
            if (Math.abs(intersection.x) > Math.abs(intersection.y)) {
                if (intersection.x < 0) {
                    return Side.Right;
                }
                return Side.Left;
            }
            else {
                if (intersection.y < 0) {
                    return Side.Bottom;
                }
                return Side.Top;
            }
        }
        return Side.None;
    }
    static fromPoints(points) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < points.length; i++) {
            if (points[i].x < minX) {
                minX = points[i].x;
            }
            if (points[i].x > maxX) {
                maxX = points[i].x;
            }
            if (points[i].y < minY) {
                minY = points[i].y;
            }
            if (points[i].y > maxY) {
                maxY = points[i].y;
            }
        }
        return new BoundingBox(minX, minY, maxX, maxY);
    }
    static fromDimension(width, height, anchor = Vector.Half, pos = Vector.Zero) {
        return new BoundingBox(-width * anchor.x + pos.x, -height * anchor.y + pos.y, width - width * anchor.x + pos.x, height - height * anchor.y + pos.y);
    }
    /**
     * Returns the calculated width of the bounding box
     */
    get width() {
        return this.right - this.left;
    }
    /**
     * Returns the calculated height of the bounding box
     */
    get height() {
        return this.bottom - this.top;
    }
    /**
     * Return whether the bounding box has zero dimensions in height,width or both
     */
    hasZeroDimensions() {
        return this.width === 0 || this.height === 0;
    }
    /**
     * Returns the center of the bounding box
     */
    get center() {
        return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);
    }
    translate(pos) {
        return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);
    }
    /**
     * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding
     * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.
     */
    rotate(angle, point = Vector.Zero) {
        const points = this.getPoints().map((p) => p.rotate(angle, point));
        return BoundingBox.fromPoints(points);
    }
    scale(scale, point = Vector.Zero) {
        const shifted = this.translate(point);
        return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);
    }
    transform(matrix) {
        const points = this.getPoints().map((p) => matrix.multv(p));
        return BoundingBox.fromPoints(points);
    }
    /**
     * Returns the perimeter of the bounding box
     */
    getPerimeter() {
        const wx = this.width;
        const wy = this.height;
        return 2 * (wx + wy);
    }
    getPoints() {
        const results = [];
        results.push(new Vector(this.left, this.top));
        results.push(new Vector(this.right, this.top));
        results.push(new Vector(this.right, this.bottom));
        results.push(new Vector(this.left, this.bottom));
        return results;
    }
    /**
     * Determines whether a ray intersects with a bounding box
     */
    rayCast(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        return tmax >= Math.max(0, tmin) && tmin < farClipDistance;
    }
    rayCastTime(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {
            return tmin;
        }
        return -1;
    }
    contains(val) {
        if (val instanceof Vector) {
            return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;
        }
        else if (val instanceof BoundingBox) {
            if (this.left < val.left && this.top < val.top && val.bottom < this.bottom && val.right < this.right) {
                return true;
            }
            return false;
        }
        return false;
    }
    /**
     * Combines this bounding box and another together returning a new bounding box
     * @param other  The bounding box to combine
     */
    combine(other) {
        const compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
        return compositeBB;
    }
    get dimensions() {
        return new Vector(this.width, this.height);
    }
    /**
     * Test wether this bounding box intersects with another returning
     * the intersection vector that can be used to resolve the collision. If there
     * is no intersection null is returned.
     *
     * @param other  Other [[BoundingBox]] to test intersection with
     * @returns A Vector in the direction of the current BoundingBox, this <- other
     */
    intersect(other) {
        const totalBoundingBox = this.combine(other);
        // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision
        if (totalBoundingBox.width < other.width + this.width &&
            totalBoundingBox.height < other.height + this.height &&
            !totalBoundingBox.dimensions.equals(other.dimensions) &&
            !totalBoundingBox.dimensions.equals(this.dimensions)) {
            // collision
            let overlapX = 0;
            // right edge is between the other's left and right edge
            /**
             *     +-this-+
             *     |      |
             *     |    +-other-+
             *     +----|-+     |
             *          |       |
             *          +-------+
             *         <---
             *          ^ overlap
             */
            if (this.right >= other.left && this.right <= other.right) {
                overlapX = other.left - this.right;
                // right edge is past the other's right edge
                /**
                 *     +-other-+
                 *     |       |
                 *     |    +-this-+
                 *     +----|--+   |
                 *          |      |
                 *          +------+
                 *          --->
                 *          ^ overlap
                 */
            }
            else {
                overlapX = other.right - this.left;
            }
            let overlapY = 0;
            // top edge is between the other's top and bottom edge
            /**
             *     +-other-+
             *     |       |
             *     |    +-this-+   | <- overlap
             *     +----|--+   |   |
             *          |      |  \ /
             *          +------+   '
             */
            if (this.top <= other.bottom && this.top >= other.top) {
                overlapY = other.bottom - this.top;
                // top edge is above the other top edge
                /**
                 *     +-this-+         .
                 *     |      |        / \
                 *     |    +-other-+   | <- overlap
                 *     +----|-+     |   |
                 *          |       |
                 *          +-------+
                 */
            }
            else {
                overlapY = other.top - this.bottom;
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new Vector(overlapX, 0);
            }
            else {
                return new Vector(0, overlapY);
            }
            // Case of total containment of one bounding box by another
        }
        else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {
            let overlapX = 0;
            // this is wider than the other
            if (this.width - other.width >= 0) {
                // This right edge is closest to the others right edge
                if (this.right - other.right <= other.left - this.left) {
                    overlapX = other.left - this.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = other.right - this.left;
                }
                // other is wider than this
            }
            else {
                // This right edge is closest to the others right edge
                if (other.right - this.right <= this.left - other.left) {
                    overlapX = this.left - other.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = this.right - other.left;
                }
            }
            let overlapY = 0;
            // this is taller than other
            if (this.height - other.height >= 0) {
                // The bottom edge is closest to the others bottom edge
                if (this.bottom - other.bottom <= other.top - this.top) {
                    overlapY = other.top - this.bottom;
                }
                else {
                    overlapY = other.bottom - this.top;
                }
                // other is taller than this
            }
            else {
                // The bottom edge is closest to the others bottom edge
                if (other.bottom - this.bottom <= this.top - other.top) {
                    overlapY = this.top - other.bottom;
                }
                else {
                    overlapY = this.bottom - other.top;
                }
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new Vector(overlapX, 0);
            }
            else {
                return new Vector(0, overlapY);
            }
        }
        else {
            return null;
        }
    }
    /**
     * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.
     * @param bb The other actor to test
     */
    intersectWithSide(bb) {
        const intersect = this.intersect(bb);
        return BoundingBox.getSideFromIntersection(intersect);
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Yellow) {
        ctx.strokeStyle = color.toString();
        ctx.strokeRect(this.left, this.top, this.width, this.height);
    }
    /**
     * Draw a debug bounding box
     * @param ex
     * @param color
     */
    draw(ex, color = Color.Yellow) {
        ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });
    }
}

;// CONCATENATED MODULE: ./Math/matrix.ts



var MatrixLocations;
(function (MatrixLocations) {
    MatrixLocations[MatrixLocations["X"] = 12] = "X";
    MatrixLocations[MatrixLocations["Y"] = 13] = "Y";
})(MatrixLocations || (MatrixLocations = {}));
const sign = (val) => {
    if (val === 0) {
        return 0;
    }
    return val < 0 ? -1 : 1;
};
// const multMatch = (a: number, b: number) => {
//   if (sign(a) < 0 && sign(b) < 0) {
//     return -Math.abs(a * b);
//   }
//   return a * b;
// }
// const epsilon = (val: number) => {
//   if (val * val < .0001) {
//     return 0;
//   }
//   return val;
// }
/**
 * Excalibur Matrix helper for 4x4 matrices
 *
 * Useful for webgl 4x4 matrices
 */
class Matrix {
    constructor() {
        /**
         *  4x4 matrix in column major order
         *
         * |         |         |          |          |
         * | ------- | ------- | -------- |          |
         * | data[0] | data[4] | data[8]  | data[12] |
         * | data[1] | data[5] | data[9]  | data[13] |
         * | data[2] | data[6] | data[10] | data[14] |
         * | data[3] | data[7] | data[11] | data[15] |
         *
         */
        this.data = new Float32Array(16);
        this._scaleSignX = 1;
        this._scaleSignY = 1;
    }
    /**
     * Creates an orthographic (flat non-perspective) projection
     * https://en.wikipedia.org/wiki/Orthographic_projection
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    static ortho(left, right, bottom, top, near, far) {
        const mat = new Matrix();
        mat.data[0] = 2 / (right - left);
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 2 / (top - bottom);
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = -2 / (far - near);
        mat.data[11] = 0;
        mat.data[12] = -(right + left) / (right - left);
        mat.data[13] = -(top + bottom) / (top - bottom);
        mat.data[14] = -(far + near) / (far - near);
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a new Matrix with the same data as the current 4x4
     */
    clone() {
        const mat = new Matrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = this.data[2];
        mat.data[3] = this.data[3];
        mat.data[4] = this.data[4];
        mat.data[5] = this.data[5];
        mat.data[6] = this.data[6];
        mat.data[7] = this.data[7];
        mat.data[8] = this.data[8];
        mat.data[9] = this.data[9];
        mat.data[10] = this.data[10];
        mat.data[11] = this.data[11];
        mat.data[12] = this.data[12];
        mat.data[13] = this.data[13];
        mat.data[14] = this.data[14];
        mat.data[15] = this.data[15];
        return mat;
    }
    /**
     * Creates a new identity matrix (a matrix that when applied does nothing)
     */
    static identity() {
        const mat = new Matrix();
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 1;
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = 0;
        mat.data[13] = 0;
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x, y) {
        const mat = Matrix.identity();
        mat.data[12] = x;
        mat.data[13] = y;
        return mat;
    }
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx, sy) {
        const mat = Matrix.identity();
        mat.data[0] = sx;
        mat.data[5] = sy;
        mat.data[10] = 1;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new rotation matrix with the specified angle
     * @param angleRadians
     */
    static rotation(angleRadians) {
        const mat = Matrix.identity();
        mat.data[0] = Math.cos(angleRadians);
        mat.data[4] = -Math.sin(angleRadians);
        mat.data[1] = Math.sin(angleRadians);
        mat.data[5] = Math.cos(angleRadians);
        return mat;
    }
    multv(other) {
        const z = 0;
        if (other instanceof Vector) {
            return new Vector(other.x * this.data[0] + other.y * this.data[4] + z * this.data[6] + 1 * this.data[12], other.x * this.data[1] + other.y * this.data[5] + z * this.data[9] + 1 * this.data[13]);
        }
        else {
            const dest = [
                other[0] * this.data[0] + other[1] * this.data[4] + z * this.data[6] + 1 * this.data[12],
                other[0] * this.data[1] + other[1] * this.data[5] + z * this.data[9] + 1 * this.data[13]
            ];
            return dest;
        }
    }
    /**
     * Multiplies the current matrix by another and returns the resulting matrix
     * @param other
     */
    multm(other) {
        const dest = new Matrix();
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const a13 = this.data[8];
        const a23 = this.data[9];
        const a33 = this.data[10];
        const a43 = this.data[11];
        const a14 = this.data[12];
        const a24 = this.data[13];
        const a34 = this.data[14];
        const a44 = this.data[15];
        const b11 = other.data[0];
        const b21 = other.data[1];
        const b31 = other.data[2];
        const b41 = other.data[3];
        const b12 = other.data[4];
        const b22 = other.data[5];
        const b32 = other.data[6];
        const b42 = other.data[7];
        const b13 = other.data[8];
        const b23 = other.data[9];
        const b33 = other.data[10];
        const b43 = other.data[11];
        const b14 = other.data[12];
        const b24 = other.data[13];
        const b34 = other.data[14];
        const b44 = other.data[15];
        dest.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        dest.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        dest.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        dest.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        dest.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        dest.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        dest.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        dest.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        dest.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        dest.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        dest.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        dest.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        dest.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        dest.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        dest.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        dest.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        const s = this.getScale();
        dest._scaleSignX = sign(s.x) * sign(dest._scaleSignX);
        dest._scaleSignY = sign(s.y) * sign(dest._scaleSignY);
        return dest;
    }
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const a13 = this.data[8];
        const a23 = this.data[9];
        const a33 = this.data[10];
        const a43 = this.data[11];
        const a14 = this.data[12];
        const a24 = this.data[13];
        const a34 = this.data[14];
        const a44 = this.data[15];
        // Doesn't change z
        const z = 0;
        const w = 1;
        this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;
        this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;
        this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;
        this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;
        return this;
    }
    setPosition(x, y) {
        this.data[12] = x;
        this.data[13] = y;
    }
    getPosition() {
        return vec(this.data[12], this.data[13]);
    }
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * a11 + sine * a12;
        this.data[1] = cosine * a21 + sine * a22;
        this.data[2] = cosine * a31 + sine * a32;
        this.data[3] = cosine * a41 + sine * a42;
        this.data[4] = cosine * a12 - sine * a11;
        this.data[5] = cosine * a22 - sine * a21;
        this.data[6] = cosine * a32 - sine * a31;
        this.data[7] = cosine * a42 - sine * a41;
        return this;
    }
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        this.data[0] = a11 * x;
        this.data[1] = a21 * x;
        this.data[2] = a31 * x;
        this.data[3] = a41 * x;
        this.data[4] = a12 * y;
        this.data[5] = a22 * y;
        this.data[6] = a32 * y;
        this.data[7] = a42 * y;
        return this;
    }
    setRotation(angle) {
        const currentScale = this.getScale();
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * currentScale.x;
        this.data[1] = sine * currentScale.y;
        this.data[4] = -sine * currentScale.x;
        this.data[5] = cosine * currentScale.y;
    }
    getRotation() {
        const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
        return canonicalizeAngle(angle);
    }
    getScaleX() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const xscale = vec(this.data[0], this.data[4]).size;
        return this._scaleSignX * xscale;
    }
    getScaleY() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const yscale = vec(this.data[1], this.data[5]).size;
        return this._scaleSignY * yscale;
    }
    /**
     * Get the scale of the matrix
     */
    getScale() {
        return vec(this.getScaleX(), this.getScaleY());
    }
    setScaleX(val) {
        this._scaleSignX = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();
        this.data[0] = xscale.x * val;
        this.data[4] = xscale.y * val;
    }
    setScaleY(val) {
        this._scaleSignY = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();
        this.data[1] = yscale.x * val;
        this.data[5] = yscale.y * val;
    }
    setScale(scale) {
        this.setScaleX(scale.x);
        this.setScaleY(scale.y);
    }
    /**
     * Determinant of the upper left 2x2 matrix
     */
    getBasisDeterminant() {
        return this.data[0] * this.data[5] - this.data[1] * this.data[4];
    }
    getAffineInverse() {
        // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html
        // See https://www.mathsisfun.com/algebra/matrix-inverse.html
        // Since we are actually only doing 2D transformations we can use this hack
        // We don't actually use the 3rd or 4th dimension
        const det = this.getBasisDeterminant();
        const inverseDet = 1 / det; // todo zero check
        const a = this.data[0];
        const b = this.data[4];
        const c = this.data[1];
        const d = this.data[5];
        const m = Matrix.identity();
        // inverts rotation and scale
        m.data[0] = d * inverseDet;
        m.data[1] = -c * inverseDet;
        m.data[4] = -b * inverseDet;
        m.data[5] = a * inverseDet;
        const tx = this.data[12];
        const ty = this.data[13];
        // invert translation
        // transform translation into the matrix basis created by rot/scale
        m.data[12] = -(tx * m.data[0] + ty * m.data[4]);
        m.data[13] = -(tx * m.data[1] + ty * m.data[5]);
        return m;
    }
    isIdentity() {
        return (this.data[0] === 1 &&
            this.data[1] === 0 &&
            this.data[2] === 0 &&
            this.data[3] === 0 &&
            this.data[4] === 0 &&
            this.data[5] === 1 &&
            this.data[6] === 0 &&
            this.data[7] === 0 &&
            this.data[8] === 0 &&
            this.data[9] === 0 &&
            this.data[10] === 1 &&
            this.data[11] === 0 &&
            this.data[12] === 0 &&
            this.data[13] === 0 &&
            this.data[14] === 0 &&
            this.data[15] === 1);
    }
    toString() {
        return `
[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]
[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]
[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]
[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]
`;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/transform-stack.ts

class TransformStack {
    constructor() {
        this._transforms = [];
        this._currentTransform = Matrix.identity();
    }
    save() {
        this._transforms.push(this._currentTransform);
        this._currentTransform = this._currentTransform.clone();
    }
    restore() {
        this._currentTransform = this._transforms.pop();
    }
    translate(x, y) {
        return this._currentTransform.translate(x, y);
    }
    rotate(angle) {
        return this._currentTransform.rotate(angle);
    }
    scale(x, y) {
        return this._currentTransform.scale(x, y);
    }
    set current(matrix) {
        this._currentTransform = matrix;
    }
    get current() {
        return this._currentTransform;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/state-stack.ts
class StateStack {
    constructor() {
        this._states = [];
        this._currentState = this._getDefaultState();
    }
    _getDefaultState() {
        return {
            opacity: 1
        };
    }
    _cloneState() {
        return {
            opacity: this._currentState.opacity
        };
    }
    save() {
        this._states.push(this._currentState);
        this._currentState = this._cloneState();
    }
    restore() {
        this._currentState = this._states.pop();
    }
    get current() {
        return this._currentState;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shader.ts
/**
 * Create a shader program for the Excalibur WebGL Graphics Context
 */
class Shader {
    /**
     * Create a shader program in excalibur
     * @param _gl WebGL graphics context
     * @param _vertexSource Vertex shader source as a string
     * @param _fragmentSource Fragment shader source as a string
     */
    constructor(_gl, _vertexSource, _fragmentSource) {
        this._gl = _gl;
        this._vertexSource = _vertexSource;
        this._fragmentSource = _fragmentSource;
        this.program = null;
        this.uniforms = {};
        this.attributes = {};
        this.layout = [];
        this.compile(_gl);
    }
    _createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        if (program === null) {
            throw Error('Could not create graphics shader program');
        }
        // attach the shaders.
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        // link the program.
        gl.linkProgram(program);
        const success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!success) {
            throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);
        }
        return program;
    }
    _compileShader(gl, source, type) {
        const shader = gl.createShader(type);
        if (shader === null) {
            throw Error(`Could not build shader: [${source}]`);
        }
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!success) {
            throw Error(`Could not compile shader [${gl.getShaderInfoLog(shader)}]`);
        }
        return shader;
    }
    /**
     * Compile the current shader against a webgl context
     * @param gl WebGL context
     */
    compile(gl) {
        const vertexShader = this._compileShader(gl, this._vertexSource, gl.VERTEX_SHADER);
        const fragmentShader = this._compileShader(gl, this._fragmentSource, gl.FRAGMENT_SHADER);
        const program = this._createProgram(gl, vertexShader, fragmentShader);
        return (this.program = program);
    }
    /**
     * Add a uniform [[Matrix]] to the shader
     * @param name Name of the uniform in the shader source
     * @param data (4x4) matrix in column major order
     */
    addUniformMatrix(name, data) {
        if (!data) {
            throw Error(`Shader Uniform Matrix '${name}' was set to null or undefined`);
        }
        const gl = this._gl;
        this.uniforms[name] = {
            name,
            type: 'matrix',
            location: gl.getUniformLocation(this.program, name),
            data: data
        };
    }
    /**
     * Add a uniform array of numbers to the shader
     * @param name Name of the uniform in the shader source
     * @param data List of numbers
     */
    addUniformIntegerArray(name, data) {
        if (!data) {
            throw Error(`Shader Uniform Integery Array '${name}' was set to null or undefined`);
        }
        const gl = this._gl;
        this.uniforms[name] = {
            name,
            type: 'numbers',
            location: gl.getUniformLocation(this.program, name),
            data: data
        };
    }
    /**
     * Add attributes in the order they appear in the VBO
     * @param name Name of the attribute in the shader source
     * @param size The size of the attribute in gl.Type units, for example `vec2 a_pos` would be 2 gl.FLOAT
     * @param glType The gl.Type of the attribute
     */
    addAttribute(name, size, glType, normalized = false) {
        const gl = this._gl;
        // TODO needs to be compiled first
        const location = gl.getAttribLocation(this.program, name);
        this.attributes[name] = {
            name,
            size,
            glType,
            normalized,
            location
        };
        this.layout.push(this.attributes[name]);
    }
    /**
     * Number of javascript floats a vertex will take up
     */
    get vertexAttributeSize() {
        let vertexSize = 0;
        for (const vert of this.layout) {
            vertexSize += vert.size;
        }
        return vertexSize;
    }
    /**
     * Total number of bytes that the vertex will take up
     */
    get totalVertexSizeBytes() {
        let vertexSize = 0;
        for (const vert of this.layout) {
            let typeSize = 1;
            switch (vert.glType) {
                case this._gl.FLOAT: {
                    typeSize = 4;
                    break;
                }
                default: {
                    typeSize = 1;
                }
            }
            vertexSize += typeSize * vert.size;
        }
        return vertexSize;
    }
    /**
     * Get a previously defined attribute size in bytes
     * @param name
     */
    getAttributeSize(name) {
        let typeSize = 1;
        switch (this.attributes[name].glType) {
            case this._gl.FLOAT: {
                typeSize = 4;
                break;
            }
            default: {
                typeSize = 1;
            }
        }
        return typeSize * this.attributes[name].size;
    }
    /**
     * Sets this shader program as the current in the underlying webgl context
     *
     * **Must** specify all attributes and uniforms before calling this
     */
    use() {
        const gl = this._gl;
        gl.useProgram(this.program);
        let offset = 0;
        for (const vert of this.layout) {
            gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);
            gl.enableVertexAttribArray(vert.location);
            offset += this.getAttributeSize(vert.name);
        }
        for (const key in this.uniforms) {
            const uniform = this.uniforms[key];
            switch (uniform.type) {
                case 'matrix': {
                    gl.uniformMatrix4fv(uniform.location, false, uniform.data);
                    break;
                }
                case 'numbers': {
                    gl.uniform1iv(uniform.location, uniform.data);
                    break;
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shaders/line-vertex.glsl
/* harmony default export */ const line_vertex = ("attribute vec4 a_position;\r\nattribute vec4 a_color;\r\n\r\nvarying lowp vec4 v_color;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * a_position;\r\n\r\n   // Passthrough the color\r\n   v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/shaders/line-fragment.glsl
/* harmony default export */ const line_fragment = ("precision mediump float;\r\n\r\n// Color\r\nvarying lowp vec4 v_color;\r\n\r\n\r\nvoid main() {\r\n  gl_FragColor = v_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/batch.ts
class BatchCommand {
    constructor(max) {
        this.max = max;
        this._pool = undefined;
        this.commands = [];
    }
    isFull() {
        if (this.commands.length >= this.max) {
            return true;
        }
        return false;
    }
    canAdd() {
        return !this.isFull();
    }
    add(cmd) {
        this.commands.push(cmd);
    }
    dispose() {
        this.commands.length = 0;
        return this;
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsDiagnostics.ts
class GraphicsDiagnostics {
    static clear() {
        GraphicsDiagnostics.DrawCallCount = 0;
        GraphicsDiagnostics.DrawnImagesCount = 0;
    }
}
GraphicsDiagnostics.DrawCallCount = 0;
GraphicsDiagnostics.DrawnImagesCount = 0;

;// CONCATENATED MODULE: ./Util/Pool.ts

class Pool {
    constructor(builder, recycler, maxObjects = 100) {
        this.builder = builder;
        this.recycler = recycler;
        this.maxObjects = maxObjects;
        this.totalAllocations = 0;
        this.index = 0;
        this.objects = [];
        this._logger = Logger.getInstance();
    }
    /**
     * Use many instances out of the in the context and return all to the pool.
     *
     * By returning values out of the contex they will be un-hooked from the pool and are free to be passed to consumers
     * @param context
     */
    using(context) {
        const result = context(this);
        if (result) {
            return this.done(...result);
        }
        return this.done();
    }
    /**
     * Use a single instance out of th pool and immediately return it to the pool
     * @param context
     */
    borrow(context) {
        const object = this.get();
        context(object);
        this.index--;
    }
    /**
     * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool
     * @param args
     */
    get(...args) {
        if (this.index === this.maxObjects) {
            // TODO implement hard or soft cap
            this._logger.warn('Max pooled objects reached, possible memory leak? Doubling');
            this.maxObjects = this.maxObjects * 2;
            // throw new Error('Max pooled objects reached, possible memory leak?');
        }
        if (this.objects[this.index]) {
            // Pool has an available object already constructed
            return this.recycler(this.objects[this.index++], ...args);
        }
        else {
            // New allocation
            this.totalAllocations++;
            const object = (this.objects[this.index++] = this.builder(...args));
            object._pool = this;
            return object;
        }
    }
    done(...objects) {
        // All objects in pool now considered "free"
        this.index = 0;
        for (const object of objects) {
            const poolIndex = this.objects.indexOf(object);
            // Build a new object to take the pool place
            this.objects[poolIndex] = this.builder(); // TODO problematic 0-arg only support
            this.objects[poolIndex]._pool = this;
            this.totalAllocations++;
            // Unhook object from the pool
            object._pool = undefined;
        }
        return objects;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/renderer.ts

// import { Pool, Poolable } from './pool';


class BatchRenderer {
    constructor(options) {
        var _a, _b, _c;
        this.priority = 0;
        this._buffer = null;
        this._maxCommandsPerBatch = 2000;
        this._batches = [];
        this._gl = options.gl;
        const command = options.command;
        this._verticesPerCommand = (_a = options === null || options === void 0 ? void 0 : options.verticesPerCommand) !== null && _a !== void 0 ? _a : 1;
        this._maxCommandsPerBatch = (_b = options === null || options === void 0 ? void 0 : options.maxCommandsPerBatch) !== null && _b !== void 0 ? _b : this._maxCommandsPerBatch;
        const batchFactory = (_c = options === null || options === void 0 ? void 0 : options.batchFactory) !== null && _c !== void 0 ? _c : (() => new BatchCommand(this._maxCommandsPerBatch));
        this.commands = new Pool(() => new command(), (c) => c.dispose(), this._maxCommandsPerBatch);
        this._batchPool = new Pool(batchFactory, (b) => b.dispose(), 100);
    }
    /**
     * Initialize render, builds shader and initialized webgl buffers
     */
    init() {
        const gl = this._gl;
        this.shader = this.buildShader(gl);
        // Initialize VBO
        // https://groups.google.com/forum/#!topic/webgl-dev-list/vMNXSNRAg8M
        this._vertices = new Float32Array(this.shader.vertexAttributeSize * this._verticesPerCommand * this._maxCommandsPerBatch);
        this._buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
    }
    get vertexSize() {
        return this.shader.vertexAttributeSize;
    }
    addCommand(cmd) {
        if (this._batches.length === 0) {
            this._batches.push(this._batchPool.get());
        }
        const lastBatch = this._batches[this._batches.length - 1];
        if (lastBatch.canAdd()) {
            lastBatch.add(cmd);
        }
        else {
            const newBatch = this._batchPool.get();
            newBatch.add(cmd);
            this._batches.push(newBatch);
        }
    }
    /**
     * Build batch geometry, submit to the gpu, and issue draw command to underlying webgl
     */
    render() {
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
        this.shader.use();
        let drawCallCount = 0;
        let drawnImagesCount = 0;
        for (const batch of this._batches) {
            // Build all geometry and ship to GPU
            // interleave VBOs https://goharsha.com/lwjgl-tutorial-series/interleaving-buffer-objects/
            const vertexCount = this.buildBatchVertices(this._vertices, batch);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
            this.renderBatch(gl, batch, vertexCount);
            drawnImagesCount += batch.commands.length;
            drawCallCount++;
        }
        this.commands.done();
        this._batchPool.done();
        this._batches.length = 0;
        GraphicsDiagnostics.DrawCallCount += drawCallCount;
        GraphicsDiagnostics.DrawnImagesCount += drawnImagesCount;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/line-renderer.ts






class DrawLine {
    constructor() {
        this.color = Color.Black;
        this.start = Vector.Zero;
        this.end = Vector.Zero;
    }
    dispose() {
        this.color.r = 0;
        this.color.g = 0;
        this.color.b = 0;
        this.color.a = 1;
        this.start.setTo(0, 0);
        this.end.setTo(0, 0);
        return this;
    }
}
class LineRenderer extends BatchRenderer {
    constructor(gl, _contextInfo) {
        super({ gl, command: DrawLine, verticesPerCommand: 2 });
        this._contextInfo = _contextInfo;
        this.init();
    }
    buildShader(gl) {
        const shader = new Shader(gl, line_vertex, line_fragment);
        shader.addAttribute('a_position', 2, gl.FLOAT);
        shader.addAttribute('a_color', 4, gl.FLOAT);
        shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);
        return shader;
    }
    addLine(start, end, color) {
        const cmd = this.commands.get();
        cmd.start = this._contextInfo.transform.current.multv(start);
        cmd.end = this._contextInfo.transform.current.multv(end);
        cmd.color.r = color.r;
        cmd.color.g = color.g;
        cmd.color.b = color.b;
        cmd.color.a = cmd.color.a * this._contextInfo.state.current.opacity;
        this.addCommand(cmd);
    }
    buildBatchVertices(vertexBuffer, batch) {
        let index = 0;
        for (const command of batch.commands) {
            // Start
            vertexBuffer[index++] = command.start.x;
            vertexBuffer[index++] = command.start.y;
            vertexBuffer[index++] = command.color.r / 255;
            vertexBuffer[index++] = command.color.g / 255;
            vertexBuffer[index++] = command.color.b / 255;
            vertexBuffer[index++] = command.color.a;
            // End
            vertexBuffer[index++] = command.end.x;
            vertexBuffer[index++] = command.end.y;
            vertexBuffer[index++] = command.color.r / 255;
            vertexBuffer[index++] = command.color.g / 255;
            vertexBuffer[index++] = command.color.b / 255;
            vertexBuffer[index++] = command.color.a;
        }
        return index / this.vertexSize;
    }
    renderBatch(gl, _batch, vertexCount) {
        gl.drawArrays(gl.LINES, 0, vertexCount);
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shaders/image-vertex.glsl
/* harmony default export */ const image_vertex = ("attribute vec4 a_position;\r\n\r\n// Opacity \r\nattribute float a_opacity;\r\nvarying float v_opacity;\r\n\r\nattribute vec4 a_color;\r\nvarying vec4 v_color;\r\n\r\n// UV coordinate\r\nattribute vec2 a_texcoord;\r\nvarying vec2 v_texcoord;\r\n\r\n// Texture number\r\nattribute lowp float a_textureIndex;\r\nvarying lowp float v_textureIndex;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * a_position;\r\n\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the UV coord to the fragment shader\r\n   v_texcoord = a_texcoord;\r\n   // Pass through the texture number to the fragment shader\r\n   v_textureIndex = a_textureIndex;\r\n   // Pass through the color to the fragment shader\r\n   v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/shaders/image-fragment.glsl
/* harmony default export */ const image_fragment = ("#ifdef GL_OES_standard_derivatives\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\nprecision mediump float;\r\n\r\n// UV coord\r\nvarying vec2 v_texcoord;\r\n\r\n// Texture index\r\nvarying lowp float v_textureIndex;\r\n\r\n// Color coord to blend with image\r\nvarying lowp vec4 v_color;\r\n\r\n// Opacity\r\nvarying float v_opacity;\r\n\r\nuniform sampler2D u_textures[%%count%%];\r\n\r\nfloat circle(in vec2 st, in float radius) {\r\n  vec2 dist = st - vec2(0.5);\r\n  float r = dot(dist, dist) * 4.0;\r\n  float delta = fwidth(r);\r\n  return 1.0 - smoothstep(radius - delta, radius + delta, r);\r\n}\r\n\r\nvoid main() {\r\n  float r = 0.0, delta = 0.0, alpha = 1.0;\r\n   // In order to support the most efficient sprite batching, we have multiple\r\n   // textures loaded into the gpu (usually 8) this picker logic skips over textures\r\n   // that do not apply to a particular sprite.\r\n\r\n   vec4 color;\r\n   // -1 If there is no texture to sample we are drawing a solid geometry (rectangles)\r\n   if (v_textureIndex == -1.0) {\r\n     color = v_color;\r\n     color.w = color.w * v_opacity;\r\n   // -2 If there is no texture we are drawing a circle\r\n   } else if (v_textureIndex == -2.0) {\r\n     color = v_color;\r\n     color.a = color.a * circle(v_texcoord, .95);\r\n   } else {\r\n     // GLSL is templated out to pick the right texture and set the vec4 color\r\n      %%texture_picker%%\r\n   }\r\n   color.w = color.w * v_opacity;\r\n   gl_FragColor = color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/draw-image-command.ts

var DrawCommandType;
(function (DrawCommandType) {
    DrawCommandType["Image"] = "image";
    DrawCommandType["Line"] = "line";
    DrawCommandType["Rectangle"] = "rectangle";
    DrawCommandType["Circle"] = "circle";
})(DrawCommandType || (DrawCommandType = {}));
class DrawImageCommand {
    constructor(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        this._pool = undefined;
        this.snapToPixel = true;
        this.type = DrawCommandType.Image;
        this.opacity = 1;
        this.width = 0;
        this.height = 0;
        this.dest = [0, 0]; // x, y
        this.view = [0, 0, 0, 0]; // sx, sy, sw, sh
        this._geom = [
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0]
        ];
        this.init(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
    }
    init(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        this.type = DrawCommandType.Image;
        this.image = image;
        this.width = (image === null || image === void 0 ? void 0 : image.width) || swidth || 0;
        this.height = (image === null || image === void 0 ? void 0 : image.height) || sheight || 0;
        this.view = [0, 0, swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width, sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height];
        this.dest = [sx, sy];
        // If destination is specified, update view and dest
        if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {
            this.view = [sx, sy, swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width, sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height];
            this.dest = [dx, dy];
            this.width = dwidth;
            this.height = dheight;
        }
        let index = 0;
        this._geom[index++] = [this.dest[0], this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1] + this.height];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    initRect(color, start, width, height) {
        this.type = DrawCommandType.Rectangle;
        this.color = color;
        this.width = width;
        this.height = height;
        let index = 0;
        this._geom[index++] = [start.x, start.y];
        this._geom[index++] = [start.x, start.y + this.height];
        this._geom[index++] = [start.x + this.width, start.y];
        this._geom[index++] = [start.x + this.width, start.y];
        this._geom[index++] = [start.x, start.y + this.height];
        this._geom[index++] = [start.x + this.width, start.y + this.height];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    initLine(color, start, end, thickness) {
        this.type = DrawCommandType.Line;
        this.color = color;
        const dir = end.sub(start).normalize();
        const normal = dir.perpendicular();
        const halfThick = thickness / 2;
        const startTop = normal.scale(halfThick).add(start);
        const startBottom = normal.scale(-halfThick).add(start);
        const endTop = normal.scale(halfThick).add(end);
        const endBottom = normal.scale(-halfThick).add(end);
        /**
         *    +---------------------^----------------------+
         *    |                     | (normal)             |
         *   (startx, starty)------------------>(endx, endy)
         *    |                                            |
         *    + -------------------------------------------+
         */
        let index = 0;
        this._geom[index++] = [startTop.x, startTop.y];
        this._geom[index++] = [endTop.x, endTop.y];
        this._geom[index++] = [startBottom.x, startBottom.y];
        this._geom[index++] = [startBottom.x, startBottom.y];
        this._geom[index++] = [endTop.x, endTop.y];
        this._geom[index++] = [endBottom.x, endBottom.y];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    initCircle(pos, radius, color) {
        this.type = DrawCommandType.Circle;
        this.color = color;
        const topLeft = pos.add(vec(-radius, -radius));
        const topRight = pos.add(vec(radius, -radius));
        const bottomRight = pos.add(vec(radius, radius));
        const bottomLeft = pos.add(vec(-radius, radius));
        let index = 0;
        this._geom[index++] = [topLeft.x, topLeft.y];
        this._geom[index++] = [topRight.x, topRight.y];
        this._geom[index++] = [bottomLeft.x, bottomLeft.y];
        this._geom[index++] = [bottomLeft.x, bottomLeft.y];
        this._geom[index++] = [topRight.x, topRight.y];
        this._geom[index++] = [bottomRight.x, bottomRight.y];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    dispose() {
        this.image = null;
        this.width = 0;
        this.height = 0;
        this.view = [0, 0, 0, 0];
        this.dest = [0, 0];
        let index = 0;
        this._geom[index++] = [this.dest[0], this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1] + this.height];
        return this;
    }
    // todo weird
    applyTransform(transform, opacity) {
        if (transform) {
            for (let i = 0; i < this._geom.length; i++) {
                this._geom[i] = transform.multv(this._geom[i]);
                if (this.snapToPixel) {
                    this._geom[i] = [~~this._geom[i][0], ~~this._geom[i][1]];
                }
            }
        }
        this.opacity = opacity;
    }
    get geometry() {
        return this._geom;
    }
}
class DrawRectCommand {
    constructor(x, y, width, height) {
        this.dest = [0, 0];
        this.width = 0;
        this.height = 0;
        this.dest = [x, y];
        this.width = width;
        this.height = height;
    }
}
class DrawDebugRectCommand {
    constructor(bounds, color) {
        this.bounds = bounds;
        this.color = color;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/webgl-util.ts
/**
 * Checks if the current number is a power of two
 */
function isPowerOfTwo(x) {
    return (x & (x - 1)) === 0;
}
/**
 * Returns the next highest power of two
 */
function nextHighestPowerOfTwo(x) {
    --x;
    for (let i = 1; i < 32; i <<= 1) {
        x = x | (x >> i);
    }
    return x + 1;
}
/**
 * Returns the input number if a power of two, otherwise the next highest power of two
 */
function ensurePowerOfTwo(x) {
    if (!isPowerOfTwo(x)) {
        return nextHighestPowerOfTwo(x);
    }
    return x;
}

;// CONCATENATED MODULE: ./Graphics/Context/texture-loader.ts

/**
 * Manages loading image sources into webgl textures, a unique id is associated with all sources
 */
class TextureLoader {
    static registerContext(context) {
        TextureLoader._GL = context;
    }
    /**
     * Get the WebGL Texture from a source image
     * @param image
     */
    static get(image) {
        return TextureLoader._TEXTURE_MAP.get(image);
    }
    /**
     * Returns whether a source image has been loaded as a texture
     * @param image
     */
    static has(image) {
        return TextureLoader._TEXTURE_MAP.has(image);
    }
    /**
     * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered
     * @param image Source graphic
     * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed
     */
    static load(image, forceUpdate = false) {
        // Ignore loading if webgl is not registered
        const gl = TextureLoader._GL;
        if (!gl) {
            return null;
        }
        let tex = null;
        // If reuse the texture if it's from the same source
        if (TextureLoader.has(image)) {
            tex = TextureLoader.get(image);
        }
        // Update existing webgl texture and return early
        if (tex) {
            if (forceUpdate) {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                const source = TextureLoader.toPowerOfTwoImage(image);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
            }
            return tex;
        }
        // No texture exists create a new one
        tex = gl.createTexture();
        const source = TextureLoader.toPowerOfTwoImage(image);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // NEAREST for pixels
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
        TextureLoader._TEXTURE_MAP.set(image, tex);
        return tex;
    }
    /**
     * Converts source images into power of two images, WebGL only supports POT images
     * https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
     * @param image
     */
    static toPowerOfTwoImage(image) {
        const potCanvas = TextureLoader._POT_CANVAS;
        const potCtx = TextureLoader._POT_CTX;
        if (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height)) {
            // Scale up the texture to the next highest power of two dimensions.
            potCanvas.width = ensurePowerOfTwo(image.width);
            potCanvas.height = ensurePowerOfTwo(image.height);
            potCtx.imageSmoothingEnabled = false;
            potCtx.clearRect(0, 0, potCanvas.width, potCanvas.height);
            potCtx.drawImage(image, 0, 0, image.width, image.height);
            image = potCanvas;
        }
        return image;
    }
}
TextureLoader._POT_CANVAS = document.createElement('canvas');
TextureLoader._POT_CTX = TextureLoader._POT_CANVAS.getContext('2d');
TextureLoader._TEXTURE_MAP = new Map();

;// CONCATENATED MODULE: ./Graphics/Context/image-renderer.ts









class BatchImage extends BatchCommand {
    constructor(maxDraws, maxTextures) {
        super(maxDraws);
        this.maxDraws = maxDraws;
        this.maxTextures = maxTextures;
        this.textures = [];
        this.commands = [];
        this._graphicMap = {};
    }
    isFull() {
        if (this.commands.length >= this.maxDraws) {
            return true;
        }
        if (this.textures.length >= this.maxTextures) {
            return true;
        }
        return false;
    }
    canAdd() {
        if (this.commands.length >= this.maxDraws) {
            return false;
        }
        if (this.textures.length < this.maxTextures) {
            return true;
        }
        return false;
    }
    _isCommandFull() {
        return this.commands.length >= this.maxDraws;
    }
    _isTextureFull() {
        return this.textures.length >= this.maxTextures;
    }
    _wouldAddTexture(command) {
        return !this._graphicMap[command.image.id];
    }
    maybeAdd(command) {
        if ((this._isCommandFull() || this._isTextureFull()) && this._wouldAddTexture(command)) {
            return false;
        }
        this.add(command);
        return true;
    }
    add(command) {
        if (command.type === DrawCommandType.Image) {
            const texture = TextureLoader.load(command.image);
            if (this.textures.indexOf(texture) === -1) {
                this.textures.push(texture);
            }
        }
        this.commands.push(command);
    }
    bindTextures(gl) {
        // Bind textures in the correct order
        for (let i = 0; i < this.maxTextures; i++) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, this.textures[i] || this.textures[0]);
        }
    }
    getBatchTextureId(command) {
        if (command.image) {
            return this.textures.indexOf(TextureLoader.get(command.image));
        }
        return -1;
    }
    dispose() {
        this.clear();
        return this;
    }
    clear() {
        this.commands.length = 0;
        this.textures.length = 0;
        this._graphicMap = {};
    }
}
class ImageRenderer extends BatchRenderer {
    constructor(gl, _contextInfo) {
        super({
            gl,
            command: DrawImageCommand,
            // 6 verts per quad
            verticesPerCommand: 6,
            maxCommandsPerBatch: 2000,
            batchFactory: () => new BatchImage(2000, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS))
        });
        this._contextInfo = _contextInfo;
        TextureLoader.registerContext(gl);
        this.init();
    }
    buildShader(gl) {
        // Initialilze default batch rendering shader
        const maxGPUTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        const shader = new Shader(gl, image_vertex, this._transformFragmentSource(image_fragment, maxGPUTextures));
        shader.addAttribute('a_position', 3, gl.FLOAT);
        shader.addAttribute('a_texcoord', 2, gl.FLOAT);
        shader.addAttribute('a_textureIndex', 1, gl.FLOAT);
        shader.addAttribute('a_opacity', 1, gl.FLOAT);
        shader.addAttribute('a_color', 4, gl.FLOAT);
        shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);
        // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]
        shader.addUniformIntegerArray('u_textures', [...Array(maxGPUTextures)].map((_, i) => i));
        return shader;
    }
    _transformFragmentSource(source, maxTextures) {
        let newSource = source.replace('%%count%%', maxTextures.toString());
        let texturePickerBuilder = '';
        for (let i = 0; i < maxTextures; i++) {
            if (i === 0) {
                texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\n`;
            }
            else {
                texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\n`;
            }
            texturePickerBuilder += `      color = texture2D(u_textures[${i}], v_texcoord);\n`;
            texturePickerBuilder += `   }\n`;
        }
        newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);
        return newSource;
    }
    addCircle(pos, radius, color) {
        const command = this.commands.get().initCircle(pos, radius, color);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    addRectangle(color, pos, width, height) {
        const command = this.commands.get().initRect(color, pos, width, height);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    addLine(color, start, end, thickness = 1) {
        const command = this.commands.get().initLine(color, start, end, thickness);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    addImage(graphic, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        const command = this.commands.get().init(graphic, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    renderBatch(gl, batch, vertexCount) {
        // Bind textures in the correct order
        batch.bindTextures(gl);
        // draw the quads
        gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
    }
    buildBatchVertices(vertexBuffer, batch) {
        var _a, _b;
        let vertIndex = 0;
        let sx = 0;
        let sy = 0;
        let sw = 0;
        let sh = 0;
        let potWidth = 1;
        let potHeight = 1;
        let textureId = 0;
        let commandColor = Color.Transparent;
        for (const command of batch.commands) {
            sx = command.view[0];
            sy = command.view[1];
            sw = command.view[2];
            sh = command.view[3];
            potWidth = ensurePowerOfTwo(((_a = command.image) === null || _a === void 0 ? void 0 : _a.width) || command.width);
            potHeight = ensurePowerOfTwo(((_b = command.image) === null || _b === void 0 ? void 0 : _b.height) || command.height);
            textureId = batch.getBatchTextureId(command);
            if (command.type === DrawCommandType.Line || command.type === DrawCommandType.Rectangle) {
                textureId = -1; // sentinel for no image rect
                commandColor = command.color;
            }
            if (command.type === DrawCommandType.Circle) {
                textureId = -2; // sentinel for circle
                commandColor = command.color;
            }
            // potential optimization when divding by 2 (bitshift)
            // Modifying the images to poweroftwo images warp the UV coordinates
            let uvx0 = sx / potWidth;
            let uvy0 = sy / potHeight;
            let uvx1 = (sx + sw) / potWidth;
            let uvy1 = (sy + sh) / potHeight;
            if (textureId === -2) {
                uvx0 = 0;
                uvy0 = 0;
                uvx1 = 1;
                uvy1 = 1;
            }
            // Quad update
            // (0, 0, z) z-index doesn't work in batch rendering between batches
            vertexBuffer[vertIndex++] = command.geometry[0][0]; // x + 0 * width;
            vertexBuffer[vertIndex++] = command.geometry[0][1]; //y + 0 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx0; // 0;
            vertexBuffer[vertIndex++] = uvy0; // 0;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (0, 1)
            vertexBuffer[vertIndex++] = command.geometry[1][0]; // x + 0 * width;
            vertexBuffer[vertIndex++] = command.geometry[1][1]; // y + 1 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx0; // 0;
            vertexBuffer[vertIndex++] = uvy1; // 1;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (1, 0)
            vertexBuffer[vertIndex++] = command.geometry[2][0]; // x + 1 * width;
            vertexBuffer[vertIndex++] = command.geometry[2][1]; // y + 0 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx1; //1;
            vertexBuffer[vertIndex++] = uvy0; //0;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (1, 0)
            vertexBuffer[vertIndex++] = command.geometry[3][0]; // x + 1 * width;
            vertexBuffer[vertIndex++] = command.geometry[3][1]; // y + 0 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx1; //1;
            vertexBuffer[vertIndex++] = uvy0; //0;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (0, 1)
            vertexBuffer[vertIndex++] = command.geometry[4][0]; // x + 0 * width;
            vertexBuffer[vertIndex++] = command.geometry[4][1]; // y + 1 * height
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx0; // 0;
            vertexBuffer[vertIndex++] = uvy1; // 1;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (1, 1)
            vertexBuffer[vertIndex++] = command.geometry[5][0]; // x + 1 * width;
            vertexBuffer[vertIndex++] = command.geometry[5][1]; // y + 1 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx1; // 1;
            vertexBuffer[vertIndex++] = uvy1; // 1;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
        }
        return vertIndex / this.vertexSize;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shaders/point-vertex.glsl
/* harmony default export */ const point_vertex = ("attribute vec4 a_position;\r\nattribute vec4 a_color;\r\nattribute float a_size;\r\nvarying lowp vec4 v_color;\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n  gl_Position = u_matrix * a_position;\r\n  gl_PointSize = a_size * 2.0;\r\n  v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/shaders/point-fragment.glsl
/* harmony default export */ const point_fragment = ("#ifdef GL_OES_standard_derivatives\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nprecision mediump float;\r\nvarying lowp vec4 v_color;\r\n\r\nvoid main() {\r\n  float r = 0.0, delta = 0.0, alpha = 1.0;\r\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\r\n  r = dot(cxy, cxy);\r\n  \r\n#ifdef GL_OES_standard_derivatives\r\n  delta = fwidth(r);\r\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\r\n#else\r\n  if (r > 1.0) {\r\n    discard;\r\n  }\r\n#endif\r\n  gl_FragColor = vec4(v_color.rgb, v_color.a * alpha);\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/point-renderer.ts






// import { Random } from '../../Math/Index';
class DrawPoint {
    constructor() {
        this.point = Vector.Zero;
        this.color = Color.Black;
        this.size = 1;
    }
    dispose() {
        this.point.setTo(0, 0);
        this.color.r = 0;
        this.color.g = 0;
        this.color.b = 0;
        this.color.a = 1;
        this.size = 1;
        return this;
    }
}
class PointRenderer extends BatchRenderer {
    constructor(gl, _contextInfo) {
        super({ gl, command: DrawPoint, verticesPerCommand: 1 });
        this._contextInfo = _contextInfo;
        this.init();
    }
    buildShader(gl) {
        gl.getExtension('OES_standard_derivatives');
        const shader = new Shader(gl, point_vertex, point_fragment);
        shader.addAttribute('a_position', 2, gl.FLOAT);
        shader.addAttribute('a_color', 4, gl.FLOAT);
        shader.addAttribute('a_size', 1, gl.FLOAT);
        shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);
        return shader;
    }
    addPoint(point, color, size) {
        const cmd = this.commands.get();
        cmd.point = this._contextInfo.transform.current.multv(point);
        cmd.color.r = color.r;
        cmd.color.g = color.g;
        cmd.color.b = color.b;
        cmd.color.a = color.a * this._contextInfo.state.current.opacity;
        cmd.size = size * Math.max(this._contextInfo.transform.current.getScaleX(), this._contextInfo.transform.current.getScaleY());
        this.addCommand(cmd);
    }
    buildBatchVertices(vertexBuffer, batch) {
        let index = 0;
        for (const command of batch.commands) {
            vertexBuffer[index++] = command.point.x;
            vertexBuffer[index++] = command.point.y;
            // normalize to [0, 1] for webgl
            vertexBuffer[index++] = command.color.r / 255;
            vertexBuffer[index++] = command.color.g / 255;
            vertexBuffer[index++] = command.color.b / 255;
            vertexBuffer[index++] = command.color.a;
            vertexBuffer[index++] = command.size;
        }
        return index / this.vertexSize;
    }
    renderBatch(gl, _batch, vertexCount) {
        gl.drawArrays(gl.POINTS, 0, vertexCount);
    }
}

;// CONCATENATED MODULE: ./Graphics/Graphic.ts


/**
 * A Graphic is the base Excalibur primitive for something that can be drawn to the [[ExcaliburGraphicsContext]].
 * [[Sprite]], [[Animation]], [[GraphicsGroup]], [[Canvas]], [[Rectangle]], [[Circle]], and [[Polygon]] all derive from the
 * [[Graphic]] abstract class.
 *
 * Implementors of a Graphic must override the abstract [[Graphic._drawImage]] method to render an image to the graphics context. Graphic
 * handles all the position, rotation, and scale transformations in [[Graphic._preDraw]] and [[Graphic._postDraw]]
 */
class Graphic {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        this.id = Graphic._ID++;
        /**
         * Gets or sets wether to show debug information about the graphic
         */
        this.showDebug = false;
        /**
         * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)
         */
        this.flipHorizontal = false;
        /**
         * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)
         */
        this.flipVertical = false;
        /**
         * Gets or sets the rotation of the graphic
         */
        this.rotation = 0;
        /**
         * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).
         */
        this.opacity = 1;
        /**
         * Gets or sets the scale of the graphic, this affects the width and
         */
        this.scale = Vector.One;
        /**
         * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin
         */
        this.origin = null;
        this._width = 0;
        this._height = 0;
        if (options) {
            this.origin = (_a = options.origin) !== null && _a !== void 0 ? _a : this.origin;
            this.flipHorizontal = (_b = options.flipHorizontal) !== null && _b !== void 0 ? _b : this.flipHorizontal;
            this.flipVertical = (_c = options.flipVertical) !== null && _c !== void 0 ? _c : this.flipVertical;
            this.rotation = (_d = options.rotation) !== null && _d !== void 0 ? _d : this.rotation;
            this.opacity = (_e = options.opacity) !== null && _e !== void 0 ? _e : this.opacity;
            this.scale = (_f = options.scale) !== null && _f !== void 0 ? _f : this.scale;
        }
    }
    cloneGraphicOptions() {
        return {
            origin: this.origin ? this.origin.clone() : null,
            flipHorizontal: this.flipHorizontal,
            flipVertical: this.flipVertical,
            rotation: this.rotation,
            opacity: this.opacity,
            scale: this.scale ? this.scale.clone() : null
        };
    }
    /**
     * Gets or sets the width of the graphic (always positive)
     */
    get width() {
        return Math.abs(this._width * this.scale.x);
    }
    /**
     * Gets or sets the height of the graphic (always positive)
     */
    get height() {
        return Math.abs(this._height * this.scale.y);
    }
    set width(value) {
        this._width = value;
    }
    set height(value) {
        this._height = value;
    }
    /**
     * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.
     */
    get localBounds() {
        return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);
    }
    /**
     * Draw the whole graphic to the context including transform
     * @param ex The excalibur graphics context
     * @param x
     * @param y
     */
    draw(ex, x, y) {
        this._preDraw(ex, x, y);
        this._drawImage(ex, 0, 0);
        this._postDraw(ex);
    }
    /**
     * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]
     * @param ex
     * @param x
     * @param y
     */
    _preDraw(ex, x, y) {
        ex.save();
        ex.translate(x, y);
        ex.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));
        this._rotate(ex);
        this._flip(ex);
        // it is important to multiply alphas so graphics respect the current context
        ex.opacity = ex.opacity * this.opacity;
    }
    _rotate(ex) {
        var _a;
        const scaleDirX = this.scale.x > 0 ? 1 : -1;
        const scaleDirY = this.scale.y > 0 ? 1 : -1;
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : vec(this.width / 2, this.height / 2);
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()
        ex.scale(scaleDirX, scaleDirY);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, this.height / this.scale.y);
            ex.scale(1, -1);
        }
    }
    /**
     * Apply any addtional work after [[Graphic._drawImage]] and restore the context state.
     * @param ex
     */
    _postDraw(ex) {
        if (this.showDebug) {
            ex.debug.drawRect(0, 0, this.width, this.height);
        }
        ex.restore();
    }
}
Graphic._ID = 0;

;// CONCATENATED MODULE: ./Util/Watch.ts
/**
 * Watch an object with a proxy, only fires if property value is different
 */
function watch(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                if (obj[prop] !== value) {
                    obj[prop] = value;
                    // Avoid watching private junk
                    if (typeof prop === 'string') {
                        if (prop[0] !== '_') {
                            change(obj);
                        }
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}
/**
 * Watch an object with a proxy, fires change on any property value change
 */
function watchAny(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                obj[prop] = value;
                // Avoid watching private junk
                if (typeof prop === 'string') {
                    if (prop[0] !== '_') {
                        change(obj);
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}

;// CONCATENATED MODULE: ./Graphics/Raster.ts







/**
 * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the
 * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.
 *
 * Implementors must implemenet the [[Raster.execute]] method to rasterize their drawing.
 */
class Raster extends Graphic {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        super(options);
        this._dirty = true;
        this._smoothing = false;
        this._color = watch(Color.Black, () => this.flagDirty());
        this._lineWidth = 1;
        this._lineDash = [];
        this._padding = 0;
        if (options) {
            this.color = (_a = options.color) !== null && _a !== void 0 ? _a : Color.Black;
            this.strokeColor = options === null || options === void 0 ? void 0 : options.strokeColor;
            this.smoothing = (_b = options.smoothing) !== null && _b !== void 0 ? _b : this.smoothing;
            this.lineWidth = (_c = options.lineWidth) !== null && _c !== void 0 ? _c : this.lineWidth;
            this.lineDash = (_d = options.lineDash) !== null && _d !== void 0 ? _d : this.lineDash;
            this.padding = (_e = options.padding) !== null && _e !== void 0 ? _e : this.padding;
        }
        this._bitmap = document.createElement('canvas');
        // get the default canvas width/height as a fallback
        const bitmapWidth = (_f = options === null || options === void 0 ? void 0 : options.width) !== null && _f !== void 0 ? _f : this._bitmap.width;
        const bitmapHeight = (_g = options === null || options === void 0 ? void 0 : options.height) !== null && _g !== void 0 ? _g : this._bitmap.height;
        // Rasters use power of two images as an optimization for webgl
        this.width = ensurePowerOfTwo(bitmapWidth);
        this.height = ensurePowerOfTwo(bitmapHeight);
        const maybeCtx = this._bitmap.getContext('2d');
        if (!maybeCtx) {
            /* istanbul ignore next */
            throw new Error('Browser does not support 2d canvas drawing, cannot create Raster graphic');
        }
        else {
            this._ctx = maybeCtx;
        }
    }
    cloneRasterOptions() {
        return {
            color: this.color ? this.color.clone() : null,
            strokeColor: this.strokeColor ? this.strokeColor.clone() : null,
            smoothing: this.smoothing,
            lineWidth: this.lineWidth,
            lineDash: this.lineDash,
            padding: this.padding
        };
    }
    /**
     * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized
     */
    get dirty() {
        return this._dirty;
    }
    /**
     * Flags the graphic as dirty, meaning it must be re-rasterized before draw.
     * This should be called any time the graphics state changes such that it affects the outputed drawing
     */
    flagDirty() {
        this._dirty = true;
    }
    /**
     * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding`s set will be factored into the width
     */
    get width() {
        return this._getTotalWidth();
    }
    set width(value) {
        this._bitmap.width = value;
        this._originalWidth = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding` set will be factored into the height
     */
    get height() {
        return this._getTotalHeight();
    }
    set height(value) {
        this._bitmap.height = value;
        this._originalHeight = value;
        this.flagDirty();
    }
    _getTotalWidth() {
        var _a;
        return ((_a = this._originalWidth) !== null && _a !== void 0 ? _a : this._bitmap.width) + this.padding * 2;
    }
    _getTotalHeight() {
        var _a;
        return ((_a = this._originalHeight) !== null && _a !== void 0 ? _a : this._bitmap.height) + this.padding * 2;
    }
    /**
     * Returns the local bounds of the Raster including the padding
     */
    get localBounds() {
        return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);
    }
    /**
     * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     */
    get smoothing() {
        return this._smoothing;
    }
    set smoothing(value) {
        this._smoothing = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get color() {
        return this._color;
    }
    set color(value) {
        var _a;
        if (!((_a = this._color) === null || _a === void 0 ? void 0 : _a.equal(value))) {
            this.flagDirty();
        }
        this._color = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get strokeColor() {
        return this._strokeColor;
    }
    set strokeColor(value) {
        var _a;
        if (!((_a = this._strokeColor) === null || _a === void 0 ? void 0 : _a.equal(value))) {
            this.flagDirty();
        }
        this._strokeColor = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get lineWidth() {
        return this._lineWidth;
    }
    set lineWidth(value) {
        this._lineWidth = value;
        this.flagDirty();
    }
    get lineDash() {
        return this._lineDash;
    }
    set lineDash(value) {
        this._lineDash = value;
        this.flagDirty();
    }
    get padding() {
        return this._padding;
    }
    set padding(value) {
        this._padding = value;
        this.flagDirty();
    }
    /**
     * Rasterize the graphic to a bitmap making it usuable as in excalibur. Rasterize is called automatically if
     * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call
     */
    rasterize() {
        this._dirty = false;
        this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());
        this._ctx.save();
        this._applyRasterProperites(this._ctx);
        this.execute(this._ctx);
        this._ctx.restore();
        // The webgl texture needs to be updated if it exists after a raster cycle
        TextureLoader.load(this._bitmap, true);
    }
    _applyRasterProperites(ctx) {
        var _a, _b, _c;
        this._bitmap.width = this._getTotalWidth();
        this._bitmap.height = this._getTotalHeight();
        ctx.translate(this.padding, this.padding);
        ctx.imageSmoothingEnabled = this.smoothing;
        ctx.lineWidth = this.lineWidth;
        ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());
        ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();
        ctx.fillStyle = (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();
    }
    _drawImage(ex, x, y) {
        if (this._dirty) {
            this.rasterize();
        }
        ex.drawImage(this._bitmap, x, y);
    }
}

;// CONCATENATED MODULE: ./Graphics/Canvas.ts

/**
 * A canvas [[Graphic]] to provide an adapter between the 2D Canvas API and the [[ExcaliburGraphicsContext]].
 *
 * The [[Canvas]] works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed
 * to the [[ExcaliburGraphicsContext]] implementation as a rendered image.
 *
 * **Low performance API**
 */
class Canvas extends Raster {
    constructor(_options) {
        super(_options);
        this._options = _options;
    }
    /**
     * Return the 2D graphics context of this canvas
     */
    get ctx() {
        return this._ctx;
    }
    clone() {
        return new Canvas(Object.assign(Object.assign(Object.assign({}, this._options), this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        var _a, _b;
        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.draw) {
            (_b = this._options) === null || _b === void 0 ? void 0 : _b.draw(ctx);
        }
        if (!this._options.cache) {
            this.flagDirty();
        }
    }
}

;// CONCATENATED MODULE: ./Events.ts
var EventTypes;
(function (EventTypes) {
    EventTypes["Kill"] = "kill";
    EventTypes["PreKill"] = "prekill";
    EventTypes["PostKill"] = "postkill";
    EventTypes["PreDraw"] = "predraw";
    EventTypes["PostDraw"] = "postdraw";
    EventTypes["PreDebugDraw"] = "predebugdraw";
    EventTypes["PostDebugDraw"] = "postdebugdraw";
    EventTypes["PreUpdate"] = "preupdate";
    EventTypes["PostUpdate"] = "postupdate";
    EventTypes["PreFrame"] = "preframe";
    EventTypes["PostFrame"] = "postframe";
    EventTypes["PreCollision"] = "precollision";
    EventTypes["CollisionStart"] = "collisionstart";
    EventTypes["CollisionEnd"] = "collisionend";
    EventTypes["PostCollision"] = "postcollision";
    EventTypes["Initialize"] = "initialize";
    EventTypes["Activate"] = "activate";
    EventTypes["Deactivate"] = "deactivate";
    EventTypes["ExitViewport"] = "exitviewport";
    EventTypes["EnterViewport"] = "enterviewport";
    EventTypes["ExitTrigger"] = "exit";
    EventTypes["EnterTrigger"] = "enter";
    EventTypes["Connect"] = "connect";
    EventTypes["Disconnect"] = "disconnect";
    EventTypes["Button"] = "button";
    EventTypes["Axis"] = "axis";
    EventTypes["Subscribe"] = "subscribe";
    EventTypes["Unsubscribe"] = "unsubscribe";
    EventTypes["Visible"] = "visible";
    EventTypes["Hidden"] = "hidden";
    EventTypes["Start"] = "start";
    EventTypes["Stop"] = "stop";
    EventTypes["PointerUp"] = "pointerup";
    EventTypes["PointerDown"] = "pointerdown";
    EventTypes["PointerMove"] = "pointermove";
    EventTypes["PointerEnter"] = "pointerenter";
    EventTypes["PointerLeave"] = "pointerleave";
    EventTypes["PointerCancel"] = "pointercancel";
    EventTypes["PointerWheel"] = "pointerwheel";
    EventTypes["Up"] = "up";
    EventTypes["Down"] = "down";
    EventTypes["Move"] = "move";
    EventTypes["Enter"] = "enter";
    EventTypes["Leave"] = "leave";
    EventTypes["Cancel"] = "cancel";
    EventTypes["Wheel"] = "wheel";
    EventTypes["Press"] = "press";
    EventTypes["Release"] = "release";
    EventTypes["Hold"] = "hold";
    EventTypes["PointerDragStart"] = "pointerdragstart";
    EventTypes["PointerDragEnd"] = "pointerdragend";
    EventTypes["PointerDragEnter"] = "pointerdragenter";
    EventTypes["PointerDragLeave"] = "pointerdragleave";
    EventTypes["PointerDragMove"] = "pointerdragmove";
})(EventTypes || (EventTypes = {}));
/**
 * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,
 * some events are unique to a type, others are not.
 *
 */
class GameEvent {
    constructor() {
        this._bubbles = true;
    }
    /**
     * If set to false, prevents event from propagating to other actors. If true it will be propagated
     * to all actors that apply.
     */
    get bubbles() {
        return this._bubbles;
    }
    set bubbles(value) {
        this._bubbles = value;
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        this.bubbles = false;
    }
}
/**
 * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.
 */
class KillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'prekill' event is emitted directly before an actor is killed.
 */
class PreKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'postkill' event is emitted directly after the actor is killed.
 */
class PostKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'start' event is emitted on engine when has started and is ready for interaction.
 */
class GameStartEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.
 */
class GameStopEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PreDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PostDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.
 */
class PreDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.
 */
class PostDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.
 */
class PreUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.
 */
class PostUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'preframe' event is emitted on the engine, before the frame begins.
 */
class PreFrameEvent extends GameEvent {
    constructor(engine, prevStats) {
        super();
        this.engine = engine;
        this.prevStats = prevStats;
        this.target = engine;
    }
}
/**
 * The 'postframe' event is emitted on the engine, after a frame ends.
 */
class PostFrameEvent extends GameEvent {
    constructor(engine, stats) {
        super();
        this.engine = engine;
        this.stats = stats;
        this.target = engine;
    }
}
/**
 * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.
 */
class GamepadConnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.
 */
class GamepadDisconnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadButtonEvent extends GameEvent {
    /**
     * @param button  The Gamepad button
     * @param value   A numeric value between 0 and 1
     */
    constructor(button, value, target) {
        super();
        this.button = button;
        this.value = value;
        this.target = target;
    }
}
/**
 * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadAxisEvent extends GameEvent {
    /**
     * @param axis  The Gamepad axis
     * @param value A numeric value between -1 and 1
     */
    constructor(axis, value, target) {
        super();
        this.axis = axis;
        this.value = value;
        this.target = target;
    }
}
/**
 * Subscribe event thrown when handlers for events other than subscribe are added. Meta event that is received by
 * [[EventDispatcher|event dispatchers]].
 */
class SubscribeEvent extends GameEvent {
    constructor(topic, handler) {
        super();
        this.topic = topic;
        this.handler = handler;
    }
}
/**
 * Unsubscribe event thrown when handlers for events other than unsubscribe are removed. Meta event that is received by
 * [[EventDispatcher|event dispatchers]].
 */
class UnsubscribeEvent extends GameEvent {
    constructor(topic, handler) {
        super();
        this.topic = topic;
        this.handler = handler;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is visible on a screen.
 */
class VisibleEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is hidden from all screens.
 */
class HiddenEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves
 */
class PreCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that will collided with the current actor
     * @param side          The side that will be collided with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame
 */
class PostCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that did collide with the current actor
     * @param side          The side that did collide with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
class ContactStartEvent {
    constructor(target, other, contact) {
        this.target = target;
        this.other = other;
        this.contact = contact;
    }
}
class ContactEndEvent {
    constructor(target, other) {
        this.target = target;
        this.other = other;
    }
}
class CollisionPreSolveEvent {
    constructor(target, other, side, intersection, contact) {
        this.target = target;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
class CollisionPostSolveEvent {
    constructor(target, other, side, intersection, contact) {
        this.target = target;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
/**
 * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.
 */
class CollisionStartEvent extends GameEvent {
    /**
     *
     * @param actor
     * @param other
     * @param contact
     */
    constructor(actor, other, contact) {
        super();
        this.other = other;
        this.contact = contact;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown when the [[Actor|actor]] is no longer colliding with another
 */
class CollisionEndEvent extends GameEvent {
    /**
     *
     */
    constructor(actor, other) {
        super();
        this.other = other;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call
 */
class InitializeEvent extends GameEvent {
    /**
     * @param engine  The reference to the current engine
     */
    constructor(engine, target) {
        super();
        this.engine = engine;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on activation
 */
class ActivateEvent extends GameEvent {
    /**
     * @param oldScene  The reference to the old scene
     */
    constructor(oldScene, target) {
        super();
        this.oldScene = oldScene;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on deactivation
 */
class DeactivateEvent extends GameEvent {
    /**
     * @param newScene  The reference to the new scene
     */
    constructor(newScene, target) {
        super();
        this.newScene = newScene;
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class ExitViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class EnterViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
class EnterTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}
class ExitTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}

;// CONCATENATED MODULE: ./EventDispatcher.ts

class EventDispatcher {
    /**
     * @param target  The object that will be the recipient of events from this event dispatcher
     */
    constructor(target) {
        this._handlers = {};
        this._wiredEventDispatchers = [];
        this._target = target;
    }
    /**
     * Clears any existing handlers or wired event dispatchers on this event dispatcher
     */
    clear() {
        this._handlers = {};
        this._wiredEventDispatchers = [];
    }
    /**
     * Emits an event for target
     * @param eventName  The name of the event to publish
     * @param event      Optionally pass an event data object to the handler
     */
    emit(eventName, event) {
        if (!eventName) {
            // key not mapped
            return;
        }
        eventName = eventName.toLowerCase();
        const target = this._target;
        if (!event) {
            event = new GameEvent();
        }
        try {
            if (!event.target) {
                event.target = target;
            }
        }
        catch (_a) {
            // pass
        }
        let i, len;
        if (this._handlers[eventName]) {
            i = 0;
            len = this._handlers[eventName].length;
            for (i; i < len; i++) {
                this._handlers[eventName][i].call(target, event);
            }
        }
        i = 0;
        len = this._wiredEventDispatchers.length;
        for (i; i < len; i++) {
            this._wiredEventDispatchers[i].emit(eventName, event);
        }
    }
    /**
     * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
     * @param eventName  The name of the event to subscribe to
     * @param handler    The handler callback to fire on this event
     */
    on(eventName, handler) {
        eventName = eventName.toLowerCase();
        if (!this._handlers[eventName]) {
            this._handlers[eventName] = [];
        }
        this._handlers[eventName].push(handler);
        // meta event handlers
        if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
            this.emit('subscribe', new SubscribeEvent(eventName, handler));
        }
    }
    /**
     * Unsubscribe an event handler(s) from an event. If a specific handler
     * is specified for an event, only that handler will be unsubscribed.
     * Otherwise all handlers will be unsubscribed for that event.
     *
     * @param eventName  The name of the event to unsubscribe
     * @param handler    Optionally the specific handler to unsubscribe
     */
    off(eventName, handler) {
        eventName = eventName.toLowerCase();
        const eventHandlers = this._handlers[eventName];
        if (eventHandlers) {
            // if no explicit handler is give with the event name clear all handlers
            if (!handler) {
                this._handlers[eventName].length = 0;
            }
            else {
                const index = eventHandlers.indexOf(handler);
                this._handlers[eventName].splice(index, 1);
            }
        }
        // meta event handlers
        if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
            this.emit('unsubscribe', new UnsubscribeEvent(eventName, handler));
        }
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        const metaHandler = (event) => {
            const ev = event || new GameEvent();
            try {
                ev.target = ev.target || this._target;
            }
            catch (_a) {
                // pass
            }
            this.off(eventName, handler);
            handler.call(ev.target, ev);
        };
        this.on(eventName, metaHandler);
    }
    /**
     * Wires this event dispatcher to also receive events from another
     */
    wire(eventDispatcher) {
        eventDispatcher._wiredEventDispatchers.push(this);
    }
    /**
     * Unwires this event dispatcher from another
     */
    unwire(eventDispatcher) {
        const index = eventDispatcher._wiredEventDispatchers.indexOf(this);
        if (index > -1) {
            eventDispatcher._wiredEventDispatchers.splice(index, 1);
        }
    }
}

;// CONCATENATED MODULE: ./Resources/Resource.ts


/**
 * The [[Resource]] type allows games built in Excalibur to load generic resources.
 * For any type of remote resource it is recommended to use [[Resource]] for preloading.
 */
class Resource {
    /**
     * @param path          Path to the remote resource
     * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
     * @param bustCache     Whether or not to cache-bust requests
     */
    constructor(path, responseType, bustCache = true) {
        this.path = path;
        this.responseType = responseType;
        this.bustCache = bustCache;
        this.data = null;
        this.logger = Logger.getInstance();
        this.events = new EventDispatcher(this);
    }
    /**
     * Returns true if the Resource is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return this.data !== null;
    }
    _cacheBust(uri) {
        const query = /\?\w*=\w*/;
        if (query.test(uri)) {
            uri += '&__=' + Date.now();
        }
        else {
            uri += '?__=' + Date.now();
        }
        return uri;
    }
    /**
     * Begin loading the resource and returns a promise to be resolved on completion
     */
    load() {
        return new Promise((resolve, reject) => {
            // Exit early if we already have data
            if (this.data !== null) {
                this.logger.debug('Already have data for resource', this.path);
                this.events.emit('complete', this.data);
                resolve(this.data);
                return;
            }
            const request = new XMLHttpRequest();
            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.addEventListener('loadstart', (e) => this.events.emit('loadstart', e));
            request.addEventListener('progress', (e) => this.events.emit('progress', e));
            request.addEventListener('error', (e) => this.events.emit('error', e));
            request.addEventListener('load', (e) => this.events.emit('load', e));
            request.addEventListener('load', () => {
                // XHR on file:// success status is 0, such as with PhantomJS
                if (request.status !== 0 && request.status !== 200) {
                    this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);
                    this.events.emit('error', request.response);
                    reject(new Error(request.statusText));
                    return;
                }
                this.data = request.response;
                this.events.emit('complete', this.data);
                this.logger.debug('Completed loading resource', this.path);
                resolve(this.data);
            });
            request.send();
        });
    }
}

;// CONCATENATED MODULE: ./Drawing/SpriteEffects.ts
/**
 * @module
 * @deprecated
 * These effects can be applied to any bitmap image but are mainly used
 * for [[Sprite]] effects or [[Animation]] effects.
 */
var SpriteEffects_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * @typedoc
 */


/**
 * Applies the "Grayscale" effect to a sprite, removing color information.
 * @deprecated [[Grayscale]] will be removed in v0.26.0
 */
let Grayscale = class Grayscale {
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
        pixel[firstPixel + 0] = avg;
        pixel[firstPixel + 1] = avg;
        pixel[firstPixel + 2] = avg;
    }
};
Grayscale = SpriteEffects_decorate([
    obsolete({
        message: 'Grayscale will be removed in v0.26.0'
    })
], Grayscale);

/**
 * Applies the "Invert" effect to a sprite, inverting the pixel colors.
 * @deprecated [[Invert]] will be removed in v0.26.0
 */
let Invert = class Invert {
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
        pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
        pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
    }
};
Invert = SpriteEffects_decorate([
    obsolete({
        message: 'Invert will be removed in v0.26.0'
    })
], Invert);

/**
 * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
 * @deprecated [[Opacity]] will be removed in v0.26.0
 */
let Opacity = class Opacity {
    /**
     * @param opacity  The new opacity of the sprite from 0-1.0
     */
    constructor(opacity) {
        this.opacity = opacity;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 3] = Math.round(this.opacity * pixel[firstPixel + 3]);
        }
    }
};
Opacity = SpriteEffects_decorate([
    obsolete({
        message: 'Opacity will be removed in v0.26.0'
    })
], Opacity);

/**
 * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
 * average of the original color and the provided color
 * @deprecated [[Colorize]] will be removed in v0.26.0
 */
let Colorize = class Colorize {
    /**
     * @param color  The color to apply to the sprite
     */
    constructor(color) {
        this.color = color;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
            pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
            pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
        }
    }
};
Colorize = SpriteEffects_decorate([
    obsolete({
        message: 'Colorize will be removed in v0.26.0'
    })
], Colorize);

/**
 * Applies the "Lighten" effect to a sprite, changes the lightness of the color according to HSL
 * @deprecated [[Lighten]] will be removed in v0.26.0
 */
let Lighten = class Lighten {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).lighten(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Lighten = SpriteEffects_decorate([
    obsolete({
        message: 'Lighten will be removed in v0.26.0'
    })
], Lighten);

/**
 * Applies the "Darken" effect to a sprite, changes the darkness of the color according to HSL
 * @deprecated [[Darken]] will be removed in v0.26.0
 */
let Darken = class Darken {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).darken(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Darken = SpriteEffects_decorate([
    obsolete({
        message: 'Darken will be removed v0.26.0'
    })
], Darken);

/**
 * Applies the "Saturate" effect to a sprite, saturates the color according to HSL
 * @deprecated [[Saturate]] will be removed in v0.26.0
 */
let Saturate = class Saturate {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).saturate(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Saturate = SpriteEffects_decorate([
    obsolete({
        message: 'Saturate will be removed in v0.26.0'
    })
], Saturate);

/**
 * Applies the "Desaturate" effect to a sprite, desaturates the color according to HSL
 * @deprecated [[Desaturate]] will be removed in v0.26.0
 */
let Desaturate = class Desaturate {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).desaturate(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Desaturate = SpriteEffects_decorate([
    obsolete({
        message: 'Desaturate will be removed in v0.26.0'
    })
], Desaturate);

/**
 * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
 * a given color
 * @deprecated [[Fill]] will be removed in v0.26.0
 */
let Fill = class Fill {
    /**
     * @param color  The color to apply to the sprite
     */
    constructor(color) {
        this.color = color;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 0] = this.color.r;
            pixel[firstPixel + 1] = this.color.g;
            pixel[firstPixel + 2] = this.color.b;
        }
    }
};
Fill = SpriteEffects_decorate([
    obsolete({
        message: 'Fill will be removed in v0.26.0'
    })
], Fill);


;// CONCATENATED MODULE: ./Drawing/Texture.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


/**
 * The [[Texture]] object allows games built in Excalibur to load image resources.
 * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]
 * to pre-load before starting a level or game.
 * @deprecated
 */
class Texture {
    /**
     * @param path       Path to the image resource or a base64 string representing an image "data:image/png;base64,iVB..."
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, bustCache = true) {
        this.path = path;
        this.bustCache = bustCache;
        this._sprite = null;
        this.loaded = new Promise(resolve => {
            this._loadedResolve = resolve;
        });
        this._resource = new Resource(path, 'blob', bustCache);
        this._sprite = new Sprite_Sprite(this, 0, 0, 0, 0);
    }
    get image() {
        return this.data;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return !!this.data;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Load base64 or blob if needed
                let url;
                if (!this.path.includes('data:image/')) {
                    const blob = yield this._resource.load();
                    url = URL.createObjectURL(blob);
                }
                else {
                    url = this.path;
                }
                // Decode the image
                const image = new Image();
                image.src = url;
                yield image.decode();
                // Set results
                this.data = image;
                this.width = this._sprite.width = image.naturalWidth;
                this.height = this._sprite.height = image.naturalHeight;
                this._sprite = new Sprite_Sprite(this, 0, 0, this.width, this.height);
            }
            catch (_a) {
                yield Promise.reject('Error loading texture');
            }
            // todo emit complete
            this._loadedResolve(this.data);
            return this.data;
        });
    }
    asSprite() {
        return this._sprite;
    }
}

;// CONCATENATED MODULE: ./Configurable.ts
/**
 * Configurable helper extends base type and makes all properties available as option bag arguments
 * @internal
 * @param base
 */
function Configurable(base) {
    return class extends base {
        assign(props) {
            //set the value of every property that was passed in,
            //if the constructor previously set this value, it will be overridden here
            for (const k in props) {
                // eslint-disable-next-line
                if (typeof this[k] !== 'function') {
                    // eslint-disable-next-line
                    this[k] = props[k];
                }
            }
        }
        constructor(...args) {
            super(...args);
            //get the number of arguments that aren't undefined. TS passes a value to all parameters
            //of whatever ctor is the implementation, so args.length doesn't work here.
            const size = args.filter(function (value) {
                return value !== undefined;
            }).length;
            if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {
                this.assign(args[0]);
            }
        }
    };
}

;// CONCATENATED MODULE: ./Drawing/Sprite.ts
var Sprite_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Sprite_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








/**
 * @hidden
 * @deprecated Use [[Sprite]]
 */
class SpriteImpl {
    /**
     * @param imageOrConfig  The backing image texture to build the Sprite, or Sprite option bag
     * @param x      The x position of the sprite
     * @param y      The y position of the sprite
     * @param width  The width of the sprite in pixels
     * @param height The height of the sprite in pixels
     */
    constructor(imageOrConfig, x, y, width, height) {
        this.x = 0;
        this.y = 0;
        this.rotation = 0.0;
        this.anchor = Vector.Half;
        this.offset = Vector.Zero;
        this.scale = Vector.One;
        /**
         * Default: false, should the sprite be drawn around the anchor or from the top left.
         * Sprite rotations/scaling still happen around the anchor regardless of this setting.
         */
        this.drawAroundAnchor = false;
        this.logger = Logger.getInstance();
        /**
         * Draws the sprite flipped vertically
         */
        this.flipVertical = false;
        /**
         * Draws the sprite flipped horizontally
         */
        this.flipHorizontal = false;
        this.effects = [];
        this.width = 0;
        this.height = 0;
        this._spriteCanvas = null;
        this._spriteCtx = null;
        this._pixelData = null;
        this._pixelsLoaded = false;
        this._dirtyEffect = true;
        this._opacity = 1;
        let image = imageOrConfig;
        if (imageOrConfig && !(imageOrConfig instanceof Texture)) {
            x = imageOrConfig.x | 0;
            y = imageOrConfig.y | 0;
            width = imageOrConfig.width | 0;
            height = imageOrConfig.height | 0;
            image = imageOrConfig.image;
            if (!image) {
                const message = 'An image texture is required to construct a sprite';
                throw new Error(message);
            }
        }
        this.x = x || 0;
        this.y = y || 0;
        this.texture = image;
        this._spriteCanvas = document.createElement('canvas');
        this._spriteCanvas.width = width;
        this._spriteCanvas.height = height;
        this._spriteCtx = this._spriteCanvas.getContext('2d');
        this._initPixelsFromTexture();
        this.width = width;
        this.height = height;
    }
    get drawWidth() {
        return Math.abs(this.width * this.scale.x);
    }
    get drawHeight() {
        return Math.abs(this.height * this.scale.y);
    }
    _initPixelsFromTexture() {
        return Sprite_awaiter(this, void 0, void 0, function* () {
            try {
                const image = yield this.texture.loaded;
                this.width = this.width || image.naturalWidth;
                this.height = this.height || image.naturalHeight;
                this._spriteCanvas.width = this._spriteCanvas.width || image.naturalWidth;
                this._spriteCanvas.height = this._spriteCanvas.height || image.naturalHeight;
                this._loadPixels();
                this._dirtyEffect = true;
            }
            catch (e) {
                this.logger.error('Error loading texture ', this.texture.path, e);
            }
        });
    }
    _loadPixels() {
        if (this.texture.isLoaded() && !this._pixelsLoaded) {
            const naturalWidth = this.texture.image.naturalWidth || 0;
            const naturalHeight = this.texture.image.naturalHeight || 0;
            if (this.width > naturalWidth) {
                this.logger.warn(`The sprite width ${this.width} exceeds the width 
                              ${naturalWidth} of the backing texture ${this.texture.path}`);
            }
            if (this.width <= 0 || naturalWidth <= 0) {
                throw new Error(`The width of a sprite cannot be 0 or negative, sprite width: ${this.width}, original width: ${naturalWidth}`);
            }
            if (this.height > naturalHeight) {
                this.logger.warn(`The sprite height ${this.height} exceeds the height 
                              ${naturalHeight} of the backing texture ${this.texture.path}`);
            }
            if (this.height <= 0 || naturalHeight <= 0) {
                throw new Error(`The height of a sprite cannot be 0 or negative, sprite height: ${this.height}, original height: ${naturalHeight}`);
            }
            this._flushTexture();
            this._pixelsLoaded = true;
        }
    }
    _flushTexture() {
        const naturalWidth = this.texture.image.naturalWidth || 0;
        const naturalHeight = this.texture.image.naturalHeight || 0;
        this._spriteCtx.clearRect(0, 0, this.width, this.height);
        this._spriteCtx.drawImage(this.texture.image, clamp(this.x, 0, naturalWidth), clamp(this.y, 0, naturalHeight), clamp(this.width, 0, naturalWidth), clamp(this.height, 0, naturalHeight), 0, 0, this.width, this.height);
    }
    /**
     * Applies the [[Opacity]] effect to a sprite, setting the alpha of all pixels to a given value
     */
    opacity(value) {
        this._opacity = value;
    }
    /**
     * Applies the [[Grayscale]] effect to a sprite, removing color information.
     */
    grayscale() {
        this.addEffect(new Grayscale());
    }
    /**
     * Applies the [[Invert]] effect to a sprite, inverting the pixel colors.
     */
    invert() {
        this.addEffect(new Invert());
    }
    /**
     * Applies the [[Fill]] effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
     */
    fill(color) {
        this.addEffect(new Fill(color));
    }
    /**
     * Applies the [[Colorize]] effect to a sprite, changing the color channels of all pixels to be the average of the original color
     * and the provided color.
     */
    colorize(color) {
        this.addEffect(new Colorize(color));
    }
    /**
     * Applies the [[Lighten]] effect to a sprite, changes the lightness of the color according to HSL
     */
    lighten(factor = 0.1) {
        this.addEffect(new Lighten(factor));
    }
    /**
     * Applies the [[Darken]] effect to a sprite, changes the darkness of the color according to HSL
     */
    darken(factor = 0.1) {
        this.addEffect(new Darken(factor));
    }
    /**
     * Applies the [[Saturate]] effect to a sprite, saturates the color according to HSL
     */
    saturate(factor = 0.1) {
        this.addEffect(new Saturate(factor));
    }
    /**
     * Applies the [[Desaturate]] effect to a sprite, desaturates the color according to HSL
     */
    desaturate(factor = 0.1) {
        this.addEffect(new Desaturate(factor));
    }
    /**
     * Adds a new [[SpriteEffect]] to this drawing.
     * @param effect  Effect to add to the this drawing
     */
    addEffect(effect) {
        this.effects.push(effect);
        // We must check if the texture and the backing sprite pixels are loaded as well before
        // an effect can be applied
        if (!this.texture.isLoaded() || !this._pixelsLoaded) {
            this._dirtyEffect = true;
        }
        else {
            this._applyEffects();
        }
    }
    removeEffect(param) {
        let indexToRemove = -1;
        if (typeof param === 'number') {
            indexToRemove = param;
        }
        else {
            indexToRemove = this.effects.indexOf(param);
        }
        // bounds check
        if (indexToRemove < 0 || indexToRemove >= this.effects.length) {
            return;
        }
        this.effects.splice(indexToRemove, 1);
        // We must check if the texture and the backing sprite pixels are loaded as well before
        // an effect can be applied
        if (!this.texture.isLoaded() || !this._pixelsLoaded) {
            this._dirtyEffect = true;
        }
        else {
            this._applyEffects();
        }
    }
    _applyEffects() {
        this._flushTexture();
        if (this.effects.length > 0) {
            this._pixelData = this._spriteCtx.getImageData(0, 0, this.width, this.height);
            const len = this.effects.length;
            for (let i = 0; i < len; i++) {
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        this.effects[i].updatePixel(x, y, this._pixelData);
                    }
                }
            }
            this._spriteCtx.clearRect(0, 0, this.width, this.height);
            this._spriteCtx.putImageData(this._pixelData, 0, 0);
        }
        this._dirtyEffect = false;
    }
    /**
     * Clears all effects from the drawing and return it to its original state.
     */
    clearEffects() {
        this.effects.length = 0;
        this._applyEffects();
    }
    /**
     * Resets the internal state of the drawing (if any)
     */
    reset() {
        // do nothing
    }
    debugDraw(ctx, x, y) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(this.rotation);
        const xpoint = this.drawWidth * this.anchor.x;
        const ypoint = this.drawHeight * this.anchor.y;
        ctx.strokeStyle = Color.Black.toString();
        ctx.strokeRect(-xpoint, -ypoint, this.drawWidth, this.drawHeight);
        ctx.restore();
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { ctx, x, y, rotation, drawWidth, drawHeight, anchor, offset, opacity, flipHorizontal, flipVertical } = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.width, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.height, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, offset: (_g = options.offset) !== null && _g !== void 0 ? _g : this.offset, opacity: ((_h = options.opacity) !== null && _h !== void 0 ? _h : 1) * ((_j = this._opacity) !== null && _j !== void 0 ? _j : 1) });
        if (this._dirtyEffect) {
            this._applyEffects();
        }
        // calculating current dimensions
        const anchorX = drawWidth * anchor.x + offset.x;
        const anchorY = drawHeight * anchor.y + offset.y;
        const scaleDirX = this.scale.x > 0 ? 1 : -1;
        const scaleDirY = this.scale.y > 0 ? 1 : -1;
        ctx.save();
        // Move the draw point of origin
        ctx.translate(x, y);
        // Rotate and scale around anchor point
        // This requires a bit of explaination, scale coordinates first positive flipping or rotating
        ctx.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));
        if (this.drawAroundAnchor) {
            // In the case where you want the anchor to match with the point of draw
            // Otherwise sprites are always drawn from top-left
            ctx.translate(-anchorX, -anchorY);
        }
        ctx.translate(anchorX, anchorY);
        ctx.rotate(rotation);
        // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()
        ctx.scale(scaleDirX, scaleDirY);
        ctx.translate(-anchorX, -anchorY);
        if (flipHorizontal) {
            ctx.translate(drawWidth, 0);
            ctx.scale(-1, 1);
        }
        if (flipVertical) {
            ctx.translate(0, drawHeight);
            ctx.scale(1, -1);
        }
        const oldAlpha = ctx.globalAlpha;
        ctx.globalAlpha = opacity;
        // Context is already rotated and scaled
        ctx.drawImage(this._spriteCanvas, 0, 0, this.width, this.height, // source
        0, 0, this.width, this.height); // dest
        ctx.globalAlpha = oldAlpha;
        ctx.restore();
    }
    /**
     * Produces a copy of the current sprite
     */
    clone() {
        const result = new Sprite_Sprite(this.texture, this.x, this.y, this.width, this.height);
        result.anchor = this.anchor.clone();
        result.scale = this.scale.clone();
        result.rotation = this.rotation;
        result.flipHorizontal = this.flipHorizontal;
        result.flipVertical = this.flipVertical;
        const len = this.effects.length;
        for (let i = 0; i < len; i++) {
            result.addEffect(this.effects[i]);
        }
        return result;
    }
}
/**
 * A [[LegacyDrawing.Sprite]] is one of the main drawing primitives. It is responsible for drawing
 * images or parts of images from a [[LegacyDrawing.Texture]] resource to the screen.
 * @deprecated Use [[Sprite]]
 */
let Sprite_Sprite = class Sprite extends Configurable(SpriteImpl) {
    constructor(imageOrConfig, x, y, width, height) {
        super(imageOrConfig, x, y, width, height);
    }
};
Sprite_Sprite = Sprite_decorate([
    obsolete({
        message: 'Label.clearTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Sprite_Sprite);


;// CONCATENATED MODULE: ./Graphics/Sprite.ts




class Sprite extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this.image = options.image;
        const { width, height } = options;
        this.sourceView = (_a = options.sourceView) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this.destSize = (_b = options.destSize) !== null && _b !== void 0 ? _b : { width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this._updateSpriteDimensions();
        this.image.ready.then(() => {
            this._updateSpriteDimensions();
        });
    }
    static from(image) {
        return new Sprite({
            image: image
        });
    }
    _updateSpriteDimensions() {
        var _a, _b, _c, _d, _e, _f;
        const { width: nativeWidth, height: nativeHeight } = this.image;
        // This code uses || to avoid 0's
        // If the source is not specified, use the native dimension
        this.sourceView.width = ((_a = this.sourceView) === null || _a === void 0 ? void 0 : _a.width) || nativeWidth;
        this.sourceView.height = ((_b = this.sourceView) === null || _b === void 0 ? void 0 : _b.height) || nativeHeight;
        // If the destination is not specified, use the source if specified, then native
        this.destSize.width = ((_c = this.destSize) === null || _c === void 0 ? void 0 : _c.width) || ((_d = this.sourceView) === null || _d === void 0 ? void 0 : _d.width) || nativeWidth;
        this.destSize.height = ((_e = this.destSize) === null || _e === void 0 ? void 0 : _e.height) || ((_f = this.sourceView) === null || _f === void 0 ? void 0 : _f.height) || nativeHeight;
        this.width = Math.ceil(this.destSize.width);
        this.height = Math.ceil(this.destSize.height);
    }
    _preDraw(ex, x, y) {
        if (this.image.isLoaded()) {
            this._updateSpriteDimensions();
        }
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        if (this.image.isLoaded()) {
            this._updateSpriteDimensions();
            ex.drawImage(this.image.image, this.sourceView.x, this.sourceView.y, this.sourceView.width, this.sourceView.height, x, y, this.destSize.width, this.destSize.height);
        }
    }
    /**
     * Create a ImageSource from legacy texture
     * @param sprite
     */
    static fromLegacySprite(sprite) {
        const tex = sprite.texture;
        const image = ImageSource.fromLegacyTexture(tex);
        return new Sprite({
            image,
            sourceView: {
                x: sprite.x,
                y: sprite.y,
                width: sprite.width,
                height: sprite.height
            }
        });
    }
    /**
     * Converts a sprite to a Legacy sprite
     * @deprecated
     * @param sprite
     * @returns LegacyDrawing.Sprite
     */
    static toLegacySprite(sprite) {
        const image = sprite.image;
        const tex = new Texture(image.path);
        tex.data = image.image;
        return new Sprite_Sprite(tex, sprite.sourceView.x, sprite.sourceView.y, sprite.sourceView.width, sprite.sourceView.height);
    }
    clone() {
        return new Sprite(Object.assign({ image: this.image, sourceView: Object.assign({}, this.sourceView), destSize: Object.assign({}, this.destSize) }, this.cloneGraphicOptions()));
    }
}

;// CONCATENATED MODULE: ./Graphics/ImageSource.ts
var ImageSource_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class ImageSource {
    /**
     * The path to the image, can also be a data url like 'data:image/'
     * @param path
     */
    constructor(path, bustCache = false) {
        this.path = path;
        this._logger = Logger.getInstance();
        /**
         * Access to the underlying html image elmeent
         */
        this.data = new Image();
        this._resource = new Resource(path, 'blob', bustCache);
        if (path.endsWith('.svg') || path.endsWith('.gif')) {
            this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);
        }
        this.ready = new Promise((resolve) => {
            this._loadedResolve = resolve;
        });
    }
    /**
     * The original size of the source image in pixels
     */
    get width() {
        return this.image.naturalWidth;
    }
    /**
     * The original height of the source image in pixels
     */
    get height() {
        return this.image.naturalHeight;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return !!this.data.src;
    }
    get image() {
        return this.data;
    }
    /**
     * Begins loading the image and returns a promise that resolves when the image is loaded
     */
    load() {
        return ImageSource_awaiter(this, void 0, void 0, function* () {
            if (this.isLoaded()) {
                return this.data;
            }
            try {
                // Load base64 or blob if needed
                let url;
                if (!this.path.includes('data:image/')) {
                    const blob = yield this._resource.load();
                    url = URL.createObjectURL(blob);
                }
                else {
                    url = this.path;
                }
                // Decode the image
                const image = new Image();
                image.src = url;
                yield image.decode();
                // Set results
                this.data = image;
            }
            catch (error) {
                throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;
            }
            // todo emit complete
            this._loadedResolve(this.data);
            return this.data;
        });
    }
    /**
     * Build a sprite from this ImageSource
     */
    toSprite() {
        return Sprite.from(this);
    }
    /**
     * Create a ImageSource from legacy texture
     * @param tex
     */
    static fromLegacyTexture(tex) {
        const image = new ImageSource(tex.path);
        if (tex.isLoaded()) {
            image.data = tex.data;
        }
        else {
            tex.loaded.then(() => {
                image.data = tex.data;
            });
        }
        return image;
    }
    /**
     * Unload images from memory
     */
    unload() {
        this.data = new Image();
    }
}

;// CONCATENATED MODULE: ./Drawing/Animation.ts
var Animation_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






/**
 * @hidden
 * @deprecated Use [[Animation]]
 */
class AnimationImpl {
    /**
     * Typically you will use a [[SpriteSheet]] to generate an [[Animation]].
     *
     * @param engineOrConfig  Reference to the current game engine
     * @param sprites  An array of sprites to create the frames for the animation
     * @param speed   The number in milliseconds to display each frame in the animation
     * @param loop    Indicates whether the animation should loop after it is completed
     */
    constructor(engineOrConfig, sprites, speed, loop) {
        /**
         * The sprite frames to play, in order. See [[SpriteSheet.getAnimationForAll]] to quickly
         * generate an [[Animation]].
         */
        this.sprites = [];
        /**
         * Current frame index being shown
         */
        this.currentFrame = 0;
        this._timeLeftInFrame = 0;
        this._idempotencyToken = -1;
        this.anchor = Vector.Zero;
        this.rotation = 0.0;
        this.scale = Vector.One;
        /**
         * Indicates whether the animation should loop after it is completed
         */
        this.loop = true;
        /**
         * Indicates the frame index the animation should freeze on for a non-looping
         * animation. By default it is the last frame.
         */
        this.freezeFrame = -1;
        /**
         * Flip each frame vertically. Sets [[Sprite.flipVertical]].
         */
        this.flipVertical = false;
        /**
         * Flip each frame horizontally. Sets [[Sprite.flipHorizontal]].
         */
        this.flipHorizontal = false;
        this.drawWidth = 0;
        this.drawHeight = 0;
        this.width = 0;
        this.height = 0;
        this._opacity = 1;
        let engine = engineOrConfig;
        if (engineOrConfig && !(engineOrConfig instanceof Engine)) {
            const config = engineOrConfig;
            engine = config.engine;
            sprites = config.sprites;
            speed = config.speed;
            loop = config.loop;
        }
        this.sprites = sprites;
        this.speed = speed;
        this._engine = engine;
        this._timeLeftInFrame = this.speed;
        if (loop != null) {
            this.loop = loop;
        }
        if (sprites && sprites[0]) {
            this.drawHeight = sprites[0] ? sprites[0].drawHeight : 0;
            this.drawWidth = sprites[0] ? sprites[0].drawWidth : 0;
            this.width = sprites[0] ? sprites[0].width : 0;
            this.height = sprites[0] ? sprites[0].height : 0;
            this.freezeFrame = sprites.length - 1;
        }
    }
    /**
     * Applies the opacity effect to a sprite, setting the alpha of all pixels to a given value
     */
    opacity(value) {
        this._opacity = value;
    }
    /**
     * Applies the grayscale effect to a sprite, removing color information.
     */
    grayscale() {
        this.addEffect(new Grayscale());
    }
    /**
     * Applies the invert effect to a sprite, inverting the pixel colors.
     */
    invert() {
        this.addEffect(new Invert());
    }
    /**
     * Applies the fill effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
     */
    fill(color) {
        this.addEffect(new Fill(color));
    }
    /**
     * Applies the colorize effect to a sprite, changing the color channels of all pixels to be the average of the original color and the
     * provided color.
     */
    colorize(color) {
        this.addEffect(new Colorize(color));
    }
    /**
     * Applies the lighten effect to a sprite, changes the lightness of the color according to hsl
     */
    lighten(factor = 0.1) {
        this.addEffect(new Lighten(factor));
    }
    /**
     * Applies the darken effect to a sprite, changes the darkness of the color according to hsl
     */
    darken(factor = 0.1) {
        this.addEffect(new Darken(factor));
    }
    /**
     * Applies the saturate effect to a sprite, saturates the color according to hsl
     */
    saturate(factor = 0.1) {
        this.addEffect(new Saturate(factor));
    }
    /**
     * Applies the desaturate effect to a sprite, desaturates the color according to hsl
     */
    desaturate(factor = 0.1) {
        this.addEffect(new Desaturate(factor));
    }
    /**
     * Add a [[SpriteEffect]] manually
     */
    addEffect(effect) {
        for (const i in this.sprites) {
            this.sprites[i].addEffect(effect);
        }
    }
    removeEffect(param) {
        for (const i in this.sprites) {
            this.sprites[i].removeEffect(param);
        }
    }
    /**
     * Clear all sprite effects
     */
    clearEffects() {
        for (const i in this.sprites) {
            this.sprites[i].clearEffects();
        }
    }
    _setAnchor(point) {
        //if (!this.anchor.equals(point)) {
        for (const i in this.sprites) {
            this.sprites[i].anchor.setTo(point.x, point.y);
        }
        //}
    }
    _setRotation(radians) {
        //if (this.rotation !== radians) {
        for (const i in this.sprites) {
            this.sprites[i].rotation = radians;
        }
        //}
    }
    _setScale(scale) {
        //if (!this.scale.equals(scale)) {
        for (const i in this.sprites) {
            this.sprites[i].scale = scale;
        }
        //}
    }
    /**
     * Resets the animation to first frame.
     */
    reset() {
        this.currentFrame = 0;
    }
    /**
     * Indicates whether the animation is complete, animations that loop are never complete.
     */
    isDone() {
        return !this.loop && this.currentFrame >= this.sprites.length;
    }
    /**
     * Not meant to be called by game developers. Ticks the animation forward internally and
     * calculates whether to change to the frame.
     * @internal
     */
    tick(elapsed, idempotencyToken) {
        if (this._idempotencyToken === idempotencyToken) {
            return;
        }
        this._idempotencyToken = idempotencyToken;
        this._timeLeftInFrame -= elapsed;
        if (this._timeLeftInFrame <= 0) {
            this.currentFrame = this.loop ? (this.currentFrame + 1) % this.sprites.length : this.currentFrame + 1;
            this._timeLeftInFrame = this.speed;
        }
        this._updateValues();
        const current = this.sprites[this.currentFrame];
        if (current) {
            this.width = current.width;
            this.height = current.height;
            this.drawWidth = current.drawWidth;
            this.drawHeight = current.drawHeight;
        }
    }
    _updateValues() {
        this._setAnchor(this.anchor);
        this._setRotation(this.rotation);
        this._setScale(this.scale);
    }
    /**
     * Skips ahead a specified number of frames in the animation
     * @param frames  Frames to skip ahead
     */
    skip(frames) {
        this.currentFrame = (this.currentFrame + frames) % this.sprites.length;
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const animOptions = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.drawWidth, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.drawHeight, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, opacity: ((_g = options.opacity) !== null && _g !== void 0 ? _g : 1) * ((_h = this._opacity) !== null && _h !== void 0 ? _h : 1) });
        this._updateValues();
        let currSprite;
        if (this.currentFrame < this.sprites.length) {
            currSprite = this.sprites[this.currentFrame];
            currSprite.draw(animOptions);
        }
        if (this.freezeFrame !== -1 && this.currentFrame >= this.sprites.length) {
            currSprite = this.sprites[clamp(this.freezeFrame, 0, this.sprites.length - 1)];
            currSprite.draw(animOptions);
        }
        // add the calculated width
        if (currSprite) {
            this.drawWidth = currSprite.drawWidth;
            this.drawHeight = currSprite.drawHeight;
        }
    }
    /**
     * Plays an animation at an arbitrary location in the game.
     * @param x  The x position in the game to play
     * @param y  The y position in the game to play
     */
    play(x, y) {
        this.reset();
        this._engine.playAnimation(this, x, y);
    }
}
/**
 * Animations allow you to display a series of images one after another,
 * creating the illusion of change. Generally these images will come from a [[SpriteSheet]] source.
 * @deprecated Use [[Animation]]
 */
let Animation_Animation = class Animation extends Configurable(AnimationImpl) {
    constructor(engineOrConfig, images, speed, loop) {
        super(engineOrConfig, images, speed, loop);
    }
};
Animation_Animation = Animation_decorate([
    obsolete({
        message: 'Animation will be removed in v0.26.0',
        alternateMethod: 'Use Graphics.Animation'
    })
], Animation_Animation);


;// CONCATENATED MODULE: ./Graphics/FontCommon.ts
/**
 * Enum representing the different font size units
 * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
 */
var FontUnit;
(function (FontUnit) {
    /**
     * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values
     */
    FontUnit["Em"] = "em";
    /**
     * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element
     */
    FontUnit["Rem"] = "rem";
    /**
     * Pixel is a unit of length in screen pixels
     */
    FontUnit["Px"] = "px";
    /**
     * Point is a physical unit length (1/72 of an inch)
     */
    FontUnit["Pt"] = "pt";
    /**
     * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff
     */
    FontUnit["Percent"] = "%";
})(FontUnit || (FontUnit = {}));
/**
 * Enum representing the different horizontal text alignments
 */
var TextAlign;
(function (TextAlign) {
    /**
     * The text is left-aligned.
     */
    TextAlign["Left"] = "left";
    /**
     * The text is right-aligned.
     */
    TextAlign["Right"] = "right";
    /**
     * The text is centered.
     */
    TextAlign["Center"] = "center";
    /**
     * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,
     * right-aligned for right-to-left locales).
     */
    TextAlign["Start"] = "start";
    /**
     * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,
     * left-aligned for right-to-left locales).
     */
    TextAlign["End"] = "end";
})(TextAlign || (TextAlign = {}));
/**
 * Enum representing the different baseline text alignments
 */
var BaseAlign;
(function (BaseAlign) {
    /**
     * The text baseline is the top of the em square.
     */
    BaseAlign["Top"] = "top";
    /**
     * The text baseline is the hanging baseline.  Currently unsupported; this will act like
     * alphabetic.
     */
    BaseAlign["Hanging"] = "hanging";
    /**
     * The text baseline is the middle of the em square.
     */
    BaseAlign["Middle"] = "middle";
    /**
     * The text baseline is the normal alphabetic baseline.
     */
    BaseAlign["Alphabetic"] = "alphabetic";
    /**
     * The text baseline is the ideographic baseline; this is the bottom of
     * the body of the characters, if the main body of characters protrudes
     * beneath the alphabetic baseline.  Currently unsupported; this will
     * act like alphabetic.
     */
    BaseAlign["Ideographic"] = "ideographic";
    /**
     * The text baseline is the bottom of the bounding box.  This differs
     * from the ideographic baseline in that the ideographic baseline
     * doesn't consider descenders.
     */
    BaseAlign["Bottom"] = "bottom";
})(BaseAlign || (BaseAlign = {}));
/**
 * Enum representing the different possible font styles
 */
var FontStyle;
(function (FontStyle) {
    FontStyle["Normal"] = "normal";
    FontStyle["Italic"] = "italic";
    FontStyle["Oblique"] = "oblique";
})(FontStyle || (FontStyle = {}));
var Direction;
(function (Direction) {
    Direction["LeftToRight"] = "ltr";
    Direction["RightToLeft"] = "rtl";
})(Direction || (Direction = {}));

;// CONCATENATED MODULE: ./Drawing/SpriteSheet.ts
var SpriteSheet_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};









/**
 * Sprite sheets are a useful mechanism for slicing up image resources into
 * separate sprites or for generating in game animations. [[Sprite|Sprites]] are organized
 * in row major order in the [[SpriteSheet]].
 * @deprecated Will be removed in v0.26.0
 */
class SpriteSheet_SpriteSheet {
    /**
     * @param imageOrConfigOrSprites The backing image texture to build the SpriteSheet, option bag, or sprite list
     * @param columns   The number of columns in the image texture
     * @param rows      The number of rows in the image texture
     * @param spWidth   The width of each individual sprite in pixels
     * @param spHeight  The height of each individual sprite in pixels
     * @param spacing   The spacing between every sprite in a spritesheet
     */
    constructor(imageOrConfigOrSprites, columns, rows, spWidth, spHeight, spacing) {
        this._sprites = [];
        this._image = null;
        this._columns = 0;
        this._rows = 0;
        this._spWidth = 0;
        this._spHeight = 0;
        this._spacing = 0;
        let loadFromImage = false;
        if (imageOrConfigOrSprites instanceof Array) {
            this._sprites = imageOrConfigOrSprites;
        }
        else {
            if (imageOrConfigOrSprites && !(imageOrConfigOrSprites instanceof Texture)) {
                this._columns = imageOrConfigOrSprites.columns;
                this._rows = imageOrConfigOrSprites.rows;
                this._spWidth = imageOrConfigOrSprites.spWidth;
                this._spHeight = imageOrConfigOrSprites.spHeight;
                this._image = imageOrConfigOrSprites.image;
                this._spacing = imageOrConfigOrSprites.spacing || 0;
            }
            else {
                this._image = imageOrConfigOrSprites;
                this._columns = columns;
                this._rows = rows;
                this._spWidth = spWidth;
                this._spHeight = spHeight;
                this._spacing = spacing || 0;
            }
            this._sprites = new Array(this._columns * this._rows);
            loadFromImage = true;
        }
        // Inspect actual image dimensions with preloading
        if (this.image instanceof Texture) {
            let isWidthError = false;
            let isHeightError = false;
            if (this.image.isLoaded()) {
                isWidthError = this.spWidth * this.columns > this.image.image.naturalWidth;
                isHeightError = this.spHeight * this.rows > this.image.image.naturalHeight;
                if (isWidthError) {
                    throw new RangeError(`SpriteSheet specified is wider, ` +
                        `${this.columns} cols x ${this.spWidth} pixels > ${this.image.image.naturalWidth} ` +
                        `pixels than image width`);
                }
                if (isHeightError) {
                    throw new RangeError(`SpriteSheet specified is taller, ` +
                        `${this.rows} rows x ${this.spHeight} pixels > ${this.image.image.naturalHeight} ` +
                        `pixels than image height`);
                }
            }
        }
        if (loadFromImage) {
            const spacing = this.getSpacingDimensions();
            for (let row = 0; row < this.rows; row++) {
                for (let col = 0; col < this.columns; col++) {
                    this._sprites[col + row * this.columns] = new Sprite_Sprite(this.image, col * this.spWidth + spacing.margin * col + spacing.left, row * this.spHeight + spacing.margin * row + spacing.top, this.spWidth, this.spHeight);
                }
            }
        }
    }
    /**
     * Gets the raw spacing dimensions for the sprites in the sheet, which can be a fixed number or custom dimensions.
     */
    get spacing() {
        return this._spacing;
    }
    /**
     * Get a copy of the backing sprite array
     */
    get sprites() {
        return [...this._sprites];
    }
    /**
     * The backing texture used for the sprite sheet
     */
    get image() {
        return this._image;
    }
    /**
     * The number of columns in the sheet
     */
    get columns() {
        return this._columns;
    }
    /**
     * The number of rows in the sheet
     */
    get rows() {
        return this._rows;
    }
    /**
     * The width of the individual sprites
     */
    get spWidth() {
        return this._spWidth;
    }
    /**
     * The height of the individual sprites
     */
    get spHeight() {
        return this._spHeight;
    }
    /**
     * Gets the calculated spacing dimensions based on whether spacing
     * is a fixed number or has different values for each dimension
     */
    getSpacingDimensions() {
        var _a, _b, _c;
        if (typeof this.spacing === 'number') {
            return {
                left: this.spacing,
                top: this.spacing,
                margin: this.spacing
            };
        }
        else {
            return {
                left: (_a = this.spacing.left) !== null && _a !== void 0 ? _a : 0,
                top: (_b = this.spacing.top) !== null && _b !== void 0 ? _b : 0,
                margin: (_c = this.spacing.margin) !== null && _c !== void 0 ? _c : 0
            };
        }
    }
    /**
     * Create an animation from the this SpriteSheet by listing out the
     * sprite indices. Sprites are organized in row major order in the SpriteSheet.
     * @param engine   Reference to the current game [[Engine]]
     * @param indices  An array of sprite indices to use in the animation
     * @param speed    The number in milliseconds to display each frame in the animation
     */
    getAnimationByIndices(engine, indices, speed) {
        let images = indices.map((index) => {
            return this.sprites[index];
        });
        images = images.map(function (i) {
            return i.clone();
        });
        return new Animation_Animation(engine, images, speed);
    }
    /**
     * Create an animation from the this SpriteSheet by specifying the range of
     * images with the beginning (inclusive) and ending (exclusive) index
     * For example `getAnimationBetween(engine, 0, 5, 200)` returns an animation with 5 frames.
     * @param engine      Reference to the current game Engine
     * @param beginIndex  The index to start taking frames (inclusive)
     * @param endIndex    The index to stop taking frames (exclusive)
     * @param speed       The number in milliseconds to display each frame in the animation
     */
    getAnimationBetween(engine, beginIndex, endIndex, speed) {
        let images = this.sprites.slice(beginIndex, endIndex);
        images = images.map(function (i) {
            return i.clone();
        });
        return new Animation_Animation(engine, images, speed);
    }
    /**
     * Treat the entire SpriteSheet as one animation, organizing the frames in
     * row major order.
     * @param engine  Reference to the current game [[Engine]]
     * @param speed   The number in milliseconds to display each frame the animation
     */
    getAnimationForAll(engine, speed) {
        const sprites = this.sprites.map(function (i) {
            return i.clone();
        });
        return new Animation_Animation(engine, sprites, speed);
    }
    /**
     * Retrieve a specific sprite from the SpriteSheet by its index. Sprites are organized
     * in row major order in the SpriteSheet.
     * @param index  The index of the sprite
     */
    getSprite(index) {
        if (index >= 0 && index < this.sprites.length) {
            return this.sprites[index];
        }
        else {
            throw new Error('Invalid index: ' + index);
        }
    }
    /**
     * Get an animation with bespoke sprite coordinates. This is useful if the SpriteSheet is
     * packed and not a uniform width or height. The resulting [[Animation]] will have the height and width of the
     * largest dimension (width, height) from among the sprite coordinates
     * @param engine
     * @param spriteCoordinates
     * @param speed
     */
    getAnimationByCoords(engine, spriteCoordinates, speed) {
        let maxWidth = 0;
        let maxHeight = 0;
        const sprites = new Array(spriteCoordinates.length);
        for (let i = 0; i < spriteCoordinates.length; i++) {
            const coord = spriteCoordinates[i];
            // no need to pass image again if using a spritesheet
            coord.image = coord.image || this.image;
            maxWidth = Math.max(maxWidth, coord.drawWidth);
            maxHeight = Math.max(maxHeight, coord.drawHeight);
            sprites[i] = new Sprite_Sprite(coord);
        }
        const anim = new Animation_Animation(engine, sprites, speed);
        anim.drawWidth = maxWidth;
        anim.drawHeight = maxHeight;
        return anim;
    }
}
/**
 * Sprite fonts are a used in conjunction with a [[Label]] to specify
 * a particular bitmap as a font. Note that some font features are not
 * supported by Sprite fonts.
 * @deprecated Will be removed into v0.26.0
 */
let SpriteFont = class SpriteFont extends SpriteSheet_SpriteSheet {
    /**
     * @param imageOrConfig   The backing image texture to build the SpriteFont or the sprite font option bag
     * @param alphabet        A string representing all the characters in the image, in row major order.
     * @param caseInsensitive  Indicate whether this font takes case into account
     * @param columns         The number of columns of characters in the image
     * @param rows            The number of rows of characters in the image
     * @param spWidth         The width of each character in pixels
     * @param spHeight        The height of each character in pixels
     */
    constructor(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight, spacing) {
        super(imageOrConfig instanceof Texture
            ? {
                image: imageOrConfig,
                spWidth: spWidth,
                spHeight: spHeight,
                rows: rows,
                columns: columns,
                spacing: spacing || 0
            }
            : imageOrConfig);
        this._currentColor = Color.Black;
        this._currentOpacity = 1.0;
        this._spriteRecord = {};
        // text shadow
        this._textShadowOn = false;
        this._textShadowDirty = true;
        this._textShadowColor = Color.Black;
        this._textShadowSprites = {};
        this._shadowOffsetX = 5;
        this._shadowOffsetY = 5;
        if (imageOrConfig && !(imageOrConfig instanceof Texture)) {
            alphabet = imageOrConfig.alphabet;
            caseInsensitive = imageOrConfig.caseInsensitive;
        }
        this.alphabet = alphabet;
        this.caseInsensitive = caseInsensitive;
        this._spriteRecord = this.getTextSprites();
    }
    /**
     * Returns a dictionary that maps each character in the alphabet to the appropriate [[Sprite]].
     */
    getTextSprites() {
        const lookup = {};
        for (let i = 0; i < this.alphabet.length; i++) {
            let char = this.alphabet[i];
            if (this.caseInsensitive) {
                char = char.toLowerCase();
            }
            lookup[char] = this.sprites[i].clone();
        }
        return lookup;
    }
    /**
     * Sets the text shadow for sprite fonts
     * @param offsetX      The x offset in pixels to place the shadow
     * @param offsetY      The y offset in pixels to place the shadow
     * @param shadowColor  The color of the text shadow
     */
    setTextShadow(offsetX, offsetY, shadowColor) {
        this._textShadowOn = true;
        this._shadowOffsetX = offsetX;
        this._shadowOffsetY = offsetY;
        this._textShadowColor = shadowColor.clone();
        this._textShadowDirty = true;
        for (const character in this._spriteRecord) {
            this._textShadowSprites[character] = this._spriteRecord[character].clone();
        }
    }
    /**
     * Toggles text shadows on or off
     */
    useTextShadow(on) {
        this._textShadowOn = on;
        if (on) {
            this.setTextShadow(5, 5, this._textShadowColor);
        }
    }
    /**
     * Draws the current sprite font
     */
    draw(ctx, text, x, y, options) {
        options = this._parseOptions(options);
        if (this._currentColor.toString() !== options.color.toString() || this._currentOpacity !== options.opacity) {
            this._currentOpacity = options.opacity;
            this._currentColor = options.color;
            for (const char in this._spriteRecord) {
                this._spriteRecord[char].clearEffects();
                this._spriteRecord[char].fill(options.color);
                this._spriteRecord[char].opacity(options.opacity);
            }
        }
        if (this._textShadowOn && this._textShadowDirty && this._textShadowColor) {
            for (const characterShadow in this._textShadowSprites) {
                this._textShadowSprites[characterShadow].clearEffects();
                this._textShadowSprites[characterShadow].addEffect(new Fill(this._textShadowColor.clone()));
            }
            this._textShadowDirty = false;
        }
        // find the current length of text in pixels
        const sprite = this.sprites[0];
        // find the current height fo the text in pixels
        const height = sprite.height;
        // calculate appropriate scale for font size
        const scale = options.fontSize / height;
        const length = text.length * sprite.width * scale + text.length * options.letterSpacing;
        let currX = x;
        if (options.textAlign === TextAlign.Left || options.textAlign === TextAlign.Start) {
            currX = x;
        }
        else if (options.textAlign === TextAlign.Right || options.textAlign === TextAlign.End) {
            currX = x - length;
        }
        else if (options.textAlign === TextAlign.Center) {
            currX = x - length / 2;
        }
        let currY = y - height * scale;
        if (options.baseAlign === BaseAlign.Top || options.baseAlign === BaseAlign.Hanging) {
            currY = y;
        }
        else if (options.baseAlign === BaseAlign.Ideographic ||
            options.baseAlign === BaseAlign.Bottom ||
            options.baseAlign === BaseAlign.Alphabetic) {
            currY = y - height * scale;
        }
        else if (options.baseAlign === BaseAlign.Middle) {
            currY = y - (height * scale) / 2;
        }
        for (let i = 0; i < text.length; i++) {
            let character = text[i];
            if (this.caseInsensitive) {
                character = character.toLowerCase();
            }
            try {
                // if text shadow
                if (this._textShadowOn) {
                    this._textShadowSprites[character].drawAroundAnchor = false;
                    this._textShadowSprites[character].scale = vec(scale, scale);
                    this._textShadowSprites[character].draw(ctx, currX + this._shadowOffsetX, currY + this._shadowOffsetY);
                }
                const charSprite = this._spriteRecord[character];
                charSprite.drawAroundAnchor = false;
                charSprite.scale = vec(scale, scale);
                charSprite.draw(ctx, currX, currY);
                currX += charSprite.drawWidth + options.letterSpacing;
            }
            catch (e) {
                Logger.getInstance().error(`SpriteFont Error drawing char ${character}`);
            }
        }
    }
    _parseOptions(options) {
        return {
            fontSize: options.fontSize || 10,
            letterSpacing: options.letterSpacing || 0,
            color: options.color || Color.Black,
            textAlign: typeof options.textAlign === undefined ? TextAlign.Left : options.textAlign,
            baseAlign: typeof options.baseAlign === undefined ? BaseAlign.Bottom : options.baseAlign,
            maxWidth: options.maxWidth || -1,
            opacity: options.opacity || 0
        };
    }
};
SpriteFont = SpriteSheet_decorate([
    obsolete({
        message: 'SpriteSheet will be removed in v0.26.0',
        alternateMethod: 'Use Graphics.SpriteSheet'
    })
], SpriteFont);


;// CONCATENATED MODULE: ./Graphics/SpriteSheet.ts



/**
 * Represents a collection of sprites from a source image with some organization in a grid
 */
class SpriteSheet {
    /**
     * Build a new sprite sheet from a list of sprites
     *
     * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid
     * @param options
     */
    constructor(options) {
        this._logger = Logger.getInstance();
        this.sprites = [];
        const { sprites, rows, columns } = options;
        this.sprites = sprites;
        this.rows = rows !== null && rows !== void 0 ? rows : 1;
        this.columns = columns !== null && columns !== void 0 ? columns : this.sprites.length;
    }
    /**
     * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left
     * @param x
     * @param y
     */
    getSprite(x, y) {
        if (x >= this.columns || x < 0) {
            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1}`);
            return null;
        }
        if (y >= this.rows || y < 0) {
            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1}`);
            return null;
        }
        const spriteIndex = x + y * this.columns;
        return this.sprites[spriteIndex];
    }
    /**
     * To a graphics sprite sheet from a legacy sprite sheet
     */
    static fromLegacySpriteSheet(legacySpriteSheet) {
        const sprites = legacySpriteSheet.sprites.map(oldSprite => Sprite.fromLegacySprite(oldSprite));
        return new SpriteSheet({
            sprites
        });
    }
    /**
     * @deprecated
     * @param spriteSheet
     * @returns
     */
    static toLegacySpriteSheet(spriteSheet) {
        const sprites = spriteSheet.sprites.map(sprite => Sprite.toLegacySprite(sprite));
        return new SpriteSheet_SpriteSheet(sprites);
    }
    /**
     * Create a SpriteSheet from an [[ImageSource]] organized in a grid
     *
     * Example:
     * ```
     * const spriteSheet = SpriteSheet.fromImageSource({
     *   image: imageSource,
     *   grid: {
     *     rows: 5,
     *     columns: 2,
     *     spriteWidth: 32, // pixels
     *     spriteHeight: 32 // pixels
     *   },
     *   // Optionally specify spacing
     *   spacing: {
     *     // pixels from the top left to start the sprite parsing
     *     originOffset: {
     *       x: 5,
     *       y: 5
     *     },
     *     // pixels between each sprite while parsing
     *     margin: {
     *       x: 1,
     *       y: 1
     *     }
     *   }
     * })
     * ```
     *
     * @param options
     */
    static fromImageSource(options) {
        var _a;
        const sprites = [];
        options.spacing = (_a = options.spacing) !== null && _a !== void 0 ? _a : {};
        const { image, grid: { rows, columns: cols, spriteWidth, spriteHeight }, spacing: { originOffset, margin } } = options;
        const offsetDefaults = Object.assign({ x: 0, y: 0 }, originOffset);
        const marginDefaults = Object.assign({ x: 0, y: 0 }, margin);
        for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
                sprites[x + y * cols] = new Sprite({
                    image: image,
                    sourceView: {
                        x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,
                        y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,
                        width: spriteWidth,
                        height: spriteHeight
                    },
                    destSize: { height: spriteHeight, width: spriteWidth }
                });
            }
        }
        return new SpriteSheet({
            sprites: sprites,
            rows: rows,
            columns: cols
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/SpriteFont.ts




class SpriteFont_SpriteFont extends Graphic {
    constructor(options) {
        super(options);
        this._text = '';
        this._dirty = true;
        this.alphabet = '';
        this.shadow = null;
        this.caseInsensitive = false;
        this.spacing = 0;
        this._logger = Logger.getInstance();
        this._sprites = [];
        const { alphabet, spriteSheet, caseInsensitive, spacing, shadow } = options;
        this.alphabet = alphabet;
        this.spriteSheet = spriteSheet;
        this.caseInsensitive = caseInsensitive !== null && caseInsensitive !== void 0 ? caseInsensitive : this.caseInsensitive;
        this.spacing = spacing !== null && spacing !== void 0 ? spacing : this.spacing;
        this.shadow = shadow !== null && shadow !== void 0 ? shadow : this.shadow;
        this.spriteSheet.sprites[0].image.ready.then(() => {
            this._updateDimensions();
        });
    }
    static fromLegacySpriteFont(spriteFont) {
        const sprites = spriteFont.sprites.map(Sprite.fromLegacySprite);
        return new SpriteFont_SpriteFont({
            alphabet: spriteFont.alphabet,
            spacing: 0,
            caseInsensitive: spriteFont.caseInsensitive,
            spriteSheet: new SpriteSheet({
                sprites
            })
        });
    }
    _getCharacterSprites(text) {
        if (!this._dirty) {
            return this._sprites;
        }
        const results = [];
        // handle case insenstive
        const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;
        const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;
        // for each letter in text
        for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {
            // find the sprite index in alphabet , if there is an error pick the first
            const letter = textToRender[letterIndex];
            let spriteIndex = alphabet.indexOf(letter);
            if (spriteIndex === -1) {
                spriteIndex = 0;
                this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'`);
            }
            const letterSprite = this.spriteSheet.sprites[spriteIndex];
            if (letterSprite) {
                results.push(letterSprite);
            }
            else {
                this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);
            }
        }
        this._dirty = false;
        return (this._sprites = results);
    }
    _updateDimensions() {
        const sprites = this._getCharacterSprites(this._text);
        let width = 0;
        let height = 0;
        for (const sprite of sprites) {
            width += sprite.width + this.spacing;
            height = Math.max(height, sprite.height);
        }
        this.width = width;
        this.height = height;
    }
    updateText(text) {
        if (this._text !== text) {
            this._dirty = true;
            this._text = text;
            this._updateDimensions();
        }
    }
    _preDraw(ex, x, y) {
        this._updateDimensions();
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        let cursor = 0;
        for (const sprite of this._getCharacterSprites(this._text)) {
            // draw it in the right spot and increase the cursor by sprite width
            sprite.draw(ex, x + cursor, y);
            cursor += sprite.width + this.spacing;
        }
    }
    render(ex, text, x, y) {
        if (this._text !== text) {
            this._dirty = true;
            this._text = text;
        }
        if (this.shadow) {
            ex.save();
            ex.translate(this.shadow.offset.x, this.shadow.offset.y);
            this.draw(ex, x, y);
            ex.restore();
        }
        this.draw(ex, x, y);
    }
    clone() {
        return new SpriteFont_SpriteFont({
            alphabet: this.alphabet,
            spriteSheet: this.spriteSheet,
            spacing: this.spacing
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/debug-font.png
/* harmony default export */ const debug_font = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAwCAYAAAD+f6R/AAAAAXNSR0IArs4c6QAABcJJREFUeJztnemu7CgMhGE07//KmT9NhrAFVzkQndQntXRP3/bCZkwCSQhCCCGEEEIIIYQQQog/TRz953Ecx/nDGIe/vdNhlc9tIz605Fk/ZmWfsO1hn9Gxuv1KHbvb3iL/VN+d1WORbyr7yR/5b9M4vjNeqko6jPJHq5wGHU151o9J2Udse9hndCxuv0rH7rY3yD/Wdyf13MrnQeDfkZIUSGKM4ff3cWN82pEZuTyQGX2IxeyR63va//8VNCYCq+1yEkLtWyagXv1P1r1H+110gP3PzT4gT8uW/mdQ8mUG8E9DqOz4MS9ICKGbXpS2BpnIrRzYeS96cll08INlCMl2/glzdcfazuuPqQO03lmqrBHsf272Q6NODXj6zzZIJd/LAHYTg3Mays5gBi7ZR27fOgs0yj8rm36DLMFiPgkAdXHKOwUQeMCQ/adSh/qBQrT/tPxbAwA9+DOZEILPAATSuHMgTv7+Auk/df2lHPCZLvMSLJe34LkEQ9PwXF1SRTllMYgvIaflqyVAjLGbsiCDcOK76jflxZ+sINPyROc5071yKWK5CJTV3dMp6+tBlyCtNlhAq/+XbWoBDcRNXYBMzD4VvQygSuPYC2jGGaSSOxXfy3dTUEsanIvNeepm38N/hssSALTPZnAXfwIYRJn2b7UBcw0FKX+nDdAMpm2j9WVnxrUa7TXaVAca/B+TgaAVh6R/rH0P/5m01dt/RLYViJn+w/bhVX2P7f/duqom5qb02pRLCLGIMgBU1wCEEN9BAUCID6MAIMSHUQAQ4sMoAAjxYRQAhPgwd1uB0fuZ7H3cnn2P+9mr/Pe4B8/eB/fwP4eRtci/0f6OfTCPt/9oHwC6G6y19RHZDumxmwzR4eE/s/2Tte/q/+XLdc9DeJ19diesQc/j7Z8fCe4tAS4CxZ7sp7eiJi7HiZmjmOTGJs+93CbS3nP0XIPH3vW8/qz6QPnX2QdsV/1uw/iZYvg8ACeHd28rpPzfNfhL+7vkw/4Ou9s+Onhbv91elpKZ48Dl6bzpwwibHigRArf+Ptk9+L3Y1Q5OB4LgCeSBw1iuB3GeJh1/HrX/zF0A9Mk+u45zMkc3r4rWPomma5+p/514LB+Zo93MErJ1JHxXPzByGa/licRYVKbpeQCoQ6Q8yxuCwJF9IPsoDkHAo/3Tx26cvA4EtJ/n04w8QOq/mrR7ddfLAC5BYFNlVI/0CnOVUflOpvJUQMx9AIMIW/nWDM67/qw0+95v9goBqD9j+72u/KD9U89IbnQbMIR2Zbneh5zUY7Hdk7XIP3UffVb+r+wDYAZLq+1n1+C7y3/ny2r7p5yeByDEh9HzAIQQJwoAQnwYBQAhPowCgBBjoNu3hNxSFACE6INuKvPajPZ4EFEAEKINcybGYzOd247WEd3TgA2jlmjEyrd+j9hvfVbD2PWQ3ZmGlu2HyO8og8eBuNUvNYWoDgMVpwHTJoLWdz1Y+ZYOy5uF7t6PPruZxANrud1lQXkP0jsGz/Yz+vGGMuygFyhSPcJnc1pMnQZElc+cRnoAlxdTvoDuK7puqF7uCQy+3fyFMiA02/vJQHh7DQDogMPTSGFNA56HTzbZ9yAfBOb1Zyo3qGM3MfMZ3f76huXf6xlmAHknMlLNXsBBBvbljIz9Uyz5Y5TzIBLR/qy/rNyrZ8+L/0BZ0m+tgXD0OK5XZxC/9P7I/g4hVFvzXf1/6i5A7+3AlijMPBLMZfCvuAp7A9rY56ApHitmLQc7c8bOv6ftAxlM9Xp35nkEK7nJetBsaMhtAAAuOLQGXwhh2dXQnn1rZ/a42BI3dL7L+jkFAbQddwdA9Ah35yMKhgEgVT46EFh5D4jz+OgavNKxeBCd1wDSJ/97oR8eoJkLi9t9/BDgDHTJ5NE7Dnzechh914OVv9M1K9PCqsfqb88XVg9qN9lm6nG176UPu+zn17GOxuO0vOWEEC/j+LFKTgghlvEfYJaLS+SA2O0AAAAASUVORK5CYII=");
;// CONCATENATED MODULE: ./Graphics/Context/debug-text.ts


/**
 * Internal debugtext helper
 */
class DebugText {
    constructor() {
        /**
         * base64 font
         */
        this.fontSheet = debug_font;
        this.size = 16;
        this.load();
    }
    load() {
        this._imageSource = new ImageSource(this.fontSheet);
        return this._imageSource.load().then(() => {
            this._spriteSheet = SpriteSheet.fromImageSource({
                image: this._imageSource,
                grid: {
                    rows: 3,
                    columns: 16,
                    spriteWidth: 16,
                    spriteHeight: 16
                }
            });
            this._spriteFont = new SpriteFont_SpriteFont({
                alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!\'&."?-()+ ',
                caseInsensitive: true,
                spriteSheet: this._spriteSheet,
                spacing: -6
            });
        });
    }
    /**
     * Writes debug text using the built in sprint font
     * @param ctx
     * @param text
     * @param pos
     */
    write(ctx, text, pos) {
        if (this._imageSource.isLoaded()) {
            this._spriteFont.render(ctx, text, pos.x, pos.y);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContextWebGL.ts












class ExcaliburGraphicsContextWebGLDebug {
    constructor(_webglCtx) {
        this._webglCtx = _webglCtx;
        this._debugText = new DebugText();
    }
    /**
     * Draw a debugging rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height, rectOptions = { color: Color.Black }) {
        this.drawLine(vec(x, y), vec(x + width, y), Object.assign({}, rectOptions));
        this.drawLine(vec(x + width, y), vec(x + width, y + height), Object.assign({}, rectOptions));
        this.drawLine(vec(x + width, y + height), vec(x, y + height), Object.assign({}, rectOptions));
        this.drawLine(vec(x, y + height), vec(x, y), Object.assign({}, rectOptions));
    }
    /**
     * Draw a debugging line to the context
     * @param start
     * @param end
     * @param lineOptions
     */
    drawLine(start, end, lineOptions = { color: Color.Black }) {
        this._webglCtx.__lineRenderer.addLine(start, end, lineOptions.color);
    }
    /**
     * Draw a debugging point to the context
     * @param point
     * @param pointOptions
     */
    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {
        this._webglCtx.__pointRenderer.addPoint(point, pointOptions.color, pointOptions.size);
    }
    drawText(text, pos) {
        this._debugText.write(this._webglCtx, text, pos);
    }
}
class ExcaliburGraphicsContextWebGL {
    constructor(options) {
        this._transform = new TransformStack();
        this._state = new StateStack();
        this.snapToPixel = true;
        this.smoothing = false;
        this.backgroundColor = Color.ExcaliburBlue;
        this.debug = new ExcaliburGraphicsContextWebGLDebug(this);
        const { canvasElement, enableTransparency, smoothing, snapToPixel, backgroundColor } = options;
        this.__gl = canvasElement.getContext('webgl', {
            antialias: smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing,
            premultipliedAlpha: false,
            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true,
            depth: true,
            powerPreference: 'high-performance'
        });
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this._init();
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get width() {
        return this.__gl.canvas.width;
    }
    get height() {
        return this.__gl.canvas.height;
    }
    /**
     * Checks the underlying webgl implementation if the requested internal resolution is supported
     * @param dim
     */
    checkIfResolutionSupported(dim) {
        // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo
        const gl = this.__gl;
        // If any dimension is greater than max texture size (divide by 4 bytes per pixel)
        const maxDim = gl.getParameter(gl.MAX_TEXTURE_SIZE) / 4;
        let supported = true;
        if (dim.width > maxDim || dim.height > maxDim) {
            supported = false;
        }
        return supported;
    }
    _init() {
        const gl = this.__gl;
        // Setup viewport and view matrix
        this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        // Clear background
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        gl.clear(gl.COLOR_BUFFER_BIT);
        // Enable alpha blending
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        this.__pointRenderer = new PointRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });
        this.__lineRenderer = new LineRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });
        this.__imageRenderer = new ImageRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });
        // 2D ctx shim
        this._canvas = new Canvas({
            width: gl.canvas.width,
            height: gl.canvas.height
        });
        this.__ctx = this._canvas.ctx;
    }
    resetTransform() {
        this._transform.current = Matrix.identity();
    }
    updateViewport() {
        const gl = this.__gl;
        this._ortho = this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);
        this.__pointRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);
        this.__lineRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);
        this.__imageRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);
        // 2D ctx shim
        this._canvas.width = gl.canvas.width;
        this._canvas.height = gl.canvas.height;
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (image.width === 0 || image.height === 0) {
            return; // zero dimension source exit early
        }
        if (!image) {
            Logger.getInstance().warn('Cannot draw a null or undefined image');
            // tslint:disable-next-line: no-console
            if (console.trace) {
                // tslint:disable-next-line: no-console
                console.trace();
            }
            return;
        }
        this.__imageRenderer.addImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
    }
    drawLine(start, end, color, thickness = 1) {
        this.__imageRenderer.addLine(color, start, end, thickness);
    }
    drawRectangle(pos, width, height, color) {
        this.__imageRenderer.addRectangle(color, pos, width, height);
    }
    drawCircle(pos, radius, color) {
        this.__imageRenderer.addCircle(pos, radius, color);
    }
    save() {
        this._transform.save();
        this._state.save();
    }
    restore() {
        this._transform.restore();
        this._state.restore();
    }
    translate(x, y) {
        this._transform.translate(this.snapToPixel ? ~~x : x, this.snapToPixel ? ~~y : y);
    }
    rotate(angle) {
        this._transform.rotate(angle);
    }
    scale(x, y) {
        this._transform.scale(x, y);
    }
    transform(matrix) {
        this._transform.current = matrix;
    }
    clear() {
        const gl = this.__gl;
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        // Clear the context with the newly set color. This is
        // the function call that actually does the drawing.
        gl.clear(gl.COLOR_BUFFER_BIT);
        GraphicsDiagnostics.clear();
    }
    /**
     * Flushes all batched rendering to the screen
     */
    flush() {
        const gl = this.__gl;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        this.__imageRenderer.render();
        this.__lineRenderer.render();
        this.__pointRenderer.render();
    }
}

;// CONCATENATED MODULE: ./Screen.ts





/**
 * Enum representing the different display modes available to Excalibur.
 */
var DisplayMode;
(function (DisplayMode) {
    /**
     * Default, use a specified resolution for the game. Like 800x600 pixels for example.
     */
    DisplayMode["Fixed"] = "Fixed";
    /**
     * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.
     * This is not the same as [[Screen.goFullScreen]] but behaves in a similar way maintaining aspect ratio.
     *
     * You may want to center your game here is an example
     * ```html
     * <!-- html -->
     * <body>
     * <main>
     *   <canvas id="game"></canvas>
     * </main>
     * </body>
     * ```
     *
     * ```css
     * // css
     * main {
     *   display: flex;
     *   align-items: center;
     *   justify-content: center;
     *   height: 100%;
     *   width: 100%;
     * }
     * ```
     *
     */
    DisplayMode["FitScreen"] = "FitScreen";
    /**
     * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will
     * change dynamically as the window is resized. This is not the same as [[Screen.goFullScreen]]
     */
    DisplayMode["FillScreen"] = "FillScreen";
    /**
     * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.
     */
    DisplayMode["FitContainer"] = "FitContainer";
    /**
     * Use the parent DOM container's css width/height for the game resolution dynamically
     */
    DisplayMode["FillContainer"] = "FillContainer";
    /**
     * Allow the game to be positioned with the [[EngineOptions.position]] option
     * @deprecated Use CSS to position the game canvas, will be removed in v0.26.0
     */
    DisplayMode["Position"] = "Position";
})(DisplayMode || (DisplayMode = {}));
/**
 * Convenience class for quick resolutions
 * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution
 */
class Resolution {
    /* istanbul ignore next */
    static get SVGA() {
        return { width: 800, height: 600 };
    }
    /* istanbul ignore next */
    static get Standard() {
        return { width: 1920, height: 1080 };
    }
    /* istanbul ignore next */
    static get Atari2600() {
        return { width: 160, height: 192 };
    }
    /* istanbul ignore next */
    static get GameBoy() {
        return { width: 160, height: 144 };
    }
    /* istanbul ignore next */
    static get GameBoyAdvance() {
        return { width: 240, height: 160 };
    }
    /* istanbul ignore next */
    static get NintendoDS() {
        return { width: 256, height: 192 };
    }
    /* istanbul ignore next */
    static get NES() {
        return { width: 256, height: 224 };
    }
    /* istanbul ignore next */
    static get SNES() {
        return { width: 256, height: 244 };
    }
}
/**
 * The Screen handles all aspects of interacting with the screen for Excalibur.
 */
class Screen {
    constructor(options) {
        var _a, _b, _c;
        this._antialiasing = true;
        this._resolutionStack = [];
        this._viewportStack = [];
        this._pixelRatioOverride = null;
        this._isFullScreen = false;
        this._isDisposed = false;
        this._logger = Logger.getInstance();
        this._fullscreenChangeHandler = () => {
            this._isFullScreen = !this._isFullScreen;
            this._logger.debug('Fullscreen Change', this._isFullScreen);
        };
        this._pixelRatioChangeHandler = () => {
            this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);
            this._devicePixelRatio = this._calculateDevicePixelRatio();
            this.applyResolutionAndViewport();
        };
        this._resizeHandler = () => {
            const parent = this.parent;
            this._logger.debug('View port resized');
            this._setResolutionAndViewportByDisplayMode(parent);
            this.applyResolutionAndViewport();
        };
        // Asking the window.devicePixelRatio is expensive we do it once
        this._devicePixelRatio = this._calculateDevicePixelRatio();
        this._alreadyWarned = false;
        this.viewport = options.viewport;
        this.resolution = (_a = options.resolution) !== null && _a !== void 0 ? _a : Object.assign({}, this.viewport);
        this._displayMode = (_b = options.displayMode) !== null && _b !== void 0 ? _b : DisplayMode.Fixed;
        this._canvas = options.canvas;
        this._ctx = options.context;
        this._antialiasing = (_c = options.antialiasing) !== null && _c !== void 0 ? _c : this._antialiasing;
        this._browser = options.browser;
        this._position = options.position;
        this._pixelRatioOverride = options.pixelRatio;
        this._applyDisplayMode();
        this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
        this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler);
        this._canvas.addEventListener('fullscreenchange', this._fullscreenChangeHandler);
        this.applyResolutionAndViewport();
    }
    dispose() {
        if (!this._isDisposed) {
            // Clean up handlers
            this._isDisposed = true;
            this._browser.window.off('resize', this._resizeHandler);
            if (this._resizeObserver) {
                this._resizeObserver.disconnect();
            }
            this.parent.removeEventListener('resize', this._resizeHandler);
            this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);
            this._canvas.removeEventListener('fullscreenchange', this._fullscreenChangeHandler);
        }
    }
    _calculateDevicePixelRatio() {
        if (window.devicePixelRatio < 1) {
            return 1;
        }
        const devicePixelRatio = window.devicePixelRatio || 1;
        return devicePixelRatio;
    }
    get pixelRatio() {
        if (this._pixelRatioOverride) {
            return this._pixelRatioOverride;
        }
        return this._devicePixelRatio;
    }
    get isHiDpi() {
        return this.pixelRatio !== 1;
    }
    get displayMode() {
        return this._displayMode;
    }
    get canvas() {
        return this._canvas;
    }
    get parent() {
        return ((this.displayMode === DisplayMode.FillContainer || this.displayMode === DisplayMode.FitContainer
            ? this.canvas.parentElement || document.body
            : window));
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(resolution) {
        this._resolution = resolution;
    }
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return this._resolution;
    }
    set viewport(viewport) {
        this._viewport = viewport;
    }
    get aspectRatio() {
        return this._resolution.width / this._resolution.height;
    }
    get scaledWidth() {
        return this._resolution.width * this.pixelRatio;
    }
    get scaledHeight() {
        return this._resolution.height * this.pixelRatio;
    }
    setCurrentCamera(camera) {
        this._camera = camera;
    }
    pushResolutionAndViewport() {
        this._resolutionStack.push(this.resolution);
        this._viewportStack.push(this.viewport);
        this.resolution = Object.assign({}, this.resolution);
        this.viewport = Object.assign({}, this.viewport);
    }
    peekViewport() {
        return this._viewportStack[this._viewportStack.length - 1];
    }
    peekResolution() {
        return this._resolutionStack[this._resolutionStack.length - 1];
    }
    popResolutionAndViewport() {
        this.resolution = this._resolutionStack.pop();
        this.viewport = this._viewportStack.pop();
    }
    applyResolutionAndViewport() {
        this._canvas.width = this.scaledWidth;
        this._canvas.height = this.scaledHeight;
        if (this._ctx instanceof ExcaliburGraphicsContextWebGL) {
            const supported = this._ctx.checkIfResolutionSupported({
                width: this.scaledWidth,
                height: this.scaledHeight
            });
            if (!supported && !this._alreadyWarned) {
                this._alreadyWarned = true; // warn once
                this._logger.warn(`The currently configured resolution (${this.resolution.width}x${this.resolution.height})` +
                    ' is too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.' +
                    ' Try reducing the resolution or disabling Hi DPI scaling to avoid this' +
                    ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');
            }
        }
        if (this._antialiasing) {
            this._canvas.style.imageRendering = 'auto';
        }
        else {
            this._canvas.style.imageRendering = 'pixelated';
            // Fall back to 'crisp-edges' if 'pixelated' is not supported
            // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering
            if (this._canvas.style.imageRendering === '') {
                this._canvas.style.imageRendering = 'crisp-edges';
            }
        }
        this._canvas.style.width = this.viewport.width + 'px';
        this._canvas.style.height = this.viewport.height + 'px';
        // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset
        this._ctx.updateViewport();
        this._ctx.resetTransform();
        this._ctx.scale(this.pixelRatio, this.pixelRatio);
        this._ctx.smoothing = this._antialiasing;
    }
    get antialiasing() {
        return this._antialiasing;
    }
    set antialiasing(isSmooth) {
        this._antialiasing = isSmooth;
        this._ctx.smoothing = this._antialiasing;
    }
    /**
     * Returns true if excalibur is fullscreened using the browser fullscreen api
     */
    get isFullScreen() {
        return this._isFullScreen;
    }
    /**
     * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.
     * For example, wire this to a user click handler.
     */
    goFullScreen() {
        return this._canvas.requestFullscreen();
    }
    /**
     * Requests to exit fullscreen using the browser fullscreen api
     */
    exitFullScreen() {
        return document.exitFullscreen();
    }
    /**
     * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to
     * Excalibur screen space.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    pageToScreenCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        if (!this._isFullScreen) {
            newX -= getPosition(this._canvas).x;
            newY -= getPosition(this._canvas).y;
        }
        // if fullscreen api on it centers with black bars
        // we need to adjust the screen to world coordinates in this case
        if (this._isFullScreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = ((newY - screenMarginY) / screenHeight) * this.viewport.height;
                newX = (newX / window.innerWidth) * this.viewport.width;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = ((newX - screenMarginX) / screenWidth) * this.viewport.width;
                newY = (newY / window.innerHeight) * this.viewport.height;
            }
        }
        newX = (newX / this.viewport.width) * this.resolution.width;
        newY = (newY / this.viewport.height) * this.resolution.height;
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,
     * this is where html elements might live if you want to position them relative to Excalibur.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    screenToPageCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        newX = (newX / this.resolution.width) * this.viewport.width;
        newY = (newY / this.resolution.height) * this.viewport.height;
        if (this._isFullScreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = (newY / this.viewport.height) * screenHeight + screenMarginY;
                newX = (newX / this.viewport.width) * window.innerWidth;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = (newX / this.viewport.width) * screenWidth + screenMarginX;
                newY = (newY / this.viewport.height) * window.innerHeight;
            }
        }
        if (!this._isFullScreen) {
            newX += getPosition(this._canvas).x;
            newY += getPosition(this._canvas).y;
        }
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.
     *
     * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]
     * and extends infinitely out relative from the [[Camera]].
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        var _a, _b, _c, _d;
        let newX = point.x;
        let newY = point.y;
        // transform back to world space
        newX = (newX / this.resolution.width) * this.drawWidth;
        newY = (newY / this.resolution.height) * this.drawHeight;
        // transform based on zoom
        newX = newX - this.halfDrawWidth;
        newY = newY - this.halfDrawHeight;
        // shift by camera focus
        newX += (_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
        newY += (_d = (_c = this._camera) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.
     *
     * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        var _a, _b, _c, _d;
        let screenX = point.x;
        let screenY = point.y;
        // shift by camera focus
        screenX -= (_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
        screenY -= (_d = (_c = this._camera) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;
        // transform back on zoom
        screenX = screenX + this.halfDrawWidth;
        screenY = screenY + this.halfDrawHeight;
        // transform back to screen space
        screenX = (screenX / this.drawWidth) * this.resolution.width;
        screenY = (screenY / this.drawHeight) * this.resolution.height;
        return new Vector(screenX, screenY);
    }
    pageToWorldCoordinates(point) {
        const screen = this.pageToScreenCoordinates(point);
        return this.screenToWorldCoordinates(screen);
    }
    worldToPageCoordinates(point) {
        const screen = this.worldToScreenCoordinates(point);
        return this.screenToPageCoordinates(screen);
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     *
     * World bounds are in world coordinates, useful for culling objects offscreen
     */
    getWorldBounds() {
        const left = this.screenToWorldCoordinates(Vector.Zero).x;
        const top = this.screenToWorldCoordinates(Vector.Zero).y;
        const right = left + this.drawWidth;
        const bottom = top + this.drawHeight;
        return new BoundingBox(left, top, right, bottom);
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.canvas.width;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.canvas.width / 2;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.canvas.height;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.canvas.height / 2;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        if (this._camera) {
            return this.resolution.width / this._camera.zoom;
        }
        return this.resolution.width;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.drawWidth / 2;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        if (this._camera) {
            return this.resolution.height / this._camera.zoom;
        }
        return this.resolution.height;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.drawHeight / 2;
    }
    /**
     * Returns screen center coordinates including zoom and device pixel ratio.
     */
    get center() {
        return vec(this.halfDrawWidth, this.halfDrawHeight);
    }
    _computeFit() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        if (window.innerWidth / aspect < window.innerHeight) {
            adjustedWidth = window.innerWidth;
            adjustedHeight = window.innerWidth / aspect;
        }
        else {
            adjustedWidth = window.innerHeight * aspect;
            adjustedHeight = window.innerHeight;
        }
        this.viewport = {
            width: adjustedWidth,
            height: adjustedHeight
        };
    }
    _computeFitContainer() {
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        const parent = this.canvas.parentElement;
        if (parent.clientWidth / aspect < parent.clientHeight) {
            adjustedWidth = parent.clientWidth;
            adjustedHeight = parent.clientWidth / aspect;
        }
        else {
            adjustedWidth = parent.clientHeight * aspect;
            adjustedHeight = parent.clientHeight;
        }
        this.viewport = {
            width: adjustedWidth,
            height: adjustedHeight
        };
    }
    _applyDisplayMode() {
        if (this.displayMode === DisplayMode.Position) {
            this._initializeDisplayModePosition(this._position);
        }
        else {
            this._setResolutionAndViewportByDisplayMode(this.parent);
            // watch resizing
            if (this.parent instanceof Window) {
                this._browser.window.on('resize', this._resizeHandler);
            }
            else {
                this._resizeObserver = new ResizeObserver(() => {
                    this._resizeHandler();
                });
                this._resizeObserver.observe(this.parent);
            }
            this.parent.addEventListener('resize', this._resizeHandler);
        }
    }
    /**
     * Sets the resoultion and viewport based on the selected display mode.
     */
    _setResolutionAndViewportByDisplayMode(parent) {
        if (this.displayMode === DisplayMode.FillContainer) {
            this.resolution = {
                width: parent.clientWidth,
                height: parent.clientHeight
            };
            this.viewport = this.resolution;
        }
        if (this.displayMode === DisplayMode.FillScreen) {
            document.body.style.margin = '0px';
            document.body.style.overflow = 'hidden';
            this.resolution = {
                width: parent.innerWidth,
                height: parent.innerHeight
            };
            this.viewport = this.resolution;
        }
        if (this.displayMode === DisplayMode.FitScreen) {
            this._computeFit();
        }
        if (this.displayMode === DisplayMode.FitContainer) {
            this._computeFitContainer();
        }
    }
    _initializeDisplayModePosition(position) {
        if (!position) {
            throw new Error('DisplayMode of Position was selected but no position option was given');
        }
        else {
            this.canvas.style.display = 'block';
            this.canvas.style.position = 'absolute';
            if (typeof position === 'string') {
                const specifiedPosition = position.split(' ');
                switch (specifiedPosition[0]) {
                    case 'top':
                        this.canvas.style.top = '0px';
                        break;
                    case 'bottom':
                        this.canvas.style.bottom = '0px';
                        break;
                    case 'middle':
                        this.canvas.style.top = '50%';
                        const offsetY = -this.halfDrawHeight;
                        this.canvas.style.marginTop = offsetY.toString();
                        break;
                    default:
                        throw new Error('Invalid Position Given');
                }
                if (specifiedPosition[1]) {
                    switch (specifiedPosition[1]) {
                        case 'left':
                            this.canvas.style.left = '0px';
                            break;
                        case 'right':
                            this.canvas.style.right = '0px';
                            break;
                        case 'center':
                            this.canvas.style.left = '50%';
                            const offsetX = -this.halfDrawWidth;
                            this.canvas.style.marginLeft = offsetX.toString();
                            break;
                        default:
                            throw new Error('Invalid Position Given');
                    }
                }
            }
            else {
                if (position.top) {
                    typeof position.top === 'number'
                        ? (this.canvas.style.top = position.top.toString() + 'px')
                        : (this.canvas.style.top = position.top);
                }
                if (position.right) {
                    typeof position.right === 'number'
                        ? (this.canvas.style.right = position.right.toString() + 'px')
                        : (this.canvas.style.right = position.right);
                }
                if (position.bottom) {
                    typeof position.bottom === 'number'
                        ? (this.canvas.style.bottom = position.bottom.toString() + 'px')
                        : (this.canvas.style.bottom = position.bottom);
                }
                if (position.left) {
                    typeof position.left === 'number'
                        ? (this.canvas.style.left = position.left.toString() + 'px')
                        : (this.canvas.style.left = position.left);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/AudioContext.ts
/**
 * Internal class used to build instances of AudioContext
 */
/* istanbul ignore next */
class AudioContextFactory {
    static create() {
        if (!this._INSTANCE) {
            if (window.AudioContext || window.webkitAudioContext) {
                this._INSTANCE = new AudioContext();
            }
        }
        return this._INSTANCE;
    }
}
AudioContextFactory._INSTANCE = null;

;// CONCATENATED MODULE: ./Util/WebAudio.ts


/**
 * Patch for detecting legacy web audio in browsers
 * @internal
 * @param source
 */
function isLegacyWebAudioSource(source) {
    return !!source.playbackState;
}
class WebAudio {
    /**
     * Play an empty sound to unlock Safari WebAudio context. Call this function
     * right after a user interaction event.
     * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     */
    static unlock() {
        const promise = new Promise((resolve, reject) => {
            if (WebAudio._UNLOCKED || !AudioContextFactory.create()) {
                return resolve(true);
            }
            const unlockTimeoutTimer = setTimeout(() => {
                Logger.getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');
                resolve(false);
            }, 200);
            const audioContext = AudioContextFactory.create();
            audioContext.resume().then(() => {
                // create empty buffer and play it
                const buffer = audioContext.createBuffer(1, 1, 22050);
                const source = audioContext.createBufferSource();
                let ended = false;
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.onended = () => (ended = true);
                source.start(0);
                // by checking the play state after some time, we know if we're really unlocked
                setTimeout(() => {
                    if (isLegacyWebAudioSource(source)) {
                        if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                    else {
                        if (audioContext.currentTime > 0 || ended) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                }, 0);
                clearTimeout(unlockTimeoutTimer);
                resolve(true);
            }, () => {
                reject();
            });
        });
        return promise;
    }
    static isUnlocked() {
        return this._UNLOCKED;
    }
}
WebAudio._UNLOCKED = false;

;// CONCATENATED MODULE: ./Class.ts

/**
 * Excalibur base class that provides basic functionality such as [[EventDispatcher]]
 * and extending abilities for vanilla Javascript projects
 */
class Class {
    constructor() {
        this.eventDispatcher = new EventDispatcher(this);
    }
    /**
     * Alias for `addEventListener`. You can listen for a variety of
     * events off of the engine; see the events section below for a complete list.
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    on(eventName, handler) {
        this.eventDispatcher.on(eventName, handler);
    }
    /**
     * Alias for `removeEventListener`. If only the eventName is specified
     * it will remove all handlers registered for that specific event. If the eventName
     * and the handler instance are specified only that handler will be removed.
     *
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    off(eventName, handler) {
        this.eventDispatcher.off(eventName, handler);
    }
    /**
     * Emits a new event
     * @param eventName   Name of the event to emit
     * @param eventObject Data associated with this event
     */
    emit(eventName, eventObject) {
        this.eventDispatcher.emit(eventName, eventObject);
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        this.eventDispatcher.once(eventName, handler);
    }
}

;// CONCATENATED MODULE: ./Util/DrawUtil.ts

/* istanbul ignore next */
/**
 * Draw a line on canvas context
 *
 * @param ctx The canvas context
 * @param color The color of the line
 * @param x1 The start x coordinate
 * @param y1 The start y coordinate
 * @param x2 The ending x coordinate
 * @param y2 The ending y coordinate
 * @param thickness The line thickness
 * @param cap The [[LineCapStyle]] (butt, round, or square)
 */
function line(ctx, color = Color.Red, x1, y1, x2, y2, thickness = 1, cap = 'butt') {
    ctx.beginPath();
    ctx.lineWidth = thickness;
    ctx.lineCap = cap;
    ctx.strokeStyle = color.toString();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.closePath();
    ctx.stroke();
}
/* istanbul ignore next */
/**
 * Draw the vector as a point onto the canvas.
 */
function point(ctx, color = Color.Red, point) {
    ctx.beginPath();
    ctx.strokeStyle = color.toString();
    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw the vector as a line onto the canvas starting a origin point.
 */
/* istanbul ignore next */
/**
 *
 */
function vector(ctx, color, origin, vector, scale = 1.0) {
    const c = color ? color.toString() : 'blue';
    const v = vector.scale(scale);
    ctx.beginPath();
    ctx.strokeStyle = c;
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(origin.x + v.x, origin.y + v.y);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw a round rectangle on a canvas context
 *
 * @param ctx The canvas context
 * @param x The top-left x coordinate
 * @param y The top-left y coordinate
 * @param width The width of the rectangle
 * @param height The height of the rectangle
 * @param radius The border radius of the rectangle
 * @param stroke The [[Color]] to stroke rectangle with
 * @param fill The [[Color]] to fill rectangle with
 */
function roundRect(ctx, x, y, width, height, radius = 5, stroke = Color.White, fill = null) {
    let br;
    if (typeof radius === 'number') {
        br = { tl: radius, tr: radius, br: radius, bl: radius };
    }
    else {
        const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
        for (const prop in defaultRadius) {
            if (defaultRadius.hasOwnProperty(prop)) {
                const side = prop;
                br[side] = radius[side] || defaultRadius[side];
            }
        }
    }
    ctx.beginPath();
    ctx.moveTo(x + br.tl, y);
    ctx.lineTo(x + width - br.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
    ctx.lineTo(x + width, y + height - br.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
    ctx.lineTo(x + br.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
    ctx.lineTo(x, y + br.tl);
    ctx.quadraticCurveTo(x, y, x + br.tl, y);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}
/**
 *
 */
function circle(ctx, x, y, radius, stroke = Color.White, fill = null) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Loader.logo.png
/* harmony default export */ const Loader_logo = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=");
// EXTERNAL MODULE: ./Loader.css
var Loader_0 = __nested_webpack_require_51441__(1388);
;// CONCATENATED MODULE: ./Loader.ts
var Loader_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








/**
 * Pre-loading assets
 *
 * The loader provides a mechanism to preload multiple resources at
 * one time. The loader must be passed to the engine in order to
 * trigger the loading progress bar.
 *
 * The [[Loader]] itself implements [[Loadable]] so you can load loaders.
 *
 * ## Example: Pre-loading resources for a game
 *
 * ```js
 * // create a loader
 * var loader = new ex.Loader();
 *
 * // create a resource dictionary (best practice is to keep a separate file)
 * var resources = {
 *   TextureGround: new ex.Texture("/images/textures/ground.png"),
 *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")
 * };
 *
 * // loop through dictionary and add to loader
 * for (var loadable in resources) {
 *   if (resources.hasOwnProperty(loadable)) {
 *     loader.addResource(resources[loadable]);
 *   }
 * }
 *
 * // start game
 * game.start(loader).then(function () {
 *   console.log("Game started!");
 * });
 * ```
 *
 * ## Customize the Loader
 *
 * The loader can be customized to show different, text, logo, background color, and button.
 *
 * ```typescript
 * const loader = new ex.Loader([playerTexture]);
 *
 * // The loaders button text can simply modified using this
 * loader.playButtonText = 'Start the best game ever';
 *
 * // The logo can be changed by inserting a base64 image string here
 *
 * loader.logo = 'data:image/png;base64,iVBORw...';
 * loader.logoWidth = 15;
 * loader.logoHeight = 14;
 *
 * // The background color can be changed like so by supplying a valid CSS color string
 *
 * loader.backgroundColor = 'red'
 * loader.backgroundColor = '#176BAA'
 *
 * // To build a completely new button
 * loader.startButtonFactory = () => {
 *     let myButton = document.createElement('button');
 *     myButton.textContent = 'The best button';
 *     return myButton;
 * };
 *
 * engine.start(loader).then(() => {});
 * ```
 */
class Loader extends Class {
    /**
     * @param loadables  Optionally provide the list of resources you want to load at constructor time
     */
    constructor(loadables) {
        super();
        this.canvas = new Canvas({
            smoothing: true,
            draw: this.draw.bind(this)
        });
        this._resourceList = [];
        this._index = 0;
        this._playButtonShown = false;
        this._resourceCount = 0;
        this._numLoaded = 0;
        this._progressCounts = {};
        this._totalCounts = {};
        // logo drawing stuff
        // base64 string encoding of the excalibur logo (logo-white.png)
        this.logo = Loader_logo;
        this.logoWidth = 468;
        this.logoHeight = 118;
        /**
         * Gets or sets the color of the loading bar, default is [[Color.White]]
         */
        this.loadingBarColor = Color.White;
        /**
         * Gets or sets the background color of the loader as a hex string
         */
        this.backgroundColor = '#176BAA';
        this.suppressPlayButton = false;
        /** Loads the css from Loader.css */
        this._playButtonStyles = Loader_0/* default.toString */.Z.toString();
        /**
         * Get/set play button text
         */
        this.playButtonText = 'Play game';
        /**
         * Return a html button element for excalibur to use as a play button
         */
        this.startButtonFactory = () => {
            let buttonElement = document.getElementById('excalibur-play');
            if (!buttonElement) {
                buttonElement = document.createElement('button');
            }
            buttonElement.id = 'excalibur-play';
            buttonElement.textContent = this.playButtonText;
            buttonElement.style.display = 'none';
            return buttonElement;
        };
        if (loadables) {
            this.addResources(loadables);
        }
    }
    get _image() {
        if (!this._imageElement) {
            this._imageElement = new Image();
            this._imageElement.src = this.logo;
        }
        return this._imageElement;
    }
    get playButtonRootElement() {
        return this._playButtonRootElement;
    }
    get playButtonElement() {
        return this._playButtonElement;
    }
    get _playButton() {
        const existingRoot = document.getElementById('excalibur-play-root');
        if (existingRoot) {
            this._playButtonRootElement = existingRoot;
        }
        if (!this._playButtonRootElement) {
            this._playButtonRootElement = document.createElement('div');
            this._playButtonRootElement.id = 'excalibur-play-root';
            this._playButtonRootElement.style.position = 'absolute';
            document.body.appendChild(this._playButtonRootElement);
        }
        if (!this._styleBlock) {
            this._styleBlock = document.createElement('style');
            this._styleBlock.textContent = this._playButtonStyles;
            document.head.appendChild(this._styleBlock);
        }
        if (!this._playButtonElement) {
            this._playButtonElement = this.startButtonFactory();
            this._playButtonRootElement.appendChild(this._playButtonElement);
        }
        return this._playButtonElement;
    }
    wireEngine(engine) {
        this._engine = engine;
        this.canvas.width = this._engine.canvas.width;
        this.canvas.height = this._engine.canvas.height;
    }
    /**
     * Add a resource to the loader to load
     * @param loadable  Resource to add
     */
    addResource(loadable) {
        const key = this._index++;
        this._resourceList.push(loadable);
        this._progressCounts[key] = 0;
        this._totalCounts[key] = 1;
        this._resourceCount++;
    }
    /**
     * Add a list of resources to the loader to load
     * @param loadables  The list of resources to load
     */
    addResources(loadables) {
        let i = 0;
        const len = loadables.length;
        for (i; i < len; i++) {
            this.addResource(loadables[i]);
        }
    }
    /**
     * Returns true if the loader has completely loaded all resources
     */
    isLoaded() {
        return this._numLoaded === this._resourceCount;
    }
    /**
     * Shows the play button and returns a promise that resolves when clicked
     */
    showPlayButton() {
        var _a;
        if (this.suppressPlayButton) {
            this.hidePlayButton();
            return Promise.resolve();
        }
        else {
            const resizeHandler = () => {
                this._positionPlayButton();
            };
            if ((_a = this._engine) === null || _a === void 0 ? void 0 : _a.browser) {
                this._engine.browser.window.on('resize', resizeHandler);
            }
            this._playButtonShown = true;
            this._playButton.style.display = 'block';
            document.body.addEventListener('keyup', (evt) => {
                if (evt.key === 'Enter') {
                    this._playButton.click();
                }
            });
            const promise = new Promise((resolve) => {
                const startButtonHandler = (e) => {
                    var _a;
                    // We want to stop propogation to keep bubbling to the engine pointer handlers
                    e.stopPropagation();
                    // Hide Button after click
                    this.hidePlayButton();
                    if ((_a = this._engine) === null || _a === void 0 ? void 0 : _a.browser) {
                        this._engine.browser.window.off('resize', resizeHandler);
                    }
                    resolve();
                };
                this._playButton.addEventListener('click', startButtonHandler);
                this._playButton.addEventListener('touchend', startButtonHandler);
                this._playButton.addEventListener('pointerup', startButtonHandler);
            });
            return promise;
        }
    }
    hidePlayButton() {
        this._playButtonShown = false;
        this._playButton.style.display = 'none';
    }
    /**
     * Clean up generated elements for the loader
     */
    dispose() {
        if (this._playButtonRootElement.parentElement) {
            this._playButtonRootElement.removeChild(this._playButtonElement);
            document.body.removeChild(this._playButtonRootElement);
            document.head.removeChild(this._styleBlock);
            this._playButtonRootElement = null;
            this._playButtonElement = null;
            this._styleBlock = null;
        }
    }
    update(_engine, _delta) {
        // override me
    }
    /**
     * Begin loading all of the supplied resources, returning a promise
     * that resolves when loading of all is complete
     */
    load() {
        return Loader_awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this._resourceList.map((r) => r.load().finally(() => {
                // capture progress
                this._numLoaded++;
            })));
            // short delay in showing the button for aesthetics
            yield delay(200);
            yield this.showPlayButton();
            // Unlock browser AudioContext in after user gesture
            // See: https://github.com/excaliburjs/Excalibur/issues/262
            // See: https://github.com/excaliburjs/Excalibur/issues/1031
            yield WebAudio.unlock();
            return (this.data = this._resourceList);
        });
    }
    markResourceComplete() {
        this._numLoaded++;
    }
    /**
     * Returns the progess of the loader as a number between [0, 1] inclusive.
     */
    get progress() {
        return this._resourceCount > 0 ? clamp(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;
    }
    _positionPlayButton() {
        const screenHeight = this._engine.screen.viewport.height;
        const screenWidth = this._engine.screen.viewport.width;
        if (this._playButtonRootElement) {
            const left = this._engine.canvas.offsetLeft;
            const top = this._engine.canvas.offsetTop;
            const buttonWidth = this._playButton.clientWidth;
            const buttonHeight = this._playButton.clientHeight;
            if (this.playButtonPosition) {
                this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;
                this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;
            }
            else {
                this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;
                this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;
            }
        }
    }
    /**
     * Loader draw function. Draws the default Excalibur loading screen.
     * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
     * to customize the drawing, or just override entire method.
     */
    draw(ctx) {
        const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;
        const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;
        this._positionPlayButton();
        ctx.fillStyle = this.backgroundColor;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        let logoY = canvasHeight / 2;
        const width = Math.min(this.logoWidth, canvasWidth * 0.75);
        let logoX = canvasWidth / 2 - width / 2;
        if (this.logoPosition) {
            logoX = this.logoPosition.x;
            logoY = this.logoPosition.y;
        }
        const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor
        const oldAntialias = this._engine.getAntialiasing();
        this._engine.setAntialiasing(true);
        if (!this.logoPosition) {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);
        }
        else {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);
        }
        // loading box
        if (!this.suppressPlayButton && this._playButtonShown) {
            this._engine.setAntialiasing(oldAntialias);
            return;
        }
        let loadingX = logoX;
        let loadingY = logoY;
        if (this.loadingBarPosition) {
            loadingX = this.loadingBarPosition.x;
            loadingY = this.loadingBarPosition.y;
        }
        ctx.lineWidth = 2;
        roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);
        const progress = width * this.progress;
        const margin = 5;
        const progressWidth = progress - margin * 2;
        const height = 20 - margin * 2;
        roundRect(ctx, loadingX + margin, loadingY + margin, progressWidth > 10 ? progressWidth : 10, height, 5, null, this.loadingBarColor);
        this._engine.setAntialiasing(oldAntialias);
    }
}

;// CONCATENATED MODULE: ./Util/Detector.ts

/**
 * This is the list of features that will be used to log the supported
 * features to the console when Detector.logBrowserFeatures() is called.
 */
const REPORTED_FEATURES = {
    webgl: 'WebGL',
    webaudio: 'WebAudio',
    gamepadapi: 'Gamepad API'
};
/**
 * Excalibur internal feature detection helper class
 */
class Detector {
    constructor() {
        this._features = null;
        this.failedTests = [];
        // critical browser features required for ex to run
        this._criticalTests = {
            // Test canvas/2d context support
            canvasSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('2d'));
            },
            // Test array buffer support ex uses for downloading binary data
            arrayBufferSupport: function () {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', '/');
                try {
                    xhr.responseType = 'arraybuffer';
                }
                catch (e) {
                    return false;
                }
                return xhr.responseType === 'arraybuffer';
            },
            // Test data urls ex uses for sprites
            dataUrlSupport: function () {
                const canvas = document.createElement('canvas');
                return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
            },
            // Test object url support for loading
            objectUrlSupport: function () {
                return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;
            },
            // RGBA support for colors
            rgbaSupport: function () {
                const style = document.createElement('a').style;
                style.cssText = 'background-color:rgba(150,255,150,.5)';
                return ('' + style.backgroundColor).indexOf('rgba') > -1;
            }
        };
        // warnings excalibur performance will be degraded
        this._warningTest = {
            webAudioSupport: function () {
                return !!(window.AudioContext ||
                    window.webkitAudioContext ||
                    window.mozAudioContext ||
                    window.msAudioContext ||
                    window.oAudioContext);
            },
            webglSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('webgl'));
            }
        };
        this._features = this._loadBrowserFeatures();
    }
    /**
     * Returns a map of currently supported browser features. This method
     * treats the features as a singleton and will only calculate feature
     * support if it has not previously been done.
     */
    getBrowserFeatures() {
        if (this._features === null) {
            this._features = this._loadBrowserFeatures();
        }
        return this._features;
    }
    /**
     * Report on non-critical browser support for debugging purposes.
     * Use native browser console colors for visibility.
     */
    logBrowserFeatures() {
        let msg = '%cSUPPORTED BROWSER FEATURES\n==========================%c\n';
        const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];
        const supported = this.getBrowserFeatures();
        for (const feature of Object.keys(REPORTED_FEATURES)) {
            if (supported[feature]) {
                msg += '(%c\u2713%c)'; // ()
                args.push('font-weight: bold; color: green');
                args.push('font-weight: normal; color: inherit');
            }
            else {
                msg += '(%c\u2717%c)'; // ()
                args.push('font-weight: bold; color: red');
                args.push('font-weight: normal; color: inherit');
            }
            msg += ' ' + REPORTED_FEATURES[feature] + '\n';
        }
        args.unshift(msg);
        // eslint-disable-next-line no-console
        console.log.apply(console, args);
    }
    /**
     * Executes several IIFE's to get a constant reference to supported
     * features within the current execution context.
     */
    _loadBrowserFeatures() {
        return {
            // IIFE to check canvas support
            canvas: (() => {
                return this._criticalTests.canvasSupport();
            })(),
            // IIFE to check arraybuffer support
            arraybuffer: (() => {
                return this._criticalTests.arrayBufferSupport();
            })(),
            // IIFE to check dataurl support
            dataurl: (() => {
                return this._criticalTests.dataUrlSupport();
            })(),
            // IIFE to check objecturl support
            objecturl: (() => {
                return this._criticalTests.objectUrlSupport();
            })(),
            // IIFE to check rgba support
            rgba: (() => {
                return this._criticalTests.rgbaSupport();
            })(),
            // IIFE to check webaudio support
            webaudio: (() => {
                return this._warningTest.webAudioSupport();
            })(),
            // IIFE to check webgl support
            webgl: (() => {
                return this._warningTest.webglSupport();
            })(),
            // IIFE to check gamepadapi support
            gamepadapi: (() => {
                return !!navigator.getGamepads;
            })()
        };
    }
    test() {
        // Critical test will for ex not to run
        let failedCritical = false;
        for (const test in this._criticalTests) {
            if (!this._criticalTests[test].call(this)) {
                this.failedTests.push(test);
                Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);
                failedCritical = true;
            }
        }
        if (failedCritical) {
            return false;
        }
        // Warning tests do not for ex to return false to compatibility
        for (const warning in this._warningTest) {
            if (!this._warningTest[warning]()) {
                Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);
            }
        }
        return true;
    }
}

;// CONCATENATED MODULE: ./Collision/CollisionType.ts
/**
 * An enum that describes the types of collisions bodies can participate in
 */
var CollisionType;
(function (CollisionType) {
    /**
     * Bodies with the `PreventCollision` setting do not participate in any
     * collisions and do not raise collision events.
     */
    CollisionType["PreventCollision"] = "PreventCollision";
    /**
     * Bodies with the `Passive` setting only raise collision events, but are not
     * influenced or moved by other bodies and do not influence or move other bodies.
     * This is useful for use in trigger type behavior.
     */
    CollisionType["Passive"] = "Passive";
    /**
     * Bodies with the `Active` setting raise collision events and participate
     * in collisions with other bodies and will be push or moved by bodies sharing
     * the `Active` or `Fixed` setting.
     */
    CollisionType["Active"] = "Active";
    /**
     * Bodies with the `Fixed` setting raise collision events and participate in
     * collisions with other bodies. Actors with the `Fixed` setting will not be
     * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed
     * bodies as "immovable/unstoppable" objects. If two `Fixed` bodies meet they will
     * not be pushed or moved by each other, they will not interact except to throw
     * collision events.
     */
    CollisionType["Fixed"] = "Fixed";
})(CollisionType || (CollisionType = {}));

;// CONCATENATED MODULE: ./Collision/Physics.ts
var Physics_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Possible collision resolution strategies
 *
 * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics. This is useful for things
 * like platformers or top down games.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated
 * simulated physical interactions.
 */
var CollisionResolutionStrategy;
(function (CollisionResolutionStrategy) {
    CollisionResolutionStrategy["Arcade"] = "arcade";
    CollisionResolutionStrategy["Realistic"] = "realistic";
})(CollisionResolutionStrategy || (CollisionResolutionStrategy = {}));
/**
 * Possible broadphase collision pair identification strategies
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster.
 */
var BroadphaseStrategy;
(function (BroadphaseStrategy) {
    BroadphaseStrategy[BroadphaseStrategy["DynamicAABBTree"] = 0] = "DynamicAABBTree";
})(BroadphaseStrategy || (BroadphaseStrategy = {}));
/**
 * Possible numerical integrators for position and velocity
 */
var Integrator;
(function (Integrator) {
    Integrator[Integrator["Euler"] = 0] = "Euler";
})(Integrator || (Integrator = {}));
/**
 * The [[Physics]] object is the global configuration object for all Excalibur physics.
 */
/* istanbul ignore next */
class Physics {
    static get gravity() {
        return Physics.acc;
    }
    static set gravity(v) {
        Physics.acc = v;
    }
    /**
     * Configures Excalibur to use "arcade" physics. Arcade physics which performs simple axis aligned arcade style physics.
     */
    static useArcadePhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
    }
    /**
     * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated
     * simulated physical interactions.
     */
    static useRealisticPhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;
    }
    static get dynamicTreeVelocityMultiplyer() {
        return Physics.dynamicTreeVelocityMultiplier;
    }
    static set dynamicTreeVelocityMultiplyer(value) {
        Physics.dynamicTreeVelocityMultiplier = value;
    }
}
/**
 * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.
 * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.
 *
 * This is a great way to globally simulate effects like gravity.
 */
Physics.acc = new Vector(0, 0);
/**
 * Globally switches all Excalibur physics behavior on or off.
 */
Physics.enabled = true;
/**
 * Gets or sets the broadphase pair identification strategy.
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster.
 */
Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;
/**
 * Gets or sets the global collision resolution strategy (narrowphase).
 *
 * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated
 * simulated physical interactions.
 */
Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
/**
 * The default mass to use if none is specified
 */
Physics.defaultMass = 10;
/**
 * Gets or sets the position and velocity positional integrator, currently only Euler is supported.
 */
Physics.integrator = Integrator.Euler;
/**
 * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);
 */
Physics.dynamicTreeVelocityMultiplier = 2;
/**
 * Pad RigidBody BoundingBox by a constant amount
 */
Physics.boundsPadding = 5;
/**
 * Number of position iterations (overlap) to run in the solver
 */
Physics.positionIterations = 3;
/**
 * Number of velocity iteration (response) to run in the solver
 */
Physics.velocityIterations = 8;
/**
 * Amount of overlap to tolerate in pixels
 */
Physics.slop = 1;
/**
 * Amount of positional overlap correction to apply each position iteration of the solver
 * O - meaning no correction, 1 - meaning correct all overlap
 */
Physics.steeringFactor = 0.2;
/**
 * Warm start set to true re-uses impulses from previous frames back in the solver
 */
Physics.warmStart = true;
/**
 * By default bodies do not sleep
 */
Physics.bodiesCanSleepByDefault = false;
/**
 * Surface epsilon is used to help deal with surface penetration
 */
Physics.surfaceEpsilon = 0.1;
Physics.sleepEpsilon = 0.07;
Physics.wakeThreshold = Physics.sleepEpsilon * 3;
Physics.sleepBias = 0.9;
/**
 * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent
 * bodies from tunneling through one another.
 */
Physics.checkForFastBodies = true;
/**
 * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the
 * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,
 * Excalibur will always perform the fast body raycast regardless of speed.
 */
Physics.disableMinimumSpeedForFastBody = false;
Physics_decorate([
    obsolete({
        message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',
        alternateMethod: 'dynamicTreeVelocityMultiplier'
    })
], Physics, "dynamicTreeVelocityMultiplyer", null);

;// CONCATENATED MODULE: ./Math/vector-view.ts

class VectorView extends Vector {
    constructor(options) {
        super(0, 0);
        this._getX = options.getX;
        this._getY = options.getY;
        this._setX = options.setX;
        this._setY = options.setY;
    }
    get x() {
        return (this._x = this._getX());
    }
    set x(val) {
        this._setX(val);
        this._x = val;
    }
    get y() {
        return (this._y = this._getY());
    }
    set y(val) {
        this._setY(val);
        this._y = val;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Component.ts
/**
 * Type guard to check if a component implements clone
 * @param x
 */
function hasClone(x) {
    return !!(x === null || x === void 0 ? void 0 : x.clone);
}
/**
 * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity posesses
 *
 * Implementations of Component must have a zero-arg constructor to support dependecies
 *
 * ```typescript
 * class MyComponent extends ex.Component<'my'> {
 *   public readonly type = 'my';
 *   // zero arg support required if you want to use component dependencies
 *   constructor(public optionalPos?: ex.Vector) {}
 * }
 * ```
 */
class Component {
    constructor() {
        /**
         * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]
         */
        this.owner = null;
    }
    /**
     * Clones any properties on this component, if that property value has a `clone()` method it will be called
     */
    clone() {
        const newComponent = new this.constructor();
        for (const prop in this) {
            if (this.hasOwnProperty(prop)) {
                const val = this[prop];
                if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {
                    newComponent[prop] = val.clone();
                }
                else {
                    newComponent[prop] = val;
                }
            }
        }
        return newComponent;
    }
}
/**
 * Tag components are a way of tagging a component with label and a simple value
 *
 * For example:
 *
 * ```typescript
 * const isOffscreen = new TagComponent('offscreen');
 * entity.addComponent(isOffscreen);
 * entity.tags.includes
 * ```
 */
class TagComponent extends Component {
    constructor(type, value) {
        super();
        this.type = type;
        this.value = value;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Components/TransformComponent.ts




const createPosView = (matrix) => {
    const source = matrix;
    return new VectorView({
        setX: (x) => {
            source.data[MatrixLocations.X] = x;
        },
        setY: (y) => {
            source.data[MatrixLocations.Y] = y;
        },
        getX: () => {
            return source.data[MatrixLocations.X];
        },
        getY: () => {
            return source.data[MatrixLocations.Y];
        }
    });
};
const createScaleView = (matrix) => {
    const source = matrix;
    return new VectorView({
        setX: (x) => {
            source.setScaleX(x);
        },
        setY: (y) => {
            source.setScaleY(y);
        },
        getX: () => {
            return source.getScaleX();
        },
        getY: () => {
            return source.getScaleY();
        }
    });
};
/**
 * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]
 */
var CoordPlane;
(function (CoordPlane) {
    /**
     * The world coordinate plane (default) represents world space, any entities drawn with world
     * space move when the camera moves.
     */
    CoordPlane["World"] = "world";
    /**
     * The screen coordinate plane represents screen space, entities drawn in screen space are pinned
     * to screen coordinates ignoring the camera.
     */
    CoordPlane["Screen"] = "screen";
})(CoordPlane || (CoordPlane = {}));
class TransformComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.transform';
        this._dirty = false;
        this.matrix = Matrix.identity().translate(0, 0).rotate(0).scale(1, 1);
        this._position = createPosView(this.matrix);
        this._rotation = 0;
        this._scale = createScaleView(this.matrix);
        /**
         * The [[CoordPlane|coordinate plane|]] for this transform for the entity.
         */
        this.coordPlane = CoordPlane.World;
        /**
         * The z-index ordering of the entity, a higher values are drawn on top of lower values.
         * For example z=99 would be drawn on top of z=0.
         */
        this.z = 0;
    }
    _recalculate() {
        this._rotation = this.matrix.getRotation();
        this._dirty = false;
    }
    getGlobalMatrix() {
        if (!this.parent) {
            return this.matrix;
        }
        else {
            return this.parent.getGlobalMatrix().multm(this.matrix);
        }
    }
    getGlobalTransform() {
        return {
            pos: this.globalPos,
            scale: this.globalScale,
            rotation: this.globalRotation,
            z: this.z,
            coordPlane: this.coordPlane
        };
    }
    get parent() {
        var _a, _b;
        return (_b = (_a = this === null || this === void 0 ? void 0 : this.owner) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.get(TransformComponent);
    }
    /**
     * The current position of the entity in world space or in screen space depending on the the [[CoordPlane|coordinate plane]].
     *
     * If a parent entity exists coordinates are local to the parent.
     */
    get pos() {
        if (this._dirty) {
            this._recalculate();
        }
        return this._position;
    }
    set pos(val) {
        this.matrix.setPosition(val.x, val.y);
        this._dirty = true;
    }
    // Dirty flag check up the chain
    get dirty() {
        var _a;
        if ((_a = this === null || this === void 0 ? void 0 : this.owner) === null || _a === void 0 ? void 0 : _a.parent) {
            const parent = this.parent;
            return parent.dirty || this._dirty;
        }
        return this._dirty;
    }
    /**
     * The current world position calculated
     */
    get globalPos() {
        const source = this.getGlobalMatrix();
        return new VectorView({
            getX: () => source.data[MatrixLocations.X],
            getY: () => source.data[MatrixLocations.Y],
            setX: (x) => {
                var _a;
                if (this.parent) {
                    const [newX] = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getGlobalMatrix().getAffineInverse().multv([x, source.data[MatrixLocations.Y]]);
                    this.matrix.data[MatrixLocations.X] = newX;
                }
                else {
                    this.matrix.data[MatrixLocations.X] = x;
                }
            },
            setY: (y) => {
                var _a;
                if (this.parent) {
                    const [, newY] = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getGlobalMatrix().getAffineInverse().multv([source.data[MatrixLocations.X], y]);
                    this.matrix.data[MatrixLocations.Y] = newY;
                }
                else {
                    this.matrix.data[MatrixLocations.Y] = y;
                }
            }
        });
    }
    set globalPos(val) {
        const parentTransform = this.parent;
        if (!parentTransform) {
            this.pos = val;
        }
        else {
            this.pos = parentTransform.getGlobalMatrix().getAffineInverse().multv(val);
        }
    }
    /**
     * The rotation of the entity in radians. For example `Math.PI` radians is the same as 180 degrees.
     */
    get rotation() {
        if (this._dirty) {
            this._recalculate();
        }
        return this._rotation;
    }
    set rotation(val) {
        this.matrix.setRotation(val);
        this._dirty = true;
    }
    get globalRotation() {
        return this.getGlobalMatrix().getRotation();
    }
    set globalRotation(val) {
        const parentTransform = this.parent;
        if (!parentTransform) {
            this.rotation = val;
        }
        else {
            this.rotation = val - parentTransform.globalRotation;
        }
    }
    /**
     * The scale of the entity.
     */
    get scale() {
        if (this._dirty) {
            this._recalculate();
        }
        return this._scale;
    }
    set scale(val) {
        this.matrix.setScale(val);
        this._dirty = true;
    }
    get globalScale() {
        const source = this.getGlobalMatrix();
        return new VectorView({
            getX: () => source.getScaleX(),
            getY: () => source.getScaleY(),
            setX: (x) => {
                if (this.parent) {
                    const globalScaleX = this.parent.globalScale.x;
                    this.matrix.setScaleX(x / globalScaleX);
                }
                else {
                    this.matrix.setScaleX(x);
                }
            },
            setY: (y) => {
                if (this.parent) {
                    const globalScaleY = this.parent.globalScale.y;
                    this.matrix.setScaleY(y / globalScaleY);
                }
                else {
                    this.matrix.setScaleY(y);
                }
            }
        });
    }
    set globalScale(val) {
        const parentTransform = this.parent;
        if (!parentTransform) {
            this.scale = val;
        }
        else {
            this.scale = vec(val.x / parentTransform.globalScale.x, val.y / parentTransform.globalScale.y);
        }
    }
    /**
     * Apply the transform to a point
     * @param point
     */
    apply(point) {
        return this.matrix.multv(point);
    }
    /**
     * Apply the inverse transform to a point
     * @param point
     */
    applyInverse(point) {
        return this.matrix.getAffineInverse().multv(point);
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Components/MotionComponent.ts


class MotionComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.motion';
        /**
         * The velocity of an entity in pixels per second
         */
        this.vel = Vector.Zero;
        /**
         * The acceleration of entity in pixels per second^2
         */
        this.acc = Vector.Zero;
        /**
         * The scale rate of change in scale units per second
         */
        this.scaleFactor = Vector.Zero;
        /**
         * The angular velocity which is how quickly the entity is rotating in radians per second
         */
        this.angularVelocity = 0;
        /**
         * The amount of torque applied to the entity, angular acceleration is torque * inertia
         */
        this.torque = 0;
        /**
         * Inerita can be thought of as the resistance to motion
         */
        this.inertia = 1;
    }
}

;// CONCATENATED MODULE: ./Collision/Group/CollisionGroup.ts
/**
 * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s
 *
 * For example:
 *
 * Players have collision group "player"
 *
 * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)
 *
 * Enemies have collision group "enemy"
 *
 * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)
 *
 * Blocks have collision group "ground"
 *
 * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)
 *
 * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide
 * with players and blocks.
 *
 * This is done with bitmasking, see the following pseudo-code
 *
 * PlayerGroup = `0b001`
 * PlayerGroupMask = `0b110`
 *
 * EnemyGroup = `0b010`
 * EnemyGroupMask = `0b101`
 *
 * BlockGroup = `0b100`
 * BlockGroupMask = `0b011`
 *
 * Should Players collide? No because the bitwise mask evaluates to 0
 * `(player1.group & player2.mask) === 0`
 * `(0b001 & 0b110) === 0`
 *
 * Should Players and Enemies collide? Yes because the bitwise mask is non-zero
 * `(player1.group & enemy1.mask) === 1`
 * `(0b001 & 0b101) === 1`
 *
 * Should Players and Blocks collide? Yes because the bitwise mask is non-zero
 * `(player1.group & blocks1.mask) === 1`
 * `(0b001 & 0b011) === 1`
 */
class CollisionGroup {
    /**
     * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups
     *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.
     * @param name Name of the collision group
     * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`
     * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`
     */
    constructor(name, category, mask) {
        this._name = name;
        this._category = category;
        this._mask = mask;
    }
    /**
     * Get the name of the collision group
     */
    get name() {
        return this._name;
    }
    /**
     * Get the category of the collision group, a 32 bit number which should be a unique power of 2
     */
    get category() {
        return this._category;
    }
    /**
     * Get the mask for this collision group
     */
    get mask() {
        return this._mask;
    }
    /**
     * Evaluates whether 2 collision groups can collide
     * @param other  CollisionGroup
     */
    canCollide(other) {
        return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;
    }
    /**
     * Inverts the collision group. For example, if before the group specified "players",
     * inverting would specify all groups except players
     * @returns CollisionGroup
     */
    invert() {
        return new CollisionGroup('~(' + this.name + ')', ~this.category, ~this.mask);
    }
    /**
     * Combine collision groups with each other. The new group includes all of the previous groups.
     *
     * @param collisionGroups
     * @returns
     */
    static combine(collisionGroups) {
        const combinedName = collisionGroups.map((c) => c.name).join('+');
        const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0b0);
        const combinedMask = ~combinedCategory;
        return new CollisionGroup(combinedName, combinedCategory, combinedMask);
    }
    /**
     * Creates a collision group that collides with the listed groups
     * @param collisionGroups
     */
    static collidesWith(collisionGroups) {
        return CollisionGroup.combine(collisionGroups).invert();
    }
}
/**
 * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,
 * it is the default collision group on colliders.
 */
CollisionGroup.All = new CollisionGroup('Collide with all groups', -1, -1);

;// CONCATENATED MODULE: ./Util/Observable.ts
/**
 * Simple Observable implemenation
 * @template T is the typescript Type that defines the data being observed
 */
class Observable {
    constructor() {
        this.observers = [];
        this.subscriptions = [];
    }
    /**
     * Register an observer to listen to this observable
     * @param observer
     */
    register(observer) {
        this.observers.push(observer);
    }
    /**
     * Register a callback to listen to this observable
     * @param func
     */
    subscribe(func) {
        this.subscriptions.push(func);
    }
    /**
     * Remove an observer from the observable
     * @param observer
     */
    unregister(observer) {
        const i = this.observers.indexOf(observer);
        if (i !== -1) {
            this.observers.splice(i, 1);
        }
    }
    /**
     * Remove a callback that is listening to this observable
     * @param func
     */
    unsubscribe(func) {
        const i = this.subscriptions.indexOf(func);
        if (i !== -1) {
            this.subscriptions.splice(i, 1);
        }
    }
    /**
     * Broadcasts a message to all observers and callbacks
     * @param message
     */
    notifyAll(message) {
        this.observers.forEach((o) => o.notify(message));
        this.subscriptions.forEach(cb => cb(message));
    }
    /**
     * Removes all observers and callbacks
     */
    clear() {
        this.observers.length = 0;
        this.subscriptions.length = 0;
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/Pair.ts


/**
 * Models a potential collision between 2 colliders
 */
class Pair {
    constructor(colliderA, colliderB) {
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.id = null;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
    }
    static canCollide(colliderA, colliderB) {
        var _a, _b;
        const bodyA = (_a = colliderA === null || colliderA === void 0 ? void 0 : colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = colliderB === null || colliderB === void 0 ? void 0 : colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        // Body's needed for collision in the current state
        // TODO can we collide without a body?
        if (!bodyA || !bodyB) {
            return false;
        }
        // If both are in the same collision group short circuit
        if (!bodyA.group.canCollide(bodyB.group)) {
            return false;
        }
        // if both are fixed short circuit
        if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {
            return false;
        }
        // if the either is prevent collision short circuit
        if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {
            return false;
        }
        // if either is dead short circuit
        if (!bodyA.active || !bodyB.active) {
            return false;
        }
        return true;
    }
    /**
     * Returns whether or not it is possible for the pairs to collide
     */
    get canCollide() {
        const colliderA = this.colliderA;
        const colliderB = this.colliderB;
        return Pair.canCollide(colliderA, colliderB);
    }
    /**
     * Runs the collision intersection logic on the members of this pair
     */
    collide() {
        return this.colliderA.collide(this.colliderB);
    }
    /**
     * Check if the collider is part of the pair
     * @param collider
     * @returns
     */
    hasCollider(collider) {
        return collider === this.colliderA || collider === this.colliderB;
    }
    /**
     * Calculates the unique pair hash id for this collision pair (owning id)
     */
    static calculatePairHash(idA, idB) {
        if (idA.value < idB.value) {
            return `#${idA.value}+${idB.value}`;
        }
        else {
            return `#${idB.value}+${idA.value}`;
        }
    }
}

;// CONCATENATED MODULE: ./Math/projection.ts
/**
 * A 1 dimensional projection on an axis, used to test overlaps
 */
class Projection {
    constructor(min, max) {
        this.min = min;
        this.max = max;
    }
    overlaps(projection) {
        return this.max > projection.min && projection.max > this.min;
    }
    getOverlap(projection) {
        if (this.overlaps(projection)) {
            if (this.max > projection.max) {
                return projection.max - this.min;
            }
            else {
                return this.max - projection.min;
            }
        }
        return 0;
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/DynamicTree.ts





/**
 * Dynamic Tree Node used for tracking bounds within the tree
 */
class TreeNode {
    constructor(parent) {
        this.parent = parent;
        this.parent = parent || null;
        this.data = null;
        this.bounds = new BoundingBox();
        this.left = null;
        this.right = null;
        this.height = 0;
    }
    isLeaf() {
        return !this.left && !this.right;
    }
}
/**
 * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for
 * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.
 *
 * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.
 * Every non-leaf node is a bounding box that contains child bounding boxes.
 */
class DynamicTree {
    constructor(worldBounds = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {
        this.worldBounds = worldBounds;
        this.root = null;
        this.nodes = {};
    }
    /**
     * Inserts a node into the dynamic tree
     */
    _insert(leaf) {
        // If there are no nodes in the tree, make this the root leaf
        if (this.root === null) {
            this.root = leaf;
            this.root.parent = null;
            return;
        }
        // Search the tree for a node that is not a leaf and find the best place to insert
        const leafAABB = leaf.bounds;
        let currentRoot = this.root;
        while (!currentRoot.isLeaf()) {
            const left = currentRoot.left;
            const right = currentRoot.right;
            const area = currentRoot.bounds.getPerimeter();
            const combinedAABB = currentRoot.bounds.combine(leafAABB);
            const combinedArea = combinedAABB.getPerimeter();
            // Calculate cost heuristic for creating a new parent and leaf
            const cost = 2 * combinedArea;
            // Minimum cost of pushing the leaf down the tree
            const inheritanceCost = 2 * (combinedArea - area);
            // Cost of descending
            let leftCost = 0;
            const leftCombined = leafAABB.combine(left.bounds);
            let newArea;
            let oldArea;
            if (left.isLeaf()) {
                leftCost = leftCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = left.bounds.getPerimeter();
                newArea = leftCombined.getPerimeter();
                leftCost = newArea - oldArea + inheritanceCost;
            }
            let rightCost = 0;
            const rightCombined = leafAABB.combine(right.bounds);
            if (right.isLeaf()) {
                rightCost = rightCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = right.bounds.getPerimeter();
                newArea = rightCombined.getPerimeter();
                rightCost = newArea - oldArea + inheritanceCost;
            }
            // cost is acceptable
            if (cost < leftCost && cost < rightCost) {
                break;
            }
            // Descend to the depths
            if (leftCost < rightCost) {
                currentRoot = left;
            }
            else {
                currentRoot = right;
            }
        }
        // Create the new parent node and insert into the tree
        const oldParent = currentRoot.parent;
        const newParent = new TreeNode(oldParent);
        newParent.bounds = leafAABB.combine(currentRoot.bounds);
        newParent.height = currentRoot.height + 1;
        if (oldParent !== null) {
            // The sibling node was not the root
            if (oldParent.left === currentRoot) {
                oldParent.left = newParent;
            }
            else {
                oldParent.right = newParent;
            }
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
        }
        else {
            // The sibling node was the root
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
            this.root = newParent;
        }
        // Walk up the tree fixing heights and AABBs
        let currentNode = leaf.parent;
        while (currentNode) {
            currentNode = this._balance(currentNode);
            if (!currentNode.left) {
                throw new Error('Parent of current leaf cannot have a null left child' + currentNode);
            }
            if (!currentNode.right) {
                throw new Error('Parent of current leaf cannot have a null right child' + currentNode);
            }
            currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
            currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
            currentNode = currentNode.parent;
        }
    }
    /**
     * Removes a node from the dynamic tree
     */
    _remove(leaf) {
        if (leaf === this.root) {
            this.root = null;
            return;
        }
        const parent = leaf.parent;
        const grandParent = parent.parent;
        let sibling;
        if (parent.left === leaf) {
            sibling = parent.right;
        }
        else {
            sibling = parent.left;
        }
        if (grandParent) {
            if (grandParent.left === parent) {
                grandParent.left = sibling;
            }
            else {
                grandParent.right = sibling;
            }
            sibling.parent = grandParent;
            let currentNode = grandParent;
            while (currentNode) {
                currentNode = this._balance(currentNode);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode = currentNode.parent;
            }
        }
        else {
            this.root = sibling;
            sibling.parent = null;
        }
    }
    /**
     * Tracks a body in the dynamic tree
     */
    trackCollider(collider) {
        const node = new TreeNode();
        node.data = collider;
        node.bounds = collider.bounds;
        node.bounds.left -= 2;
        node.bounds.top -= 2;
        node.bounds.right += 2;
        node.bounds.bottom += 2;
        this.nodes[collider.id.value] = node;
        this._insert(node);
    }
    /**
     * Updates the dynamic tree given the current bounds of each body being tracked
     */
    updateCollider(collider) {
        var _a;
        const node = this.nodes[collider.id.value];
        if (!node) {
            return false;
        }
        const b = collider.bounds;
        // if the body is outside the world no longer update it
        if (!this.worldBounds.contains(b)) {
            Logger.getInstance().warn('Collider with id ' + collider.id.value + ' is outside the world bounds and will no longer be tracked for physics');
            this.untrackCollider(collider);
            return false;
        }
        if (node.bounds.contains(b)) {
            return false;
        }
        this._remove(node);
        b.left -= Physics.boundsPadding;
        b.top -= Physics.boundsPadding;
        b.right += Physics.boundsPadding;
        b.bottom += Physics.boundsPadding;
        // THIS IS CAUSING UNECESSARY CHECKS
        if (collider.owner) {
            const body = (_a = collider.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            if (body) {
                const multdx = ((body.vel.x * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;
                const multdy = ((body.vel.y * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;
                if (multdx < 0) {
                    b.left += multdx;
                }
                else {
                    b.right += multdx;
                }
                if (multdy < 0) {
                    b.top += multdy;
                }
                else {
                    b.bottom += multdy;
                }
            }
        }
        node.bounds = b;
        this._insert(node);
        return true;
    }
    /**
     * Untracks a body from the dynamic tree
     */
    untrackCollider(collider) {
        const node = this.nodes[collider.id.value];
        if (!node) {
            return;
        }
        this._remove(node);
        this.nodes[collider.id.value] = null;
        delete this.nodes[collider.id.value];
    }
    /**
     * Balances the tree about a node
     */
    _balance(node) {
        if (node === null) {
            throw new Error('Cannot balance at null node');
        }
        if (node.isLeaf() || node.height < 2) {
            return node;
        }
        const left = node.left;
        const right = node.right;
        const a = node;
        const b = left;
        const c = right;
        const d = left.left;
        const e = left.right;
        const f = right.left;
        const g = right.right;
        const balance = c.height - b.height;
        // Rotate c node up
        if (balance > 1) {
            // Swap the right node with it's parent
            c.left = a;
            c.parent = a.parent;
            a.parent = c;
            // The original node's old parent should point to the right node
            // this is mega confusing
            if (c.parent) {
                if (c.parent.left === a) {
                    c.parent.left = c;
                }
                else {
                    c.parent.right = c;
                }
            }
            else {
                this.root = c;
            }
            // Rotate
            if (f.height > g.height) {
                c.right = f;
                a.right = g;
                g.parent = a;
                a.bounds = b.bounds.combine(g.bounds);
                c.bounds = a.bounds.combine(f.bounds);
                a.height = 1 + Math.max(b.height, g.height);
                c.height = 1 + Math.max(a.height, f.height);
            }
            else {
                c.right = g;
                a.right = f;
                f.parent = a;
                a.bounds = b.bounds.combine(f.bounds);
                c.bounds = a.bounds.combine(g.bounds);
                a.height = 1 + Math.max(b.height, f.height);
                c.height = 1 + Math.max(a.height, g.height);
            }
            return c;
        }
        // Rotate left node up
        if (balance < -1) {
            // swap
            b.left = a;
            b.parent = a.parent;
            a.parent = b;
            // node's old parent should point to b
            if (b.parent) {
                if (b.parent.left === a) {
                    b.parent.left = b;
                }
                else {
                    if (b.parent.right !== a) {
                        throw 'Error rotating Dynamic Tree';
                    }
                    b.parent.right = b;
                }
            }
            else {
                this.root = b;
            }
            // rotate
            if (d.height > e.height) {
                b.right = d;
                a.left = e;
                e.parent = a;
                a.bounds = c.bounds.combine(e.bounds);
                b.bounds = a.bounds.combine(d.bounds);
                a.height = 1 + Math.max(c.height, e.height);
                b.height = 1 + Math.max(a.height, d.height);
            }
            else {
                b.right = e;
                a.left = d;
                d.parent = a;
                a.bounds = c.bounds.combine(d.bounds);
                b.bounds = a.bounds.combine(e.bounds);
                a.height = 1 + Math.max(c.height, d.height);
                b.height = 1 + Math.max(a.height, e.height);
            }
            return b;
        }
        return node;
    }
    /**
     * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
     */
    getHeight() {
        if (this.root === null) {
            return 0;
        }
        return this.root.height;
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
     *
     * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
     * that you are complete with your query and you do not want to continue. Returning false will continue searching
     * the tree until all possible colliders have been returned.
     */
    query(collider, callback) {
        const bounds = collider.bounds;
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.intersect(bounds)) {
                if (currentNode.isLeaf() && currentNode.data !== collider) {
                    if (callback.call(collider, currentNode.data)) {
                        return true;
                    }
                }
                else {
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false;
        };
        helper(this.root);
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
     * long ray to test the tree specified by `max`.
     *
     * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this
     * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
     * the tree until all possible bodies that would intersect with the ray have been returned.
     */
    rayCastQuery(ray, max = Infinity, callback) {
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.rayCast(ray, max)) {
                if (currentNode.isLeaf()) {
                    if (callback.call(ray, currentNode.data)) {
                        // ray hit a leaf! return the body
                        return true;
                    }
                }
                else {
                    // ray hit but not at a leaf, recurse deeper
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false; // ray missed
        };
        helper(this.root);
    }
    getNodes() {
        const helper = (currentNode) => {
            if (currentNode) {
                return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
            }
            else {
                return [];
            }
        };
        return helper(this.root);
    }
    debug(ex) {
        // draw all the nodes in the Dynamic Tree
        const helper = (currentNode) => {
            if (currentNode) {
                if (currentNode.isLeaf()) {
                    currentNode.bounds.draw(ex, Color.Green);
                }
                else {
                    currentNode.bounds.draw(ex, Color.White);
                }
                if (currentNode.left) {
                    helper(currentNode.left);
                }
                if (currentNode.right) {
                    helper(currentNode.right);
                }
            }
        };
        helper(this.root);
    }
}

;// CONCATENATED MODULE: ./Math/ray.ts
/**
 * A 2D ray that can be cast into the scene to do collision detection
 */
class Ray {
    /**
     * @param pos The starting position for the ray
     * @param dir The vector indicating the direction of the ray
     */
    constructor(pos, dir) {
        this.pos = pos;
        this.dir = dir.normalize();
    }
    /**
     * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
     * This number indicates the mathematical intersection time.
     * @param line  The line to test
     */
    intersect(line) {
        const numerator = line.begin.sub(this.pos);
        // Test is line and ray are parallel and non intersecting
        if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
            return -1;
        }
        // Lines are parallel
        const divisor = this.dir.cross(line.getSlope());
        if (divisor === 0) {
            return -1;
        }
        const t = numerator.cross(line.getSlope()) / divisor;
        if (t >= 0) {
            const u = numerator.cross(this.dir) / divisor / line.getLength();
            if (u >= 0 && u <= 1) {
                return t;
            }
        }
        return -1;
    }
    intersectPoint(line) {
        const time = this.intersect(line);
        if (time < 0) {
            return null;
        }
        return this.getPoint(time);
    }
    /**
     * Returns the point of intersection given the intersection time
     */
    getPoint(time) {
        return this.pos.add(this.dir.scale(time));
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/DynamicTreeCollisionProcessor.ts









/**
 * Responsible for performing the collision broadphase (locating potential colllisions) and
 * the narrowphase (actual collision contacts)
 */
class DynamicTreeCollisionProcessor {
    constructor() {
        this._dynamicCollisionTree = new DynamicTree();
        this._collisions = new Set();
        this._collisionPairCache = [];
        this._colliders = [];
    }
    getColliders() {
        return this._colliders;
    }
    /**
     * Tracks a physics body for collisions
     */
    track(target) {
        if (!target) {
            Logger.getInstance().warn('Cannot track null collider');
            return;
        }
        if (target instanceof CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                c.owner = target.owner;
                this._colliders.push(c);
                this._dynamicCollisionTree.trackCollider(c);
            }
        }
        else {
            this._colliders.push(target);
            this._dynamicCollisionTree.trackCollider(target);
        }
    }
    /**
     * Untracks a physics body
     */
    untrack(target) {
        if (!target) {
            Logger.getInstance().warn('Cannot untrack a null collider');
            return;
        }
        if (target instanceof CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                const index = this._colliders.indexOf(c);
                if (index !== -1) {
                    this._colliders.splice(index, 1);
                }
                this._dynamicCollisionTree.untrackCollider(c);
            }
        }
        else {
            const index = this._colliders.indexOf(target);
            if (index !== -1) {
                this._colliders.splice(index, 1);
            }
            this._dynamicCollisionTree.untrackCollider(target);
        }
    }
    _shouldGenerateCollisionPair(colliderA, colliderB) {
        // if the collision pair must be 2 separate colliders
        // Also separate owners for composite colliders
        if ((colliderA.id !== null &&
            colliderB.id !== null &&
            colliderA.id === colliderB.id) ||
            (colliderA.owner !== null &&
                colliderB.owner !== null &&
                colliderA.owner === colliderB.owner)) {
            return false;
        }
        // if the collision pair has been calculated already short circuit
        const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);
        if (this._collisions.has(hash)) {
            return false; // pair exists easy exit return false
        }
        // if the pair has a member with zero dimension
        if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {
            return false;
        }
        return Pair.canCollide(colliderA, colliderB);
    }
    /**
     * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
     */
    broadphase(targets, delta, stats) {
        const seconds = delta / 1000;
        // Retrieve the list of potential colliders, exclude killed, prevented, and self
        const potentialColliders = targets.filter((other) => {
            var _a, _b;
            const body = (_a = other.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            return ((_b = other.owner) === null || _b === void 0 ? void 0 : _b.active) && body.collisionType !== CollisionType.PreventCollision;
        });
        // clear old list of collision pairs
        this._collisionPairCache = [];
        this._collisions.clear();
        // check for normal collision pairs
        let collider;
        for (let j = 0, l = potentialColliders.length; j < l; j++) {
            collider = potentialColliders[j];
            // Query the collision tree for potential colliders
            this._dynamicCollisionTree.query(collider, (other) => {
                if (this._shouldGenerateCollisionPair(collider, other)) {
                    const pair = new Pair(collider, other);
                    this._collisions.add(pair.id);
                    this._collisionPairCache.push(pair);
                }
                // Always return false, to query whole tree. Returning true in the query method stops searching
                return false;
            });
        }
        if (stats) {
            stats.physics.pairs = this._collisionPairCache.length;
        }
        // Check dynamic tree for fast moving objects
        // Fast moving objects are those moving at least there smallest bound per frame
        if (Physics.checkForFastBodies) {
            for (const collider of potentialColliders) {
                const body = collider.owner.get(BodyComponent);
                // Skip non-active objects. Does not make sense on other collision types
                if (body.collisionType !== CollisionType.Active) {
                    continue;
                }
                // Maximum travel distance next frame
                const updateDistance = body.vel.size * seconds + // velocity term
                    body.acc.size * 0.5 * seconds * seconds; // acc term
                // Find the minimum dimension
                const minDimension = Math.min(collider.bounds.height, collider.bounds.width);
                if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {
                    if (stats) {
                        stats.physics.fastBodies++;
                    }
                    // start with the oldPos because the integration for actors has already happened
                    // objects resting on a surface may be slightly penetrating in the current position
                    const updateVec = body.pos.sub(body.oldPos);
                    const centerPoint = collider.center;
                    const furthestPoint = collider.getFurthestPoint(body.vel);
                    const origin = furthestPoint.sub(updateVec);
                    const ray = new Ray(origin, body.vel);
                    // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface
                    ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));
                    let minCollider;
                    let minTranslate = new Vector(Infinity, Infinity);
                    this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other) => {
                        if (collider !== other && Pair.canCollide(collider, other)) {
                            const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);
                            if (hitPoint) {
                                const translate = hitPoint.sub(origin);
                                if (translate.size < minTranslate.size) {
                                    minTranslate = translate;
                                    minCollider = other;
                                }
                            }
                        }
                        return false;
                    });
                    if (minCollider && Vector.isValid(minTranslate)) {
                        const pair = new Pair(collider, minCollider);
                        if (!this._collisions.has(pair.id)) {
                            this._collisions.add(pair.id);
                            this._collisionPairCache.push(pair);
                        }
                        // move the fast moving object to the other body
                        // need to push into the surface by ex.Physics.surfaceEpsilon
                        const shift = centerPoint.sub(furthestPoint);
                        body.pos = origin
                            .add(shift)
                            .add(minTranslate)
                            .add(ray.dir.scale(10 * Physics.surfaceEpsilon)); // needed to push the shape slightly into contact
                        collider.update(body.transform);
                        if (stats) {
                            stats.physics.fastBodyCollisions++;
                        }
                    }
                }
            }
        }
        // return cache
        return this._collisionPairCache;
    }
    /**
     * Applies narrow phase on collision pairs to find actual area intersections
     * Adds actual colliding pairs to stats' Frame data
     */
    narrowphase(pairs, stats) {
        let contacts = [];
        for (let i = 0; i < pairs.length; i++) {
            const newContacts = pairs[i].collide();
            contacts = contacts.concat(newContacts);
            if (stats && newContacts.length > 0) {
                for (const c of newContacts) {
                    stats.physics.contacts.set(c.id, c);
                }
            }
        }
        if (stats) {
            stats.physics.collisions += contacts.length;
        }
        return contacts;
    }
    /**
     * Update the dynamic tree positions
     */
    update(targets) {
        let updated = 0;
        const len = targets.length;
        for (let i = 0; i < len; i++) {
            if (this._dynamicCollisionTree.updateCollider(targets[i])) {
                updated++;
            }
        }
        return updated;
    }
    debug(ex) {
        this._dynamicCollisionTree.debug(ex);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/Collider.ts


/**
 * A collision collider specifies the geometry that can detect when other collision colliders intersect
 * for the purposes of colliding 2 objects in excalibur.
 */
class Collider {
    constructor() {
        this.id = createId('collider', Collider._ID++);
        this.events = new EventDispatcher(this);
    }
    /**
     * Returns a boolean indicating whether this body collided with
     * or was in stationary contact with
     * the body of the other [[Collider]]
     */
    touching(other) {
        const contact = this.collide(other);
        if (contact) {
            return true;
        }
        return false;
    }
}
Collider._ID = 0;

;// CONCATENATED MODULE: ./Collision/Colliders/CompositeCollider.ts








class CompositeCollider extends Collider {
    constructor(colliders) {
        super();
        this._collisionProcessor = new DynamicTreeCollisionProcessor();
        this._dynamicAABBTree = new DynamicTree();
        this._colliders = [];
        for (const c of colliders) {
            this.addCollider(c);
        }
    }
    clearColliders() {
        this._colliders = [];
    }
    addCollider(collider) {
        this.events.wire(collider.events);
        this._colliders.push(collider);
        this._collisionProcessor.track(collider);
        this._dynamicAABBTree.trackCollider(collider);
    }
    removeCollider(collider) {
        this.events.unwire(collider.events);
        removeItemFromArray(collider, this._colliders);
        this._collisionProcessor.untrack(collider);
        this._dynamicAABBTree.untrackCollider(collider);
    }
    getColliders() {
        return this._colliders;
    }
    get worldPos() {
        var _a, _b;
        // TODO transform component world pos
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get center() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get bounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.bounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox().translate(this.worldPos));
        return results;
    }
    get localBounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox());
        return results;
    }
    get axes() {
        // TODO cache this
        const colliders = this.getColliders();
        let axes = [];
        for (const collider of colliders) {
            axes = axes.concat(collider.axes);
        }
        return axes;
    }
    getFurthestPoint(direction) {
        const colliders = this.getColliders();
        const furthestPoints = [];
        for (const collider of colliders) {
            furthestPoints.push(collider.getFurthestPoint(direction));
        }
        // Pick best point from all colliders
        let bestPoint = furthestPoints[0];
        let maxDistance = -Number.MAX_VALUE;
        for (const point of furthestPoints) {
            const distance = point.dot(direction);
            if (distance > maxDistance) {
                bestPoint = point;
                maxDistance = distance;
            }
        }
        return bestPoint;
    }
    getInertia(mass) {
        const colliders = this.getColliders();
        let totalInertia = 0;
        for (const collider of colliders) {
            totalInertia += collider.getInertia(mass);
        }
        return totalInertia;
    }
    collide(other) {
        let otherColliders = [other];
        if (other instanceof CompositeCollider) {
            otherColliders = other.getColliders();
        }
        const pairs = [];
        for (const c of otherColliders) {
            this._dynamicAABBTree.query(c, (potentialCollider) => {
                pairs.push(new Pair(c, potentialCollider));
                return false;
            });
        }
        let contacts = [];
        for (const p of pairs) {
            contacts = contacts.concat(p.collide());
        }
        return contacts;
    }
    getClosestLineBetween(other) {
        const colliders = this.getColliders();
        const lines = [];
        if (other instanceof CompositeCollider) {
            const otherColliders = other.getColliders();
            for (const colliderA of colliders) {
                for (const colliderB of otherColliders) {
                    const maybeLine = colliderA.getClosestLineBetween(colliderB);
                    if (maybeLine) {
                        lines.push(maybeLine);
                    }
                }
            }
        }
        else {
            for (const collider of colliders) {
                const maybeLine = other.getClosestLineBetween(collider);
                if (maybeLine) {
                    lines.push(maybeLine);
                }
            }
        }
        if (lines.length) {
            let minLength = lines[0].getLength();
            let minLine = lines[0];
            for (const line of lines) {
                const length = line.getLength();
                if (length < minLength) {
                    minLength = length;
                    minLine = line;
                }
            }
            return minLine;
        }
        return null;
    }
    contains(point) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            if (collider.contains(point)) {
                return true;
            }
        }
        return false;
    }
    rayCast(ray, max) {
        const colliders = this.getColliders();
        const points = [];
        for (const collider of colliders) {
            const vec = collider.rayCast(ray, max);
            if (vec) {
                points.push(vec);
            }
        }
        if (points.length) {
            let minPoint = points[0];
            let minDistance = minPoint.dot(ray.dir);
            for (const point of points) {
                const distance = ray.dir.dot(point);
                if (distance < minDistance) {
                    minPoint = point;
                    minDistance = distance;
                }
            }
            return minPoint;
        }
        return null;
    }
    project(axis) {
        const colliders = this.getColliders();
        const projs = [];
        for (const collider of colliders) {
            const proj = collider.project(axis);
            if (proj) {
                projs.push(proj);
            }
        }
        // Merge all proj's on the same axis
        if (projs.length) {
            const newProjection = new Projection(projs[0].min, projs[0].max);
            for (const proj of projs) {
                newProjection.min = Math.min(proj.min, newProjection.min);
                newProjection.max = Math.max(proj.max, newProjection.max);
            }
            return newProjection;
        }
        return null;
    }
    update(transform) {
        if (transform) {
            const colliders = this.getColliders();
            for (const collider of colliders) {
                collider.owner = this.owner;
                collider.update(transform);
            }
        }
    }
    draw(ctx, color, pos) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            collider.draw(ctx, color, pos);
        }
    }
    debug(ex, color) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            collider.debug(ex, color);
        }
    }
    debugDraw(ctx, color) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            collider.draw(ctx, color);
        }
    }
    clone() {
        return new CompositeCollider(this._colliders.map((c) => c.clone()));
    }
}

;// CONCATENATED MODULE: ./Math/line.ts

/**
 * A 2D line segment
 */
class Line {
    /**
     * @param begin  The starting point of the line segment
     * @param end  The ending point of the line segment
     */
    constructor(begin, end) {
        this.begin = begin;
        this.end = end;
    }
    /**
     * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
     */
    get slope() {
        return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
    }
    /**
     * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
     */
    get intercept() {
        return this.begin.y - this.slope * this.begin.x;
    }
    /**
     * Gets the normal of the line
     */
    normal() {
        return this.end.sub(this.begin).normal();
    }
    dir() {
        return this.end.sub(this.begin);
    }
    getPoints() {
        return [this.begin, this.end];
    }
    /**
     * Returns the slope of the line in the form of a vector of length 1
     */
    getSlope() {
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the edge of the line as vector, the length of the vector is the length of the edge
     */
    getEdge() {
        const begin = this.begin;
        const end = this.end;
        return end.sub(begin);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Returns the midpoint of the edge
     */
    get midpoint() {
        return this.begin.add(this.end).scale(0.5);
    }
    /**
     * Flips the direction of the line segment
     */
    flip() {
        return new Line(this.end, this.begin);
    }
    /**
     * Tests if a given point is below the line, points in the normal direction above the line are considered above.
     * @param point
     */
    below(point) {
        const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);
        return above2 >= 0;
    }
    /**
     * Returns the clip point
     * @param sideVector Vector that traces the line
     * @param length Length to clip along side
     */
    clip(sideVector, length) {
        let dir = sideVector;
        dir = dir.normalize();
        const near = dir.dot(this.begin) - length;
        const far = dir.dot(this.end) - length;
        const results = [];
        if (near <= 0) {
            results.push(this.begin);
        }
        if (far <= 0) {
            results.push(this.end);
        }
        if (near * far < 0) {
            const clipTime = near / (near - far);
            results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));
        }
        if (results.length !== 2) {
            return null;
        }
        return new Line(results[0], results[1]);
    }
    /**
     * Find the perpendicular distance from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * @param point
     */
    distanceToPoint(point, signed = false) {
        const x0 = point.x;
        const y0 = point.y;
        const l = this.getLength();
        const dy = this.end.y - this.begin.y;
        const dx = this.end.x - this.begin.x;
        const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
        return signed ? distance : Math.abs(distance);
    }
    /**
     * Find the perpendicular line from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * (a - p) - ((a - p) * n)n
     * a is a point on the line
     * p is the arbitrary point above the line
     * n is a unit vector in direction of the line
     * @param point
     */
    findVectorToPoint(point) {
        const aMinusP = this.begin.sub(point);
        const n = this.getSlope();
        return aMinusP.sub(n.scale(aMinusP.dot(n)));
    }
    /**
     * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
     * a new point with the calculated Y value and vice-versa.
     *
     * @param x The known X value of the target point
     * @param y The known Y value of the target point
     * @returns A new point with the other calculated axis value
     */
    findPoint(x = null, y = null) {
        const m = this.slope;
        const b = this.intercept;
        if (x !== null) {
            return new Vector(x, m * x + b);
        }
        else if (y !== null) {
            return new Vector((y - b) / m, y);
        }
        else {
            throw new Error('You must provide an X or a Y value');
        }
    }
    /**
     * @see http://stackoverflow.com/a/11908158/109458
     */
    hasPoint() {
        let currPoint;
        let threshold = 0;
        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            currPoint = new Vector(arguments[0], arguments[1]);
            threshold = arguments[2] || 0;
        }
        else if (arguments[0] instanceof Vector) {
            currPoint = arguments[0];
            threshold = arguments[1] || 0;
        }
        else {
            throw 'Could not determine the arguments for Vector.hasPoint';
        }
        const dxc = currPoint.x - this.begin.x;
        const dyc = currPoint.y - this.begin.y;
        const dx1 = this.end.x - this.begin.x;
        const dy1 = this.end.y - this.begin.y;
        const cross = dxc * dy1 - dyc * dx1;
        // check whether point lines on the line
        if (Math.abs(cross) > threshold) {
            return false;
        }
        // check whether point lies in-between start and end
        if (Math.abs(dx1) >= Math.abs(dy1)) {
            return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
        }
        else {
            return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/ClosestLineJumpTable.ts



/**
 * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment
 * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
 * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
 * @param p0 Point where L1 begins
 * @param u Direction and length of L1
 * @param q0 Point were L2 begins
 * @param v Direction and length of L2
 */
function ClosestLine(p0, u, q0, v) {
    // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html
    // w(s, t) = P(s) - Q(t)
    // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest
    //
    // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.
    // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0
    //
    // The closest point between 2 lines then satisfies this pair of equations
    // 1: u * wClosest = 0
    // 2: v * wClosest = 0
    //
    // Substituting wClosest into the equations we get
    //
    // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0
    // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0
    // simplify w0
    const w0 = p0.sub(q0);
    // simplify (u * u);
    const a = u.dot(u);
    // simplify (u * v);
    const b = u.dot(v);
    // simplify (v * v)
    const c = v.dot(v);
    // simplify (u * w0)
    const d = u.dot(w0);
    // simplify (v * w0)
    const e = v.dot(w0);
    // denominator ac - b^2
    const denom = a * c - b * b;
    let sDenom = denom;
    let tDenom = denom;
    // if denom is 0 they are parallel, use any point from either as the start in this case p0
    if (denom === 0 || denom <= 0.01) {
        const tClosestParallel = d / b;
        return new Line(p0, q0.add(v.scale(tClosestParallel)));
    }
    // Solve for sClosest for infinite line
    let sClosest = b * e - c * d; // / denom;
    // Solve for tClosest for infinite line
    let tClosest = a * e - b * d; // / denom;
    // Solve for segments candidate edges, if sClosest and tClosest are outside their segments
    if (sClosest < 0) {
        sClosest = 0;
        tClosest = e;
        tDenom = c;
    }
    else if (sClosest > sDenom) {
        sClosest = sDenom;
        tClosest = e + b;
        tDenom = c;
    }
    if (tClosest < 0) {
        tClosest = 0;
        if (-d < 0) {
            sClosest = 0;
        }
        else if (-d > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d;
            sDenom = a;
        }
    }
    else if (tClosest > tDenom) {
        tClosest = tDenom;
        if (-d + b < 0) {
            sClosest = 0;
        }
        else if (-d + b > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d + b;
            sDenom = a;
        }
    }
    sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;
    tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;
    return new Line(p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));
}
const ClosestLineJumpTable = {
    PolygonPolygonClosestLine(polygonA, polygonB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = polygonB.worldPos;
        const otherDirection = otherWorldPos.sub(polygonA.worldPos);
        const thisDirection = otherDirection.negate();
        const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);
        const rayTowardsThis = new Ray(otherWorldPos, thisDirection);
        const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));
        const thisFace = polygonA.getClosestFace(thisPoint);
        const otherFace = polygonB.getClosestFace(otherPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const q0 = otherFace.face.begin;
        const v = otherFace.face.getEdge();
        return ClosestLine(p0, u, q0, v);
    },
    PolygonEdgeClosestLine(polygon, edge) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = edge.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const q0 = edgeStart;
        const v = edgeVector;
        return ClosestLine(p0, u, q0, v);
    },
    PolygonCircleClosestLine(polygon, circle) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circle.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // Time of minimum distance
        let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);
        return new Line(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));
    },
    CircleCircleClosestLine(circleA, circleB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circleB.worldPos;
        const otherDirection = otherWorldPos.sub(circleA.worldPos);
        const thisWorldPos = circleA.worldPos;
        const thisDirection = thisWorldPos.sub(circleB.worldPos);
        const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);
        const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);
        const thisPoint = circleA.rayCast(rayTowardsOther);
        const otherPoint = circleB.rayCast(rayTowardsThis);
        return new Line(thisPoint, otherPoint);
    },
    CircleEdgeClosestLine(circle, edge) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        const circleWorlPos = circle.worldPos;
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const p0 = edgeStart;
        const u = edgeVector;
        // Time of minimum distance
        let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp to edge
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - circleWorlPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - circleWorlPos.y) * circle.radius) / (circle.radius + d);
        return new Line(u.scale(t).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));
    },
    EdgeEdgeClosestLine(edgeA, edgeB) {
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLineA = edgeA.asLine();
        const edgeStartA = edgeLineA.begin;
        const edgeVectorA = edgeLineA.getEdge();
        const p0 = edgeStartA;
        const u = edgeVectorA;
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLineB = edgeB.asLine();
        const edgeStartB = edgeLineB.begin;
        const edgeVectorB = edgeLineB.getEdge();
        const q0 = edgeStartB;
        const v = edgeVectorB;
        return ClosestLine(p0, u, q0, v);
    }
};

;// CONCATENATED MODULE: ./Collision/Colliders/CircleCollider.ts









/**
 * This is a circle collider for the excalibur rigid body physics simulation
 */
class CircleCollider extends Collider {
    constructor(options) {
        super();
        /**
         * Position of the circle relative to the collider, by default (0, 0).
         */
        this.offset = Vector.Zero;
        this.offset = options.offset || Vector.Zero;
        this.radius = options.radius || 0;
    }
    get worldPos() {
        var _a, _b;
        return this.offset.add((_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero);
    }
    /**
     * Returns a clone of this shape, not associated with any collider
     */
    clone() {
        return new CircleCollider({
            offset: this.offset.clone(),
            radius: this.radius
        });
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        var _a, _b;
        return this.offset.add((_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero);
    }
    /**
     * Tests if a point is contained in this collider
     */
    contains(point) {
        var _a, _b;
        const pos = (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : this.offset;
        const distance = pos.distance(point);
        if (distance <= this.radius) {
            return true;
        }
        return false;
    }
    /**
     * Casts a ray at the Circle collider and returns the nearest point of collision
     * @param ray
     */
    rayCast(ray, max = Infinity) {
        //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
        const c = this.center;
        const dir = ray.dir;
        const orig = ray.pos;
        const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));
        if (discriminant < 0) {
            // no intersection
            return null;
        }
        else {
            let toi = 0;
            if (discriminant === 0) {
                toi = -dir.dot(orig.sub(c));
                if (toi > 0 && toi < max) {
                    return ray.getPoint(toi);
                }
                return null;
            }
            else {
                const toi1 = -dir.dot(orig.sub(c)) + discriminant;
                const toi2 = -dir.dot(orig.sub(c)) - discriminant;
                const positiveToi = [];
                if (toi1 >= 0) {
                    positiveToi.push(toi1);
                }
                if (toi2 >= 0) {
                    positiveToi.push(toi2);
                }
                const mintoi = Math.min(...positiveToi);
                if (mintoi <= max) {
                    return ray.getPoint(mintoi);
                }
                return null;
            }
        }
    }
    getClosestLineBetween(shape) {
        if (shape instanceof CircleCollider) {
            return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);
        }
        else if (shape instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();
        }
        else if (shape instanceof EdgeCollider) {
            return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(collider) {
        if (collider instanceof CircleCollider) {
            return CollisionJumpTable.CollideCircleCircle(this, collider);
        }
        else if (collider instanceof PolygonCollider) {
            return CollisionJumpTable.CollideCirclePolygon(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return CollisionJumpTable.CollideCircleEdge(this, collider);
        }
        else {
            throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        return this.center.add(direction.normalize().scale(this.radius));
    }
    /**
     * Find the local point on the shape in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const dir = direction.normalize();
        return dir.scale(this.radius);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in world coordinates
     */
    get bounds() {
        var _a;
        const tx = this._transform;
        const bodyPos = (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _a !== void 0 ? _a : Vector.Zero;
        return new BoundingBox(this.offset.x + bodyPos.x - this.radius, this.offset.y + bodyPos.y - this.radius, this.offset.x + bodyPos.x + this.radius, this.offset.y + bodyPos.y + this.radius);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in local coordinates
     */
    get localBounds() {
        return new BoundingBox(this.offset.x - this.radius, this.offset.y - this.radius, this.offset.x + this.radius, this.offset.y + this.radius);
    }
    /**
     * Get axis not implemented on circles, since there are infinite axis in a circle
     */
    get axes() {
        return [];
    }
    /**
     * Returns the moment of inertia of a circle given it's mass
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        return (mass * this.radius * this.radius) / 2;
    }
    /* istanbul ignore next */
    update(transform) {
        this._transform = transform;
    }
    /**
     * Project the circle along a specified axis
     */
    project(axis) {
        const scalars = [];
        const point = this.center;
        const dotProduct = point.dot(axis);
        scalars.push(dotProduct);
        scalars.push(dotProduct + this.radius);
        scalars.push(dotProduct - this.radius);
        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    draw(ctx, color = Color.Green, pos = Vector.Zero) {
        const newPos = pos.add(this.offset);
        ctx.beginPath();
        ctx.fillStyle = color.toString();
        ctx.arc(newPos.x, newPos.y, this.radius, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
    }
    debug(ex, color) {
        const tx = this._transform;
        const pos = (tx === null || tx === void 0 ? void 0 : tx.globalPos) ? tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset) : this.offset;
        ex.drawCircle(pos, this.radius, color);
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Green) {
        const transform = this._transform;
        const pos = transform ? transform.pos.add(this.offset) : this.offset;
        const rotation = transform ? transform.rotation : 0;
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        ctx.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(Math.cos(rotation) * this.radius + pos.x, Math.sin(rotation) * this.radius + pos.y);
        ctx.closePath();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/CollisionContact.ts




/**
 * Collision contacts are used internally by Excalibur to resolve collision between colliders. This
 * Pair prevents collisions from being evaluated more than one time
 */
class CollisionContact {
    constructor(colliderA, colliderB, mtv, normal, tangent, points, localPoints, info) {
        this._canceled = false;
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.mtv = mtv;
        this.normal = normal;
        this.tangent = tangent;
        this.points = points;
        this.localPoints = localPoints;
        this.info = info;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
    }
    /**
     * Match contact awake state, except if body's are Fixed
     */
    matchAwake() {
        const bodyA = this.colliderA.owner.get(BodyComponent);
        const bodyB = this.colliderB.owner.get(BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.sleeping !== bodyB.sleeping) {
                if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) {
                    bodyA.setSleeping(false);
                }
                if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) {
                    bodyB.setSleeping(false);
                }
            }
        }
    }
    isCanceled() {
        return this._canceled;
    }
    cancel() {
        this._canceled = true;
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/SeparatingAxis.ts
class SeparatingAxis {
    static findPolygonPolygonSeparation(polyA, polyB) {
        let bestSeparation = -Number.MAX_VALUE;
        let bestSide = null;
        let bestAxis = null;
        let bestSideIndex = -1;
        let bestOtherPoint = null;
        const sides = polyA.getSides();
        const localSides = polyA.getLocalSides();
        for (let i = 0; i < sides.length; i++) {
            const side = sides[i];
            const axis = side.normal();
            const vertB = polyB.getFurthestPoint(axis.negate());
            // Separation on side i's axis
            // We are looking for the largest separation between poly A's sides
            const vertSeparation = side.distanceToPoint(vertB, true);
            if (vertSeparation > bestSeparation) {
                bestSeparation = vertSeparation;
                bestSide = side;
                bestAxis = axis;
                bestSideIndex = i;
                bestOtherPoint = vertB;
            }
        }
        return {
            collider: polyA,
            separation: bestAxis ? bestSeparation : 99,
            axis: bestAxis,
            side: bestSide,
            localSide: localSides[bestSideIndex],
            sideId: bestSideIndex,
            point: bestOtherPoint,
            localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis.negate()) : null
        };
    }
    static findCirclePolygonSeparation(circle, polygon) {
        const axes = polygon.axes;
        const pc = polygon.center;
        // Special SAT with circles
        const polyDir = pc.sub(circle.worldPos);
        const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());
        axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());
        let minOverlap = Number.MAX_VALUE;
        let minAxis = null;
        let minIndex = -1;
        for (let i = 0; i < axes.length; i++) {
            const proj1 = polygon.project(axes[i]);
            const proj2 = circle.project(axes[i]);
            const overlap = proj1.getOverlap(proj2);
            if (overlap <= 0) {
                return null;
            }
            else {
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    minAxis = axes[i];
                    minIndex = i;
                }
            }
        }
        if (minIndex < 0) {
            return null;
        }
        return minAxis.normalize().scale(minOverlap);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/CollisionJumpTable.ts








const CollisionJumpTable = {
    CollideCircleCircle(circleA, circleB) {
        const circleAPos = circleA.worldPos;
        const circleBPos = circleB.worldPos;
        const combinedRadius = circleA.radius + circleB.radius;
        const distance = circleAPos.distance(circleBPos);
        if (distance > combinedRadius) {
            return [];
        }
        // negative means overlap
        const separation = combinedRadius - distance;
        // Normal points from A -> B
        const normal = circleBPos.sub(circleAPos).normalize();
        const tangent = normal.perpendicular();
        const mvt = normal.scale(separation);
        const point = circleA.getFurthestPoint(normal);
        const local = circleA.getFurthestLocalPoint(normal);
        const info = {
            collider: circleA,
            separation,
            axis: normal,
            point: point
        };
        return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point], [local], info)];
    },
    CollideCirclePolygon(circle, polygon) {
        var _a, _b;
        let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle, polygon);
        if (!minAxis) {
            return [];
        }
        // make sure that the minAxis is pointing away from circle
        const samedir = minAxis.dot(polygon.center.sub(circle.center));
        minAxis = samedir < 0 ? minAxis.negate() : minAxis;
        const point = circle.getFurthestPoint(minAxis);
        const xf = (_b = (_a = circle.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
        const local = xf.applyInverse(point);
        const normal = minAxis.normalize();
        const info = {
            collider: circle,
            separation: -minAxis.size,
            axis: normal,
            point: point,
            localPoint: local,
            side: polygon.findSide(normal.negate()),
            localSide: polygon.findLocalSide(normal.negate())
        };
        return [new CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [point], [local], info)];
    },
    CollideCircleEdge(circle, edge) {
        // TODO not sure this actually abides by local/world collisions
        // Are edge.begin and edge.end local space or world space? I think they should be local
        // center of the circle in world pos
        const cc = circle.center;
        // vector in the direction of the edge
        const edgeWorld = edge.asLine();
        const e = edgeWorld.end.sub(edgeWorld.begin);
        // amount of overlap with the circle's center along the edge direction
        const u = e.dot(edgeWorld.end.sub(cc));
        const v = e.dot(cc.sub(edgeWorld.begin));
        const side = edge.asLine();
        const localSide = edge.asLocalLine();
        // Potential region A collision (circle is on the left side of the edge, before the beginning)
        if (v <= 0) {
            const da = edgeWorld.begin.sub(cc);
            const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts
            // save some sqrts
            if (dda > circle.radius * circle.radius) {
                return []; // no collision
            }
            const normal = da.normalize();
            const separation = circle.radius - Math.sqrt(dda);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.begin,
                side: side,
                localSide: localSide
            };
            return [
                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.begin], [localSide.begin], info)
            ];
        }
        // Potential region B collision (circle is on the right side of the edge, after the end)
        if (u <= 0) {
            const db = edgeWorld.end.sub(cc);
            const ddb = db.dot(db);
            if (ddb > circle.radius * circle.radius) {
                return [];
            }
            const normal = db.normalize();
            const separation = circle.radius - Math.sqrt(ddb);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.end,
                side: side,
                localSide: localSide
            };
            return [
                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.end], [localSide.end], info)
            ];
        }
        // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)
        const den = e.dot(e);
        const pointOnEdge = edgeWorld.begin
            .scale(u)
            .add(edgeWorld.end.scale(v))
            .scale(1 / den);
        const d = cc.sub(pointOnEdge);
        const dd = d.dot(d);
        if (dd > circle.radius * circle.radius) {
            return []; // no collision
        }
        let normal = e.perpendicular();
        // flip correct direction
        if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        normal = normal.normalize();
        const separation = circle.radius - Math.sqrt(dd);
        const mvt = normal.scale(separation);
        const info = {
            collider: circle,
            separation: separation,
            axis: normal,
            point: pointOnEdge,
            side: side,
            localSide: localSide
        };
        return [
            new CollisionContact(circle, edge, mvt, normal.negate(), normal.negate().perpendicular(), [pointOnEdge], [pointOnEdge.sub(edge.worldPos)], info)
        ];
    },
    CollideEdgeEdge() {
        // Edge-edge collision doesn't make sense
        return [];
    },
    CollidePolygonEdge(polygon, edge) {
        var _a;
        const pc = polygon.center;
        const ec = edge.center;
        const dir = ec.sub(pc).normalize();
        // build a temporary polygon from the edge to use SAT
        const linePoly = new PolygonCollider({
            points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],
            offset: edge.offset
        });
        linePoly.owner = edge.owner;
        const tx = (_a = edge.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
        if (tx) {
            linePoly.update(edge.owner.get(TransformComponent));
        }
        // Gross hack but poly-poly works well
        const contact = this.CollidePolygonPolygon(polygon, linePoly);
        if (contact.length) {
            // Fudge the contact back to edge
            contact[0].colliderB = edge;
            contact[0].id = Pair.calculatePairHash(polygon.id, edge.id);
            // contact[0].info.collider
        }
        return contact;
    },
    CollidePolygonPolygon(polyA, polyB) {
        var _a, _b, _c, _d;
        // Multi contact from SAT
        // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection
        // do a SAT test to find a min axis if it exists
        const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);
        // If there is no overlap from boxA's perspective we can end early
        if (separationA.separation > 0) {
            return [];
        }
        const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);
        // If there is no overlap from boxB's perspective exit now
        if (separationB.separation > 0) {
            return [];
        }
        // Separations are both negative, we want to pick the least negative (minimal movement)
        const separation = separationA.separation > separationB.separation ? separationA : separationB;
        // The incident side is the most opposite from the axes of collision on the other collider
        const other = separation.collider === polyA ? polyB : polyA;
        const incident = other.findSide(separation.axis.negate());
        // Clip incident side by the perpendicular lines at each end of the reference side
        // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm
        const reference = separation.side;
        const refDir = reference.dir().normalize();
        // Find our contact points by clipping the incident by the collision side
        const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));
        let clipLeft = null;
        if (clipRight) {
            clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));
        }
        // If there is no left there is no collision
        if (clipLeft) {
            // We only want clip points below the reference edge, discard the others
            const points = clipLeft.getPoints().filter((p) => {
                return reference.below(p);
            });
            let normal = separation.axis;
            let tangent = normal.perpendicular();
            // Point Contact A -> B
            if (polyB.worldPos.sub(polyA.worldPos).dot(normal) < 0) {
                normal = normal.negate();
                tangent = normal.perpendicular();
            }
            // Points are clipped from incident which is the other collider
            // Store those as locals
            let localPoints = [];
            if (separation.collider === polyA) {
                const xf = (_b = (_a = polyB.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
                localPoints = points.map((p) => xf.applyInverse(p));
            }
            else {
                const xf = (_d = (_c = polyA.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
                localPoints = points.map((p) => xf.applyInverse(p));
            }
            return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];
        }
        return [];
    },
    FindContactSeparation(contact, localPoint) {
        var _a, _b, _c, _d;
        const shapeA = contact.colliderA;
        const txA = (_b = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
        const shapeB = contact.colliderB;
        const txB = (_d = (_c = contact.colliderB.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
        // both are circles
        if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {
            const combinedRadius = shapeA.radius + shapeB.radius;
            const distance = txA.pos.distance(txB.pos);
            const separation = combinedRadius - distance;
            return -separation;
        }
        // both are polygons
        if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {
            if (contact.info.localSide) {
                let side;
                let worldPoint;
                if (contact.info.collider === shapeA) {
                    side = new Line(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));
                    worldPoint = txB.apply(localPoint);
                }
                else {
                    side = new Line(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));
                    worldPoint = txA.apply(localPoint);
                }
                return side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v circle
        if ((shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider) ||
            (shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider)) {
            const worldPoint = txA.apply(localPoint);
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v edge
        if ((shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider) ||
            (shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider)) {
            let worldPoint;
            if (contact.info.collider === shapeA) {
                worldPoint = txB.apply(localPoint);
            }
            else {
                worldPoint = txA.apply(localPoint);
            }
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // circle v edge
        if ((shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider) ||
            (shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider)) {
            // Local point is always on the edge which is always shapeB
            const worldPoint = txB.apply(localPoint);
            let circlePoint;
            if (shapeA instanceof CircleCollider) {
                circlePoint = shapeA.getFurthestPoint(contact.normal);
            }
            const dist = worldPoint.distance(circlePoint);
            if (contact.info.side) {
                return dist > 0 ? -dist : 0;
            }
        }
        return 0;
    }
};

;// CONCATENATED MODULE: ./Collision/Colliders/EdgeCollider.ts










/**
 * Edge is a single line collider to create collisions with a single line.
 */
class EdgeCollider extends Collider {
    constructor(options) {
        var _a;
        super();
        this.begin = options.begin || Vector.Zero;
        this.end = options.end || Vector.Zero;
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    /**
     * Returns a clone of this Edge, not associated with any collider
     */
    clone() {
        return new EdgeCollider({
            begin: this.begin.clone(),
            end: this.end.clone()
        });
    }
    get worldPos() {
        var _a;
        const tx = this._transform;
        return (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset)) !== null && _a !== void 0 ? _a : this.offset;
    }
    /**
     * Get the center of the collision area in world coordinates
     */
    get center() {
        const pos = this.begin.average(this.end).add(this._getBodyPos());
        return pos;
    }
    _getBodyPos() {
        var _a;
        const tx = this._transform;
        const bodyPos = (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _a !== void 0 ? _a : Vector.Zero;
        return bodyPos;
    }
    _getTransformedBegin() {
        const tx = this._transform;
        const angle = tx ? tx.globalRotation : 0;
        return this.begin.rotate(angle).add(this._getBodyPos());
    }
    _getTransformedEnd() {
        const tx = this._transform;
        const angle = tx ? tx.globalRotation : 0;
        return this.end.rotate(angle).add(this._getBodyPos());
    }
    /**
     * Returns the slope of the line in the form of a vector
     */
    getSlope() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Tests if a point is contained in this collision area
     */
    contains() {
        return false;
    }
    /**
     * @inheritdoc
     */
    rayCast(ray, max = Infinity) {
        const numerator = this._getTransformedBegin().sub(ray.pos);
        // Test is line and ray are parallel and non intersecting
        if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
            return null;
        }
        // Lines are parallel
        const divisor = ray.dir.cross(this.getSlope());
        if (divisor === 0) {
            return null;
        }
        const t = numerator.cross(this.getSlope()) / divisor;
        if (t >= 0 && t <= max) {
            const u = numerator.cross(ray.dir) / divisor / this.getLength();
            if (u >= 0 && u <= 1) {
                return ray.getPoint(t);
            }
        }
        return null;
    }
    /**
     * Returns the closes line between this and another collider, from this -> collider
     * @param shape
     */
    getClosestLineBetween(shape) {
        if (shape instanceof CircleCollider) {
            return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);
        }
        else if (shape instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();
        }
        else if (shape instanceof EdgeCollider) {
            return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(shape) {
        if (shape instanceof CircleCollider) {
            return CollisionJumpTable.CollideCircleEdge(shape, this);
        }
        else if (shape instanceof PolygonCollider) {
            return CollisionJumpTable.CollidePolygonEdge(shape, this);
        }
        else if (shape instanceof EdgeCollider) {
            return CollisionJumpTable.CollideEdgeEdge();
        }
        else {
            throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        if (direction.dot(transformedBegin) > 0) {
            return transformedBegin;
        }
        else {
            return transformedEnd;
        }
    }
    _boundsFromBeginEnd(begin, end, padding = 10) {
        // A perfectly vertical or horizontal edge would have a bounds 0 width or height
        // this causes problems for the collision system so we give them some padding
        return new BoundingBox(Math.min(begin.x, end.x) - padding, Math.min(begin.y, end.y) - padding, Math.max(begin.x, end.x) + padding, Math.max(begin.y, end.y) + padding);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in world space
     */
    get bounds() {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        return this._boundsFromBeginEnd(transformedBegin, transformedEnd);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in local space
     */
    get localBounds() {
        return this._boundsFromBeginEnd(this.begin, this.end);
    }
    /**
     * Returns this edge represented as a line in world coordinates
     */
    asLine() {
        return new Line(this._getTransformedBegin(), this._getTransformedEnd());
    }
    /**
     * Return this edge as a line in local line coordinates (relative to the position)
     */
    asLocalLine() {
        return new Line(this.begin, this.end);
    }
    /**
     * Get the axis associated with the edge
     */
    get axes() {
        const e = this._getTransformedEnd().sub(this._getTransformedBegin());
        const edgeNormal = e.normal();
        const axes = [];
        axes.push(edgeNormal);
        axes.push(edgeNormal.negate());
        axes.push(edgeNormal.normal());
        axes.push(edgeNormal.normal().negate());
        return axes;
    }
    /**
     * Get the moment of inertia for an edge
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        const length = this.end.sub(this.begin).distance() / 2;
        return mass * length * length;
    }
    /**
     * @inheritdoc
     */
    update(transform) {
        this._transform = transform;
    }
    /**
     * Project the edge along a specified axis
     */
    project(axis) {
        const scalars = [];
        const points = [this._getTransformedBegin(), this._getTransformedEnd()];
        const len = points.length;
        for (let i = 0; i < len; i++) {
            scalars.push(points[i].dot(axis));
        }
        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    draw(ctx, color = Color.Green, pos = Vector.Zero) {
        const begin = this.begin.add(pos);
        const end = this.end.add(pos);
        ctx.strokeStyle = color.toString();
        ctx.beginPath();
        ctx.moveTo(begin.x, begin.y);
        ctx.lineTo(end.x, end.y);
        ctx.closePath();
        ctx.stroke();
    }
    debug(ex, color) {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        ex.drawLine(begin, end, color, 2);
        ex.drawCircle(begin, 2, color);
        ex.drawCircle(end, 2, color);
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Red) {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        ctx.strokeStyle = color.toString();
        ctx.beginPath();
        ctx.moveTo(begin.x, begin.y);
        ctx.lineTo(end.x, end.y);
        ctx.closePath();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/PolygonCollider.ts











/**
 * Polygon collider for detecting collisions
 */
class PolygonCollider extends Collider {
    constructor(options) {
        var _a;
        super();
        this._transformedPoints = [];
        this._axes = [];
        this._sides = [];
        this._localSides = [];
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
        const winding = !!options.clockwiseWinding;
        this.points = (winding ? options.points.reverse() : options.points) || [];
        // calculate initial transformation
        this._calculateTransformation();
    }
    /**
     * Returns a clone of this ConvexPolygon, not associated with any collider
     */
    clone() {
        return new PolygonCollider({
            offset: this.offset.clone(),
            points: this.points.map((p) => p.clone())
        });
    }
    /**
     * Returns the world position of the collider, which is the current body transform plus any defined offset
     */
    get worldPos() {
        if (this._transform) {
            return this._transform.pos.add(this.offset);
        }
        return this.offset;
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        return this.bounds.center;
    }
    /**
     * Calculates the underlying transformation from the body relative space to world space
     */
    _calculateTransformation() {
        const transform = this._transform;
        const pos = transform ? transform.globalPos.add(this.offset) : this.offset;
        const angle = transform ? transform.globalRotation : 0;
        const scale = transform ? transform.globalScale : Vector.One;
        const len = this.points.length;
        this._transformedPoints.length = 0; // clear out old transform
        for (let i = 0; i < len; i++) {
            this._transformedPoints[i] = this.points[i].scale(scale).rotate(angle).add(pos);
        }
    }
    /**
     * Gets the points that make up the polygon in world space, from actor relative space (if specified)
     */
    getTransformedPoints() {
        this._calculateTransformation();
        return this._transformedPoints;
    }
    /**
     * Gets the sides of the polygon in world space
     */
    getSides() {
        if (this._sides.length) {
            return this._sides;
        }
        const lines = [];
        const points = this.getTransformedPoints();
        const len = points.length;
        for (let i = 0; i < len; i++) {
            // This winding is important
            lines.push(new Line(points[i], points[(i + 1) % len]));
        }
        this._sides = lines;
        return this._sides;
    }
    /**
     * Returns the local coordinate space sides
     */
    getLocalSides() {
        if (this._localSides.length) {
            return this._localSides;
        }
        const lines = [];
        const points = this.points;
        const len = points.length;
        for (let i = 0; i < len; i++) {
            // This winding is important
            lines.push(new Line(points[i], points[(i + 1) % len]));
        }
        this._localSides = lines;
        return this._localSides;
    }
    /**
     * Given a direction vector find the world space side that is most in that direction
     * @param direction
     */
    findSide(direction) {
        const sides = this.getSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Given a direction vector find the local space side that is most in that direction
     * @param direction
     */
    findLocalSide(direction) {
        const sides = this.getLocalSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Get the axis associated with the convex polygon
     */
    get axes() {
        if (this._axes.length) {
            return this._axes;
        }
        const axes = this.getSides().map((s) => s.normal());
        this._axes = axes;
        return this._axes;
    }
    update(transform) {
        this._transform = transform;
        this._sides.length = 0;
        this._localSides.length = 0;
        this._axes.length = 0;
        this._transformedPoints.length = 0;
        this.getTransformedPoints();
        this.getSides();
        this.getLocalSides();
    }
    /**
     * Tests if a point is contained in this collider in world space
     */
    contains(point) {
        // Always cast to the right, as long as we cast in a consistent fixed direction we
        // will be fine
        const testRay = new Ray(point, new Vector(1, 0));
        const intersectCount = this.getSides().reduce(function (accum, side) {
            if (testRay.intersect(side) >= 0) {
                return accum + 1;
            }
            return accum;
        }, 0);
        if (intersectCount % 2 === 0) {
            return false;
        }
        return true;
    }
    getClosestLineBetween(collider) {
        if (collider instanceof CircleCollider) {
            return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);
        }
        else if (collider instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Returns a collision contact if the 2 colliders collide, otherwise collide will
     * return null.
     * @param collider
     */
    collide(collider) {
        if (collider instanceof CircleCollider) {
            return CollisionJumpTable.CollideCirclePolygon(collider, this);
        }
        else if (collider instanceof PolygonCollider) {
            return CollisionJumpTable.CollidePolygonPolygon(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return CollisionJumpTable.CollidePolygonEdge(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const pts = this.getTransformedPoints();
        let furthestPoint = null;
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Find the local point on the collider furthest in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const pts = this.points;
        let furthestPoint = pts[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Finds the closes face to the point using perpendicular distance
     * @param point point to test against polygon
     */
    getClosestFace(point) {
        const sides = this.getSides();
        let min = Number.POSITIVE_INFINITY;
        let faceIndex = -1;
        let distance = -1;
        for (let i = 0; i < sides.length; i++) {
            const dist = sides[i].distanceToPoint(point);
            if (dist < min) {
                min = dist;
                faceIndex = i;
                distance = dist;
            }
        }
        if (faceIndex !== -1) {
            return {
                distance: sides[faceIndex].normal().scale(distance),
                face: sides[faceIndex]
            };
        }
        return null;
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in world coordinates
     */
    get bounds() {
        var _a, _b, _c;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
        const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;
        const pos = ((_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero).add(this.offset);
        return this.localBounds.scale(scale).rotate(rotation).translate(pos);
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in local coordinates
     */
    get localBounds() {
        return BoundingBox.fromPoints(this.points);
    }
    /**
     * Get the moment of inertia for an arbitrary polygon
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        let numerator = 0;
        let denominator = 0;
        for (let i = 0; i < this.points.length; i++) {
            const iplusone = (i + 1) % this.points.length;
            const crossTerm = this.points[iplusone].cross(this.points[i]);
            numerator +=
                crossTerm *
                    (this.points[i].dot(this.points[i]) + this.points[i].dot(this.points[iplusone]) + this.points[iplusone].dot(this.points[iplusone]));
            denominator += crossTerm;
        }
        return (mass / 6) * (numerator / denominator);
    }
    /**
     * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
     */
    rayCast(ray, max = Infinity) {
        // find the minimum contact time greater than 0
        // contact times less than 0 are behind the ray and we don't want those
        const sides = this.getSides();
        const len = sides.length;
        let minContactTime = Number.MAX_VALUE;
        let contactIndex = -1;
        for (let i = 0; i < len; i++) {
            const contactTime = ray.intersect(sides[i]);
            if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
                minContactTime = contactTime;
                contactIndex = i;
            }
        }
        // contact was found
        if (contactIndex >= 0) {
            return ray.getPoint(minContactTime);
        }
        // no contact found
        return null;
    }
    /**
     * Project the edges of the polygon along a specified axis
     */
    project(axis) {
        const points = this.getTransformedPoints();
        const len = points.length;
        let min = Number.MAX_VALUE;
        let max = -Number.MAX_VALUE;
        for (let i = 0; i < len; i++) {
            const scalar = points[i].dot(axis);
            min = Math.min(min, scalar);
            max = Math.max(max, scalar);
        }
        return new Projection(min, max);
    }
    draw(ctx, color = Color.Green, pos = Vector.Zero) {
        const effectiveOffset = pos.add(this.offset);
        ctx.beginPath();
        ctx.fillStyle = color.toString();
        const firstPoint = this.points[0].add(effectiveOffset);
        ctx.moveTo(firstPoint.x, firstPoint.y);
        // Points are relative
        this.points
            .map((p) => p.add(effectiveOffset))
            .forEach(function (point) {
            ctx.lineTo(point.x, point.y);
        });
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        ctx.fill();
    }
    debug(ex, color) {
        const firstPoint = this.getTransformedPoints()[0];
        const points = [firstPoint, ...this.getTransformedPoints(), firstPoint];
        for (let i = 0; i < points.length - 1; i++) {
            ex.drawLine(points[i], points[i + 1], color, 2);
            ex.drawCircle(points[i], 2, color);
            ex.drawCircle(points[i + 1], 2, color);
        }
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Red) {
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        // Iterate through the supplied points and construct a 'polygon'
        const firstPoint = this.getTransformedPoints()[0];
        ctx.moveTo(firstPoint.x, firstPoint.y);
        this.getTransformedPoints().forEach(function (point) {
            ctx.lineTo(point.x, point.y);
        });
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/Shape.ts







/**
 * Excalibur helper for defining colliders quickly
 */
class Shape {
    /**
     * Creates a box collider, under the hood defines a [[PolygonCollider]] collider
     * @param width Width of the box
     * @param height Height of the box
     * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Box(width, height, anchor = Vector.Half, offset = Vector.Zero) {
        return new PolygonCollider({
            points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),
            offset: offset
        });
    }
    /**
     * Creates a new [[PolygonCollider|arbitrary polygon]] collider
     *
     * PolygonColliders are useful for creating convex polygon shapes
     * @param points Points specified in counter clockwise
     * @param clockwiseWinding Optionally changed the winding of points, by default false meaning counter-clockwise winding.
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Polygon(points, clockwiseWinding = false, offset = Vector.Zero) {
        return new PolygonCollider({
            points: points,
            offset: offset,
            clockwiseWinding: clockwiseWinding
        });
    }
    /**
     * Creates a new [[CircleCollider|circle]] collider
     *
     * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges
     * @param radius Radius of the circle collider
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Circle(radius, offset = Vector.Zero) {
        return new CircleCollider({
            radius: radius,
            offset: offset
        });
    }
    /**
     * Creates a new [[EdgeCollider|edge]] collider
     *
     * Edge colliders are useful for  floors, walls, and other barriers
     * @param begin Beginning of the edge in local coordinates to the collider
     * @param end Ending of the edge in local coordinates to the collider
     */
    static Edge(begin, end) {
        return new EdgeCollider({
            begin: begin,
            end: end
        });
    }
    /**
     * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box
     *
     * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth
     * player experience.
     *
     * @param width
     * @param height
     * @param offset Optional offset
     */
    static Capsule(width, height, offset = Vector.Zero) {
        const logger = Logger.getInstance();
        if (width === height) {
            logger.warn('A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider');
        }
        const vertical = height >= width;
        if (vertical) {
            // height > width, if equal maybe use a circle
            const capsule = new CompositeCollider([
                Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),
                Shape.Box(width, height - width, Vector.Half, offset),
                Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))
            ]);
            return capsule;
        }
        else {
            // width > height, if equal maybe use a circle
            const capsule = new CompositeCollider([
                Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),
                Shape.Box(width - height, height, Vector.Half, offset),
                Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))
            ]);
            return capsule;
        }
    }
}

;// CONCATENATED MODULE: ./Collision/ColliderComponent.ts









class ColliderComponent extends Component {
    constructor(collider) {
        super();
        this.type = 'ex.collider';
        this.events = new EventDispatcher(this);
        /**
         * Observable that notifies when a collider is added to the body
         */
        this.$colliderAdded = new Observable();
        /**
         * Observable that notifies when a collider is removed from the body
         */
        this.$colliderRemoved = new Observable();
        this.set(collider);
    }
    /**
     * Get the current collider geometry
     * @returns
     */
    get() {
        return this._collider;
    }
    /**
     * Set the collider geometry
     * @param collider
     * @returns the collider you set
     */
    set(collider) {
        this.clear();
        if (collider) {
            this._collider = collider;
            this._collider.owner = this.owner;
            this.events.wire(collider.events);
            this.$colliderAdded.notifyAll(collider);
            this.update();
        }
        return collider;
    }
    /**
     * Remove collider geometry from collider component
     */
    clear() {
        if (this._collider) {
            this.events.unwire(this._collider.events);
            this.$colliderRemoved.notifyAll(this._collider);
            this._collider.owner = null;
            this._collider = null;
        }
    }
    /**
     * Return world space bounds
     */
    get bounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Return local space bounds
     */
    get localBounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Update the collider's transformed geometry
     */
    update() {
        var _a;
        const tx = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
        if (this._collider) {
            this._collider.owner = this.owner;
            if (tx) {
                this._collider.update(tx);
            }
        }
    }
    /**
     * Collide component with another
     * @param other
     * @returns
     */
    collide(other) {
        let colliderA = this._collider;
        let colliderB = other._collider;
        if (!colliderA || !colliderB) {
            return [];
        }
        // If we have a composite lefthand side :(
        // Might bite us, but to avoid updating all the handlers make composite always left side
        let flipped = false;
        if (colliderB instanceof CompositeCollider) {
            colliderA = colliderB;
            colliderB = this._collider;
            flipped = true;
        }
        if (this._collider) {
            const contacts = colliderA.collide(colliderB);
            if (contacts) {
                if (flipped) {
                    contacts.forEach((contact) => {
                        contact.mtv = contact.mtv.negate();
                        contact.normal = contact.normal.negate();
                        contact.tangent = contact.normal.perpendicular();
                        contact.colliderA = this._collider;
                        contact.colliderB = other._collider;
                    });
                }
                return contacts;
            }
            return [];
        }
        return [];
    }
    onAdd(entity) {
        if (this._collider) {
            this.update();
        }
        // Wire up the collider events to the owning entity
        this.events.on('precollision', (evt) => {
            const precollision = evt;
            entity.events.emit('precollision', new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection));
        });
        this.events.on('postcollision', (evt) => {
            const postcollision = evt;
            entity.events.emit('postcollision', new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection));
        });
        this.events.on('collisionstart', (evt) => {
            const start = evt;
            entity.events.emit('collisionstart', new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));
        });
        this.events.on('collisionend', (evt) => {
            const end = evt;
            entity.events.emit('collisionend', new CollisionEndEvent(end.target.owner, end.other.owner));
        });
    }
    onRemove() {
        this.events.clear();
        this.$colliderRemoved.notifyAll(this._collider);
    }
    /**
     * Sets up a box geometry based on the current bounds of the associated actor of this physics body.
     *
     * If no width/height are specified the body will attempt to use the associated actor's width/height.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useBoxCollider(width, height, anchor = Vector.Half, center = Vector.Zero) {
        const collider = Shape.Box(width, height, anchor, center);
        return (this.set(collider));
    }
    /**
     * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative
     *  to the anchor of the associated actor
     * of this physics body.
     *
     * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    usePolygonCollider(points, center = Vector.Zero) {
        const poly = Shape.Polygon(points, false, center);
        return (this.set(poly));
    }
    /**
     * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useCircleCollider(radius, center = Vector.Zero) {
        const collider = Shape.Circle(radius, center);
        return (this.set(collider));
    }
    /**
     * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor
     * of this physics body.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useEdgeCollider(begin, end) {
        const collider = Shape.Edge(begin, end);
        return (this.set(collider));
    }
    /**
     * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders
     * @param colliders
     * @returns
     */
    useCompositeCollider(colliders) {
        return (this.set(new CompositeCollider(colliders)));
    }
}

;// CONCATENATED MODULE: ./Collision/BodyComponent.ts











var DegreeOfFreedom;
(function (DegreeOfFreedom) {
    DegreeOfFreedom["Rotation"] = "rotation";
    DegreeOfFreedom["X"] = "x";
    DegreeOfFreedom["Y"] = "y";
})(DegreeOfFreedom || (DegreeOfFreedom = {}));
/**
 * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of
 * of physics simulation.
 */
class BodyComponent extends Component {
    constructor(options) {
        var _a, _b, _c;
        super();
        this.type = 'ex.body';
        this.dependencies = [TransformComponent, MotionComponent];
        this.id = createId('body', BodyComponent._ID++);
        this.events = new EventDispatcher(this);
        /**
         * Collision type for the rigidbody physics simulation, by default [[CollisionType.PreventCollision]]
         */
        this.collisionType = CollisionType.PreventCollision;
        /**
         * The collision group for the body's colliders, by default body colliders collide with everything
         */
        this.group = CollisionGroup.All;
        /**
         * The amount of mass the body has
         */
        this.mass = Physics.defaultMass;
        /**
         * Amount of "motion" the body has before sleeping. If below [[Physics.sleepEpsilon]] it goes to "sleep"
         */
        this.sleepMotion = Physics.sleepEpsilon * 5;
        /**
         * Can this body sleep, by default bodies do not sleep
         */
        this.canSleep = Physics.bodiesCanSleepByDefault;
        this._sleeping = false;
        /**
         * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the
         * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.
         */
        this.bounciness = 0.2;
        /**
         * The coefficient of friction on this actor
         */
        this.friction = 0.99;
        /**
         * Should use global gravity [[Physics.gravity]] in it's physics simulation, default is true
         */
        this.useGravity = true;
        /**
         * Degrees of freedom to limit
         */
        this.limitDegreeOfFreedom = [];
        /**
         * The position of the actor last frame (x, y) in pixels
         */
        this.oldPos = new Vector(0, 0);
        /**
         * The velocity of the actor last frame (vx, vy) in pixels/second
         */
        this.oldVel = new Vector(0, 0);
        /**
         * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
         */
        this.oldAcc = Vector.Zero;
        /**
         * Gets/sets the rotation of the body from the last frame.
         */
        this.oldRotation = 0; // radians
        /**
         * The scale of the actor last frame
         * @deprecated ex.Body.scale will be removed in v0.25.0
         */
        this.oldScale = Vector.One;
        if (options) {
            this.collisionType = (_a = options.type) !== null && _a !== void 0 ? _a : this.collisionType;
            this.group = (_b = options.group) !== null && _b !== void 0 ? _b : this.group;
            this.useGravity = (_c = options.useGravity) !== null && _c !== void 0 ? _c : this.useGravity;
        }
    }
    /**
     * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseMass() {
        return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;
    }
    /**
     * Whether this body is sleeping or not
     */
    get sleeping() {
        return this._sleeping;
    }
    /**
     * Set the sleep state of the body
     * @param sleeping
     */
    setSleeping(sleeping) {
        this._sleeping = sleeping;
        if (!sleeping) {
            // Give it a kick to keep it from falling asleep immediately
            this.sleepMotion = Physics.sleepEpsilon * 5;
        }
        else {
            this.vel = Vector.Zero;
            this.acc = Vector.Zero;
            this.angularVelocity = 0;
            this.sleepMotion = 0;
        }
    }
    /**
     * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping
     */
    updateMotion() {
        if (this._sleeping) {
            this.setSleeping(true);
        }
        const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);
        const bias = Physics.sleepBias;
        this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;
        this.sleepMotion = clamp(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);
        if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) {
            this.setSleeping(true);
        }
    }
    /**
     * Get the moment of inertia from the [[ColliderComponent]]
     */
    get inertia() {
        // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?
        const collider = this.owner.get(ColliderComponent);
        if (collider === null || collider === void 0 ? void 0 : collider.get()) {
            return collider.get().getInertia(this.mass);
        }
        return 0;
    }
    /**
     * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseInertia() {
        return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;
    }
    /**
     * Returns if the owner is active
     */
    get active() {
        var _a;
        return !!((_a = this.owner) === null || _a === void 0 ? void 0 : _a.active);
    }
    get center() {
        return this.pos;
    }
    get transform() {
        var _a;
        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
    }
    get motion() {
        var _a;
        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(MotionComponent);
    }
    /**
     * The (x, y) position of the actor this will be in the middle of the actor if the
     * [[Actor.anchor]] is set to (0.5, 0.5) which is default.
     * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
     */
    get pos() {
        return this.transform.globalPos;
    }
    set pos(val) {
        this.transform.globalPos = val;
    }
    /**
     * The current velocity vector (vx, vy) of the actor in pixels/second
     */
    get vel() {
        return this.motion.vel;
    }
    set vel(val) {
        this.motion.vel = val;
    }
    /**
     * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
     * be useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    set acc(val) {
        this.motion.acc = val;
    }
    /**
     * The current torque applied to the actor
     */
    get torque() {
        return this.motion.torque;
    }
    set torque(val) {
        this.motion.torque = val;
    }
    /**
     * The rotation of the body in radians
     */
    get rotation() {
        return this.transform.globalRotation;
    }
    set rotation(val) {
        this.transform.globalRotation = val;
    }
    /**
     * The scale vector of the actor
     * @deprecated ex.Body.scale will be removed in v0.25.0, Use ex.Transform.scale
     */
    get scale() {
        return this.transform.globalScale;
    }
    set scale(val) {
        this.transform.globalScale = val;
    }
    /**
     * The x scalar velocity of the actor in scale/second
     * @deprecated ex.Body.scale will be removed in v0.25.0
     */
    get sx() {
        return this.motion.scaleFactor.x;
    }
    set sx(xFactor) {
        this.motion.scaleFactor.x = xFactor;
    }
    /**
     * The y scalar velocity of the actor in scale/second
     * @deprecated ex.Body.scale will be removed in v0.25.0
     */
    get sy() {
        return this.motion.scaleFactor.y;
    }
    set sy(yFactor) {
        this.motion.scaleFactor.y = yFactor;
    }
    /**
     * The rotational velocity of the actor in radians/second
     * @deprecated
     */
    get rx() {
        return this.motion.angularVelocity;
    }
    /**
     * The rotational velocity of the actor in radians/second
     * @deprecated
     */
    set rx(value) {
        this.motion.angularVelocity = value;
    }
    /**
     * Get the angular velocity in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Set the angular velocity in radians/second
     */
    set angularVelocity(value) {
        this.motion.angularVelocity = value;
    }
    /**
     * Apply a specific impulse to the body
     * @param point
     * @param impulse
     */
    applyImpulse(point, impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass);
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
            finalImpulse.y = 0;
        }
        this.vel.addEqual(finalImpulse);
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.pos);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Apply only linear impulse to the body
     * @param impulse
     */
    applyLinearImpulse(impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass);
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
            finalImpulse.y = 0;
        }
        this.vel = this.vel.add(finalImpulse);
    }
    /**
     * Apply only angular impuse to the body
     * @param point
     * @param impulse
     */
    applyAngularImpulse(point, impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.pos);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Sets the old versions of pos, vel, acc, and scale.
     */
    captureOldTransform() {
        // Capture old values before integration step updates them
        this.oldVel.setTo(this.vel.x, this.vel.y);
        this.oldPos.setTo(this.pos.x, this.pos.y);
        this.oldAcc.setTo(this.acc.x, this.acc.y);
        this.oldScale.setTo(this.scale.x, this.scale.y);
        this.oldRotation = this.rotation;
    }
    debugDraw(_ctx) {
        // pass
    }
}
BodyComponent._ID = 0;

;// CONCATENATED MODULE: ./Util/CullingBox.ts


/**
 * @deprecated Will be removed in 0.26.0
 */
class CullingBox {
    constructor() {
        this._topLeft = new Vector(0, 0);
        this._topRight = new Vector(0, 0);
        this._bottomLeft = new Vector(0, 0);
        this._bottomRight = new Vector(0, 0);
    }
    isSpriteOffScreen(actor, engine) {
        const drawingWidth = actor.currentDrawing.drawWidth;
        const drawingHeight = actor.currentDrawing.drawHeight;
        const rotation = actor.rotation;
        const anchor = actor.center;
        const worldPos = actor.getGlobalPos();
        this._topLeft = vec(worldPos.x - drawingWidth / 2, worldPos.y - drawingHeight / 2);
        this._topLeft = this._topLeft.rotate(rotation, anchor);
        this._topRight = vec(worldPos.x + drawingWidth / 2, worldPos.y - drawingHeight / 2);
        this._topRight = this._topRight.rotate(rotation, anchor);
        this._bottomLeft = vec(worldPos.x - drawingWidth / 2, worldPos.y + drawingHeight / 2);
        this._bottomLeft = this._bottomLeft.rotate(rotation, anchor);
        this._bottomRight = vec(worldPos.x + drawingWidth / 2, worldPos.y + drawingHeight / 2);
        this._bottomRight = this._bottomRight.rotate(rotation, anchor);
        const topLeftScreen = engine.worldToScreenCoordinates(this._topLeft);
        const topRightScreen = engine.worldToScreenCoordinates(this._topRight);
        const bottomLeftScreen = engine.worldToScreenCoordinates(this._bottomLeft);
        const bottomRightScreen = engine.worldToScreenCoordinates(this._bottomRight);
        this._xCoords = [];
        this._yCoords = [];
        this._xCoords.push(topLeftScreen.x, topRightScreen.x, bottomLeftScreen.x, bottomRightScreen.x);
        this._yCoords.push(topLeftScreen.y, topRightScreen.y, bottomLeftScreen.y, bottomRightScreen.y);
        this._xMin = Math.min.apply(null, this._xCoords);
        this._yMin = Math.min.apply(null, this._yCoords);
        this._xMax = Math.max.apply(null, this._xCoords);
        this._yMax = Math.max.apply(null, this._yCoords);
        const minWorld = engine.screenToWorldCoordinates(new Vector(this._xMin, this._yMin));
        const maxWorld = engine.screenToWorldCoordinates(new Vector(this._xMax, this._yMax));
        this._xMinWorld = minWorld.x;
        this._yMinWorld = minWorld.y;
        this._xMaxWorld = maxWorld.x;
        this._yMaxWorld = maxWorld.y;
        const boundingPoints = [
            new Vector(this._xMin, this._yMin),
            new Vector(this._xMax, this._yMin),
            new Vector(this._xMin, this._yMax),
            new Vector(this._xMax, this._yMax) // bottom right
        ];
        // sprite can be wider than canvas screen (and still visible within canvas)
        // top or bottom of sprite must be within canvas
        if (boundingPoints[0].x < 0 &&
            boundingPoints[1].x > engine.canvas.clientWidth &&
            (boundingPoints[0].y > 0 || boundingPoints[2].y < engine.canvas.clientHeight)) {
            return false;
        }
        // sprite can be taller than canvas screen (and still visible within canvas)
        // left or right of sprite must be within canvas
        if (boundingPoints[0].y < 0 &&
            boundingPoints[2].y > engine.canvas.clientHeight &&
            (boundingPoints[1].x > 0 || boundingPoints[0].x < engine.canvas.clientWidth)) {
            return false;
        }
        // otherwise if any corner is visible, we're not offscreen
        for (let i = 0; i < boundingPoints.length; i++) {
            if (boundingPoints[i].x > 0 &&
                boundingPoints[i].y > 0 &&
                boundingPoints[i].x < engine.canvas.clientWidth &&
                boundingPoints[i].y < engine.canvas.clientHeight) {
                return false;
            }
        }
        return true;
    }
    debugDraw(ctx) {
        // bounding rectangle
        ctx.beginPath();
        ctx.strokeStyle = Color.White.toString();
        ctx.rect(this._xMinWorld, this._yMinWorld, this._xMaxWorld - this._xMinWorld, this._yMaxWorld - this._yMinWorld);
        ctx.stroke();
        ctx.fillStyle = Color.Red.toString();
        ctx.beginPath();
        ctx.arc(this._topLeft.x, this._topLeft.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = Color.Green.toString();
        ctx.beginPath();
        ctx.arc(this._topRight.x, this._topRight.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = Color.Blue.toString();
        ctx.beginPath();
        ctx.arc(this._bottomLeft.x, this._bottomLeft.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = Color.Magenta.toString();
        ctx.beginPath();
        ctx.arc(this._bottomRight.x, this._bottomRight.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
    }
}

;// CONCATENATED MODULE: ./Traits/OffscreenCulling.ts



/**
 * @deprecated will be removed in 0.26.0
 */
class OffscreenCulling {
    constructor() {
        this.cullingBox = new CullingBox();
    }
    update(actor, engine) {
        const events = actor.eventDispatcher;
        let isSpriteOffScreen = true;
        if (actor.currentDrawing != null) {
            isSpriteOffScreen = this.cullingBox.isSpriteOffScreen(actor, engine);
        }
        let actorBoundsOffscreen = false;
        if (engine && engine.currentScene && engine.currentScene.camera && engine.currentScene.camera.viewport && !actor.parent) {
            actorBoundsOffscreen = !engine.currentScene.camera.viewport.intersect(actor.collider.bounds);
        }
        if (!actor.isOffScreen) {
            if (actorBoundsOffscreen && isSpriteOffScreen) {
                events.emit('exitviewport', new ExitViewPortEvent(actor));
                actor.addComponent(new TagComponent('offscreen'));
            }
        }
        else {
            if (!actorBoundsOffscreen || !isSpriteOffScreen) {
                events.emit('enterviewport', new EnterViewPortEvent(actor));
                actor.removeComponent('offscreen');
            }
        }
    }
}

;// CONCATENATED MODULE: ./Traits/CapturePointer.ts
/**
 * Revises pointer events path accordingly to the actor
 * @deprecated Will be removed in 0.26.0
 */
class CapturePointer {
    update(actor, engine) {
        if (!actor.enableCapturePointer) {
            return;
        }
        if (actor.isKilled()) {
            return;
        }
        engine.input.pointers.checkAndUpdateActorUnderPointer(actor);
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Entity.ts





/**
 * AddedComponent message
 */
class AddedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Added';
    }
}
/**
 * Type guard to know if message is f an Added Component
 */
function isAddedComponent(x) {
    return !!x && x.type === 'Component Added';
}
/**
 * RemovedComponent message
 */
class RemovedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Removed';
    }
}
/**
 * Type guard to know if message is for a Removed Component
 */
function isRemovedComponent(x) {
    return !!x && x.type === 'Component Removed';
}
/**
 * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system
 *
 * Entities can be strongly typed with the components they contain
 *
 * ```typescript
 * const entity = new Entity<ComponentA | ComponentB>();
 * entity.components.a; // Type ComponentA
 * entity.components.b; // Type ComponentB
 * ```
 */
class Entity extends Class {
    constructor(components, name) {
        super();
        /**
         * The unique identifier for the entity
         */
        this.id = Entity._ID++;
        this._name = 'anonymous';
        /**
         * Whether this entity is active, if set to false it will be reclaimed
         */
        this.active = true;
        /**
         * Bucket to hold on to deferred removals
         */
        this._componentsToRemove = [];
        this._componentTypeToInstance = new Map();
        this._componentStringToInstance = new Map();
        this._tagsMemo = [];
        this._typesMemo = [];
        /**
         * Observable that keeps track of component add or remove changes on the entity
         */
        this.componentAdded$ = new Observable();
        this.componentRemoved$ = new Observable();
        this._parent = null;
        this.childrenAdded$ = new Observable();
        this.childrenRemoved$ = new Observable();
        this._children = [];
        this._isInitialized = false;
        this._setName(name);
        if (components) {
            for (const component of components) {
                this.addComponent(component);
            }
        }
    }
    _setName(name) {
        if (name) {
            this._name = name;
        }
    }
    get name() {
        return this._name;
    }
    get events() {
        return this.eventDispatcher;
    }
    /**
     * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.
     */
    kill() {
        this.active = false;
    }
    isKilled() {
        return !this.active;
    }
    /**
     * Specifically get the tags on the entity from [[TagComponent]]
     */
    get tags() {
        return this._tagsMemo;
    }
    /**
     * Check if a tag exists on the entity
     * @param tag name to check for
     */
    hasTag(tag) {
        return this.tags.includes(tag);
    }
    /**
     * Adds a tag to an entity
     * @param tag
     * @returns Entity
     */
    addTag(tag) {
        return this.addComponent(new TagComponent(tag));
    }
    /**
     * Removes a tag on the entity
     *
     * Removals are deferred until the end of update
     * @param tag
     * @param force Remove component immediately, no deferred
     */
    removeTag(tag, force = false) {
        return this.removeComponent(tag, force);
    }
    /**
     * The types of the components on the Entity
     */
    get types() {
        return this._typesMemo;
    }
    _rebuildMemos() {
        this._tagsMemo = Array.from(this._componentStringToInstance.values())
            .filter((c) => c instanceof TagComponent)
            .map((c) => c.type);
        this._typesMemo = Array.from(this._componentStringToInstance.keys());
    }
    getComponents() {
        return Array.from(this._componentStringToInstance.values());
    }
    _notifyAddComponent(component) {
        this._rebuildMemos();
        const added = new AddedComponent({
            component,
            entity: this
        });
        this.componentAdded$.notifyAll(added);
    }
    _notifyRemoveComponent(component) {
        const removed = new RemovedComponent({
            component,
            entity: this
        });
        this.componentRemoved$.notifyAll(removed);
        this._rebuildMemos();
    }
    get parent() {
        return this._parent;
    }
    /**
     * Get the direct children of this entity
     */
    get children() {
        return this._children;
    }
    /**
     * Unparents this entity, if there is a parent. Otherwise it does nothing.
     */
    unparent() {
        if (this._parent) {
            this._parent.removeChild(this);
            this._parent = null;
        }
    }
    /**
     * Adds an entity to be a child of this entity
     * @param entity
     */
    addChild(entity) {
        if (entity.parent === null) {
            if (this.getAncestors().includes(entity)) {
                throw new Error('Cycle detected, cannot add entity');
            }
            this._children.push(entity);
            entity._parent = this;
            this.childrenAdded$.notifyAll(entity);
        }
        else {
            throw new Error('Entity already has a parent, cannot add without unparenting');
        }
        return this;
    }
    /**
     * Remove an entity from children if it exists
     * @param entity
     */
    removeChild(entity) {
        if (entity.parent === this) {
            removeItemFromArray(entity, this._children);
            entity._parent = null;
            this.childrenRemoved$.notifyAll(entity);
        }
        return this;
    }
    /**
     * Removes all children from this entity
     */
    removeAllChildren() {
        this.children.forEach((c) => {
            this.removeChild(c);
        });
        return this;
    }
    /**
     * Returns a list of parent entities starting with the topmost parent. Includes the current entity.
     */
    getAncestors() {
        const result = [this];
        let current = this.parent;
        while (current) {
            result.push(current);
            current = current.parent;
        }
        return result.reverse();
    }
    /**
     * Returns a list of all the entities that descend from this entity. Includes the current entity.
     */
    getDescendants() {
        let result = [this];
        let queue = [this];
        while (queue.length > 0) {
            const curr = queue.pop();
            queue = queue.concat(curr.children);
            result = result.concat(curr.children);
        }
        return result;
    }
    /**
     * Creates a deep copy of the entity and a copy of all its components
     */
    clone() {
        const newEntity = new Entity();
        for (const c of this.types) {
            newEntity.addComponent(this.get(c).clone());
        }
        for (const child of this.children) {
            newEntity.addChild(child.clone());
        }
        return newEntity;
    }
    /**
     * Adds a copy of all the components from another template entity as a "prefab"
     * @param templateEntity Entity to use as a template
     * @param force Force component replacement if it aleady exists on the target entity
     */
    addTemplate(templateEntity, force = false) {
        for (const c of templateEntity.getComponents()) {
            this.addComponent(c.clone(), force);
        }
        for (const child of templateEntity.children) {
            this.addChild(child.clone().addTemplate(child));
        }
        return this;
    }
    /**
     * Adds a component to the entity
     * @param component Component or Entity to add copy of components from
     * @param force Optionally overwrite any existing components of the same type
     */
    addComponent(component, force = false) {
        // if component already exists, skip if not forced
        if (this.has(component.type)) {
            if (force) {
                // Remove existing component type if exists when forced
                this.removeComponent(component);
            }
            else {
                // early exit component exiss
                return this;
            }
        }
        // TODO circular dependencies will be a problem
        if (component.dependencies && component.dependencies.length) {
            for (const ctor of component.dependencies) {
                this.addComponent(new ctor());
            }
        }
        component.owner = this;
        const constuctorType = component.constructor;
        this._componentTypeToInstance.set(constuctorType, component);
        this._componentStringToInstance.set(component.type, component);
        if (component.onAdd) {
            component.onAdd(this);
        }
        this._notifyAddComponent(component);
        return this;
    }
    /**
     * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues
     *
     * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately
     * @param componentOrType
     * @param force
     */
    removeComponent(componentOrType, force = false) {
        if (force) {
            if (typeof componentOrType === 'string') {
                this._removeComponentByType(componentOrType);
            }
            else if (componentOrType instanceof Component) {
                this._removeComponentByType(componentOrType.type);
            }
        }
        else {
            this._componentsToRemove.push(componentOrType);
        }
        return this;
    }
    _removeComponentByType(type) {
        if (this.has(type)) {
            const component = this.get(type);
            component.owner = null;
            if (component.onRemove) {
                component.onRemove(this);
            }
            const ctor = component.constructor;
            this._componentTypeToInstance.delete(ctor);
            this._componentStringToInstance.delete(component.type);
            this._notifyRemoveComponent(component);
        }
    }
    /**
     * @hidden
     * @internal
     */
    processComponentRemoval() {
        for (const componentOrType of this._componentsToRemove) {
            const type = typeof componentOrType === 'string' ? componentOrType : componentOrType.type;
            this._removeComponentByType(type);
        }
        this._componentsToRemove.length = 0;
    }
    has(type) {
        if (typeof type === 'string') {
            return this._componentStringToInstance.has(type);
        }
        else {
            return this._componentTypeToInstance.has(type);
        }
    }
    get(type) {
        if (typeof type === 'string') {
            return this._componentStringToInstance.get(type);
        }
        else {
            return this._componentTypeToInstance.get(type);
        }
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * `onInitialize` is called before the first update of the entity. This method is meant to be
     * overridden.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an entity is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an entity is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     *
     * Entity update lifecycle, called internally
     *
     * @internal
     * @param engine
     * @param delta
     */
    update(engine, delta) {
        this._initialize(engine);
        this._preupdate(engine, delta);
        for (const child of this.children) {
            child.update(engine, delta);
        }
        this._postupdate(engine, delta);
    }
}
Entity._ID = 0;

;// CONCATENATED MODULE: ./Drawing/CanvasDrawComponent.ts

/**
 * Shim to draw to the canvas when in LegacyDrawing mode
 * @deprecated
 */
class CanvasDrawComponent extends Component {
    constructor(draw) {
        var _a;
        super();
        this.draw = draw;
        this.type = 'ex.canvas';
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.draw = (_a = this.draw) !== null && _a !== void 0 ? _a : (() => { });
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsComponent.ts





/**
 * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)
 * @param graphic
 */
function hasGraphicsTick(graphic) {
    return !!graphic.tick;
}
class GraphicsLayer {
    constructor(_options, _graphics) {
        this._options = _options;
        this._graphics = _graphics;
        this.graphics = [];
    }
    get name() {
        return this._options.name;
    }
    hide(nameOrGraphic) {
        if (!nameOrGraphic) {
            this.graphics.length = 0;
        }
        else {
            let gfx = null;
            if (nameOrGraphic instanceof Graphic) {
                gfx = nameOrGraphic;
            }
            else {
                gfx = this._graphics.getGraphic(nameOrGraphic);
            }
            this.graphics = this.graphics.filter((g) => g.graphic !== gfx);
        }
    }
    /**
     * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.
     *
     * If `show()` is called multiple times for the same graphic it will be shown multiple times.
     * @param nameOrGraphic
     * @param options
     */
    show(nameOrGraphic, options) {
        options = Object.assign({}, options);
        let gfx;
        if (nameOrGraphic instanceof Graphic) {
            gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;
        }
        else {
            gfx = this._graphics.getGraphic(nameOrGraphic);
            if (!gfx) {
                Logger.getInstance().error(`No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `, this._graphics.getNames());
            }
        }
        if (gfx) {
            this.graphics.push({ graphic: gfx, options });
            return gfx;
        }
        else {
            return null;
        }
    }
    /**
     * Use a specific graphic, swap out any current graphics being shown
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        options = Object.assign({}, options);
        this.hide();
        return this.show(nameOrGraphic, options);
    }
    /**
     * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    get order() {
        return this._options.order;
    }
    /**
     * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    set order(order) {
        this._options.order = order;
    }
    /**
     * Get or set the pixel offset from the layer anchor for all graphics in the layer
     */
    get offset() {
        var _a;
        return (_a = this._options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    set offset(value) {
        this._options.offset = value;
    }
    get currentKeys() {
        var _a;
        return (_a = this.name) !== null && _a !== void 0 ? _a : 'anonymous';
    }
}
class GraphicsLayers {
    constructor(_component) {
        this._component = _component;
        this._layers = [];
        this._layerMap = {};
        this.default = new GraphicsLayer({ name: 'default', order: 0 }, _component);
        this._maybeAddLayer(this.default);
    }
    create(options) {
        const layer = new GraphicsLayer(options, this._component);
        return this._maybeAddLayer(layer);
    }
    get(name) {
        if (name) {
            return this._getLayer(name);
        }
        return this._layers;
    }
    currentKeys() {
        const graphicsLayerKeys = [];
        for (const layer of this._layers) {
            graphicsLayerKeys.push(layer.currentKeys);
        }
        return graphicsLayerKeys;
    }
    has(name) {
        return name in this._layerMap;
    }
    _maybeAddLayer(layer) {
        if (this._layerMap[layer.name]) {
            // todo log warning
            return this._layerMap[layer.name];
        }
        this._layerMap[layer.name] = layer;
        this._layers.push(layer);
        this._layers.sort((a, b) => a.order - b.order);
        return layer;
    }
    _getLayer(name) {
        return this._layerMap[name];
    }
}
/**
 * Component to manage drawings, using with the position component
 */
class GraphicsComponent extends Component {
    constructor(options) {
        super();
        this.type = 'ex.graphics';
        this._graphics = {};
        /**
         * Sets or gets wether any drawing should be visible in this component
         */
        this.visible = true;
        /**
         * Sets or gets wither all drawings should have an opacity applied
         */
        this.opacity = 1;
        /**
         * Offset to apply to graphics by default
         */
        this.offset = Vector.Zero;
        /**
         * Anchor to apply to graphics by default
         */
        this.anchor = Vector.Half;
        /**
         * If set to true graphics added to the component will be copied. This can affect performance
         */
        this.copyGraphics = false;
        this._bounds = null;
        // Defaults
        options = Object.assign({ visible: this.visible }, options);
        const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw } = options;
        this._graphics = graphics || {};
        this.offset = offset !== null && offset !== void 0 ? offset : this.offset;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : this.anchor;
        this.copyGraphics = copyGraphics !== null && copyGraphics !== void 0 ? copyGraphics : this.copyGraphics;
        this.onPreDraw = onPreDraw !== null && onPreDraw !== void 0 ? onPreDraw : this.onPreDraw;
        this.onPostDraw = onPostDraw !== null && onPostDraw !== void 0 ? onPostDraw : this.onPostDraw;
        this.visible = !!visible;
        this.layers = new GraphicsLayers(this);
        if (current && this._graphics[current]) {
            this.show(this._graphics[current]);
        }
    }
    getGraphic(name) {
        return this._graphics[name];
    }
    /**
     * Get registered graphics names
     */
    getNames() {
        return Object.keys(this._graphics);
    }
    /**
     * Returns the currently displayed graphics and their offsets, empty array if hidden
     */
    get current() {
        return this.layers.default.graphics;
    }
    /**
     * Returns all graphics associated with this component
     */
    get graphics() {
        return this._graphics;
    }
    add(nameOrGraphic, graphic) {
        let name = 'default';
        let graphicToSet = null;
        if (typeof nameOrGraphic === 'string') {
            name = nameOrGraphic;
            graphicToSet = graphic;
        }
        else {
            graphicToSet = nameOrGraphic;
        }
        this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;
        if (name === 'default') {
            this.show('default');
        }
        return graphicToSet;
    }
    /**
     * Show a graphic by name on the **default** layer, returns the new [[Graphic]]
     */
    show(nameOrGraphic, options) {
        return this.layers.default.show(nameOrGraphic, options);
    }
    /**
     * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        return this.layers.default.use(nameOrGraphic, options);
    }
    hide(nameOrGraphic) {
        this.layers.default.hide(nameOrGraphic);
    }
    set localBounds(bounds) {
        this._bounds = bounds;
    }
    get localBounds() {
        if (this._bounds) {
            return this._bounds;
        }
        let bb = new BoundingBox();
        for (const layer of this.layers.get()) {
            for (const { graphic, options } of layer.graphics) {
                let anchor = this.anchor;
                let offset = this.offset;
                if (options === null || options === void 0 ? void 0 : options.anchor) {
                    anchor = options.anchor;
                }
                if (options === null || options === void 0 ? void 0 : options.offset) {
                    offset = options.offset;
                }
                const bounds = graphic.localBounds;
                const offsetX = -bounds.width * graphic.scale.x * anchor.x + offset.x;
                const offsetY = -bounds.height * graphic.scale.y * anchor.y + offset.y;
                bb = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb);
            }
        }
        return bb;
    }
    /**
     * Update underlying graphics if necesary, called internally
     * @param elapsed
     * @internal
     */
    update(elapsed, idempotencyToken = 0) {
        for (const layer of this.layers.get()) {
            for (const { graphic } of layer.graphics) {
                if (hasGraphicsTick(graphic)) {
                    graphic === null || graphic === void 0 ? void 0 : graphic.tick(elapsed, idempotencyToken);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Rectangle.ts

/**
 * A Rectangle [[Graphic]] for drawing rectangles to the [[ExcaliburGraphicsContext]]
 */
class Rectangle extends Raster {
    constructor(options) {
        super(options);
        this.width = options.width;
        this.height = options.height;
        this.rasterize();
    }
    clone() {
        return new Rectangle(Object.assign(Object.assign({ width: this.width, height: this.height }, this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        if (this.color) {
            ctx.fillRect(0, 0, this.width, this.height);
        }
        if (this.strokeColor) {
            ctx.strokeRect(0, 0, this.width, this.height);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Circle.ts

/**
 * A circle [[Graphic]] for drawing circles to the [[ExcaliburGraphicsContext]]
 */
class Circle extends Raster {
    constructor(options) {
        var _a;
        super(options);
        this._radius = 0;
        this.padding = (_a = options.padding) !== null && _a !== void 0 ? _a : 2; // default 2 padding for circles looks nice
        this.radius = options.radius;
        this.rasterize();
    }
    get radius() {
        return this._radius;
    }
    set radius(value) {
        this._radius = value;
        this.width = this._radius * 2;
        this.height = this._radius * 2;
        this.flagDirty();
    }
    clone() {
        return new Circle(Object.assign(Object.assign({ radius: this.radius }, this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        if (this.radius > 0) {
            ctx.beginPath();
            ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}

;// CONCATENATED MODULE: ./Util/EasingFunctions.ts
var EasingFunctions_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]
 * Given a time, the function will return a value from positive startValue to positive endValue.
 *
 * ```js
 * function Linear (t) {
 *    return t * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInQuad (t) {
 *    return t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutQuad (t) {
 *    return t * (2 - t);
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutQuad (t) {
 *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInCubic (t) {
 *    return t * t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutCubic (t) {
 *    return (--t) * t * t + 1;
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutCubic (t) {
 *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
 * }
 * ```
 */
class EasingFunctions {
    static CreateReversibleEasingFunction(easing) {
        return (time, start, end, duration) => {
            if (end < start) {
                return start - (easing(time, end, start, duration) - end);
            }
            else {
                return easing(time, start, end, duration);
            }
        };
    }
    static CreateReversableEasingFunction(easing) {
        return EasingFunctions.CreateReversibleEasingFunction(easing);
    }
    static CreateVectorEasingFunction(easing) {
        return (time, start, end, duration) => {
            return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));
        };
    }
}
EasingFunctions.Linear = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    return (endValue * currentTime) / duration + startValue;
});
EasingFunctions.EaseInQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return -endValue * currentTime * (currentTime - 2) + startValue;
});
EasingFunctions.EaseInOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime + startValue;
    }
    currentTime--;
    return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;
});
EasingFunctions.EaseInCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    currentTime--;
    return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
});
EasingFunctions.EaseInOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;
    }
    currentTime -= 2;
    return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;
});
EasingFunctions_decorate([
    obsolete({
        message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',
        alternateMethod: 'CreateReversibleEasingFunction'
    })
], EasingFunctions, "CreateReversableEasingFunction", null);

;// CONCATENATED MODULE: ./Actions/ActionQueue.ts
/**
 * Action Queues represent an ordered sequence of actions
 *
 * Action queues are part of the [[ActionContext|Action API]] and
 * store the list of actions to be executed for an [[Actor]].
 *
 * Actors implement [[Actor.actions]] which can be manipulated by
 * advanced users to adjust the actions currently being executed in the
 * queue.
 */
class ActionQueue {
    constructor(entity) {
        this._actions = [];
        this._completedActions = [];
        this._entity = entity;
    }
    /**
     * Add an action to the sequence
     * @param action
     */
    add(action) {
        this._actions.push(action);
    }
    /**
     * Remove an action by reference from the sequence
     * @param action
     */
    remove(action) {
        const index = this._actions.indexOf(action);
        this._actions.splice(index, 1);
    }
    /**
     * Removes all actions from this sequence
     */
    clearActions() {
        this._actions.length = 0;
        this._completedActions.length = 0;
        if (this._currentAction) {
            this._currentAction.stop();
        }
    }
    /**
     *
     * @returns The total list of actions in this sequence complete or not
     */
    getActions() {
        return this._actions.concat(this._completedActions);
    }
    /**
     *
     * @returns `true` if there are more actions to process in the sequence
     */
    hasNext() {
        return this._actions.length > 0;
    }
    /**
     * @returns `true` if the current sequence of actions is done
     */
    isComplete() {
        return this._actions.length === 0;
    }
    /**
     * Resets the sequence of actions, this is used to restart a sequence from the beginning
     */
    reset() {
        this._actions = this.getActions();
        const len = this._actions.length;
        for (let i = 0; i < len; i++) {
            this._actions[i].reset();
        }
        this._completedActions = [];
    }
    /**
     * Update the queue which updates actions and handles completing actions
     * @param elapsedMs
     */
    update(elapsedMs) {
        if (this._actions.length > 0) {
            this._currentAction = this._actions[0];
            this._currentAction.update(elapsedMs);
            if (this._currentAction.isComplete(this._entity)) {
                this._completedActions.push(this._actions.shift());
            }
        }
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Repeat.ts

class Repeat {
    constructor(entity, repeatBuilder, repeat) {
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeat = repeat;
        this._originalRepeat = repeat;
        this._repeatBuilder(this._repeatContext);
        this._repeat--; // current execution is the first repeat
    }
    update(delta) {
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
            this._repeat--;
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped || (this._repeat <= 0 && this._actionQueue.isComplete());
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._repeat = this._originalRepeat;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/RepeatForever.ts

/**
 * RepeatForever Action implementation, it is recommended you use the fluent action
 * context API.
 *
 *
 */
class RepeatForever {
    constructor(entity, repeatBuilder) {
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeatBuilder(this._repeatContext);
    }
    update(delta) {
        if (this._stopped) {
            return;
        }
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        this._stopped = true;
        this._actionQueue.clearActions();
    }
    reset() {
        return;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/MoveBy.ts




class MoveBy {
    constructor(entity, offsetX, offsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._entity = entity;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._speed = speed;
        this._offset = new Vector(offsetX, offsetY);
        if (speed <= 0) {
            Logger.getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);
            throw new Error('Speed must be greater than 0 pixels per second');
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
            this._end = this._start.add(this._offset);
            this._distance = this._offset.size;
            this._dir = this._end.sub(this._start).normalize();
        }
        if (this.isComplete(this._entity)) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
        else {
            this._motion.vel = this._dir.scale(this._speed);
        }
    }
    isComplete(entity) {
        const tx = entity.get(TransformComponent);
        return this._stopped || tx.pos.distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/MoveTo.ts



class MoveTo {
    constructor(entity, destx, desty, speed) {
        this.entity = entity;
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._end = new Vector(destx, desty);
        this._speed = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
            this._distance = this._start.distance(this._end);
            this._dir = this._end.sub(this._start).normalize();
        }
        const m = this._dir.scale(this._speed);
        this._motion.vel = vec(m.x, m.y);
        if (this.isComplete(this.entity)) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    isComplete(entity) {
        const tx = entity.get(TransformComponent);
        return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/RotationType.ts
/**
 * An enum that describes the strategies that rotation actions can use
 */
var RotationType;
(function (RotationType) {
    /**
     * Rotation via `ShortestPath` will use the smallest angle
     * between the starting and ending points. This strategy is the default behavior.
     */
    RotationType[RotationType["ShortestPath"] = 0] = "ShortestPath";
    /**
     * Rotation via `LongestPath` will use the largest angle
     * between the starting and ending points.
     */
    RotationType[RotationType["LongestPath"] = 1] = "LongestPath";
    /**
     * Rotation via `Clockwise` will travel in a clockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["Clockwise"] = 2] = "Clockwise";
    /**
     * Rotation via `CounterClockwise` will travel in a counterclockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["CounterClockwise"] = 3] = "CounterClockwise";
})(RotationType || (RotationType = {}));

;// CONCATENATED MODULE: ./Actions/Action/RotateTo.ts




class RotateTo {
    constructor(entity, angleRadians, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._end = angleRadians;
        this._speed = speed;
        this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
            switch (this._rotationType) {
                case RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case RotationType.CounterClockwise:
                    this._direction = -1;
                    if (!this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTravelled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTravelled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/RotateBy.ts




class RotateBy {
    constructor(entity, angleRadiansOffset, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._speed = speed;
        this._offset = angleRadiansOffset;
        this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            this._end = this._start + this._offset;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
            switch (this._rotationType) {
                case RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortDistance >= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case RotationType.CounterClockwise:
                    this._direction = -1;
                    if (this._shortDistance <= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTravelled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTravelled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ScaleTo.ts



class ScaleTo {
    constructor(entity, scaleX, scaleY, speedX, speedY) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._endX = scaleX;
        this._endY = scaleY;
        this._speedX = speedX;
        this._speedY = speedY;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startX = this._tx.scale.x;
            this._startY = this._tx.scale.y;
            this._distanceX = Math.abs(this._endX - this._startX);
            this._distanceY = Math.abs(this._endY - this._startY);
        }
        if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {
            const directionX = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.x = this._speedX * directionX;
        }
        else {
            this._motion.scaleFactor.x = 0;
        }
        if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {
            const directionY = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.y = this._speedY * directionY;
        }
        else {
            this._motion.scaleFactor.y = 0;
        }
        if (this.isComplete()) {
            this._tx.scale = vec(this._endX, this._endY);
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.y - this._startX) >= this._distanceX && Math.abs(this._tx.scale.y - this._startY) >= this._distanceY));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ScaleBy.ts



class ScaleBy {
    constructor(entity, scaleOffsetX, scaleOffsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._offset = new Vector(scaleOffsetX, scaleOffsetY);
        this._speedX = this._speedY = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startScale = this._tx.scale.clone();
            this._endScale = this._startScale.add(this._offset);
            this._distanceX = Math.abs(this._endScale.x - this._startScale.x);
            this._distanceY = Math.abs(this._endScale.y - this._startScale.y);
            this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;
            this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;
        }
        this._motion.scaleFactor.x = this._speedX * this._directionX;
        this._motion.scaleFactor.y = this._speedY * this._directionY;
        if (this.isComplete()) {
            this._tx.scale = this._endScale;
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.x - this._startScale.x) >= this._distanceX &&
                Math.abs(this._tx.scale.y - this._startScale.y) >= this._distanceY));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/CallMethod.ts
class CallMethod {
    constructor(method) {
        this._method = null;
        this._hasBeenCalled = false;
        this._method = method;
    }
    update(_delta) {
        this._method();
        this._hasBeenCalled = true;
    }
    isComplete() {
        return this._hasBeenCalled;
    }
    reset() {
        this._hasBeenCalled = false;
    }
    stop() {
        this._hasBeenCalled = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/EaseTo.ts



class EaseTo {
    constructor(entity, x, y, duration, easingFcn) {
        this.easingFcn = easingFcn;
        this._currentLerpTime = 0;
        this._lerpDuration = 1 * 1000; // 1 second
        this._lerpStart = new Vector(0, 0);
        this._lerpEnd = new Vector(0, 0);
        this._initialized = false;
        this._stopped = false;
        this._distance = 0;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._lerpDuration = duration;
        this._lerpEnd = new Vector(x, y);
    }
    _initialize() {
        this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._currentLerpTime = 0;
        this._distance = this._lerpStart.distance(this._lerpEnd);
    }
    update(delta) {
        if (!this._initialized) {
            this._initialize();
            this._initialized = true;
        }
        // Need to update lerp time first, otherwise the first update will always be zero
        this._currentLerpTime += delta;
        let newX = this._tx.pos.x;
        let newY = this._tx.pos.y;
        if (this._currentLerpTime < this._lerpDuration) {
            if (this._lerpEnd.x < this._lerpStart.x) {
                newX =
                    this._lerpStart.x -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
            }
            else {
                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
            }
            if (this._lerpEnd.y < this._lerpStart.y) {
                newY =
                    this._lerpStart.y -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
            }
            else {
                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
            }
            // Given the lerp position figure out the velocity in pixels per second
            this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));
        }
        else {
            this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);
            this._motion.vel = Vector.Zero;
        }
    }
    isComplete(actor) {
        return this._stopped || new Vector(actor.pos.x, actor.pos.y).distance(this._lerpStart) >= this._distance;
    }
    reset() {
        this._initialized = false;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Blink.ts

class Blink {
    constructor(entity, timeVisible, timeNotVisible, numBlinks = 1) {
        this._timeVisible = 0;
        this._timeNotVisible = 0;
        this._elapsedTime = 0;
        this._totalTime = 0;
        this._stopped = false;
        this._started = false;
        this._graphics = entity.get(GraphicsComponent);
        this._timeVisible = timeVisible;
        this._timeNotVisible = timeNotVisible;
        this._duration = (timeVisible + timeNotVisible) * numBlinks;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
        }
        if (!this._graphics) {
            return;
        }
        this._elapsedTime += delta;
        this._totalTime += delta;
        if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {
            this._graphics.visible = false;
            this._elapsedTime = 0;
        }
        if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {
            this._graphics.visible = true;
            this._elapsedTime = 0;
        }
        if (this.isComplete()) {
            this._graphics.visible = true;
        }
    }
    isComplete() {
        return this._stopped || this._totalTime >= this._duration;
    }
    stop() {
        if (this._graphics) {
            this._graphics.visible = true;
        }
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._elapsedTime = 0;
        this._totalTime = 0;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Fade.ts


class Fade {
    constructor(entity, endOpacity, speed) {
        this._multiplier = 1;
        this._started = false;
        this._stopped = false;
        this._graphics = entity.get(GraphicsComponent);
        this._endOpacity = endOpacity;
        this._speed = speed;
    }
    update(delta) {
        if (!this._graphics) {
            return;
        }
        if (!this._started) {
            this._started = true;
            // determine direction when we start
            if (this._endOpacity < this._graphics.opacity) {
                this._multiplier = -1;
            }
            else {
                this._multiplier = 1;
            }
        }
        if (this._speed > 0) {
            this._graphics.opacity += (this._multiplier *
                (Math.abs(this._graphics.opacity - this._endOpacity) * delta)) / this._speed;
        }
        this._speed -= delta;
        if (this.isComplete()) {
            this._graphics.opacity = this._endOpacity;
        }
        Logger.getInstance().debug('[Action fade] Actor opacity:', this._graphics.opacity);
    }
    isComplete() {
        return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Delay.ts
class Delay {
    constructor(delay) {
        this._elapsedTime = 0;
        this._started = false;
        this._stopped = false;
        this._delay = delay;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
        }
        this._elapsedTime += delta;
    }
    isComplete() {
        return this._stopped || this._elapsedTime >= this._delay;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._elapsedTime = 0;
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Die.ts

class Die {
    constructor(entity) {
        this._stopped = false;
        this._entity = entity;
    }
    update(_delta) {
        this._entity.get(ActionsComponent).clearActions();
        this._entity.kill();
        this._stopped = true;
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        return;
    }
    reset() {
        return;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Follow.ts



class Follow {
    constructor(entity, entityToFollow, followDistance) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._followTx = entityToFollow.get(TransformComponent);
        this._followMotion = entityToFollow.get(MotionComponent);
        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);
        this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);
        this._speed = 0;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));
        if (actorToFollowSpeed !== 0) {
            this._speed = actorToFollowSpeed;
        }
        this._current = vec(this._tx.pos.x, this._tx.pos.y);
        this._end = vec(this._followTx.pos.x, this._followTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        if (this._distanceBetween >= this._maximumDistance) {
            const m = this._dir.scale(this._speed);
            this._motion.vel = vec(m.x, m.y);
        }
        else {
            this._motion.vel = vec(0, 0);
        }
        if (this.isComplete()) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    isComplete() {
        // the actor following should never stop unless specified to do so
        return this._stopped;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Meet.ts



class Meet {
    constructor(actor, actorToMeet, speed) {
        this._started = false;
        this._stopped = false;
        this._speedWasSpecified = false;
        this._tx = actor.get(TransformComponent);
        this._motion = actor.get(MotionComponent);
        this._meetTx = actorToMeet.get(TransformComponent);
        this._meetMotion = actorToMeet.get(MotionComponent);
        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);
        this._speed = speed || 0;
        if (speed !== undefined) {
            this._speedWasSpecified = true;
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));
        if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {
            this._speed = actorToMeetSpeed;
        }
        this._current = vec(this._tx.pos.x, this._tx.pos.y);
        this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        const m = this._dir.scale(this._speed);
        this._motion.vel = vec(m.x, m.y);
        if (this.isComplete()) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    isComplete() {
        return this._stopped || this._distanceBetween <= 1;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/ActionContext.ts



















/**
 * The fluent Action API allows you to perform "actions" on
 * [[Actor|Actors]] such as following, moving, rotating, and
 * more. You can implement your own actions by implementing
 * the [[Action]] interface.
 */
class ActionContext {
    constructor(entity) {
        this._entity = entity;
        this._queue = new ActionQueue(entity);
    }
    getQueue() {
        return this._queue;
    }
    update(elapsedMs) {
        this._queue.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        this._queue.clearActions();
    }
    easeTo(...args) {
        var _a, _b;
        let x = 0;
        let y = 0;
        let duration = 0;
        let easingFcn = EasingFunctions.Linear;
        if (args[0] instanceof Vector) {
            x = args[0].x;
            y = args[0].y;
            duration = args[1];
            easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;
        }
        else {
            x = args[0];
            y = args[1];
            duration = args[2];
            easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;
        }
        this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));
        return this;
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
        let x = 0;
        let y = 0;
        let speed = 0;
        if (xOrPos instanceof Vector) {
            x = xOrPos.x;
            y = xOrPos.y;
            speed = yOrSpeed;
        }
        else {
            x = xOrPos;
            y = yOrSpeed;
            speed = speedOrUndefined;
        }
        this._queue.add(new MoveTo(this._entity, x, y, speed));
        return this;
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
        let xOffset = 0;
        let yOffset = 0;
        let speed = 0;
        if (xOffsetOrVector instanceof Vector) {
            xOffset = xOffsetOrVector.x;
            yOffset = xOffsetOrVector.y;
            speed = yOffsetOrSpeed;
        }
        else {
            xOffset = xOffsetOrVector;
            yOffset = yOffsetOrSpeed;
            speed = speedOrUndefined;
        }
        this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));
        return this;
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
        this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));
        return this;
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
        this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));
        return this;
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        let sizeX = 1;
        let sizeY = 1;
        let speedX = 0;
        let speedY = 0;
        if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {
            sizeX = sizeXOrVector.x;
            sizeY = sizeXOrVector.y;
            speedX = sizeYOrSpeed.x;
            speedY = sizeYOrSpeed.y;
        }
        if (typeof sizeXOrVector === 'number' && typeof sizeYOrSpeed === 'number') {
            sizeX = sizeXOrVector;
            sizeY = sizeYOrSpeed;
            speedX = speedXOrUndefined;
            speedY = speedYOrUndefined;
        }
        this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));
        return this;
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
        let sizeOffsetX = 1;
        let sizeOffsetY = 1;
        if (sizeOffsetXOrVector instanceof Vector) {
            sizeOffsetX = sizeOffsetXOrVector.x;
            sizeOffsetY = sizeOffsetXOrVector.y;
            speed = sizeOffsetYOrSpeed;
        }
        if (typeof sizeOffsetXOrVector === 'number' && typeof sizeOffsetYOrSpeed === 'number') {
            sizeOffsetX = sizeOffsetXOrVector;
            sizeOffsetY = sizeOffsetYOrSpeed;
        }
        this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));
        return this;
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks = 1) {
        this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));
        return this;
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
        this._queue.add(new Fade(this._entity, opacity, time));
        return this;
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
        this._queue.add(new Delay(time));
        return this;
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        this._queue.add(new Die(this._entity));
        return this;
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        this._queue.add(new CallMethod(method));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        if (!times) {
            this.repeatForever(repeatBuilder);
            return this;
        }
        this._queue.add(new Repeat(this._entity, repeatBuilder, times));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        this._queue.add(new RepeatForever(this._entity, repeatBuilder));
        return this;
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        if (followDistance === undefined) {
            this._queue.add(new Follow(this._entity, entity));
        }
        else {
            this._queue.add(new Follow(this._entity, entity, followDistance));
        }
        return this;
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        if (speed === undefined) {
            this._queue.add(new Meet(this._entity, entity));
        }
        else {
            this._queue.add(new Meet(this._entity, entity, speed));
        }
        return this;
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     * @deprecated Use `toPromise()` will be removed in v0.26.0
     */
    asPromise() {
        return this.toPromise();
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        const temp = new Promise((resolve) => {
            this._queue.add(new CallMethod(() => {
                resolve();
            }));
        });
        return temp;
    }
}

;// CONCATENATED MODULE: ./Actions/ActionsComponent.ts




;
class ActionsComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.actions';
        this.dependencies = [TransformComponent, MotionComponent];
    }
    onAdd(entity) {
        this._ctx = new ActionContext(entity);
    }
    onRemove() {
        this._ctx = null;
    }
    /**
     * Returns the internal action queue
     * @returns action queu
     */
    getQueue() {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.getQueue();
    }
    /**
     * Updates the internal action context, performing action and moving through the internal queue
     * @param elapsedMs
     */
    update(elapsedMs) {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        var _a;
        (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.clearActions();
    }
    easeTo(...args) {
        return this._ctx.easeTo.apply(this._ctx, args);
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
        return this._ctx.moveTo.apply(this._ctx, [xOrPos, yOrSpeed, speedOrUndefined]);
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
        return this._ctx.moveBy.apply(this._ctx, [xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined]);
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
        return this._ctx.rotateTo(angleRadians, speed, rotationType);
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
        return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        return this._ctx.scaleTo.apply(this._ctx, [sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
        return this._ctx.scaleBy.apply(this._ctx, [sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed]);
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks) {
        return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
        return this._ctx.fade(opacity, time);
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
        return this._ctx.delay(time);
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        return this._ctx.die();
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        return this._ctx.callMethod(method);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        return this._ctx.repeat(repeatBuilder, times);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        return this._ctx.repeatForever(repeatBuilder);
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        return this._ctx.follow(entity, followDistance);
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        return this._ctx.meet(entity, speed);
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     * @deprecated Use `toPromise()` will be removed in v0.26.0
     */
    asPromise() {
        return this.toPromise();
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        return this._ctx.toPromise();
    }
}

;// CONCATENATED MODULE: ./Actor.ts
var Actor_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






















/**
 * Type guard for checking if something is an Actor
 * @param x
 */
function isActor(x) {
    return x instanceof Actor;
}
/**
 * The most important primitive in Excalibur is an `Actor`. Anything that
 * can move on the screen, collide with another `Actor`, respond to events,
 * or interact with the current scene, must be an actor. An `Actor` **must**
 * be part of a [[Scene]] for it to be drawn to the screen.
 */
class Actor extends Entity {
    // #endregion
    /**
     *
     * @param config
     */
    constructor(config) {
        super();
        /**
         * The anchor to apply all actor related transformations like rotation,
         * translation, and scaling. By default the anchor is in the center of
         * the actor. By default it is set to the center of the actor (.5, .5)
         *
         * An anchor of (.5, .5) will ensure that drawings are centered.
         *
         * Use `anchor.setTo` to set the anchor to a different point using
         * values between 0 and 1. For example, anchoring to the top-left would be
         * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.
         */
        this._anchor = watch(Vector.Half, (v) => this._handleAnchorChange(v));
        /**
         * Convenience reference to the global logger
         */
        this.logger = Logger.getInstance();
        /**
         * The scene that the actor is in
         */
        this.scene = null;
        this.frames = {};
        /**
         * Access to the current drawing for the actor, this can be
         * an [[Animation]], [[Sprite]], or [[Polygon]].
         * Set drawings with [[setDrawing]].
         * @deprecated
         */
        this.currentDrawing = null;
        /**
         * Draggable helper
         */
        this._draggable = false;
        this._dragging = false;
        this._pointerDragStartHandler = () => {
            this._dragging = true;
        };
        this._pointerDragEndHandler = () => {
            this._dragging = false;
        };
        this._pointerDragMoveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.pointer.lastWorldPos;
            }
        };
        this._pointerDragLeaveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.pointer.lastWorldPos;
            }
        };
        /**
         * Modify the current actor update pipeline.
         */
        this.traits = [];
        /**
         * Whether or not to enable the [[Traits.CapturePointer]] trait that propagates
         * pointer events to this actor
         */
        this.enableCapturePointer = false;
        /**
         * Configuration for [[Traits.CapturePointer]] trait
         */
        this.capturePointer = {
            captureMoveEvents: false,
            captureDragEvents: false
        };
        // #region Events
        this._capturePointerEvents = [
            'pointerup',
            'pointerdown',
            'pointermove',
            'pointerenter',
            'pointerleave',
            'pointerdragstart',
            'pointerdragend',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        this._captureMoveEvents = [
            'pointermove',
            'pointerenter',
            'pointerleave',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        this._captureDragEvents = [
            'pointerdragstart',
            'pointerdragend',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        const { name, x, y, pos, scale, width, height, radius, collider, vel, acc, rotation, angularVelocity, z, color, visible, anchor, collisionType, collisionGroup } = Object.assign({}, config);
        this._setName(name);
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : Actor.defaults.anchor.clone();
        this.addComponent(new TransformComponent());
        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.rotation = rotation !== null && rotation !== void 0 ? rotation : 0;
        this.scale = scale !== null && scale !== void 0 ? scale : vec(1, 1);
        this.z = z !== null && z !== void 0 ? z : 0;
        this.addComponent(new GraphicsComponent());
        this.addComponent(new CanvasDrawComponent((ctx, delta) => this.draw(ctx, delta)));
        this.addComponent(new MotionComponent());
        this.vel = vel !== null && vel !== void 0 ? vel : Vector.Zero;
        this.acc = acc !== null && acc !== void 0 ? acc : Vector.Zero;
        this.angularVelocity = angularVelocity !== null && angularVelocity !== void 0 ? angularVelocity : 0;
        this.addComponent(new ActionsComponent());
        this.addComponent(new BodyComponent());
        this.body.collisionType = collisionType !== null && collisionType !== void 0 ? collisionType : CollisionType.Passive;
        if (collisionGroup) {
            this.body.group = collisionGroup;
        }
        if (collider) {
            this.addComponent(new ColliderComponent(collider));
        }
        else if (radius) {
            this.addComponent(new ColliderComponent(Shape.Circle(radius, this.anchor)));
        }
        else {
            if (width > 0 && height > 0) {
                this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));
            }
            else {
                this.addComponent(new ColliderComponent()); // no collider
            }
        }
        this.graphics.visible = visible !== null && visible !== void 0 ? visible : true;
        if (color) {
            this.color = color;
            if (width && height) {
                this.graphics.add(new Rectangle({
                    color: color,
                    width,
                    height
                }));
            }
            else if (radius) {
                this.graphics.add(new Circle({
                    color: color,
                    radius
                }));
            }
        }
        // Build default pipeline
        if (Flags.isEnabled(Legacy.LegacyDrawing)) {
            // TODO remove offscreen trait after legacy drawing removed
            this.traits.push(new OffscreenCulling());
        }
        this.traits.push(new CapturePointer());
    }
    /**
     * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,
     * acceleration, mass, inertia, etc.
     */
    get body() {
        return this.get(BodyComponent);
    }
    /**
     * Access the Actor's built in [[TransformComponent]]
     */
    get transform() {
        return this.get(TransformComponent);
    }
    /**
     * Access the Actor's built in [[MotionComponent]]
     */
    get motion() {
        return this.get(MotionComponent);
    }
    /**
     * Access to the Actor's built in [[GraphicsComponent]]
     */
    get graphics() {
        return this.get(GraphicsComponent);
    }
    /**
     * Access to the Actor's built in [[ColliderComponent]]
     */
    get collider() {
        return this.get(ColliderComponent);
    }
    /**
     * Useful for quickly scripting actor behavior, like moving to a place, patroling back and forth, blinking, etc.
     *
     *  Access to the Actor's built in [[ActionsComponent]] which forwards to the
     * [[ActionContext|Action context]] of the actor.
     */
    get actions() {
        return this.get(ActionsComponent);
    }
    /**
     * Gets the position vector of the actor in pixels
     */
    get pos() {
        return this.transform.pos;
    }
    /**
     * Sets the position vector of the actor in pixels
     */
    set pos(thePos) {
        this.transform.pos = thePos.clone();
    }
    /**
     * Gets the position vector of the actor from the last frame
     */
    get oldPos() {
        return this.body.oldPos;
    }
    /**
     * Sets the position vector of the actor in the last frame
     */
    set oldPos(thePos) {
        this.body.oldPos.setTo(thePos.x, thePos.y);
    }
    /**
     * Gets the velocity vector of the actor in pixels/sec
     */
    get vel() {
        return this.motion.vel;
    }
    /**
     * Sets the velocity vector of the actor in pixels/sec
     */
    set vel(theVel) {
        this.motion.vel = theVel.clone();
    }
    /**
     * Gets the velocity vector of the actor from the last frame
     */
    get oldVel() {
        return this.body.oldVel;
    }
    /**
     * Sets the velocity vector of the actor from the last frame
     */
    set oldVel(theVel) {
        this.body.oldVel.setTo(theVel.x, theVel.y);
    }
    /**
     * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
     * useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    /**
     * Sets the acceleration vector of teh actor in pixels/second/second
     */
    set acc(theAcc) {
        this.motion.acc = theAcc.clone();
    }
    /**
     * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    set oldAcc(theAcc) {
        this.body.oldAcc.setTo(theAcc.x, theAcc.y);
    }
    /**
     * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    get oldAcc() {
        return this.body.oldAcc;
    }
    /**
     * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    get rotation() {
        return this.transform.rotation;
    }
    /**
     * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    set rotation(theAngle) {
        this.transform.rotation = theAngle;
    }
    /**
     * Gets the rotational velocity of the actor in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Sets the rotational velocity of the actor in radians/sec
     */
    set angularVelocity(angularVelocity) {
        this.motion.angularVelocity = angularVelocity;
    }
    get scale() {
        return this.get(TransformComponent).scale;
    }
    set scale(scale) {
        this.get(TransformComponent).scale = scale;
    }
    get anchor() {
        return this._anchor;
    }
    set anchor(vec) {
        this._anchor = watch(vec, (v) => this._handleAnchorChange(v));
        this._handleAnchorChange(vec);
    }
    _handleAnchorChange(v) {
        if (this.graphics) {
            this.graphics.anchor = v;
        }
    }
    /**
     * Indicates whether the actor is physically in the viewport
     */
    get isOffScreen() {
        return this.hasTag('offscreen');
    }
    /**
     * The visibility of an actor
     * @deprecated Use [[GraphicsComponent.visible|Actor.graphics.visible]], will be removed in v0.26.0
     */
    get visible() {
        return this.graphics.visible;
    }
    set visible(isVisible) {
        this.graphics.visible = isVisible;
    }
    /**
     * The opacity of an actor.
     *
     * @deprecated Actor.opacity will be removed in v0.26.0, use [[GraphicsComponent.opacity|Actor.graphics.opacity]].
     */
    get opacity() {
        return this.graphics.opacity;
    }
    set opacity(opacity) {
        this.graphics.opacity = opacity;
    }
    get draggable() {
        return this._draggable;
    }
    set draggable(isDraggable) {
        if (isDraggable) {
            if (isDraggable && !this._draggable) {
                this.on('pointerdragstart', this._pointerDragStartHandler);
                this.on('pointerdragend', this._pointerDragEndHandler);
                this.on('pointerdragmove', this._pointerDragMoveHandler);
                this.on('pointerdragleave', this._pointerDragLeaveHandler);
            }
            else if (!isDraggable && this._draggable) {
                this.off('pointerdragstart', this._pointerDragStartHandler);
                this.off('pointerdragend', this._pointerDragEndHandler);
                this.off('pointerdragmove', this._pointerDragMoveHandler);
                this.off('pointerdragleave', this._pointerDragLeaveHandler);
            }
            this._draggable = isDraggable;
        }
    }
    /**
     * Sets the color of the actor. A rectangle of this color will be
     * drawn if no [[Drawable]] is specified as the actors drawing.
     *
     * The default is `null` which prevents a rectangle from being drawn.
     */
    get color() {
        return this._color;
    }
    set color(v) {
        this._color = v.clone();
    }
    /**
     * `onInitialize` is called before the first update of the actor. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        super._initialize(engine);
        for (const child of this.children) {
            child._initialize(engine);
        }
    }
    _checkForPointerOptIn(eventName) {
        if (eventName) {
            const normalized = eventName.toLowerCase();
            if (this._capturePointerEvents.indexOf(normalized) !== -1) {
                this.enableCapturePointer = true;
                if (this._captureMoveEvents.indexOf(normalized) !== -1) {
                    this.capturePointer.captureMoveEvents = true;
                }
                if (this._captureDragEvents.indexOf(normalized) !== -1) {
                    this.capturePointer.captureDragEvents = true;
                }
            }
        }
    }
    on(eventName, handler) {
        this._checkForPointerOptIn(eventName);
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        this._checkForPointerOptIn(eventName);
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    // #endregion
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPreKill]] lifecycle event
     * @internal
     */
    _prekill(_scene) {
        super.emit('prekill', new PreKillEvent(this));
        this.onPreKill(_scene);
    }
    /**
     * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`
     *
     * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].
     */
    onPreKill(_scene) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPostKill]] lifecycle event
     * @internal
     */
    _postkill(_scene) {
        super.emit('postkill', new PostKillEvent(this));
        this.onPostKill(_scene);
    }
    /**
     * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`
     *
     * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].
     */
    onPostKill(_scene) {
        // Override me
    }
    /**
     * If the current actor is a member of the scene, this will remove
     * it from the scene graph. It will no longer be drawn or updated.
     */
    kill() {
        if (this.scene) {
            this._prekill(this.scene);
            this.emit('kill', new KillEvent(this));
            super.kill();
            this._postkill(this.scene);
        }
        else {
            this.logger.warn('Cannot kill actor, it was never added to the Scene');
        }
    }
    /**
     * If the current actor is killed, it will now not be killed.
     */
    unkill() {
        this.active = true;
    }
    /**
     * Indicates wether the actor has been killed.
     */
    isKilled() {
        return !this.active;
    }
    setDrawing(key) {
        key = key.toString();
        if (this.currentDrawing !== this.frames[key]) {
            if (this.frames[key] != null) {
                this.frames[key].reset();
                this.currentDrawing = this.frames[key];
            }
            else {
                Logger.getInstance().error(`the specified drawing key ${key} does not exist`);
            }
        }
        if (this.currentDrawing && this.currentDrawing instanceof Animation_Animation) {
            this.currentDrawing.tick(0);
        }
    }
    addDrawing() {
        if (arguments.length === 2) {
            this.frames[arguments[0]] = arguments[1];
            if (!this.currentDrawing) {
                this.currentDrawing = arguments[1];
            }
        }
        else {
            if (arguments[0] instanceof Sprite_Sprite) {
                this.addDrawing('default', arguments[0]);
            }
            if (arguments[0] instanceof Texture) {
                this.addDrawing('default', arguments[0].asSprite());
            }
        }
    }
    /**
     * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     */
    get z() {
        return this.get(TransformComponent).z;
    }
    /**
     * @deprecated Use [[Actor.z]]
     */
    getZIndex() {
        return this.get(TransformComponent).z;
    }
    /**
     * Sets the z-index of an actor and updates it in the drawing list for the scene.
     * The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     * @param newZ new z-index to assign
     */
    set z(newZ) {
        this.get(TransformComponent).z = newZ;
    }
    /**
     * @param newIndex new z-index to assign
     * @deprecated Use [[Actor.z]]
     */
    setZIndex(newIndex) {
        this.get(TransformComponent).z = newIndex;
    }
    /**
     * Get the center point of an actor
     */
    get center() {
        return new Vector(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);
    }
    get width() {
        return this.collider.localBounds.width * this.getGlobalScale().x;
    }
    get height() {
        return this.collider.localBounds.height * this.getGlobalScale().y;
    }
    /**
     * Gets this actor's rotation taking into account any parent relationships
     *
     * @returns Rotation angle in radians
     */
    getGlobalRotation() {
        return this.get(TransformComponent).globalRotation;
    }
    /**
     * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
     *
     * @returns Position in world coordinates
     */
    getGlobalPos() {
        return this.get(TransformComponent).globalPos;
    }
    /**
     * Gets the global scale of the Actor
     */
    getGlobalScale() {
        return this.get(TransformComponent).globalScale;
    }
    // #region Collision
    /**
     * Tests whether the x/y specified are contained in the actor
     * @param x  X coordinate to test (in world coordinates)
     * @param y  Y coordinate to test (in world coordinates)
     * @param recurse checks whether the x/y are contained in any child actors (if they exist).
     */
    contains(x, y, recurse = false) {
        const point = vec(x, y);
        const collider = this.get(ColliderComponent);
        collider.update();
        const geom = collider.get();
        if (!geom) {
            return false;
        }
        const containment = geom.contains(point);
        if (recurse) {
            return (containment ||
                this.children.some((child) => {
                    return child.contains(x, y, true);
                }));
        }
        return containment;
    }
    /**
     * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other
     * @param actor     Actor to test
     * @param distance  Distance in pixels to test
     */
    within(actor, distance) {
        const collider = this.get(ColliderComponent);
        const otherCollider = actor.get(ColliderComponent);
        const me = collider.get();
        const other = otherCollider.get();
        if (me && other) {
            return me.getClosestLineBetween(other).getLength() <= distance;
        }
        return false;
    }
    // #endregion
    // #region Update
    /**
     * Called by the Engine, updates the state of the actor
     * @internal
     * @param engine The reference to the current game engine
     * @param delta  The time elapsed since the last update in milliseconds
     */
    update(engine, delta) {
        this._initialize(engine);
        this._preupdate(engine, delta);
        // Tick animations
        const drawing = this.currentDrawing;
        if (drawing && drawing instanceof Animation_Animation) {
            drawing.tick(delta, engine.stats.currFrame.id);
        }
        // Update actor pipeline (movement, collision detection, event propagation, offscreen culling)
        for (const trait of this.traits) {
            trait.update(this, engine, delta);
        }
        this._postupdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an actor is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an actor is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PreUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    // endregion
    // #region Drawing
    /**
     * Called by the Engine, draws the actor to the screen
     * @param ctx   The rendering context
     * @param delta The time since the last draw in milliseconds
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics, will be removed in v0.26.0
     */
    draw(ctx, delta) {
        var _a;
        // translate canvas by anchor offset
        ctx.save();
        if (this.currentDrawing) {
            ctx.translate(-(this.width * this.anchor.x), -(this.height * this.anchor.y));
            this._predraw(ctx, delta);
            const drawing = this.currentDrawing;
            // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula
            const offsetX = (this.width - drawing.width * drawing.scale.x) * this.anchor.x;
            const offsetY = (this.height - drawing.height * drawing.scale.y) * this.anchor.y;
            this.currentDrawing.draw({ ctx, x: offsetX, y: offsetY, opacity: this.graphics.opacity });
        }
        else {
            this._predraw(ctx, delta);
            if (this.color && this.collider) {
                // update collider geometry based on transform
                const collider = this.get(ColliderComponent);
                collider.update();
                if (collider && !collider.bounds.hasZeroDimensions()) {
                    // Colliders are already shifted by anchor, unshift
                    ctx.globalAlpha = this.graphics.opacity;
                    (_a = collider.get()) === null || _a === void 0 ? void 0 : _a.draw(ctx, this.color, vec(0, 0));
                }
            }
        }
        ctx.restore();
        this._postdraw(ctx, delta);
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('predraw', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before an actor is drawn, but after local transforms are made.
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     */
    onPreDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('postdraw', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after an actor is drawn, and before local transforms are removed.
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     */
    onPostDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for [[onPreDraw]] lifecycle event
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPreDraw, will be removed in v0.26.0
     * @internal
     */
    _predraw(ctx, delta) {
        this.emit('predraw', new PreDrawEvent(ctx, delta, this));
        this.onPreDraw(ctx, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for [[onPostDraw]] lifecycle event
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     * @internal
     */
    _postdraw(ctx, delta) {
        this.emit('postdraw', new PreDrawEvent(ctx, delta, this));
        this.onPostDraw(ctx, delta);
    }
    /**
     * Called by the Engine, draws the actors debugging to the screen
     * @param ctx The rendering context
     *
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     * @internal
     */
    /* istanbul ignore next */
    debugDraw(_ctx) {
        // pass
    }
}
// #region Properties
/**
 * Set defaults for all Actors
 */
Actor.defaults = {
    anchor: Vector.Half
};
Actor_decorate([
    obsolete({ message: 'Actor.visible will be removed in v0.26.0', alternateMethod: 'Use Actor.graphics.visible' })
], Actor.prototype, "visible", null);
Actor_decorate([
    obsolete({
        message: 'Actor.opacity will be removed in v0.26.0',
        alternateMethod: 'Use Actor.graphics.opacity'
    })
], Actor.prototype, "opacity", null);
Actor_decorate([
    obsolete({
        message: 'Actor.setDrawing will be removed in v0.26.0',
        alternateMethod: 'Use Actor.graphics.show() or Actor.graphics.use()'
    })
], Actor.prototype, "setDrawing", null);
Actor_decorate([
    obsolete({
        message: 'Actor.addDrawing will be removed in v0.26.0',
        alternateMethod: 'Use Actor.graphics.add()'
    })
], Actor.prototype, "addDrawing", null);
Actor_decorate([
    obsolete({
        message: 'Actor.getZIndex will be removed in v0.26.0',
        alternateMethod: 'Use Actor.transform.z or Actor.z'
    })
], Actor.prototype, "getZIndex", null);
Actor_decorate([
    obsolete({
        message: 'Actor.setZIndex will be removed in v0.26.0',
        alternateMethod: 'Use Actor.transform.z or Actor.z'
    })
], Actor.prototype, "setZIndex", null);

;// CONCATENATED MODULE: ./ScreenElement.ts





/**
 * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does
 * not participate in collisions. Drawn on top of all other actors.
 */
class ScreenElement_ScreenElement extends Actor {
    constructor(config) {
        super(Object.assign({}, config));
        this.get(TransformComponent).coordPlane = CoordPlane.Screen;
        this.traits = [];
        this.traits.push(new CapturePointer());
        this.anchor = vec(0, 0);
        this.body.collisionType = CollisionType.PreventCollision;
        this.collider.useBoxCollider(this.width, this.height, this.anchor);
        this.enableCapturePointer = true;
    }
    _initialize(engine) {
        this._engine = engine;
        super._initialize(engine);
    }
    contains(x, y, useWorld = true) {
        if (useWorld) {
            return super.contains(x, y);
        }
        const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));
        return super.contains(coords.x, coords.y);
    }
}

;// CONCATENATED MODULE: ./Timer.ts
var Timer_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * The Excalibur timer hooks into the internal timer and fires callbacks,
 * after a certain interval, optionally repeating.
 */
class Timer {
    constructor(fcn, interval, repeats, numberOfRepeats) {
        this._logger = Logger.getInstance();
        this.id = 0;
        this._elapsedTime = 0;
        this._totalTimeAlive = 0;
        this._running = false;
        this._numberOfTicks = 0;
        this.interval = 10;
        this.repeats = false;
        this.maxNumberOfRepeats = -1;
        this._complete = false;
        this.scene = null;
        if (typeof fcn !== 'function') {
            const options = fcn;
            fcn = options.fcn;
            interval = options.interval;
            repeats = options.repeats;
            numberOfRepeats = options.numberOfRepeats;
        }
        if (!!numberOfRepeats && numberOfRepeats >= 0) {
            this.maxNumberOfRepeats = numberOfRepeats;
            if (!repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this.id = Timer._MAX_ID++;
        this.interval = interval || this.interval;
        this.repeats = repeats || this.repeats;
        this._callbacks = [];
        if (fcn) {
            this.on(fcn);
        }
    }
    get complete() {
        return this._complete;
    }
    /**
     * Adds a new callback to be fired after the interval is complete
     * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.
     */
    on(fcn) {
        this._callbacks.push(fcn);
    }
    /**
     * Removes a callback from the callback list to be fired after the interval is complete.
     * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.
     */
    off(fcn) {
        const index = this._callbacks.indexOf(fcn);
        this._callbacks.splice(index, 1);
    }
    /**
     * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
     * @param delta  Number of elapsed milliseconds since the last update.
     */
    update(delta) {
        if (this._running) {
            this._totalTimeAlive += delta;
            this._elapsedTime += delta;
            if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {
                this._complete = true;
                this._running = false;
                this._elapsedTime = 0;
            }
            if (!this.complete && this._elapsedTime >= this.interval) {
                this._callbacks.forEach((c) => {
                    c.call(this);
                });
                this._numberOfTicks++;
                if (this.repeats) {
                    this._elapsedTime = 0;
                }
                else {
                    this._complete = true;
                    this._running = false;
                    this._elapsedTime = 0;
                }
            }
        }
    }
    /**
     * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
     *
     * Warning** you may need to call `timer.start()` again if the timer had completed
     * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
     * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes
     */
    reset(newInterval, newNumberOfRepeats) {
        if (!!newInterval && newInterval >= 0) {
            this.interval = newInterval;
        }
        if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {
            this.maxNumberOfRepeats = newNumberOfRepeats;
            if (!this.repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this._complete = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
    }
    get timesRepeated() {
        return this._numberOfTicks;
    }
    getTimeRunning() {
        return this._totalTimeAlive;
    }
    /**
     * @returns milliseconds until the next action callback, if complete will return 0
     */
    get timeToNextAction() {
        if (this.complete) {
            return 0;
        }
        return this.interval - this._elapsedTime;
    }
    /**
     * @returns milliseconds elapsed toward the next action
     */
    get timeElapsedTowardNextAction() {
        return this._elapsedTime;
    }
    get isRunning() {
        return this._running;
    }
    /**
     * Pauses the timer, time will no longer increment towards the next call
     */
    pause() {
        this._running = false;
        return this;
    }
    /**
     * Unpauses the timer. Time will now increment towards the next call
     * @deprecated Will be removed in v0.26.0
     */
    unpause() {
        this._running = true;
    }
    /**
     * Resumes the timer, time will now increment towards the next call.
     */
    resume() {
        this._running = true;
        return this;
    }
    /**
     * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter
     */
    start() {
        if (!this.scene) {
            this._logger.warn('Cannot start a timer not part of a scene, timer wont start until added');
        }
        this._running = true;
        if (this.complete) {
            this._complete = false;
            this._elapsedTime = 0;
            this._numberOfTicks = 0;
        }
        return this;
    }
    /**
     * Stops the timer and resets the elapsed time counter towards the next action invocation
     */
    stop() {
        this._running = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
        return this;
    }
    /**
     * Cancels the timer, preventing any further executions.
     */
    cancel() {
        this.pause();
        if (this.scene) {
            this.scene.cancelTimer(this);
        }
    }
}
Timer._MAX_ID = 0;
Timer_decorate([
    obsolete({ message: 'Will be removed in v0.26.0', alternateMethod: 'Use Timer.resume()' })
], Timer.prototype, "unpause", null);

;// CONCATENATED MODULE: ./TileMap.ts
var TileMap_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


















/**
 * @hidden
 */
class TileMapImpl extends Entity {
    /**
     * @param xOrConfig     The x coordinate to anchor the TileMap's upper left corner (should not be changed once set) or TileMap option bag
     * @param y             The y coordinate to anchor the TileMap's upper left corner (should not be changed once set)
     * @param cellWidth     The individual width of each cell (in pixels) (should not be changed once set)
     * @param cellHeight    The individual height of each cell (in pixels) (should not be changed once set)
     * @param rows          The number of rows in the TileMap (should not be changed once set)
     * @param cols          The number of cols in the TileMap (should not be changed once set)
     */
    constructor(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
        super();
        this._token = 0;
        this._onScreenXStart = 0;
        this._onScreenXEnd = 9999;
        this._onScreenYStart = 0;
        this._onScreenYEnd = 9999;
        this._spriteSheets = {};
        this._legacySpriteMap = new Map();
        this.logger = Logger.getInstance();
        this.data = [];
        this._rows = [];
        this._cols = [];
        this.visible = true;
        this.isOffscreen = false;
        this._dirty = true;
        if (xOrConfig && typeof xOrConfig === 'object') {
            const config = xOrConfig;
            xOrConfig = config.x;
            y = config.y;
            cellWidth = config.cellWidth;
            cellHeight = config.cellHeight;
            rows = config.rows;
            cols = config.cols;
        }
        this.addComponent(new TransformComponent());
        this.addComponent(new MotionComponent());
        this.addComponent(new BodyComponent({
            type: CollisionType.Fixed
        }));
        this.addComponent(new CanvasDrawComponent((ctx, delta) => this.draw(ctx, delta)));
        this.addComponent(new GraphicsComponent({
            onPostDraw: (ctx, delta) => this.draw(ctx, delta)
        }));
        this.addComponent(new ColliderComponent());
        this._transform = this.get(TransformComponent);
        this._motion = this.get(MotionComponent);
        this._collider = this.get(ColliderComponent);
        this._composite = this._collider.useCompositeCollider([]);
        this.x = xOrConfig;
        this.y = y;
        this.cellWidth = cellWidth;
        this.cellHeight = cellHeight;
        this.rows = rows;
        this.cols = cols;
        this.data = new Array(rows * cols);
        this._rows = new Array(rows);
        this._cols = new Array(cols);
        let currentCol = [];
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                const cd = new Cell(i * cellWidth + xOrConfig, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                cd.map = this;
                this.data[i + j * cols] = cd;
                currentCol.push(cd);
                if (!this._rows[j]) {
                    this._rows[j] = [];
                }
                this._rows[j].push(cd);
            }
            this._cols[i] = currentCol;
            currentCol = [];
        }
        this.get(GraphicsComponent).localBounds = new BoundingBox({
            left: 0,
            top: 0,
            right: this.cols * this.cellWidth,
            bottom: this.rows * this.cellHeight
        });
    }
    flagDirty() {
        this._dirty = true;
    }
    get x() {
        var _a;
        return (_a = this._transform.pos.x) !== null && _a !== void 0 ? _a : 0;
    }
    set x(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this.get(TransformComponent).pos = vec(val, this.y);
        }
    }
    get y() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos.y) !== null && _b !== void 0 ? _b : 0;
    }
    set y(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this._transform.pos = vec(this.x, val);
        }
    }
    get z() {
        var _a;
        return (_a = this._transform.z) !== null && _a !== void 0 ? _a : 0;
    }
    set z(val) {
        if (this._transform) {
            this._transform.z = val;
        }
    }
    get rotation() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : 0;
    }
    set rotation(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) {
            this._transform.rotation = val;
        }
    }
    get scale() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) !== null && _b !== void 0 ? _b : Vector.One;
    }
    set scale(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) {
            this._transform.scale = val;
        }
    }
    get pos() {
        return this._transform.pos;
    }
    set pos(val) {
        this._transform.pos = val;
    }
    get vel() {
        return this._motion.vel;
    }
    set vel(val) {
        this._motion.vel = val;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    registerSpriteSheet(key, spriteSheet) {
        if (spriteSheet instanceof SpriteSheet) {
            this._spriteSheets[key] = spriteSheet;
        }
        else {
            this._spriteSheets[key] = SpriteSheet.fromLegacySpriteSheet(spriteSheet);
        }
    }
    /**
     * Tiles colliders based on the solid tiles in the tilemap.
     */
    _updateColliders() {
        this._composite.clearColliders();
        const colliders = [];
        let current;
        // Bad square tessalation algo
        for (let i = 0; i < this.cols; i++) {
            // Scan column for colliders
            for (let j = 0; j < this.rows; j++) {
                // Columns start with a new collider
                if (j === 0) {
                    current = null;
                }
                const tile = this.data[i + j * this.cols];
                // Current tile in column is solid build up current collider
                if (tile.solid) {
                    if (!current) {
                        current = tile.bounds;
                    }
                    else {
                        current = current.combine(tile.bounds);
                    }
                }
                else {
                    // Not solid skip and cut off the current collider
                    if (current) {
                        colliders.push(current);
                    }
                    current = null;
                }
            }
            // After a column is complete check to see if it can be merged into the last one
            if (current) {
                // if previous is the same combine it
                const prev = colliders[colliders.length - 1];
                if (prev && prev.top === current.top && prev.bottom === current.bottom) {
                    colliders[colliders.length - 1] = prev.combine(current);
                }
                else {
                    // else new collider
                    colliders.push(current);
                }
            }
        }
        this._composite = this._collider.useCompositeCollider([]);
        for (const c of colliders) {
            const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));
            collider.owner = this;
            this._composite.addCollider(collider);
        }
        this._collider.update();
    }
    /**
     * Returns the [[Cell]] by index (row major order)
     */
    getCellByIndex(index) {
        return this.data[index];
    }
    /**
     * Returns the [[Cell]] by its x and y coordinates
     */
    getCell(x, y) {
        if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
            return null;
        }
        return this.data[x + y * this.cols];
    }
    /**
     * Returns the [[Cell]] by testing a point in global coordinates,
     * returns `null` if no cell was found.
     */
    getCellByPoint(x, y) {
        x = Math.floor((x - this.pos.x) / this.cellWidth);
        y = Math.floor((y - this.pos.y) / this.cellHeight);
        const cell = this.getCell(x, y);
        if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
            return cell;
        }
        return null;
    }
    getRows() {
        return this._rows;
    }
    getColumns() {
        return this._cols;
    }
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    update(engine, delta) {
        this.onPreUpdate(engine, delta);
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        if (this._dirty) {
            this._dirty = false;
            this._updateColliders();
        }
        this._token++;
        const worldBounds = engine.getWorldBounds();
        const worldCoordsUpperLeft = vec(worldBounds.left, worldBounds.top);
        const worldCoordsLowerRight = vec(worldBounds.right, worldBounds.bottom);
        this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - this.x) / this.cellWidth) - 2, 0);
        this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
        this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - this.x) / this.cellWidth) + 2, 0);
        this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
        this._transform.pos = vec(this.x, this.y);
        this.onPostUpdate(engine, delta);
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
    }
    /**
     * Draws the tile map to the screen. Called by the [[Scene]].
     * @param ctx CanvasRenderingContext2D or ExcaliburGraphicsContext
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        this.emit('predraw', new PreDrawEvent(ctx, delta, this)); // TODO fix event
        let x = this._onScreenXStart;
        const xEnd = Math.min(this._onScreenXEnd, this.cols);
        let y = this._onScreenYStart;
        const yEnd = Math.min(this._onScreenYEnd, this.rows);
        let graphics, graphicsIndex, graphicsLen;
        for (x; x < xEnd; x++) {
            for (y; y < yEnd; y++) {
                // get non-negative tile sprites
                graphics = this.getCell(x, y).graphics;
                for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {
                    // draw sprite, warning if sprite doesn't exist
                    const graphic = graphics[graphicsIndex];
                    if (graphic) {
                        if (!(ctx instanceof CanvasRenderingContext2D)) {
                            if (hasGraphicsTick(graphic)) {
                                graphic === null || graphic === void 0 ? void 0 : graphic.tick(delta, this._token);
                            }
                            graphic.draw(ctx, x * this.cellWidth, y * this.cellHeight);
                        }
                        else if (graphic instanceof Sprite) {
                            // TODO legacy drawing mode
                            if (!this._legacySpriteMap.has(graphic)) {
                                this._legacySpriteMap.set(graphic, Sprite.toLegacySprite(graphic));
                            }
                            this._legacySpriteMap.get(graphic).draw(ctx, x * this.cellWidth, y * this.cellHeight);
                        }
                    }
                }
            }
            y = this._onScreenYStart;
        }
        this.emit('postdraw', new PostDrawEvent(ctx, delta, this));
    }
}
TileMap_decorate([
    obsolete({ message: 'No longer used, will be removed in v0.26.0' })
], TileMapImpl.prototype, "registerSpriteSheet", null);
/**
 * The [[TileMap]] class provides a lightweight way to do large complex scenes with collision
 * without the overhead of actors.
 */
class TileMap extends Configurable(TileMapImpl) {
    constructor(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
        super(xOrConfig, y, cellWidth, cellHeight, rows, cols);
    }
}
/**
 * @hidden
 */
class CellImpl extends Entity {
    /**
     * @param xOrConfig Gets or sets x coordinate of the cell in world coordinates or cell option bag
     * @param y       Gets or sets y coordinate of the cell in world coordinates
     * @param width   Gets or sets the width of the cell
     * @param height  Gets or sets the height of the cell
     * @param index   The index of the cell in row major order
     * @param solid   Gets or sets whether this cell is solid
     * @param graphics The list of tile graphics to use to draw in this cell (in order)
     */
    constructor(xOrConfig, y, width, height, index, solid = false, graphics = []) {
        super();
        this._solid = false;
        /**
         * Current list of graphics for this cell
         */
        this.graphics = [];
        /**
         * Abitrary data storage per cell, useful for any game specific data
         */
        this.data = new Map();
        if (xOrConfig && typeof xOrConfig === 'object') {
            const config = xOrConfig;
            xOrConfig = config.x;
            y = config.y;
            width = config.width;
            height = config.height;
            index = config.index;
            solid = config.solid;
            graphics = config.sprites;
        }
        this.x = xOrConfig;
        this.y = y;
        this.width = width;
        this.height = height;
        this.index = index;
        this.solid = solid;
        this.graphics = graphics;
        this._bounds = new BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);
    }
    /**
     * Wether this cell should be treated as solid by the tilemap
     */
    get solid() {
        return this._solid;
    }
    /**
     * Wether this cell should be treated as solid by the tilemap
     */
    set solid(val) {
        var _a;
        (_a = this.map) === null || _a === void 0 ? void 0 : _a.flagDirty();
        this._solid = val;
    }
    get bounds() {
        return this._bounds;
    }
    get center() {
        return new Vector(this.x + this.width / 2, this.y + this.height / 2);
    }
    /**
     * Add another [[Sprite]] to this cell
     * @deprecated Use addSprite, will be removed in v0.26.0
     */
    pushSprite(sprite) {
        this.addGraphic(sprite);
    }
    /**
     * Add another [[Graphic]] to this TileMap cell
     * @param graphic
     */
    addGraphic(graphic) {
        if (graphic instanceof Sprite_Sprite) {
            this.graphics.push(Sprite.fromLegacySprite(graphic));
        }
        else {
            this.graphics.push(graphic);
        }
    }
    /**
     * Remove an instance of a [[Graphic]] from this cell
     */
    removeGraphic(graphic) {
        removeItemFromArray(graphic, this.graphics);
    }
    /**
     * Clear all graphis from this cell
     */
    clearGraphics() {
        this.graphics.length = 0;
    }
}
TileMap_decorate([
    obsolete({ message: 'Will be removed in v0.26.0', alternateMethod: 'addSprite' })
], CellImpl.prototype, "pushSprite", null);
/**
 * TileMap Cell
 *
 * A light-weight object that occupies a space in a collision map. Generally
 * created by a [[TileMap]].
 *
 * Cells can draw multiple sprites. Note that the order of drawing is the order
 * of the sprites in the array so the last one will be drawn on top. You can
 * use transparency to create layers this way.
 */
class Cell extends Configurable(CellImpl) {
    constructor(xOrConfig, y, width, height, index, solid, sprites) {
        super(xOrConfig, y, width, height, index, solid, sprites);
    }
}

;// CONCATENATED MODULE: ./Camera.ts








/**
 * Container to house convenience strategy methods
 * @internal
 */
class StrategyContainer {
    constructor(camera) {
        this.camera = camera;
    }
    /**
     * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.
     * @param actor The actor to lock the camera to
     */
    lockToActor(actor) {
        this.camera.addStrategy(new LockCameraToActorStrategy(actor));
    }
    /**
     * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera
     * @param actor The actor to lock the camera to
     * @param axis The axis to follow the actor on
     */
    lockToActorAxis(actor, axis) {
        this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
    }
    /**
     * Creates and adds the [[ElasticToActorStrategy]] on the current camera
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param actor Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    elasticToActor(actor, cameraElasticity, cameraFriction) {
        this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
    }
    /**
     * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera
     * @param actor Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    radiusAroundActor(actor, radius) {
        this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
    }
    /**
     * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera
     * @param box The bounding box to limit the camera to.
     */
    limitCameraBounds(box) {
        this.camera.addStrategy(new LimitCameraBoundsStrategy(box));
    }
}
/**
 * Camera axis enum
 */
var Axis;
(function (Axis) {
    Axis[Axis["X"] = 0] = "X";
    Axis[Axis["Y"] = 1] = "Y";
})(Axis || (Axis = {}));
/**
 * Lock a camera to the exact x/y position of an actor.
 */
class LockCameraToActorStrategy {
    constructor(target) {
        this.target = target;
        this.action = (target, _cam, _eng, _delta) => {
            const center = target.center;
            return center;
        };
    }
}
/**
 * Lock a camera to a specific axis around an actor.
 */
class LockCameraToActorAxisStrategy {
    constructor(target, axis) {
        this.target = target;
        this.axis = axis;
        this.action = (target, cam, _eng, _delta) => {
            const center = target.center;
            const currentFocus = cam.getFocus();
            if (this.axis === Axis.X) {
                return new Vector(center.x, currentFocus.y);
            }
            else {
                return new Vector(currentFocus.x, center.y);
            }
        };
    }
}
/**
 * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.
 */
class ElasticToActorStrategy {
    /**
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param target Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    constructor(target, cameraElasticity, cameraFriction) {
        this.target = target;
        this.cameraElasticity = cameraElasticity;
        this.cameraFriction = cameraFriction;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            let focus = cam.getFocus();
            let cameraVel = cam.vel.clone();
            // Calculate the stretch vector, using the spring equation
            // F = kX
            // https://en.wikipedia.org/wiki/Hooke's_law
            // Apply to the current camera velocity
            const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X
            cameraVel = cameraVel.add(stretch);
            // Calculate the friction (-1 to apply a force in the opposition of motion)
            // Apply to the current camera velocity
            const friction = cameraVel.scale(-1).scale(this.cameraFriction);
            cameraVel = cameraVel.add(friction);
            // Update position by velocity deltas
            focus = focus.add(cameraVel);
            return focus;
        };
    }
}
class RadiusAroundActorStrategy {
    /**
     *
     * @param target Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    constructor(target, radius) {
        this.target = target;
        this.radius = radius;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            const focus = cam.getFocus();
            const direction = position.sub(focus);
            const distance = direction.size;
            if (distance >= this.radius) {
                const offset = distance - this.radius;
                return focus.add(direction.normalize().scale(offset));
            }
            return focus;
        };
    }
}
/**
 * Prevent a camera from going beyond the given camera dimensions.
 */
class LimitCameraBoundsStrategy {
    constructor(target) {
        this.target = target;
        /**
         * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.
         *
         * Note that this strategy does not perform any movement by itself.
         * It only sets the camera position to within the given bounds when the camera has gone beyond them.
         * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.
         *
         * Make sure that the camera bounds are at least as large as the viewport size.
         *
         * @param target The bounding box to limit the camera to
         */
        this.boundSizeChecked = false; // Check and warn only once
        this.action = (target, cam, _eng, _delta) => {
            const focus = cam.getFocus();
            if (!this.boundSizeChecked) {
                if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {
                    Logger.getInstance().warn('Camera bounds should not be smaller than the engine viewport');
                }
                this.boundSizeChecked = true;
            }
            let focusX = focus.x;
            let focusY = focus.y;
            if (focus.x < target.left + _eng.halfDrawWidth) {
                focusX = target.left + _eng.halfDrawWidth;
            }
            else if (focus.x > target.right - _eng.halfDrawWidth) {
                focusX = target.right - _eng.halfDrawWidth;
            }
            if (focus.y < target.top + _eng.halfDrawHeight) {
                focusY = target.top + _eng.halfDrawHeight;
            }
            else if (focus.y > target.bottom - _eng.halfDrawHeight) {
                focusY = target.bottom - _eng.halfDrawHeight;
            }
            return vec(focusX, focusY);
        };
    }
}
/**
 * Cameras
 *
 * [[Camera]] is the base class for all Excalibur cameras. Cameras are used
 * to move around your game and set focus. They are used to determine
 * what is "off screen" and can be used to scale the game.
 *
 */
class Camera extends Class {
    constructor() {
        super(...arguments);
        this._cameraStrategies = [];
        this.strategy = new StrategyContainer(this);
        /**
         * Get or set current zoom of the camera, defaults to 1
         */
        this._z = 1;
        /**
         * Get or set rate of change in zoom, defaults to 0
         */
        this.dz = 0;
        /**
         * Get or set zoom acceleration
         */
        this.az = 0;
        /**
         * Current rotation of the camera
         */
        this.rotation = 0;
        /**
         * Current angular velocity
         */
        this.rx = 0;
        /**
         * Get or set the camera's position
         */
        this._posChanged = false;
        this._pos = watchAny(Vector.Zero, () => (this._posChanged = true));
        /**
         * Get or set the camera's velocity
         */
        this.vel = Vector.Zero;
        /**
         * GEt or set the camera's acceleration
         */
        this.acc = Vector.Zero;
        this._cameraMoving = false;
        this._currentLerpTime = 0;
        this._lerpDuration = 1000; // 1 second
        this._lerpStart = null;
        this._lerpEnd = null;
        //camera effects
        this._isShaking = false;
        this._shakeMagnitudeX = 0;
        this._shakeMagnitudeY = 0;
        this._shakeDuration = 0;
        this._elapsedShakeTime = 0;
        this._xShake = 0;
        this._yShake = 0;
        this._isZooming = false;
        this._zoomStart = 1;
        this._zoomEnd = 1;
        this._currentZoomTime = 0;
        this._zoomDuration = 0;
        this._zoomEasing = EasingFunctions.EaseInOutCubic;
        this._easing = EasingFunctions.EaseInOutCubic;
        this._halfWidth = 0;
        this._halfHeight = 0;
        this._viewport = null;
        this._isInitialized = false;
    }
    get zoom() {
        return this._z;
    }
    set zoom(val) {
        this._z = val;
        if (this._engine) {
            this._halfWidth = this._engine.halfDrawWidth;
            this._halfHeight = this._engine.halfDrawHeight;
        }
    }
    /**
     * Get or set the camera's angular velocity
     */
    get angularVelocity() {
        return this.rx;
    }
    set angularVelocity(value) {
        this.rx = value;
    }
    get pos() {
        return this._pos;
    }
    set pos(vec) {
        this._pos = watchAny(vec, () => (this._posChanged = true));
        this._posChanged = true;
    }
    /**
     * Get the camera's x position
     */
    get x() {
        return this.pos.x;
    }
    /**
     * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)
     */
    set x(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = vec(value, this.pos.y);
        }
    }
    /**
     * Get the camera's y position
     */
    get y() {
        return this.pos.y;
    }
    /**
     * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)
     */
    set y(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = vec(this.pos.x, value);
        }
    }
    /**
     * Get or set the camera's x velocity
     */
    get dx() {
        return this.vel.x;
    }
    set dx(value) {
        this.vel = vec(value, this.vel.y);
    }
    /**
     * Get or set the camera's y velocity
     */
    get dy() {
        return this.vel.y;
    }
    set dy(value) {
        this.vel = vec(this.vel.x, value);
    }
    /**
     * Get or set the camera's x acceleration
     */
    get ax() {
        return this.acc.x;
    }
    set ax(value) {
        this.acc = vec(value, this.acc.y);
    }
    /**
     * Get or set the camera's y acceleration
     */
    get ay() {
        return this.acc.y;
    }
    set ay(value) {
        this.acc = vec(this.acc.x, value);
    }
    /**
     * Returns the focal point of the camera, a new point giving the x and y position of the camera
     */
    getFocus() {
        return this.pos;
    }
    /**
     * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
     *
     * @param pos The target position to move to
     * @param duration The duration in milliseconds the move should last
     * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)
     * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.
     *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.
     */
    move(pos, duration, easingFn = EasingFunctions.EaseInOutCubic) {
        if (typeof easingFn !== 'function') {
            throw 'Please specify an EasingFunction';
        }
        // cannot move when following an actor
        if (this._follow) {
            return Promise.reject(pos);
        }
        // resolve existing promise, if any
        if (this._lerpPromise && this._lerpResolve) {
            this._lerpResolve(pos);
        }
        this._lerpPromise = new Promise((resolve) => {
            this._lerpResolve = resolve;
        });
        this._lerpStart = this.getFocus().clone();
        this._lerpDuration = duration;
        this._lerpEnd = pos;
        this._currentLerpTime = 0;
        this._cameraMoving = true;
        this._easing = easingFn;
        return this._lerpPromise;
    }
    /**
     * Sets the camera to shake at the specified magnitudes for the specified duration
     * @param magnitudeX  The x magnitude of the shake
     * @param magnitudeY  The y magnitude of the shake
     * @param duration    The duration of the shake in milliseconds
     */
    shake(magnitudeX, magnitudeY, duration) {
        this._isShaking = true;
        this._shakeMagnitudeX = magnitudeX;
        this._shakeMagnitudeY = magnitudeY;
        this._shakeDuration = duration;
    }
    /**
     * Zooms the camera in or out by the specified scale over the specified duration.
     * If no duration is specified, it take effect immediately.
     * @param scale    The scale of the zoom
     * @param duration The duration of the zoom in milliseconds
     */
    zoomOverTime(scale, duration = 0, easingFn = EasingFunctions.EaseInOutCubic) {
        this._zoomPromise = new Promise((resolve) => {
            this._zoomResolve = resolve;
        });
        if (duration) {
            this._isZooming = true;
            this._zoomEasing = easingFn;
            this._currentZoomTime = 0;
            this._zoomDuration = duration;
            this._zoomStart = this.zoom;
            this._zoomEnd = scale;
        }
        else {
            this._isZooming = false;
            this.zoom = scale;
            return Promise.resolve(true);
        }
        return this._zoomPromise;
    }
    /**
     * Gets the bounding box of the viewport of this camera in world coordinates
     */
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return new BoundingBox(0, 0, 0, 0);
    }
    /**
     * Adds a new camera strategy to this camera
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    addStrategy(cameraStrategy) {
        this._cameraStrategies.push(cameraStrategy);
    }
    /**
     * Removes a camera strategy by reference
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    removeStrategy(cameraStrategy) {
        removeItemFromArray(cameraStrategy, this._cameraStrategies);
    }
    /**
     * Clears all camera strategies from the camera
     */
    clearAllStrategies() {
        this._cameraStrategies.length = 0;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Overridable
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Overridable
    }
    get isInitialized() {
        return this._isInitialized;
    }
    _initialize(_engine) {
        if (!this.isInitialized) {
            this._engine = _engine;
            const currentRes = this._engine.screen.resolution;
            let center = vec(currentRes.width / 2, currentRes.height / 2);
            if (!this._engine.loadingComplete) {
                // If there was a loading screen, we peek the configured resolution
                const res = this._engine.screen.peekResolution();
                if (res) {
                    center = vec(res.width / 2, res.height / 2);
                }
            }
            this._halfWidth = center.x;
            this._halfHeight = center.x;
            // If the user has not set the camera pos, apply default center screen position
            if (!this._posChanged) {
                this.pos = center;
            }
            this.onInitialize(_engine);
            super.emit('initialize', new InitializeEvent(_engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onInitialize(_engine) {
        // Overridable
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    update(_engine, delta) {
        this._initialize(_engine);
        this._preupdate(_engine, delta);
        // Update placements based on linear algebra
        this.pos = this.pos.add(this.vel.scale(delta / 1000));
        this.zoom += (this.dz * delta) / 1000;
        this.vel = this.vel.add(this.acc.scale(delta / 1000));
        this.dz += (this.az * delta) / 1000;
        this.rotation += (this.angularVelocity * delta) / 1000;
        if (this._isZooming) {
            if (this._currentZoomTime < this._zoomDuration) {
                const zoomEasing = this._zoomEasing;
                const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);
                this.zoom = newZoom;
                this._currentZoomTime += delta;
            }
            else {
                this._isZooming = false;
                this.zoom = this._zoomEnd;
                this._currentZoomTime = 0;
                this._zoomResolve(true);
            }
        }
        if (this._cameraMoving) {
            if (this._currentLerpTime < this._lerpDuration) {
                const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);
                const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);
                this.pos = lerpPoint;
                this._currentLerpTime += delta;
            }
            else {
                this.pos = this._lerpEnd;
                const end = this._lerpEnd.clone();
                this._lerpStart = null;
                this._lerpEnd = null;
                this._currentLerpTime = 0;
                this._cameraMoving = false;
                // Order matters here, resolve should be last so any chain promises have a clean slate
                this._lerpResolve(end);
            }
        }
        if (this._isDoneShaking()) {
            this._isShaking = false;
            this._elapsedShakeTime = 0;
            this._shakeMagnitudeX = 0;
            this._shakeMagnitudeY = 0;
            this._shakeDuration = 0;
            this._xShake = 0;
            this._yShake = 0;
        }
        else {
            this._elapsedShakeTime += delta;
            this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;
            this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;
        }
        for (const s of this._cameraStrategies) {
            this.pos = s.action.call(s, s.target, this, _engine, delta);
        }
        this._viewport = new BoundingBox(this.x - this._halfWidth, this.y - this._halfHeight, this.x + this._halfWidth, this.y + this._halfHeight);
        this._postupdate(_engine, delta);
    }
    draw(ctx) {
        let canvasWidth = 0;
        let canvasHeight = 0;
        if (ctx instanceof CanvasRenderingContext2D) {
            canvasWidth = ctx.canvas.width;
            canvasHeight = ctx.canvas.height;
        }
        else {
            canvasWidth = ctx.width;
            canvasHeight = ctx.height;
        }
        const focus = this.getFocus();
        const pixelRatio = this._engine ? this._engine.pixelRatio : 1;
        const zoom = this.zoom;
        const newCanvasWidth = canvasWidth / zoom / pixelRatio;
        const newCanvasHeight = canvasHeight / zoom / pixelRatio;
        ctx.scale(zoom, zoom);
        ctx.translate(-focus.x + newCanvasWidth / 2 + this._xShake, -focus.y + newCanvasHeight / 2 + this._yShake);
    }
    /* istanbul ignore next */
    debugDraw(_ctx) {
        // pass
    }
    _isDoneShaking() {
        return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;
    }
}

;// CONCATENATED MODULE: ./Util/Actors.ts



/**
 * Type guard to detect if something is an actor
 * @deprecated Will be removed in v0.26.0
 * @param actor
 */
function isVanillaActor(actor) {
    return !(actor instanceof ScreenElement) && !(actor instanceof Trigger) && !(actor instanceof Label);
}
/**
 * Type guard to detect a screen element
 * @todo move to ScreenElement
 */
function isScreenElement(actor) {
    return actor instanceof ScreenElement_ScreenElement;
}

;// CONCATENATED MODULE: ./Trigger.ts







const triggerDefaults = {
    pos: Vector.Zero,
    width: 10,
    height: 10,
    visible: false,
    action: () => {
        return;
    },
    filter: () => true,
    repeat: -1
};
/**
 * Triggers are a method of firing arbitrary code on collision. These are useful
 * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
 * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.
 */
class Trigger_Trigger extends Actor {
    /**
     *
     * @param opts Trigger options
     */
    constructor(opts) {
        super({ x: opts.pos.x, y: opts.pos.y, width: opts.width, height: opts.height });
        /**
         * Action to fire when triggered by collision
         */
        this.action = () => {
            return;
        };
        /**
         * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when
         * filter return true for the collided actor.
         */
        this.filter = () => true;
        /**
         * Number of times to repeat before killing the trigger,
         */
        this.repeat = -1;
        opts = extend({}, triggerDefaults, opts);
        this.filter = opts.filter || this.filter;
        this.repeat = opts.repeat || this.repeat;
        this.action = opts.action || this.action;
        if (opts.target) {
            this.target = opts.target;
        }
        this.graphics.visible = opts.visible;
        this.body.collisionType = CollisionType.Passive;
        this.eventDispatcher = new EventDispatcher(this);
        this.events.on('collisionstart', (evt) => {
            if (this.filter(evt.other)) {
                this.emit('enter', new EnterTriggerEvent(this, evt.other));
                this._dispatchAction();
                // remove trigger if its done, -1 repeat forever
                if (this.repeat === 0) {
                    this.kill();
                }
            }
        });
        this.events.on('collisionend', (evt) => {
            if (this.filter(evt.other)) {
                this.emit('exit', new ExitTriggerEvent(this, evt.other));
            }
        });
    }
    set target(target) {
        this._target = target;
        this.filter = (actor) => actor === target;
    }
    get target() {
        return this._target;
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    _dispatchAction() {
        if (this.repeat !== 0) {
            this.action.call(this);
            this.repeat--;
        }
    }
    /* istanbul ignore next */
    debugDraw(ctx) {
        super.debugDraw(ctx);
        // Meant to draw debug information about actors
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        const bb = this.collider.bounds;
        const wp = this.getGlobalPos();
        bb.left = bb.left - wp.x;
        bb.right = bb.right - wp.x;
        bb.top = bb.top - wp.y;
        bb.bottom = bb.bottom - wp.y;
        ctx.fillStyle = Color.Violet.toString();
        ctx.strokeStyle = Color.Violet.toString();
        ctx.fillText('Trigger', 10, 10);
        bb.debugDraw(ctx);
        ctx.restore();
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/System.ts
/**
 * Enum that determines whether to run the system in the update or draw phase
 */
var SystemType;
(function (SystemType) {
    SystemType["Update"] = "update";
    SystemType["Draw"] = "draw";
})(SystemType || (SystemType = {}));
/**
 * An Excalibur [[System]] that updates entities of certain types.
 * Systems are scene specific
 *
 * Excalibur Systems currently require at least 1 Component type to operated
 *
 * Multiple types are declared as a type union
 * For example:
 *
 * ```typescript
 * class MySystem extends System<ComponentA | ComponentB> {
 *   public readonly types = ['a', 'b'] as const;
 *   public readonly systemType = SystemType.Update;
 *   public update(entities: Entity<ComponentA | ComponentB>) {
 *      ...
 *   }
 * }
 * ```
 */
class System {
    constructor() {
        /**
         * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.
         * For a system to execute before all other a lower priority value (-1 for example) must be set.
         * For a system to exectue after all other a higher priority value (10 for example) must be set.
         */
        this.priority = 0;
    }
    /**
     * Systems observe when entities match their types or no longer match their types, override
     * @param _entityAddedOrRemoved
     */
    notify(_entityAddedOrRemoved) {
        // Override me
    }
}
/**
 * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.
 */
class AddedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Added';
    }
}
/**
 * Type guard to check for AddedEntity messages
 * @param x
 */
function isAddedSystemEntity(x) {
    return !!x && x.type === 'Entity Added';
}
/**
 * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.
 */
class RemovedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Removed';
    }
}
/**
 * type guard to check for the RemovedEntity message
 */
function isRemoveSystemEntity(x) {
    return !!x && x.type === 'Entity Removed';
}

;// CONCATENATED MODULE: ./EntityComponentSystem/EntityManager.ts


// Add/Remove entitys and components
class EntityManager {
    constructor(_world) {
        this._world = _world;
        this.entities = [];
        this._entityIndex = {};
        this._entitiesToRemove = [];
    }
    /**
     * Runs the entity lifecycle
     * @param _context
     */
    updateEntities(_context, elapsed) {
        for (const entity of this.entities) {
            // TODO is this right?
            entity.update(_context.engine, elapsed);
            if (!entity.active) {
                this.removeEntity(entity);
            }
        }
    }
    findEntitiesForRemoval() {
        for (const entity of this.entities) {
            if (!entity.active) {
                this.removeEntity(entity);
            }
        }
    }
    /**
     * EntityManager observes changes on entities
     * @param message
     */
    notify(message) {
        if (isAddedComponent(message)) {
            // we don't need the component, it's already on the entity
            this._world.queryManager.addEntity(message.data.entity);
        }
        if (isRemovedComponent(message)) {
            this._world.queryManager.removeComponent(message.data.entity, message.data.component);
        }
    }
    /**
     * Adds an entity to be tracked by the EntityManager
     * @param entity
     */
    addEntity(entity) {
        entity.active = true;
        if (entity && !this._entityIndex[entity.id]) {
            this._entityIndex[entity.id] = entity;
            this.entities.push(entity);
            this._world.queryManager.addEntity(entity);
            entity.componentAdded$.register(this);
            entity.componentRemoved$.register(this);
            // if entity has children
            entity.children.forEach((c) => this.addEntity(c));
            entity.childrenAdded$.register({
                notify: (e) => {
                    this.addEntity(e);
                }
            });
            entity.childrenRemoved$.register({
                notify: (e) => {
                    this.removeEntity(e, false);
                }
            });
        }
    }
    removeEntity(idOrEntity, deferred = true) {
        var _a;
        let id = 0;
        if (idOrEntity instanceof Entity) {
            id = idOrEntity.id;
        }
        else {
            id = idOrEntity;
        }
        const entity = this._entityIndex[id];
        if (entity && entity.active) {
            entity.kill();
        }
        if (entity && deferred) {
            this._entitiesToRemove.push(entity);
            return;
        }
        delete this._entityIndex[id];
        if (entity) {
            removeItemFromArray(entity, this.entities);
            this._world.queryManager.removeEntity(entity);
            entity.componentAdded$.unregister(this);
            entity.componentRemoved$.unregister(this);
            // if entity has children
            entity.children.forEach((c) => this.removeEntity(c, deferred));
            entity.childrenAdded$.clear();
            entity.childrenRemoved$.clear();
            // stats
            if ((_a = this._world.context) === null || _a === void 0 ? void 0 : _a.engine) {
                this._world.context.engine.stats.currFrame.actors.killed++;
            }
        }
    }
    processEntityRemovals() {
        for (const entity of this._entitiesToRemove) {
            if (entity.active) {
                continue;
            }
            this.removeEntity(entity, false);
        }
    }
    processComponentRemovals() {
        for (const entity of this.entities) {
            entity.processComponentRemoval();
        }
    }
    getById(id) {
        return this._entityIndex[id];
    }
    getByName(name) {
        return this.entities.filter(e => e.name === name);
    }
    clear() {
        for (const entity of this.entities) {
            this.removeEntity(entity);
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Util.ts
const buildTypeKey = (types) => {
    const key = [...types].sort((a, b) => a.localeCompare(b)).join('+');
    return key;
};

;// CONCATENATED MODULE: ./EntityComponentSystem/Query.ts





/**
 * Represents query for entities that match a list of types that is cached and observable
 *
 * Queries can be strongly typed by supplying a type union in the optional type parameter
 * ```typescript
 * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);
 * ```
 */
class Query extends Observable {
    constructor(types) {
        super();
        this._entities = [];
        if (types[0] instanceof Function) {
            this.types = types.map(T => (new T).type);
        }
        else {
            this.types = types;
        }
    }
    get key() {
        if (this._key) {
            return this._key;
        }
        return (this._key = buildTypeKey(this.types));
    }
    /**
     * Returns a list of entities that match the query
     *
     * @param sort Optional sorting function to sort entities returned from the query
     */
    getEntities(sort) {
        if (sort) {
            this._entities.sort(sort);
        }
        return this._entities;
    }
    /**
     * Add an entity to the query, will only be added if the entity matches the query types
     * @param entity
     */
    addEntity(entity) {
        if (!contains(this._entities, entity) && this.matches(entity)) {
            this._entities.push(entity);
            this.notifyAll(new AddedEntity(entity));
        }
    }
    /**
     * If the entity is part of the query it will be removed regardless of types
     * @param entity
     */
    removeEntity(entity) {
        if (removeItemFromArray(entity, this._entities)) {
            this.notifyAll(new RemovedEntity(entity));
        }
    }
    /**
     * Removes all entities and observers from the query
     */
    clear() {
        this._entities.length = 0;
        for (const observer of this.observers) {
            this.unregister(observer);
        }
    }
    matches(typesOrEntity) {
        let types = [];
        if (typesOrEntity instanceof Entity) {
            types = typesOrEntity.types;
        }
        else {
            types = typesOrEntity;
        }
        let matches = true;
        for (const type of this.types) {
            matches = matches && types.indexOf(type) > -1;
            if (!matches) {
                return false;
            }
        }
        return matches;
    }
    contain(type) {
        return this.types.indexOf(type) > -1;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/QueryManager.ts


/**
 * The query manager is responsible for updating all queries when entities/components change
 */
class QueryManager {
    constructor(_world) {
        this._world = _world;
        this._queries = {};
    }
    /**
     * Adds a query to the manager and populates with any entities that match
     * @param query
     */
    _addQuery(query) {
        this._queries[buildTypeKey(query.types)] = query;
        for (const entity of this._world.entityManager.entities) {
            query.addEntity(entity);
        }
    }
    /**
     * Removes the query if there are no observers left
     * @param query
     */
    maybeRemoveQuery(query) {
        if (query.observers.length === 0) {
            query.clear();
            delete this._queries[buildTypeKey(query.types)];
        }
    }
    /**
     * Adds the entity to any matching query in the query manage
     * @param entity
     */
    addEntity(entity) {
        for (const queryType in this._queries) {
            if (this._queries[queryType]) {
                this._queries[queryType].addEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from queries if the removed component disqualifies it
     * @param entity
     * @param component
     */
    removeComponent(entity, component) {
        for (const queryType in this._queries) {
            // If the component being removed from an entity is a part of a query,
            // it is now disqualified from that query, remove it
            if (this._queries[queryType].contain(component.type)) {
                this._queries[queryType].removeEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from all queries it is currently a part of
     * @param entity
     */
    removeEntity(entity) {
        for (const queryType in this._queries) {
            this._queries[queryType].removeEntity(entity);
        }
    }
    /**
     * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance
     * @param types
     */
    createQuery(types) {
        const maybeExistingQuery = this.getQuery(types);
        if (maybeExistingQuery) {
            return maybeExistingQuery;
        }
        const query = new Query(types);
        this._addQuery(query);
        return query;
    }
    /**
     * Retrieves an existing query by types if it exists otherwise returns null
     * @param types
     */
    getQuery(types) {
        const key = buildTypeKey(types);
        if (this._queries[key]) {
            return this._queries[key];
        }
        return null;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/SystemManager.ts

/**
 * The SystemManager is responsible for keeping track of all systems in a scene.
 * Systems are scene specific
 */
class SystemManager {
    constructor(_world) {
        this._world = _world;
        /**
         * List of systems, to add a new system call [[SystemManager.addSystem]]
         */
        this.systems = [];
        this.initialized = false;
    }
    /**
     * Get a system registered in the manager by type
     * @param systemType
     * @returns
     */
    get(systemType) {
        return this.systems.find((s) => s instanceof systemType);
    }
    /**
     * Adds a system to the manager, it will now be updated every frame
     * @param system
     */
    addSystem(system) {
        // validate system has types
        if (!system.types || system.types.length === 0) {
            throw new Error(`Attempted to add a System without any types`);
        }
        const query = this._world.queryManager.createQuery(system.types);
        this.systems.push(system);
        this.systems.sort((a, b) => a.priority - b.priority);
        query.register(system);
        if (this.initialized && system.initialize) {
            system.initialize(this._world.context);
        }
    }
    /**
     * Removes a system from the manager, it will no longer be updated
     * @param system
     */
    removeSystem(system) {
        removeItemFromArray(system, this.systems);
        const query = this._world.queryManager.getQuery(system.types);
        if (query) {
            query.unregister(system);
            this._world.queryManager.maybeRemoveQuery(query);
        }
    }
    /**
     * Updates all systems
     * @param type whether this is an update or draw system
     * @param context context reference
     * @param delta time in milliseconds
     */
    updateSystems(type, context, delta) {
        if (!this.initialized) {
            this.initialized = true;
            for (const s of this.systems) {
                if (s.initialize) {
                    s.initialize(this._world.context);
                }
            }
        }
        const systems = this.systems.filter((s) => s.systemType === type);
        for (const s of systems) {
            if (s.preupdate) {
                s.preupdate(context, delta);
            }
        }
        for (const s of systems) {
            // Get entities that match the system types, pre-sort
            const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);
            // Initialize entities if needed
            if (context instanceof Scene) {
                for (const entity of entities) {
                    entity._initialize(context === null || context === void 0 ? void 0 : context.engine);
                }
            }
            s.update(entities, delta);
        }
        for (const s of systems) {
            if (s.postupdate) {
                s.postupdate(context, delta);
            }
        }
    }
    clear() {
        for (const system of this.systems) {
            this.removeSystem(system);
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/World.ts





/**
 * The World is a self-contained entity component system for a particular context.
 */
class World {
    /**
     * The context type is passed to the system updates
     * @param context
     */
    constructor(context) {
        this.context = context;
        this.queryManager = new QueryManager(this);
        this.entityManager = new EntityManager(this);
        this.systemManager = new SystemManager(this);
    }
    /**
     * Update systems by type and time elapsed in milliseconds
     */
    update(type, delta) {
        if (type === SystemType.Update) {
            this.entityManager.updateEntities(this.context, delta);
        }
        this.systemManager.updateSystems(type, this.context, delta);
        this.entityManager.findEntitiesForRemoval();
        this.entityManager.processComponentRemovals();
        this.entityManager.processEntityRemovals();
    }
    add(entityOrSystem) {
        if (entityOrSystem instanceof Entity) {
            this.entityManager.addEntity(entityOrSystem);
        }
        if (entityOrSystem instanceof System) {
            this.systemManager.addSystem(entityOrSystem);
        }
    }
    remove(entityOrSystem, deferred = true) {
        if (entityOrSystem instanceof Entity) {
            this.entityManager.removeEntity(entityOrSystem, deferred);
        }
        if (entityOrSystem instanceof System) {
            this.systemManager.removeSystem(entityOrSystem);
        }
    }
    clearEntities() {
        this.entityManager.clear();
    }
    clearSystems() {
        this.systemManager.clear();
    }
}

;// CONCATENATED MODULE: ./Collision/Integrator.ts
class EulerIntegrator {
    static integrate(transform, motion, totalAcc, elapsedMs) {
        const seconds = elapsedMs / 1000;
        motion.vel.addEqual(totalAcc.scale(seconds));
        transform.pos.addEqual(motion.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
        motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;
        transform.rotation += motion.angularVelocity * seconds;
        transform.scale.addEqual(motion.scaleFactor.scale(seconds));
    }
}

;// CONCATENATED MODULE: ./Collision/MotionSystem.ts







class MotionSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.motion'];
        this.systemType = SystemType.Update;
        this.priority = -1;
    }
    update(_entities, elapsedMs) {
        let transform;
        let motion;
        for (const entity of _entities) {
            transform = entity.get(TransformComponent);
            motion = entity.get(MotionComponent);
            const optionalBody = entity.get(BodyComponent);
            if (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.sleeping) {
                continue;
            }
            const totalAcc = motion.acc.clone();
            if ((optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.collisionType) === CollisionType.Active && (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.useGravity)) {
                totalAcc.addEqual(Physics.gravity);
            }
            optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.captureOldTransform();
            // Update transform and motion based on Euler linear algebra
            EulerIntegrator.integrate(transform, motion, totalAcc, elapsedMs);
        }
    }
    debugDraw(_ctx) {
        // pass
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/Solver.ts
/**
 * A collision solver figures out how to position colliders such that they are no longer overlapping
 *
 * Solvers are executed in the order
 *
 * 1. preSolve
 * 2. solveVelocity
 * 3. solvePosition
 * 4. postSolve
 * @inheritdoc
 */
class CollisionSolver {
    /**
     * Solves overlapping contact in
     *
     * Solvers are executed in the order
     * 1. preSolve
     * 2. solveVelocity
     * 3. solvePosition
     * 4. postSolve
     * @param contacts
     */
    solve(contacts) {
        // Events and init
        this.preSolve(contacts);
        // Remove any canceled contacts
        contacts = contacts.filter(c => !c.isCanceled());
        // Solve velocity first
        this.solveVelocity(contacts);
        // Solve position last because non-overlap is the most important
        this.solvePosition(contacts);
        // Events and any contact house-keeping the solver needs
        this.postSolve(contacts);
        return contacts;
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/ArcadeSolver.ts





/**
 * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,
 * and negates velocity along the collision normal.
 *
 * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.
 *
 */
class ArcadeSolver extends CollisionSolver {
    preSolve(contacts) {
        for (const contact of contacts) {
            const side = Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            // Publish collision events on both participants
            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
        }
    }
    postSolve(contacts) {
        var _a, _b;
        for (const contact of contacts) {
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
            }
            const side = Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            // Publish collision events on both participants
            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
        }
    }
    solvePosition(contacts) {
        var _a, _b;
        for (const contact of contacts) {
            let mtv = contact.mtv;
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
                if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {
                    // split overlaps if both are Active
                    mtv = mtv.scale(0.5);
                }
                // Resolve overlaps
                if (bodyA.collisionType === CollisionType.Active) {
                    bodyA.pos.x -= mtv.x;
                    bodyA.pos.y -= mtv.y;
                }
                if (bodyB.collisionType === CollisionType.Active) {
                    bodyB.pos.x += mtv.x;
                    bodyB.pos.y += mtv.y;
                }
            }
        }
    }
    solveVelocity(contacts) {
        var _a, _b;
        for (const contact of contacts) {
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
                const normal = contact.normal;
                const opposite = normal.negate();
                // Cancel out velocity opposite direction of collision normal
                if (bodyA.collisionType === CollisionType.Active) {
                    const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));
                    bodyA.vel = bodyA.vel.add(velAdj);
                }
                if (bodyB.collisionType === CollisionType.Active) {
                    const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));
                    bodyB.vel = bodyB.vel.add(velAdj);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/ContactConstraintPoint.ts


/**
 * Holds information about contact points, meant to be reused over multiple frames of contact
 */
class ContactConstraintPoint {
    constructor(point, local, contact) {
        this.point = point;
        this.local = local;
        this.contact = contact;
        /**
         * Impulse accumulated over time in normal direction
         */
        this.normalImpulse = 0;
        /**
         * Impulse accumulated over time in the tangent direction
         */
        this.tangentImpulse = 0;
        /**
         * Effective mass seen in the normal direction
         */
        this.normalMass = 0;
        /**
         * Effective mass seen in the tangent direction
         */
        this.tangentMass = 0;
        /**
         * Direction from center of mass of bodyA to contact point
         */
        this.aToContact = new Vector(0, 0);
        /**
         * Direction from center of mass of bodyB to contact point
         */
        this.bToContact = new Vector(0, 0);
        this.update();
    }
    /**
     * Updates the contact information
     */
    update() {
        var _a, _b;
        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            const normal = this.contact.normal;
            const tangent = this.contact.tangent;
            this.aToContact = this.point.sub(bodyA.pos);
            this.bToContact = this.point.sub(bodyB.pos);
            const aToContactNormal = this.aToContact.cross(normal);
            const bToContactNormal = this.bToContact.cross(normal);
            this.normalMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                    bodyB.inverseInertia * bToContactNormal * bToContactNormal;
            const aToContactTangent = this.aToContact.cross(tangent);
            const bToContactTangent = this.bToContact.cross(tangent);
            this.tangentMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                    bodyB.inverseInertia * bToContactTangent * bToContactTangent;
        }
        return this;
    }
    /**
     * Returns the relative velocity betwen bodyA and bodyB
     */
    getRelativeVelocity() {
        var _a, _b;
        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            // Relative velocity in linear terms
            // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity
            const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));
            const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));
            return velB.sub(velA);
        }
        return Vector.Zero;
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/RealisticSolver.ts









class RealisticSolver extends CollisionSolver {
    constructor() {
        super(...arguments);
        this.lastFrameContacts = new Map();
        // map contact id to contact points
        this.idToContactConstraint = new Map();
    }
    getContactConstraints(id) {
        var _a;
        return (_a = this.idToContactConstraint.get(id)) !== null && _a !== void 0 ? _a : [];
    }
    preSolve(contacts) {
        var _a, _b, _c;
        for (const contact of contacts) {
            // Publish collision events on both participants
            const side = Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
            contact.colliderA.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
            contact.colliderB.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
            // Match awake state for sleeping
            contact.matchAwake();
        }
        // Keep track of contacts that done
        const finishedContactIds = Array.from(this.idToContactConstraint.keys());
        for (const contact of contacts) {
            // Remove all current contacts that are not done
            const index = finishedContactIds.indexOf(contact.id);
            if (index > -1) {
                finishedContactIds.splice(index, 1);
            }
            const contactPoints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];
            let pointIndex = 0;
            const bodyA = contact.colliderA.owner.get(BodyComponent);
            const bodyB = contact.colliderB.owner.get(BodyComponent);
            if (bodyA && bodyB) {
                for (const point of contact.points) {
                    const normal = contact.normal;
                    const tangent = contact.tangent;
                    const aToContact = point.sub(bodyA.pos);
                    const bToContact = point.sub(bodyB.pos);
                    const aToContactNormal = aToContact.cross(normal);
                    const bToContactNormal = bToContact.cross(normal);
                    const normalMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                        bodyB.inverseInertia * bToContactNormal * bToContactNormal;
                    const aToContactTangent = aToContact.cross(tangent);
                    const bToContactTangent = bToContact.cross(tangent);
                    const tangentMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                        bodyB.inverseInertia * bToContactTangent * bToContactTangent;
                    // Preserve normal/tangent impulse by re-using the contact point if it's close
                    if (contactPoints[pointIndex] && ((_c = (_b = contactPoints[pointIndex]) === null || _b === void 0 ? void 0 : _b.point) === null || _c === void 0 ? void 0 : _c.squareDistance(point)) < 4) {
                        contactPoints[pointIndex].point = point;
                        contactPoints[pointIndex].local = contact.localPoints[pointIndex];
                    }
                    else {
                        // new contact if it's not close or doesn't exist
                        contactPoints[pointIndex] = new ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);
                    }
                    // Update contact point calculations
                    contactPoints[pointIndex].aToContact = aToContact;
                    contactPoints[pointIndex].bToContact = bToContact;
                    contactPoints[pointIndex].normalMass = normalMass;
                    contactPoints[pointIndex].tangentMass = tangentMass;
                    pointIndex++;
                }
            }
            this.idToContactConstraint.set(contact.id, contactPoints);
        }
        // Clean up any contacts that did not occur last frame
        for (const id of finishedContactIds) {
            this.idToContactConstraint.delete(id);
        }
        // Warm contacts with accumulated impulse
        // Useful for tall stacks
        if (Physics.warmStart) {
            this.warmStart(contacts);
        }
        else {
            for (const contact of contacts) {
                const contactPoints = this.getContactConstraints(contact.id);
                for (const point of contactPoints) {
                    point.normalImpulse = 0;
                    point.tangentImpulse = 0;
                }
            }
        }
    }
    postSolve(contacts) {
        for (const contact of contacts) {
            const bodyA = contact.colliderA.owner.get(BodyComponent);
            const bodyB = contact.colliderB.owner.get(BodyComponent);
            if (bodyA && bodyB) {
                // Skip post solve for active+passive collisions
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
                // Update motion values for sleeping
                bodyA.updateMotion();
                bodyB.updateMotion();
            }
            // Publish collision events on both participants
            const side = Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
            contact.colliderA.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
            contact.colliderB.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
        }
        // Store contacts
        this.lastFrameContacts.clear();
        for (const c of contacts) {
            this.lastFrameContacts.set(c.id, c);
        }
    }
    /**
     * Warm up body's based on previous frame contact points
     * @param contacts
     */
    warmStart(contacts) {
        var _a, _b, _c;
        for (const contact of contacts) {
            const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                const contactPoints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                for (const point of contactPoints) {
                    if (Physics.warmStart) {
                        const normalImpulse = contact.normal.scale(point.normalImpulse);
                        const tangentImpulse = contact.tangent.scale(point.tangentImpulse);
                        const impulse = normalImpulse.add(tangentImpulse);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    else {
                        point.normalImpulse = 0;
                        point.tangentImpulse = 0;
                    }
                }
            }
        }
    }
    /**
     * Iteratively solve the position overlap constraint
     * @param contacts
     */
    solvePosition(contacts) {
        var _a, _b, _c;
        for (let i = 0; i < Physics.positionIterations; i++) {
            for (const contact of contacts) {
                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                        continue;
                    }
                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                    for (const point of constraints) {
                        const normal = contact.normal;
                        const separation = CollisionJumpTable.FindContactSeparation(contact, point.local);
                        const steeringConstant = Physics.steeringFactor; //0.2;
                        const maxCorrection = -5;
                        const slop = Physics.slop; //1;
                        // Clamp to avoid over-correction
                        // Remember that we are shooting for 0 overlap in the end
                        const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);
                        const impulse = normal.scale(-steeringForce / point.normalMass);
                        // This is a pseudo impulse, meaning we aren't doing a real impulse calculation
                        // We adjust position and rotation instead of doing the velocity
                        if (bodyA.collisionType === CollisionType.Active) {
                            bodyA.pos = bodyA.pos.add(impulse.negate().scale(bodyA.inverseMass));
                            bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;
                        }
                        if (bodyB.collisionType === CollisionType.Active) {
                            bodyB.pos = bodyB.pos.add(impulse.scale(bodyB.inverseMass));
                            bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;
                        }
                    }
                }
            }
        }
    }
    solveVelocity(contacts) {
        var _a, _b, _c;
        for (let i = 0; i < Physics.velocityIterations; i++) {
            for (const contact of contacts) {
                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                        continue;
                    }
                    const restitution = bodyA.bounciness * bodyB.bounciness;
                    const friction = Math.min(bodyA.friction, bodyB.friction);
                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                    for (const point of constraints) {
                        const relativeVelocity = point.getRelativeVelocity();
                        // Negate velocity in tangent direction to simulate friction
                        const tangentVelocity = -relativeVelocity.dot(contact.tangent);
                        let impulseDelta = tangentVelocity / point.tangentMass;
                        // Clamping based in Erin Catto's GDC 2006 talk
                        // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf
                        // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction
                        // But deltas can vary
                        const maxFriction = friction * point.normalImpulse;
                        const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);
                        impulseDelta = newImpulse - point.tangentImpulse;
                        point.tangentImpulse = newImpulse;
                        const impulse = contact.tangent.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    for (const point of constraints) {
                        // Need to recalc relative velocity because the previous step could have changed vel
                        const relativeVelocity = point.getRelativeVelocity();
                        // Compute impulse in normal direction
                        const normalVelocity = relativeVelocity.dot(contact.normal);
                        // See https://en.wikipedia.org/wiki/Collision_response
                        let impulseDelta = (-(1 + restitution) * normalVelocity) / point.normalMass;
                        // Clamping based in Erin Catto's GDC 2014 talk
                        // Accumulated impulse stored in the contact is always positive (dV > 0)
                        // But deltas can be negative
                        const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);
                        impulseDelta = newImpulse - point.normalImpulse;
                        point.normalImpulse = newImpulse;
                        const impulse = contact.normal.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Collision/CollisionSystem.ts








class CollisionSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.motion', 'ex.collider'];
        this.systemType = SystemType.Update;
        this.priority = -1;
        this._realisticSolver = new RealisticSolver();
        this._arcadeSolver = new ArcadeSolver();
        this._processor = new DynamicTreeCollisionProcessor();
        this._lastFrameContacts = new Map();
        this._currentFrameContacts = new Map();
        this._trackCollider = (c) => this._processor.track(c);
        this._untrackCollider = (c) => this._processor.untrack(c);
    }
    notify(message) {
        if (isAddedSystemEntity(message)) {
            const colliderComponent = message.data.get(ColliderComponent);
            colliderComponent.$colliderAdded.subscribe(this._trackCollider);
            colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);
            const collider = colliderComponent.get();
            if (collider) {
                this._processor.track(collider);
            }
        }
        else {
            const colliderComponent = message.data.get(ColliderComponent);
            const collider = colliderComponent.get();
            if (colliderComponent && collider) {
                this._processor.untrack(collider);
            }
        }
    }
    initialize(scene) {
        this._engine = scene.engine;
    }
    update(_entities, elapsedMs) {
        var _a;
        if (!Physics.enabled) {
            return;
        }
        // Collect up all the colliders
        let colliders = [];
        for (const entity of _entities) {
            const colliderComp = entity.get(ColliderComponent);
            const collider = colliderComp === null || colliderComp === void 0 ? void 0 : colliderComp.get();
            if (colliderComp && ((_a = colliderComp.owner) === null || _a === void 0 ? void 0 : _a.active) && collider) {
                colliderComp.update();
                if (collider instanceof CompositeCollider) {
                    colliders = colliders.concat(collider.getColliders());
                }
                else {
                    colliders.push(collider);
                }
            }
        }
        // Update the spatial partitioning data structures
        // TODO if collider invalid it will break the processor
        // TODO rename "update" to something more specific
        this._processor.update(colliders);
        // Run broadphase on all colliders and locates potential collisions
        const pairs = this._processor.broadphase(colliders, elapsedMs);
        this._currentFrameContacts.clear();
        // Given possible pairs find actual contacts
        let contacts = this._processor.narrowphase(pairs, this._engine.debug.stats.currFrame);
        const solver = this.getSolver();
        // Solve, this resolves the position/velocity so entities arent overlapping
        contacts = solver.solve(contacts);
        // Record contacts
        contacts.forEach((c) => this._currentFrameContacts.set(c.id, c));
        // Emit contact start/end events
        this.runContactStartEnd();
        // reset the last frame cache
        this._lastFrameContacts.clear();
        // Keep track of collisions contacts that have started or ended
        this._lastFrameContacts = new Map(this._currentFrameContacts);
    }
    getSolver() {
        return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;
    }
    debug(ex) {
        this._processor.debug(ex);
    }
    runContactStartEnd() {
        for (const [id, c] of this._currentFrameContacts) {
            // find all new contacts
            if (!this._lastFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                colliderA.events.emit('collisionstart', new CollisionStartEvent(colliderA, colliderB, c));
                colliderA.events.emit('contactstart', new ContactStartEvent(colliderA, colliderB, c));
                colliderB.events.emit('collisionstart', new CollisionStartEvent(colliderB, colliderA, c));
                colliderB.events.emit('contactstart', new ContactStartEvent(colliderB, colliderA, c));
            }
        }
        // find all contacts taht have ceased
        for (const [id, c] of this._lastFrameContacts) {
            if (!this._currentFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                colliderA.events.emit('collisionend', new CollisionEndEvent(colliderA, colliderB));
                colliderA.events.emit('contactend', new ContactEndEvent(colliderA, colliderB));
                colliderB.events.emit('collisionend', new CollisionEndEvent(colliderB, colliderA));
                colliderB.events.emit('contactend', new ContactEndEvent(colliderB, colliderA));
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Animation.ts






var AnimationDirection;
(function (AnimationDirection) {
    /**
     * Animation is playing forwards
     */
    AnimationDirection["Forward"] = "forward";
    /**
     * Animation is play backwards
     */
    AnimationDirection["Backward"] = "backward";
})(AnimationDirection || (AnimationDirection = {}));
var AnimationStrategy;
(function (AnimationStrategy) {
    /**
     * Animation ends without displaying anything
     */
    AnimationStrategy["End"] = "end";
    /**
     * Animation loops to the first frame after the last frame
     */
    AnimationStrategy["Loop"] = "loop";
    /**
     * Animation plays to the last frame, then backwards to the first frame, then repeats
     */
    AnimationStrategy["PingPong"] = "pingpong";
    /**
     * Animation ends stopping on the last frame
     */
    AnimationStrategy["Freeze"] = "freeze";
})(AnimationStrategy || (AnimationStrategy = {}));
/**
 * Create an Animation given a list of [[Frame|frames]] in [[AnimationOptions]]
 *
 * To create an Animation from a [[SpriteSheet]], use [[Animation.fromSpriteSheet]]
 */
class Animation extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this.events = new EventDispatcher(this); // TODO replace with new Emitter
        this.frames = [];
        this.strategy = AnimationStrategy.Loop;
        this.frameDuration = 100;
        this.timeScale = 1;
        this._idempotencyToken = -1;
        this._firstTick = true;
        this._currentFrame = 0;
        this._timeLeftInFrame = 0;
        this._direction = 1; // TODO only used in ping-pong
        this._done = false;
        this._playing = true;
        this._reversed = false;
        this.frames = options.frames;
        this.strategy = (_a = options.strategy) !== null && _a !== void 0 ? _a : this.strategy;
        this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : (_b = options.frameDuration) !== null && _b !== void 0 ? _b : this.frameDuration;
        if (options.reverse) {
            this.reverse();
        }
        this.goToFrame(0);
    }
    clone() {
        return new Animation(Object.assign({ frames: this.frames.map((f) => (Object.assign({}, f))), frameDuration: this.frameDuration, reverse: this._reversed, strategy: this.strategy }, this.cloneGraphicOptions()));
    }
    /**
     * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame
     * and optional [[AnimationStrategy]]
     *
     * Example:
     * ```typescript
     * const spriteSheet = SpriteSheet.fromImageSource({...});
     *
     * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);
     * ```
     *
     * @param spriteSheet
     * @param frameIndices
     * @param durationPerFrameMs
     * @param strategy
     */
    static fromSpriteSheet(spriteSheet, frameIndices, durationPerFrameMs, strategy = AnimationStrategy.Loop) {
        const maxIndex = spriteSheet.sprites.length - 1;
        const invalidIndices = frameIndices.filter((index) => index < 0 || index > maxIndex);
        if (invalidIndices.length) {
            Animation._LOGGER.warn(`Indices into SpriteSheet were provided that don\'t exist: ${invalidIndices.join(',')} no frame will be shown`);
        }
        return new Animation({
            frames: spriteSheet.sprites
                .filter((_, index) => frameIndices.indexOf(index) > -1)
                .map((f) => ({
                graphic: f,
                duration: durationPerFrameMs
            })),
            strategy: strategy
        });
    }
    /**
     * Converts an animation to a legacy animation
     * @deprecated
     * @param engine
     * @param animation
     * @returns LegacyDrawing.Animation
     */
    static toLegacyAnimation(engine, animation) {
        const legacySprites = animation.frames.map(f => Sprite.toLegacySprite(f.graphic));
        return new Animation_Animation({
            sprites: legacySprites,
            loop: animation.strategy === AnimationStrategy.Loop,
            freezeFrame: animation.strategy === AnimationStrategy.Freeze ? legacySprites.length - 1 : undefined,
            speed: animation.frameDuration,
            engine: engine
        });
    }
    /**
     * Returns the current Frame of the animation
     */
    get currentFrame() {
        if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {
            return this.frames[this._currentFrame];
        }
        return null;
    }
    /**
     * Returns the current frame index of the animation
     */
    get currentFrameIndex() {
        return this._currentFrame;
    }
    /**
     * Returns `true` if the animation is playing
     */
    get isPlaying() {
        return this._playing;
    }
    /**
     * Reverses the play direction of the Animation, this preserves the current frame
     */
    reverse() {
        // Don't mutate with the original frame list, create a copy
        this.frames = this.frames.slice().reverse();
        this._reversed = !this._reversed;
    }
    /**
     * Returns the current play direction of the animation
     */
    get direction() {
        // Keep logically consistent with ping-pong direction
        // If ping-pong is forward = 1 and reversed is true then we are logically reversed
        const reversed = (this._reversed && this._direction === 1) ? true : false;
        return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;
    }
    /**
     * Plays or resumes the animation from the current frame
     */
    play() {
        this._playing = true;
    }
    /**
     * Pauses the animation on the current frame
     */
    pause() {
        this._playing = false;
        this._firstTick = true; // firstTick must be set to emit the proper frame event
    }
    /**
     * Reset the animation back to the beginning, including if the animation were done
     */
    reset() {
        this._done = false;
        this._firstTick = true;
        this._currentFrame = 0;
    }
    /**
     * Returns `true` if the animation can end
     */
    get canFinish() {
        switch (this.strategy) {
            case AnimationStrategy.End:
            case AnimationStrategy.Freeze: {
                return true;
            }
            default: {
                return false;
            }
        }
    }
    /**
     * Returns `true` if the animation is done, for looping type animations
     * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`
     *
     * See the `ex.Animation.canFinish()` method to know if an animation type can end
     */
    get done() {
        return this._done;
    }
    /**
     * Jump the animation immediately to a specific frame if it exists
     * @param frameNumber
     */
    goToFrame(frameNumber) {
        var _a, _b;
        this._currentFrame = frameNumber;
        this._timeLeftInFrame = this.frameDuration;
        const maybeFrame = this.frames[this._currentFrame];
        if (maybeFrame && !this._done) {
            this._timeLeftInFrame = (maybeFrame === null || maybeFrame === void 0 ? void 0 : maybeFrame.duration) || this.frameDuration;
            this.width = (_a = maybeFrame.graphic) === null || _a === void 0 ? void 0 : _a.width;
            this.height = (_b = maybeFrame.graphic) === null || _b === void 0 ? void 0 : _b.height;
            this.events.emit('frame', maybeFrame);
        }
    }
    _nextFrame() {
        const currentFrame = this._currentFrame;
        if (this._done) {
            return currentFrame;
        }
        let next = -1;
        switch (this.strategy) {
            case AnimationStrategy.Loop: {
                next = (currentFrame + 1) % this.frames.length;
                if (next === 0) {
                    this.events.emit('loop', this);
                }
                break;
            }
            case AnimationStrategy.End: {
                next = currentFrame + 1;
                if (next >= this.frames.length) {
                    this._done = true;
                    this._currentFrame = this.frames.length;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.Freeze: {
                next = clamp(currentFrame + 1, 0, this.frames.length - 1);
                if (next >= this.frames.length - 1) {
                    this._done = true;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.PingPong: {
                if (currentFrame + this._direction >= this.frames.length) {
                    this._direction = -1;
                    this.events.emit('loop', this);
                }
                if (currentFrame + this._direction < 0) {
                    this._direction = 1;
                    this.events.emit('loop', this);
                }
                next = currentFrame + (this._direction % this.frames.length);
                break;
            }
        }
        return next;
    }
    /**
     * Called internally by Excalibur to update the state of the animation potential update the current frame
     * @param elapsedMilliseconds Milliseconds elapsed
     * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame
     */
    tick(elapsedMilliseconds, idempotencyToken = 0) {
        if (this._idempotencyToken === idempotencyToken) {
            return;
        }
        this._idempotencyToken = idempotencyToken;
        if (!this._playing) {
            return;
        }
        // if it's the first frame emit frame event
        if (this._firstTick) {
            this._firstTick = false;
            this.events.emit('frame', this.currentFrame);
        }
        this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;
        if (this._timeLeftInFrame <= 0) {
            this.goToFrame(this._nextFrame());
        }
        this._updateDimensions();
    }
    _updateDimensions() {
        var _a, _b;
        if (this.currentFrame) {
            this.width = (_a = this.currentFrame.graphic) === null || _a === void 0 ? void 0 : _a.width;
            this.height = (_b = this.currentFrame.graphic) === null || _b === void 0 ? void 0 : _b.height;
        }
    }
    _drawImage(ctx, x, y) {
        if (this.currentFrame) {
            this.currentFrame.graphic.draw(ctx, x, y);
        }
    }
}
Animation._LOGGER = Logger.getInstance();

;// CONCATENATED MODULE: ./Graphics/GraphicsGroup.ts



class GraphicsGroup extends Graphic {
    constructor(options) {
        super(options);
        this.members = [];
        this.members = options.members;
        this._updateDimensions();
    }
    clone() {
        return new GraphicsGroup(Object.assign({ members: [...this.members] }, this.cloneGraphicOptions()));
    }
    _updateDimensions() {
        let bb = new BoundingBox();
        for (const { graphic, pos } of this.members) {
            bb = graphic.localBounds.translate(pos).combine(bb);
        }
        this.width = bb.width;
        this.height = bb.height;
        return bb;
    }
    get localBounds() {
        let bb = new BoundingBox();
        for (const { graphic, pos } of this.members) {
            bb = graphic.localBounds.translate(pos).combine(bb);
        }
        return bb;
    }
    _isAnimationOrGroup(graphic) {
        return graphic instanceof Animation || graphic instanceof GraphicsGroup;
    }
    tick(elapsedMilliseconds, idempotencyToken) {
        for (const member of this.members) {
            const maybeAnimation = member.graphic;
            if (this._isAnimationOrGroup(maybeAnimation)) {
                maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);
            }
        }
    }
    reset() {
        for (const member of this.members) {
            const maybeAnimation = member.graphic;
            if (this._isAnimationOrGroup(maybeAnimation)) {
                maybeAnimation.reset();
            }
        }
    }
    _preDraw(ex, x, y) {
        this._updateDimensions();
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        for (const member of this.members) {
            ex.save();
            ex.translate(x, y);
            member.graphic.draw(ex, member.pos.x, member.pos.y);
            if (this.showDebug) {
                /* istanbul ignore next */
                ex.debug.drawRect(0, 0, this.width, this.height);
            }
            ex.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Particles.ts














/**
 * An enum that represents the types of emitter nozzles
 */
var EmitterType;
(function (EmitterType) {
    /**
     * Constant for the circular emitter type
     */
    EmitterType[EmitterType["Circle"] = 0] = "Circle";
    /**
     * Constant for the rectangular emitter type
     */
    EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
})(EmitterType || (EmitterType = {}));
/**
 * @hidden
 */
class ParticleImpl extends Entity {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        super();
        this.position = new Vector(0, 0);
        this.velocity = new Vector(0, 0);
        this.acceleration = new Vector(0, 0);
        this.particleRotationalVelocity = 0;
        this.currentRotation = 0;
        this.focus = null;
        this.focusAccel = 0;
        this.opacity = 1;
        this.beginColor = Color.White;
        this.endColor = Color.White;
        // Life is counted in ms
        this.life = 300;
        this.fadeFlag = false;
        // Color transitions
        this._rRate = 1;
        this._gRate = 1;
        this._bRate = 1;
        this._aRate = 0;
        this._currentColor = Color.White;
        this.emitter = null;
        this.particleSize = 5;
        this.particleSprite = null;
        this.sizeRate = 0;
        this.elapsedMultiplier = 0;
        this.visible = true;
        this.isOffscreen = false;
        let emitter = emitterOrConfig;
        if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {
            const config = emitterOrConfig;
            emitter = config.emitter;
            life = config.life;
            opacity = config.opacity;
            endColor = config.endColor;
            beginColor = config.beginColor;
            position = config.position;
            velocity = config.velocity;
            acceleration = config.acceleration;
            startSize = config.startSize;
            endSize = config.endSize;
        }
        this.emitter = emitter;
        this.life = life || this.life;
        this.opacity = opacity || this.opacity;
        this.endColor = endColor || this.endColor.clone();
        this.beginColor = beginColor || this.beginColor.clone();
        this._currentColor = this.beginColor.clone();
        this.position = (position || this.position).add(this.emitter.pos);
        this.velocity = velocity || this.velocity;
        this.acceleration = acceleration || this.acceleration;
        this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
        this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
        this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
        this._aRate = this.opacity / this.life;
        this.startSize = startSize || 0;
        this.endSize = endSize || 0;
        if (this.endSize > 0 && this.startSize > 0) {
            this.sizeRate = (this.endSize - this.startSize) / this.life;
            this.particleSize = this.startSize;
        }
        this.addComponent((this.transform = new TransformComponent()));
        this.addComponent(new CanvasDrawComponent((ctx) => this.draw(ctx)));
        this.addComponent((this.graphics = new GraphicsComponent()));
        this.transform.pos = this.position;
        this.transform.rotation = this.currentRotation;
        this.transform.scale = vec(1, 1); // TODO wut
        if (this.particleSprite) {
            this.graphics.opacity = this.opacity;
            this.graphics.use(Sprite.fromLegacySprite(this.particleSprite));
        }
        else {
            this.graphics.onPostDraw = (ctx) => {
                ctx.save();
                this.graphics.opacity = this.opacity;
                const tmpColor = this._currentColor.clone();
                tmpColor.a = 1;
                ctx.debug.drawPoint(vec(0, 0), { color: tmpColor, size: this.particleSize });
                ctx.restore();
            };
        }
    }
    kill() {
        this.emitter.removeParticle(this);
    }
    update(_engine, delta) {
        this.life = this.life - delta;
        this.elapsedMultiplier = this.elapsedMultiplier + delta;
        if (this.life < 0) {
            this.kill();
        }
        if (this.fadeFlag) {
            this.opacity = clamp(this._aRate * this.life, 0.0001, 1);
        }
        if (this.startSize > 0 && this.endSize > 0) {
            this.particleSize = clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
        }
        this._currentColor.r = clamp(this._currentColor.r + this._rRate * delta, 0, 255);
        this._currentColor.g = clamp(this._currentColor.g + this._gRate * delta, 0, 255);
        this._currentColor.b = clamp(this._currentColor.b + this._bRate * delta, 0, 255);
        this._currentColor.a = clamp(this.opacity, 0.0001, 1);
        if (this.focus) {
            const accel = this.focus
                .sub(this.position)
                .normalize()
                .scale(this.focusAccel)
                .scale(delta / 1000);
            this.velocity = this.velocity.add(accel);
        }
        else {
            this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
        }
        this.position = this.position.add(this.velocity.scale(delta / 1000));
        if (this.particleRotationalVelocity) {
            this.currentRotation = (this.currentRotation + (this.particleRotationalVelocity * delta) / 1000) % (2 * Math.PI);
        }
        this.transform.pos = this.position;
        this.transform.rotation = this.currentRotation;
        this.transform.scale = vec(1, 1); // todo wut
        this.graphics.opacity = this.opacity;
    }
    draw(ctx) {
        if (this.particleSprite) {
            this.particleSprite.opacity(this.opacity);
            this.particleSprite.draw(ctx, 0, 0);
            return;
        }
        ctx.save();
        this._currentColor.a = clamp(this.opacity, 0.0001, 1);
        ctx.fillStyle = this._currentColor.toString();
        ctx.beginPath();
        ctx.arc(0, 0, this.particleSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
        ctx.restore();
    }
}
/**
 * Particle is used in a [[ParticleEmitter]]
 */
class Particle extends Configurable(ParticleImpl) {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);
    }
}
/**
 * Using a particle emitter is a great way to create interesting effects
 * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`
 * extend [[Actor]] allowing you to use all of the features that come with.
 */
class ParticleEmitter extends Actor {
    /**
     * @param config particle emitter options bag
     */
    constructor(config) {
        var _a, _b;
        super({ width: (_a = config.width) !== null && _a !== void 0 ? _a : 0, height: (_b = config.height) !== null && _b !== void 0 ? _b : 0 });
        this._particlesToEmit = 0;
        this.numParticles = 0;
        /**
         * Gets or sets the isEmitting flag
         */
        this.isEmitting = true;
        /**
         * Gets or sets the backing particle collection
         */
        this.particles = [];
        /**
         * Gets or sets the backing deadParticle collection
         */
        this.deadParticles = [];
        /**
         * Gets or sets the minimum particle velocity
         */
        this.minVel = 0;
        /**
         * Gets or sets the maximum particle velocity
         */
        this.maxVel = 0;
        /**
         * Gets or sets the acceleration vector for all particles
         */
        this.acceleration = new Vector(0, 0);
        /**
         * Gets or sets the minimum angle in radians
         */
        this.minAngle = 0;
        /**
         * Gets or sets the maximum angle in radians
         */
        this.maxAngle = 0;
        /**
         * Gets or sets the emission rate for particles (particles/sec)
         */
        this.emitRate = 1; //particles/sec
        /**
         * Gets or sets the life of each particle in milliseconds
         */
        this.particleLife = 2000;
        /**
         * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
         */
        this.fadeFlag = false;
        /**
         * Gets or sets the optional focus where all particles should accelerate towards
         */
        this.focus = null;
        /**
         * Gets or sets the acceleration for focusing particles if a focus has been specified
         */
        this.focusAccel = null;
        /**
         * Gets or sets the optional starting size for the particles
         */
        this.startSize = null;
        /**
         * Gets or sets the optional ending size for the particles
         */
        this.endSize = null;
        /**
         * Gets or sets the minimum size of all particles
         */
        this.minSize = 5;
        /**
         * Gets or sets the maximum size of all particles
         */
        this.maxSize = 5;
        /**
         * Gets or sets the beginning color of all particles
         */
        this.beginColor = Color.White;
        /**
         * Gets or sets the ending color of all particles
         */
        this.endColor = Color.White;
        this._og = null;
        this._sprite = null;
        /**
         * Gets or sets the emitter type for the particle emitter
         */
        this.emitterType = EmitterType.Rectangle;
        /**
         * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]
         */
        this.radius = 0;
        /**
         * Gets or sets the particle rotational speed velocity
         */
        this.particleRotationalVelocity = 0;
        /**
         * Indicates whether particles should start with a random rotation
         */
        this.randomRotation = false;
        const { x, y, pos, isEmitting, minVel, maxVel, acceleration, minAngle, maxAngle, emitRate, particleLife, opacity, fadeFlag, focus, focusAccel, startSize, endSize, minSize, maxSize, beginColor, endColor, particleSprite, emitterType, radius, particleRotationalVelocity, randomRotation, random } = Object.assign({}, config);
        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.isEmitting = isEmitting !== null && isEmitting !== void 0 ? isEmitting : this.isEmitting;
        this.minVel = minVel !== null && minVel !== void 0 ? minVel : this.minVel;
        this.maxVel = maxVel !== null && maxVel !== void 0 ? maxVel : this.maxVel;
        this.acceleration = acceleration !== null && acceleration !== void 0 ? acceleration : this.acceleration;
        this.minAngle = minAngle !== null && minAngle !== void 0 ? minAngle : this.minAngle;
        this.maxAngle = maxAngle !== null && maxAngle !== void 0 ? maxAngle : this.maxAngle;
        this.emitRate = emitRate !== null && emitRate !== void 0 ? emitRate : this.emitRate;
        this.particleLife = particleLife !== null && particleLife !== void 0 ? particleLife : this.particleLife;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.fadeFlag = fadeFlag !== null && fadeFlag !== void 0 ? fadeFlag : this.fadeFlag;
        this.focus = focus !== null && focus !== void 0 ? focus : this.focus;
        this.focusAccel = focusAccel !== null && focusAccel !== void 0 ? focusAccel : this.focusAccel;
        this.startSize = startSize !== null && startSize !== void 0 ? startSize : this.startSize;
        this.endSize = endSize !== null && endSize !== void 0 ? endSize : this.endSize;
        this.minSize = minSize !== null && minSize !== void 0 ? minSize : this.minSize;
        this.maxSize = maxSize !== null && maxSize !== void 0 ? maxSize : this.maxSize;
        this.beginColor = beginColor !== null && beginColor !== void 0 ? beginColor : this.beginColor;
        this.endColor = endColor !== null && endColor !== void 0 ? endColor : this.endColor;
        this.particleSprite = particleSprite !== null && particleSprite !== void 0 ? particleSprite : this.particleSprite;
        this.emitterType = emitterType !== null && emitterType !== void 0 ? emitterType : this.emitterType;
        this.radius = radius !== null && radius !== void 0 ? radius : this.radius;
        this.particleRotationalVelocity = particleRotationalVelocity !== null && particleRotationalVelocity !== void 0 ? particleRotationalVelocity : this.particleRotationalVelocity;
        this.randomRotation = randomRotation !== null && randomRotation !== void 0 ? randomRotation : this.randomRotation;
        this.body.collisionType = CollisionType.PreventCollision;
        this.random = random !== null && random !== void 0 ? random : new Random();
        // Remove offscreen culling from particle emitters
        for (let i = 0; i < this.traits.length; i++) {
            if (this.traits[i] instanceof OffscreenCulling) {
                this.traits.splice(i, 1);
            }
        }
    }
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    get opacity() {
        return super.graphics.opacity;
    }
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    set opacity(opacity) {
        super.graphics.opacity = opacity;
    }
    /**
     * Gets or sets the sprite that a particle should use
     */
    get particleSprite() {
        return this._og;
    }
    set particleSprite(val) {
        this._og = val;
        if (val) {
            this._sprite = Sprite.fromLegacySprite(val);
        }
    }
    removeParticle(particle) {
        this.deadParticles.push(particle);
    }
    /**
     * Causes the emitter to emit particles
     * @param particleCount  Number of particles to emit right now
     */
    emitParticles(particleCount) {
        var _a;
        for (let i = 0; i < particleCount; i++) {
            const p = this._createParticle();
            this.particles.push(p);
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                this.scene.world.add(p);
            }
        }
    }
    clearParticles() {
        this.particles.length = 0;
    }
    // Creates a new particle given the constraints of the emitter
    _createParticle() {
        // todo implement emitter constraints;
        let ranX = 0;
        let ranY = 0;
        const angle = randomInRange(this.minAngle, this.maxAngle, this.random);
        const vel = randomInRange(this.minVel, this.maxVel, this.random);
        const size = this.startSize || randomInRange(this.minSize, this.maxSize, this.random);
        const dx = vel * Math.cos(angle);
        const dy = vel * Math.sin(angle);
        if (this.emitterType === EmitterType.Rectangle) {
            ranX = randomInRange(0, this.width, this.random);
            ranY = randomInRange(0, this.height, this.random);
        }
        else if (this.emitterType === EmitterType.Circle) {
            const radius = randomInRange(0, this.radius, this.random);
            ranX = radius * Math.cos(angle);
            ranY = radius * Math.sin(angle);
        }
        const p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Vector(ranX, ranY), new Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
        p.fadeFlag = this.fadeFlag;
        p.particleSize = size;
        if (this.particleSprite) {
            p.particleSprite = this.particleSprite;
            p.graphics.opacity = this.opacity;
            p.graphics.use(this._sprite);
        }
        p.particleRotationalVelocity = this.particleRotationalVelocity;
        if (this.randomRotation) {
            p.currentRotation = randomInRange(0, Math.PI * 2, this.random);
        }
        if (this.focus) {
            p.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));
            p.focusAccel = this.focusAccel;
        }
        return p;
    }
    update(engine, delta) {
        var _a;
        super.update(engine, delta);
        if (this.isEmitting) {
            this._particlesToEmit += this.emitRate * (delta / 1000);
            if (this._particlesToEmit > 1.0) {
                this.emitParticles(Math.floor(this._particlesToEmit));
                this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
            }
        }
        // deferred removal
        for (let i = 0; i < this.deadParticles.length; i++) {
            removeItemFromArray(this.deadParticles[i], this.particles);
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                this.scene.world.remove(this.deadParticles[i], false);
            }
        }
        this.deadParticles.length = 0;
    }
    draw(ctx) {
        // todo is there a more efficient to draw
        // possibly use a webgl offscreen canvas and shaders to do particles?
        this.particles.forEach((p) => p.draw(ctx));
    }
    debugDraw(ctx) {
        super.debugDraw(ctx);
        ctx.fillStyle = Color.Black.toString();
        ctx.fillText('Particles: ' + this.particles.length, this.pos.x, this.pos.y + 20);
        if (this.focus) {
            ctx.fillRect(this.focus.x + this.pos.x, this.focus.y + this.pos.y, 3, 3);
            line(ctx, Color.Yellow, this.focus.x + this.pos.x, this.focus.y + this.pos.y, this.center.x, this.center.y);
            ctx.fillText('Focus', this.focus.x + this.pos.x, this.focus.y + this.pos.y);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsSystem.ts








class GraphicsSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.graphics'];
        this.systemType = SystemType.Draw;
        this.priority = 0;
        this._token = 0;
    }
    initialize(scene) {
        this._graphicsContext = scene.engine.graphicsContext;
        this._camera = scene.camera;
        this._engine = scene.engine;
    }
    sort(a, b) {
        return a.get(TransformComponent).z - b.get(TransformComponent).z;
    }
    update(entities, delta) {
        this._clearScreen();
        this._token++;
        let transform;
        let graphics;
        for (const entity of entities) {
            transform = entity.get(TransformComponent);
            graphics = entity.get(GraphicsComponent);
            // Figure out if entities are offscreen
            const entityOffscreen = this._isOffscreen(transform, graphics);
            if (entityOffscreen && !entity.hasTag('offscreen')) {
                entity.eventDispatcher.emit('exitviewport', new ExitViewPortEvent(entity));
                entity.addComponent(new TagComponent('offscreen'));
            }
            if (!entityOffscreen && entity.hasTag('offscreen')) {
                entity.eventDispatcher.emit('enterviewport', new EnterViewPortEvent(entity));
                entity.removeComponent('offscreen');
            }
            // Skip entities that have graphics offscreen
            if (entityOffscreen) {
                continue;
            }
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            this._pushCameraTransform(transform);
            this._graphicsContext.save();
            // Tick any graphics state (but only once) for animations and graphics groups
            graphics.update(delta, this._token);
            // Position the entity
            this._applyTransform(entity);
            // Optionally run the onPreDraw graphics lifecycle draw
            if (graphics.onPreDraw) {
                graphics.onPreDraw(this._graphicsContext, delta);
            }
            // TODO remove this hack on the particle redo
            const particleOpacity = (entity instanceof Particle) ? entity.opacity : 1;
            this._graphicsContext.opacity = graphics.opacity * particleOpacity;
            // Draw the graphics component
            this._drawGraphicsComponent(graphics);
            // Optionally run the onPostDraw graphics lifecycle draw
            if (graphics.onPostDraw) {
                graphics.onPostDraw(this._graphicsContext, delta);
            }
            this._graphicsContext.restore();
            // Reset the transform back to the original
            this._popCameraTransform(transform);
        }
        this._graphicsContext.flush();
        this._engine.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;
        this._engine.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;
    }
    _clearScreen() {
        this._graphicsContext.clear();
    }
    _isOffscreen(transform, graphics) {
        if (transform.coordPlane === CoordPlane.World) {
            const graphicsOffscreen = !this._camera.viewport.intersect(graphics.localBounds.transform(transform.getGlobalMatrix()));
            return graphicsOffscreen;
        }
        else {
            // TODO sceen coordinates
            return false;
        }
    }
    _drawGraphicsComponent(graphicsComponent) {
        var _a, _b;
        if (graphicsComponent.visible) {
            // this should be moved to the graphics system
            for (const layer of graphicsComponent.layers.get()) {
                for (const { graphic, options } of layer.graphics) {
                    let anchor = graphicsComponent.anchor;
                    let offset = graphicsComponent.offset;
                    if (options === null || options === void 0 ? void 0 : options.anchor) {
                        anchor = options.anchor;
                    }
                    if (options === null || options === void 0 ? void 0 : options.offset) {
                        offset = options.offset;
                    }
                    // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula
                    const offsetX = -graphic.width * anchor.x + offset.x;
                    const offsetY = -graphic.height * anchor.y + offset.y;
                    graphic === null || graphic === void 0 ? void 0 : graphic.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);
                    if (((_a = this._engine) === null || _a === void 0 ? void 0 : _a.isDebug) && this._engine.debug.graphics.showBounds) {
                        const offset = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);
                        if (graphic instanceof GraphicsGroup) {
                            for (const g of graphic.members) {
                                (_b = g.graphic) === null || _b === void 0 ? void 0 : _b.localBounds.translate(offset.add(g.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                            }
                        }
                        else {
                            /* istanbul ignore next */
                            graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                        }
                    }
                }
            }
        }
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            if (transform) {
                this._graphicsContext.translate(transform.pos.x, transform.pos.y);
                this._graphicsContext.scale(transform.scale.x, transform.scale.y);
                this._graphicsContext.rotate(transform.rotation);
            }
        }
    }
    /**
     * Applies the current camera transform if in world coordinates
     * @param transform
     */
    _pushCameraTransform(transform) {
        // Establish camera offset per entity
        if (transform.coordPlane === CoordPlane.World) {
            this._graphicsContext.save();
            if (this._camera) {
                this._camera.draw(this._graphicsContext);
            }
        }
    }
    /**
     * Resets the current camera transform if in world coordinates
     * @param transform
     */
    _popCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Apply camera world offset
            this._graphicsContext.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Drawing/CanvasDrawingSystem.ts




/**
 * Draws anything with a transform and a "draw" method
 * @deprecated Shim for canvas drawing, will be removed v0.26.0
 */
class CanvasDrawingSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.canvas'];
        this.systemType = SystemType.Draw;
        this.priority = -1;
    }
    initialize(scene) {
        this._ctx = scene.engine.ctx;
        this._engine = scene.engine;
        this._camera = scene.camera;
    }
    sort(a, b) {
        return a.get(TransformComponent).z - b.get(TransformComponent).z;
    }
    update(entities, delta) {
        var _a, _b, _c;
        this._clearScreen();
        let transform;
        let canvasdraw;
        const length = entities.length;
        for (let i = 0; i < length; i++) {
            const visible = (_c = (_b = (_a = entities[i]) === null || _a === void 0 ? void 0 : _a.graphics) === null || _b === void 0 ? void 0 : _b.visible) !== null && _c !== void 0 ? _c : true;
            const offscreen = entities[i].isOffScreen;
            if (visible && !offscreen) {
                transform = entities[i].get(TransformComponent);
                canvasdraw = entities[i].get(CanvasDrawComponent);
                this._ctx.save();
                this._pushCameraTransform(transform);
                this._ctx.save();
                this._applyTransform(entities[i]);
                canvasdraw.draw(this._ctx, delta);
                this._ctx.restore();
                this._popCameraTransform(transform);
                this._ctx.restore();
            }
            if (this._engine.isDebug) {
                this._ctx.save();
                this._pushCameraTransform(transform);
                this._ctx.strokeStyle = 'yellow';
                entities[i].debugDraw(this._ctx);
                this._popCameraTransform(transform);
                this._ctx.restore();
            }
        }
        if (this._engine.isDebug) {
            this._ctx.save();
            this._camera.draw(this._ctx);
            this._camera.debugDraw(this._ctx);
            this._ctx.restore();
        }
        this._engine.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;
        this._engine.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;
    }
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            if (transform) {
                this._ctx.translate(transform.pos.x, transform.pos.y);
                this._ctx.rotate(transform.rotation);
                this._ctx.scale(transform.scale.x, transform.scale.y);
            }
        }
    }
    _clearScreen() {
        this._ctx.clearRect(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);
        this._ctx.fillStyle = this._engine.backgroundColor.toString();
        this._ctx.fillRect(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);
    }
    _pushCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Apply camera transform to place entity in world space
            this._ctx.save();
            if (this._camera) {
                this._camera.draw(this._ctx);
            }
        }
    }
    _popCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Restore back to screen space from world space if we were drawing an entity there
            this._ctx.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Debug/DebugSystem.ts






class DebugSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform'];
        this.systemType = SystemType.Draw;
        this.priority = 999; // lowest priority
    }
    initialize(scene) {
        this._graphicsContext = scene.engine.graphicsContext;
        this._camera = scene.camera;
        this._engine = scene.engine;
        this._collisionSystem = scene.world.systemManager.get(CollisionSystem);
    }
    update(entities, _delta) {
        var _a, _b;
        if (!this._engine.isDebug) {
            return;
        }
        const filterSettings = this._engine.debug.filter;
        let id;
        let name;
        const entitySettings = this._engine.debug.entity;
        let tx;
        const txSettings = this._engine.debug.transform;
        let motion;
        const motionSettings = this._engine.debug.motion;
        let colliderComp;
        const colliderSettings = this._engine.debug.collider;
        const physicsSettings = this._engine.debug.physics;
        let graphics;
        const graphicsSettings = this._engine.debug.graphics;
        let body;
        const bodySettings = this._engine.debug.body;
        const cameraSettings = this._engine.debug.camera;
        for (const entity of entities) {
            if (entity.hasTag('offscreen')) {
                // skip offscreen entities
                continue;
            }
            if (entity instanceof Particle) {
                // Particles crush the renderer :(
                continue;
            }
            if (filterSettings.useFilter) {
                const allIds = filterSettings.ids.length === 0;
                const idMatch = allIds || filterSettings.ids.includes(entity.id);
                if (!idMatch) {
                    continue;
                }
                const allNames = filterSettings.nameQuery === '';
                const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);
                if (!nameMatch) {
                    continue;
                }
            }
            let cursor = Vector.Zero;
            const lineHeight = vec(0, 16);
            id = entity.id;
            name = entity.name;
            tx = entity.get(TransformComponent);
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            this._pushCameraTransform(tx);
            this._graphicsContext.save();
            this._applyTransform(entity);
            if (tx) {
                if (txSettings.showAll || txSettings.showPosition) {
                    this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 2, color: txSettings.positionColor });
                    this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showId) {
                    this._graphicsContext.debug.drawText(`id(${id}) ${tx.parent ? 'child of id(' + ((_b = (_a = tx.parent) === null || _a === void 0 ? void 0 : _a.owner) === null || _b === void 0 ? void 0 : _b.id) + ')' : ''}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showName) {
                    this._graphicsContext.debug.drawText(`name(${name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showRotation) {
                    this._graphicsContext.drawLine(Vector.Zero, Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero), txSettings.rotationColor, 2);
                    this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showScale) {
                    this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);
                }
            }
            graphics = entity.get(GraphicsComponent);
            if (graphics) {
                if (graphicsSettings.showAll || graphicsSettings.showBounds) {
                    const bounds = graphics.localBounds;
                    bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);
                }
            }
            body = entity.get(BodyComponent);
            if (body) {
                if (bodySettings.showAll || bodySettings.showCollisionGroup) {
                    this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showCollisionType) {
                    this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMass) {
                    this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMotion) {
                    this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showSleeping) {
                    this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping : 'cant sleep'})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
            }
            this._graphicsContext.restore();
            motion = entity.get(MotionComponent);
            if (motion) {
                if (motionSettings.showAll || motionSettings.showVelocity) {
                    this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);
                    cursor = cursor.add(lineHeight);
                }
                if (motionSettings.showAll || motionSettings.showAcceleration) {
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);
                }
            }
            // Colliders live in world space already so after the restore()
            colliderComp = entity.get(ColliderComponent);
            if (colliderComp) {
                const collider = colliderComp.get();
                if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {
                    collider.debug(this._graphicsContext, colliderSettings.geometryColor);
                }
                if (colliderSettings.showAll || colliderSettings.showBounds) {
                    if (collider instanceof CompositeCollider) {
                        const colliders = collider.getColliders();
                        for (const collider of colliders) {
                            const bounds = collider.bounds;
                            const pos = vec(bounds.left, bounds.top);
                            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                            if (colliderSettings.showAll || colliderSettings.showOwner) {
                                this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);
                            }
                        }
                        colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);
                    }
                    else if (collider) {
                        const bounds = colliderComp.bounds;
                        const pos = vec(bounds.left, bounds.top);
                        this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                        if (colliderSettings.showAll || colliderSettings.showOwner) {
                            this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);
                        }
                    }
                }
            }
            this._popCameraTransform(tx);
        }
        this._graphicsContext.save();
        this._camera.draw(this._graphicsContext);
        if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {
            this._collisionSystem.debug(this._graphicsContext);
        }
        if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {
            for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {
                if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawPoint(point, { size: 5, color: physicsSettings.collisionContactColor });
                    }
                }
                if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {
                            color: physicsSettings.collisionNormalColor
                        });
                    }
                }
            }
        }
        this._graphicsContext.restore();
        if (cameraSettings) {
            this._graphicsContext.save();
            this._camera.draw(this._graphicsContext);
            if (cameraSettings.showAll || cameraSettings.showFocus) {
                this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);
            }
            if (cameraSettings.showAll || cameraSettings.showZoom) {
                this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);
            }
            this._graphicsContext.restore();
        }
        this._graphicsContext.flush();
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            if (transform) {
                this._graphicsContext.translate(transform.pos.x, transform.pos.y);
                this._graphicsContext.scale(transform.scale.x, transform.scale.y);
                this._graphicsContext.rotate(transform.rotation);
            }
        }
    }
    /**
     * Applies the current camera transform if in world coordinates
     * @param transform
     */
    _pushCameraTransform(transform) {
        // Establish camera offset per entity
        if (transform.coordPlane === CoordPlane.World) {
            this._graphicsContext.save();
            if (this._camera) {
                this._camera.draw(this._graphicsContext);
            }
        }
    }
    /**
     * Resets the current camera transform if in world coordinates
     * @param transform
     */
    _popCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Apply camera world offset
            this._graphicsContext.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Actions/ActionsSystem.ts


class ActionsSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.actions'];
        this.systemType = SystemType.Update;
        this.priority = -1;
    }
    update(entities, delta) {
        let actions;
        for (const entity of entities) {
            actions = entity.get(ActionsComponent);
            actions.update(delta);
        }
    }
}

;// CONCATENATED MODULE: ./Scene.ts
var Scene_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






















/**
 * [[Actor|Actors]] are composed together into groupings called Scenes in
 * Excalibur. The metaphor models the same idea behind real world
 * actors in a scene. Only actors in scenes will be updated and drawn.
 *
 * Typical usages of a scene include: levels, menus, loading screens, etc.
 */
class Scene extends Class {
    constructor() {
        super();
        this._logger = Logger.getInstance();
        /**
         * Gets or sets the current camera for the scene
         */
        this.camera = new Camera();
        /**
         * The ECS world for the scene
         */
        this.world = new World(this);
        this._isInitialized = false;
        this._timers = [];
        this._cancelQueue = [];
        // TODO how to people do there own systems
        // Initialize systems
        this.world.add(new ActionsSystem());
        this.world.add(new MotionSystem());
        this.world.add(new CollisionSystem());
        if (Flags.isEnabled(Legacy.LegacyDrawing)) {
            this.world.add(new CanvasDrawingSystem());
        }
        else {
            this.world.add(new GraphicsSystem());
        }
        this.world.add(new DebugSystem());
    }
    /**
     * The actors in the current scene
     */
    get actors() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof Actor;
        });
    }
    /**
     * The entities in the current scene
     */
    get entities() {
        return this.world.entityManager.entities;
    }
    /**
     * The triggers in the current scene
     */
    get triggers() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof Trigger_Trigger;
        });
    }
    /**
     * The [[TileMap]]s in the scene, if any
     */
    get tileMaps() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof TileMap;
        });
    }
    /**
     * The [[ScreenElement]]s in a scene, if any; these are drawn last
     * @deprecated Use [[Scene.actors]]
     */
    get screenElements() {
        return this.actors.filter((a) => a instanceof ScreenElement_ScreenElement);
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    /**
     * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     */
    onInitialize(_engine) {
        // will be overridden
    }
    /**
     * This is called when the scene is made active and started. It is meant to be overridden,
     * this is where you should setup any DOM UI or event handlers needed for the scene.
     */
    onActivate(_oldScene, _newScene) {
        // will be overridden
    }
    /**
     * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,
     * this is where you should cleanup any DOM UI or event handlers needed for the scene.
     */
    onDeactivate(_oldScene, _newScene) {
        // will be overridden
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before a scene is drawn.
     */
    onPreDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after a scene is drawn.
     */
    onPostDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Initializes actors in the scene
     */
    _initializeChildren() {
        for (const child of this.entities) {
            child._initialize(this.engine);
        }
    }
    /**
     * Gets whether or not the [[Scene]] has been initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Initializes the scene before the first update, meant to be called by engine not by users of
     * Excalibur
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.engine = engine;
            // Initialize camera first
            this.camera._initialize(engine);
            // This order is important! we want to be sure any custom init that add actors
            // fire before the actor init
            this.onInitialize.call(this, engine);
            this._initializeChildren();
            this._logger.debug('Scene.onInitialize', this, engine);
            this.eventDispatcher.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.
     * @internal
     */
    _activate(oldScene, newScene) {
        this._logger.debug('Scene.onActivate', this);
        this.onActivate(oldScene, newScene);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.
     * @internal
     */
    _deactivate(oldScene, newScene) {
        this._logger.debug('Scene.onDeactivate', this);
        this.onDeactivate(oldScene, newScene);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(_engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(_engine, delta, this));
        this.onPreUpdate(_engine, delta);
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(_engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(_engine, delta, this));
        this.onPostUpdate(_engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for [[onPreDraw]] lifecycle event
     *
     * @internal
     */
    _predraw(_ctx, _delta) {
        this.emit('predraw', new PreDrawEvent(_ctx, _delta, this));
        this.onPreDraw(_ctx, _delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for [[onPostDraw]] lifecycle event
     *
     * @internal
     */
    _postdraw(_ctx, _delta) {
        this.emit('postdraw', new PostDrawEvent(_ctx, _delta, this));
        this.onPostDraw(_ctx, _delta);
    }
    /**
     * Updates all the actors and timers in the scene. Called by the [[Engine]].
     * @param engine  Reference to the current Engine
     * @param delta   The number of milliseconds since the last update
     */
    update(engine, delta) {
        this._preupdate(engine, delta);
        if (this.camera) {
            this.camera.update(engine, delta);
        }
        // TODO differed entity removal for timers
        let i, len;
        // Remove timers in the cancel queue before updating them
        for (i = 0, len = this._cancelQueue.length; i < len; i++) {
            this.removeTimer(this._cancelQueue[i]);
        }
        this._cancelQueue.length = 0;
        // Cycle through timers updating timers
        for (const timer of this._timers) {
            timer.update(delta);
        }
        this.world.update(SystemType.Update, delta);
        this._collectActorStats(engine);
        engine.input.pointers.dispatchPointerEvents();
        this._postupdate(engine, delta);
    }
    /**
     * Draws all the actors in the Scene. Called by the [[Engine]].
     * @param ctx    The current rendering context
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        var _a;
        this._predraw(ctx, delta);
        this.world.update(SystemType.Draw, delta);
        if ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.isDebug) {
            this.debugDraw(ctx);
        }
        this._postdraw(ctx, delta);
    }
    /**
     * Draws all the actors' debug information in the Scene. Called by the [[Engine]].
     * @param ctx  The current rendering context
     * @deprecated
     */
    /* istanbul ignore next */
    debugDraw(ctx) {
        this.emit('predebugdraw', new PreDebugDrawEvent(ctx, this));
        // pass
        this.emit('postdebugdraw', new PostDebugDrawEvent(ctx, this));
    }
    /**
     * Checks whether an actor is contained in this scene or not
     */
    contains(actor) {
        return this.actors.indexOf(actor) > -1;
    }
    add(entity) {
        this.emit('entityadded', { target: entity });
        this.world.add(entity);
        entity.scene = this;
        if (entity instanceof Timer) {
            if (!contains(this._timers, entity)) {
                this.addTimer(entity);
            }
            return;
        }
    }
    remove(entity) {
        if (entity instanceof Entity) {
            this.emit('entityremoved', { target: entity });
            this.world.remove(entity);
        }
        if (entity instanceof Timer) {
            this.removeTimer(entity);
        }
    }
    /**
     * Adds (any) actor to act as a piece of UI, meaning it is always positioned
     * in screen coordinates. UI actors do not participate in collisions.
     * @todo Should this be `ScreenElement` only?
     * @deprecated Use [[Scene.add]]
     */
    addScreenElement(actor) {
        this.add(actor);
    }
    /**
     * Removes an actor as a piece of UI
     * @deprecated Use [[Scene.remove]]
     */
    removeScreenElement(actor) {
        this.remove(actor);
    }
    /**
     * Adds a [[TileMap]] to the scene, once this is done the TileMap will be drawn and updated.
     * @deprecated Use [[Scene.add]]
     */
    addTileMap(tileMap) {
        this.world.add(tileMap);
    }
    /**
     * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.
     * @deprecated Use [[Scene.remove]]
     */
    removeTileMap(tileMap) {
        this.world.remove(tileMap);
    }
    /**
     * Adds a [[Timer]] to the scene
     * @param timer  The timer to add
     */
    addTimer(timer) {
        this._timers.push(timer);
        timer.scene = this;
        return timer;
    }
    /**
     * Removes a [[Timer]] from the scene.
     * @warning Can be dangerous, use [[cancelTimer]] instead
     * @param timer  The timer to remove
     */
    removeTimer(timer) {
        const i = this._timers.indexOf(timer);
        if (i !== -1) {
            this._timers.splice(i, 1);
        }
        return timer;
    }
    /**
     * Cancels a [[Timer]], removing it from the scene nicely
     * @param timer  The timer to cancel
     */
    cancelTimer(timer) {
        this._cancelQueue.push(timer);
        return timer;
    }
    /**
     * Tests whether a [[Timer]] is active in the scene
     */
    isTimerActive(timer) {
        return this._timers.indexOf(timer) > -1 && !timer.complete;
    }
    isCurrentScene() {
        if (this.engine) {
            return this.engine.currentScene === this;
        }
        return false;
    }
    _collectActorStats(engine) {
        const screenElements = this.actors.filter((a) => a instanceof ScreenElement_ScreenElement);
        for (const _ui of screenElements) {
            engine.stats.currFrame.actors.ui++;
        }
        for (const actor of this.actors) {
            engine.stats.currFrame.actors.alive++;
            for (const child of actor.children) {
                if (isScreenElement(child)) {
                    // TODO not true
                    engine.stats.currFrame.actors.ui++;
                }
                else {
                    engine.stats.currFrame.actors.alive++;
                }
            }
        }
    }
}
Scene_decorate([
    obsolete({
        message: 'Will be removed in excalibur v0.26.0',
        alternateMethod: 'ScreenElements now are normal actors with a Transform Coordinate Plane of Screen'
    })
], Scene.prototype, "screenElements", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.add' })
], Scene.prototype, "addScreenElement", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.remove' })
], Scene.prototype, "removeScreenElement", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.add' })
], Scene.prototype, "addTileMap", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.remove' })
], Scene.prototype, "removeTileMap", null);

;// CONCATENATED MODULE: ./PostProcessing/ColorBlindCorrector.ts

var ColorBlindness;
(function (ColorBlindness) {
    ColorBlindness[ColorBlindness["Protanope"] = 0] = "Protanope";
    ColorBlindness[ColorBlindness["Deuteranope"] = 1] = "Deuteranope";
    ColorBlindness[ColorBlindness["Tritanope"] = 2] = "Tritanope";
})(ColorBlindness || (ColorBlindness = {}));
/**
 * This post processor can correct colors and simulate color blindness.
 * It is possible to use this on every game, but the game's performance
 * will suffer measurably. It's better to use it as a helpful tool while developing your game.
 * Remember, the best practice is to design with color blindness in mind.
 */
class ColorBlindCorrector {
    constructor(engine, simulate = false, colorMode = ColorBlindness.Protanope) {
        this.engine = engine;
        this.simulate = simulate;
        this.colorMode = colorMode;
        /*eslint-disable */
        this._vertexShader = '' +
            'attribute vec2 a_position;' +
            'attribute vec2 a_texCoord;' +
            'uniform vec2 u_resolution;' +
            'varying vec2 v_texCoord;' +
            'void main() {' +
            // convert the rectangle from pixels to 0.0 to 1.0
            'vec2 zeroToOne = a_position / u_resolution;' +
            // convert from 0->1 to 0->2
            'vec2 zeroToTwo = zeroToOne * 2.0;' +
            // convert from 0->2 to -1->+1 (clipspace)
            'vec2 clipSpace = zeroToTwo - 1.0;' +
            'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' +
            // pass the texCoord to the fragment shader
            // The GPU will interpolate this value between points.
            'v_texCoord = a_texCoord;' +
            '}';
        this._fragmentShader = 'precision mediump float;' +
            // our texture
            'uniform sampler2D u_image;' +
            // the texCoords passed in from the vertex shader.
            'varying vec2 v_texCoord;' +
            // Color blind conversions
            /*'mat3 m[9] =' +
           '{' +
              'mat3(1.0, 0.0, 0.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0  ),' + // normal
              'mat3(0.567, 0.433, 0.0,  0.558, 0.442, 0.0,  0.0, 0.242, 0.758),' + // protanopia
              'mat3(0.817, 0.183, 0.0,  0.333, 0.667, 0.0,  0.0, 0.125,0.875),' + // protanomaly
              'mat3(0.625, 0.375, 0.0,  0.7, 0.3, 0.0,  0.0, 0.3,0.7  ),' + // deuteranopia
              'mat3(0.8, 0.2, 0.0,  0.258, 0.742, 0.0,  0.0, 0.142,0.858),' + // deuteranomaly
              'mat3(0.95, 0.05, 0.0,  0.0, 0.433, 0.567,  0.0, 0.475,0.525),' + // tritanopia
              'mat3(0.967, 0.033, 0.0,  0.0, 0.733, 0.267,  0.0, 0.183,0.817),' + // tritanomaly
              'mat3(0.299, 0.587, 0.114,  0.299, 0.587, 0.114,  0.299, 0.587,0.114),' + // achromatopsia
              'mat3(0.618, 0.320, 0.062,  0.163, 0.775, 0.062,  0.163, 0.320,0.516)' +  // achromatomaly
           '};' +*/
            'void main() {' +
            'vec4 o =  texture2D(u_image, v_texCoord);' +
            // RGB to LMS matrix conversion
            'float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);' +
            'float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);' +
            'float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);' +
            // Simulate color blindness
            '//MODE CODE//' +
            /* Deuteranope for testing
              'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;' +*/
            // LMS to RGB matrix conversion
            'vec4 error;' +
            'error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);' +
            'error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);' +
            'error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);' +
            'error.a = 1.0;' +
            'vec4 diff = o - error;' +
            'vec4 correction;' +
            'correction.r = 0.0;' +
            'correction.g =  (diff.r * 0.7) + (diff.g * 1.0);' +
            'correction.b =  (diff.r * 0.7) + (diff.b * 1.0);' +
            'correction = o + correction;' +
            'correction.a = o.a;' +
            '//SIMULATE//' +
            '}';
        this._internalCanvas = document.createElement('canvas');
        this._internalCanvas.width = engine.drawWidth;
        this._internalCanvas.height = engine.drawHeight;
        // eslint-disable-next-line
        this._gl = this._internalCanvas.getContext('webgl', { preserveDrawingBuffer: true });
        this._program = this._gl.createProgram();
        const fragmentShader = this._getShader('Fragment', this._getFragmentShaderByMode(colorMode));
        const vertextShader = this._getShader('Vertex', this._vertexShader);
        this._gl.attachShader(this._program, vertextShader);
        this._gl.attachShader(this._program, fragmentShader);
        this._gl.linkProgram(this._program);
        if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {
            Logger.getInstance().error('Unable to link shader program!');
        }
        this._gl.useProgram(this._program);
    }
    _getFragmentShaderByMode(colorMode) {
        let code = '';
        if (colorMode === ColorBlindness.Protanope) {
            code =
                'float l = 0.0 * L + 2.02344 * M + -2.52581 * S;' +
                    'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
        }
        else if (colorMode === ColorBlindness.Deuteranope) {
            code =
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
        }
        else if (colorMode === ColorBlindness.Tritanope) {
            code =
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                    'float s = -0.395913 * L + 0.801109 * M + 0.0 * S;';
        }
        if (this.simulate) {
            this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = error.rgba;');
        }
        else {
            this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = correction.rgba;');
        }
        return this._fragmentShader.replace('//MODE CODE//', code);
    }
    _setRectangle(x, y, width, height) {
        const x1 = x;
        const x2 = x + width;
        const y1 = y;
        const y2 = y + height;
        this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), this._gl.STATIC_DRAW);
    }
    _getShader(type, program) {
        let shader;
        if (type === 'Fragment') {
            shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
        }
        else if (type === 'Vertex') {
            shader = this._gl.createShader(this._gl.VERTEX_SHADER);
        }
        else {
            Logger.getInstance().error('Error unknown shader type', type);
        }
        this._gl.shaderSource(shader, program);
        this._gl.compileShader(shader);
        if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {
            Logger.getInstance().error('Unable to compile shader!', this._gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }
    process(image, out) {
        // look up where the vertex data needs to go.
        const positionLocation = this._gl.getAttribLocation(this._program, 'a_position');
        const texCoordLocation = this._gl.getAttribLocation(this._program, 'a_texCoord');
        const texCoordBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, texCoordBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), this._gl.STATIC_DRAW);
        this._gl.enableVertexAttribArray(texCoordLocation);
        this._gl.vertexAttribPointer(texCoordLocation, 2, this._gl.FLOAT, false, 0, 0);
        // Create a texture.
        const texture = this._gl.createTexture();
        this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
        // Set the parameters so we can render any size image.
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
        // Flip the texture when unpacking into the gl context, gl reads textures in the opposite order as everything else :/
        this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);
        // Upload the image into the texture.
        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
        // lookup uniforms
        const resolutionLocation = this._gl.getUniformLocation(this._program, 'u_resolution');
        // set the resolution
        this._gl.uniform2f(resolutionLocation, this._internalCanvas.width, this._internalCanvas.height);
        // Create a buffer for the position of the rectangle corners.
        const positionBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, positionBuffer);
        this._gl.enableVertexAttribArray(positionLocation);
        this._gl.vertexAttribPointer(positionLocation, 2, this._gl.FLOAT, false, 0, 0);
        // Set a rectangle the same size as the image.
        this._setRectangle(0, 0, image.width, image.height);
        // Draw the rectangle.
        this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
        // Grab transformed image from internal canvas
        const pixelData = new Uint8Array(image.width * image.height * 4);
        this._gl.readPixels(0, 0, image.width, image.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixelData);
        image.data.set(pixelData);
        out.putImageData(image, 0, 0);
    }
}

;// CONCATENATED MODULE: ./Debug/DebugFlags.ts

class ColorBlindFlags {
    constructor(engine) {
        this._engine = engine;
    }
    correct(colorBlindness) {
        this._engine.postProcessors.push(new ColorBlindCorrector(this._engine, false, colorBlindness));
    }
    simulate(colorBlindness) {
        this._engine.postProcessors.push(new ColorBlindCorrector(this._engine, true, colorBlindness));
    }
}

;// CONCATENATED MODULE: ./Debug/Debug.ts


/**
 * Debug statistics and flags for Excalibur. If polling these values, it would be
 * best to do so on the `postupdate` event for [[Engine]], after all values have been
 * updated during a frame.
 */
class Debug {
    constructor(engine) {
        /**
         * Performance statistics
         */
        this.stats = {
            /**
             * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[postframe]] event. See [[FrameStats]]
             */
            currFrame: new FrameStats(),
            /**
             * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]
             */
            prevFrame: new FrameStats()
        };
        /**
         * Filter debug context to named entities or entity ids
         */
        this.filter = {
            /**
             * Toggle filter on or off (default off) must be on for DebugDraw to use filters
             */
            useFilter: false,
            /**
             * Query for entities by name, if the entity name contains `nameQuery` it will be included
             */
            nameQuery: '',
            /**
             * Query for Entity ids, if the id matches it will be included
             */
            ids: []
        };
        /**
         * Entity debug settings
         */
        this.entity = {
            showAll: false,
            showId: true,
            showName: false
        };
        /**
         * Transform component debug settings
         */
        this.transform = {
            showAll: false,
            showPosition: false,
            positionColor: Color.Yellow,
            showScale: false,
            scaleColor: Color.Green,
            showRotation: false,
            rotationColor: Color.Blue
        };
        /**
         * Graphics component debug settings
         */
        this.graphics = {
            showAll: false,
            showBounds: true,
            boundsColor: Color.Yellow
        };
        /**
         * Collider component debug settings
         */
        this.collider = {
            showAll: false,
            showBounds: true,
            boundsColor: Color.Blue,
            showOwner: false,
            showGeometry: true,
            geometryColor: Color.Green
        };
        /**
         * Physics simulation debug settings
         */
        this.physics = {
            showAll: false,
            showBroadphaseSpacePartitionDebug: false,
            showCollisionNormals: false,
            collisionNormalColor: Color.Cyan,
            showCollisionContacts: true,
            collisionContactColor: Color.Red
        };
        /**
         * Motion component debug settings
         */
        this.motion = {
            showAll: false,
            showVelocity: false,
            velocityColor: Color.Yellow,
            showAcceleration: false,
            accelerationColor: Color.Red
        };
        /**
         * Body component debug settings
         */
        this.body = {
            showAll: false,
            showCollisionGroup: false,
            showCollisionType: false,
            showSleeping: false,
            showMotion: false,
            showMass: false
        };
        /**
         * Camera debug settings
         */
        this.camera = {
            showAll: false,
            showFocus: false,
            focusColor: Color.Red,
            showZoom: false
        };
        this._engine = engine;
        this.colorBlindMode = new ColorBlindFlags(this._engine);
    }
}
/**
 * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid
 * creating instances of this every frame.
 */
class FrameStats {
    constructor() {
        this._id = 0;
        this._delta = 0;
        this._fps = 0;
        this._actorStats = {
            alive: 0,
            killed: 0,
            ui: 0,
            get remaining() {
                return this.alive - this.killed;
            },
            get total() {
                return this.remaining + this.ui;
            }
        };
        this._durationStats = {
            update: 0,
            draw: 0,
            get total() {
                return this.update + this.draw;
            }
        };
        this._physicsStats = new PhysicsStats();
        this._graphicsStats = {
            drawCalls: 0,
            drawnImages: 0
        };
    }
    /**
     * Zero out values or clone other IFrameStat stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.id = otherStats.id;
            this.delta = otherStats.delta;
            this.fps = otherStats.fps;
            this.actors.alive = otherStats.actors.alive;
            this.actors.killed = otherStats.actors.killed;
            this.actors.ui = otherStats.actors.ui;
            this.duration.update = otherStats.duration.update;
            this.duration.draw = otherStats.duration.draw;
            this._physicsStats.reset(otherStats.physics);
            this.graphics.drawCalls = otherStats.graphics.drawCalls;
            this.graphics.drawnImages = otherStats.graphics.drawnImages;
        }
        else {
            this.id = this.delta = this.fps = 0;
            this.actors.alive = this.actors.killed = this.actors.ui = 0;
            this.duration.update = this.duration.draw = 0;
            this._physicsStats.reset();
            this.graphics.drawnImages = this.graphics.drawCalls = 0;
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const fs = new FrameStats();
        fs.reset(this);
        return fs;
    }
    /**
     * Gets the frame's id
     */
    get id() {
        return this._id;
    }
    /**
     * Sets the frame's id
     */
    set id(value) {
        this._id = value;
    }
    /**
     * Gets the frame's delta (time since last frame)
     */
    get delta() {
        return this._delta;
    }
    /**
     * Sets the frame's delta (time since last frame). Internal use only.
     * @internal
     */
    set delta(value) {
        this._delta = value;
    }
    /**
     * Gets the frame's frames-per-second (FPS)
     */
    get fps() {
        return this._fps;
    }
    /**
     * Sets the frame's frames-per-second (FPS). Internal use only.
     * @internal
     */
    set fps(value) {
        this._fps = value;
    }
    /**
     * Gets the frame's actor statistics
     */
    get actors() {
        return this._actorStats;
    }
    /**
     * Gets the frame's duration statistics
     */
    get duration() {
        return this._durationStats;
    }
    /**
     * Gets the frame's physics statistics
     */
    get physics() {
        return this._physicsStats;
    }
    /**
     * Gets the frame's graphics statistics
     */
    get graphics() {
        return this._graphicsStats;
    }
}
class PhysicsStats {
    constructor() {
        this._pairs = 0;
        this._collisions = 0;
        this._contacts = new Map();
        this._fastBodies = 0;
        this._fastBodyCollisions = 0;
        this._broadphase = 0;
        this._narrowphase = 0;
    }
    /**
     * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.pairs = otherStats.pairs;
            this.collisions = otherStats.collisions;
            this.contacts = otherStats.contacts;
            this.fastBodies = otherStats.fastBodies;
            this.fastBodyCollisions = otherStats.fastBodyCollisions;
            this.broadphase = otherStats.broadphase;
            this.narrowphase = otherStats.narrowphase;
        }
        else {
            this.pairs = this.collisions = this.fastBodies = 0;
            this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
            this.contacts.clear();
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const ps = new PhysicsStats();
        ps.reset(this);
        return ps;
    }
    get pairs() {
        return this._pairs;
    }
    set pairs(value) {
        this._pairs = value;
    }
    get collisions() {
        return this._collisions;
    }
    set collisions(value) {
        this._collisions = value;
    }
    get contacts() {
        return this._contacts;
    }
    set contacts(contacts) {
        this._contacts = contacts;
    }
    get fastBodies() {
        return this._fastBodies;
    }
    set fastBodies(value) {
        this._fastBodies = value;
    }
    get fastBodyCollisions() {
        return this._fastBodyCollisions;
    }
    set fastBodyCollisions(value) {
        this._fastBodyCollisions = value;
    }
    get broadphase() {
        return this._broadphase;
    }
    set broadphase(value) {
        this._broadphase = value;
    }
    get narrowphase() {
        return this._narrowphase;
    }
    set narrowphase(value) {
        this._narrowphase = value;
    }
}

;// CONCATENATED MODULE: ./Input/Keyboard.ts



/**
 * Enum representing physical input key codes
 */
var Keys;
(function (Keys) {
    // NUMPAD
    Keys["Num0"] = "Numpad0";
    Keys["Num1"] = "Numpad1";
    Keys["Num2"] = "Numpad2";
    Keys["Num3"] = "Numpad3";
    Keys["Num4"] = "Numpad4";
    Keys["Num5"] = "Numpad5";
    Keys["Num6"] = "Numpad6";
    Keys["Num7"] = "Numpad7";
    Keys["Num8"] = "Numpad8";
    Keys["Num9"] = "Numpad9";
    Keys["NumAdd"] = "NumpadAdd";
    Keys["NumSubtract"] = "NumpadSubtract";
    Keys["NumMultiply"] = "NumpadMultiply";
    Keys["NumDivide"] = "NumpadDivide";
    // NumComma = 'NumpadComma', // not x-browser
    Keys["NumDecimal"] = "NumpadDecimal";
    Keys["Numpad0"] = "Numpad0";
    Keys["Numpad1"] = "Numpad1";
    Keys["Numpad2"] = "Numpad2";
    Keys["Numpad3"] = "Numpad3";
    Keys["Numpad4"] = "Numpad4";
    Keys["Numpad5"] = "Numpad5";
    Keys["Numpad6"] = "Numpad6";
    Keys["Numpad7"] = "Numpad7";
    Keys["Numpad8"] = "Numpad8";
    Keys["Numpad9"] = "Numpad9";
    Keys["NumpadAdd"] = "NumpadAdd";
    Keys["NumpadSubtract"] = "NumpadSubtract";
    Keys["NumpadMultiply"] = "NumpadMultiply";
    Keys["NumpadDivide"] = "NumpadDivide";
    // NumpadComma = 'NumpadComma', // not x-browser
    Keys["NumpadDecimal"] = "NumpadDecimal";
    // MODIFIERS
    Keys["NumLock"] = "NumLock";
    Keys["ShiftLeft"] = "ShiftLeft";
    Keys["ShiftRight"] = "ShiftRight";
    Keys["AltLeft"] = "AltLeft";
    Keys["AltRight"] = "AltRight";
    // NUMBERS
    Keys["Key0"] = "Digit0";
    Keys["Key1"] = "Digit1";
    Keys["Key2"] = "Digit2";
    Keys["Key3"] = "Digit3";
    Keys["Key4"] = "Digit4";
    Keys["Key5"] = "Digit5";
    Keys["Key6"] = "Digit6";
    Keys["Key7"] = "Digit7";
    Keys["Key8"] = "Digit8";
    Keys["Key9"] = "Digit9";
    Keys["Digit0"] = "Digit0";
    Keys["Digit1"] = "Digit1";
    Keys["Digit2"] = "Digit2";
    Keys["Digit3"] = "Digit3";
    Keys["Digit4"] = "Digit4";
    Keys["Digit5"] = "Digit5";
    Keys["Digit6"] = "Digit6";
    Keys["Digit7"] = "Digit7";
    Keys["Digit8"] = "Digit8";
    Keys["Digit9"] = "Digit9";
    // LETTERS
    Keys["A"] = "KeyA";
    Keys["B"] = "KeyB";
    Keys["C"] = "KeyC";
    Keys["D"] = "KeyD";
    Keys["E"] = "KeyE";
    Keys["F"] = "KeyF";
    Keys["G"] = "KeyG";
    Keys["H"] = "KeyH";
    Keys["I"] = "KeyI";
    Keys["J"] = "KeyJ";
    Keys["K"] = "KeyK";
    Keys["L"] = "KeyL";
    Keys["M"] = "KeyM";
    Keys["N"] = "KeyN";
    Keys["O"] = "KeyO";
    Keys["P"] = "KeyP";
    Keys["Q"] = "KeyQ";
    Keys["R"] = "KeyR";
    Keys["S"] = "KeyS";
    Keys["T"] = "KeyT";
    Keys["U"] = "KeyU";
    Keys["V"] = "KeyV";
    Keys["W"] = "KeyW";
    Keys["X"] = "KeyX";
    Keys["Y"] = "KeyY";
    Keys["Z"] = "KeyZ";
    Keys["KeyA"] = "KeyA";
    Keys["KeyB"] = "KeyB";
    Keys["KeyC"] = "KeyC";
    Keys["KeyD"] = "KeyD";
    Keys["KeyE"] = "KeyE";
    Keys["KeyF"] = "KeyF";
    Keys["KeyG"] = "KeyG";
    Keys["KeyH"] = "KeyH";
    Keys["KeyI"] = "KeyI";
    Keys["KeyJ"] = "KeyJ";
    Keys["KeyK"] = "KeyK";
    Keys["KeyL"] = "KeyL";
    Keys["KeyM"] = "KeyM";
    Keys["KeyN"] = "KeyN";
    Keys["KeyO"] = "KeyO";
    Keys["KeyP"] = "KeyP";
    Keys["KeyQ"] = "KeyQ";
    Keys["KeyR"] = "KeyR";
    Keys["KeyS"] = "KeyS";
    Keys["KeyT"] = "KeyT";
    Keys["KeyU"] = "KeyU";
    Keys["KeyV"] = "KeyV";
    Keys["KeyW"] = "KeyW";
    Keys["KeyX"] = "KeyX";
    Keys["KeyY"] = "KeyY";
    Keys["KeyZ"] = "KeyZ";
    // SYMBOLS
    Keys["Semicolon"] = "Semicolon";
    Keys["Quote"] = "Quote";
    Keys["Comma"] = "Comma";
    Keys["Minus"] = "Minus";
    Keys["Period"] = "Period";
    Keys["Slash"] = "Slash";
    Keys["Equal"] = "Equal";
    Keys["BracketLeft"] = "BracketLeft";
    Keys["Backslash"] = "Backslash";
    Keys["BracketRight"] = "BracketRight";
    Keys["Backquote"] = "Backquote";
    // DIRECTIONS
    Keys["Up"] = "ArrowUp";
    Keys["Down"] = "ArrowDown";
    Keys["Left"] = "ArrowLeft";
    Keys["Right"] = "ArrowRight";
    Keys["ArrowUp"] = "ArrowUp";
    Keys["ArrowDown"] = "ArrowDown";
    Keys["ArrowLeft"] = "ArrowLeft";
    Keys["ArrowRight"] = "ArrowRight";
    // OTHER
    Keys["Space"] = "Space";
    Keys["Esc"] = "Escape";
    Keys["Escape"] = "Escape";
})(Keys || (Keys = {}));
/**
 * Event thrown on a game object for a key event
 */
class KeyEvent extends GameEvent {
    /**
     * @param key  The key responsible for throwing the event
     * @param value The key's typed value the browser detected
     * @param originalEvent The original keyboard event that Excalibur handled
     */
    constructor(key, value, originalEvent) {
        super();
        this.key = key;
        this.value = value;
        this.originalEvent = originalEvent;
    }
}
/**
 * Provides keyboard support for Excalibur.
 */
class Keyboard extends Class {
    constructor() {
        super();
        this._keys = [];
        this._keysUp = [];
        this._keysDown = [];
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    /**
     * Initialize Keyboard event listeners
     */
    init(global) {
        if (!global) {
            try {
                // Try and listen to events on top window frame if within an iframe.
                //
                // See https://github.com/excaliburjs/Excalibur/issues/1294
                //
                // Attempt to add an event listener, which triggers a DOMException on
                // cross-origin iframes
                const noop = () => {
                    return;
                };
                window.top.addEventListener('blur', noop);
                window.top.removeEventListener('blur', noop);
                // this will be the same as window if not embedded within an iframe
                global = window.top;
            }
            catch (_a) {
                // fallback to current frame
                global = window;
                Logger.getInstance().warn('Failed to bind to keyboard events to top frame. ' +
                    'If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.');
            }
        }
        global.addEventListener('blur', () => {
            this._keys.length = 0; // empties array efficiently
        });
        // key up is on window because canvas cannot have focus
        global.addEventListener('keyup', (ev) => {
            const code = ev.code;
            const key = this._keys.indexOf(code);
            this._keys.splice(key, 1);
            this._keysUp.push(code);
            const keyEvent = new KeyEvent(code, ev.key, ev);
            // alias the old api, we may want to deprecate this in the future
            this.eventDispatcher.emit('up', keyEvent);
            this.eventDispatcher.emit('release', keyEvent);
        });
        // key down is on window because canvas cannot have focus
        global.addEventListener('keydown', (ev) => {
            const code = ev.code;
            if (this._keys.indexOf(code) === -1) {
                this._keys.push(code);
                this._keysDown.push(code);
                const keyEvent = new KeyEvent(code, ev.key, ev);
                this.eventDispatcher.emit('down', keyEvent);
                this.eventDispatcher.emit('press', keyEvent);
            }
        });
    }
    update() {
        // Reset keysDown and keysUp after update is complete
        this._keysDown.length = 0;
        this._keysUp.length = 0;
        // Emit synthetic "hold" event
        for (let i = 0; i < this._keys.length; i++) {
            this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));
        }
    }
    /**
     * Gets list of keys being pressed down
     */
    getKeys() {
        return this._keys;
    }
    /**
     * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
     * @param key Test whether a key was just pressed
     */
    wasPressed(key) {
        return this._keysDown.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key is held down. This is persisted between frames.
     * @param key  Test whether a key is held down
     */
    isHeld(key) {
        return this._keys.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
     * @param key  Test whether a key was just released
     */
    wasReleased(key) {
        return this._keysUp.indexOf(key) > -1;
    }
}

;// CONCATENATED MODULE: ./Input/Pointer.ts




/**
 * The type of pointer for a [[PointerEvent]].
 */
var PointerType;
(function (PointerType) {
    PointerType["Touch"] = "Touch";
    PointerType["Mouse"] = "Mouse";
    PointerType["Pen"] = "Pen";
    PointerType["Unknown"] = "Unknown";
})(PointerType || (PointerType = {}));
/**
 * Determines the scope of handling mouse/touch events. See [[Pointers]] for more information.
 */
var PointerScope;
(function (PointerScope) {
    /**
     * Handle events on the `canvas` element only. Events originating outside the
     * `canvas` will not be handled.
     */
    PointerScope["Canvas"] = "Canvas";
    /**
     * Handles events on the entire document. All events will be handled by Excalibur.
     */
    PointerScope["Document"] = "Document";
})(PointerScope || (PointerScope = {}));
/**
 * Captures and dispatches PointerEvents
 */
class Pointer extends Class {
    constructor() {
        super();
        this.id = Pointer._MAX_ID++;
        this._isDown = false;
        this._wasDown = false;
        this._actorsUnderPointer = { length: 0 };
        this._actors = [];
        this._actorsLastFrame = [];
        this._actorsNoLongerUnderPointer = [];
        this._actorSortingFcn = (a, b) => {
            if (a.z === b.z) {
                return b.id - a.id;
            }
            return b.z - a.z;
        };
        /**
         * The last position on the document this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastPagePos = null;
        /**
         * The last position on the screen this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastScreenPos = null;
        /**
         * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastWorldPos = null;
        /**
         * Returns the currently dragging target or null if it isn't exist
         */
        this.dragTarget = null;
        this.on('move', this._onPointerMove);
        this.on('down', this._onPointerDown);
        this.on('up', this._onPointerUp);
    }
    /**
     * Whether the Pointer is currently dragging.
     */
    get isDragging() {
        return this._isDown;
    }
    /**
     * Whether the Pointer just started dragging.
     */
    get isDragStart() {
        return !this._wasDown && this._isDown;
    }
    /**
     * Whether the Pointer just ended dragging.
     */
    get isDragEnd() {
        return this._wasDown && !this._isDown;
    }
    /**
     * Returns true if pointer has any actors under
     */
    get hasActorsUnderPointer() {
        return !!this._actorsUnderPointer.length;
    }
    on(event, handler) {
        super.on(event, handler);
    }
    once(event, handler) {
        super.once(event, handler);
    }
    off(event, handler) {
        super.off(event, handler);
    }
    /**
     * Update the state of current pointer, meant to be called a the end of frame
     */
    update() {
        if (this._wasDown && !this._isDown) {
            this._wasDown = false;
        }
        else if (!this._wasDown && this._isDown) {
            this._wasDown = true;
        }
        this._actorsLastFrame = [...this._actors];
        this._actorsNoLongerUnderPointer = [];
    }
    /**
     * Adds an Actor to actorsUnderPointer object.
     * @param actor An Actor to be added;
     */
    addActorUnderPointer(actor) {
        if (!this.isActorAliveUnderPointer(actor)) {
            this._actorsUnderPointer[actor.id] = actor;
            this._actorsUnderPointer.length += 1;
            this._actors.push(actor);
        }
        // Actors are processed in z-order highest z to lowest
        // ties are broken by id highest id (newest) to lowest id (oldest)
        this._actors.sort(this._actorSortingFcn);
    }
    /**
     * Removes an Actor from actorsUnderPointer object.
     * @param actor An Actor to be removed;
     */
    removeActorUnderPointer(actor) {
        if (this.isActorAliveUnderPointer(actor)) {
            delete this._actorsUnderPointer[actor.id];
            this._actorsUnderPointer.length -= 1;
            removeItemFromArray(actor, this._actors);
            this._actorsNoLongerUnderPointer.push(actor);
        }
    }
    /**
     * Returns all actors under this pointer this frame
     */
    getActorsUnderPointer() {
        return this._actors;
    }
    /**
     * Returns all actors that are no longer under the pointer this frame
     */
    getActorsUnderPointerLastFrame() {
        return this._actorsLastFrame;
    }
    /**
     * Returns all actors relevant for events to pointer this frame
     */
    getActorsForEvents() {
        return this._actors
            .concat(this._actorsLastFrame)
            .filter((actor, i, self) => {
            return self.indexOf(actor) === i; // de-dup
        })
            .sort(this._actorSortingFcn); // sort by z
    }
    /**
     * Checks if Pointer location has a specific Actor bounds contained underneath.
     * @param actor An Actor for check;
     */
    checkActorUnderPointer(actor) {
        if (this.lastWorldPos) {
            return actor.contains(this.lastWorldPos.x, this.lastWorldPos.y, !isScreenElement(actor));
        }
        return false;
    }
    /**
     * Checks if an actor was under the pointer last frame
     * @param actor
     */
    wasActorUnderPointer(actor) {
        return this._actorsLastFrame.indexOf(actor) > -1;
    }
    /**
     * Checks if Pointer has a specific Actor in ActorsUnderPointer list.
     * @param actor An Actor for check;
     */
    isActorAliveUnderPointer(actor) {
        return !!(!actor.isKilled() && actor.scene && this._actorsUnderPointer.hasOwnProperty(actor.id.toString()));
    }
    _onPointerMove(ev) {
        this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
        this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
        this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
    }
    _onPointerDown(ev) {
        this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
        this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
        this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
        this._isDown = true;
    }
    _onPointerUp(_ev) {
        this._isDown = false;
        this.dragTarget = null;
    }
}
Pointer._MAX_ID = 0;

;// CONCATENATED MODULE: ./Input/PointerEvents.ts

/**
 * Native browser button enumeration
 */
var NativePointerButton;
(function (NativePointerButton) {
    NativePointerButton[NativePointerButton["NoButton"] = -1] = "NoButton";
    NativePointerButton[NativePointerButton["Left"] = 0] = "Left";
    NativePointerButton[NativePointerButton["Middle"] = 1] = "Middle";
    NativePointerButton[NativePointerButton["Right"] = 2] = "Right";
    NativePointerButton[NativePointerButton["Unknown"] = 3] = "Unknown";
})(NativePointerButton || (NativePointerButton = {}));
/**
 * The mouse button being pressed.
 */
var PointerButton;
(function (PointerButton) {
    PointerButton["Left"] = "Left";
    PointerButton["Middle"] = "Middle";
    PointerButton["Right"] = "Right";
    PointerButton["Unknown"] = "Unknown";
    PointerButton["NoButton"] = "NoButton";
})(PointerButton || (PointerButton = {}));
var WheelDeltaMode;
(function (WheelDeltaMode) {
    WheelDeltaMode["Pixel"] = "Pixel";
    WheelDeltaMode["Line"] = "Line";
    WheelDeltaMode["Page"] = "Page";
})(WheelDeltaMode || (WheelDeltaMode = {}));
/**
 * Pointer events
 *
 * Represents a mouse, touch, or stylus event. See [[Pointers]] for more information on
 * handling pointer input.
 *
 * For mouse-based events, you can inspect [[PointerEvent.button]] to see what button was pressed.
 */
class PointerEvent extends GameEvent {
    /**
     * @param coordinates         The [[GlobalCoordinates]] of the event
     * @param pointer             The [[Pointer]] of the event
     * @param index               The index of the pointer (zero-based)
     * @param pointerType         The type of pointer
     * @param button              The button pressed (if [[PointerType.Mouse]])
     * @param ev                  The raw DOM event being handled
     */
    constructor(coordinates, pointer, index, pointerType, button, ev) {
        super();
        this.coordinates = coordinates;
        this.pointer = pointer;
        this.index = index;
        this.pointerType = pointerType;
        this.button = button;
        this.ev = ev;
        this._canceled = false;
    }
    get name() {
        return this._name;
    }
    /** The world coordinates of the event. */
    get worldPos() {
        return this.coordinates.worldPos.clone();
    }
    /** The page coordinates of the event. */
    get pagePos() {
        return this.coordinates.pagePos.clone();
    }
    /** The screen coordinates of the event. */
    get screenPos() {
        return this.coordinates.screenPos.clone();
    }
    get pos() {
        return this.coordinates.worldPos.clone();
    }
    /**
     * Cancels pointer event propogation, event will not be transmitted to any other actors
     */
    cancel() {
        this._canceled = true;
    }
    /**
     *
     * @returns If the event is canceled it will no longer be transmitted to any other actors
     */
    isCanceled() {
        return this._canceled;
    }
    propagate(actor) {
        this.doAction(actor);
        if (this.bubbles && !this.isCanceled() && actor.parent) {
            this.propagate(actor.parent); // TODO not true
        }
    }
    /**
     * Action, that calls when event happens
     */
    doAction(actor) {
        if (actor) {
            this._onActionStart(actor);
            actor.emit(this._name, this);
            this._onActionEnd(actor);
        }
    }
    _onActionStart(_actor) {
        // to be rewritten
    }
    _onActionEnd(_actor) {
        // to be rewritten
    }
}
class PointerEventFactory {
    constructor(_pointerEventType) {
        this._pointerEventType = _pointerEventType;
    }
    /**
     * Create specific PointerEvent
     */
    create(coordinates, pointer, index, pointerType, button, ev) {
        return new this._pointerEventType(coordinates, pointer, index, pointerType, button, ev);
    }
}
class PointerDragEvent extends PointerEvent {
}
class PointerUpEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerup';
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragEnd && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragend', this);
        }
    }
}
class PointerDownEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerdown';
    }
    _onActionEnd(actor) {
        if (this.pointer.isDragStart && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragstart', this);
        }
    }
}
class PointerMoveEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointermove';
        // private _onActorEnter(actor: Actor) {
        //   const pe = createPointerEventByName('enter', this.coordinates, this.pointer, this.index, this.pointerType, this.button, this.ev);
        //   pe.propagate(actor);
        //   this.pointer.addActorUnderPointer(actor);
        //   if (this.pointer.isDragging) {
        //     this.pointer.dragTarget = actor;
        //   }
        // }
        // private _onActorLeave(actor: Actor) {
        //   const pe = createPointerEventByName('leave', this.coordinates, this.pointer, this.index, this.pointerType, this.button, this.ev);
        //   pe.propagate(actor);
        //   this.pointer.removeActorUnderPointer(actor);
        // }
    }
    propagate(actor) {
        // If the actor was under the pointer last frame, but not this one it left
        // if (this.pointer.wasActorUnderPointer(actor) && !this.pointer.isActorUnderPointer(actor)) {
        //   this._onActorLeave(actor);
        //   return;
        // }
        if (this.pointer.isActorAliveUnderPointer(actor)) {
            this.doAction(actor);
            if (this.bubbles && !this.isCanceled() && actor.parent) {
                this.propagate(actor.parent); // TODO not true
            }
        }
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
        // In the case this is new
        // if (this.pointer.checkActorUnderPointer(actor) && !this.pointer.wasActorUnderPointer(actor)) {
        //   this._onActorEnter(actor);
        // }
        if (this.pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragmove', this);
        }
    }
}
class PointerEnterEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerenter';
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragenter', this);
        }
    }
}
class PointerLeaveEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerleave';
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragleave', this);
        }
    }
}
class PointerCancelEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointercancel';
    }
}
/**
 * Wheel Events
 *
 * Represents a mouse wheel event. See [[Pointers]] for more information on
 * handling point input.
 */
class WheelEvent extends GameEvent {
    /**
     * @param x            The `x` coordinate of the event (in world coordinates)
     * @param y            The `y` coordinate of the event (in world coordinates)
     * @param pageX        The `x` coordinate of the event (in document coordinates)
     * @param pageY        The `y` coordinate of the event (in document coordinates)
     * @param screenX      The `x` coordinate of the event (in screen coordinates)
     * @param screenY      The `y` coordinate of the event (in screen coordinates)
     * @param index        The index of the pointer (zero-based)
     * @param deltaX       The type of pointer
     * @param deltaY       The type of pointer
     * @param deltaZ       The type of pointer
     * @param deltaMode    The type of movement [[WheelDeltaMode]]
     * @param ev           The raw DOM event being handled
     */
    constructor(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
        super();
        this.x = x;
        this.y = y;
        this.pageX = pageX;
        this.pageY = pageY;
        this.screenX = screenX;
        this.screenY = screenY;
        this.index = index;
        this.deltaX = deltaX;
        this.deltaY = deltaY;
        this.deltaZ = deltaZ;
        this.deltaMode = deltaMode;
        this.ev = ev;
        this._isCanceled = false;
    }
    /**
     * Cancels pointer event propogation, event will not be transmitted to any other actors
     */
    cancel() {
        this._isCanceled = true;
    }
    /**
     *
     * @returns If the event is canceled it will no longer be transmitted to any other actors
     */
    isCanceled() {
        return this._isCanceled;
    }
}
/**
 *
 */
function createPointerEventByName(eventName, coordinates, pointer, index, pointerType, button, ev) {
    let factory;
    switch (eventName) {
        case 'up':
            factory = new PointerEventFactory(PointerUpEvent);
            break;
        case 'down':
            factory = new PointerEventFactory(PointerDownEvent);
            break;
        case 'move':
            factory = new PointerEventFactory(PointerMoveEvent);
            break;
        case 'cancel':
            factory = new PointerEventFactory(PointerCancelEvent);
            break;
        case 'enter':
            factory = new PointerEventFactory(PointerEnterEvent);
            break;
        case 'leave':
            factory = new PointerEventFactory(PointerLeaveEvent);
            break;
    }
    return factory.create(coordinates, pointer, index, pointerType, button, ev);
}

;// CONCATENATED MODULE: ./Math/global-coordinates.ts

class GlobalCoordinates {
    constructor(worldPos, pagePos, screenPos) {
        this.worldPos = worldPos;
        this.pagePos = pagePos;
        this.screenPos = screenPos;
    }
    static fromPagePosition(xOrPos, yOrEngine, engineOrUndefined) {
        let pageX;
        let pageY;
        let pagePos;
        let engine;
        if (arguments.length === 3) {
            pageX = xOrPos;
            pageY = yOrEngine;
            pagePos = new Vector(pageX, pageY);
            engine = engineOrUndefined;
        }
        else {
            pagePos = xOrPos;
            pageX = pagePos.x;
            pageY = pagePos.y;
            engine = yOrEngine;
        }
        const screenPos = engine.screen.pageToScreenCoordinates(pagePos);
        const worldPos = engine.screen.screenToWorldCoordinates(screenPos);
        return new GlobalCoordinates(worldPos, pagePos, screenPos);
    }
}

;// CONCATENATED MODULE: ./Input/Pointers.ts








/**
 * A constant used to normalize wheel events across different browsers
 *
 * This normalization factor is pulled from https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser
 */
const ScrollWheelNormalizationFactor = -1 / 40;
/**
 * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to
 * [W3C Pointer Events](http://www.w3.org/TR/pointerevents/).
 */
class Pointers extends Class {
    constructor(engine) {
        super();
        this._pointerDown = [];
        this._pointerUp = [];
        this._pointerMove = [];
        this._pointerCancel = [];
        this._wheel = [];
        this._pointers = [];
        this._activePointers = [];
        this._engine = engine;
        this._pointers.push(new Pointer());
        this._activePointers = [-1];
        this.primary = this._pointers[0];
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    /**
     * Initializes pointer event listeners
     */
    init(target) {
        target = target || this._engine.canvas;
        // Touch Events
        target.addEventListener('touchstart', this._handleTouchEvent('down', this._pointerDown));
        target.addEventListener('touchend', this._handleTouchEvent('up', this._pointerUp));
        target.addEventListener('touchmove', this._handleTouchEvent('move', this._pointerMove));
        target.addEventListener('touchcancel', this._handleTouchEvent('cancel', this._pointerCancel));
        // W3C Pointer Events
        // Current: IE11, IE10
        if (window.PointerEvent) {
            // IE11
            this._engine.canvas.style.touchAction = 'none';
            target.addEventListener('pointerdown', this._handlePointerEvent('down', this._pointerDown));
            target.addEventListener('pointerup', this._handlePointerEvent('up', this._pointerUp));
            target.addEventListener('pointermove', this._handlePointerEvent('move', this._pointerMove));
            target.addEventListener('pointercancel', this._handlePointerEvent('cancel', this._pointerCancel));
        }
        else if (window.MSPointerEvent) {
            // IE10
            this._engine.canvas.style.msTouchAction = 'none';
            target.addEventListener('MSPointerDown', this._handlePointerEvent('down', this._pointerDown));
            target.addEventListener('MSPointerUp', this._handlePointerEvent('up', this._pointerUp));
            target.addEventListener('MSPointerMove', this._handlePointerEvent('move', this._pointerMove));
            target.addEventListener('MSPointerCancel', this._handlePointerEvent('cancel', this._pointerCancel));
        }
        else {
            // Mouse Events
            target.addEventListener('mousedown', this._handleMouseEvent('down', this._pointerDown));
            target.addEventListener('mouseup', this._handleMouseEvent('up', this._pointerUp));
            target.addEventListener('mousemove', this._handleMouseEvent('move', this._pointerMove));
        }
        // MDN MouseWheelEvent
        const wheelOptions = {
            passive: !(this._engine.pageScrollPreventionMode === ScrollPreventionMode.All ||
                this._engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas)
        };
        if ('onwheel' in document.createElement('div')) {
            // Modern Browsers
            target.addEventListener('wheel', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
        else if (document.onmousewheel !== undefined) {
            // Webkit and IE
            target.addEventListener('mousewheel', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
        else {
            // Remaining browser and older Firefox
            target.addEventListener('MozMousePixelScroll', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
    }
    /**
     * Synthesize a pointer event that looks like a real browser event to excalibur
     * @param eventName
     * @param pos
     */
    triggerEvent(eventName, pos, button = NativePointerButton.Left, pointerType = 'mouse', pointerId = 0) {
        let x = 0;
        let y = 0;
        let coords;
        if (pos instanceof GlobalCoordinates) {
            x = pos.pagePos.x;
            y = pos.pagePos.y;
            coords = pos;
        }
        else {
            x = pos.x;
            y = pos.y;
            coords = new GlobalCoordinates(pos.clone(), pos.clone(), pos.clone());
        }
        const eventish = {
            pageX: x,
            pageY: y,
            pointerId: pointerId,
            pointerType: pointerType,
            button: button,
            preventDefault: () => {
                /* do nothing */
            }
        };
        switch (eventName) {
            case 'move':
                this._handlePointerEvent(eventName, this._pointerMove, coords)(eventish);
                break;
            case 'down':
                this._handlePointerEvent(eventName, this._pointerDown, coords)(eventish);
                break;
            case 'up':
                this._handlePointerEvent(eventName, this._pointerUp, coords)(eventish);
                break;
            case 'cancel':
                this._handlePointerEvent(eventName, this._pointerCancel, coords)(eventish);
                break;
        }
        for (const actor of this._engine.currentScene.actors) {
            const capturePointer = actor.traits.filter((t) => t instanceof CapturePointer)[0];
            if (capturePointer) {
                capturePointer.update(actor, this._engine, 1);
            }
        }
        this.dispatchPointerEvents();
        this.update();
    }
    /**
     * Update all pointer events and pointers, meant to be called at the end of frame
     */
    update() {
        this._pointerUp.length = 0;
        this._pointerDown.length = 0;
        this._pointerMove.length = 0;
        this._pointerCancel.length = 0;
        this._wheel.length = 0;
        for (let i = 0; i < this._pointers.length; i++) {
            this._pointers[i].update();
        }
    }
    /**
     * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
     * @param index  The pointer index to retrieve
     */
    at(index) {
        if (index >= this._pointers.length) {
            // Ensure there is a pointer to retrieve
            for (let i = this._pointers.length - 1, max = index; i < max; i++) {
                this._pointers.push(new Pointer());
                this._activePointers.push(-1);
            }
        }
        return this._pointers[index];
    }
    /**
     * Get number of pointers being watched
     */
    count() {
        return this._pointers.length;
    }
    checkAndUpdateActorUnderPointer(actor) {
        for (const pointer of this._pointers) {
            if (pointer.checkActorUnderPointer(actor)) {
                pointer.addActorUnderPointer(actor);
            }
            else {
                pointer.removeActorUnderPointer(actor);
            }
        }
    }
    _dispatchWithBubble(events) {
        for (const evt of events) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                if (!evt.isCanceled()) {
                    evt.propagate(actor);
                }
                if (!evt.bubbles || evt.isCanceled()) {
                    // if the event stops bubbling part way stop processing
                    break;
                }
            }
        }
    }
    _dispatchPointerLeaveEvents() {
        const lastMoveEventPerPointerPerActor = {};
        const pointerLeave = [];
        for (const evt of this._pointerMove) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                // If the actor was under the pointer last frame, but not this this frame, pointer left
                if (!lastMoveEventPerPointerPerActor[evt.pointer.id + '+' + actor.id] &&
                    evt.pointer.wasActorUnderPointer(actor) &&
                    !evt.pointer.isActorAliveUnderPointer(actor) &&
                    !evt.isCanceled()) {
                    lastMoveEventPerPointerPerActor[evt.pointer.id + '+' + actor.id] = evt;
                    const pe = createPointerEventByName('leave', new GlobalCoordinates(evt.worldPos, evt.pagePos, evt.screenPos), evt.pointer, evt.index, evt.pointerType, evt.button, evt.ev);
                    pe.propagate(actor);
                    pointerLeave.push(pe);
                }
            }
        }
        return pointerLeave;
    }
    _dispatchPointerEnterEvents() {
        const lastMoveEventPerPointer = {};
        const pointerEnter = [];
        for (const evt of this._pointerMove) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                // If the actor was not under the pointer last frame, but it is this frame, pointer entered
                if (!lastMoveEventPerPointer[evt.pointer.id] &&
                    !evt.pointer.wasActorUnderPointer(actor) &&
                    evt.pointer.isActorAliveUnderPointer(actor) &&
                    !evt.isCanceled()) {
                    lastMoveEventPerPointer[evt.pointer.id] = evt;
                    const pe = createPointerEventByName('enter', new GlobalCoordinates(evt.worldPos, evt.pagePos, evt.screenPos), evt.pointer, evt.index, evt.pointerType, evt.button, evt.ev);
                    pe.propagate(actor);
                    pointerEnter.push(pe);
                    // if pointer is dragging set the drag target
                    if (evt.pointer.isDragging) {
                        evt.pointer.dragTarget = actor;
                    }
                }
            }
        }
        return pointerEnter;
    }
    dispatchPointerEvents() {
        this._dispatchWithBubble(this._pointerDown);
        this._dispatchWithBubble(this._pointerUp);
        this._dispatchWithBubble(this._pointerMove);
        this._dispatchPointerLeaveEvents();
        this._dispatchPointerEnterEvents();
        this._dispatchWithBubble(this._pointerCancel);
        // TODO some duplication here
        for (const evt of this._wheel) {
            for (const actor of this._pointers[evt.index].getActorsUnderPointer()) {
                this._propagateWheelPointerEvent(actor, evt);
                if (!evt.bubbles || evt.isCanceled()) {
                    // if the event stops bubbling part way stop processing
                    break;
                }
            }
        }
    }
    _propagateWheelPointerEvent(actor, wheelEvent) {
        actor.emit('pointerwheel', wheelEvent);
        // Recurse and propagate
        if (wheelEvent.bubbles && !wheelEvent.isCanceled() && actor.parent) {
            this._propagateWheelPointerEvent(actor.parent, wheelEvent); // TODO not true
        }
    }
    _handleMouseEvent(eventName, eventArr) {
        return (e) => {
            e.preventDefault();
            const pointer = this.at(0);
            const coordinates = GlobalCoordinates.fromPagePosition(e.pageX, e.pageY, this._engine);
            const pe = createPointerEventByName(eventName, coordinates, pointer, 0, PointerType.Mouse, this._nativeButtonToPointerButton(e.button), e);
            eventArr.push(pe);
            pointer.eventDispatcher.emit(eventName, pe);
        };
    }
    _handleTouchEvent(eventName, eventArr) {
        return (e) => {
            e.preventDefault();
            for (let i = 0, len = e.changedTouches.length; i < len; i++) {
                const index = this._pointers.length > 1 ? this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                if (index === -1) {
                    continue;
                }
                const pointer = this.at(index);
                const coordinates = GlobalCoordinates.fromPagePosition(e.changedTouches[i].pageX, e.changedTouches[i].pageY, this._engine);
                const pe = createPointerEventByName(eventName, coordinates, pointer, index, PointerType.Touch, PointerButton.Unknown, e);
                eventArr.push(pe);
                pointer.eventDispatcher.emit(eventName, pe);
                this.emit(eventName, pe);
                // only with multi-pointer
                if (this._pointers.length > 1) {
                    if (eventName === 'up') {
                        // remove pointer ID from pool when pointer is lifted
                        this._activePointers[index] = -1;
                    }
                    else if (eventName === 'down') {
                        // set pointer ID to given index
                        this._activePointers[index] = e.changedTouches[i].identifier;
                    }
                }
            }
        };
    }
    _handlePointerEvent(eventName, eventArr, coords) {
        return (e) => {
            e.preventDefault();
            // get the index for this pointer ID if multi-pointer is asked for
            const index = this._pointers.length > 1 ? this._getPointerIndex(e.pointerId) : 0;
            if (index === -1) {
                return;
            }
            const pointer = this.at(index);
            const coordinates = coords || GlobalCoordinates.fromPagePosition(e.pageX, e.pageY, this._engine);
            const pe = createPointerEventByName(eventName, coordinates, pointer, index, this._stringToPointerType(e.pointerType), this._nativeButtonToPointerButton(e.button), e);
            eventArr.push(pe);
            pointer.eventDispatcher.emit(eventName, pe);
            this.emit(eventName, pe);
            // only with multi-pointer
            if (this._pointers.length > 1) {
                if (eventName === 'up') {
                    // remove pointer ID from pool when pointer is lifted
                    this._activePointers[index] = -1;
                }
                else if (eventName === 'down') {
                    // set pointer ID to given index
                    this._activePointers[index] = e.pointerId;
                }
            }
        };
    }
    _handleWheelEvent(eventName, eventArr) {
        return (e) => {
            // Should we prevent page scroll because of this event
            if (this._engine.pageScrollPreventionMode === ScrollPreventionMode.All ||
                (this._engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && e.target === this._engine.canvas)) {
                e.preventDefault();
            }
            const screen = this._engine.screen.pageToScreenCoordinates(vec(e.pageX, e.pageY));
            const world = this._engine.screen.screenToWorldCoordinates(screen);
            // deltaX, deltaY, and deltaZ are the standard modern properties
            // wheelDeltaX, wheelDeltaY, are legacy properties in webkit browsers and older IE
            // e.detail is only used in opera
            const deltaX = e.deltaX || e.wheelDeltaX * ScrollWheelNormalizationFactor || 0;
            const deltaY = e.deltaY || e.wheelDeltaY * ScrollWheelNormalizationFactor || e.wheelDelta * ScrollWheelNormalizationFactor || e.detail || 0;
            const deltaZ = e.deltaZ || 0;
            let deltaMode = WheelDeltaMode.Pixel;
            if (e.deltaMode) {
                if (e.deltaMode === 1) {
                    deltaMode = WheelDeltaMode.Line;
                }
                else if (e.deltaMode === 2) {
                    deltaMode = WheelDeltaMode.Page;
                }
            }
            const we = new WheelEvent(world.x, world.y, e.pageX, e.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, e);
            eventArr.push(we);
            this.at(0).eventDispatcher.emit(eventName, we);
            this.emit(eventName, we);
        };
    }
    /**
     * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
     * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
     */
    _getPointerIndex(pointerId) {
        let idx;
        if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
            return idx;
        }
        for (let i = 0; i < this._activePointers.length; i++) {
            if (this._activePointers[i] === -1) {
                return i;
            }
        }
        // ignore pointer because game isn't watching
        return -1;
    }
    _nativeButtonToPointerButton(s) {
        switch (s) {
            case NativePointerButton.NoButton:
                return PointerButton.NoButton;
            case NativePointerButton.Left:
                return PointerButton.Left;
            case NativePointerButton.Middle:
                return PointerButton.Middle;
            case NativePointerButton.Right:
                return PointerButton.Right;
            case NativePointerButton.Unknown:
                return PointerButton.Unknown;
            default:
                return fail(s);
        }
    }
    _stringToPointerType(s) {
        switch (s) {
            case 'touch':
                return PointerType.Touch;
            case 'mouse':
                return PointerType.Mouse;
            case 'pen':
                return PointerType.Pen;
            default:
                return PointerType.Unknown;
        }
    }
}

;// CONCATENATED MODULE: ./Input/Gamepad.ts


/**
 * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)
 * to provide controller support for your games.
 */
class Gamepads extends Class {
    constructor() {
        super();
        /**
         * Whether or not to poll for Gamepad input (default: `false`)
         */
        this.enabled = false;
        /**
         * Whether or not Gamepad API is supported
         */
        this.supported = !!navigator.getGamepads;
        this._gamePadTimeStamps = [0, 0, 0, 0];
        this._oldPads = [];
        this._pads = [];
        this._initSuccess = false;
        this._navigator = navigator;
        this._minimumConfiguration = null;
    }
    init() {
        if (!this.supported) {
            return;
        }
        if (this._initSuccess) {
            return;
        }
        // In Chrome, this will return 4 undefined items until a button is pressed
        // In FF, this will not return any items until a button is pressed
        this._oldPads = this._clonePads(this._navigator.getGamepads());
        if (this._oldPads.length && this._oldPads[0]) {
            this._initSuccess = true;
        }
    }
    /**
     * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
     * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
     * all other controllers with more axis or buttons are valid as well. If no minimum
     * configuration is set all pads are valid.
     */
    setMinimumGamepadConfiguration(config) {
        this._enableAndUpdate(); // if config is used, implicitly enable
        this._minimumConfiguration = config;
    }
    /**
     * When implicitly enabled, set the enabled flag and run an update so information is updated
     */
    _enableAndUpdate() {
        if (!this.enabled) {
            this.enabled = true;
            this.update();
        }
    }
    /**
     * Checks a navigator gamepad against the minimum configuration if present.
     */
    _isGamepadValid(pad) {
        if (!this._minimumConfiguration) {
            return true;
        }
        if (!pad) {
            return false;
        }
        const axesLength = pad.axes.filter((value) => {
            return typeof value !== undefined;
        }).length;
        const buttonLength = pad.buttons.filter((value) => {
            return typeof value !== undefined;
        }).length;
        return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;
    }
    on(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.off(eventName, handler);
    }
    /**
     * Updates Gamepad state and publishes Gamepad events
     */
    update() {
        if (!this.enabled || !this.supported) {
            return;
        }
        this.init();
        const gamepads = this._navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (!gamepads[i]) {
                const gamepad = this.at(i);
                // If was connected, but now isn't emit the disconnect event
                if (gamepad.connected) {
                    this.eventDispatcher.emit('disconnect', new GamepadDisconnectEvent(i, gamepad));
                }
                // Reset connection status
                gamepad.connected = false;
                continue;
            }
            else {
                if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
                    this.eventDispatcher.emit('connect', new GamepadConnectEvent(i, this.at(i)));
                }
                // Set connection status
                this.at(i).connected = true;
            }
            // Only supported in Chrome
            if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                continue;
            }
            this._gamePadTimeStamps[i] = gamepads[i].timestamp;
            // Add reference to navigator gamepad
            this.at(i).navigatorGamepad = gamepads[i];
            // Buttons
            let b, bi, a, ai, value;
            for (b in Buttons) {
                bi = Buttons[b];
                if (typeof bi === 'number') {
                    if (gamepads[i].buttons[bi]) {
                        value = gamepads[i].buttons[bi].value;
                        if (value !== this._oldPads[i].getButton(bi)) {
                            if (gamepads[i].buttons[bi].pressed) {
                                this.at(i).updateButton(bi, value);
                                this.at(i).eventDispatcher.emit('button', new GamepadButtonEvent(bi, value, this.at(i)));
                            }
                            else {
                                this.at(i).updateButton(bi, 0);
                            }
                        }
                    }
                }
            }
            // Axes
            for (a in Axes) {
                ai = Axes[a];
                if (typeof ai === 'number') {
                    value = gamepads[i].axes[ai];
                    if (value !== this._oldPads[i].getAxes(ai)) {
                        this.at(i).updateAxes(ai, value);
                        this.at(i).eventDispatcher.emit('axis', new GamepadAxisEvent(ai, value, this.at(i)));
                    }
                }
            }
            this._oldPads[i] = this._clonePad(gamepads[i]);
        }
    }
    /**
     * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
     */
    at(index) {
        this._enableAndUpdate(); // implicitly enable gamepads when at() is called
        if (index >= this._pads.length) {
            // Ensure there is a pad to retrieve
            for (let i = this._pads.length - 1, max = index; i < max; i++) {
                this._pads.push(new Gamepad());
                this._oldPads.push(new Gamepad());
            }
        }
        return this._pads[index];
    }
    /**
     * Returns a list of all valid gamepads that meet the minimum configuration requirement.
     */
    getValidGamepads() {
        this._enableAndUpdate();
        const result = [];
        for (let i = 0; i < this._pads.length; i++) {
            if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
                result.push(this.at(i));
            }
        }
        return result;
    }
    /**
     * Gets the number of connected gamepads
     */
    count() {
        return this._pads.filter((p) => p.connected).length;
    }
    _clonePads(pads) {
        const arr = [];
        for (let i = 0, len = pads.length; i < len; i++) {
            arr.push(this._clonePad(pads[i]));
        }
        return arr;
    }
    /**
     * Fastest way to clone a known object is to do it yourself
     */
    _clonePad(pad) {
        let i, len;
        const clonedPad = new Gamepad();
        if (!pad) {
            return clonedPad;
        }
        for (i = 0, len = pad.buttons.length; i < len; i++) {
            if (pad.buttons[i]) {
                clonedPad.updateButton(i, pad.buttons[i].value);
            }
        }
        for (i = 0, len = pad.axes.length; i < len; i++) {
            clonedPad.updateAxes(i, pad.axes[i]);
        }
        return clonedPad;
    }
}
/**
 * The minimum value an axis has to move before considering it a change
 */
Gamepads.MinAxisMoveThreshold = 0.05;
/**
 * Gamepad holds state information for a connected controller. See [[Gamepads]]
 * for more information on handling controller input.
 */
class Gamepad extends Class {
    constructor() {
        super();
        this.connected = false;
        this._buttons = new Array(16);
        this._axes = new Array(4);
        for (let i = 0; i < this._buttons.length; i++) {
            this._buttons[i] = 0;
        }
        for (let i = 0; i < this._axes.length; i++) {
            this._axes[i] = 0;
        }
    }
    /**
     * Whether or not the given button is pressed
     * @param button     The button to query
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    isButtonPressed(button, threshold = 1) {
        return this._buttons[button] >= threshold;
    }
    /**
     * Gets the given button value between 0 and 1
     */
    getButton(button) {
        return this._buttons[button];
    }
    /**
     * Gets the given axis value between -1 and 1. Values below
     * [[MinAxisMoveThreshold]] are considered 0.
     */
    getAxes(axes) {
        const value = this._axes[axes];
        if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
            return 0;
        }
        else {
            return value;
        }
    }
    updateButton(buttonIndex, value) {
        this._buttons[buttonIndex] = value;
    }
    updateAxes(axesIndex, value) {
        this._axes[axesIndex] = value;
    }
}
/**
 * Gamepad Buttons enumeration
 */
var Buttons;
(function (Buttons) {
    /**
     * Face 1 button (e.g. A)
     */
    Buttons[Buttons["Face1"] = 0] = "Face1";
    /**
     * Face 2 button (e.g. B)
     */
    Buttons[Buttons["Face2"] = 1] = "Face2";
    /**
     * Face 3 button (e.g. X)
     */
    Buttons[Buttons["Face3"] = 2] = "Face3";
    /**
     * Face 4 button (e.g. Y)
     */
    Buttons[Buttons["Face4"] = 3] = "Face4";
    /**
     * Left bumper button
     */
    Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
    /**
     * Right bumper button
     */
    Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
    /**
     * Left trigger button
     */
    Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
    /**
     * Right trigger button
     */
    Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
    /**
     * Select button
     */
    Buttons[Buttons["Select"] = 8] = "Select";
    /**
     * Start button
     */
    Buttons[Buttons["Start"] = 9] = "Start";
    /**
     * Left analog stick press (e.g. L3)
     */
    Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
    /**
     * Right analog stick press (e.g. R3)
     */
    Buttons[Buttons["RightStick"] = 11] = "RightStick";
    /**
     * D-pad up
     */
    Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
    /**
     * D-pad down
     */
    Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
    /**
     * D-pad left
     */
    Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
    /**
     * D-pad right
     */
    Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
})(Buttons || (Buttons = {}));
/**
 * Gamepad Axes enumeration
 */
var Axes;
(function (Axes) {
    /**
     * Left analogue stick X direction
     */
    Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
    /**
     * Left analogue stick Y direction
     */
    Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
    /**
     * Right analogue stick X direction
     */
    Axes[Axes["RightStickX"] = 2] = "RightStickX";
    /**
     * Right analogue stick Y direction
     */
    Axes[Axes["RightStickY"] = 3] = "RightStickY";
})(Axes || (Axes = {}));

;// CONCATENATED MODULE: ./Util/Browser.ts
class BrowserComponent {
    constructor(nativeComponent) {
        this.nativeComponent = nativeComponent;
        this._paused = false;
        this._nativeHandlers = {};
    }
    on(eventName, handler) {
        if (this._nativeHandlers[eventName]) {
            this.off(eventName, this._nativeHandlers[eventName]);
        }
        this._nativeHandlers[eventName] = this._decorate(handler);
        this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);
    }
    off(eventName, handler) {
        if (!handler) {
            handler = this._nativeHandlers[eventName];
        }
        this.nativeComponent.removeEventListener(eventName, handler);
        this._nativeHandlers[eventName] = null;
    }
    _decorate(handler) {
        return (evt) => {
            if (!this._paused) {
                handler(evt);
            }
        };
    }
    pause() {
        this._paused = true;
    }
    resume() {
        this._paused = false;
    }
    clear() {
        for (const event in this._nativeHandlers) {
            this.off(event);
        }
    }
}
class BrowserEvents {
    constructor(_windowGlobal, _documentGlobal) {
        this._windowGlobal = _windowGlobal;
        this._documentGlobal = _documentGlobal;
        this._windowComponent = new BrowserComponent(this._windowGlobal);
        this._documentComponent = new BrowserComponent(this._documentGlobal);
    }
    get window() {
        return this._windowComponent;
    }
    get document() {
        return this._documentComponent;
    }
    pause() {
        this.window.pause();
        this.document.pause();
    }
    resume() {
        this.window.resume();
        this.document.resume();
    }
    clear() {
        this.window.clear();
        this.document.clear();
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts




class ExcaliburGraphicsContext2DCanvasDebug {
    constructor(_ex) {
        this._ex = _ex;
        this._debugText = new DebugText();
    }
    /**
     * Draw a debug rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height) {
        this._ex.__ctx.save();
        this._ex.__ctx.strokeStyle = 'red';
        this._ex.__ctx.strokeRect(this._ex.snapToPixel ? ~~x : x, this._ex.snapToPixel ? ~~y : y, this._ex.snapToPixel ? ~~width : width, this._ex.snapToPixel ? ~~height : height);
        this._ex.__ctx.restore();
    }
    drawLine(start, end, lineOptions = { color: Color.Black }) {
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.strokeStyle = lineOptions.color.toString();
        this._ex.__ctx.moveTo(this._ex.snapToPixel ? ~~start.x : start.x, this._ex.snapToPixel ? ~~start.y : start.y);
        this._ex.__ctx.lineTo(this._ex.snapToPixel ? ~~end.x : end.x, this._ex.snapToPixel ? ~~end.y : end.y);
        this._ex.__ctx.lineWidth = 2;
        this._ex.__ctx.stroke();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.fillStyle = pointOptions.color.toString();
        this._ex.__ctx.arc(this._ex.snapToPixel ? ~~point.x : point.x, this._ex.snapToPixel ? ~~point.y : point.y, pointOptions.size, 0, Math.PI * 2);
        this._ex.__ctx.fill();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawText(text, pos) {
        this._debugText.write(this._ex, text, pos);
    }
}
class ExcaliburGraphicsContext2DCanvas {
    constructor(options) {
        this.backgroundColor = Color.ExcaliburBlue;
        this._state = new StateStack();
        this.snapToPixel = true;
        this.debug = new ExcaliburGraphicsContext2DCanvasDebug(this);
        const { canvasElement, enableTransparency, snapToPixel, smoothing, backgroundColor } = options;
        this.__ctx = canvasElement.getContext('2d', {
            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true
        });
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
    }
    get width() {
        return this.__ctx.canvas.width;
    }
    get height() {
        return this.__ctx.canvas.height;
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get smoothing() {
        return this.__ctx.imageSmoothingEnabled;
    }
    set smoothing(value) {
        this.__ctx.imageSmoothingEnabled = value;
    }
    resetTransform() {
        this.__ctx.resetTransform();
    }
    updateViewport() {
        // pass
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (image.width === 0 || image.height === 0) {
            return; // zero dimension source exit early
        }
        this.__ctx.globalAlpha = this.opacity;
        const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight]
            .filter((a) => a !== undefined)
            .map((a) => (typeof a === 'number' && this.snapToPixel ? ~~a : a));
        this.__ctx.drawImage.apply(this.__ctx, args);
        GraphicsDiagnostics.DrawCallCount++;
        GraphicsDiagnostics.DrawnImagesCount = 1;
    }
    drawLine(start, end, color, thickness = 1) {
        this.__ctx.save();
        this.__ctx.beginPath();
        this.__ctx.strokeStyle = color.toString();
        this.__ctx.moveTo(this.snapToPixel ? ~~start.x : start.x, this.snapToPixel ? ~~start.y : start.y);
        this.__ctx.lineTo(this.snapToPixel ? ~~end.x : end.x, this.snapToPixel ? ~~end.y : end.y);
        this.__ctx.lineWidth = thickness;
        this.__ctx.stroke();
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    drawRectangle(pos, width, height, color) {
        this.__ctx.save();
        this.__ctx.fillStyle = color.toString();
        this.__ctx.fillRect(this.snapToPixel ? ~~pos.x : pos.x, this.snapToPixel ? ~~pos.y : pos.y, this.snapToPixel ? ~~width : width, this.snapToPixel ? ~~height : height);
        this.__ctx.restore();
    }
    drawCircle(pos, radius, color) {
        this.__ctx.save();
        this.__ctx.beginPath();
        this.__ctx.fillStyle = color.toString();
        this.__ctx.arc(this.snapToPixel ? ~~pos.x : pos.x, this.snapToPixel ? ~~pos.y : pos.y, radius, 0, Math.PI * 2);
        this.__ctx.fill();
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    /**
     * Save the current state of the canvas to the stack (transforms and opacity)
     */
    save() {
        this.__ctx.save();
    }
    /**
     * Restore the state of the canvas from the stack
     */
    restore() {
        this.__ctx.restore();
    }
    /**
     * Translate the origin of the context by an x and y
     * @param x
     * @param y
     */
    translate(x, y) {
        this.__ctx.translate(this.snapToPixel ? ~~x : x, this.snapToPixel ? ~~y : y);
    }
    /**
     * Rotate the context about the current origin
     */
    rotate(angle) {
        this.__ctx.rotate(angle);
    }
    /**
     * Scale the context by an x and y factor
     * @param x
     * @param y
     */
    scale(x, y) {
        this.__ctx.scale(x, y);
    }
    clear() {
        // Clear frame
        this.__ctx.clearRect(0, 0, this.width, this.height);
        this.__ctx.fillStyle = this.backgroundColor.toString();
        this.__ctx.fillRect(0, 0, this.width, this.height);
        GraphicsDiagnostics.clear();
    }
    /**
     * Flushes the batched draw calls to the screen
     */
    flush() {
        // pass
    }
}

;// CONCATENATED MODULE: ./Engine.ts
var Engine_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



polyfill();














/**
 * Enum representing the different mousewheel event bubble prevention
 */
var ScrollPreventionMode;
(function (ScrollPreventionMode) {
    /**
     * Do not prevent any page scrolling
     */
    ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";
    /**
     * Prevent page scroll if mouse is over the game canvas
     */
    ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";
    /**
     * Prevent all page scrolling via mouse wheel
     */
    ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";
})(ScrollPreventionMode || (ScrollPreventionMode = {}));
/**
 * The Excalibur Engine
 *
 * The [[Engine]] is the main driver for a game. It is responsible for
 * starting/stopping the game, maintaining state, transmitting events,
 * loading resources, and managing the scene.
 */
class Engine extends Class {
    /**
     * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,
     * the game will be rendered full screen (taking up all available browser window space).
     * You can customize the game rendering through [[EngineOptions]].
     *
     * Example:
     *
     * ```js
     * var game = new ex.Engine({
     *   width: 0, // the width of the canvas
     *   height: 0, // the height of the canvas
     *   enableCanvasTransparency: true, // the transparencySection of the canvas
     *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
     *   displayMode: ex.DisplayMode.FullScreen, // the display mode
     *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
     *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
     * });
     *
     * // call game.start, which is a Promise
     * game.start().then(function () {
     *   // ready, set, go!
     * });
     * ```
     */
    constructor(options) {
        var _a, _b, _c;
        super();
        this._hasStarted = false;
        /**
         * Gets or sets the list of post processors to apply at the end of drawing a frame (such as [[ColorBlindCorrector]])
         */
        this.postProcessors = [];
        /**
         * Contains all the scenes currently registered with Excalibur
         */
        this.scenes = {};
        /**
         * @hidden
         * @deprecated
         */
        this._animations = [];
        this._suppressPlayButton = false;
        /**
         * Indicates whether audio should be paused when the game is no longer visible.
         */
        this.pauseAudioWhenHidden = true;
        /**
         * Indicates whether the engine should draw with debug information
         */
        this._isDebug = false;
        this.debugColor = new Color(255, 255, 255);
        /**
         * Sets the Transparency for the engine.
         */
        this.enableCanvasTransparency = true;
        /**
         * The action to take when a fatal exception is thrown
         */
        this.onFatalException = (e) => {
            Logger.getInstance().fatal(e);
        };
        this._timescale = 1.0;
        this._isLoading = false;
        this._isInitialized = false;
        this._deferredGoTo = null;
        this._loadingComplete = false;
        options = Object.assign(Object.assign({}, Engine._DEFAULT_ENGINE_OPTIONS), options);
        Flags.freeze();
        // Initialize browser events facade
        this.browser = new BrowserEvents(window, document);
        // Check compatibility
        const detector = new Detector();
        if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {
            const message = document.createElement('div');
            message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';
            document.body.appendChild(message);
            detector.failedTests.forEach(function (test) {
                const testMessage = document.createElement('div');
                testMessage.innerText = 'Browser feature missing ' + test;
                document.body.appendChild(testMessage);
            });
            if (options.canvasElementId) {
                const canvas = document.getElementById(options.canvasElementId);
                if (canvas) {
                    canvas.parentElement.removeChild(canvas);
                }
            }
            return;
        }
        else {
            this._compatible = true;
        }
        // Use native console API for color fun
        // eslint-disable-next-line no-console
        if (console.log && !options.suppressConsoleBootMessage) {
            // eslint-disable-next-line no-console
            console.log(`%cPowered by Excalibur.js (v${EX_VERSION})`, 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');
            // eslint-disable-next-line no-console
            console.log('\n\
      /| ________________\n\
O|===|* >________________>\n\
      \\|');
            // eslint-disable-next-line no-console
            console.log('Visit', 'http://excaliburjs.com', 'for more information');
        }
        // Suppress play button
        if (options.suppressPlayButton) {
            this._suppressPlayButton = true;
        }
        this._logger = Logger.getInstance();
        // If debug is enabled, let's log browser features to the console.
        if (this._logger.defaultLevel === LogLevel.Debug) {
            detector.logBrowserFeatures();
        }
        this._logger.debug('Building engine...');
        this.canvasElementId = options.canvasElementId;
        if (options.canvasElementId) {
            this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);
            this.canvas = document.getElementById(options.canvasElementId);
        }
        else if (options.canvasElement) {
            this._logger.debug('Using Canvas element specified:', options.canvasElement);
            this.canvas = options.canvasElement;
        }
        else {
            this._logger.debug('Using generated canvas element');
            this.canvas = document.createElement('canvas');
        }
        let displayMode = (_a = options.displayMode) !== null && _a !== void 0 ? _a : DisplayMode.Fixed;
        if ((options.width && options.height) || options.viewport) {
            if (options.displayMode === undefined) {
                displayMode = DisplayMode.Fixed;
            }
            this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);
        }
        else if (!options.displayMode) {
            this._logger.debug('Engine viewport is fit');
            displayMode = DisplayMode.FitScreen;
        }
        if (Flags.isEnabled(Legacy.Canvas)) {
            const ex2dCtx = new ExcaliburGraphicsContext2DCanvas({
                canvasElement: this.canvas,
                enableTransparency: this.enableCanvasTransparency,
                smoothing: options.antialiasing,
                backgroundColor: options.backgroundColor,
                snapToPixel: options.snapToPixel
            });
            this.graphicsContext = ex2dCtx;
            this.ctx = ex2dCtx.__ctx;
        }
        else {
            const exWebglCtx = new ExcaliburGraphicsContextWebGL({
                canvasElement: this.canvas,
                enableTransparency: this.enableCanvasTransparency,
                smoothing: options.antialiasing,
                backgroundColor: options.backgroundColor,
                snapToPixel: options.snapToPixel
            });
            this.graphicsContext = exWebglCtx;
            this.ctx = exWebglCtx.__ctx;
        }
        this.screen = new Screen({
            canvas: this.canvas,
            context: this.graphicsContext,
            antialiasing: (_b = options.antialiasing) !== null && _b !== void 0 ? _b : true,
            browser: this.browser,
            viewport: (_c = options.viewport) !== null && _c !== void 0 ? _c : (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),
            resolution: options.resolution,
            displayMode,
            position: options.position,
            pixelRatio: options.suppressHiDPIScaling ? 1 : null
        });
        if (options.backgroundColor) {
            this.backgroundColor = options.backgroundColor.clone();
        }
        this.enableCanvasTransparency = options.enableCanvasTransparency;
        this._loader = new Loader();
        this.debug = new Debug(this);
        this._initialize(options);
        this.rootScene = this.currentScene = new Scene();
        this.addScene('root', this.rootScene);
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.screen.canvasWidth;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.screen.halfCanvasWidth;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.screen.canvasHeight;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.screen.halfCanvasHeight;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        return this.screen.drawWidth;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.screen.halfDrawWidth;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        return this.screen.drawHeight;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.screen.halfDrawHeight;
    }
    /**
     * Returns whether excalibur detects the current screen to be HiDPI
     */
    get isHiDpi() {
        return this.screen.isHiDpi;
    }
    /**
     * Access [[stats]] that holds frame statistics.
     */
    get stats() {
        return this.debug.stats;
    }
    /**
     * Indicates whether the engine is set to fullscreen or not
     */
    get isFullscreen() {
        return this.screen.isFullScreen;
    }
    /**
     * Indicates the current [[DisplayMode]] of the engine.
     */
    get displayMode() {
        return this.screen.displayMode;
    }
    /**
     * Returns the calculated pixel ration for use in rendering
     */
    get pixelRatio() {
        return this.screen.pixelRatio;
    }
    get isDebug() {
        return this._isDebug;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     */
    getWorldBounds() {
        return this.screen.getWorldBounds();
    }
    /**
     * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
     */
    get timescale() {
        return this._timescale;
    }
    /**
     * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
     * when using time-based movement.
     */
    set timescale(value) {
        if (value <= 0) {
            Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');
            return;
        }
        this._timescale = value;
    }
    /**
     * Plays a sprite animation on the screen at the specified `x` and `y`
     * (in game coordinates, not screen pixels). These animations play
     * independent of actors, and will be cleaned up internally as soon
     * as they are complete. Note animations that loop will never be
     * cleaned up.
     *
     * @param animation  Animation to play
     * @param x          x game coordinate to play the animation
     * @param y          y game coordinate to play the animation
     * @deprecated
     */
    playAnimation(animation, x, y) {
        this._animations.push(new AnimationNode(animation, x, y));
    }
    /**
     * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap
     * will be drawn and updated.
     */
    addTileMap(tileMap) {
        this.currentScene.addTileMap(tileMap);
    }
    /**
     * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.
     */
    removeTileMap(tileMap) {
        this.currentScene.removeTileMap(tileMap);
    }
    /**
     * Adds a [[Timer]] to the [[currentScene]].
     * @param timer  The timer to add to the [[currentScene]].
     */
    addTimer(timer) {
        return this.currentScene.addTimer(timer);
    }
    /**
     * Removes a [[Timer]] from the [[currentScene]].
     * @param timer  The timer to remove to the [[currentScene]].
     */
    removeTimer(timer) {
        return this.currentScene.removeTimer(timer);
    }
    /**
     * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you
     * would levels or menus.
     *
     * @param key  The name of the scene, must be unique
     * @param scene The scene to add to the engine
     */
    addScene(key, scene) {
        if (this.scenes[key]) {
            this._logger.warn('Scene', key, 'already exists overwriting');
        }
        this.scenes[key] = scene;
    }
    /**
     * @internal
     */
    removeScene(entity) {
        if (entity instanceof Scene) {
            // remove scene
            for (const key in this.scenes) {
                if (this.scenes.hasOwnProperty(key)) {
                    if (this.scenes[key] === entity) {
                        delete this.scenes[key];
                    }
                }
            }
        }
        if (typeof entity === 'string') {
            // remove scene
            delete this.scenes[entity];
        }
    }
    add(entity) {
        if (arguments.length === 2) {
            this.addScene(arguments[0], arguments[1]);
            return;
        }
        if (this._deferredGoTo && this.scenes[this._deferredGoTo]) {
            this.scenes[this._deferredGoTo].add(entity);
        }
        else {
            this.currentScene.add(entity);
        }
    }
    remove(entity) {
        if (entity instanceof Entity) {
            this.currentScene.remove(entity);
        }
        if (entity instanceof Scene) {
            this.removeScene(entity);
        }
        if (typeof entity === 'string') {
            this.removeScene(entity);
        }
    }
    /**
     * Changes the currently updating and drawing scene to a different,
     * named scene. Calls the [[Scene]] lifecycle events.
     * @param key  The key of the scene to transition to.
     */
    goToScene(key) {
        // if not yet initialized defer goToScene
        if (!this.isInitialized) {
            this._deferredGoTo = key;
            return;
        }
        if (this.scenes[key]) {
            const oldScene = this.currentScene;
            const newScene = this.scenes[key];
            this._logger.debug('Going to scene:', key);
            // only deactivate when initialized
            if (this.currentScene.isInitialized) {
                this.currentScene._deactivate.apply(this.currentScene, [oldScene, newScene]);
                this.currentScene.eventDispatcher.emit('deactivate', new DeactivateEvent(newScene, this.currentScene));
            }
            // set current scene to new one
            this.currentScene = newScene;
            this.screen.setCurrentCamera(newScene.camera);
            // initialize the current scene if has not been already
            this.currentScene._initialize(this);
            this.currentScene._activate.apply(this.currentScene, [oldScene, newScene]);
            this.currentScene.eventDispatcher.emit('activate', new ActivateEvent(oldScene, this.currentScene));
        }
        else {
            this._logger.error('Scene', key, 'does not exist!');
        }
    }
    /**
     * Transforms the current x, y from screen coordinates to world coordinates
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        return this.screen.screenToWorldCoordinates(point);
    }
    /**
     * Transforms a world coordinate, to a screen coordinate
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        return this.screen.worldToScreenCoordinates(point);
    }
    /**
     * Initializes the internal canvas, rendering context, display mode, and native event listeners
     */
    _initialize(options) {
        this.pageScrollPreventionMode = options.scrollPreventionMode;
        // initialize inputs
        this.input = {
            keyboard: new Keyboard(),
            pointers: new Pointers(this),
            gamepads: new Gamepads()
        };
        this.input.keyboard.init();
        this.input.pointers.init(options && options.pointerScope === PointerScope.Document ? document : this.canvas);
        this.input.gamepads.init();
        // Issue #385 make use of the visibility api
        // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
        let hidden, visibilityChange;
        if (typeof document.hidden !== 'undefined') {
            // Opera 12.10 and Firefox 18 and later support
            hidden = 'hidden';
            visibilityChange = 'visibilitychange';
        }
        else if ('msHidden' in document) {
            hidden = 'msHidden';
            visibilityChange = 'msvisibilitychange';
        }
        else if ('webkitHidden' in document) {
            hidden = 'webkitHidden';
            visibilityChange = 'webkitvisibilitychange';
        }
        this.browser.document.on(visibilityChange, () => {
            if (document[hidden]) {
                this.eventDispatcher.emit('hidden', new HiddenEvent(this));
                this._logger.debug('Window hidden');
            }
            else {
                this.eventDispatcher.emit('visible', new VisibleEvent(this));
                this._logger.debug('Window visible');
            }
        });
        if (!this.canvasElementId && !options.canvasElement) {
            document.body.appendChild(this.canvas);
        }
    }
    onInitialize(_engine) {
        // Override me
    }
    /**
     * If supported by the browser, this will set the antialiasing flag on the
     * canvas. Set this to `false` if you want a 'jagged' pixel art look to your
     * image resources.
     * @param isSmooth  Set smoothing to true or false
     */
    setAntialiasing(isSmooth) {
        this.screen.antialiasing = isSmooth;
    }
    /**
     * Return the current smoothing status of the canvas
     */
    getAntialiasing() {
        return this.screen.antialiasing;
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    _overrideInitialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
            if (this._deferredGoTo) {
                this.goToScene(this._deferredGoTo);
            }
            else {
                this.goToScene('root');
            }
        }
    }
    /**
     * Updates the entire state of the game
     * @param delta  Number of milliseconds elapsed since the last update.
     */
    _update(delta) {
        if (this._isLoading) {
            // suspend updates until loading is finished
            this._loader.update(this, delta);
            // Update input listeners
            this.input.keyboard.update();
            this.input.pointers.update();
            this.input.gamepads.update();
            return;
        }
        this._overrideInitialize(this);
        // Publish preupdate events
        this._preupdate(delta);
        // process engine level events
        this.currentScene.update(this, delta);
        // update animations
        // TODO remove
        this._animations = this._animations.filter(function (a) {
            return !a.animation.isDone();
        });
        // Update input listeners
        this.input.keyboard.update();
        this.input.pointers.update();
        this.input.gamepads.update();
        // Publish update event
        this._postupdate(delta);
    }
    /**
     * @internal
     */
    _preupdate(delta) {
        this.emit('preupdate', new PreUpdateEvent(this, delta, this));
        this.onPreUpdate(this, delta);
    }
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postupdate(delta) {
        this.emit('postupdate', new PostUpdateEvent(this, delta, this));
        this.onPostUpdate(this, delta);
    }
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Draws the entire game
     * @param delta  Number of milliseconds elapsed since the last draw.
     */
    _draw(delta) {
        const ctx = this.ctx;
        this._predraw(ctx, delta);
        if (this._isLoading) {
            this._loader.canvas.draw(this.graphicsContext, 0, 0);
            this.graphicsContext.flush();
            // Drawing nothing else while loading
            return;
        }
        // TODO move to graphics systems?
        this.graphicsContext.backgroundColor = this.backgroundColor;
        this.currentScene.draw(this.ctx, delta);
        // todo needs to be a better way of doing this
        let a = 0;
        const len = this._animations.length;
        for (a; a < len; a++) {
            this._animations[a].animation.draw(ctx, this._animations[a].x, this._animations[a].y);
        }
        // Draw debug information
        // TODO don't access ctx directly
        if (this.isDebug) {
            this.ctx.font = 'Consolas';
            this.ctx.fillStyle = this.debugColor.toString();
            const keys = this.input.keyboard.getKeys();
            for (let j = 0; j < keys.length; j++) {
                this.ctx.fillText(keys[j].toString() + ' : ' + (Keys[keys[j]] ? Keys[keys[j]] : 'Not Mapped'), 100, 10 * j + 10);
            }
            this.ctx.fillText('FPS:' + this.stats.currFrame.fps.toFixed(2).toString(), 10, 10);
        }
        // Post processing
        for (let i = 0; i < this.postProcessors.length; i++) {
            this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight), this.ctx);
        }
        this._postdraw(ctx, delta);
    }
    /**
     * @internal
     */
    _predraw(_ctx, delta) {
        this.emit('predraw', new PreDrawEvent(_ctx, delta, this));
        this.onPreDraw(_ctx, delta);
    }
    onPreDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postdraw(_ctx, delta) {
        this.emit('postdraw', new PostDrawEvent(_ctx, delta, this));
        this.onPostDraw(_ctx, delta);
    }
    onPostDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * Enable or disable Excalibur debugging functionality.
     * @param toggle a value that debug drawing will be changed to
     */
    showDebug(toggle) {
        this._isDebug = toggle;
    }
    /**
     * Toggle Excalibur debugging functionality.
     */
    toggleDebug() {
        this._isDebug = !this._isDebug;
        return this._isDebug;
    }
    /**
     * Returns true when loading is totally complete and the player has clicked start
     */
    get loadingComplete() {
        return this._loadingComplete;
    }
    /**
     * Starts the internal game loop for Excalibur after loading
     * any provided assets.
     * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own
     * custom loader.
     */
    start(loader) {
        if (!this._compatible) {
            return Promise.reject('Excalibur is incompatible with your browser');
        }
        let loadingComplete;
        // Push the current user entered resolution/viewport
        this.screen.pushResolutionAndViewport();
        // Configure resolution for loader
        this.screen.resolution = this.screen.viewport;
        this.screen.applyResolutionAndViewport();
        this.graphicsContext.updateViewport();
        if (loader) {
            this._loader = loader;
            this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;
            this._loader.wireEngine(this);
            loadingComplete = this.load(this._loader);
        }
        else {
            loadingComplete = Promise.resolve();
        }
        loadingComplete.then(() => {
            this.screen.popResolutionAndViewport();
            this.screen.applyResolutionAndViewport();
            this.graphicsContext.updateViewport();
            this.emit('start', new GameStartEvent(this));
            this._loadingComplete = true;
        });
        if (!this._hasStarted) {
            // has started is a slight misnomer, it's really mainloop started
            this._hasStarted = true;
            this._logger.debug('Starting game...');
            this.browser.resume();
            Engine.createMainLoop(this, window.requestAnimationFrame, Date.now)();
            this._logger.debug('Game started');
        }
        else {
            // Game already started;
        }
        return loadingComplete;
    }
    static createMainLoop(game, raf, nowFn) {
        let lastTime = nowFn();
        return function mainloop() {
            if (!game._hasStarted) {
                return;
            }
            try {
                game._requestId = raf(mainloop);
                game.emit('preframe', new PreFrameEvent(game, game.stats.prevFrame));
                // Get the time to calculate time-elapsed
                const now = nowFn();
                let elapsed = Math.floor(now - lastTime) || 1;
                // Resolves issue #138 if the game has been paused, or blurred for
                // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability
                // and provides more expected behavior when the engine comes back
                // into focus
                if (elapsed > 200) {
                    elapsed = 1;
                }
                const delta = elapsed * game.timescale;
                // reset frame stats (reuse existing instances)
                const frameId = game.stats.prevFrame.id + 1;
                game.stats.currFrame.reset();
                game.stats.currFrame.id = frameId;
                game.stats.currFrame.delta = delta;
                game.stats.currFrame.fps = 1.0 / (delta / 1000);
                const beforeUpdate = nowFn();
                game._update(delta);
                const afterUpdate = nowFn();
                game._draw(delta);
                const afterDraw = nowFn();
                game.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
                game.stats.currFrame.duration.draw = afterDraw - afterUpdate;
                lastTime = now;
                game.emit('postframe', new PostFrameEvent(game, game.stats.currFrame));
                game.stats.prevFrame.reset(game.stats.currFrame);
            }
            catch (e) {
                window.cancelAnimationFrame(game._requestId);
                game.stop();
                game.onFatalException(e);
            }
        };
    }
    /**
     * Stops Excalibur's main loop, useful for pausing the game.
     */
    stop() {
        if (this._hasStarted) {
            this.emit('stop', new GameStopEvent(this));
            this.browser.pause();
            this._hasStarted = false;
            this._logger.debug('Game stopped');
        }
    }
    /**
     * Returns the Engine's Running status, Useful for checking whether engine is running or paused.
     */
    isPaused() {
        return !this._hasStarted;
    }
    /**
     * Takes a screen shot of the current viewport and returns it as an
     * HTML Image Element.
     */
    screenshot() {
        const result = new Image();
        const raw = this.canvas.toDataURL('image/png');
        result.src = raw;
        return result;
    }
    /**
     * Another option available to you to load resources into the game.
     * Immediately after calling this the game will pause and the loading screen
     * will appear.
     * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].
     */
    load(loader) {
        const complete = new Promise((resolve) => {
            this._isLoading = true;
            loader.load().then(() => {
                if (this._suppressPlayButton) {
                    setTimeout(() => {
                        this._isLoading = false;
                        resolve();
                        // Delay is to give the logo a chance to show, otherwise don't delay
                    }, 500);
                }
                else {
                    this._isLoading = false;
                    resolve();
                }
            });
        });
        return complete;
    }
}
/**
 * Default [[EngineOptions]]
 */
Engine._DEFAULT_ENGINE_OPTIONS = {
    width: 0,
    height: 0,
    enableCanvasTransparency: true,
    canvasElementId: '',
    canvasElement: undefined,
    snapToPixel: false,
    pointerScope: PointerScope.Canvas,
    suppressConsoleBootMessage: null,
    suppressMinimumBrowserFeatureDetection: null,
    suppressHiDPIScaling: null,
    suppressPlayButton: null,
    scrollPreventionMode: ScrollPreventionMode.Canvas,
    backgroundColor: Color.fromHex('#2185d0') // Excalibur blue
};
Engine_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Actor.graphics' })
], Engine.prototype, "playAnimation", null);
/**
 * @internal
 * @deprecated
 */
let AnimationNode = class AnimationNode {
    constructor(animation, x, y) {
        this.animation = animation;
        this.x = x;
        this.y = y;
    }
};
AnimationNode = Engine_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0' })
], AnimationNode);

;// CONCATENATED MODULE: ./Math/Index.ts









;// CONCATENATED MODULE: ./Debug/index.ts




;// CONCATENATED MODULE: ./Events/MediaEvents.ts

class MediaEvent extends GameEvent {
    constructor(target, _name = 'MediaEvent') {
        super();
        this.target = target;
        this._name = _name;
    }
    /**
     * Media event cannot bubble
     */
    set bubbles(_value) {
        // stubbed
    }
    /**
     * Media event cannot bubble
     */
    get bubbles() {
        return false;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    get _path() {
        return null;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    set _path(_val) {
        // stubbed
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        /**
         * Stub
         */
    }
    /**
     * Action, that calls when event happens
     */
    action() {
        /**
         * Stub
         */
    }
    /**
     * Propagate event further through event path
     */
    propagate() {
        /**
         * Stub
         */
    }
    layPath(_actor) {
        /**
         * Stub
         */
    }
}
class NativeSoundEvent extends MediaEvent {
    constructor(target, track) {
        super(target, 'NativeSoundEvent');
        this.track = track;
    }
}
class NativeSoundProcessedEvent extends MediaEvent {
    constructor(target, _processedData) {
        super(target, 'NativeSoundProcessedEvent');
        this._processedData = _processedData;
        this.data = this._processedData;
    }
}

;// CONCATENATED MODULE: ./Graphics/Font.ts





class Font extends Raster {
    constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        super(options);
        /**
         * Font quality determines the size of the underlying rastered text, higher quality means less jagged edges.
         * If quality is set to 1, then just enough raster bitmap is generated to render the text.
         *
         * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.
         *
         * (Default 4)
         */
        this.quality = 2;
        this.family = 'sans-serif';
        this.style = FontStyle.Normal;
        this.bold = false;
        this.unit = FontUnit.Px;
        this.textAlign = TextAlign.Left;
        this.baseAlign = BaseAlign.Alphabetic;
        this.direction = Direction.LeftToRight;
        this.size = 10;
        this.shadow = null;
        this._textBounds = new BoundingBox();
        this._textWidth = 0;
        this._textHeight = 0;
        this.family = (_a = options === null || options === void 0 ? void 0 : options.family) !== null && _a !== void 0 ? _a : this.family;
        this.style = (_b = options === null || options === void 0 ? void 0 : options.style) !== null && _b !== void 0 ? _b : this.style;
        this.bold = (_c = options === null || options === void 0 ? void 0 : options.bold) !== null && _c !== void 0 ? _c : this.bold;
        this.size = (_d = options === null || options === void 0 ? void 0 : options.size) !== null && _d !== void 0 ? _d : this.size;
        this.unit = (_e = options === null || options === void 0 ? void 0 : options.unit) !== null && _e !== void 0 ? _e : this.unit;
        this.textAlign = (_f = options === null || options === void 0 ? void 0 : options.textAlign) !== null && _f !== void 0 ? _f : this.textAlign;
        this.baseAlign = (_g = options === null || options === void 0 ? void 0 : options.baseAlign) !== null && _g !== void 0 ? _g : this.baseAlign;
        this.direction = (_h = options === null || options === void 0 ? void 0 : options.direction) !== null && _h !== void 0 ? _h : this.direction;
        this.quality = (_j = options === null || options === void 0 ? void 0 : options.quality) !== null && _j !== void 0 ? _j : this.quality;
        if (options === null || options === void 0 ? void 0 : options.shadow) {
            this.shadow = {};
            this.shadow.blur = (_k = options.shadow.blur) !== null && _k !== void 0 ? _k : this.shadow.blur;
            this.shadow.offset = (_l = options.shadow.offset) !== null && _l !== void 0 ? _l : this.shadow.offset;
            this.shadow.color = (_m = options.shadow.color) !== null && _m !== void 0 ? _m : this.shadow.color;
        }
        this.flagDirty();
    }
    clone() {
        return new Font(Object.assign(Object.assign(Object.assign({}, this.cloneGraphicOptions()), this.cloneRasterOptions()), { size: this.size, unit: this.unit, family: this.family, style: this.style, bold: this.bold, textAlign: this.textAlign, baseAlign: this.baseAlign, direction: this.direction, shadow: this.shadow
                ? {
                    blur: this.shadow.blur,
                    offset: this.shadow.offset,
                    color: this.shadow.color
                }
                : null }));
    }
    get fontString() {
        return `${this.style} ${this.bold ? 'bold' : ''} ${this.size}${this.unit} ${this.family}`;
    }
    get width() {
        return this._textWidth;
    }
    set width(value) {
        this._textWidth = value;
    }
    get height() {
        var _a, _b;
        const numLines = (_b = (_a = this._lines) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 1;
        return this._textHeight * numLines;
    }
    set height(value) {
        var _a, _b;
        const numLines = (_b = (_a = this._lines) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 1;
        this._textHeight = value / numLines;
    }
    get _rasterWidth() {
        return this._bitmap.width;
    }
    get _rasterHeight() {
        return this._bitmap.height;
    }
    get _halfRasterWidth() {
        return Math.floor(this._bitmap.width / 2);
    }
    get _halfRasterHeight() {
        return Math.floor(this._bitmap.height / 2);
    }
    get localBounds() {
        return this._textBounds;
    }
    _drawImage(ex, x, y) {
        if (this.dirty) {
            this.rasterize();
        }
        ex.drawImage(this._bitmap, 0, 0, this._rasterWidth, this._rasterHeight, x - this._rasterWidth / this.quality / 2, y - this._rasterHeight / this.quality / 2, this._rasterWidth / this.quality, this._rasterHeight / this.quality);
    }
    _rotate(ex) {
        var _a;
        // TODO this needs to change depending on the bounding box...
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : this._textBounds.center;
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this._textBounds.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, -this._textBounds.height / 2 / this.scale.y);
            ex.scale(1, -1);
        }
    }
    updateText(text) {
        if (this._text !== text) {
            this._text = text;
            this._lines = this._text.split('\n');
            this._updateDimensions();
            this.flagDirty();
        }
    }
    _updateDimensions() {
        if (this._text) {
            this._applyFont(this._ctx);
            const maxWidthLine = this._lines.reduce((a, b) => {
                return a.length > b.length ? a : b;
            });
            const metrics = this._ctx.measureText(maxWidthLine);
            this._textWidth = Math.abs(metrics.actualBoundingBoxLeft) + Math.abs(metrics.actualBoundingBoxRight);
            this._textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);
            // TODO lineheight makes the text bounds wonky
            const lineAdjustedHeight = this._textHeight * this._lines.length;
            // this._textHeight = lineAdjustedHeight;
            // Changing the width and height clears the context properties
            // We double the bitmap width to account for alignment
            // We scale by "quality" so we render text without jaggies
            this._bitmap.width = (this._textWidth + this.padding * 2) * 2 * this.quality;
            this._bitmap.height = (lineAdjustedHeight + this.padding * 2) * 2 * this.quality;
            // These bounds exist in raster bitmap space where the top left corner is the corder of the bitmap
            const x = 0;
            const y = 0;
            const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);
            this._textBounds = new BoundingBox({
                left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.padding,
                top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.padding,
                bottom: y + bottomBounds + this.padding,
                right: x + Math.abs(metrics.actualBoundingBoxRight) + this.padding
            });
        }
    }
    _preDraw(ex, x, y) {
        if (this.dirty) {
            this._updateDimensions();
        }
        super._preDraw(ex, x, y);
    }
    _postDraw(ex) {
        if (this.showDebug) {
            /* istanbul ignore next */
            ex.debug.drawRect(-this._halfRasterWidth, -this._halfRasterHeight, this._rasterWidth, this._rasterHeight);
        }
        ex.restore();
    }
    _applyFont(ctx) {
        ctx.translate(this.padding + this._halfRasterWidth, this.padding + this._halfRasterHeight);
        ctx.scale(this.quality, this.quality);
        ctx.textAlign = this.textAlign;
        ctx.textBaseline = this.baseAlign;
        ctx.font = this.fontString;
        ctx.direction = this.direction;
        if (this.shadow) {
            ctx.shadowColor = this.shadow.color.toString();
            ctx.shadowBlur = this.shadow.blur;
            ctx.shadowOffsetX = this.shadow.offset.x;
            ctx.shadowOffsetY = this.shadow.offset.y;
        }
    }
    execute(ctx) {
        if (this._text) {
            // The reason we need to re-apply the font is setting raster properties (like width/height) can reset the context props
            this._applyRasterProperites(ctx);
            this._applyFont(ctx);
            const lineHeight = this._textHeight; // TODO user specified line height
            for (let i = 0; i < this._lines.length; i++) {
                const line = this._lines[i];
                if (this.color) {
                    ctx.fillText(line, 0, i * lineHeight);
                }
                if (this.strokeColor) {
                    ctx.strokeText(line, 0, i * lineHeight);
                }
            }
            if (this.showDebug) {
                // Horizontal line
                /* istanbul ignore next */
                line(ctx, Color.Red, -this._halfRasterWidth, 0, this._halfRasterWidth, 0, 2);
                // Vertical line
                /* istanbul ignore next */
                line(ctx, Color.Red, 0, -this._halfRasterHeight, 0, this._halfRasterHeight, 2);
            }
        }
    }
    render(ex, text, x, y) {
        this.updateText(text);
        this.draw(ex, x, y);
    }
}

;// CONCATENATED MODULE: ./Graphics/Text.ts




class Text extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this._text = '';
        // This order is important font, color, then text
        this.font = (_a = options.font) !== null && _a !== void 0 ? _a : new Font();
        this.color = (_b = options.color) !== null && _b !== void 0 ? _b : this.color;
        this.text = options.text;
    }
    clone() {
        return new Text({
            text: this.text.slice(),
            color: this.color.clone(),
            font: this.font.clone()
        });
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        this.font.updateText(value);
    }
    // TODO SpriteFont doesn't support a color yet :(
    get color() {
        if (this.font instanceof Font) {
            return this.font.color;
        }
        return Color.Black;
    }
    set color(color) {
        if (this.font instanceof Font) {
            this.font.color = color;
        }
    }
    get font() {
        return this._font;
    }
    set font(font) {
        if (font instanceof Font) {
            this._font = watch(font, (font) => font.flagDirty());
        }
        else {
            this._font = font;
        }
    }
    get width() {
        return this.font.width;
    }
    get height() {
        return this.font.height;
    }
    get localBounds() {
        return this.font.localBounds;
    }
    _rotate(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _flip(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _drawImage(ex, x, y) {
        if (this.font instanceof Font) {
            this.font.color = this.color;
        }
        this.font.flipHorizontal = this.flipHorizontal;
        this.font.flipVertical = this.flipVertical;
        this.font.scale = this.scale;
        this.font.rotation = this.rotation;
        this.font.origin = this.origin;
        this.font.opacity = this.opacity;
        this.font.render(ex, this._text, x, y);
    }
}

;// CONCATENATED MODULE: ./Label.ts
var Label_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







/**
 * Labels are the way to draw small amounts of text to the screen. They are
 * actors and inherit all of the benefits and capabilities.
 */
class Label_Label extends Actor {
    /**
     * Build a new label
     * @param options
     */
    constructor(options) {
        super(options);
        this.font = new Font();
        this._text = new Text({ text: '', font: this.font });
        /**
         * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
         * @deprecated Use [[SpriteFont.spacing]]
         */
        this.letterSpacing = 0; //px
        /**
         * Whether or not the [[SpriteFont]] will be case-sensitive when matching characters.
         * @deprecated Use Graphics.SpriteFont.caseInsensitve
         */
        this.caseInsensitive = true;
        const { text, pos, x, y, spriteFont, font, color } = options;
        this.pos = pos !== null && pos !== void 0 ? pos : (x && y ? vec(x, y) : this.pos);
        this.text = text !== null && text !== void 0 ? text : this.text;
        this.spriteFont = spriteFont !== null && spriteFont !== void 0 ? spriteFont : this.spriteFont;
        this.font = font !== null && font !== void 0 ? font : this.font;
        this.color = color !== null && color !== void 0 ? color : this.color;
        const gfx = this.get(GraphicsComponent);
        gfx.anchor = Vector.Zero;
        gfx.use(this._text);
    }
    /**
     * The text to draw.
     */
    get text() {
        return this._text.text;
    }
    set text(text) {
        this._text.text = text;
    }
    get color() {
        return this._text.color;
    }
    set color(color) {
        this._text.color = color;
    }
    get opacity() {
        return this._text.opacity;
    }
    set opacity(opacity) {
        this._text.opacity = opacity;
    }
    /**
     * Sets or gets the bold property of the label's text, by default it's false
     * @deprecated Use [[Font.bold|Label.font.bold]]
     */
    get bold() {
        return this.font.bold;
    }
    set bold(isBold) {
        this.font.bold = isBold;
    }
    /**
     * The CSS font family string (e.g. `sans-serif`, `Droid Sans Pro`). Web fonts
     * are supported, same as in CSS.
     * @deprecated Use [[Font.family|Label.font.family]]
     */
    get fontFamily() {
        return this.font.family;
    }
    set fontFamily(family) {
        this.font.family = family;
    }
    /**
     * The font size in the selected units, default is 10 (default units is pixel)
     * @deprecated Use [[Font.size|Label.font.size]]
     */
    get fontSize() {
        return this.font.size;
    }
    set fontSize(sizeInUnit) {
        this.font.size = sizeInUnit;
    }
    /**
     * The font style for this label, the default is [[FontStyle.Normal]]
     * @deprecated Use [[Font.style|Label.font.style]]
     */
    get fontStyle() {
        return this.font.style;
    }
    set fontStyle(style) {
        this.font.style = style;
    }
    /**
     * The css units for a font size such as px, pt, em (SpriteFont only support px), by default is 'px';
     * @deprecated Use [[Font.unit|Label.font.unit]]
     */
    get fontUnit() {
        return this.font.unit;
    }
    set fontUnit(unit) {
        this.font.unit = unit;
    }
    /**
     * Gets or sets the horizontal text alignment property for the label.
     * @deprecated Use [[Font.textAlign|Label.font.textAlign]]
     */
    get textAlign() {
        return this.font.textAlign;
    }
    set textAlign(align) {
        this.font.textAlign = align;
    }
    /**
     * Gets or sets the baseline alignment property for the label.
     * @deprecated Use [[Font.baseAlign|Label.font.baseAlign]]
     */
    get baseAlign() {
        return this.font.baseAlign;
    }
    set baseAlign(align) {
        this.font.baseAlign = align;
    }
    /**
     * The [[LegacyDrawing.SpriteFont]] to use, if any. Overrides [[fontFamily]] if present.
     * @deprecated Use [[SpriteFont]]
     */
    get spriteFont() {
        return this._legacySpriteFont;
    }
    set spriteFont(sf) {
        if (sf) {
            if (sf instanceof SpriteFont) {
                this._legacySpriteFont = sf;
                this._spriteFont = SpriteFont_SpriteFont.fromLegacySpriteFont(sf);
                this._text.font = this._spriteFont;
                return;
            }
            this._spriteFont = sf;
            this._text.font = this._spriteFont;
        }
    }
    _initialize(engine) {
        super._initialize(engine);
        this._graphicsContext = engine.graphicsContext;
    }
    /**
     * Returns the width of the text in the label (in pixels);
     */
    getTextWidth() {
        return this._text.width;
    }
    /**
     * Sets the text shadow for sprite fonts
     * @param offsetX      The x offset in pixels to place the shadow
     * @param offsetY      The y offset in pixels to place the shadow
     * @param shadowColor  The color of the text shadow
     * @deprecated Use [[Font.shadow|Label.font.shadow]]
     */
    setTextShadow(offsetX, offsetY, shadowColor) {
        this.font.shadow = { offset: vec(offsetX, offsetY), blur: 2, color: shadowColor };
    }
    /**
     * Toggles text shadows on or off, only applies when using sprite fonts
     * @deprecated Use [[Font.shadow|Label.font.shadow]]
     */
    useTextShadow(on) {
        if (this.spriteFont) {
            this.spriteFont.useTextShadow(on);
        }
    }
    /**
     * Clears the current text shadow
     * @deprecated Use [[Font.shadow|Label.font.shadow]]
     */
    clearTextShadow() {
        this.font.shadow = null;
    }
    draw(_ctx, _delta) {
        const exctx = this._graphicsContext;
        this._text.draw(exctx, 0, 0);
    }
}
Label_decorate([
    obsolete({
        message: 'Label.bold will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.bold'
    })
], Label_Label.prototype, "bold", null);
Label_decorate([
    obsolete({
        message: 'Label.fontFamily will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.family'
    })
], Label_Label.prototype, "fontFamily", null);
Label_decorate([
    obsolete({
        message: 'Label.fontSize will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.size'
    })
], Label_Label.prototype, "fontSize", null);
Label_decorate([
    obsolete({
        message: 'Label.fontStyle will be removed in v0.26.0',
        alternateMethod: 'Use Lable.font.style'
    })
], Label_Label.prototype, "fontStyle", null);
Label_decorate([
    obsolete({
        message: 'Label.fontUnit will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.unit'
    })
], Label_Label.prototype, "fontUnit", null);
Label_decorate([
    obsolete({
        message: 'Label.textAlign will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.textAlign'
    })
], Label_Label.prototype, "textAlign", null);
Label_decorate([
    obsolete({
        message: 'Label.baseAlign will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.baseAlign'
    })
], Label_Label.prototype, "baseAlign", null);
Label_decorate([
    obsolete()
], Label_Label.prototype, "spriteFont", null);
Label_decorate([
    obsolete({
        message: 'Label.setTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Label_Label.prototype, "setTextShadow", null);
Label_decorate([
    obsolete({
        message: 'Label.useTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Label_Label.prototype, "useTextShadow", null);
Label_decorate([
    obsolete({
        message: 'Label.clearTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Label_Label.prototype, "clearTextShadow", null);

;// CONCATENATED MODULE: ./Actions/Index.ts






















;// CONCATENATED MODULE: ./Collision/Group/CollisionGroupManager.ts

/**
 * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur
 */
class CollisionGroupManager {
    /**
     * Create a new named collision group up to a max of 32.
     * @param name Name for the collision group
     * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one
     */
    static create(name, mask) {
        if (this._CURRENT_GROUP > this._MAX_GROUPS) {
            throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);
        }
        if (this._GROUPS.get(name)) {
            throw new Error(`Collision group ${name} already exists`);
        }
        const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);
        this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;
        this._CURRENT_GROUP++;
        this._GROUPS.set(name, group);
        return group;
    }
    /**
     * Get all collision groups currently tracked by excalibur
     */
    static get groups() {
        return Array.from(this._GROUPS.values());
    }
    /**
     * Get a collision group by it's name
     * @param name
     */
    static groupByName(name) {
        return this._GROUPS.get(name);
    }
    /**
     * Resets the managers internal group management state
     */
    static reset() {
        this._GROUPS = new Map();
        this._CURRENT_BIT = this._STARTING_BIT;
        this._CURRENT_GROUP = 1;
    }
}
// using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.
CollisionGroupManager._STARTING_BIT = 0b1 | 0;
CollisionGroupManager._MAX_GROUPS = 32;
CollisionGroupManager._CURRENT_GROUP = 1;
CollisionGroupManager._CURRENT_BIT = CollisionGroupManager._STARTING_BIT;
CollisionGroupManager._GROUPS = new Map();

;// CONCATENATED MODULE: ./Collision/Index.ts





























;// CONCATENATED MODULE: ./Drawing/Polygon.ts
var Polygon_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Creates a closed polygon drawing given a list of [[Vector]]s.
 *
 * @deprecated Use [[Polygon]]
 * @warning Use sparingly as Polygons are performance intensive
 */
let Polygon = class Polygon {
    /**
     * @param points  The vectors to use to build the polygon in order
     */
    constructor(points) {
        /**
         * The width of the lines of the polygon
         */
        this.lineWidth = 5;
        /**
         * Indicates whether the polygon is filled or not.
         */
        this.filled = false;
        this._points = [];
        this.anchor = Vector.Zero;
        this.offset = Vector.Zero;
        this.rotation = 0;
        this.scale = Vector.One;
        this.opacity = 1;
        this._points = points;
        const minX = this._points.reduce((prev, curr) => {
            return Math.min(prev, curr.x);
        }, 0);
        const maxX = this._points.reduce((prev, curr) => {
            return Math.max(prev, curr.x);
        }, 0);
        this.drawWidth = maxX - minX;
        const minY = this._points.reduce((prev, curr) => {
            return Math.min(prev, curr.y);
        }, 0);
        const maxY = this._points.reduce((prev, curr) => {
            return Math.max(prev, curr.y);
        }, 0);
        this.drawHeight = maxY - minY;
        this.height = this.drawHeight;
        this.width = this.drawWidth;
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    addEffect() {
        // not supported on polygons
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    removeEffect() {
        // not supported on polygons
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    clearEffects() {
        // not supported on polygons
    }
    reset() {
        //pass
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { ctx, x, y, rotation, drawWidth, drawHeight, anchor, offset, opacity, flipHorizontal, flipVertical } = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.drawWidth, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.drawHeight, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, offset: (_g = options.offset) !== null && _g !== void 0 ? _g : this.offset, opacity: ((_h = options.opacity) !== null && _h !== void 0 ? _h : 1) * ((_j = this.opacity) !== null && _j !== void 0 ? _j : 1) });
        const xpoint = drawWidth * anchor.x + offset.x + x;
        const ypoint = drawHeight * anchor.y + offset.y + y;
        ctx.save();
        ctx.translate(xpoint, ypoint);
        ctx.scale(this.scale.x, this.scale.y);
        ctx.rotate(rotation);
        ctx.beginPath();
        ctx.lineWidth = this.lineWidth;
        // Iterate through the supplied points and construct a 'polygon'
        const firstPoint = this._points[0];
        ctx.moveTo(firstPoint.x, firstPoint.y);
        let i = 0;
        const len = this._points.length;
        for (i; i < len; i++) {
            ctx.lineTo(this._points[i].x, this._points[i].y);
        }
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        if (this.filled) {
            ctx.fillStyle = this.fillColor.toString();
            ctx.fill();
        }
        ctx.strokeStyle = this.lineColor.toString();
        if (flipHorizontal) {
            ctx.translate(drawWidth, 0);
            ctx.scale(-1, 1);
        }
        if (flipVertical) {
            ctx.translate(0, drawHeight);
            ctx.scale(1, -1);
        }
        const oldAlpha = ctx.globalAlpha;
        ctx.globalAlpha = opacity;
        ctx.stroke();
        ctx.globalAlpha = oldAlpha;
        ctx.restore();
    }
};
Polygon = Polygon_decorate([
    obsolete({
        message: 'Polygon will be removed in v0.26.0',
        alternateMethod: 'Use Graphics.Polygon'
    })
], Polygon);


;// CONCATENATED MODULE: ./Drawing/Index.ts










;// CONCATENATED MODULE: ./Interfaces/AudioImplementation.ts
class ExResponse {
}
ExResponse.type = {
    any: '',
    blob: 'blob',
    json: 'json',
    text: 'text',
    document: 'document',
    arraybuffer: 'arraybuffer'
};

;// CONCATENATED MODULE: ./Interfaces/LifecycleEvents.ts
/**
 * Type guard checking for internal initialize method
 * @internal
 * @param a
 */
function has_initialize(a) {
    return !!a._initialize;
}
/**
 *
 */
function hasOnInitialize(a) {
    return !!a.onInitialize;
}
/**
 *
 */
function has_preupdate(a) {
    return !!a._preupdate;
}
/**
 *
 */
function hasOnPreUpdate(a) {
    return !!a.onPreUpdate;
}
/**
 *
 */
function has_postupdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasOnPostUpdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasPreDraw(a) {
    return !!a.onPreDraw;
}
/**
 *
 */
function hasPostDraw(a) {
    return !!a.onPostDraw;
}

;// CONCATENATED MODULE: ./Interfaces/Index.ts










;// CONCATENATED MODULE: ./PostProcessing/Index.ts



;// CONCATENATED MODULE: ./Resources/Sound/WebAudioInstance.ts


/**
 * Internal class representing a Web Audio AudioBufferSourceNode instance
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
 */
class WebAudioInstance {
    constructor(_src) {
        this._src = _src;
        this._volume = 1;
        this._duration = undefined;
        this._loop = false;
        this._isPlaying = false;
        this._isPaused = false;
        this._audioContext = AudioContextFactory.create();
        this._volumeNode = this._audioContext.createGain();
        /**
         * Current playback offset (in seconds)
         */
        this._currentOffset = 0;
        this._createNewBufferSource();
    }
    set loop(value) {
        this._loop = value;
        if (this._instance) {
            this._instance.loop = value;
            this._wireUpOnEnded();
        }
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        value = clamp(value, 0, 1.0);
        this._volume = value;
        if (this._isPlaying && this._volumeNode.gain.setTargetAtTime) {
            // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime
            // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.
            // This exponential ramp provides a more pleasant transition in gain
            this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);
        }
        else {
            this._volumeNode.gain.value = value;
        }
    }
    get volume() {
        return this._volume;
    }
    set duration(value) {
        this._duration = value;
    }
    /**
     * Duration of the sound, in seconds.
     */
    get duration() {
        return this._duration;
    }
    get _playbackRate() {
        return this._instance ? 1 / (this._instance.playbackRate.value || 1.0) : null;
    }
    isPlaying() {
        return this._isPlaying;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    play(playStarted = () => { }) {
        if (this._isPaused) {
            this._resumePlayBack();
            playStarted();
        }
        if (!this._isPlaying) {
            this._startPlayBack();
            playStarted();
        }
        return this._playingPromise;
    }
    pause() {
        if (!this._isPlaying) {
            return;
        }
        this._isPaused = true;
        this._isPlaying = false;
        this._instance.stop(0);
        // Playback rate will be a scale factor of how fast/slow the audio is being played
        // default is 1.0
        // we need to invert it to get the time scale
        this._setPauseOffset();
    }
    stop() {
        if (!this._isPlaying) {
            return;
        }
        this._isPlaying = false;
        this._isPaused = false;
        this._currentOffset = 0;
        this._instance.stop(0);
        // handler will not be wired up if we were looping
        if (!this._instance.onended) {
            this._handleOnEnded();
        }
    }
    _startPlayBack() {
        this._isPlaying = true;
        this._isPaused = false;
        this._playingPromise = new Promise((resolve) => {
            this._playingResolve = resolve;
        });
        if (!this._instance) {
            this._createNewBufferSource();
        }
        this._rememberStartTime();
        this._volumeNode.connect(this._audioContext.destination);
        this._instance.start(0, 0);
        this._currentOffset = 0;
        this._wireUpOnEnded();
    }
    _resumePlayBack() {
        if (!this._isPaused) {
            return;
        }
        this._isPaused = false;
        this._isPlaying = true;
        // a buffer source can only be started once
        // so we need to dispose of the previous instance before
        // "resuming" the next one
        this._instance.onended = null; // dispose of any previous event handler
        this._createNewBufferSource();
        const duration = this._playbackRate * this._src.duration;
        const restartTime = this._currentOffset % duration;
        this._rememberStartTime(restartTime * -1000);
        this._instance.start(0, restartTime);
        this._wireUpOnEnded();
    }
    _wireUpOnEnded() {
        if (!this.loop) {
            this._instance.onended = () => this._handleOnEnded();
        }
    }
    _handleOnEnded() {
        // pausing calls stop(0) which triggers onended event
        // so we don't "resolve" yet (when we resume we'll try again)
        if (!this._isPaused) {
            this._isPlaying = false;
            this._playingResolve(true);
        }
    }
    _rememberStartTime(amend) {
        this._startTime = new Date().getTime() + (amend | 0);
    }
    _setPauseOffset() {
        this._currentOffset = ((new Date().getTime() - this._startTime) * this._playbackRate) / 1000; // in seconds
    }
    _createNewBufferSource() {
        this._instance = this._audioContext.createBufferSource();
        this._instance.buffer = this._src;
        this._instance.loop = this.loop;
        this._instance.playbackRate.setValueAtTime(1.0, 0);
        this._instance.connect(this._volumeNode);
    }
}

;// CONCATENATED MODULE: ./Util/Sound.ts

/**
 * Whether or not the browser can play this file as HTML5 Audio
 */
function canPlayFile(file) {
    try {
        const a = new Audio();
        const filetype = /.*\.([A-Za-z0-9]+)$/;
        const type = file.match(filetype)[1];
        if (a.canPlayType('audio/' + type)) {
            return true;
        }
        else {
            return false;
        }
    }
    catch (e) {
        Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);
        return false;
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/Sound.ts
var Sound_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








/**
 * The [[Sound]] object allows games built in Excalibur to load audio
 * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]
 * which means it can be passed to a [[Loader]] to pre-load before a game or level.
 */
class Sound extends Class {
    /**
     * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    constructor(...paths) {
        super();
        this.logger = Logger.getInstance();
        this._loop = false;
        this._volume = 1;
        this._duration = undefined;
        this._isStopped = false;
        this._isPaused = false;
        this._tracks = [];
        this._wasPlayingOnHidden = false;
        this._audioContext = AudioContextFactory.create();
        this._resource = new Resource('', ExResponse.type.arraybuffer);
        /**
         * Chrome : MP3, WAV, Ogg
         * Firefox : WAV, Ogg,
         * IE : MP3, WAV coming soon
         * Safari MP3, WAV, Ogg
         */
        for (const path of paths) {
            if (canPlayFile(path)) {
                this.path = path;
                break;
            }
        }
        if (!this.path) {
            this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));
            this.logger.warn('Attempting to use', paths[0]);
            this.path = paths[0]; // select the first specified
        }
    }
    /**
     * Indicates whether the clip should loop when complete
     * @param value  Set the looping flag
     */
    set loop(value) {
        this._loop = value;
        for (const track of this._tracks) {
            track.loop = this._loop;
        }
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        this._volume = value;
        for (const track of this._tracks) {
            track.volume = this._volume;
        }
        this.emit('volumechange', new NativeSoundEvent(this));
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);
    }
    get volume() {
        return this._volume;
    }
    get duration() {
        return this._duration;
    }
    /**
     * Return array of Current AudioInstances playing or being paused
     */
    get instances() {
        return this._tracks;
    }
    get path() {
        return this._resource.path;
    }
    set path(val) {
        this._resource.path = val;
    }
    isLoaded() {
        return !!this.data;
    }
    load() {
        return Sound_awaiter(this, void 0, void 0, function* () {
            if (this.data) {
                return this.data;
            }
            const arraybuffer = yield this._resource.load();
            const audiobuffer = yield this.decodeAudio(arraybuffer.slice(0));
            this._duration = typeof audiobuffer === 'object' ? audiobuffer.duration : undefined;
            this.emit('processed', new NativeSoundProcessedEvent(this, audiobuffer));
            return this.data = audiobuffer;
        });
    }
    decodeAudio(data) {
        return Sound_awaiter(this, void 0, void 0, function* () {
            try {
                return yield this._audioContext.decodeAudioData(data.slice(0));
            }
            catch (e) {
                this.logger.error('Unable to decode ' +
                    ' this browser may not fully support this format, or the file may be corrupt, ' +
                    'if this is an mp3 try removing id3 tags and album art from the file.');
                return yield Promise.reject();
            }
        });
    }
    wireEngine(engine) {
        if (engine) {
            this._engine = engine;
            this._engine.on('hidden', () => {
                if (engine.pauseAudioWhenHidden && this.isPlaying()) {
                    this._wasPlayingOnHidden = true;
                    this.pause();
                }
            });
            this._engine.on('visible', () => {
                if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {
                    this.play();
                    this._wasPlayingOnHidden = false;
                }
            });
            this._engine.on('start', () => {
                this._isStopped = false;
            });
            this._engine.on('stop', () => {
                this.stop();
                this._isStopped = true;
            });
        }
    }
    /**
     * Returns how many instances of the sound are currently playing
     */
    instanceCount() {
        return this._tracks.length;
    }
    /**
     * Whether or not the sound is playing right now
     */
    isPlaying() {
        return this._tracks.some((t) => t.isPlaying());
    }
    /**
     * Play the sound, returns a promise that resolves when the sound is done playing
     * An optional volume argument can be passed in to play the sound. Max volume is 1.0
     */
    play(volume) {
        if (!this.isLoaded()) {
            this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');
            return Promise.resolve(true);
        }
        if (this._isStopped) {
            this.logger.warn('Cannot start playing. Engine is in a stopped state.');
            return Promise.resolve(false);
        }
        this.volume = volume || this.volume;
        if (this._isPaused) {
            return this._resumePlayback();
        }
        else {
            return this._startPlayback();
        }
    }
    /**
     * Stop the sound, and do not rewind
     */
    pause() {
        if (!this.isPlaying()) {
            return;
        }
        for (const track of this._tracks) {
            track.pause();
        }
        this._isPaused = true;
        this.emit('pause', new NativeSoundEvent(this));
        this.logger.debug('Paused all instances of sound', this.path);
    }
    /**
     * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.
     */
    stop() {
        for (const track of this._tracks) {
            track.stop();
        }
        this.emit('stop', new NativeSoundEvent(this));
        this._isPaused = false;
        this._tracks.length = 0;
        this.logger.debug('Stopped all instances of sound', this.path);
    }
    /**
     * Get Id of provided AudioInstance in current trackList
     * @param track [[Audio]] which Id is to be given
     */
    getTrackId(track) {
        return this._tracks.indexOf(track);
    }
    _resumePlayback() {
        return Sound_awaiter(this, void 0, void 0, function* () {
            if (this._isPaused) {
                const resumed = [];
                // ensure we resume *current* tracks (if paused)
                for (const track of this._tracks) {
                    resumed.push(track.play());
                }
                this._isPaused = false;
                this.emit('resume', new NativeSoundEvent(this));
                this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);
                // resolve when resumed tracks are done
                yield Promise.all(resumed);
            }
            return true;
        });
    }
    /**
     * Starts playback, returns a promise that resolves when playback is complete
     */
    _startPlayback() {
        return Sound_awaiter(this, void 0, void 0, function* () {
            const track = yield this._getTrackInstance(this.data);
            const complete = yield track.play(() => {
                this.emit('playbackstart', new NativeSoundEvent(this, track));
                this.logger.debug('Playing new instance for sound', this.path);
            });
            // when done, remove track
            this.emit('playbackend', new NativeSoundEvent(this, track));
            this._tracks.splice(this.getTrackId(track), 1);
            return complete;
        });
    }
    _getTrackInstance(data) {
        const newTrack = new WebAudioInstance(data);
        newTrack.loop = this.loop;
        newTrack.volume = this.volume;
        newTrack.duration = this.duration;
        this._tracks.push(newTrack);
        return newTrack;
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/Index.ts




;// CONCATENATED MODULE: ./Resources/Gif.ts
var Gif_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







/**
 * The [[Texture]] object allows games built in Excalibur to load image resources.
 * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]
 * to pre-load before starting a level or game.
 */
class Gif {
    /**
     * @param path       Path to the image resource
     * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, color = Color.Magenta, bustCache = true) {
        this.path = path;
        this.color = color;
        this.bustCache = bustCache;
        this._stream = null;
        this._gif = null;
        this._textures = [];
        this._animation = null;
        this._transparentColor = null;
        this._resource = new Resource(path, 'arraybuffer', bustCache);
        this._transparentColor = color;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    load() {
        return Gif_awaiter(this, void 0, void 0, function* () {
            const arraybuffer = yield this._resource.load();
            this._stream = new Stream(arraybuffer);
            this._gif = new ParseGif(this._stream, this._transparentColor);
            const images = this._gif.images.map(i => new ImageSource(i.src, false));
            // Load all textures
            yield Promise.all(images.map(t => t.load()));
            return this.data = this._textures = images;
        });
    }
    isLoaded() {
        return !!this.data;
    }
    /**
     * Return a frame of the gif as a legacy sprite by index
     * @deprecated
     */
    toLegacySprite(id = 0) {
        return Sprite.toLegacySprite(this.toSprite(id));
    }
    /**
     * Return the gif as a legacy spritesheet
     * @deprecated
     * @returns
     */
    toLegacySpriteSheet() {
        return SpriteSheet.toLegacySpriteSheet(this.toSpriteSheet());
    }
    /**
     * Return the gif as a legacy animation
     * @deprecated
     * @param speed
     */
    toLegacyAnimation(engine, speed) {
        return Animation.toLegacyAnimation(engine, this.toAnimation(speed));
    }
    /**
     * Return a frame of the gif as a sprite by id
     * @param id
     */
    toSprite(id = 0) {
        const sprite = this._textures[id].toSprite();
        return sprite;
    }
    /**
     * Return the gif as a spritesheet
     */
    toSpriteSheet() {
        const sprites = this._textures.map((image) => {
            return image.toSprite();
        });
        return new SpriteSheet({ sprites });
    }
    /**
     * Transform the GIF into an animation with duration per frame
     */
    toAnimation(durationPerFrameMs) {
        const spriteSheet = this.toSpriteSheet();
        const length = spriteSheet.sprites.length;
        this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);
        return this._animation;
    }
    get readCheckBytes() {
        return this._gif.checkBytes;
    }
}
const bitsToNum = (ba) => {
    return ba.reduce(function (s, n) {
        return s * 2 + n;
    }, 0);
};
const byteToBitArr = (bite) => {
    const a = [];
    for (let i = 7; i >= 0; i--) {
        a.push(!!(bite & (1 << i)));
    }
    return a;
};
class Stream {
    constructor(dataArray) {
        this.data = null;
        this.len = 0;
        this.position = 0;
        this.readByte = () => {
            if (this.position >= this.data.byteLength) {
                throw new Error('Attempted to read past end of stream.');
            }
            return this.data[this.position++];
        };
        this.readBytes = (n) => {
            const bytes = [];
            for (let i = 0; i < n; i++) {
                bytes.push(this.readByte());
            }
            return bytes;
        };
        this.read = (n) => {
            let s = '';
            for (let i = 0; i < n; i++) {
                s += String.fromCharCode(this.readByte());
            }
            return s;
        };
        this.readUnsigned = () => {
            // Little-endian.
            const a = this.readBytes(2);
            return (a[1] << 8) + a[0];
        };
        this.data = new Uint8Array(dataArray);
        this.len = this.data.byteLength;
        if (this.len === 0) {
            throw new Error('No data loaded from file');
        }
    }
}
const lzwDecode = function (minCodeSize, data) {
    // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?
    let pos = 0; // Maybe this streaming thing should be merged with the Stream?
    const readCode = function (size) {
        let code = 0;
        for (let i = 0; i < size; i++) {
            if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {
                code |= 1 << i;
            }
            pos++;
        }
        return code;
    };
    const output = [];
    const clearCode = 1 << minCodeSize;
    const eoiCode = clearCode + 1;
    let codeSize = minCodeSize + 1;
    let dict = [];
    const clear = function () {
        dict = [];
        codeSize = minCodeSize + 1;
        for (let i = 0; i < clearCode; i++) {
            dict[i] = [i];
        }
        dict[clearCode] = [];
        dict[eoiCode] = null;
    };
    let code;
    let last;
    while (true) {
        last = code;
        code = readCode(codeSize);
        if (code === clearCode) {
            clear();
            continue;
        }
        if (code === eoiCode) {
            break;
        }
        if (code < dict.length) {
            if (last !== clearCode) {
                dict.push(dict[last].concat(dict[code][0]));
            }
        }
        else {
            if (code !== dict.length) {
                throw new Error('Invalid LZW code.');
            }
            dict.push(dict[last].concat(dict[last][0]));
        }
        output.push.apply(output, dict[code]);
        if (dict.length === 1 << codeSize && codeSize < 12) {
            // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.
            codeSize++;
        }
    }
    // I don't know if this is technically an error, but some GIFs do it.
    //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');
    return output;
};
// The actual parsing; returns an object with properties.
class ParseGif {
    constructor(stream, color = Color.Magenta) {
        this._st = null;
        this._handler = {};
        this._transparentColor = null;
        this.frames = [];
        this.images = [];
        this.globalColorTable = [];
        this.checkBytes = [];
        // LZW (GIF-specific)
        this.parseColorTable = (entries) => {
            // Each entry is 3 bytes, for RGB.
            const ct = [];
            for (let i = 0; i < entries; i++) {
                const rgb = this._st.readBytes(3);
                const rgba = '#' +
                    rgb
                        .map((x) => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    })
                        .join('');
                ct.push(rgba);
            }
            return ct;
        };
        this.readSubBlocks = () => {
            let size, data;
            data = '';
            do {
                size = this._st.readByte();
                data += this._st.read(size);
            } while (size !== 0);
            return data;
        };
        this.parseHeader = () => {
            const hdr = {
                sig: null,
                ver: null,
                width: null,
                height: null,
                colorRes: null,
                globalColorTableSize: null,
                gctFlag: null,
                sorted: null,
                globalColorTable: [],
                bgColor: null,
                pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            };
            hdr.sig = this._st.read(3);
            hdr.ver = this._st.read(3);
            if (hdr.sig !== 'GIF') {
                throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.
            }
            hdr.width = this._st.readUnsigned();
            hdr.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            hdr.gctFlag = bits.shift();
            hdr.colorRes = bitsToNum(bits.splice(0, 3));
            hdr.sorted = bits.shift();
            hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));
            hdr.bgColor = this._st.readByte();
            hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            if (hdr.gctFlag) {
                hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));
                this.globalColorTable = hdr.globalColorTable;
            }
            if (this._handler.hdr && this._handler.hdr(hdr)) {
                this.checkBytes.push(this._handler.hdr);
            }
        };
        this.parseExt = (block) => {
            const parseGCExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 4
                const bits = byteToBitArr(this._st.readByte());
                block.reserved = bits.splice(0, 3); // Reserved; should be 000.
                block.disposalMethod = bitsToNum(bits.splice(0, 3));
                block.userInput = bits.shift();
                block.transparencyGiven = bits.shift();
                block.delayTime = this._st.readUnsigned();
                block.transparencyIndex = this._st.readByte();
                block.terminator = this._st.readByte();
                if (this._handler.gce && this._handler.gce(block)) {
                    this.checkBytes.push(this._handler.gce);
                }
            };
            const parseComExt = (block) => {
                block.comment = this.readSubBlocks();
                if (this._handler.com && this._handler.com(block)) {
                    this.checkBytes.push(this._handler.com);
                }
            };
            const parsePTExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 12
                block.ptHeader = this._st.readBytes(12);
                block.ptData = this.readSubBlocks();
                if (this._handler.pte && this._handler.pte(block)) {
                    this.checkBytes.push(this._handler.pte);
                }
            };
            const parseAppExt = (block) => {
                const parseNetscapeExt = (block) => {
                    this.checkBytes.push(this._st.readByte()); // Always 3
                    block.unknown = this._st.readByte(); // Q: Always 1? What is this?
                    block.iterations = this._st.readUnsigned();
                    block.terminator = this._st.readByte();
                    if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {
                        this.checkBytes.push(this._handler.app);
                    }
                };
                const parseUnknownAppExt = (block) => {
                    block.appData = this.readSubBlocks();
                    // FIXME: This won't work if a handler wants to match on any identifier.
                    if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {
                        this.checkBytes.push(this._handler.app[block.identifier]);
                    }
                };
                this.checkBytes.push(this._st.readByte()); // Always 11
                block.identifier = this._st.read(8);
                block.authCode = this._st.read(3);
                switch (block.identifier) {
                    case 'NETSCAPE':
                        parseNetscapeExt(block);
                        break;
                    default:
                        parseUnknownAppExt(block);
                        break;
                }
            };
            const parseUnknownExt = (block) => {
                block.data = this.readSubBlocks();
                if (this._handler.unknown && this._handler.unknown(block)) {
                    this.checkBytes.push(this._handler.unknown);
                }
            };
            block.label = this._st.readByte();
            switch (block.label) {
                case 0xf9:
                    block.extType = 'gce';
                    parseGCExt(block);
                    break;
                case 0xfe:
                    block.extType = 'com';
                    parseComExt(block);
                    break;
                case 0x01:
                    block.extType = 'pte';
                    parsePTExt(block);
                    break;
                case 0xff:
                    block.extType = 'app';
                    parseAppExt(block);
                    break;
                default:
                    block.extType = 'unknown';
                    parseUnknownExt(block);
                    break;
            }
        };
        this.parseImg = (img) => {
            const deinterlace = (pixels, width) => {
                // Of course this defeats the purpose of interlacing. And it's *probably*
                // the least efficient way it's ever been implemented. But nevertheless...
                const newPixels = new Array(pixels.length);
                const rows = pixels.length / width;
                const cpRow = (toRow, fromRow) => {
                    const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
                    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
                };
                const offsets = [0, 4, 2, 1];
                const steps = [8, 8, 4, 2];
                let fromRow = 0;
                for (let pass = 0; pass < 4; pass++) {
                    for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
                        cpRow(toRow, fromRow);
                        fromRow++;
                    }
                }
                return newPixels;
            };
            img.leftPos = this._st.readUnsigned();
            img.topPos = this._st.readUnsigned();
            img.width = this._st.readUnsigned();
            img.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            img.lctFlag = bits.shift();
            img.interlaced = bits.shift();
            img.sorted = bits.shift();
            img.reserved = bits.splice(0, 2);
            img.lctSize = bitsToNum(bits.splice(0, 3));
            if (img.lctFlag) {
                img.lct = this.parseColorTable(1 << (img.lctSize + 1));
            }
            img.lzwMinCodeSize = this._st.readByte();
            const lzwData = this.readSubBlocks();
            img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);
            if (img.interlaced) {
                // Move
                img.pixels = deinterlace(img.pixels, img.width);
            }
            this.frames.push(img);
            this.arrayToImage(img);
            if (this._handler.img && this._handler.img(img)) {
                this.checkBytes.push(this._handler);
            }
        };
        this.parseBlock = () => {
            const block = {
                sentinel: this._st.readByte(),
                type: ''
            };
            const blockChar = String.fromCharCode(block.sentinel);
            switch (blockChar) {
                case '!':
                    block.type = 'ext';
                    this.parseExt(block);
                    break;
                case ',':
                    block.type = 'img';
                    this.parseImg(block);
                    break;
                case ';':
                    block.type = 'eof';
                    if (this._handler.eof && this._handler.eof(block)) {
                        this.checkBytes.push(this._handler.eof);
                    }
                    break;
                default:
                    throw new Error('Unknown block: 0x' + block.sentinel.toString(16));
            }
            if (block.type !== 'eof') {
                this.parseBlock();
            }
        };
        this.arrayToImage = (frame) => {
            let count = 0;
            const c = document.createElement('canvas');
            c.id = count.toString();
            c.width = frame.width;
            c.height = frame.height;
            count++;
            const context = c.getContext('2d');
            const pixSize = 1;
            let y = 0;
            let x = 0;
            for (let i = 0; i < frame.pixels.length; i++) {
                if (x % frame.width === 0) {
                    y++;
                    x = 0;
                }
                if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) {
                    context.fillStyle = `rgba(0, 0, 0, 0)`;
                }
                else {
                    context.fillStyle = this.globalColorTable[frame.pixels[i]];
                }
                context.fillRect(x, y, pixSize, pixSize);
                x++;
            }
            const img = new Image();
            img.src = c.toDataURL();
            this.images.push(img);
        };
        this._st = stream;
        this._handler = {};
        this._transparentColor = color;
        this.parseHeader();
        this.parseBlock();
    }
}

;// CONCATENATED MODULE: ./Resources/Index.ts




;// CONCATENATED MODULE: ./EntityComponentSystem/index.ts











;// CONCATENATED MODULE: ./Graphics/Polygon.ts


/**
 * A polygon [[Graphic]] for drawing arbitrary polygons to the [[ExcaliburGraphicsContext]]
 */
class Polygon_Polygon extends Raster {
    constructor(options) {
        super(options);
        this.points = options.points;
        this.rasterize();
    }
    get points() {
        return this._points;
    }
    set points(points) {
        this._points = points;
        const min = this.minPoint;
        this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;
        this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;
        this.flagDirty();
    }
    get minPoint() {
        const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);
        const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);
        return vec(minX, minY);
    }
    clone() {
        return new Polygon_Polygon(Object.assign(Object.assign({ points: this.points.map((p) => p.clone()) }, this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        if (this.points && this.points.length) {
            ctx.beginPath();
            // Iterate through the supplied points and construct a 'polygon'
            const min = this.minPoint.negate();
            const firstPoint = this.points[0].add(min);
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this.points.forEach((point) => {
                ctx.lineTo(point.x + min.x, point.y + min.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/index.ts
// Graphics






// Graphics ECS


// Raster graphics














;// CONCATENATED MODULE: ./Input/Index.ts
/**
 * @module
 * Provides support for mice, keyboards, and controllers.
 */
/**
 * @typedoc
 */








;// CONCATENATED MODULE: ./Traits/Index.ts
/**
 * @module
 */



;// CONCATENATED MODULE: ./Util/Index.ts







;// CONCATENATED MODULE: ./Util/SortedList.ts
var SortedList_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * A sorted list implementation. NOTE: this implementation is not self-balancing
 * @deprecated WIll be removed in v0.26.0 Use built in JS array.sort
 */
let SortedList = class SortedList {
    constructor(getComparable) {
        this._getComparable = getComparable;
    }
    find(element) {
        return this._find(this._root, element);
    }
    _find(node, element) {
        if (node == null) {
            return false;
        }
        else if (this._getComparable(element) === node.getKey()) {
            if (node.getData().indexOf(element) > -1) {
                return true;
            }
            else {
                return false;
            }
        }
        else if (this._getComparable(element) < node.getKey()) {
            return this._find(node.getLeft(), element);
        }
        else {
            return this._find(node.getRight(), element);
        }
    }
    // returns the array of elements at a specific key value
    get(key) {
        return this._get(this._root, key);
    }
    _get(node, key) {
        if (node == null) {
            return [];
        }
        else if (key === node.getKey()) {
            return node.getData();
        }
        else if (key < node.getKey()) {
            return this._get(node.getLeft(), key);
        }
        else {
            return this._get(node.getRight(), key);
        }
    }
    add(element) {
        if (this._root == null) {
            this._root = new BinaryTreeNode(this._getComparable(element), [element], null, null);
            return true;
        }
        else {
            return this._insert(this._root, element);
        }
    }
    _insert(node, element) {
        if (node != null) {
            if (this._getComparable(element) === node.getKey()) {
                if (node.getData().indexOf(element) > -1) {
                    return false; // the element we're trying to insert already exists
                }
                else {
                    node.getData().push(element);
                    return true;
                }
            }
            else if (this._getComparable(element) < node.getKey()) {
                if (node.getLeft() == null) {
                    node.setLeft(new BinaryTreeNode(this._getComparable(element), [element], null, null));
                    return true;
                }
                else {
                    return this._insert(node.getLeft(), element);
                }
            }
            else {
                if (node.getRight() == null) {
                    node.setRight(new BinaryTreeNode(this._getComparable(element), [element], null, null));
                    return true;
                }
                else {
                    return this._insert(node.getRight(), element);
                }
            }
        }
        return false;
    }
    removeByComparable(element) {
        this._root = this._remove(this._root, element);
    }
    _remove(node, element) {
        if (node == null) {
            return null;
        }
        else if (this._getComparable(element) === node.getKey()) {
            const elementIndex = node.getData().indexOf(element);
            // if the node contains the element, remove the element
            if (elementIndex > -1) {
                node.getData().splice(elementIndex, 1);
                // if we have removed the last element at this node, remove the node
                if (node.getData().length === 0) {
                    // if the node is a leaf
                    if (node.getLeft() == null && node.getRight() == null) {
                        return null;
                    }
                    else if (node.getLeft() == null) {
                        return node.getRight();
                    }
                    else if (node.getRight() == null) {
                        return node.getLeft();
                    }
                    // if node has 2 children
                    const temp = this._findMinNode(node.getRight());
                    node.setKey(temp.getKey());
                    node.setData(temp.getData());
                    node.setRight(this._cleanup(node.getRight(), temp)); //"cleanup nodes" (move them up recursively)
                    return node;
                }
                else {
                    // this prevents the node from being removed since it still contains elements
                    return node;
                }
            }
        }
        else if (this._getComparable(element) < node.getKey()) {
            node.setLeft(this._remove(node.getLeft(), element));
            return node;
        }
        else {
            node.setRight(this._remove(node.getRight(), element));
            return node;
        }
        return null;
    }
    // called once we have successfully removed the element we wanted, recursively corrects the part of the tree below the removed node
    _cleanup(node, element) {
        const comparable = element.getKey();
        if (node == null) {
            return null;
        }
        else if (comparable === node.getKey()) {
            // if the node is a leaf
            if (node.getLeft() == null && node.getRight() == null) {
                return null;
            }
            else if (node.getLeft() == null) {
                return node.getRight();
            }
            else if (node.getRight() == null) {
                return node.getLeft();
            }
            // if node has 2 children
            const temp = this._findMinNode(node.getRight());
            node.setKey(temp.getKey());
            node.setData(temp.getData());
            node.setRight(this._cleanup(node.getRight(), temp));
            return node;
        }
        else if (element.getKey() < node.getKey()) {
            node.setLeft(this._cleanup(node.getLeft(), element));
            return node;
        }
        else {
            node.setRight(this._cleanup(node.getRight(), element));
            return node;
        }
    }
    _findMinNode(node) {
        let current = node;
        while (current.getLeft() != null) {
            current = current.getLeft();
        }
        return current;
    }
    list() {
        const results = new Array();
        this._list(this._root, results);
        return results;
    }
    _list(treeNode, results) {
        if (treeNode != null) {
            this._list(treeNode.getLeft(), results);
            treeNode.getData().forEach((element) => {
                results.push(element);
            });
            this._list(treeNode.getRight(), results);
        }
    }
};
SortedList = SortedList_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use built in JS array.sort' })
], SortedList);

/**
 * A tree node part of [[SortedList]]
 * @deprecated Will be removed in v0.26.0
 */
let BinaryTreeNode = class BinaryTreeNode {
    constructor(key, data, left, right) {
        this._key = key;
        this._data = data;
        this._left = left;
        this._right = right;
    }
    getKey() {
        return this._key;
    }
    setKey(key) {
        this._key = key;
    }
    getData() {
        return this._data;
    }
    setData(data) {
        this._data = data;
    }
    getLeft() {
        return this._left;
    }
    setLeft(left) {
        this._left = left;
    }
    getRight() {
        return this._right;
    }
    setRight(right) {
        this._right = right;
    }
};
BinaryTreeNode = SortedList_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0' })
], BinaryTreeNode);

/**
 * Mock element for testing
 *
 * @internal
 * @deprecated Will be removed in v0.26.0
 */
class MockedElement {
    constructor(key) {
        this._key = 0;
        this._key = key;
    }
    getTheKey() {
        return this._key;
    }
    setKey(key) {
        this._key = key;
    }
}

;// CONCATENATED MODULE: ./Promises.ts
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
var Promises_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Promise_1;

/**
 * Valid states for a promise to be in
 * @deprecated Will be removed in v0.26.0
 */
var PromiseState;
(function (PromiseState) {
    PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
    PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
    PromiseState[PromiseState["Pending"] = 2] = "Pending";
})(PromiseState || (PromiseState = {}));
/**
 * Promises are used to do asynchronous work and they are useful for
 * creating a chain of actions. In Excalibur they are used for loading,
 * sounds, animation, actions, and more.
 * @deprecated Will be removed in v0.26.0
 */
let Promises_Promise = Promise_1 = class Promise {
    constructor() {
        this._state = PromiseState.Pending;
        this._successCallbacks = [];
        this._rejectCallback = () => {
            return;
        };
    }
    /**
     * Create and resolve a Promise with an optional value
     * @param value  An optional value to wrap in a resolved promise
     * @deprecated Use browser native promises
     */
    static resolve(value) {
        const promise = new Promise_1().resolve(value);
        return promise;
    }
    /**
     * Create and reject a Promise with an optional value
     * @param value  An optional value to wrap in a rejected promise
     * @deprecated Use browser native promises
     */
    static reject(value) {
        const promise = new Promise_1().reject(value);
        return promise;
    }
    static join() {
        let promises = [];
        if (arguments.length > 0 && !Array.isArray(arguments[0])) {
            for (let _i = 0; _i < arguments.length; _i++) {
                promises[_i - 0] = arguments[_i];
            }
        }
        else if (arguments.length === 1 && Array.isArray(arguments[0])) {
            promises = arguments[0];
        }
        const joinedPromise = new Promise_1();
        if (!promises || !promises.length) {
            return joinedPromise.resolve();
        }
        const total = promises.length;
        let successes = 0;
        let rejects = 0;
        const errors = [];
        promises.forEach((p) => {
            p.then(() => {
                successes += 1;
                if (successes === total) {
                    joinedPromise.resolve();
                }
                else if (successes + rejects + errors.length === total) {
                    joinedPromise.reject(errors);
                }
            }, () => {
                rejects += 1;
                if (successes + rejects + errors.length === total) {
                    joinedPromise.reject(errors);
                }
            }).error((e) => {
                errors.push(e);
                if (errors.length + successes + rejects === total) {
                    joinedPromise.reject(errors);
                }
            });
        });
        return joinedPromise;
    }
    /**
     * Chain success and reject callbacks after the promise is resolved
     * @param successCallback  Call on resolution of promise
     * @param rejectCallback   Call on rejection of promise
     * @deprecated Use browser native promises
     */
    then(successCallback, rejectCallback) {
        if (successCallback) {
            this._successCallbacks.push(successCallback);
            // If the promise is already resolved call immediately
            if (this.state() === PromiseState.Resolved) {
                try {
                    successCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
        }
        if (rejectCallback) {
            this._rejectCallback = rejectCallback;
            // If the promise is already rejected call immediately
            if (this.state() === PromiseState.Rejected) {
                try {
                    rejectCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
        }
        return this;
    }
    /**
     * Add an error callback to the promise
     * @param errorCallback  Call if there was an error in a callback
     * @deprecated Use browser native promises
     */
    error(errorCallback) {
        if (errorCallback) {
            this._errorCallback = errorCallback;
        }
        return this;
    }
    /**
     * Resolve the promise and pass an option value to the success callbacks
     * @param value  Value to pass to the success callbacks
     * @deprecated Use browser native promises
     */
    resolve(value) {
        if (this._state === PromiseState.Pending) {
            this._value = value;
            try {
                this._state = PromiseState.Resolved;
                this._successCallbacks.forEach((cb) => {
                    cb.call(this, this._value);
                });
            }
            catch (e) {
                this._handleError(e);
            }
        }
        else {
            throw new Error('Cannot resolve a promise that is not in a pending state!');
        }
        return this;
    }
    /**
     * Reject the promise and pass an option value to the reject callbacks
     * @param value  Value to pass to the reject callbacks
     * @deprecated Use browser native promises
     */
    reject(value) {
        if (this._state === PromiseState.Pending) {
            this._value = value;
            try {
                this._state = PromiseState.Rejected;
                this._rejectCallback.call(this, this._value);
            }
            catch (e) {
                this._handleError(e);
            }
        }
        else {
            throw new Error('Cannot reject a promise that is not in a pending state!');
        }
        return this;
    }
    /**
     * Inspect the current state of a promise
     * @deprecated Use browser native promises
     */
    state() {
        return this._state;
    }
    _handleError(e) {
        if (this._errorCallback) {
            this._errorCallback.call(this, e);
        }
        else {
            // rethrow error
            throw e;
        }
    }
};
Promises_Promise = Promise_1 = Promises_decorate([
    obsolete({
        message: 'ex.Promises are being replaced by native browser promises in v0.26.0',
        alternateMethod: 'Use browser native promises'
    })
], Promises_Promise);


;// CONCATENATED MODULE: ./index.ts
/**
 * The current Excalibur version string
 * @description `process.env.__EX_VERSION` gets replaced by Webpack on build
 */
const EX_VERSION = "0.25.1";

polyfill();
// This file is used as the bundle entry point and exports everything
// that will be exposed as the `ex` global variable.

























// ex.LegacyDrawing namespace








// ex.Events namespace


// ex.Input namespace


// ex.Traits namespace


// ex.Util namespaces












// ex.Deprecated

// import * as deprecated from './Deprecated';
// export { deprecated as Deprecated };
// export * from './Deprecated';

})();

var __webpack_exports__ActionContext = __webpack_exports__.fWn;
var __webpack_exports__ActionQueue = __webpack_exports__.Ia8;
var __webpack_exports__ActionsComponent = __webpack_exports__.hLI;
var __webpack_exports__ActionsSystem = __webpack_exports__.yyv;
var __webpack_exports__ActivateEvent = __webpack_exports__.tX5;
var __webpack_exports__Actor = __webpack_exports__.vtX;
var __webpack_exports__AddedComponent = __webpack_exports__.r7K;
var __webpack_exports__AddedEntity = __webpack_exports__.lCh;
var __webpack_exports__Animation = __webpack_exports__.fwF;
var __webpack_exports__AnimationDirection = __webpack_exports__.sce;
var __webpack_exports__AnimationStrategy = __webpack_exports__._c7;
var __webpack_exports__ArcadeSolver = __webpack_exports__.KUs;
var __webpack_exports__AudioContextFactory = __webpack_exports__.Ajp;
var __webpack_exports__Axis = __webpack_exports__.RDh;
var __webpack_exports__BaseAlign = __webpack_exports__._H9;
var __webpack_exports__BinaryTreeNode = __webpack_exports__.Ulf;
var __webpack_exports__Blink = __webpack_exports__.mxs;
var __webpack_exports__BodyComponent = __webpack_exports__.OmD;
var __webpack_exports__BoundingBox = __webpack_exports__.kBf;
var __webpack_exports__BroadphaseStrategy = __webpack_exports__.C4F;
var __webpack_exports__BrowserComponent = __webpack_exports__.NQt;
var __webpack_exports__BrowserEvents = __webpack_exports__.JjN;
var __webpack_exports__Camera = __webpack_exports__.V1s;
var __webpack_exports__Canvas = __webpack_exports__.Xz7;
var __webpack_exports__Cell = __webpack_exports__.bLd;
var __webpack_exports__Circle = __webpack_exports__.Cdc;
var __webpack_exports__CircleCollider = __webpack_exports__.FKn;
var __webpack_exports__Class = __webpack_exports__.wTW;
var __webpack_exports__ClosestLine = __webpack_exports__.ab2;
var __webpack_exports__ClosestLineJumpTable = __webpack_exports__.GfZ;
var __webpack_exports__Collider = __webpack_exports__.YMS;
var __webpack_exports__ColliderComponent = __webpack_exports__.oyv;
var __webpack_exports__CollisionContact = __webpack_exports__.aUb;
var __webpack_exports__CollisionEndEvent = __webpack_exports__.SdD;
var __webpack_exports__CollisionGroup = __webpack_exports__.JUv;
var __webpack_exports__CollisionGroupManager = __webpack_exports__.jEj;
var __webpack_exports__CollisionJumpTable = __webpack_exports__.TFq;
var __webpack_exports__CollisionPostSolveEvent = __webpack_exports__.HDU;
var __webpack_exports__CollisionPreSolveEvent = __webpack_exports__.R_y;
var __webpack_exports__CollisionResolutionStrategy = __webpack_exports__.ydN;
var __webpack_exports__CollisionSolver = __webpack_exports__._N2;
var __webpack_exports__CollisionStartEvent = __webpack_exports__.t50;
var __webpack_exports__CollisionSystem = __webpack_exports__.s$$;
var __webpack_exports__CollisionType = __webpack_exports__.v2G;
var __webpack_exports__Color = __webpack_exports__.Ilk;
var __webpack_exports__ColorBlindCorrector = __webpack_exports__.H_9;
var __webpack_exports__ColorBlindFlags = __webpack_exports__.s9i;
var __webpack_exports__ColorBlindness = __webpack_exports__.ksl;
var __webpack_exports__Component = __webpack_exports__.wA2;
var __webpack_exports__CompositeCollider = __webpack_exports__.R_p;
var __webpack_exports__Configurable = __webpack_exports__.IQ$;
var __webpack_exports__ConsoleAppender = __webpack_exports__.I5F;
var __webpack_exports__ContactConstraintPoint = __webpack_exports__.X8$;
var __webpack_exports__ContactEndEvent = __webpack_exports__.FR6;
var __webpack_exports__ContactStartEvent = __webpack_exports__.U8o;
var __webpack_exports__CoordPlane = __webpack_exports__.kbG;
var __webpack_exports__CullingBox = __webpack_exports__.oeJ;
var __webpack_exports__DeactivateEvent = __webpack_exports__.iS_;
var __webpack_exports__Debug = __webpack_exports__.cGG;
var __webpack_exports__DebugSystem = __webpack_exports__.skb;
var __webpack_exports__DebugText = __webpack_exports__.SLU;
var __webpack_exports__DegreeOfFreedom = __webpack_exports__.RdJ;
var __webpack_exports__Detector = __webpack_exports__.gU7;
var __webpack_exports__Die = __webpack_exports__.LSk;
var __webpack_exports__Direction = __webpack_exports__.Nmp;
var __webpack_exports__DisplayMode = __webpack_exports__.d1Y;
var __webpack_exports__DynamicTree = __webpack_exports__.xrL;
var __webpack_exports__DynamicTreeCollisionProcessor = __webpack_exports__.sRW;
var __webpack_exports__EX_VERSION = __webpack_exports__.cmV;
var __webpack_exports__EaseTo = __webpack_exports__.N0Q;
var __webpack_exports__EasingFunctions = __webpack_exports__.q8b;
var __webpack_exports__EdgeCollider = __webpack_exports__.ynB;
var __webpack_exports__ElasticToActorStrategy = __webpack_exports__.jT9;
var __webpack_exports__EmitterType = __webpack_exports__.wAz;
var __webpack_exports__Engine = __webpack_exports__.D4V;
var __webpack_exports__EnterTriggerEvent = __webpack_exports__.N6H;
var __webpack_exports__EnterViewPortEvent = __webpack_exports__.W1A;
var __webpack_exports__Entity = __webpack_exports__.JHW;
var __webpack_exports__EntityManager = __webpack_exports__.v2K;
var __webpack_exports__EventDispatcher = __webpack_exports__.pBf;
var __webpack_exports__EventTypes = __webpack_exports__.GMl;
var __webpack_exports__Events = __webpack_exports__.zW2;
var __webpack_exports__ExResponse = __webpack_exports__.B0K;
var __webpack_exports__ExcaliburGraphicsContext2DCanvas = __webpack_exports__.Nv7;
var __webpack_exports__ExcaliburGraphicsContextWebGL = __webpack_exports__.C_p;
var __webpack_exports__ExitTriggerEvent = __webpack_exports__.MUA;
var __webpack_exports__ExitViewPortEvent = __webpack_exports__.xqU;
var __webpack_exports__Experiments = __webpack_exports__.peG;
var __webpack_exports__Fade = __webpack_exports__.pTp;
var __webpack_exports__Flags = __webpack_exports__.vUK;
var __webpack_exports__Follow = __webpack_exports__.j9l;
var __webpack_exports__Font = __webpack_exports__.Zxw;
var __webpack_exports__FontStyle = __webpack_exports__.Hdx;
var __webpack_exports__FontUnit = __webpack_exports__.Z$d;
var __webpack_exports__FrameStats = __webpack_exports__.o$7;
var __webpack_exports__GameEvent = __webpack_exports__.Zm$;
var __webpack_exports__GameStartEvent = __webpack_exports__.$QH;
var __webpack_exports__GameStopEvent = __webpack_exports__.i78;
var __webpack_exports__GamepadAxisEvent = __webpack_exports__.h6u;
var __webpack_exports__GamepadButtonEvent = __webpack_exports__.hts;
var __webpack_exports__GamepadConnectEvent = __webpack_exports__.j88;
var __webpack_exports__GamepadDisconnectEvent = __webpack_exports__.VME;
var __webpack_exports__Gif = __webpack_exports__.nt;
var __webpack_exports__GlobalCoordinates = __webpack_exports__.Ukr;
var __webpack_exports__Graphic = __webpack_exports__.zsu;
var __webpack_exports__GraphicsComponent = __webpack_exports__.oA6;
var __webpack_exports__GraphicsGroup = __webpack_exports__.TVh;
var __webpack_exports__GraphicsLayer = __webpack_exports__.TwZ;
var __webpack_exports__GraphicsLayers = __webpack_exports__.GTT;
var __webpack_exports__GraphicsSystem = __webpack_exports__.xxj;
var __webpack_exports__HiddenEvent = __webpack_exports__.XdK;
var __webpack_exports__ImageSource = __webpack_exports__.cXo;
var __webpack_exports__InitializeEvent = __webpack_exports__.Dm5;
var __webpack_exports__Input = __webpack_exports__.IIB;
var __webpack_exports__Integrator = __webpack_exports__.zI0;
var __webpack_exports__KillEvent = __webpack_exports__.SKZ;
var __webpack_exports__Label = __webpack_exports__.__J;
var __webpack_exports__Legacy = __webpack_exports__.Dvr;
var __webpack_exports__LegacyDrawing = __webpack_exports__.Tf9;
var __webpack_exports__LimitCameraBoundsStrategy = __webpack_exports__.RI$;
var __webpack_exports__Line = __webpack_exports__.x12;
var __webpack_exports__Loader = __webpack_exports__.aNw;
var __webpack_exports__LockCameraToActorAxisStrategy = __webpack_exports__.xwn;
var __webpack_exports__LockCameraToActorStrategy = __webpack_exports__.dNK;
var __webpack_exports__LogLevel = __webpack_exports__.ini;
var __webpack_exports__Logger = __webpack_exports__.YdH;
var __webpack_exports__Matrix = __webpack_exports__.y3G;
var __webpack_exports__MatrixLocations = __webpack_exports__.l57;
var __webpack_exports__MediaEvent = __webpack_exports__.xn0;
var __webpack_exports__Meet = __webpack_exports__.t2V;
var __webpack_exports__MockedElement = __webpack_exports__.ZyS;
var __webpack_exports__MotionComponent = __webpack_exports__.uxB;
var __webpack_exports__MotionSystem = __webpack_exports__.cpd;
var __webpack_exports__MoveBy = __webpack_exports__.fiy;
var __webpack_exports__MoveTo = __webpack_exports__.$XZ;
var __webpack_exports__NativeSoundEvent = __webpack_exports__.uqK;
var __webpack_exports__NativeSoundProcessedEvent = __webpack_exports__.STE;
var __webpack_exports__Observable = __webpack_exports__.y$z;
var __webpack_exports__Pair = __webpack_exports__.sOq;
var __webpack_exports__ParseGif = __webpack_exports__.Sqs;
var __webpack_exports__Particle = __webpack_exports__.hpZ;
var __webpack_exports__ParticleEmitter = __webpack_exports__.Vol;
var __webpack_exports__Physics = __webpack_exports__.wIZ;
var __webpack_exports__PhysicsStats = __webpack_exports__.cBi;
var __webpack_exports__Polygon = __webpack_exports__.mgq;
var __webpack_exports__PolygonCollider = __webpack_exports__.YVA;
var __webpack_exports__Pool = __webpack_exports__.Kgp;
var __webpack_exports__PostCollisionEvent = __webpack_exports__.HH$;
var __webpack_exports__PostDebugDrawEvent = __webpack_exports__.M_d;
var __webpack_exports__PostDrawEvent = __webpack_exports__.rgh;
var __webpack_exports__PostFrameEvent = __webpack_exports__.Ra6;
var __webpack_exports__PostKillEvent = __webpack_exports__.KhR;
var __webpack_exports__PostUpdateEvent = __webpack_exports__.BS5;
var __webpack_exports__PreCollisionEvent = __webpack_exports__.xhz;
var __webpack_exports__PreDebugDrawEvent = __webpack_exports__.xOq;
var __webpack_exports__PreDrawEvent = __webpack_exports__.a9j;
var __webpack_exports__PreFrameEvent = __webpack_exports__.bHk;
var __webpack_exports__PreKillEvent = __webpack_exports__.CgK;
var __webpack_exports__PreUpdateEvent = __webpack_exports__.cuY;
var __webpack_exports__Projection = __webpack_exports__.kvE;
var __webpack_exports__Promise = __webpack_exports__.JDb;
var __webpack_exports__PromiseState = __webpack_exports__.Cbi;
var __webpack_exports__Query = __webpack_exports__.AE_;
var __webpack_exports__QueryManager = __webpack_exports__.ctO;
var __webpack_exports__RadiusAroundActorStrategy = __webpack_exports__.OLH;
var __webpack_exports__Random = __webpack_exports__.kky;
var __webpack_exports__Raster = __webpack_exports__.nSF;
var __webpack_exports__Ray = __webpack_exports__.zHn;
var __webpack_exports__RealisticSolver = __webpack_exports__.zwx;
var __webpack_exports__Rectangle = __webpack_exports__.AeJ;
var __webpack_exports__RemovedComponent = __webpack_exports__.hLz;
var __webpack_exports__RemovedEntity = __webpack_exports__.D9g;
var __webpack_exports__Repeat = __webpack_exports__.wA;
var __webpack_exports__RepeatForever = __webpack_exports__.jhr;
var __webpack_exports__Resolution = __webpack_exports__.GVs;
var __webpack_exports__Resource = __webpack_exports__._zO;
var __webpack_exports__RotateBy = __webpack_exports__.w6$;
var __webpack_exports__RotateTo = __webpack_exports__.mhV;
var __webpack_exports__RotationType = __webpack_exports__.MOD;
var __webpack_exports__ScaleBy = __webpack_exports__.kwd;
var __webpack_exports__ScaleTo = __webpack_exports__.Lmr;
var __webpack_exports__Scene = __webpack_exports__.xsS;
var __webpack_exports__Screen = __webpack_exports__.lLr;
var __webpack_exports__ScreenAppender = __webpack_exports__.Z$r;
var __webpack_exports__ScreenElement = __webpack_exports__.IXb;
var __webpack_exports__ScrollPreventionMode = __webpack_exports__.SMj;
var __webpack_exports__Shape = __webpack_exports__.bnF;
var __webpack_exports__Side = __webpack_exports__.MFA;
var __webpack_exports__SortedList = __webpack_exports__.$XC;
var __webpack_exports__Sound = __webpack_exports__.$uU;
var __webpack_exports__Sprite = __webpack_exports__.jyi;
var __webpack_exports__SpriteFont = __webpack_exports__.E03;
var __webpack_exports__SpriteSheet = __webpack_exports__.V6q;
var __webpack_exports__StrategyContainer = __webpack_exports__.nVo;
var __webpack_exports__Stream = __webpack_exports__.F6N;
var __webpack_exports__SubscribeEvent = __webpack_exports__.ad3;
var __webpack_exports__System = __webpack_exports__.xP7;
var __webpack_exports__SystemManager = __webpack_exports__.Odq;
var __webpack_exports__SystemType = __webpack_exports__.Zif;
var __webpack_exports__TagComponent = __webpack_exports__.ZGJ;
var __webpack_exports__Text = __webpack_exports__.xvT;
var __webpack_exports__TextAlign = __webpack_exports__.PHM;
var __webpack_exports__TileMap = __webpack_exports__.KwO;
var __webpack_exports__Timer = __webpack_exports__.B7y;
var __webpack_exports__Traits = __webpack_exports__.SFp;
var __webpack_exports__TransformComponent = __webpack_exports__.Uvn;
var __webpack_exports__TreeNode = __webpack_exports__.OFT;
var __webpack_exports__Trigger = __webpack_exports__.xzN;
var __webpack_exports__UnsubscribeEvent = __webpack_exports__.H6j;
var __webpack_exports__Util = __webpack_exports__.ZrN;
var __webpack_exports__Vector = __webpack_exports__.OWs;
var __webpack_exports__VectorView = __webpack_exports__.dF9;
var __webpack_exports__VisibleEvent = __webpack_exports__.VHo;
var __webpack_exports__WebAudioInstance = __webpack_exports__.R$E;
var __webpack_exports__World = __webpack_exports__.q3I;
var __webpack_exports__canonicalizeAngle = __webpack_exports__.Pab;
var __webpack_exports__clamp = __webpack_exports__.uZ5;
var __webpack_exports__createId = __webpack_exports__.McK;
var __webpack_exports__hasGraphicsTick = __webpack_exports__.k0b;
var __webpack_exports__hasOnInitialize = __webpack_exports__.hnT;
var __webpack_exports__hasOnPostUpdate = __webpack_exports__.RSJ;
var __webpack_exports__hasOnPreUpdate = __webpack_exports__.Mku;
var __webpack_exports__hasPostDraw = __webpack_exports__.h90;
var __webpack_exports__hasPreDraw = __webpack_exports__.rms;
var __webpack_exports__has_initialize = __webpack_exports__.ErP;
var __webpack_exports__has_postupdate = __webpack_exports__.aVg;
var __webpack_exports__has_preupdate = __webpack_exports__.lPc;
var __webpack_exports__isAddedComponent = __webpack_exports__.Z8E;
var __webpack_exports__isAddedSystemEntity = __webpack_exports__.NNA;
var __webpack_exports__isRemoveSystemEntity = __webpack_exports__.yFn;
var __webpack_exports__isRemovedComponent = __webpack_exports__.lNv;
var __webpack_exports__maxMessages = __webpack_exports__.MZQ;
var __webpack_exports__obsolete = __webpack_exports__.FUM;
var __webpack_exports__randomInRange = __webpack_exports__.vdf;
var __webpack_exports__randomIntInRange = __webpack_exports__.iaL;
var __webpack_exports__range = __webpack_exports__.w6H;
var __webpack_exports__resetObsoleteCounter = __webpack_exports__.Q4c;
var __webpack_exports__toDegrees = __webpack_exports__.Uxb;
var __webpack_exports__toRadians = __webpack_exports__.Yr5;
var __webpack_exports__vec = __webpack_exports__.Bhw;


//# sourceMappingURL=excalibur.js.map

/***/ }),

/***/ "./src/actors/player.ts":
/*!******************************!*\
  !*** ./src/actors/player.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Player)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.js");
/* harmony import */ var _resources__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources */ "./src/resources.ts");


class Player extends excalibur__WEBPACK_IMPORTED_MODULE_1__.Actor {
    constructor() {
        super({
            x: 64,
            y: 64,
            width: 64,
            height: 32,
            collisionType: excalibur__WEBPACK_IMPORTED_MODULE_1__.CollisionType.Active,
        });
    }
    onInitialize(_engine) {
        this.graphics.use(_resources__WEBPACK_IMPORTED_MODULE_0__.SpriteSheets.player_idle.sprites[0]);
    }
    onPostUpdate(engine, _delta) {
        if (engine.input.keyboard.isHeld(excalibur__WEBPACK_IMPORTED_MODULE_1__.Input.Keys.Right)) {
            this.move((0,excalibur__WEBPACK_IMPORTED_MODULE_1__.vec)(1, 0));
        }
        if (engine.input.keyboard.isHeld(excalibur__WEBPACK_IMPORTED_MODULE_1__.Input.Keys.Left)) {
            this.move((0,excalibur__WEBPACK_IMPORTED_MODULE_1__.vec)(-1, 0));
        }
        if (engine.input.keyboard.wasPressed(excalibur__WEBPACK_IMPORTED_MODULE_1__.Input.Keys.Space)) {
            this.vel.y -= 100;
        }
    }
    move(vec) {
        this.pos.x += vec.x;
        this.pos.y += vec.y;
    }
}


/***/ }),

/***/ "./src/resources.ts":
/*!**************************!*\
  !*** ./src/resources.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loader": () => (/* binding */ loader),
/* harmony export */   "SpriteSheets": () => (/* binding */ SpriteSheets)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.js");
/* harmony import */ var _assets_images_player_idle_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assets/images/player_idle.png */ "./assets/images/player_idle.png");


const Images = {
    playerIdle: new excalibur__WEBPACK_IMPORTED_MODULE_1__.ImageSource(_assets_images_player_idle_png__WEBPACK_IMPORTED_MODULE_0__),
};
const SpriteSheets = {
    player_idle: excalibur__WEBPACK_IMPORTED_MODULE_1__.SpriteSheet.fromImageSource({
        image: Images.playerIdle,
        grid: {
            columns: 1,
            rows: 1,
            spriteWidth: 64,
            spriteHeight: 32,
        },
    }),
};
const loader = new excalibur__WEBPACK_IMPORTED_MODULE_1__.Loader();
for (const image in Images) {
    loader.addResource(Images[image]);
}



/***/ }),

/***/ "./assets/images/player_idle.png":
/*!***************************************!*\
  !*** ./assets/images/player_idle.png ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "cd3ad3070e170a6f5e76.png";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.js");
/* harmony import */ var _actors_player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actors/player */ "./src/actors/player.ts");
/* harmony import */ var _resources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources */ "./src/resources.ts");



excalibur__WEBPACK_IMPORTED_MODULE_2__.Physics.acc = (0,excalibur__WEBPACK_IMPORTED_MODULE_2__.vec)(0, 500);
const game = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Engine({
    width: 800,
    height: 600,
});
game.start(_resources__WEBPACK_IMPORTED_MODULE_1__.loader);
const player = new _actors_player__WEBPACK_IMPORTED_MODULE_0__["default"]();
const ground = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Actor({
    pos: (0,excalibur__WEBPACK_IMPORTED_MODULE_2__.vec)(game.halfDrawWidth, game.drawHeight),
    width: game.drawHeight,
    height: 100,
    color: excalibur__WEBPACK_IMPORTED_MODULE_2__.Color.Green,
    collisionType: excalibur__WEBPACK_IMPORTED_MODULE_2__.CollisionType.Fixed,
});
game.add(ground);
game.add(player);

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyw4QkFBbUI7O0FBRTdELDhCQUFtQjtBQUNuQixrQkFBa0IsOEJBQW1COztBQUVyQzs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyw4QkFBbUI7O0FBRTdELDhCQUFtQjtBQUNuQixXQUFXLDhCQUFtQjs7QUFFOUI7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsOEJBQW1COztBQUU3RCxpQkFBaUIsOEJBQW1CO0FBQ3BDLGtCQUFrQiw4QkFBbUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxlQUFlLCtCQUFtQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELHNCQUFzQiwrQkFBbUI7QUFDekMsZUFBZSwrQkFBbUI7QUFDbEMsc0JBQXNCLCtCQUFtQjs7QUFFekMsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sV0FBVyxnQkFBZ0I7QUFDakM7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7O0FBRzdELFlBQVksK0JBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFELEdBQUc7QUFDSDs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0QsNEJBQTRCLCtCQUFtQjtBQUMvQyxpQkFBaUIsK0JBQW1CO0FBQ3BDLGlCQUFpQiwrQkFBbUI7QUFDcEMsc0JBQXNCLCtCQUFtQjs7QUFFekM7QUFDQTtBQUNBLGlEQUFpRCxtQkFBbUI7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELFVBQVUsK0JBQW1CO0FBQzdCLGNBQWMsK0JBQW1CO0FBQ2pDLHFDQUFxQywrQkFBbUI7QUFDeEQsMkJBQTJCLCtCQUFtQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0Qsa0JBQWtCLCtCQUFtQjtBQUNyQywyQkFBMkIsK0JBQW1CO0FBQzlDLCtCQUErQiwrQkFBbUI7O0FBRWxEO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELFlBQVksK0JBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxtQkFBbUIsYUFBYTtBQUN4RSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0QsYUFBYSwrQkFBbUI7QUFDaEMsZUFBZSwrQkFBbUI7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxnQkFBZ0IsK0JBQW1COztBQUVuQzs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELFNBQVMsK0JBQW1COztBQUU1Qjs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELGlCQUFpQiwrQkFBbUI7O0FBRXBDOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0QsYUFBYSwrQkFBbUI7QUFDaEMsZ0JBQWdCLCtCQUFtQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0QsZ0JBQWdCLCtCQUFtQjs7QUFFbkM7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxhQUFhLCtCQUFtQjtBQUNoQyxXQUFXLCtCQUFtQjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxhQUFhLCtCQUFtQjtBQUNoQywrQkFBK0IsK0JBQW1CO0FBQ2xELGtDQUFrQywrQkFBbUI7QUFDckQsZUFBZSwrQkFBbUI7QUFDbEMsZ0JBQWdCLCtCQUFtQjtBQUNuQyxnQ0FBZ0MsK0JBQW1CO0FBQ25ELGVBQWUsK0JBQW1COztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtREFBbUQ7QUFDbkQsSUFBSTtBQUNKLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxnQkFBZ0IsZ0NBQW1COztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGtCQUFrQixnQ0FBbUI7QUFDckMsVUFBVSxnQ0FBbUI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGFBQWEsZ0NBQW1CO0FBQ2hDLGlCQUFpQixnQ0FBbUI7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxnQkFBZ0IsZ0NBQW1COztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFtQixrQkFBa0IsZ0NBQW1CO0FBQ3ZFO0FBQ0EsaUJBQWlCLGNBQWM7OztBQUcvQixPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsZUFBZSxnQ0FBbUI7O0FBRWxDLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxrQkFBa0IsZ0NBQW1CO0FBQ3JDLFlBQVksZ0NBQW1CO0FBQy9CLG9CQUFvQixnQ0FBbUI7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLEdBQUc7QUFDSCxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsWUFBWSxnQ0FBbUI7QUFDL0IsY0FBYyxnQ0FBbUI7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxFQUFFOzs7QUFHRixPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsaUJBQWlCLGdDQUFtQjtBQUNwQyxZQUFZLGdDQUFtQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0Qsc0JBQXNCLGdDQUFtQjtBQUN6QyxhQUFhLGdDQUFtQjtBQUNoQyxlQUFlLGdDQUFtQjtBQUNsQyxrQ0FBa0MsZ0NBQW1CO0FBQ3JELGdCQUFnQixnQ0FBbUI7QUFDbkMsYUFBYSxnQ0FBbUI7QUFDaEMsZ0JBQWdCLGdDQUFtQjtBQUNuQyxpQkFBaUIsZ0NBQW1COztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELFlBQVksZ0NBQW1CO0FBQy9CLGlCQUFpQixnQ0FBbUI7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxpQkFBaUIsZ0NBQW1COztBQUVwQztBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGlCQUFpQixnQ0FBbUI7QUFDcEMsaUJBQWlCLGdDQUFtQjtBQUNwQyx3QkFBd0IsZ0NBQW1COztBQUUzQztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdEO0FBQ0EsaUJBQWlCLGdDQUFtQjtBQUNwQyxZQUFZLGdDQUFtQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxhQUFhLGdDQUFtQjtBQUNoQyxpQkFBaUIsZ0NBQW1CO0FBQ3BDLG9CQUFvQixnQ0FBbUI7O0FBRXZDOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0Qsa0JBQWtCLGdDQUFtQjtBQUNyQyxxQkFBcUIsZ0NBQW1CO0FBQ3hDLGVBQWUsZ0NBQW1CO0FBQ2xDLG9CQUFvQixnQ0FBbUI7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0Qsa0JBQWtCLGdDQUFtQjtBQUNyQyxpQ0FBaUMsZ0NBQW1CO0FBQ3BELCtCQUErQixnQ0FBbUI7QUFDbEQsc0JBQXNCLGdDQUFtQjtBQUN6QyxvQkFBb0IsZ0NBQW1CO0FBQ3ZDLFVBQVUsZ0NBQW1CO0FBQzdCLHFCQUFxQixnQ0FBbUI7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QseUJBQXlCLGdDQUFtQjtBQUM1QyxrQkFBa0IsZ0NBQW1COztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsVUFBVSxnQ0FBbUI7QUFDN0Isc0JBQXNCLGdDQUFtQjtBQUN6QyxjQUFjLGdDQUFtQjtBQUNqQyxpQkFBaUIsZ0NBQW1COztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCx5QkFBeUIsZ0NBQW1CO0FBQzVDLGtCQUFrQixnQ0FBbUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOzs7QUFHQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxNQUFNOztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0YsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGlCQUFpQixnQ0FBbUI7QUFDcEMsZUFBZSxnQ0FBbUI7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGlCQUFpQixnQ0FBbUI7QUFDcEMsZ0NBQWdDLGdDQUFtQjtBQUNuRCxrQ0FBa0MsZ0NBQW1CO0FBQ3JELGVBQWUsZ0NBQW1COztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxhQUFhLGdDQUFtQjs7QUFFaEM7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxhQUFhLGdDQUFtQjtBQUNoQyxpQkFBaUIsZ0NBQW1CO0FBQ3BDLFVBQVUsZ0NBQW1CO0FBQzdCLGtDQUFrQyxnQ0FBbUI7QUFDckQsZ0JBQWdCLGdDQUFtQjtBQUNuQyxvQkFBb0IsZ0NBQW1CO0FBQ3ZDLDBCQUEwQixnQ0FBbUI7QUFDN0MsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsYUFBYSxnQ0FBbUI7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBa0Q7QUFDM0YsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsYUFBYSxnQ0FBbUI7QUFDaEMsVUFBVSxnQ0FBbUI7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGFBQWEsZ0NBQW1CO0FBQ2hDLGdCQUFnQixnQ0FBbUI7O0FBRW5DO0FBQ0Esa0RBQWtEOztBQUVsRDs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGNBQWMsZ0NBQW1CO0FBQ2pDLFlBQVksZ0NBQW1COztBQUUvQjtBQUNBLHFFQUFxRTtBQUNyRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGdCQUFnQixnQ0FBbUI7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdEO0FBQ0Esb0JBQW9CLGdDQUFtQjtBQUN2Qyw2QkFBNkIsZ0NBQW1COztBQUVoRDtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxnQkFBZ0IsZ0NBQW1COztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCw2QkFBNkIsZ0NBQW1COztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsZUFBZSxnQ0FBbUI7QUFDbEMsZUFBZSxnQ0FBbUI7QUFDbEMsZ0JBQWdCLGdDQUFtQjtBQUNuQywwQkFBMEIsZ0NBQW1CO0FBQzdDLHNCQUFzQixnQ0FBbUI7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGtCQUFrQixnQ0FBbUI7QUFDckMsZUFBZSxnQ0FBbUI7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELHNCQUFzQixnQ0FBbUI7O0FBRXpDO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxjQUFjLGdDQUFtQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RDtBQUNBLG9CQUFvQixnQ0FBbUI7O0FBRXZDO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGFBQWEsZ0NBQW1CO0FBQ2hDLGFBQWEsZ0NBQW1CO0FBQ2hDLFVBQVUsZ0NBQW1CO0FBQzdCLFVBQVUsZ0NBQW1CO0FBQzdCLG9CQUFvQixnQ0FBbUI7QUFDdkMsd0JBQXdCLGdDQUFtQjs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwyREFBMkQsZ0NBQW1COzs7QUFHOUUsUUFBUSxnQ0FBbUI7QUFDM0IsZ0JBQWdCLGdDQUFtQjtBQUNuQyxlQUFlLGdDQUFtQjtBQUNsQyxlQUFlLGdDQUFtQjtBQUNsQyxlQUFlLGdDQUFtQjtBQUNsQyxZQUFZLGdDQUFtQjtBQUMvQixtQkFBbUIsZ0NBQW1CO0FBQ3RDLDBCQUEwQixnQ0FBbUI7QUFDN0MsU0FBUyxnQ0FBbUI7QUFDNUIsaUJBQWlCLGdDQUFtQjtBQUNwQyxTQUFTLGdDQUFtQjtBQUM1QixhQUFhLGdDQUFtQjs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsV0FBVztBQUM3Qjs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRCxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQyxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7O0FBRUEsOEJBQThCLG1CQUFtQjs7QUFFakQsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksOENBQThDO0FBQ2xEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBLDJEQUEyRCxnQ0FBbUI7O0FBRTlFLFFBQVEsZ0NBQW1CO0FBQzNCLGVBQWUsZ0NBQW1CO0FBQ2xDLGlCQUFpQixnQ0FBbUI7QUFDcEMsWUFBWSxnQ0FBbUI7O0FBRS9CLDhDQUE4QyxnQkFBZ0I7O0FBRTlEO0FBQ0E7QUFDQSxJQUFJLDJEQUEyRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EscUNBQXFDLGdDQUFtQjs7QUFFeEQscUJBQXFCLGdDQUFtQjtBQUN4QztBQUNBLHNCQUFzQjtBQUN0Qiw0R0FBNEcsZ0NBQW1CO0FBQy9ILGlJQUFpSSxnQ0FBbUI7QUFDcEoscUdBQXFHLGdDQUFtQjtBQUN4SCwwSEFBMEgsZ0NBQW1CO0FBQzdJOzs7QUFHQTtBQUNBO0FBQ0EsbUdBQW1HLDRCQUE0Qix5QkFBeUIsbUJBQW1CLHlCQUF5QixtQkFBbUIsMEJBQTBCLDRCQUE0QixrQ0FBa0MsdUNBQXVDLGdCQUFnQiw0QkFBNEIsMEJBQTBCLHFCQUFxQiw4QkFBOEIsc0JBQXNCLDBCQUEwQixxQkFBcUIsc0JBQXNCLHlCQUF5QixxRUFBcUUsK0JBQStCLDRCQUE0Qiw0REFBNEQsMEZBQTBGLHNFQUFzRSwwRUFBMEUsaUVBQWlFLEtBQUsscUNBQXFDLG9CQUFvQixLQUFLLHVDQUF1Qyx5QkFBeUIsa0JBQWtCLHdCQUF3Qiw4REFBOEQsaUJBQWlCLGdCQUFnQixlQUFlLGdCQUFnQixLQUFLLHNDQUFzQyx5QkFBeUIsa0JBQWtCLHdCQUF3QixpQkFBaUIsZ0JBQWdCLDBCQUEwQixrQkFBa0IsbUJBQW1CLEtBQUsscUVBQXFFLDBCQUEwQixLQUFLLHFDQUFxQyw4QkFBOEIsMkJBQTJCLEtBQUssc0NBQXNDLDZCQUE2QixLQUFLLDRDQUE0QyxZQUFZLG1CQUFtQixPQUFPLFVBQVUsbUJBQW1CLE9BQU8sS0FBSyx1RUFBdUUsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUssNkZBQTZGLFlBQVksbUJBQW1CLE9BQU8sVUFBVSxtQkFBbUIsT0FBTyxLQUFLLDJFQUEyRSxZQUFZLG1CQUFtQixPQUFPLFVBQVUsbUJBQW1CLE9BQU8sS0FBSyxxRUFBcUUsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUssV0FBVyxxRkFBcUYsTUFBTSxZQUFZLGFBQWEsV0FBVyxZQUFZLFdBQVcsTUFBTSxPQUFPLGFBQWEsV0FBVyxZQUFZLGFBQWEsV0FBVyxZQUFZLFdBQVcsWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLGFBQWEsY0FBYyx5QkFBeUIseUJBQXlCLHlCQUF5Qix5QkFBeUIsYUFBYSxPQUFPLE9BQU8sTUFBTSxLQUFLLFlBQVksV0FBVyxZQUFZLGFBQWEsV0FBVyxVQUFVLFVBQVUsVUFBVSxNQUFNLEtBQUssWUFBWSxXQUFXLFlBQVksV0FBVyxVQUFVLFlBQVksV0FBVyxVQUFVLE1BQU0sTUFBTSxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLGtGQUFrRiw0QkFBNEIseUJBQXlCLG1CQUFtQix5QkFBeUIsbUJBQW1CLDBCQUEwQiw0QkFBNEIsa0NBQWtDLHVDQUF1QyxnQkFBZ0IsNEJBQTRCLDBCQUEwQixxQkFBcUIsOEJBQThCLHNCQUFzQiwwQkFBMEIscUJBQXFCLHNCQUFzQix5QkFBeUIscUVBQXFFLCtCQUErQiw0QkFBNEIsNERBQTRELDBGQUEwRixzRUFBc0UsMEVBQTBFLGlFQUFpRSxLQUFLLHFDQUFxQyxvQkFBb0IsS0FBSyx1Q0FBdUMseUJBQXlCLGtCQUFrQix3QkFBd0IsOERBQThELGlCQUFpQixnQkFBZ0IsZUFBZSxnQkFBZ0IsS0FBSyxzQ0FBc0MseUJBQXlCLGtCQUFrQix3QkFBd0IsaUJBQWlCLGdCQUFnQiwwQkFBMEIsa0JBQWtCLG1CQUFtQixLQUFLLHFFQUFxRSwwQkFBMEIsS0FBSyxxQ0FBcUMsOEJBQThCLDJCQUEyQixLQUFLLHNDQUFzQyw2QkFBNkIsS0FBSyw0Q0FBNEMsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUssdUVBQXVFLFlBQVksbUJBQW1CLE9BQU8sVUFBVSxtQkFBbUIsT0FBTyxLQUFLLDZGQUE2RixZQUFZLG1CQUFtQixPQUFPLFVBQVUsbUJBQW1CLE9BQU8sS0FBSywyRUFBMkUsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUsscUVBQXFFLFlBQVksbUJBQW1CLE9BQU8sVUFBVSxtQkFBbUIsT0FBTyxLQUFLLHVCQUF1QjtBQUNobk07QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQSxxRkFBcUY7QUFDckY7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNGQUFzRixxQkFBcUI7QUFDM0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdDQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQ0FBbUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBbUIsYUFBYSxXQUFXO0FBQ3REO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdDQUFtQjtBQUM3QjtBQUNBLGVBQWUsZ0NBQW1CLHdCQUF3QixnQ0FBbUI7QUFDN0UsbURBQW1ELHdDQUF3QztBQUMzRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQW1CO0FBQzdCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQW1CO0FBQzdCO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsZ0NBQW1CO0FBQ25CLGdDQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsZ0NBQW1CO0FBQ25CLGdDQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxnQ0FBbUI7QUFDbkIsZ0NBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxnQ0FBbUI7QUFDbkIsZ0NBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGdDQUFtQjtBQUNuQixnQ0FBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxnQ0FBbUI7QUFDbkIsZ0NBQW1CO0FBQ25CO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxnQ0FBbUI7QUFDbkIsZ0NBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLGdDQUFtQjtBQUM5QjtBQUNBLFdBQVcsZ0NBQW1CO0FBQzlCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFckIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQixFQUFFLG1DQUFtQyxFQUFFLHlCQUF5QjtBQUNySCwyQkFBMkIsaUJBQWlCLHNCQUFzQixnQkFBZ0I7QUFDbEYsK0NBQStDLHlCQUF5QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCLElBQUksc0JBQXNCO0FBQ3ZFO0FBQ0EsbUJBQW1CLE9BQU8sSUFBSSxPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQW1FO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0hBQWtIO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDM0M7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLE9BQU87QUFDakY7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjO0FBQ2pFLEdBQUcsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYztBQUNqRSxHQUFHLGNBQWMsRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLGNBQWM7QUFDbEUsR0FBRyxjQUFjLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0QkFBNEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsNkVBQTZFLDJCQUEyQixrQ0FBa0MsOEJBQThCLHlCQUF5Qiw2R0FBNkcsNERBQTRELEtBQUs7QUFDL1csQ0FBQztBQUNELDZFQUE2RSw4Q0FBOEMseUJBQXlCLDZCQUE2QixLQUFLO0FBQ3RMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQThDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELDhFQUE4RSxpREFBaUQsNEJBQTRCLCtCQUErQix5QkFBeUIsc0RBQXNELDRCQUE0QixpRUFBaUUsc0NBQXNDLDhCQUE4Qix5QkFBeUIsNkdBQTZHLDBGQUEwRix5RkFBeUYsdUdBQXVHLGdGQUFnRixLQUFLO0FBQy81QixDQUFDO0FBQ0QsaUxBQWlMLCtDQUErQyw4REFBOEQsd0VBQXdFLDhDQUE4QyxnREFBZ0QsbURBQW1ELGlDQUFpQyxzQ0FBc0MsOEJBQThCLGlFQUFpRSxLQUFLLHFCQUFxQiw4Q0FBOEMsbVBBQW1QLDhIQUE4SCx5QkFBeUIsdUNBQXVDLG9FQUFvRSxrQ0FBa0MseUJBQXlCLHFEQUFxRCxTQUFTLE1BQU0sc0hBQXNILHFDQUFxQyw0QkFBNEIsS0FBSztBQUNyaEQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSxpRUFBaUUsRUFBRSxLQUFLO0FBQ3hFO0FBQ0E7QUFDQSx5RUFBeUUsRUFBRSxLQUFLO0FBQ2hGO0FBQ0EsMEVBQTBFLEVBQUUsZUFBZTtBQUMzRix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELDhFQUE4RSwyQkFBMkIsMkJBQTJCLDhCQUE4QiwwQkFBMEIscUJBQXFCLDBDQUEwQyxrQ0FBa0Msd0JBQXdCLEtBQUs7QUFDMVQsQ0FBQztBQUNELHFMQUFxTCw4QkFBOEIscUJBQXFCLDhDQUE4QywyQ0FBMkMsd0JBQXdCLG9FQUFvRSw0REFBNEQsNkJBQTZCLGdCQUFnQixPQUFPLG9FQUFvRSxLQUFLO0FBQ3RsQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBK0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakUsZ0NBQWdDLGNBQWMseUJBQXlCLGtCQUFrQjtBQUN6RjtBQUNBO0FBQ0EsZ0dBQWdHLFdBQVcsb0JBQW9CLGFBQWE7QUFDNUk7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FLGdDQUFnQyxlQUFlLHlCQUF5QixrQkFBa0I7QUFDMUY7QUFDQTtBQUNBLGtHQUFrRyxZQUFZLHFCQUFxQixjQUFjO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDLGdDQUFnQyxpQkFBaUI7QUFDakQsb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0dBQW9HLGdDQUFnQyxjQUFjLG10QkFBbXRCO0FBQ3IzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEMsdUZBQXVGO0FBQ3ZGLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJDQUEyQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtDQUErQyw4Q0FBOEMsa0JBQWtCO0FBQ3pKO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLEtBQUs7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFVBQVUsZ0JBQWdCLGNBQWM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsY0FBYywrb0JBQStvQjtBQUN2dEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0IsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWMsU0FBUyxjQUFjLFdBQVcsK0JBQStCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVcsU0FBUyxlQUFlLFdBQVcsZ0NBQWdDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0Msa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFVBQVU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxHQUFHLDBCQUEwQixpQkFBaUI7QUFDdkk7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLEVBQUUsSUFBSSxFQUFFLFFBQVEsR0FBRywwQkFBMEIsY0FBYztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWUsZ0RBQWdELGFBQWEseUJBQXlCO0FBQ3JILCtDQUErQyxZQUFZO0FBQzNELCtDQUErQyxZQUFZO0FBQzNELHdCQUF3QixVQUFVO0FBQ2xDLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGdDQUFnQztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBMEQ7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQ0FBbUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxPQUFPLDRCQUE0QixTQUFTO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxPQUFPLGNBQWMsWUFBWTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsQ0FBQztBQUNELGlFQUFpRTtBQUNqRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvQkFBb0I7QUFDdEUsb0VBQW9FO0FBQ3BFLHFGQUFxRjtBQUNyRixzRkFBc0Y7QUFDdEYscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2QkFBNkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2RUFBNkU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHFFQUFxRTtBQUM1SCxxREFBcUQscUVBQXFFO0FBQzFILHVEQUF1RCxxRUFBcUU7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Ysd0JBQXdCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRDQUE0QztBQUM1QywwRUFBMEUsc0JBQXNCLEdBQUcsdUJBQXVCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELGtFQUFrRTtBQUNsRTtBQUNBLGVBQWUsZ0NBQW1CO0FBQ2xDLENBQUM7QUFDRDtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwQkFBMEI7QUFDdEYsMkRBQTJELDBCQUEwQjtBQUNyRjtBQUNBO0FBQ0EsNERBQTRELHlDQUF5QztBQUNyRywyREFBMkQsZ0RBQWdEO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0NBQW9DO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyw4Q0FBOEM7QUFDOUMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsOENBQThDO0FBQzlDLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDOztBQUV2QyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0VBQWtFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVSxHQUFHLFVBQVU7QUFDOUM7QUFDQTtBQUNBLHVCQUF1QixVQUFVLEdBQUcsVUFBVTtBQUM5QztBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixnQkFBZ0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixhQUFhO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixnQkFBZ0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLGdCQUFnQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxJQUFJO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsY0FBYztBQUNyRztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQsZ0JBQWdCLDJGQUEyRjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsd0NBQXdDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUpBQXlKLGtCQUFrQjtBQUMzTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLElBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxJQUFJO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxJQUFJO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLElBQUk7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2REFBNkQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLElBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csSUFBSTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9HQUFvRztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4RUFBOEU7QUFDN0Y7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsdUVBQXVFLDZCQUE2QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQXVEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxRUFBcUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLElBQUk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLElBQUk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNFQUFzRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0RBQWdELDZGQUE2RjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxJQUFJO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLDBCQUEwQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw0QkFBNEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQ0FBMEM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0lBQWdJO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZSQUE2UixrQkFBa0I7QUFDL1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsMENBQTBDO0FBQ25ILCtEQUErRCxtQkFBbUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEdBQUcsSUFBSSwySkFBMko7QUFDak87QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usa0NBQWtDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGdCQUFnQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsbUJBQW1CO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxpQkFBaUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLDZDQUE2QztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCx1QkFBdUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxxQ0FBcUM7QUFDbko7QUFDQSxpRkFBaUYsa0JBQWtCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLHFDQUFxQztBQUMvSTtBQUNBLDZFQUE2RSxzQkFBc0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHVEQUF1RDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtCQUFrQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLElBQUk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsSUFBSTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxJQUFJO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLElBQUk7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLG1GQUFtRjtBQUNsRztBQUNBO0FBQ0EsZUFBZSxzRkFBc0Y7QUFDckc7QUFDQTtBQUNBLGVBQWUsbUZBQW1GO0FBQ2xHO0FBQ0E7QUFDQSxlQUFlLHNGQUFzRjtBQUNyRzs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2QyxxQ0FBcUM7QUFDckMsMEJBQTBCO0FBQzFCO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsOENBQThDO0FBQzlDLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGNBQWM7QUFDZCx3REFBd0Q7QUFDeEQ7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMEJBQTBCO0FBQzFCLHNEQUFzRDtBQUN0RDtBQUNBLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxvRUFBb0U7QUFDcEUsMkRBQTJEO0FBQzNEO0FBQ0Esd0JBQXdCO0FBQ3hCLG1GQUFtRjtBQUNuRixxRkFBcUY7QUFDckYsd0ZBQXdGO0FBQ3hGLDJCQUEyQjtBQUMzQixtQ0FBbUM7QUFDbkMsNkJBQTZCO0FBQzdCLGdDQUFnQztBQUNoQyw2REFBNkQ7QUFDN0QsNkRBQTZEO0FBQzdELHlDQUF5QztBQUN6QyxnQ0FBZ0M7QUFDaEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsNkJBQTZCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxvRUFBb0U7QUFDcEUsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCwyREFBMkQ7QUFDM0Qsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBLGdIQUFnSDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsU0FBUztBQUNULDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxTQUFTO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHFCQUFxQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7O0FBRXJCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2RUFBNkU7QUFDN0Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVcsMEJBQTBCLGNBQWMsb0JBQW9CLGVBQWUsa0JBQWtCLGtCQUFrQjtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILCtDQUErQztBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3RkFBd0Y7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFpRDtBQUNoRTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSw2REFBNkQ7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esa0JBQWtCLFlBQVksRUFBRSx5QkFBeUIsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFlBQVk7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJDQUEyQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCO0FBQ3ZFO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0dBQW9HLGdDQUFnQyxjQUFjLDB0QkFBMHRCO0FBQzUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0Msb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwyQ0FBMkM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0dBQWdHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQWlEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzArVzs7QUFFMStXOzs7Ozs7Ozs7Ozs7Ozs7O0FDenM0QjZFO0FBQ2pDO0FBRTdCLE1BQU0sTUFBTyxTQUFRLDRDQUFLO0lBQ3ZDO1FBQ0UsS0FBSyxDQUFDO1lBQ0osQ0FBQyxFQUFFLEVBQUU7WUFDTCxDQUFDLEVBQUUsRUFBRTtZQUNMLEtBQUssRUFBRSxFQUFFO1lBQ1QsTUFBTSxFQUFFLEVBQUU7WUFDVixhQUFhLEVBQUUsMkRBQW9CO1NBQ3BDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTSxZQUFZLENBQUMsT0FBZTtRQUNqQyxJQUFJLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQywyRUFBbUMsQ0FBQyxDQUFDO0lBQ3pELENBQUM7SUFFTSxZQUFZLENBQUMsTUFBYyxFQUFFLE1BQWM7UUFDaEQsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsdURBQWdCLENBQUMsRUFBRTtZQUNsRCxJQUFJLENBQUMsSUFBSSxDQUFDLDhDQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEI7UUFFRCxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxzREFBZSxDQUFDLEVBQUU7WUFDakQsSUFBSSxDQUFDLElBQUksQ0FBQyw4Q0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdkI7UUFFRCxJQUFJLE1BQU0sQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyx1REFBZ0IsQ0FBQyxFQUFFO1lBQ3RELElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQztTQUNuQjtJQUNILENBQUM7SUFFTyxJQUFJLENBQUMsR0FBVztRQUN0QixJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3BCLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdEIsQ0FBQztDQUNGOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNwQzREO0FBQ0M7QUFFOUQsTUFBTSxNQUFNLEdBQW1DO0lBQzdDLFVBQVUsRUFBRSxJQUFJLGtEQUFXLENBQUMsMkRBQWMsQ0FBQztDQUM1QyxDQUFDO0FBRUYsTUFBTSxZQUFZLEdBQW1DO0lBQ25ELFdBQVcsRUFBRSxrRUFBMkIsQ0FBQztRQUN2QyxLQUFLLEVBQUUsTUFBTSxDQUFDLFVBQVU7UUFDeEIsSUFBSSxFQUFFO1lBQ0osT0FBTyxFQUFFLENBQUM7WUFDVixJQUFJLEVBQUUsQ0FBQztZQUNQLFdBQVcsRUFBRSxFQUFFO1lBQ2YsWUFBWSxFQUFFLEVBQUU7U0FDakI7S0FDRixDQUFDO0NBQ0gsQ0FBQztBQUVGLE1BQU0sTUFBTSxHQUFHLElBQUksNkNBQU0sRUFBRSxDQUFDO0FBQzVCLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFO0lBQzFCLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDbkM7QUFFK0I7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDeEJoQztVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7Ozs7Ozs7Ozs7Ozs7QUNmOEU7QUFDekM7QUFDQTtBQUVyQyxrREFBVyxHQUFHLDhDQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO0FBRTFCLE1BQU0sSUFBSSxHQUFHLElBQUksNkNBQU0sQ0FBQztJQUN0QixLQUFLLEVBQUUsR0FBRztJQUNWLE1BQU0sRUFBRSxHQUFHO0NBQ1osQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLEtBQUssQ0FBQyw4Q0FBTSxDQUFDLENBQUM7QUFFbkIsTUFBTSxNQUFNLEdBQUcsSUFBSSxzREFBTSxFQUFFLENBQUM7QUFDNUIsTUFBTSxNQUFNLEdBQUcsSUFBSSw0Q0FBSyxDQUFDO0lBQ3ZCLEdBQUcsRUFBRSw4Q0FBRyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUM3QyxLQUFLLEVBQUUsSUFBSSxDQUFDLFVBQVU7SUFDdEIsTUFBTSxFQUFFLEdBQUc7SUFDWCxLQUFLLEVBQUUsa0RBQVc7SUFDbEIsYUFBYSxFQUFFLDBEQUFtQjtDQUNuQyxDQUFDLENBQUM7QUFFSCxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0FBQ2pCLElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcmFua2llLy4vbm9kZV9tb2R1bGVzL2V4Y2FsaWJ1ci9idWlsZC9lc20vZXhjYWxpYnVyLmpzIiwid2VicGFjazovL2ZyYW5raWUvLi9zcmMvYWN0b3JzL3BsYXllci50cyIsIndlYnBhY2s6Ly9mcmFua2llLy4vc3JjL3Jlc291cmNlcy50cyIsIndlYnBhY2s6Ly9mcmFua2llL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2ZyYW5raWUvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2ZyYW5raWUvd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly9mcmFua2llL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vZnJhbmtpZS93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2ZyYW5raWUvd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vZnJhbmtpZS8uL3NyYy9pbmRleC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIGV4Y2FsaWJ1ciAtIDAuMjUuMSAtIDIwMjEtMTEtNVxuICogaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1clxuICogQ29weXJpZ2h0IChjKSAyMDIxIEV4Y2FsaWJ1ci5qcyA8aHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9ncmFwaHMvY29udHJpYnV0b3JzPlxuICogTGljZW5zZWQgQlNELTItQ2xhdXNlXG4gKiBAcHJlc2VydmVcbiAqL1xuLyoqKioqKi8gdmFyIF9fd2VicGFja19tb2R1bGVzX18gPSAoe1xuXG4vKioqLyA0NjYyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM0MzApO1xudmFyIGVudHJ5VW5iaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NzkxKTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbnRyeVVuYmluZCgnQXJyYXknLCAnc29ydCcpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MzQzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQ3NjkpO1xudmFyIHBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkyNzYpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LmtleXM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcxMTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcbnZhciB0cnlUb1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oOTgyMSk7XG5cbi8vIGBBc3NlcnQ6IElzQ2FsbGFibGUoYXJndW1lbnQpIGlzIHRydWVgXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICBpZiAoaXNDYWxsYWJsZShhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgVHlwZUVycm9yKHRyeVRvU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDExNzY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTA1Mik7XG5cbi8vIGBBc3NlcnQ6IFR5cGUoYXJndW1lbnQpIGlzIE9iamVjdGBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc09iamVjdChhcmd1bWVudCkpIHJldHVybiBhcmd1bWVudDtcbiAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhbiBvYmplY3QnKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk1NDA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwNSk7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMzcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd2VicGFja19yZXF1aXJlX18oMzIzMSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICBpZiAoSVNfSU5DTFVERVMgJiYgZWwgIT0gZWwpIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgICAgdmFsdWUgPSBPW2luZGV4KytdO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZSAtLSBOYU4gY2hlY2tcbiAgICAgIGlmICh2YWx1ZSAhPSB2YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgLy8gQXJyYXkjaW5kZXhPZiBpZ25vcmVzIGhvbGVzLCBBcnJheSNpbmNsdWRlcyAtIG5vdFxuICAgIH0gZWxzZSBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgIH0gcmV0dXJuICFJU19JTkNMVURFUyAmJiAtMTtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5jbHVkZXNcbiAgaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmRleE9mYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MDM4OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIyOSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FLCBhcmd1bWVudCkge1xuICB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuICByZXR1cm4gISFtZXRob2QgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNhbGwsbm8tdGhyb3ctbGl0ZXJhbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICAgIG1ldGhvZC5jYWxsKG51bGwsIGFyZ3VtZW50IHx8IGZ1bmN0aW9uICgpIHsgdGhyb3cgMTsgfSwgMSk7XG4gIH0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzg2Nzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbi8vIFRPRE86IHVzZSBzb21ldGhpbmcgbW9yZSBjb21wbGV4IGxpa2UgdGltc29ydD9cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbnZhciBtZXJnZVNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgbWlkZGxlID0gZmxvb3IobGVuZ3RoIC8gMik7XG4gIHJldHVybiBsZW5ndGggPCA4ID8gaW5zZXJ0aW9uU29ydChhcnJheSwgY29tcGFyZWZuKSA6IG1lcmdlKFxuICAgIG1lcmdlU29ydChhcnJheS5zbGljZSgwLCBtaWRkbGUpLCBjb21wYXJlZm4pLFxuICAgIG1lcmdlU29ydChhcnJheS5zbGljZShtaWRkbGUpLCBjb21wYXJlZm4pLFxuICAgIGNvbXBhcmVmblxuICApO1xufTtcblxudmFyIGluc2VydGlvblNvcnQgPSBmdW5jdGlvbiAoYXJyYXksIGNvbXBhcmVmbikge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgaSA9IDE7XG4gIHZhciBlbGVtZW50LCBqO1xuXG4gIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gICAgaiA9IGk7XG4gICAgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgIHdoaWxlIChqICYmIGNvbXBhcmVmbihhcnJheVtqIC0gMV0sIGVsZW1lbnQpID4gMCkge1xuICAgICAgYXJyYXlbal0gPSBhcnJheVstLWpdO1xuICAgIH1cbiAgICBpZiAoaiAhPT0gaSsrKSBhcnJheVtqXSA9IGVsZW1lbnQ7XG4gIH0gcmV0dXJuIGFycmF5O1xufTtcblxudmFyIG1lcmdlID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0LCBjb21wYXJlZm4pIHtcbiAgdmFyIGxsZW5ndGggPSBsZWZ0Lmxlbmd0aDtcbiAgdmFyIHJsZW5ndGggPSByaWdodC5sZW5ndGg7XG4gIHZhciBsaW5kZXggPSAwO1xuICB2YXIgcmluZGV4ID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlIChsaW5kZXggPCBsbGVuZ3RoIHx8IHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICBpZiAobGluZGV4IDwgbGxlbmd0aCAmJiByaW5kZXggPCBybGVuZ3RoKSB7XG4gICAgICByZXN1bHQucHVzaChjb21wYXJlZm4obGVmdFtsaW5kZXhdLCByaWdodFtyaW5kZXhdKSA8PSAwID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK10pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucHVzaChsaW5kZXggPCBsbGVuZ3RoID8gbGVmdFtsaW5kZXgrK10gOiByaWdodFtyaW5kZXgrK10pO1xuICAgIH1cbiAgfSByZXR1cm4gcmVzdWx0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBtZXJnZVNvcnQ7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDcwNzk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE1ODk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBUT19TVFJJTkdfVEFHX1NVUFBPUlQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2MDEpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MzMpO1xudmFyIGNsYXNzb2ZSYXcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNzkpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbi8vIEVTMyB3cm9uZyBoZXJlXG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA9PSAnQXJndW1lbnRzJztcblxuLy8gZmFsbGJhY2sgZm9yIElFMTEgU2NyaXB0IEFjY2VzcyBEZW5pZWQgZXJyb3JcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICB0cnkge1xuICAgIHJldHVybiBpdFtrZXldO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG4vLyBnZXR0aW5nIHRhZyBmcm9tIEVTNisgYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgXG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8sIHRhZywgcmVzdWx0O1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCdcbiAgICAvLyBAQHRvU3RyaW5nVGFnIGNhc2VcbiAgICA6IHR5cGVvZiAodGFnID0gdHJ5R2V0KE8gPSBPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWdcbiAgICAvLyBidWlsdGluVGFnIGNhc2VcbiAgICA6IENPUlJFQ1RfQVJHVU1FTlRTID8gY2xhc3NvZlJhdyhPKVxuICAgIC8vIEVTMyBhcmd1bWVudHMgZmFsbGJhY2tcbiAgICA6IChyZXN1bHQgPSBjbGFzc29mUmF3KE8pKSA9PSAnT2JqZWN0JyAmJiBpc0NhbGxhYmxlKE8uY2FsbGVlKSA/ICdBcmd1bWVudHMnIDogcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzA4MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oODE2KTtcbnZhciBvd25LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0ODI2KTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5MzMpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNzg3KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXModGFyZ2V0LCBrZXkpKSBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU3NjI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQwMCk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3ODcpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNTM1OCk7XG5cbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgPyBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gIG9iamVjdFtrZXldID0gdmFsdWU7XG4gIHJldHVybiBvYmplY3Q7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MzU4OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzQwMDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjI5KTtcblxuLy8gRGV0ZWN0IElFOCdzIGluY29tcGxldGUgZGVmaW5lUHJvcGVydHkgaW1wbGVtZW50YXRpb25cbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAxLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KVsxXSAhPSA3O1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2MzU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDUyKTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2NzE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciB1c2VyQWdlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5OCk7XG5cbnZhciBmaXJlZm94ID0gdXNlckFnZW50Lm1hdGNoKC9maXJlZm94XFwvKFxcZCspL2kpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICEhZmlyZWZveCAmJiArZmlyZWZveFsxXTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODUwNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIFVBID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IC9NU0lFfFRyaWRlbnQvLnRlc3QoVUEpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1OTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzMzKTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCduYXZpZ2F0b3InLCAndXNlckFnZW50JykgfHwgJyc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYzNTg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oNTk4KTtcblxudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBEZW5vID0gZ2xvYmFsLkRlbm87XG52YXIgdmVyc2lvbnMgPSBwcm9jZXNzICYmIHByb2Nlc3MudmVyc2lvbnMgfHwgRGVubyAmJiBEZW5vLnZlcnNpb247XG52YXIgdjggPSB2ZXJzaW9ucyAmJiB2ZXJzaW9ucy52ODtcbnZhciBtYXRjaCwgdmVyc2lvbjtcblxuaWYgKHY4KSB7XG4gIG1hdGNoID0gdjguc3BsaXQoJy4nKTtcbiAgdmVyc2lvbiA9IG1hdGNoWzBdIDwgNCA/IDEgOiBtYXRjaFswXSArIG1hdGNoWzFdO1xufSBlbHNlIGlmICh1c2VyQWdlbnQpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0VkZ2VcXC8oXFxkKykvKTtcbiAgaWYgKCFtYXRjaCB8fCBtYXRjaFsxXSA+PSA3NCkge1xuICAgIG1hdGNoID0gdXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oXFxkKykvKTtcbiAgICBpZiAobWF0Y2gpIHZlcnNpb24gPSBtYXRjaFsxXTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlcnNpb24gJiYgK3ZlcnNpb247XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk4MTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciB1c2VyQWdlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5OCk7XG5cbnZhciB3ZWJraXQgPSB1c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLyk7XG5cbm1vZHVsZS5leHBvcnRzID0gISF3ZWJraXQgJiYgK3dlYmtpdFsxXTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODc5MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTg1OSk7XG52YXIgYmluZCA9IF9fd2VicGFja19yZXF1aXJlX18oNzYzNik7XG5cbnZhciBjYWxsID0gRnVuY3Rpb24uY2FsbDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1IsIE1FVEhPRCwgbGVuZ3RoKSB7XG4gIHJldHVybiBiaW5kKGNhbGwsIGdsb2JhbFtDT05TVFJVQ1RPUl0ucHJvdG90eXBlW01FVEhPRF0sIGxlbmd0aCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzODM3OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLy8gSUU4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IFtcbiAgJ2NvbnN0cnVjdG9yJyxcbiAgJ2hhc093blByb3BlcnR5JyxcbiAgJ2lzUHJvdG90eXBlT2YnLFxuICAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICAndG9Mb2NhbGVTdHJpbmcnLFxuICAndG9TdHJpbmcnLFxuICAndmFsdWVPZidcbl07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMxMDM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNzkzMykuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3NjIpO1xudmFyIHJlZGVmaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDg3KTtcbnZhciBzZXRHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNzkpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwODEpO1xudmFyIGlzRm9yY2VkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NTQxKTtcblxuLypcbiAgb3B0aW9ucy50YXJnZXQgICAgICAtIG5hbWUgb2YgdGhlIHRhcmdldCBvYmplY3RcbiAgb3B0aW9ucy5nbG9iYWwgICAgICAtIHRhcmdldCBpcyB0aGUgZ2xvYmFsIG9iamVjdFxuICBvcHRpb25zLnN0YXQgICAgICAgIC0gZXhwb3J0IGFzIHN0YXRpYyBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnByb3RvICAgICAgIC0gZXhwb3J0IGFzIHByb3RvdHlwZSBtZXRob2RzIG9mIHRhcmdldFxuICBvcHRpb25zLnJlYWwgICAgICAgIC0gcmVhbCBwcm90b3R5cGUgbWV0aG9kIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy5mb3JjZWQgICAgICAtIGV4cG9ydCBldmVuIGlmIHRoZSBuYXRpdmUgZmVhdHVyZSBpcyBhdmFpbGFibGVcbiAgb3B0aW9ucy5iaW5kICAgICAgICAtIGJpbmQgbWV0aG9kcyB0byB0aGUgdGFyZ2V0LCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMud3JhcCAgICAgICAgLSB3cmFwIGNvbnN0cnVjdG9ycyB0byBwcmV2ZW50aW5nIGdsb2JhbCBwb2xsdXRpb24sIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy51bnNhZmUgICAgICAtIHVzZSB0aGUgc2ltcGxlIGFzc2lnbm1lbnQgb2YgcHJvcGVydHkgaW5zdGVhZCBvZiBkZWxldGUgKyBkZWZpbmVQcm9wZXJ0eVxuICBvcHRpb25zLnNoYW0gICAgICAgIC0gYWRkIGEgZmxhZyB0byBub3QgY29tcGxldGVseSBmdWxsIHBvbHlmaWxsc1xuICBvcHRpb25zLmVudW1lcmFibGUgIC0gZXhwb3J0IGFzIGVudW1lcmFibGUgcHJvcGVydHlcbiAgb3B0aW9ucy5ub1RhcmdldEdldCAtIHByZXZlbnQgY2FsbGluZyBhIGdldHRlciBvbiB0YXJnZXRcbiAgb3B0aW9ucy5uYW1lICAgICAgICAtIHRoZSAubmFtZSBvZiB0aGUgZnVuY3Rpb24gaWYgaXQgZG9lcyBub3QgbWF0Y2ggdGhlIGtleVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuICB2YXIgVEFSR0VUID0gb3B0aW9ucy50YXJnZXQ7XG4gIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiAgdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiAgdmFyIEZPUkNFRCwgdGFyZ2V0LCBrZXksIHRhcmdldFByb3BlcnR5LCBzb3VyY2VQcm9wZXJ0eSwgZGVzY3JpcHRvcjtcbiAgaWYgKEdMT0JBTCkge1xuICAgIHRhcmdldCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgICB0YXJnZXQgPSBnbG9iYWxbVEFSR0VUXSB8fCBzZXRHbG9iYWwoVEFSR0VULCB7fSk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0ID0gKGdsb2JhbFtUQVJHRVRdIHx8IHt9KS5wcm90b3R5cGU7XG4gIH1cbiAgaWYgKHRhcmdldCkgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgc291cmNlUHJvcGVydHkgPSBzb3VyY2Vba2V5XTtcbiAgICBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSk7XG4gICAgICB0YXJnZXRQcm9wZXJ0eSA9IGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2UgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgICBGT1JDRUQgPSBpc0ZvcmNlZChHTE9CQUwgPyBrZXkgOiBUQVJHRVQgKyAoU1RBVElDID8gJy4nIDogJyMnKSArIGtleSwgb3B0aW9ucy5mb3JjZWQpO1xuICAgIC8vIGNvbnRhaW5lZCBpbiB0YXJnZXRcbiAgICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIHNvdXJjZVByb3BlcnR5ID09PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpIGNvbnRpbnVlO1xuICAgICAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhzb3VyY2VQcm9wZXJ0eSwgdGFyZ2V0UHJvcGVydHkpO1xuICAgIH1cbiAgICAvLyBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gICAgaWYgKG9wdGlvbnMuc2hhbSB8fCAodGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQyMjk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NjM2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MTExKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFDYWxsYWJsZShmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcbiAgICB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTgwNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDAwKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNik7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXREZXNjcmlwdG9yID0gREVTQ1JJUFRPUlMgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxudmFyIEVYSVNUUyA9IGhhcyhGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKTtcbi8vIGFkZGl0aW9uYWwgcHJvdGVjdGlvbiBmcm9tIG1pbmlmaWVkIC8gbWFuZ2xlZCAvIGRyb3BwZWQgZnVuY3Rpb24gbmFtZXNcbnZhciBQUk9QRVIgPSBFWElTVFMgJiYgKGZ1bmN0aW9uIHNvbWV0aGluZygpIHsgLyogZW1wdHkgKi8gfSkubmFtZSA9PT0gJ3NvbWV0aGluZyc7XG52YXIgQ09ORklHVVJBQkxFID0gRVhJU1RTICYmICghREVTQ1JJUFRPUlMgfHwgKERFU0NSSVBUT1JTICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJykuY29uZmlndXJhYmxlKSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBFWElTVFM6IEVYSVNUUyxcbiAgUFJPUEVSOiBQUk9QRVIsXG4gIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMzMzOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcblxudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNDYWxsYWJsZShhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSkgOiBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTMwMDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzExMSk7XG5cbi8vIGBHZXRNZXRob2RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1nZXRtZXRob2Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFYsIFApIHtcbiAgdmFyIGZ1bmMgPSBWW1BdO1xuICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYUNhbGxhYmxlKGZ1bmMpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTg1OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxubW9kdWxlLmV4cG9ydHMgPVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tZ2xvYmFsLXRoaXMgLS0gc2FmZVxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fFxuICBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtZ2xvYmFscyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBzZWxmID09ICdvYmplY3QnICYmIHNlbGYpIHx8XG4gIGNoZWNrKHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPT0gJ29iamVjdCcgJiYgX193ZWJwYWNrX3JlcXVpcmVfXy5nKSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmMgLS0gZmFsbGJhY2tcbiAgKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCkgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODE2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5OTEpO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuaGFzT3duIHx8IGZ1bmN0aW9uIGhhc093bihpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHRvT2JqZWN0KGl0KSwga2V5KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU5Nzc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0Mzk0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0MDApO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjI5KTtcbnZhciBjcmVhdGVFbGVtZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjM1KTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSByZXF1aWVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTMzNzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjI5KTtcbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MDc5KTtcblxudmFyIHNwbGl0ID0gJycuc3BsaXQ7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zIC0tIHNhZmVcbiAgcmV0dXJuICFPYmplY3QoJ3onKS5wcm9wZXJ0eUlzRW51bWVyYWJsZSgwKTtcbn0pID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjbGFzc29mKGl0KSA9PSAnU3RyaW5nJyA/IHNwbGl0LmNhbGwoaXQsICcnKSA6IE9iamVjdChpdCk7XG59IDogT2JqZWN0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NTExOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjczMyk7XG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzNTMpO1xuXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnRvU3RyaW5nO1xuXG4vLyB0aGlzIGhlbHBlciBicm9rZW4gaW4gYGNvcmUtanNAMy40LjEtMy40LjRgLCBzbyB3ZSBjYW4ndCB1c2UgYHNoYXJlZGAgaGVscGVyXG5pZiAoIWlzQ2FsbGFibGUoc3RvcmUuaW5zcGVjdFNvdXJjZSkpIHtcbiAgc3RvcmUuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBmdW5jdGlvblRvU3RyaW5nLmNhbGwoaXQpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY0MDc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBOQVRJVkVfV0VBS19NQVAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg2OTQpO1xudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTg1OSk7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNTIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNTc2Mik7XG52YXIgb2JqZWN0SGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTYpO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTM1Myk7XG52YXIgc2hhcmVkS2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mzk5KTtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTc3KTtcblxudmFyIE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEID0gJ09iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkJztcbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcblxudmFyIGVuZm9yY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xuXG52YXIgZ2V0dGVyRm9yID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBzdGF0ZTtcbiAgICBpZiAoIWlzT2JqZWN0KGl0KSB8fCAoc3RhdGUgPSBnZXQoaXQpKS50eXBlICE9PSBUWVBFKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29tcGF0aWJsZSByZWNlaXZlciwgJyArIFRZUEUgKyAnIHJlcXVpcmVkJyk7XG4gICAgfSByZXR1cm4gc3RhdGU7XG4gIH07XG59O1xuXG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuICB2YXIgc3RvcmUgPSBzaGFyZWQuc3RhdGUgfHwgKHNoYXJlZC5zdGF0ZSA9IG5ldyBXZWFrTWFwKCkpO1xuICB2YXIgd21nZXQgPSBzdG9yZS5nZXQ7XG4gIHZhciB3bWhhcyA9IHN0b3JlLmhhcztcbiAgdmFyIHdtc2V0ID0gc3RvcmUuc2V0O1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKHdtaGFzLmNhbGwoc3RvcmUsIGl0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgd21zZXQuY2FsbChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcy5jYWxsKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGlmIChvYmplY3RIYXMoaXQsIFNUQVRFKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gICAgbWV0YWRhdGEuZmFjYWRlID0gaXQ7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBnZXQ6IGdldCxcbiAgaGFzOiBoYXMsXG4gIGVuZm9yY2U6IGVuZm9yY2UsXG4gIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NzMzOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLy8gYElzQ2FsbGFibGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1pc2NhbGxhYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09PSAnZnVuY3Rpb24nO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjU0MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjI5KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcblxudmFyIHJlcGxhY2VtZW50ID0gLyN8XFwucHJvdG90eXBlXFwuLztcblxudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuICB2YXIgdmFsdWUgPSBkYXRhW25vcm1hbGl6ZShmZWF0dXJlKV07XG4gIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWVcbiAgICA6IHZhbHVlID09IE5BVElWRSA/IGZhbHNlXG4gICAgOiBpc0NhbGxhYmxlKGRldGVjdGlvbikgPyBmYWlscyhkZXRlY3Rpb24pXG4gICAgOiAhIWRldGVjdGlvbjtcbn07XG5cbnZhciBub3JtYWxpemUgPSBpc0ZvcmNlZC5ub3JtYWxpemUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgZGF0YSA9IGlzRm9yY2VkLmRhdGEgPSB7fTtcbnZhciBOQVRJVkUgPSBpc0ZvcmNlZC5OQVRJVkUgPSAnTic7XG52YXIgUE9MWUZJTEwgPSBpc0ZvcmNlZC5QT0xZRklMTCA9ICdQJztcblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZvcmNlZDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTA1Mjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MzMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZShpdCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0MjMxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTM5NTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MzMpO1xudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMzMpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTY5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgJFN5bWJvbCA9IGdldEJ1aWx0SW4oJ1N5bWJvbCcpO1xuICByZXR1cm4gaXNDYWxsYWJsZSgkU3ltYm9sKSAmJiBPYmplY3QoaXQpIGluc3RhbmNlb2YgJFN5bWJvbDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM4Mzk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIFY4X1ZFUlNJT04gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzNTgpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjI5KTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gcmVxdWlyZWQgZm9yIHRlc3Rpbmdcbm1vZHVsZS5leHBvcnRzID0gISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgLy8gQ2hyb21lIDM4IFN5bWJvbCBoYXMgaW5jb3JyZWN0IHRvU3RyaW5nIGNvbnZlcnNpb25cbiAgLy8gYGdldC1vd24tcHJvcGVydHktc3ltYm9sc2AgcG9seWZpbGwgc3ltYm9scyBjb252ZXJ0ZWQgdG8gb2JqZWN0IGFyZSBub3QgU3ltYm9sIGluc3RhbmNlc1xuICByZXR1cm4gIVN0cmluZyhzeW1ib2wpIHx8ICEoT2JqZWN0KHN5bWJvbCkgaW5zdGFuY2VvZiBTeW1ib2wpIHx8XG4gICAgLy8gQ2hyb21lIDM4LTQwIHN5bWJvbHMgYXJlIG5vdCBpbmhlcml0ZWQgZnJvbSBET00gY29sbGVjdGlvbnMgcHJvdG90eXBlcyB0byBpbnN0YW5jZXNcbiAgICAhU3ltYm9sLnNoYW0gJiYgVjhfVkVSU0lPTiAmJiBWOF9WRVJTSU9OIDwgNDE7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODY5NDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTg1OSk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjczMyk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oODUxMSk7XG5cbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNDYWxsYWJsZShXZWFrTWFwKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoaW5zcGVjdFNvdXJjZShXZWFrTWFwKSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE3ODc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQwMCk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzOTQpO1xudmFyIGFuT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMTc2KTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzEwKTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1kZWZpbmVwcm9wZXJ0eSAtLSBzYWZlXG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuICBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3OTMzOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0MDApO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MTk1KTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzNTgpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTA1KTtcbnZhciB0b1Byb3BlcnR5S2V5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MzEwKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzOTQpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5ZGVzY3JpcHRvciAtLSBzYWZlXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5ZGVzY3JpcHRvclxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gODE1MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgzNyk7XG5cbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eW5hbWVzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5bmFtZXMgLS0gc2FmZVxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4OTQ6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlzeW1ib2xzIC0tIHNhZmVcbmV4cG9ydHMuZiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE0MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oODE2KTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkwNSk7XG52YXIgaW5kZXhPZiA9IF9fd2VicGFja19yZXF1aXJlX18oOTU0MCkuaW5kZXhPZjtcbnZhciBoaWRkZW5LZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTc3KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTYzMjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQwKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oMzgzNyk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWtleXMgLS0gc2FmZVxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MTk1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG4vLyBOYXNob3JuIH4gSkRLOCBidWdcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUucHJvcGVydHlpc2VudW1lcmFibGVcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuICB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiAgcmV0dXJuICEhZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmVudW1lcmFibGU7XG59IDogJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTE0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjczMyk7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNTIpO1xuXG4vLyBgT3JkaW5hcnlUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9yZGluYXJ5dG9wcmltaXRpdmVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gIHZhciBmbiwgdmFsO1xuICBpZiAocHJlZiA9PT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoaXNDYWxsYWJsZShmbiA9IGlucHV0LnZhbHVlT2YpICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChwcmVmICE9PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQ4MjY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnZXRCdWlsdEluID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzMzKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTUxKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg5NCk7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNzYpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTI3Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTg1OSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NDg3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzYyKTtcbnZhciBzZXRHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNzkpO1xudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1MTEpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY0MDcpO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gX193ZWJwYWNrX3JlcXVpcmVfXygxODA1KS5DT05GSUdVUkFCTEU7XG5cbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgZW5mb3JjZUludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmVuZm9yY2U7XG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gIHZhciB1bnNhZmUgPSBvcHRpb25zID8gISFvcHRpb25zLnVuc2FmZSA6IGZhbHNlO1xuICB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gIHZhciBub1RhcmdldEdldCA9IG9wdGlvbnMgPyAhIW9wdGlvbnMubm9UYXJnZXRHZXQgOiBmYWxzZTtcbiAgdmFyIG5hbWUgPSBvcHRpb25zICYmIG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuICB2YXIgc3RhdGU7XG4gIGlmIChpc0NhbGxhYmxlKHZhbHVlKSkge1xuICAgIGlmIChTdHJpbmcobmFtZSkuc2xpY2UoMCwgNykgPT09ICdTeW1ib2woJykge1xuICAgICAgbmFtZSA9ICdbJyArIFN0cmluZyhuYW1lKS5yZXBsYWNlKC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuICAgIH1cbiAgICBpZiAoIWhhcyh2YWx1ZSwgJ25hbWUnKSB8fCAoQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgJiYgdmFsdWUubmFtZSAhPT0gbmFtZSkpIHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSh2YWx1ZSwgJ25hbWUnLCBuYW1lKTtcbiAgICB9XG4gICAgc3RhdGUgPSBlbmZvcmNlSW50ZXJuYWxTdGF0ZSh2YWx1ZSk7XG4gICAgaWYgKCFzdGF0ZS5zb3VyY2UpIHtcbiAgICAgIHN0YXRlLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIG5hbWUgPT0gJ3N0cmluZycgPyBuYW1lIDogJycpO1xuICAgIH1cbiAgfVxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcbiAgICBzaW1wbGUgPSB0cnVlO1xuICB9XG4gIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICBlbHNlIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCBrZXksIHZhbHVlKTtcbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIGlzQ2FsbGFibGUodGhpcykgJiYgZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zb3VyY2UgfHwgaW5zcGVjdFNvdXJjZSh0aGlzKTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4ODg1OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLy8gYFJlcXVpcmVPYmplY3RDb2VyY2libGVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjA3OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTg1OSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGdsb2JhbFtrZXldID0gdmFsdWU7XG4gIH0gcmV0dXJuIHZhbHVlO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDM5OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzAzNik7XG52YXIgdWlkID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDQxKTtcblxudmFyIGtleXMgPSBzaGFyZWQoJ2tleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiBrZXlzW2tleV0gfHwgKGtleXNba2V5XSA9IHVpZChrZXkpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUzNTM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA3OSk7XG5cbnZhciBTSEFSRUQgPSAnX19jb3JlLWpzX3NoYXJlZF9fJztcbnZhciBzdG9yZSA9IGdsb2JhbFtTSEFSRURdIHx8IHNldEdsb2JhbChTSEFSRUQsIHt9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdG9yZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzAzNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIElTX1BVUkUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMzEpO1xudmFyIHN0b3JlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzUzKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gIHZlcnNpb246ICczLjE4LjEnLFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMjEgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzIzMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjA1MSk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gSGVscGVyIGZvciBhIHBvcHVsYXIgcmVwZWF0aW5nIGNhc2Ugb2YgdGhlIHNwZWM6XG4vLyBMZXQgaW50ZWdlciBiZSA/IFRvSW50ZWdlcihpbmRleCkuXG4vLyBJZiBpbnRlZ2VyIDwgMCwgbGV0IHJlc3VsdCBiZSBtYXgoKGxlbmd0aCArIGludGVnZXIpLCAwKTsgZWxzZSBsZXQgcmVzdWx0IGJlIG1pbihpbnRlZ2VyLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTA1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG4vLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMzcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4ODUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MDUxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9pbnRlZ2VyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQyMzc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciB0b0ludGVnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYwNTEpO1xuXG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBUb0xlbmd0aGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjk5MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg4ODUpO1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b29iamVjdFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGFyZ3VtZW50KSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMDY2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNTIpO1xudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mzk1KTtcbnZhciBnZXRNZXRob2QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzMDApO1xudmFyIG9yZGluYXJ5VG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5MTQpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xuXG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xuXG4vLyBgVG9QcmltaXRpdmVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgaWYgKCFpc09iamVjdChpbnB1dCkgfHwgaXNTeW1ib2woaW5wdXQpKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChleG90aWNUb1ByaW0pIHtcbiAgICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ2RlZmF1bHQnO1xuICAgIHJlc3VsdCA9IGV4b3RpY1RvUHJpbS5jYWxsKGlucHV0LCBwcmVmKTtcbiAgICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gIH1cbiAgaWYgKHByZWYgPT09IHVuZGVmaW5lZCkgcHJlZiA9ICdudW1iZXInO1xuICByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MzEwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgdG9QcmltaXRpdmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwNjYpO1xudmFyIGlzU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5Mzk1KTtcblxuLy8gYFRvUHJvcGVydHlLZXlgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b3Byb3BlcnR5a2V5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsICdzdHJpbmcnKTtcbiAgcmV0dXJuIGlzU3ltYm9sKGtleSkgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE2MDE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk1KTtcblxudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xuXG50ZXN0W1RPX1NUUklOR19UQUddID0gJ3onO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMzI2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgY2xhc3NvZiA9IF9fd2VicGFja19yZXF1aXJlX18oMTU4OSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiAgcmV0dXJuIFN0cmluZyhhcmd1bWVudCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODIxOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gU3RyaW5nKGFyZ3VtZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ09iamVjdCc7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDE0NDE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG52YXIgaWQgPSAwO1xudmFyIHBvc3RmaXggPSBNYXRoLnJhbmRvbSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJyArIFN0cmluZyhrZXkgPT09IHVuZGVmaW5lZCA/ICcnIDoga2V5KSArICcpXycgKyAoKytpZCArIHBvc3RmaXgpLnRvU3RyaW5nKDM2KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY5Njk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGVzbGludC1kaXNhYmxlIGVzL25vLXN5bWJvbCAtLSByZXF1aXJlZCBmb3IgdGVzdGluZyAqL1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4MzkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0xcbiAgJiYgIVN5bWJvbC5zaGFtXG4gICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcbnZhciBzaGFyZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwMzYpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oODE2KTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0NDEpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4MzkpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OTY5KTtcblxudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbCA6IFN5bWJvbCAmJiBTeW1ib2wud2l0aG91dFNldHRlciB8fCB1aWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgaWYgKCFoYXMoV2VsbEtub3duU3ltYm9sc1N0b3JlLCBuYW1lKSB8fCAhKE5BVElWRV9TWU1CT0wgfHwgdHlwZW9mIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9PSAnc3RyaW5nJykpIHtcbiAgICBpZiAoTkFUSVZFX1NZTUJPTCAmJiBoYXMoU3ltYm9sLCBuYW1lKSkge1xuICAgICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gICAgfVxuICB9IHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzNDMwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxMDMpO1xudmFyIGFDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzExMSk7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5OTEpO1xudmFyIHRvTGVuZ3RoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjM3KTtcbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMyNik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xudmFyIGludGVybmFsU29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMzg2Nyk7XG52YXIgYXJyYXlNZXRob2RJc1N0cmljdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjAzOCk7XG52YXIgRkYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2NzEpO1xudmFyIElFX09SX0VER0UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg1MDYpO1xudmFyIFY4ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MzU4KTtcbnZhciBXRUJLSVQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4MTEpO1xuXG52YXIgdGVzdCA9IFtdO1xudmFyIG5hdGl2ZVNvcnQgPSB0ZXN0LnNvcnQ7XG5cbi8vIElFOC1cbnZhciBGQUlMU19PTl9VTkRFRklORUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHRlc3Quc29ydCh1bmRlZmluZWQpO1xufSk7XG4vLyBWOCBidWdcbnZhciBGQUlMU19PTl9OVUxMID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQobnVsbCk7XG59KTtcbi8vIE9sZCBXZWJLaXRcbnZhciBTVFJJQ1RfTUVUSE9EID0gYXJyYXlNZXRob2RJc1N0cmljdCgnc29ydCcpO1xuXG52YXIgU1RBQkxFX1NPUlQgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBmZWF0dXJlIGRldGVjdGlvbiBjYW4gYmUgdG9vIHNsb3csIHNvIGNoZWNrIGVuZ2luZXMgdmVyc2lvbnNcbiAgaWYgKFY4KSByZXR1cm4gVjggPCA3MDtcbiAgaWYgKEZGICYmIEZGID4gMykgcmV0dXJuO1xuICBpZiAoSUVfT1JfRURHRSkgcmV0dXJuIHRydWU7XG4gIGlmIChXRUJLSVQpIHJldHVybiBXRUJLSVQgPCA2MDM7XG5cbiAgdmFyIHJlc3VsdCA9ICcnO1xuICB2YXIgY29kZSwgY2hyLCB2YWx1ZSwgaW5kZXg7XG5cbiAgLy8gZ2VuZXJhdGUgYW4gYXJyYXkgd2l0aCBtb3JlIDUxMiBlbGVtZW50cyAoQ2hha3JhIGFuZCBvbGQgVjggZmFpbHMgb25seSBpbiB0aGlzIGNhc2UpXG4gIGZvciAoY29kZSA9IDY1OyBjb2RlIDwgNzY7IGNvZGUrKykge1xuICAgIGNociA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG5cbiAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgIGNhc2UgNjY6IGNhc2UgNjk6IGNhc2UgNzA6IGNhc2UgNzI6IHZhbHVlID0gMzsgYnJlYWs7XG4gICAgICBjYXNlIDY4OiBjYXNlIDcxOiB2YWx1ZSA9IDQ7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogdmFsdWUgPSAyO1xuICAgIH1cblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IDQ3OyBpbmRleCsrKSB7XG4gICAgICB0ZXN0LnB1c2goeyBrOiBjaHIgKyBpbmRleCwgdjogdmFsdWUgfSk7XG4gICAgfVxuICB9XG5cbiAgdGVzdC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBiLnYgLSBhLnY7IH0pO1xuXG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHRlc3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY2hyID0gdGVzdFtpbmRleF0uay5jaGFyQXQoMCk7XG4gICAgaWYgKHJlc3VsdC5jaGFyQXQocmVzdWx0Lmxlbmd0aCAtIDEpICE9PSBjaHIpIHJlc3VsdCArPSBjaHI7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0ICE9PSAnREdCRUZIQUNJSksnO1xufSk7XG5cbnZhciBGT1JDRUQgPSBGQUlMU19PTl9VTkRFRklORUQgfHwgIUZBSUxTX09OX05VTEwgfHwgIVNUUklDVF9NRVRIT0QgfHwgIVNUQUJMRV9TT1JUO1xuXG52YXIgZ2V0U29ydENvbXBhcmUgPSBmdW5jdGlvbiAoY29tcGFyZWZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoeCwgeSkge1xuICAgIGlmICh5ID09PSB1bmRlZmluZWQpIHJldHVybiAtMTtcbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gMTtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIHJldHVybiArY29tcGFyZWZuKHgsIHkpIHx8IDA7XG4gICAgcmV0dXJuIHRvU3RyaW5nKHgpID4gdG9TdHJpbmcoeSkgPyAxIDogLTE7XG4gIH07XG59O1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnNvcnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29ydFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgc29ydDogZnVuY3Rpb24gc29ydChjb21wYXJlZm4pIHtcbiAgICBpZiAoY29tcGFyZWZuICE9PSB1bmRlZmluZWQpIGFDYWxsYWJsZShjb21wYXJlZm4pO1xuXG4gICAgdmFyIGFycmF5ID0gdG9PYmplY3QodGhpcyk7XG5cbiAgICBpZiAoU1RBQkxFX1NPUlQpIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZCA/IG5hdGl2ZVNvcnQuY2FsbChhcnJheSkgOiBuYXRpdmVTb3J0LmNhbGwoYXJyYXksIGNvbXBhcmVmbik7XG5cbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgYXJyYXlMZW5ndGggPSB0b0xlbmd0aChhcnJheS5sZW5ndGgpO1xuICAgIHZhciBpdGVtc0xlbmd0aCwgaW5kZXg7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBhcnJheUxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGluZGV4IGluIGFycmF5KSBpdGVtcy5wdXNoKGFycmF5W2luZGV4XSk7XG4gICAgfVxuXG4gICAgaXRlbXMgPSBpbnRlcm5hbFNvcnQoaXRlbXMsIGdldFNvcnRDb21wYXJlKGNvbXBhcmVmbikpO1xuICAgIGl0ZW1zTGVuZ3RoID0gaXRlbXMubGVuZ3RoO1xuICAgIGluZGV4ID0gMDtcblxuICAgIHdoaWxlIChpbmRleCA8IGl0ZW1zTGVuZ3RoKSBhcnJheVtpbmRleF0gPSBpdGVtc1tpbmRleCsrXTtcbiAgICB3aGlsZSAoaW5kZXggPCBhcnJheUxlbmd0aCkgZGVsZXRlIGFycmF5W2luZGV4KytdO1xuXG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDc2OTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMzEwMyk7XG52YXIgdG9PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5OTEpO1xudmFyIG5hdGl2ZUtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2MzIpO1xudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjI5KTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUtleXMoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyB9LCB7XG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyh0b09iamVjdChpdCkpO1xuICB9XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTM4ODpcbi8qKiovICgobW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwiWlwiOiAoKSA9PiAoX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18pXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX3NvdXJjZU1hcHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjcyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX3NvdXJjZU1hcHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX3NvdXJjZU1hcHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYwOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9hcGlfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8vIEltcG9ydHNcblxuXG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQoKSgoX25vZGVfbW9kdWxlc19jc3NfbG9hZGVyX2Rpc3RfcnVudGltZV9zb3VyY2VNYXBzX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKiBCdXR0b25zIHN0eWxlcyBzdGFydCAqL1xcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheSB7XFxyXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICB6LWluZGV4OiA5OTk7XFxyXFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxyXFxuICBib3JkZXI6IG5vbmU7XFxyXFxuICAvKmJvcmRlcjogM3B4IHNvbGlkO1xcclxcbiAgICBib3JkZXItY29sb3I6IHdoaXRlO1xcclxcbiAgICBib3gtc2hhZG93OiAwIDAgMTBweCAjY2NjOyovXFxyXFxuICBwYWRkaW5nOiAxcmVtIDEuNXJlbSAxcmVtIDRyZW07XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuICBiYWNrZ3JvdW5kOiAjMDBiMjMzO1xcclxcbiAgY29sb3I6ICNmZmZmZmY7XFxyXFxuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcXHJcXG4gIGZvbnQtc2l6ZTogMnJlbTtcXHJcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuICBsaW5lLWhlaWdodDogMTtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQgMjUwbXMgZWFzZS1pbi1vdXQsIHRyYW5zZm9ybSAxNTBtcyBlYXNlO1xcclxcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcclxcbiAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcclxcblxcclxcbiAgLXdlYmtpdC1hbmltYXRpb246IGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIDIwMG1zOyAvKiBTYWZhcmksIENocm9tZSBhbmQgT3BlcmEgPiAxMi4xICovXFxyXFxuICAtbW96LWFuaW1hdGlvbjogZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4gMjAwbXM7IC8qIEZpcmVmb3ggPCAxNiAqL1xcclxcbiAgLW1zLWFuaW1hdGlvbjogZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4gMjAwbXM7IC8qIEludGVybmV0IEV4cGxvcmVyICovXFxyXFxuICAtby1hbmltYXRpb246IGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIDIwMG1zOyAvKiBPcGVyYSA8IDEyLjEgKi9cXHJcXG4gIGFuaW1hdGlvbjogZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4gMjAwbXM7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5IHtcXHJcXG4gIGRpc3BsYXk6IG5vbmU7XFxyXFxufSovXFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmFmdGVyIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGNvbnRlbnQ6ICcnO1xcclxcbiAgYm9yZGVyOiA4cHggc29saWQ7XFxyXFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHdoaXRlO1xcclxcbiAgbGVmdDogMzVweDtcXHJcXG4gIHRvcDogMjRweDtcXHJcXG4gIHdpZHRoOiAwO1xcclxcbiAgaGVpZ2h0OiAwO1xcclxcbn1cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6YmVmb3JlIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGNvbnRlbnQ6ICcnO1xcclxcbiAgYm9yZGVyOiAzcHggc29saWQ7XFxyXFxuICBsZWZ0OiAxOXB4O1xcclxcbiAgdG9wOiAxNHB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gIHdpZHRoOiAzMHB4O1xcclxcbiAgaGVpZ2h0OiAzMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6aG92ZXIsXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmZvY3VzIHtcXHJcXG4gIGJhY2tncm91bmQ6ICMwMDk4MmM7XFxyXFxufVxcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTpmb2N1cyB7XFxyXFxuICBvdXRsaW5lOiAxcHggc29saWQgI2ZmZjtcXHJcXG4gIG91dGxpbmUtb2Zmc2V0OiAtNHB4O1xcclxcbn1cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6YWN0aXZlIHtcXHJcXG4gIHRyYW5zZm9ybTogc2NhbGUoMC45OSk7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4ge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi8qIEZpcmVmb3ggPCAxNiAqL1xcclxcbkAtbW96LWtleWZyYW1lcyBleGNhbGlidXItYnV0dG9uLWZhZGVpbiB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLyogU2FmYXJpLCBDaHJvbWUgYW5kIE9wZXJhID4gMTIuMSAqL1xcclxcbkAtd2Via2l0LWtleWZyYW1lcyBleGNhbGlidXItYnV0dG9uLWZhZGVpbiB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLyogSW50ZXJuZXQgRXhwbG9yZXIgKi9cXHJcXG5ALW1zLWtleWZyYW1lcyBleGNhbGlidXItYnV0dG9uLWZhZGVpbiB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLyogT3BlcmEgPCAxMi4xICovXFxyXFxuQC1vLWtleWZyYW1lcyBleGNhbGlidXItYnV0dG9uLWZhZGVpbiB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vTG9hZGVyLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQSx5QkFBeUI7O0FBRXpCO0VBQ0UscUJBQXFCO0VBQ3JCLGtCQUFrQjtFQUNsQixZQUFZO0VBQ1osa0JBQWtCO0VBQ2xCLFlBQVk7RUFDWjs7K0JBRTZCO0VBQzdCLDhCQUE4QjtFQUM5QixTQUFTO0VBQ1QscUJBQXFCO0VBQ3JCLG1CQUFtQjtFQUNuQixjQUFjO0VBQ2QsdUJBQXVCO0VBQ3ZCLGVBQWU7RUFDZixtQkFBbUI7RUFDbkIsY0FBYztFQUNkLGVBQWU7RUFDZixrQkFBa0I7RUFDbEIsOERBQThEO0VBQzlELHdCQUF3QjtFQUN4QixxQkFBcUI7O0VBRXJCLGdEQUFnRCxFQUFFLG9DQUFvQztFQUN0Riw2Q0FBNkMsRUFBRSxpQkFBaUI7RUFDaEUsNENBQTRDLEVBQUUsc0JBQXNCO0VBQ3BFLDJDQUEyQyxFQUFFLGlCQUFpQjtFQUM5RCx3Q0FBd0M7QUFDMUM7O0FBRUE7OztFQUdFOztBQUVGO0VBQ0Usa0JBQWtCO0VBQ2xCLFdBQVc7RUFDWCxpQkFBaUI7RUFDakIsdURBQXVEO0VBQ3ZELFVBQVU7RUFDVixTQUFTO0VBQ1QsUUFBUTtFQUNSLFNBQVM7QUFDWDs7QUFFQTtFQUNFLGtCQUFrQjtFQUNsQixXQUFXO0VBQ1gsaUJBQWlCO0VBQ2pCLFVBQVU7RUFDVixTQUFTO0VBQ1QsbUJBQW1CO0VBQ25CLFdBQVc7RUFDWCxZQUFZO0FBQ2Q7O0FBRUE7O0VBRUUsbUJBQW1CO0FBQ3JCOztBQUVBO0VBQ0UsdUJBQXVCO0VBQ3ZCLG9CQUFvQjtBQUN0Qjs7QUFFQTtFQUNFLHNCQUFzQjtBQUN4Qjs7QUFFQTtFQUNFO0lBQ0UsVUFBVTtFQUNaO0VBQ0E7SUFDRSxVQUFVO0VBQ1o7QUFDRjs7QUFFQSxpQkFBaUI7QUFDakI7RUFDRTtJQUNFLFVBQVU7RUFDWjtFQUNBO0lBQ0UsVUFBVTtFQUNaO0FBQ0Y7O0FBRUEsb0NBQW9DO0FBQ3BDO0VBQ0U7SUFDRSxVQUFVO0VBQ1o7RUFDQTtJQUNFLFVBQVU7RUFDWjtBQUNGOztBQUVBLHNCQUFzQjtBQUN0QjtFQUNFO0lBQ0UsVUFBVTtFQUNaO0VBQ0E7SUFDRSxVQUFVO0VBQ1o7QUFDRjs7QUFFQSxpQkFBaUI7QUFDakI7RUFDRTtJQUNFLFVBQVU7RUFDWjtFQUNBO0lBQ0UsVUFBVTtFQUNaO0FBQ0ZcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyogQnV0dG9ucyBzdHlsZXMgc3RhcnQgKi9cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXkge1xcclxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcclxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcclxcbiAgei1pbmRleDogOTk5O1xcclxcbiAgYm9yZGVyLXJhZGl1czogNnB4O1xcclxcbiAgYm9yZGVyOiBub25lO1xcclxcbiAgLypib3JkZXI6IDNweCBzb2xpZDtcXHJcXG4gICAgYm9yZGVyLWNvbG9yOiB3aGl0ZTtcXHJcXG4gICAgYm94LXNoYWRvdzogMCAwIDEwcHggI2NjYzsqL1xcclxcbiAgcGFkZGluZzogMXJlbSAxLjVyZW0gMXJlbSA0cmVtO1xcclxcbiAgbWFyZ2luOiAwO1xcclxcbiAgdGV4dC1kZWNvcmF0aW9uOiBub25lO1xcclxcbiAgYmFja2dyb3VuZDogIzAwYjIzMztcXHJcXG4gIGNvbG9yOiAjZmZmZmZmO1xcclxcbiAgZm9udC1mYW1pbHk6IHNhbnMtc2VyaWY7XFxyXFxuICBmb250LXNpemU6IDJyZW07XFxyXFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcclxcbiAgbGluZS1oZWlnaHQ6IDE7XFxyXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxyXFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxyXFxuICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kIDI1MG1zIGVhc2UtaW4tb3V0LCB0cmFuc2Zvcm0gMTUwbXMgZWFzZTtcXHJcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXHJcXG4gIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXHJcXG5cXHJcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBleGNhbGlidXItYnV0dG9uLWZhZGVpbiAyMDBtczsgLyogU2FmYXJpLCBDaHJvbWUgYW5kIE9wZXJhID4gMTIuMSAqL1xcclxcbiAgLW1vei1hbmltYXRpb246IGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIDIwMG1zOyAvKiBGaXJlZm94IDwgMTYgKi9cXHJcXG4gIC1tcy1hbmltYXRpb246IGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIDIwMG1zOyAvKiBJbnRlcm5ldCBFeHBsb3JlciAqL1xcclxcbiAgLW8tYW5pbWF0aW9uOiBleGNhbGlidXItYnV0dG9uLWZhZGVpbiAyMDBtczsgLyogT3BlcmEgPCAxMi4xICovXFxyXFxuICBhbmltYXRpb246IGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIDIwMG1zO1xcclxcbn1cXHJcXG5cXHJcXG4vKlxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheSB7XFxyXFxuICBkaXNwbGF5OiBub25lO1xcclxcbn0qL1xcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTphZnRlciB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBjb250ZW50OiAnJztcXHJcXG4gIGJvcmRlcjogOHB4IHNvbGlkO1xcclxcbiAgYm9yZGVyLWNvbG9yOiB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB3aGl0ZTtcXHJcXG4gIGxlZnQ6IDM1cHg7XFxyXFxuICB0b3A6IDI0cHg7XFxyXFxuICB3aWR0aDogMDtcXHJcXG4gIGhlaWdodDogMDtcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmJlZm9yZSB7XFxyXFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuICBjb250ZW50OiAnJztcXHJcXG4gIGJvcmRlcjogM3B4IHNvbGlkO1xcclxcbiAgbGVmdDogMTlweDtcXHJcXG4gIHRvcDogMTRweDtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDIwcHg7XFxyXFxuICB3aWR0aDogMzBweDtcXHJcXG4gIGhlaWdodDogMzBweDtcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmhvdmVyLFxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTpmb2N1cyB7XFxyXFxuICBiYWNrZ3JvdW5kOiAjMDA5ODJjO1xcclxcbn1cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6Zm9jdXMge1xcclxcbiAgb3V0bGluZTogMXB4IHNvbGlkICNmZmY7XFxyXFxuICBvdXRsaW5lLW9mZnNldDogLTRweDtcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmFjdGl2ZSB7XFxyXFxuICB0cmFuc2Zvcm06IHNjYWxlKDAuOTkpO1xcclxcbn1cXHJcXG5cXHJcXG5Aa2V5ZnJhbWVzIGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKiBGaXJlZm94IDwgMTYgKi9cXHJcXG5ALW1vei1rZXlmcmFtZXMgZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4ge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi8qIFNhZmFyaSwgQ2hyb21lIGFuZCBPcGVyYSA+IDEyLjEgKi9cXHJcXG5ALXdlYmtpdC1rZXlmcmFtZXMgZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4ge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi8qIEludGVybmV0IEV4cGxvcmVyICovXFxyXFxuQC1tcy1rZXlmcmFtZXMgZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4ge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi8qIE9wZXJhIDwgMTIuMSAqL1xcclxcbkAtby1rZXlmcmFtZXMgZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4ge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChfX19DU1NfTE9BREVSX0VYUE9SVF9fXyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI2MDk6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cblxuLypcbiAgTUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcbiAgQXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcpIHtcbiAgdmFyIGxpc3QgPSBbXTsgLy8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXG4gIGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciBjb250ZW50ID0gXCJcIjtcbiAgICAgIHZhciBuZWVkTGF5ZXIgPSB0eXBlb2YgaXRlbVs1XSAhPT0gXCJ1bmRlZmluZWRcIjtcblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKTtcbiAgICAgIH1cblxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuXG4gICAgICBpZiAobmVlZExheWVyKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH0pLmpvaW4oXCJcIik7XG4gIH07IC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cblxuICBsaXN0LmkgPSBmdW5jdGlvbiBpKG1vZHVsZXMsIG1lZGlhLCBkZWR1cGUsIHN1cHBvcnRzLCBsYXllcikge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgbW9kdWxlcyA9IFtbbnVsbCwgbW9kdWxlcywgdW5kZWZpbmVkXV07XG4gICAgfVxuXG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblxuICAgIGlmIChkZWR1cGUpIHtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB0aGlzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaWQgPSB0aGlzW19pXVswXTtcblxuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaWRdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG1vZHVsZXMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgdmFyIGl0ZW0gPSBbXS5jb25jYXQobW9kdWxlc1tfaTJdKTtcblxuICAgICAgaWYgKGRlZHVwZSAmJiBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobWVkaWEpIHtcbiAgICAgICAgaWYgKCFpdGVtWzJdKSB7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3VwcG9ydHMpIHtcbiAgICAgICAgaWYgKCFpdGVtWzRdKSB7XG4gICAgICAgICAgaXRlbVs0XSA9IFwiXCIuY29uY2F0KHN1cHBvcnRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChpdGVtWzRdLCBcIikge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNF0gPSBzdXBwb3J0cztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBsaXN0O1xufTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDI3Mjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gIHZhciBjb250ZW50ID0gaXRlbVsxXTtcbiAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuXG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY3NzTWFwcGluZykpKSk7XG4gICAgdmFyIGRhdGEgPSBcInNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LFwiLmNvbmNhdChiYXNlNjQpO1xuICAgIHZhciBzb3VyY2VNYXBwaW5nID0gXCIvKiMgXCIuY29uY2F0KGRhdGEsIFwiICovXCIpO1xuICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG4gICAgICByZXR1cm4gXCIvKiMgc291cmNlVVJMPVwiLmNvbmNhdChjc3NNYXBwaW5nLnNvdXJjZVJvb3QgfHwgXCJcIikuY29uY2F0KHNvdXJjZSwgXCIgKi9cIik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtjb250ZW50XS5jb25jYXQoc291cmNlVVJMcykuY29uY2F0KFtzb3VyY2VNYXBwaW5nXSkuam9pbihcIlxcblwiKTtcbiAgfVxuXG4gIHJldHVybiBbY29udGVudF0uam9pbihcIlxcblwiKTtcbn07XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIH0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFxuLyoqKioqKi8gLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0aWQ6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0fTtcbi8qKioqKiovIFxuLyoqKioqKi8gXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcbi8qKioqKiovIFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gfVxuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuLyoqKioqKi8gXHRcdFx0KCkgPT4gKG1vZHVsZSk7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuLyoqKioqKi8gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9nbG9iYWwgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcbi8qKioqKiovIFx0XHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcbi8qKioqKiovIFx0XHR0cnkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4vKioqKioqLyBcdFx0fSBjYXRjaCAoZSkge1xuLyoqKioqKi8gXHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSlcbi8qKioqKiovIH0pKCk7XG4vKioqKioqLyBcbi8qKioqKiovIC8qIHdlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QgKi9cbi8qKioqKiovICgoKSA9PiB7XG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0ge307XG4vLyBUaGlzIGVudHJ5IG5lZWQgdG8gYmUgd3JhcHBlZCBpbiBhbiBJSUZFIGJlY2F1c2UgaXQgbmVlZCB0byBiZSBpc29sYXRlZCBhZ2FpbnN0IG90aGVyIG1vZHVsZXMgaW4gdGhlIGNodW5rLlxuKCgpID0+IHtcblxuLy8gRVhQT1JUU1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbiAgXCJmV25cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFjdGlvbkNvbnRleHQpLFxuICBcIklhOFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWN0aW9uUXVldWUpLFxuICBcImhMSVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWN0aW9uc0NvbXBvbmVudCksXG4gIFwieXl2XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBY3Rpb25zU3lzdGVtKSxcbiAgXCJ0WDVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFjdGl2YXRlRXZlbnQpLFxuICBcInZ0WFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWN0b3IpLFxuICBcInI3S1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWRkZWRDb21wb25lbnQpLFxuICBcImxDaFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWRkZWRFbnRpdHkpLFxuICBcImZ3RlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQW5pbWF0aW9uKSxcbiAgXCJzY2VcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFuaW1hdGlvbkRpcmVjdGlvbiksXG4gIFwiX2M3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbmltYXRpb25TdHJhdGVneSksXG4gIFwiS1VzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBcmNhZGVTb2x2ZXIpLFxuICBcIkFqcFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQXVkaW9Db250ZXh0RmFjdG9yeSksXG4gIFwiUkRoXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBeGlzKSxcbiAgXCJfSDlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEJhc2VBbGlnbiksXG4gIFwiVWxmXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBCaW5hcnlUcmVlTm9kZSksXG4gIFwibXhzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBCbGluayksXG4gIFwiT21EXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBCb2R5Q29tcG9uZW50KSxcbiAgXCJrQmZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEJvdW5kaW5nQm94KSxcbiAgXCJDNEZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEJyb2FkcGhhc2VTdHJhdGVneSksXG4gIFwiTlF0XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBCcm93c2VyQ29tcG9uZW50KSxcbiAgXCJKak5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEJyb3dzZXJFdmVudHMpLFxuICBcIlYxc1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ2FtZXJhKSxcbiAgXCJYejdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENhbnZhcyksXG4gIFwiYkxkXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDZWxsKSxcbiAgXCJDZGNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENpcmNsZSksXG4gIFwiRktuXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDaXJjbGVDb2xsaWRlciksXG4gIFwid1RXXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDbGFzcyksXG4gIFwiYWIyXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDbG9zZXN0TGluZSksXG4gIFwiR2ZaXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDbG9zZXN0TGluZUp1bXBUYWJsZSksXG4gIFwiWU1TXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaWRlciksXG4gIFwib3l2XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaWRlckNvbXBvbmVudCksXG4gIFwiYVViXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaXNpb25Db250YWN0KSxcbiAgXCJTZERcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvbkVuZEV2ZW50KSxcbiAgXCJKVXZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvbkdyb3VwKSxcbiAgXCJqRWpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvbkdyb3VwTWFuYWdlciksXG4gIFwiVEZxXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaXNpb25KdW1wVGFibGUpLFxuICBcIkhEVVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uUG9zdFNvbHZlRXZlbnQpLFxuICBcIlJfeVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uUHJlU29sdmVFdmVudCksXG4gIFwieWROXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kpLFxuICBcIl9OMlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uU29sdmVyKSxcbiAgXCJ0NTBcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvblN0YXJ0RXZlbnQpLFxuICBcInMkJFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uU3lzdGVtKSxcbiAgXCJ2MkdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvblR5cGUpLFxuICBcIklsa1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sb3IpLFxuICBcIkhfOVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sb3JCbGluZENvcnJlY3RvciksXG4gIFwiczlpXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xvckJsaW5kRmxhZ3MpLFxuICBcImtzbFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sb3JCbGluZG5lc3MpLFxuICBcIndBMlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29tcG9uZW50KSxcbiAgXCJSX3BcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbXBvc2l0ZUNvbGxpZGVyKSxcbiAgXCJJUSRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbmZpZ3VyYWJsZSksXG4gIFwiSTVGXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb25zb2xlQXBwZW5kZXIpLFxuICBcIlg4JFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29udGFjdENvbnN0cmFpbnRQb2ludCksXG4gIFwiRlI2XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb250YWN0RW5kRXZlbnQpLFxuICBcIlU4b1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29udGFjdFN0YXJ0RXZlbnQpLFxuICBcImtiR1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29vcmRQbGFuZSksXG4gIFwib2VKXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDdWxsaW5nQm94KSxcbiAgXCJpU19cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERlYWN0aXZhdGVFdmVudCksXG4gIFwiY0dHXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEZWJ1ZyksXG4gIFwic2tiXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEZWJ1Z1N5c3RlbSksXG4gIFwiU0xVXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEZWJ1Z1RleHQpLFxuICBcIlJkSlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGVncmVlT2ZGcmVlZG9tKSxcbiAgXCJnVTdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERldGVjdG9yKSxcbiAgXCJMU2tcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERpZSksXG4gIFwiTm1wXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEaXJlY3Rpb24pLFxuICBcImQxWVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGlzcGxheU1vZGUpLFxuICBcInhyTFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRHluYW1pY1RyZWUpLFxuICBcInNSV1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRHluYW1pY1RyZWVDb2xsaXNpb25Qcm9jZXNzb3IpLFxuICBcImNtVlwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBFWF9WRVJTSU9OKSxcbiAgXCJOMFFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVhc2VUbyksXG4gIFwicThiXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFYXNpbmdGdW5jdGlvbnMpLFxuICBcInluQlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRWRnZUNvbGxpZGVyKSxcbiAgXCJqVDlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVsYXN0aWNUb0FjdG9yU3RyYXRlZ3kpLFxuICBcIndBelwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRW1pdHRlclR5cGUpLFxuICBcIkQ0VlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRW5naW5lKSxcbiAgXCJONkhcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVudGVyVHJpZ2dlckV2ZW50KSxcbiAgXCJXMUFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVudGVyVmlld1BvcnRFdmVudCksXG4gIFwiSkhXXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFbnRpdHkpLFxuICBcInYyS1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRW50aXR5TWFuYWdlciksXG4gIFwicEJmXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFdmVudERpc3BhdGNoZXIpLFxuICBcIkdNbFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRXZlbnRUeXBlcyksXG4gIFwielcyXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFdmVudHNfbmFtZXNwYWNlT2JqZWN0KSxcbiAgXCJCMEtcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEV4UmVzcG9uc2UpLFxuICBcIk52N1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXMpLFxuICBcIkNfcFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0wpLFxuICBcIk1VQVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRXhpdFRyaWdnZXJFdmVudCksXG4gIFwieHFVXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFeGl0Vmlld1BvcnRFdmVudCksXG4gIFwicGVHXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFeHBlcmltZW50cyksXG4gIFwicFRwXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBGYWRlKSxcbiAgXCJ2VUtcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZsYWdzKSxcbiAgXCJqOWxcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZvbGxvdyksXG4gIFwiWnh3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBGb250KSxcbiAgXCJIZHhcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZvbnRTdHlsZSksXG4gIFwiWiRkXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBGb250VW5pdCksXG4gIFwibyQ3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBGcmFtZVN0YXRzKSxcbiAgXCJabSRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdhbWVFdmVudCksXG4gIFwiJFFIXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHYW1lU3RhcnRFdmVudCksXG4gIFwiaTc4XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHYW1lU3RvcEV2ZW50KSxcbiAgXCJoNnVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdhbWVwYWRBeGlzRXZlbnQpLFxuICBcImh0c1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR2FtZXBhZEJ1dHRvbkV2ZW50KSxcbiAgXCJqODhcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdhbWVwYWRDb25uZWN0RXZlbnQpLFxuICBcIlZNRVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR2FtZXBhZERpc2Nvbm5lY3RFdmVudCksXG4gIFwibnRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdpZiksXG4gIFwiVWtyXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHbG9iYWxDb29yZGluYXRlcyksXG4gIFwienN1XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHcmFwaGljKSxcbiAgXCJvQTZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdyYXBoaWNzQ29tcG9uZW50KSxcbiAgXCJUVmhcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdyYXBoaWNzR3JvdXApLFxuICBcIlR3WlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR3JhcGhpY3NMYXllciksXG4gIFwiR1RUXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHcmFwaGljc0xheWVycyksXG4gIFwieHhqXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHcmFwaGljc1N5c3RlbSksXG4gIFwiWGRLXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBIaWRkZW5FdmVudCksXG4gIFwiY1hvXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBJbWFnZVNvdXJjZSksXG4gIFwiRG01XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBJbml0aWFsaXplRXZlbnQpLFxuICBcIklJQlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gSW5wdXRfSW5kZXhfbmFtZXNwYWNlT2JqZWN0KSxcbiAgXCJ6STBcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEludGVncmF0b3IpLFxuICBcIlNLWlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gS2lsbEV2ZW50KSxcbiAgXCJfX0pcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExhYmVsX0xhYmVsKSxcbiAgXCJEdnJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExlZ2FjeSksXG4gIFwiVGY5XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEcmF3aW5nX0luZGV4X25hbWVzcGFjZU9iamVjdCksXG4gIFwiUkkkXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBMaW1pdENhbWVyYUJvdW5kc1N0cmF0ZWd5KSxcbiAgXCJ4MTJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExpbmUpLFxuICBcImFOd1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9hZGVyKSxcbiAgXCJ4d25cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5KSxcbiAgXCJkTktcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3kpLFxuICBcImluaVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9nTGV2ZWwpLFxuICBcIllkSFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9nZ2VyKSxcbiAgXCJ5M0dcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1hdHJpeCksXG4gIFwibDU3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNYXRyaXhMb2NhdGlvbnMpLFxuICBcInhuMFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTWVkaWFFdmVudCksXG4gIFwidDJWXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNZWV0KSxcbiAgXCJaeVNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1vY2tlZEVsZW1lbnQpLFxuICBcInV4QlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTW90aW9uQ29tcG9uZW50KSxcbiAgXCJjcGRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1vdGlvblN5c3RlbSksXG4gIFwiZml5XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNb3ZlQnkpLFxuICBcIiRYWlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTW92ZVRvKSxcbiAgXCJ1cUtcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE5hdGl2ZVNvdW5kRXZlbnQpLFxuICBcIlNURVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTmF0aXZlU291bmRQcm9jZXNzZWRFdmVudCksXG4gIFwieSR6XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBPYnNlcnZhYmxlKSxcbiAgXCJzT3FcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBhaXIpLFxuICBcIlNxc1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGFyc2VHaWYpLFxuICBcImhwWlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGFydGljbGUpLFxuICBcIlZvbFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGFydGljbGVFbWl0dGVyKSxcbiAgXCJ3SVpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBoeXNpY3MpLFxuICBcImNCaVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGh5c2ljc1N0YXRzKSxcbiAgXCJtZ3FcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBvbHlnb25fUG9seWdvbiksXG4gIFwiWVZBXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb2x5Z29uQ29sbGlkZXIpLFxuICBcIktncFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUG9vbCksXG4gIFwiSEgkXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb3N0Q29sbGlzaW9uRXZlbnQpLFxuICBcIk1fZFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUG9zdERlYnVnRHJhd0V2ZW50KSxcbiAgXCJyZ2hcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBvc3REcmF3RXZlbnQpLFxuICBcIlJhNlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUG9zdEZyYW1lRXZlbnQpLFxuICBcIktoUlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUG9zdEtpbGxFdmVudCksXG4gIFwiQlM1XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb3N0VXBkYXRlRXZlbnQpLFxuICBcInhoelwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUHJlQ29sbGlzaW9uRXZlbnQpLFxuICBcInhPcVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUHJlRGVidWdEcmF3RXZlbnQpLFxuICBcImE5alwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUHJlRHJhd0V2ZW50KSxcbiAgXCJiSGtcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFByZUZyYW1lRXZlbnQpLFxuICBcIkNnS1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUHJlS2lsbEV2ZW50KSxcbiAgXCJjdVlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFByZVVwZGF0ZUV2ZW50KSxcbiAgXCJrdkVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFByb2plY3Rpb24pLFxuICBcIkpEYlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUHJvbWlzZXNfUHJvbWlzZSksXG4gIFwiQ2JpXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcm9taXNlU3RhdGUpLFxuICBcIkFFX1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUXVlcnkpLFxuICBcImN0T1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUXVlcnlNYW5hZ2VyKSxcbiAgXCJPTEhcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3kpLFxuICBcImtreVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmFuZG9tKSxcbiAgXCJuU0ZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJhc3RlciksXG4gIFwiekhuXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSYXkpLFxuICBcInp3eFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmVhbGlzdGljU29sdmVyKSxcbiAgXCJBZUpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlY3RhbmdsZSksXG4gIFwiaEx6XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSZW1vdmVkQ29tcG9uZW50KSxcbiAgXCJEOWdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlbW92ZWRFbnRpdHkpLFxuICBcIndBXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSZXBlYXQpLFxuICBcImpoclwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmVwZWF0Rm9yZXZlciksXG4gIFwiR1ZzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSZXNvbHV0aW9uKSxcbiAgXCJfek9cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlc291cmNlKSxcbiAgXCJ3NiRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJvdGF0ZUJ5KSxcbiAgXCJtaFZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJvdGF0ZVRvKSxcbiAgXCJNT0RcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJvdGF0aW9uVHlwZSksXG4gIFwia3dkXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTY2FsZUJ5KSxcbiAgXCJMbXJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNjYWxlVG8pLFxuICBcInhzU1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2NlbmUpLFxuICBcImxMclwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2NyZWVuKSxcbiAgXCJaJHJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNjcmVlbkFwcGVuZGVyKSxcbiAgXCJJWGJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNjcmVlbkVsZW1lbnRfU2NyZWVuRWxlbWVudCksXG4gIFwiU01qXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTY3JvbGxQcmV2ZW50aW9uTW9kZSksXG4gIFwiYm5GXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTaGFwZSksXG4gIFwiTUZBXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTaWRlKSxcbiAgXCIkWENcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNvcnRlZExpc3QpLFxuICBcIiR1VVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU291bmQpLFxuICBcImp5aVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3ByaXRlKSxcbiAgXCJFMDNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNwcml0ZUZvbnRfU3ByaXRlRm9udCksXG4gIFwiVjZxXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTcHJpdGVTaGVldCksXG4gIFwiblZvXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTdHJhdGVneUNvbnRhaW5lciksXG4gIFwiRjZOXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTdHJlYW0pLFxuICBcImFkM1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3Vic2NyaWJlRXZlbnQpLFxuICBcInhQN1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3lzdGVtKSxcbiAgXCJPZHFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFN5c3RlbU1hbmFnZXIpLFxuICBcIlppZlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3lzdGVtVHlwZSksXG4gIFwiWkdKXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUYWdDb21wb25lbnQpLFxuICBcInh2VFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVGV4dCksXG4gIFwiUEhNXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUZXh0QWxpZ24pLFxuICBcIkt3T1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVGlsZU1hcCksXG4gIFwiQjd5XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUaW1lciksXG4gIFwiU0ZwXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUcmFpdHNfSW5kZXhfbmFtZXNwYWNlT2JqZWN0KSxcbiAgXCJVdm5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRyYW5zZm9ybUNvbXBvbmVudCksXG4gIFwiT0ZUXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUcmVlTm9kZSksXG4gIFwieHpOXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUcmlnZ2VyX1RyaWdnZXIpLFxuICBcIkg2alwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVW5zdWJzY3JpYmVFdmVudCksXG4gIFwiWnJOXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBVdGlsX0luZGV4X25hbWVzcGFjZU9iamVjdCksXG4gIFwiT1dzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBWZWN0b3IpLFxuICBcImRGOVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVmVjdG9yVmlldyksXG4gIFwiVkhvXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBWaXNpYmxlRXZlbnQpLFxuICBcIlIkRVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gV2ViQXVkaW9JbnN0YW5jZSksXG4gIFwicTNJXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBXb3JsZCksXG4gIFwiUGFiXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBjYW5vbmljYWxpemVBbmdsZSksXG4gIFwidVo1XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBjbGFtcCksXG4gIFwiTWNLXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBjcmVhdGVJZCksXG4gIFwiazBiXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBoYXNHcmFwaGljc1RpY2spLFxuICBcImhuVFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaGFzT25Jbml0aWFsaXplKSxcbiAgXCJSU0pcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc09uUG9zdFVwZGF0ZSksXG4gIFwiTWt1XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBoYXNPblByZVVwZGF0ZSksXG4gIFwiaDkwXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBoYXNQb3N0RHJhdyksXG4gIFwicm1zXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBoYXNQcmVEcmF3KSxcbiAgXCJFclBcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc19pbml0aWFsaXplKSxcbiAgXCJhVmdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc19wb3N0dXBkYXRlKSxcbiAgXCJsUGNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc19wcmV1cGRhdGUpLFxuICBcIlo4RVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaXNBZGRlZENvbXBvbmVudCksXG4gIFwiTk5BXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBpc0FkZGVkU3lzdGVtRW50aXR5KSxcbiAgXCJ5Rm5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGlzUmVtb3ZlU3lzdGVtRW50aXR5KSxcbiAgXCJsTnZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGlzUmVtb3ZlZENvbXBvbmVudCksXG4gIFwiTVpRXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBtYXhNZXNzYWdlcyksXG4gIFwiRlVNXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBvYnNvbGV0ZSksXG4gIFwidmRmXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyByYW5kb21JblJhbmdlKSxcbiAgXCJpYUxcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHJhbmRvbUludEluUmFuZ2UpLFxuICBcInc2SFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gcmFuZ2UpLFxuICBcIlE0Y1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gcmVzZXRPYnNvbGV0ZUNvdW50ZXIpLFxuICBcIlV4YlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gdG9EZWdyZWVzKSxcbiAgXCJZcjVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHRvUmFkaWFucyksXG4gIFwiQmh3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyB2ZWMpXG59KTtcblxuLy8gTkFNRVNQQUNFIE9CSkVDVDogLi9FdmVudHMudHNcbnZhciBFdmVudHNfbmFtZXNwYWNlT2JqZWN0ID0ge307XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoRXZlbnRzX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoRXZlbnRzX25hbWVzcGFjZU9iamVjdCwge1xuICBcIkFjdGl2YXRlRXZlbnRcIjogKCkgPT4gKEFjdGl2YXRlRXZlbnQpLFxuICBcIkNvbGxpc2lvbkVuZEV2ZW50XCI6ICgpID0+IChDb2xsaXNpb25FbmRFdmVudCksXG4gIFwiQ29sbGlzaW9uUG9zdFNvbHZlRXZlbnRcIjogKCkgPT4gKENvbGxpc2lvblBvc3RTb2x2ZUV2ZW50KSxcbiAgXCJDb2xsaXNpb25QcmVTb2x2ZUV2ZW50XCI6ICgpID0+IChDb2xsaXNpb25QcmVTb2x2ZUV2ZW50KSxcbiAgXCJDb2xsaXNpb25TdGFydEV2ZW50XCI6ICgpID0+IChDb2xsaXNpb25TdGFydEV2ZW50KSxcbiAgXCJDb250YWN0RW5kRXZlbnRcIjogKCkgPT4gKENvbnRhY3RFbmRFdmVudCksXG4gIFwiQ29udGFjdFN0YXJ0RXZlbnRcIjogKCkgPT4gKENvbnRhY3RTdGFydEV2ZW50KSxcbiAgXCJEZWFjdGl2YXRlRXZlbnRcIjogKCkgPT4gKERlYWN0aXZhdGVFdmVudCksXG4gIFwiRW50ZXJUcmlnZ2VyRXZlbnRcIjogKCkgPT4gKEVudGVyVHJpZ2dlckV2ZW50KSxcbiAgXCJFbnRlclZpZXdQb3J0RXZlbnRcIjogKCkgPT4gKEVudGVyVmlld1BvcnRFdmVudCksXG4gIFwiRXZlbnRUeXBlc1wiOiAoKSA9PiAoRXZlbnRUeXBlcyksXG4gIFwiRXhpdFRyaWdnZXJFdmVudFwiOiAoKSA9PiAoRXhpdFRyaWdnZXJFdmVudCksXG4gIFwiRXhpdFZpZXdQb3J0RXZlbnRcIjogKCkgPT4gKEV4aXRWaWV3UG9ydEV2ZW50KSxcbiAgXCJHYW1lRXZlbnRcIjogKCkgPT4gKEdhbWVFdmVudCksXG4gIFwiR2FtZVN0YXJ0RXZlbnRcIjogKCkgPT4gKEdhbWVTdGFydEV2ZW50KSxcbiAgXCJHYW1lU3RvcEV2ZW50XCI6ICgpID0+IChHYW1lU3RvcEV2ZW50KSxcbiAgXCJHYW1lcGFkQXhpc0V2ZW50XCI6ICgpID0+IChHYW1lcGFkQXhpc0V2ZW50KSxcbiAgXCJHYW1lcGFkQnV0dG9uRXZlbnRcIjogKCkgPT4gKEdhbWVwYWRCdXR0b25FdmVudCksXG4gIFwiR2FtZXBhZENvbm5lY3RFdmVudFwiOiAoKSA9PiAoR2FtZXBhZENvbm5lY3RFdmVudCksXG4gIFwiR2FtZXBhZERpc2Nvbm5lY3RFdmVudFwiOiAoKSA9PiAoR2FtZXBhZERpc2Nvbm5lY3RFdmVudCksXG4gIFwiSGlkZGVuRXZlbnRcIjogKCkgPT4gKEhpZGRlbkV2ZW50KSxcbiAgXCJJbml0aWFsaXplRXZlbnRcIjogKCkgPT4gKEluaXRpYWxpemVFdmVudCksXG4gIFwiS2lsbEV2ZW50XCI6ICgpID0+IChLaWxsRXZlbnQpLFxuICBcIlBvc3RDb2xsaXNpb25FdmVudFwiOiAoKSA9PiAoUG9zdENvbGxpc2lvbkV2ZW50KSxcbiAgXCJQb3N0RGVidWdEcmF3RXZlbnRcIjogKCkgPT4gKFBvc3REZWJ1Z0RyYXdFdmVudCksXG4gIFwiUG9zdERyYXdFdmVudFwiOiAoKSA9PiAoUG9zdERyYXdFdmVudCksXG4gIFwiUG9zdEZyYW1lRXZlbnRcIjogKCkgPT4gKFBvc3RGcmFtZUV2ZW50KSxcbiAgXCJQb3N0S2lsbEV2ZW50XCI6ICgpID0+IChQb3N0S2lsbEV2ZW50KSxcbiAgXCJQb3N0VXBkYXRlRXZlbnRcIjogKCkgPT4gKFBvc3RVcGRhdGVFdmVudCksXG4gIFwiUHJlQ29sbGlzaW9uRXZlbnRcIjogKCkgPT4gKFByZUNvbGxpc2lvbkV2ZW50KSxcbiAgXCJQcmVEZWJ1Z0RyYXdFdmVudFwiOiAoKSA9PiAoUHJlRGVidWdEcmF3RXZlbnQpLFxuICBcIlByZURyYXdFdmVudFwiOiAoKSA9PiAoUHJlRHJhd0V2ZW50KSxcbiAgXCJQcmVGcmFtZUV2ZW50XCI6ICgpID0+IChQcmVGcmFtZUV2ZW50KSxcbiAgXCJQcmVLaWxsRXZlbnRcIjogKCkgPT4gKFByZUtpbGxFdmVudCksXG4gIFwiUHJlVXBkYXRlRXZlbnRcIjogKCkgPT4gKFByZVVwZGF0ZUV2ZW50KSxcbiAgXCJTdWJzY3JpYmVFdmVudFwiOiAoKSA9PiAoU3Vic2NyaWJlRXZlbnQpLFxuICBcIlVuc3Vic2NyaWJlRXZlbnRcIjogKCkgPT4gKFVuc3Vic2NyaWJlRXZlbnQpLFxuICBcIlZpc2libGVFdmVudFwiOiAoKSA9PiAoVmlzaWJsZUV2ZW50KVxufSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vRHJhd2luZy9TcHJpdGVFZmZlY3RzLnRzXG52YXIgU3ByaXRlRWZmZWN0c19uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihTcHJpdGVFZmZlY3RzX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoU3ByaXRlRWZmZWN0c19uYW1lc3BhY2VPYmplY3QsIHtcbiAgXCJDb2xvcml6ZVwiOiAoKSA9PiAoQ29sb3JpemUpLFxuICBcIkRhcmtlblwiOiAoKSA9PiAoRGFya2VuKSxcbiAgXCJEZXNhdHVyYXRlXCI6ICgpID0+IChEZXNhdHVyYXRlKSxcbiAgXCJGaWxsXCI6ICgpID0+IChGaWxsKSxcbiAgXCJHcmF5c2NhbGVcIjogKCkgPT4gKEdyYXlzY2FsZSksXG4gIFwiSW52ZXJ0XCI6ICgpID0+IChJbnZlcnQpLFxuICBcIkxpZ2h0ZW5cIjogKCkgPT4gKExpZ2h0ZW4pLFxuICBcIk9wYWNpdHlcIjogKCkgPT4gKE9wYWNpdHkpLFxuICBcIlNhdHVyYXRlXCI6ICgpID0+IChTYXR1cmF0ZSlcbn0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL1V0aWwvRHJhd1V0aWwudHNcbnZhciBEcmF3VXRpbF9uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihEcmF3VXRpbF9uYW1lc3BhY2VPYmplY3QpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKERyYXdVdGlsX25hbWVzcGFjZU9iamVjdCwge1xuICBcImNpcmNsZVwiOiAoKSA9PiAoY2lyY2xlKSxcbiAgXCJsaW5lXCI6ICgpID0+IChsaW5lKSxcbiAgXCJwb2ludFwiOiAoKSA9PiAocG9pbnQpLFxuICBcInJvdW5kUmVjdFwiOiAoKSA9PiAocm91bmRSZWN0KSxcbiAgXCJ2ZWN0b3JcIjogKCkgPT4gKHZlY3Rvcilcbn0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL0RyYXdpbmcvSW5kZXgudHNcbnZhciBEcmF3aW5nX0luZGV4X25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKERyYXdpbmdfSW5kZXhfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChEcmF3aW5nX0luZGV4X25hbWVzcGFjZU9iamVjdCwge1xuICBcIkFuaW1hdGlvblwiOiAoKSA9PiAoQW5pbWF0aW9uX0FuaW1hdGlvbiksXG4gIFwiQ2FudmFzRHJhd0NvbXBvbmVudFwiOiAoKSA9PiAoQ2FudmFzRHJhd0NvbXBvbmVudCksXG4gIFwiQ2FudmFzRHJhd2luZ1N5c3RlbVwiOiAoKSA9PiAoQ2FudmFzRHJhd2luZ1N5c3RlbSksXG4gIFwiRWZmZWN0c1wiOiAoKSA9PiAoU3ByaXRlRWZmZWN0c19uYW1lc3BhY2VPYmplY3QpLFxuICBcIlBvbHlnb25cIjogKCkgPT4gKFBvbHlnb24pLFxuICBcIlNwcml0ZVwiOiAoKSA9PiAoU3ByaXRlX1Nwcml0ZSksXG4gIFwiU3ByaXRlRm9udFwiOiAoKSA9PiAoU3ByaXRlRm9udCksXG4gIFwiU3ByaXRlU2hlZXRcIjogKCkgPT4gKFNwcml0ZVNoZWV0X1Nwcml0ZVNoZWV0KSxcbiAgXCJUZXh0dXJlXCI6ICgpID0+IChUZXh0dXJlKVxufSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vSW5wdXQvSW5kZXgudHNcbnZhciBJbnB1dF9JbmRleF9uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihJbnB1dF9JbmRleF9uYW1lc3BhY2VPYmplY3QpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKElucHV0X0luZGV4X25hbWVzcGFjZU9iamVjdCwge1xuICBcIkF4ZXNcIjogKCkgPT4gKEF4ZXMpLFxuICBcIkJ1dHRvbnNcIjogKCkgPT4gKEJ1dHRvbnMpLFxuICBcIkdhbWVwYWRcIjogKCkgPT4gKEdhbWVwYWQpLFxuICBcIkdhbWVwYWRzXCI6ICgpID0+IChHYW1lcGFkcyksXG4gIFwiS2V5RXZlbnRcIjogKCkgPT4gKEtleUV2ZW50KSxcbiAgXCJLZXlib2FyZFwiOiAoKSA9PiAoS2V5Ym9hcmQpLFxuICBcIktleXNcIjogKCkgPT4gKEtleXMpLFxuICBcIk5hdGl2ZVBvaW50ZXJCdXR0b25cIjogKCkgPT4gKE5hdGl2ZVBvaW50ZXJCdXR0b24pLFxuICBcIlBvaW50ZXJcIjogKCkgPT4gKFBvaW50ZXIpLFxuICBcIlBvaW50ZXJCdXR0b25cIjogKCkgPT4gKFBvaW50ZXJCdXR0b24pLFxuICBcIlBvaW50ZXJDYW5jZWxFdmVudFwiOiAoKSA9PiAoUG9pbnRlckNhbmNlbEV2ZW50KSxcbiAgXCJQb2ludGVyRG93bkV2ZW50XCI6ICgpID0+IChQb2ludGVyRG93bkV2ZW50KSxcbiAgXCJQb2ludGVyRHJhZ0V2ZW50XCI6ICgpID0+IChQb2ludGVyRHJhZ0V2ZW50KSxcbiAgXCJQb2ludGVyRW50ZXJFdmVudFwiOiAoKSA9PiAoUG9pbnRlckVudGVyRXZlbnQpLFxuICBcIlBvaW50ZXJFdmVudFwiOiAoKSA9PiAoUG9pbnRlckV2ZW50KSxcbiAgXCJQb2ludGVyRXZlbnRGYWN0b3J5XCI6ICgpID0+IChQb2ludGVyRXZlbnRGYWN0b3J5KSxcbiAgXCJQb2ludGVyTGVhdmVFdmVudFwiOiAoKSA9PiAoUG9pbnRlckxlYXZlRXZlbnQpLFxuICBcIlBvaW50ZXJNb3ZlRXZlbnRcIjogKCkgPT4gKFBvaW50ZXJNb3ZlRXZlbnQpLFxuICBcIlBvaW50ZXJTY29wZVwiOiAoKSA9PiAoUG9pbnRlclNjb3BlKSxcbiAgXCJQb2ludGVyVHlwZVwiOiAoKSA9PiAoUG9pbnRlclR5cGUpLFxuICBcIlBvaW50ZXJVcEV2ZW50XCI6ICgpID0+IChQb2ludGVyVXBFdmVudCksXG4gIFwiUG9pbnRlcnNcIjogKCkgPT4gKFBvaW50ZXJzKSxcbiAgXCJXaGVlbERlbHRhTW9kZVwiOiAoKSA9PiAoV2hlZWxEZWx0YU1vZGUpLFxuICBcIldoZWVsRXZlbnRcIjogKCkgPT4gKFdoZWVsRXZlbnQpLFxuICBcImNyZWF0ZVBvaW50ZXJFdmVudEJ5TmFtZVwiOiAoKSA9PiAoY3JlYXRlUG9pbnRlckV2ZW50QnlOYW1lKVxufSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vVHJhaXRzL0luZGV4LnRzXG52YXIgVHJhaXRzX0luZGV4X25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKFRyYWl0c19JbmRleF9uYW1lc3BhY2VPYmplY3QpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKFRyYWl0c19JbmRleF9uYW1lc3BhY2VPYmplY3QsIHtcbiAgXCJDYXB0dXJlUG9pbnRlclwiOiAoKSA9PiAoQ2FwdHVyZVBvaW50ZXIpLFxuICBcIk9mZnNjcmVlbkN1bGxpbmdcIjogKCkgPT4gKE9mZnNjcmVlbkN1bGxpbmcpXG59KTtcblxuLy8gTkFNRVNQQUNFIE9CSkVDVDogLi9VdGlsL0luZGV4LnRzXG52YXIgVXRpbF9JbmRleF9uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihVdGlsX0luZGV4X25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoVXRpbF9JbmRleF9uYW1lc3BhY2VPYmplY3QsIHtcbiAgXCJDb2xsZWN0aW9uXCI6ICgpID0+IChDb2xsZWN0aW9uKSxcbiAgXCJDb25zb2xlQXBwZW5kZXJcIjogKCkgPT4gKENvbnNvbGVBcHBlbmRlciksXG4gIFwiRHJhd1V0aWxcIjogKCkgPT4gKERyYXdVdGlsX25hbWVzcGFjZU9iamVjdCksXG4gIFwiRWFzaW5nRnVuY3Rpb25zXCI6ICgpID0+IChFYXNpbmdGdW5jdGlvbnMpLFxuICBcIkxvZ0xldmVsXCI6ICgpID0+IChMb2dMZXZlbCksXG4gIFwiTG9nZ2VyXCI6ICgpID0+IChMb2dnZXIpLFxuICBcIk9ic2VydmFibGVcIjogKCkgPT4gKE9ic2VydmFibGUpLFxuICBcIlNjcmVlbkFwcGVuZGVyXCI6ICgpID0+IChTY3JlZW5BcHBlbmRlciksXG4gIFwiVHdvUElcIjogKCkgPT4gKFR3b1BJKSxcbiAgXCJhZGRJdGVtVG9BcnJheVwiOiAoKSA9PiAoYWRkSXRlbVRvQXJyYXkpLFxuICBcImJhc2U2NEVuY29kZVwiOiAoKSA9PiAoYmFzZTY0RW5jb2RlKSxcbiAgXCJjYW5vbmljYWxpemVBbmdsZVwiOiAoKSA9PiAoY2Fub25pY2FsaXplQW5nbGUpLFxuICBcImNsYW1wXCI6ICgpID0+IChjbGFtcCksXG4gIFwiY29udGFpbnNcIjogKCkgPT4gKGNvbnRhaW5zKSxcbiAgXCJkZWxheVwiOiAoKSA9PiAoZGVsYXkpLFxuICBcImV4dGVuZFwiOiAoKSA9PiAoZXh0ZW5kKSxcbiAgXCJmYWlsXCI6ICgpID0+IChmYWlsKSxcbiAgXCJnZXRPcHBvc2l0ZVNpZGVcIjogKCkgPT4gKGdldE9wcG9zaXRlU2lkZSksXG4gIFwiZ2V0UG9zaXRpb25cIjogKCkgPT4gKGdldFBvc2l0aW9uKSxcbiAgXCJnZXRTaWRlRnJvbURpcmVjdGlvblwiOiAoKSA9PiAoZ2V0U2lkZUZyb21EaXJlY3Rpb24pLFxuICBcIm51bGxpc2hcIjogKCkgPT4gKG51bGxpc2gpLFxuICBcInJhbmRvbUluUmFuZ2VcIjogKCkgPT4gKHJhbmRvbUluUmFuZ2UpLFxuICBcInJhbmRvbUludEluUmFuZ2VcIjogKCkgPT4gKHJhbmRvbUludEluUmFuZ2UpLFxuICBcInJhbmdlXCI6ICgpID0+IChyYW5nZSksXG4gIFwicmVtb3ZlSXRlbUZyb21BcnJheVwiOiAoKSA9PiAocmVtb3ZlSXRlbUZyb21BcnJheSksXG4gIFwidG9EZWdyZWVzXCI6ICgpID0+ICh0b0RlZ3JlZXMpLFxuICBcInRvUmFkaWFuc1wiOiAoKSA9PiAodG9SYWRpYW5zKVxufSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi4vLi4vbm9kZV9tb2R1bGVzL2NvcmUtanMvZXMvYXJyYXkvc29ydC5qc1xudmFyIHNvcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2NjIpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9vYmplY3Qva2V5cy5qc1xudmFyIGtleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgzNDMpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUG9seWZpbGwudHNcblxyXG5cclxuLyoqXHJcbiAqIFBvbHlmaWxsIGFkZGluZyBmdW5jdGlvblxyXG4gKi9cclxuZnVuY3Rpb24gcG9seWZpbGwoKSB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgd2luZG93ID0ge1xyXG4gICAgICAgICAgICBhdWRpb0NvbnRleHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9XHJcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5tb3pSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRJbnRlcnZhbChjYWxsYmFjaywgMTAwMCAvIDYwKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUpIHtcclxuICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPVxyXG4gICAgICAgICAgICB3aW5kb3cud2Via2l0Q2FuY2VsQW5pbWF0aW9uRnJhbWUgfHxcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICF3aW5kb3cuQXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQpIHtcclxuICAgICAgICAgICAgY29uc3QgY3R4ID0gd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dDtcclxuICAgICAgICAgICAgY29uc3QgcmVwbGFjZU1lID0gY3R4LnByb3RvdHlwZS5kZWNvZGVBdWRpb0RhdGE7XHJcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQucHJvdG90eXBlLmRlY29kZUF1ZGlvRGF0YSA9IGZ1bmN0aW9uIChhcnJheUJ1ZmZlcikge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXBsYWNlTWUuY2FsbCh0aGlzLCBhcnJheUJ1ZmZlciwgcmVzb2x2ZSwgcmVqZWN0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB3aW5kb3cuQXVkaW9Db250ZXh0ID1cclxuICAgICAgICAgICAgd2luZG93LkF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgd2luZG93Lm1vekF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgd2luZG93Lm1zQXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cub0F1ZGlvQ29udGV4dDtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XHJcbiAgICAgICAgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRmxhZ3MudHNcbi8qKlxyXG4gKiBGZWF0dXJlcyBpbiBwcmV2aWV3XHJcbiAqL1xyXG52YXIgRXhwZXJpbWVudHM7XHJcbihmdW5jdGlvbiAoRXhwZXJpbWVudHMpIHtcclxuICAgIEV4cGVyaW1lbnRzW1wiV2ViR0xcIl0gPSBcInVzZS13ZWJnbFwiO1xyXG59KShFeHBlcmltZW50cyB8fCAoRXhwZXJpbWVudHMgPSB7fSkpO1xyXG4vKipcclxuICogTGVnYWN5IGZlYXR1cmVzIHRoYXQgd2lsbCBnbyBhd2F5XHJcbiAqL1xyXG52YXIgTGVnYWN5O1xyXG4oZnVuY3Rpb24gKExlZ2FjeSkge1xyXG4gICAgTGVnYWN5W1wiQ2FudmFzXCJdID0gXCJ1c2UtY2FudmFzLWNvbnRleHRcIjtcclxuICAgIExlZ2FjeVtcIkxlZ2FjeURyYXdpbmdcIl0gPSBcInVzZS1sZWdhY3ktZHJhd2luZ1wiO1xyXG59KShMZWdhY3kgfHwgKExlZ2FjeSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBGbGFncyBpcyBhIGZlYXR1cmUgZmxhZyBpbXBsZW1lbnRhdGlvbiBmb3IgRXhjYWxpYnVyLiBUaGV5IGNhbiBvbmx5IGJlIG9wZXJhdGVkICoqYmVmb3JlIFtbRW5naW5lXV0gY29uc3RydWN0aW9uKipcclxuICogYWZ0ZXIgd2hpY2ggdGhleSBhcmUgZnJvemVuIGFuZCBhcmUgcmVhZC1vbmx5LlxyXG4gKlxyXG4gKiBGbGFncyBhcmUgdXNlZCB0byBlbmFibGUgZXhwZXJpbWVudGFsIG9yIHByZXZpZXcgZmVhdHVyZXMgaW4gRXhjYWxpYnVyLlxyXG4gKi9cclxuY2xhc3MgRmxhZ3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBGcmVlemUgYWxsIGZsYWcgbW9kaWZpY2F0aW9ucyBtYWtpbmcgdGhlbSByZWFkb25seVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJlZXplKCkge1xyXG4gICAgICAgIEZsYWdzLl9GUk9aRU4gPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgaW50ZXJuYWwgZmxhZyBzdGF0ZSwgbm90IG1lYW50IHRvIGJlIGNhbGxlZCBieSB1c2Vycy4gT25seSB1c2VkIGZvciB0ZXN0aW5nLlxyXG4gICAgICpcclxuICAgICAqIENhbGxpbmcgdGhpcyBpbiB5b3VyIGdhbWUgaXMgVU5TVVBQT1JURURcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgX3Jlc2V0KCkge1xyXG4gICAgICAgIEZsYWdzLl9GUk9aRU4gPSBmYWxzZTtcclxuICAgICAgICBGbGFncy5fRkxBR1MgPSB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHVybiBvbiB3ZWJnbCBzdXBwb3J0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1c2VXZWJHTCgpIHtcclxuICAgICAgICBGbGFncy5lbmFibGUoRXhwZXJpbWVudHMuV2ViR0wpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHVzZUNhbnZhc0dyYXBoaWNzQ29udGV4dCgpIHtcclxuICAgICAgICBGbGFncy5lbmFibGUoTGVnYWN5LkNhbnZhcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIFJlY29tbWVuZGVkIG5vdCB0byB1c2UgbGVnYWN5IGRyYXdpbmcsIGdvaW5nIGF3YXkgaW4gdjAuMjYuMFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdXNlTGVnYWN5RHJhd2luZygpIHtcclxuICAgICAgICBGbGFncy5lbmFibGUoTGVnYWN5LkxlZ2FjeURyYXdpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgYSBzcGVjaWZpYyBmZWF0dXJlIGZsYWcgYnkgbmFtZS4gKipOb3RlOiBjYW4gb25seSBiZSBzZXQgYmVmb3JlIFtbRW5naW5lXV0gY29uc3RydWN0b3IgdGltZSoqXHJcbiAgICAgKiBAcGFyYW0gZmxhZ05hbWVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGVuYWJsZShmbGFnTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9GUk9aRU4pIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ZlYXR1cmUgZmxhZ3MgY2FuIG9ubHkgYmUgZW5hYmxlZCBiZWZvcmUgRW5naW5lIGNvbnN0cnVjdG9yIHRpbWUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRmxhZ3MuX0ZMQUdTW2ZsYWdOYW1lXSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGUgYSBzcGVjaWZpYyBmZWF0dXJlIGZsYWcgYnkgbmFtZS4gKipOb3RlOiBjYW4gb25seSBiZSBzZXQgYmVmb3JlIFtbRW5naW5lXV0gY29uc3RydWN0b3IgdGltZSoqXHJcbiAgICAgKiBAcGFyYW0gZmxhZ05hbWVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGRpc2FibGUoZmxhZ05hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fRlJPWkVOKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdGZWF0dXJlIGZsYWdzIGNhbiBvbmx5IGJlIGRpc2FibGVkIGJlZm9yZSBFbmdpbmUgY29uc3RydWN0b3IgdGltZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBGbGFncy5fRkxBR1NbZmxhZ05hbWVdID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGEgZmxhZyBpcyBlbmFibGVkLiBJZiB0aGUgZmxhZyBpcyBkaXNhYmxlZCBvciBkb2VzIG5vdCBleGlzdCBgZmFsc2VgIGlzIHJldHVybmVkXHJcbiAgICAgKiBAcGFyYW0gZmxhZ05hbWVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzRW5hYmxlZChmbGFnTmFtZSkge1xyXG4gICAgICAgIHJldHVybiAhIUZsYWdzLl9GTEFHU1tmbGFnTmFtZV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgYSBsaXN0IG9mIGN1cnJlbnRseSBrbm93biBmbGFnc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgc2hvdygpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoRmxhZ3MuX0ZMQUdTKTtcclxuICAgIH1cclxufVxyXG5GbGFncy5fRlJPWkVOID0gZmFsc2U7XHJcbkZsYWdzLl9GTEFHUyA9IHt9O1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lkLnRzXG4vKipcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZUlkKHR5cGUsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4geyB0eXBlLCB2YWx1ZSB9O1xyXG59XHJcbjtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL0xvZy50c1xuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xyXG4vKipcclxuICogTG9nZ2luZyBsZXZlbCB0aGF0IEV4Y2FsaWJ1ciB3aWxsIHRhZ1xyXG4gKi9cclxudmFyIExvZ0xldmVsO1xyXG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkRlYnVnXCJdID0gMF0gPSBcIkRlYnVnXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIkluZm9cIl0gPSAxXSA9IFwiSW5mb1wiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJXYXJuXCJdID0gMl0gPSBcIldhcm5cIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRXJyb3JcIl0gPSAzXSA9IFwiRXJyb3JcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRmF0YWxcIl0gPSA0XSA9IFwiRmF0YWxcIjtcclxufSkoTG9nTGV2ZWwgfHwgKExvZ0xldmVsID0ge30pKTtcclxuLyoqXHJcbiAqIFN0YXRpYyBzaW5nbGV0b24gdGhhdCByZXByZXNlbnRzIHRoZSBsb2dnaW5nIGZhY2lsaXR5IGZvciBFeGNhbGlidXIuXHJcbiAqIEV4Y2FsaWJ1ciBjb21lcyBidWlsdC1pbiB3aXRoIGEgW1tDb25zb2xlQXBwZW5kZXJdXSBhbmQgW1tTY3JlZW5BcHBlbmRlcl1dLlxyXG4gKiBEZXJpdmUgZnJvbSBbW0FwcGVuZGVyXV0gdG8gY3JlYXRlIHlvdXIgb3duIGxvZ2dpbmcgYXBwZW5kZXJzLlxyXG4gKi9cclxuY2xhc3MgTG9nZ2VyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2FwcGVuZGVycyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZGVmYXVsdCBsb2dnaW5nIGxldmVsLiBFeGNhbGlidXIgd2lsbCBvbmx5IGxvZ1xyXG4gICAgICAgICAqIG1lc3NhZ2VzIGlmIGVxdWFsIHRvIG9yIGFib3ZlIHRoaXMgbGV2ZWwuIERlZmF1bHQ6IFtbTG9nTGV2ZWwuSW5mb11dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kZWZhdWx0TGV2ZWwgPSBMb2dMZXZlbC5JbmZvO1xyXG4gICAgICAgIGlmIChMb2dnZXIuX0lOU1RBTkNFKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9nZ2VyIGlzIGEgc2luZ2xldG9uJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIExvZ2dlci5fSU5TVEFOQ0UgPSB0aGlzO1xyXG4gICAgICAgIC8vIERlZmF1bHQgY29uc29sZSBhcHBlbmRlclxyXG4gICAgICAgIExvZ2dlci5fSU5TVEFOQ0UuYWRkQXBwZW5kZXIobmV3IENvbnNvbGVBcHBlbmRlcigpKTtcclxuICAgICAgICByZXR1cm4gTG9nZ2VyLl9JTlNUQU5DRTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBzdGF0aWMgaW5zdGFuY2Ugb2YgTG9nZ2VyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZSgpIHtcclxuICAgICAgICBpZiAoTG9nZ2VyLl9JTlNUQU5DRSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5fSU5TVEFOQ0UgPSBuZXcgTG9nZ2VyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBMb2dnZXIuX0lOU1RBTkNFO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IFtbQXBwZW5kZXJdXSB0byB0aGUgbGlzdCBvZiBhcHBlbmRlcnMgdG8gd3JpdGUgdG9cclxuICAgICAqL1xyXG4gICAgYWRkQXBwZW5kZXIoYXBwZW5kZXIpIHtcclxuICAgICAgICB0aGlzLl9hcHBlbmRlcnMucHVzaChhcHBlbmRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbGwgYXBwZW5kZXJzIGZyb20gdGhlIGxvZ2dlclxyXG4gICAgICovXHJcbiAgICBjbGVhckFwcGVuZGVycygpIHtcclxuICAgICAgICB0aGlzLl9hcHBlbmRlcnMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9ncyBhIG1lc3NhZ2UgYXQgYSBnaXZlbiBMb2dMZXZlbFxyXG4gICAgICogQHBhcmFtIGxldmVsICBUaGUgTG9nTGV2ZWxgdG8gbG9nIHRoZSBtZXNzYWdlIGF0XHJcbiAgICAgKiBAcGFyYW0gYXJncyAgIEFuIGFycmF5IG9mIGFyZ3VtZW50cyB0byB3cml0ZSB0byBhbiBhcHBlbmRlclxyXG4gICAgICovXHJcbiAgICBfbG9nKGxldmVsLCBhcmdzKSB7XHJcbiAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcclxuICAgICAgICAgICAgbGV2ZWwgPSB0aGlzLmRlZmF1bHRMZXZlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYXBwZW5kZXJzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChsZXZlbCA+PSB0aGlzLmRlZmF1bHRMZXZlbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kZXJzW2ldLmxvZyhsZXZlbCwgYXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkRlYnVnXV0gbGV2ZWxcclxuICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuRGVidWcsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgW1tMb2dMZXZlbC5JbmZvXV0gbGV2ZWxcclxuICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIGluZm8oLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5JbmZvLCBhcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIFtbTG9nTGV2ZWwuV2Fybl1dIGxldmVsXHJcbiAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICovXHJcbiAgICB3YXJuKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuV2FybiwgYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkVycm9yXV0gbGV2ZWxcclxuICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIGVycm9yKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuRXJyb3IsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgW1tMb2dMZXZlbC5GYXRhbF1dIGxldmVsXHJcbiAgICAgKiBAcGFyYW0gYXJncyAgQWNjZXB0cyBhbnkgbnVtYmVyIG9mIGFyZ3VtZW50c1xyXG4gICAgICovXHJcbiAgICBmYXRhbCguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkZhdGFsLCBhcmdzKTtcclxuICAgIH1cclxufVxyXG5Mb2dnZXIuX0lOU1RBTkNFID0gbnVsbDtcclxuLyoqXHJcbiAqIENvbnNvbGUgYXBwZW5kZXIgZm9yIGJyb3dzZXJzIChpLmUuIGBjb25zb2xlLmxvZ2ApXHJcbiAqL1xyXG5jbGFzcyBDb25zb2xlQXBwZW5kZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUgZ2l2ZW4gW1tMb2dMZXZlbF1dXHJcbiAgICAgKiBAcGFyYW0gbGV2ZWwgIExldmVsIHRvIGxvZyBhdFxyXG4gICAgICogQHBhcmFtIGFyZ3MgICBBcmd1bWVudHMgdG8gbG9nXHJcbiAgICAgKi9cclxuICAgIGxvZyhsZXZlbCwgYXJncykge1xyXG4gICAgICAgIC8vIENoZWNrIGZvciBjb25zb2xlIHN1cHBvcnRcclxuICAgICAgICBpZiAoIWNvbnNvbGUgJiYgIWNvbnNvbGUubG9nICYmIGNvbnNvbGUud2FybiAmJiBjb25zb2xlLmVycm9yKSB7XHJcbiAgICAgICAgICAgIC8vIHRvZG8gbWF5YmUgZG8gc29tZXRoaW5nIGJldHRlciB0aGFuIG5vdGhpbmdcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29uc29sZSBhcmdzIGFycmF5XHJcbiAgICAgICAgY29uc3QgY29uc29sZUFyZ3MgPSBbXTtcclxuICAgICAgICBjb25zb2xlQXJncy51bnNoaWZ0LmFwcGx5KGNvbnNvbGVBcmdzLCBhcmdzKTtcclxuICAgICAgICBjb25zb2xlQXJncy51bnNoaWZ0KCdbJyArIExvZ0xldmVsW2xldmVsXSArICddIDogJyk7XHJcbiAgICAgICAgaWYgKGxldmVsIDwgTG9nTGV2ZWwuV2Fybikge1xyXG4gICAgICAgICAgICAvLyBDYWxsIC5sb2cgZm9yIERlYnVnL0luZm9cclxuICAgICAgICAgICAgaWYgKGNvbnNvbGUubG9nLmFwcGx5KSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHJlcXVpcmVkIG9uIHNvbWUgb2xkZXIgYnJvd3NlcnMgdGhhdCBkb24ndCBzdXBwb3J0IGFwcGx5IG9uIGNvbnNvbGUubG9nIDooXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjb25zb2xlQXJncy5qb2luKCcgJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGxldmVsIDwgTG9nTGV2ZWwuRXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gQ2FsbCAud2FybiBmb3IgV2FyblxyXG4gICAgICAgICAgICBpZiAoY29uc29sZS53YXJuLmFwcGx5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgY29uc29sZUFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIENhbGwgLmVycm9yIGZvciBFcnJvci9GYXRhbFxyXG4gICAgICAgICAgICBpZiAoY29uc29sZS5lcnJvci5hcHBseSkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIE9uLXNjcmVlbiAoY2FudmFzKSBhcHBlbmRlclxyXG4gKi9cclxuY2xhc3MgU2NyZWVuQXBwZW5kZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggICBXaWR0aCBvZiB0aGUgc2NyZWVuIGFwcGVuZGVyIGluIHBpeGVsc1xyXG4gICAgICogQHBhcmFtIGhlaWdodCAgSGVpZ2h0IG9mIHRoZSBzY3JlZW4gYXBwZW5kZXIgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICAvLyBAdG9kbyBDbGVhbiB0aGlzIHVwXHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSB3aWR0aCB8fCB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gaGVpZ2h0IHx8IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgIHRoaXMuX2N0eCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCB0aGUgZ2l2ZW4gW1tMb2dMZXZlbF1dXHJcbiAgICAgKiBAcGFyYW0gbGV2ZWwgIExldmVsIHRvIGxvZyBhdFxyXG4gICAgICogQHBhcmFtIGFyZ3MgICBBcmd1bWVudHMgdG8gbG9nXHJcbiAgICAgKi9cclxuICAgIGxvZyhsZXZlbCwgYXJncykge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBhcmdzLmpvaW4oJywnKTtcclxuICAgICAgICB0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2NhbnZhcy53aWR0aCwgdGhpcy5fY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fbWVzc2FnZXMudW5zaGlmdCgnWycgKyBMb2dMZXZlbFtsZXZlbF0gKyAnXSA6ICcgKyBtZXNzYWdlKTtcclxuICAgICAgICBsZXQgcG9zID0gMTA7XHJcbiAgICAgICAgbGV0IG9wYWNpdHkgPSAxLjA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9tZXNzYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gJ3JnYmEoMjU1LDI1NSwyNTUsJyArIG9wYWNpdHkudG9GaXhlZCgyKSArICcpJztcclxuICAgICAgICAgICAgdGhpcy5fY3R4LmZpbGxUZXh0KHRoaXMuX21lc3NhZ2VzW2ldLCAyMDAsIHBvcyk7XHJcbiAgICAgICAgICAgIHBvcyArPSAxMDtcclxuICAgICAgICAgICAgb3BhY2l0eSA9IG9wYWNpdHkgPiAwID8gb3BhY2l0eSAtIDAuMDUgOiAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL01hdGgvUmFuZG9tLnRzXG4vKipcclxuICogQG1vZHVsZVxyXG4gKiBQc2V1ZG8tUmFuZG9tIFV0aWxpdHlcclxuICpcclxuICogQSBwc2V1ZG8tcmFuZG9tIHV0aWxpdHkgdG8gYWRkIHNlZWRlZCByYW5kb20gc3VwcG9ydCBmb3IgaGVscCBpblxyXG4gKiBnZW5lcmF0aW5nIHRoaW5ncyBsaWtlIHRlcnJhaW4gb3IgcmVwcm9kdWNpYmxlIHJhbmRvbW5lc3MuIFVzZXMgdGhlXHJcbiAqIFtNZXJzZW5uZSBUd2lzdGVyXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXJzZW5uZV9Ud2lzdGVyKSBhbGdvcml0aG0uXHJcbiAqL1xyXG4vKipcclxuICogMzItYml0IG1hc2tcclxuICovXHJcbmNvbnN0IEJJVE1BU0szMiA9IDB4ZmZmZmZmZmY7XHJcbi8qKlxyXG4gKiBQc2V1ZG8tcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgZm9sbG93aW5nIHRoZSBNZXJzZW5uZV9Ud2lzdGVyIGFsZ29yaXRobS4gR2l2ZW4gYSBzZWVkIHRoaXMgZ2VuZXJhdG9yIHdpbGwgcHJvZHVjZSB0aGUgc2FtZSBzZXF1ZW5jZVxyXG4gKiBvZiBudW1iZXJzIGVhY2ggdGltZSBpdCBpcyBjYWxsZWQuXHJcbiAqIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZXJzZW5uZV9Ud2lzdGVyIGZvciBtb3JlIGRldGFpbHMuXHJcbiAqIFVzZXMgdGhlIE1UMTk5MzctMzIgKDIwMDIpIGltcGxlbWVudGF0aW9uIGRvY3VtZW50ZWQgaGVyZSBodHRwOi8vd3d3Lm1hdGguc2NpLmhpcm9zaGltYS11LmFjLmpwL35tLW1hdC9NVC9NVDIwMDIvZW10MTk5Mzdhci5odG1sXHJcbiAqXHJcbiAqIEFwaSBpbnNwaXJlZCBieSBodHRwOi8vY2hhbmNlanMuY29tLyMgaHR0cHM6Ly9naXRodWIuY29tL2NoYW5jZWpzL2NoYW5jZWpzXHJcbiAqL1xyXG5jbGFzcyBSYW5kb20ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBubyBzZWVkIGlzIHNwZWNpZmllZCwgdGhlIERhdGUubm93KCkgaXMgdXNlZFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihzZWVkKSB7XHJcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcclxuICAgICAgICAvLyBTZXBhcmF0aW9uIHBvaW50IG9mIG9uZSBvbmUgd29yZCwgdGhlIG51bWJlciBvZiBiaXRzIGluIHRoZSBsb3dlciBiaXRtYXNrIDAgPD0gciA8PSB3LTFcclxuICAgICAgICB0aGlzLl9sb3dlck1hc2sgPSAweDdmZmZmZmZmOyAvLyAzMSBiaXRzIHNhbWUgYXMgX3JcclxuICAgICAgICB0aGlzLl91cHBlck1hc2sgPSAweDgwMDAwMDAwOyAvLyAzNCBoaWdoIGJpdHNcclxuICAgICAgICAvLyBXb3JkIHNpemUsIDY0IGJpdHNcclxuICAgICAgICB0aGlzLl93ID0gMzI7XHJcbiAgICAgICAgLy8gRGVncmVlIG9mIHJlY3VycmVuY2VcclxuICAgICAgICB0aGlzLl9uID0gNjI0O1xyXG4gICAgICAgIC8vIE1pZGRsZSB3b3JkLCBhbiBvZmZzZXQgdXNlZCBpbiB0aGUgcmVjdXJyZW5jZSBkZWZpbmluZyB0aGUgc2VyaWVzIHgsIDE8PW08blxyXG4gICAgICAgIHRoaXMuX20gPSAzOTc7XHJcbiAgICAgICAgLy8gY29lZmZpY2llbnRzIG9mIHRlaCByYXRpb25hbCBub3JtYWwgZm9ybSB0d2lzdCBtYXRyaXhcclxuICAgICAgICB0aGlzLl9hID0gMHg5OTA4YjBkZjtcclxuICAgICAgICAvLyB0ZW1wZXJpbmcgYml0IHNoaWZ0cyBhbmQgbWFza3NcclxuICAgICAgICB0aGlzLl91ID0gMTE7XHJcbiAgICAgICAgdGhpcy5fcyA9IDc7XHJcbiAgICAgICAgdGhpcy5fYiA9IDB4OWQyYzU2ODA7XHJcbiAgICAgICAgdGhpcy5fdCA9IDE1O1xyXG4gICAgICAgIHRoaXMuX2MgPSAweGVmYzYwMDAwO1xyXG4gICAgICAgIHRoaXMuX2wgPSAxODtcclxuICAgICAgICB0aGlzLl9mID0gMTgxMjQzMzI1MztcclxuICAgICAgICB0aGlzLl9tdCA9IG5ldyBBcnJheSh0aGlzLl9uKTtcclxuICAgICAgICAvLyBuZWVkIHRvIG1hc2sgdG8gc3VwcG9ydCBoaWdoZXIgYml0IG1hY2hpbmVzXHJcbiAgICAgICAgdGhpcy5fbXRbMF0gPSAoc2VlZCB8fCBEYXRlLm5vdygpKSA+Pj4gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuX247IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5fbXRbaSAtIDFdIF4gKHRoaXMuX210W2kgLSAxXSA+Pj4gKHRoaXMuX3cgLSAyKSk7XHJcbiAgICAgICAgICAgIC8vIG51bWJlcnMgYXJlIGJpZ2dlciB0aGFuIHRoZSBKUyBtYXggc2FmZSBpbnQsIGFkZCBpbiAxNi1iaXQgY2h1bmtzIHRvIHByZXZlbnQgSUVFRSByb3VuZGluZyBlcnJvcnMgb24gaGlnaCBiaXRzXHJcbiAgICAgICAgICAgIHRoaXMuX210W2ldID0gKCgodGhpcy5fZiAqICgocyAmIDB4ZmZmZjAwMDApID4+PiAxNikpIDw8IDE2KSArIHRoaXMuX2YgKiAocyAmIDB4ZmZmZikgKyBpKSA+Pj4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSB0aGlzLl9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0aGUgdHdpc3RcclxuICAgICAqL1xyXG4gICAgX3R3aXN0KCkge1xyXG4gICAgICAgIGNvbnN0IG1hZzAxID0gWzB4MCwgdGhpcy5fYV07XHJcbiAgICAgICAgbGV0IHkgPSAwLCBpID0gMDtcclxuICAgICAgICBmb3IgKDsgaSA8IHRoaXMuX24gLSB0aGlzLl9tOyBpKyspIHtcclxuICAgICAgICAgICAgeSA9ICh0aGlzLl9tdFtpXSAmIHRoaXMuX3VwcGVyTWFzaykgfCAodGhpcy5fbXRbaSArIDFdICYgdGhpcy5fbG93ZXJNYXNrKTtcclxuICAgICAgICAgICAgdGhpcy5fbXRbaV0gPSB0aGlzLl9tdFtpICsgdGhpcy5fbV0gXiAoeSA+Pj4gMSkgXiAobWFnMDFbeSAmIDB4MV0gJiBCSVRNQVNLMzIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKDsgaSA8IHRoaXMuX24gLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgeSA9ICh0aGlzLl9tdFtpXSAmIHRoaXMuX3VwcGVyTWFzaykgfCAodGhpcy5fbXRbaSArIDFdICYgdGhpcy5fbG93ZXJNYXNrKTtcclxuICAgICAgICAgICAgdGhpcy5fbXRbaV0gPSB0aGlzLl9tdFtpICsgKHRoaXMuX20gLSB0aGlzLl9uKV0gXiAoeSA+Pj4gMSkgXiAobWFnMDFbeSAmIDB4MV0gJiBCSVRNQVNLMzIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB5ID0gKHRoaXMuX210W3RoaXMuX24gLSAxXSAmIHRoaXMuX3VwcGVyTWFzaykgfCAodGhpcy5fbXRbMF0gJiB0aGlzLl9sb3dlck1hc2spO1xyXG4gICAgICAgIHRoaXMuX210W3RoaXMuX24gLSAxXSA9IHRoaXMuX210W3RoaXMuX20gLSAxXSBeICh5ID4+PiAxKSBeIChtYWcwMVt5ICYgMHgxXSAmIEJJVE1BU0szMik7XHJcbiAgICAgICAgdGhpcy5faW5kZXggPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gbmV4dCAzMiBiaXQgaW50ZWdlciBudW1iZXIgaW4gc2VxdWVuY2VcclxuICAgICAqL1xyXG4gICAgbmV4dEludCgpIHtcclxuICAgICAgICBpZiAodGhpcy5faW5kZXggPj0gdGhpcy5fbikge1xyXG4gICAgICAgICAgICB0aGlzLl90d2lzdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgeSA9IHRoaXMuX210W3RoaXMuX2luZGV4KytdO1xyXG4gICAgICAgIHkgXj0geSA+Pj4gdGhpcy5fdTtcclxuICAgICAgICB5IF49ICh5IDw8IHRoaXMuX3MpICYgdGhpcy5fYjtcclxuICAgICAgICB5IF49ICh5IDw8IHRoaXMuX3QpICYgdGhpcy5fYztcclxuICAgICAgICB5IF49IHkgPj4+IHRoaXMuX2w7XHJcbiAgICAgICAgcmV0dXJuIHkgPj4+IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJhbmRvbSBmbG9hdGluZyBwb2ludCBudW1iZXIgYmV0d2VlbiBbMCwgMSlcclxuICAgICAqL1xyXG4gICAgbmV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0SW50KCkgKiAoMS4wIC8gNDI5NDk2NzI5Ni4wKTsgLy8gZGl2aWRlZCBieSAyXjMyXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJhbmRvbSBmbG9hdGluZyBwb2ludCBpbiByYW5nZSBbbWluLCBtYXgpIG1pbiBpcyBpbmNsdWRlZCwgbWF4IGlzIG5vdCBpbmNsdWRlZFxyXG4gICAgICovXHJcbiAgICBmbG9hdGluZyhtaW4sIG1heCkge1xyXG4gICAgICAgIHJldHVybiAobWF4IC0gbWluKSAqIHRoaXMubmV4dCgpICsgbWluO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSByYW5kb20gaW50ZWdlciBpbiByYW5nZSBbbWluLCBtYXhdIG1pbiBpcyBpbmNsdWRlZCwgbWF4IGlzIGluY2x1ZGVkLlxyXG4gICAgICogSW1wbGVtZW50ZWQgd2l0aCByZWplY3Rpb24gc2FtcGxpbmcsIHNlZSBodHRwczovL21lZGl1bS5jb20vQGJldGFibGUvdGlmdS1ieS11c2luZy1tYXRoLXJhbmRvbS1mMWMzMDhjNGZkOWQjLmkxM3RkaXU1YVxyXG4gICAgICovXHJcbiAgICBpbnRlZ2VyKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKG1heCAtIG1pbiArIDEpICogdGhpcy5uZXh0KCkgKyBtaW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgb3IgZmFsc2UgcmFuZG9tbHkgd2l0aCA1MC81MCBvZGRzIGJ5IGRlZmF1bHQuXHJcbiAgICAgKiBCeSBkZWZhdWx0IHRoZSBsaWtlbGlob29kIG9mIHJldHVybmluZyBhIHRydWUgaXMgLjUgKDUwJSkuXHJcbiAgICAgKiBAcGFyYW0gbGlrZWxpaG9vZCB0YWtlcyB2YWx1ZXMgYmV0d2VlbiBbMCwgMV1cclxuICAgICAqL1xyXG4gICAgYm9vbChsaWtlbGlob29kID0gMC41KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubmV4dCgpIDw9IGxpa2VsaWhvb2Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgb25lIGVsZW1lbnQgZnJvbSBhbiBhcnJheSBhdCByYW5kb21cclxuICAgICAqL1xyXG4gICAgcGlja09uZShhcnJheSkge1xyXG4gICAgICAgIHJldHVybiBhcnJheVt0aGlzLmludGVnZXIoMCwgYXJyYXkubGVuZ3RoIC0gMSldO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbmV3IGFycmF5IHJhbmRvbSBwaWNraW5nIGVsZW1lbnRzIGZyb20gdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBAcGFyYW0gYXJyYXkgT3JpZ2luYWwgYXJyYXkgdG8gcGljayBmcm9tXHJcbiAgICAgKiBAcGFyYW0gbnVtUGlja3MgY2FuIGJlIGFueSBwb3NpdGl2ZSBudW1iZXJcclxuICAgICAqIEBwYXJhbSBhbGxvd0R1cGxpY2F0ZXMgaW5kaWNhdGVzIHdoZXRoZXIgdGhlIHJldHVybmVkIHNldCBpcyBhbGxvd2VkIGR1cGxpY2F0ZXMgKGl0IGRvZXMgbm90IG1lYW4gdGhlcmUgd2lsbCBhbHdheXMgYmUgZHVwbGljYXRlc1xyXG4gICAgICoganVzdCB0aGF0IGl0IGlzIHBvc3NpYmxlKVxyXG4gICAgICovXHJcbiAgICBwaWNrU2V0KGFycmF5LCBudW1QaWNrcywgYWxsb3dEdXBsaWNhdGVzID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoYWxsb3dEdXBsaWNhdGVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9waWNrU2V0V2l0aER1cGxpY2F0ZXMoYXJyYXksIG51bVBpY2tzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9waWNrU2V0V2l0aG91dER1cGxpY2F0ZXMoYXJyYXksIG51bVBpY2tzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgcmFuZG9tbHkgcGlja2luZyBlbGVtZW50cyBpbiB0aGUgb3JpZ2luYWwgKG5vdCByZXVzZWQpXHJcbiAgICAgKiBAcGFyYW0gYXJyYXkgQXJyYXkgdG8gcGljayBlbGVtZW50cyBvdXQgb2ZcclxuICAgICAqIEBwYXJhbSBudW1QaWNrcyBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheS5cclxuICAgICAqL1xyXG4gICAgX3BpY2tTZXRXaXRob3V0RHVwbGljYXRlcyhhcnJheSwgbnVtUGlja3MpIHtcclxuICAgICAgICBpZiAobnVtUGlja3MgPiBhcnJheS5sZW5ndGggfHwgbnVtUGlja3MgPCAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBudW1iZXIgb2YgZWxlbWVudHMgdG8gcGljaywgbXVzdCBwaWNrIGEgdmFsdWUgMCA8IG4gPD0gbGVuZ3RoJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChudW1QaWNrcyA9PT0gYXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KG51bVBpY2tzKTtcclxuICAgICAgICBsZXQgY3VycmVudFBpY2sgPSAwO1xyXG4gICAgICAgIGNvbnN0IHRlbXBBcnJheSA9IGFycmF5LnNsaWNlKDApO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50UGljayA8IG51bVBpY2tzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5pbnRlZ2VyKDAsIHRlbXBBcnJheS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgcmVzdWx0W2N1cnJlbnRQaWNrKytdID0gdGVtcEFycmF5W2luZGV4XTtcclxuICAgICAgICAgICAgdGVtcEFycmF5LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgcmFuZG9tIHBpY2tpbmcgZWxlbWVudHMgZnJvbSB0aGUgb3JpZ2luYWwgYWxsb3dpbmcgZHVwbGljYXRlc1xyXG4gICAgICogQHBhcmFtIGFycmF5IEFycmF5IHRvIHBpY2sgZWxlbWVudHMgb3V0IG9mXHJcbiAgICAgKiBAcGFyYW0gbnVtUGlja3MgY2FuIGJlIGFueSBwb3NpdGl2ZSBudW1iZXJcclxuICAgICAqL1xyXG4gICAgX3BpY2tTZXRXaXRoRHVwbGljYXRlcyhhcnJheSwgbnVtUGlja3MpIHtcclxuICAgICAgICAvLyBUeXBlc2NyaXB0IG51bWJlcnMgYXJlIGFsbCBmbG9hdGluZyBwb2ludCwgc28gZG8gd2UgYWRkIGNoZWNrIGZvciBpbnQ/IChvciBmbG9vciB0aGUgaW5wdXQ/KVxyXG4gICAgICAgIGlmIChudW1QaWNrcyA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyB0byBwaWNrLCBtdXN0IHBpY2sgYSB2YWx1ZSAwIDw9IG4gPCBNQVhfSU5UJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShudW1QaWNrcyk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1QaWNrczsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMucGlja09uZShhcnJheSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgdGhhdCBoYXMgaXRzIGVsZW1lbnRzIHNodWZmbGVkLiBVc2luZyB0aGUgRmlzaGVyL1lhdGVzIG1ldGhvZFxyXG4gICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVyJUUyJTgwJTkzWWF0ZXNfc2h1ZmZsZVxyXG4gICAgICovXHJcbiAgICBzaHVmZmxlKGFycmF5KSB7XHJcbiAgICAgICAgY29uc3QgdGVtcEFycmF5ID0gYXJyYXkuc2xpY2UoMCk7XHJcbiAgICAgICAgbGV0IHN3YXAgPSBudWxsO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVtcEFycmF5Lmxlbmd0aCAtIDI7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCByYW5kb21JbmRleCA9IHRoaXMuaW50ZWdlcihpLCB0ZW1wQXJyYXkubGVuZ3RoIC0gMSk7XHJcbiAgICAgICAgICAgIHN3YXAgPSB0ZW1wQXJyYXlbaV07XHJcbiAgICAgICAgICAgIHRlbXBBcnJheVtpXSA9IHRlbXBBcnJheVtyYW5kb21JbmRleF07XHJcbiAgICAgICAgICAgIHRlbXBBcnJheVtyYW5kb21JbmRleF0gPSBzd2FwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGVtcEFycmF5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZW5lcmF0ZSBhIGxpc3Qgb2YgcmFuZG9tIGludGVnZXIgbnVtYmVyc1xyXG4gICAgICogQHBhcmFtIGxlbmd0aCB0aGUgbGVuZ3RoIG9mIHRoZSBmaW5hbCBhcnJheVxyXG4gICAgICogQHBhcmFtIG1pbiB0aGUgbWluaW11bSBpbnRlZ2VyIG51bWJlciB0byBnZW5lcmF0ZSBpbmNsdXNpdmVcclxuICAgICAqIEBwYXJhbSBtYXggdGhlIG1heGltdW0gaW50ZWdlciBudW1iZXIgdG8gZ2VuZXJhdGUgaW5jbHVzaXZlXHJcbiAgICAgKi9cclxuICAgIHJhbmdlKGxlbmd0aCwgbWluLCBtYXgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuaW50ZWdlcihtaW4sIG1heCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQ0IGRpY2Ugcm9sbFxyXG4gICAgICovXHJcbiAgICBkNCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkNiBkaWNlIHJvbGxcclxuICAgICAqL1xyXG4gICAgZDYoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCA2KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDggZGljZSByb2xsXHJcbiAgICAgKi9cclxuICAgIGQ4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgOCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQxMCBkaWNlIHJvbGxcclxuICAgICAqL1xyXG4gICAgZDEwKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgMTApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkMTIgZGljZSByb2xsXHJcbiAgICAgKi9cclxuICAgIGQxMigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDEyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDIwIGRpY2Ugcm9sbFxyXG4gICAgICovXHJcbiAgICBkMjAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCAyMCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vU2lkZS50c1xuXHJcbi8qKlxyXG4gKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIHRoZSBzaWRlcyBvZiBhbiBheGlzIGFsaWduZWQgYm94IGZvciBjb2xsaXNpb25cclxuICovXHJcbnZhciBTaWRlO1xyXG4oZnVuY3Rpb24gKFNpZGUpIHtcclxuICAgIFNpZGVbXCJOb25lXCJdID0gXCJOb25lXCI7XHJcbiAgICBTaWRlW1wiVG9wXCJdID0gXCJUb3BcIjtcclxuICAgIFNpZGVbXCJCb3R0b21cIl0gPSBcIkJvdHRvbVwiO1xyXG4gICAgU2lkZVtcIkxlZnRcIl0gPSBcIkxlZnRcIjtcclxuICAgIFNpZGVbXCJSaWdodFwiXSA9IFwiUmlnaHRcIjtcclxufSkoU2lkZSB8fCAoU2lkZSA9IHt9KSk7XHJcbihmdW5jdGlvbiAoU2lkZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBvcHBvc2l0ZSBzaWRlIGZyb20gdGhlIGN1cnJlbnRcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0T3Bwb3NpdGUoc2lkZSkge1xyXG4gICAgICAgIGlmIChzaWRlID09PSBTaWRlLlRvcCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2lkZS5Cb3R0b207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaWRlID09PSBTaWRlLkJvdHRvbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2lkZS5Ub3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaWRlID09PSBTaWRlLkxlZnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNpZGUuUmlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaWRlID09PSBTaWRlLlJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlLkxlZnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBTaWRlLk5vbmU7XHJcbiAgICB9XHJcbiAgICBTaWRlLmdldE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGU7XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgdmVjdG9yLCByZXR1cm4gdGhlIFNpZGUgbW9zdCBpbiB0aGF0IGRpcmVjdGlvbiAodmlhIGRvdCBwcm9kdWN0KVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBmcm9tRGlyZWN0aW9uKGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbnMgPSBbVmVjdG9yLkxlZnQsIFZlY3Rvci5SaWdodCwgVmVjdG9yLlVwLCBWZWN0b3IuRG93bl07XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uRW51bSA9IFtTaWRlLkxlZnQsIFNpZGUuUmlnaHQsIFNpZGUuVG9wLCBTaWRlLkJvdHRvbV07XHJcbiAgICAgICAgbGV0IG1heCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGxldCBtYXhJbmRleCA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZGlyZWN0aW9uc1tpXS5kb3QoZGlyZWN0aW9uKSA+IG1heCkge1xyXG4gICAgICAgICAgICAgICAgbWF4ID0gZGlyZWN0aW9uc1tpXS5kb3QoZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgICAgIG1heEluZGV4ID0gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZGlyZWN0aW9uRW51bVttYXhJbmRleF07XHJcbiAgICB9XHJcbiAgICBTaWRlLmZyb21EaXJlY3Rpb24gPSBmcm9tRGlyZWN0aW9uO1xyXG59KShTaWRlIHx8IChTaWRlID0ge30pKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL1V0aWwudHNcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUd28gUEkgY29uc3RhbnRcclxuICovXHJcbmNvbnN0IFR3b1BJID0gTWF0aC5QSSAqIDI7XHJcbi8qKlxyXG4gKiBNZXJnZXMgb25lIG9yIG1vcmUgb2JqZWN0cyBpbnRvIGEgc2luZ2xlIHRhcmdldCBvYmplY3RcclxuICpcclxuICogQHJldHVybnMgTWVyZ2VkIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgZnJvbSBvdGhlciBvYmplY3RzXHJcbiAqIEBjcmVkaXQgaHR0cHM6Ly9nb21ha2V0aGluZ3MuY29tL3ZhbmlsbGEtamF2YXNjcmlwdC12ZXJzaW9uLW9mLWpxdWVyeS1leHRlbmQvXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRlbmQoKSB7XHJcbiAgICBjb25zdCBleHRlbmRlZCA9IHt9O1xyXG4gICAgbGV0IGRlZXAgPSBmYWxzZTtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGNvbnN0IGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XHJcbiAgICAvLyBDaGVjayBpZiBhIGRlZXAgbWVyZ2VcclxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzWzBdKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nKSB7XHJcbiAgICAgICAgZGVlcCA9IGFyZ3VtZW50c1swXTtcclxuICAgICAgICBpKys7XHJcbiAgICB9XHJcbiAgICAvLyBNZXJnZSB0aGUgb2JqZWN0IGludG8gdGhlIGV4dGVuZGVkIG9iamVjdFxyXG4gICAgY29uc3QgYXNzaWduRXhpc3RzID0gdHlwZW9mIE9iamVjdC5hc3NpZ24gPT09ICdmdW5jdGlvbic7XHJcbiAgICBsZXQgbWVyZ2UgPSBudWxsO1xyXG4gICAgaWYgKCFhc3NpZ25FeGlzdHMpIHtcclxuICAgICAgICBtZXJnZSA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIG9iaikge1xyXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGVlcCBtZXJnZSBhbmQgcHJvcGVydHkgaXMgYW4gb2JqZWN0LCBtZXJnZSBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZXAgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9ialtwcm9wXSkgPT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVuZGVkW3Byb3BdID0gZXh0ZW5kKHRydWUsIGV4dGVuZGVkW3Byb3BdLCBvYmpbcHJvcF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRbcHJvcF0gPSBvYmpbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIG1lcmdlID0gT2JqZWN0LmFzc2lnbjtcclxuICAgIH1cclxuICAgIC8vIExvb3AgdGhyb3VnaCBlYWNoIG9iamVjdCBhbmQgY29uZHVjdCBhIG1lcmdlXHJcbiAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgIGlmICghYXNzaWduRXhpc3RzKSB7XHJcbiAgICAgICAgICAgIG1lcmdlKG9iaik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBtZXJnZShleHRlbmRlZCwgb2JqKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXh0ZW5kZWQ7XHJcbn1cclxuLyoqXHJcbiAqIEVuY29kZSBhIHN0cmluZyBpbiBiYXNlNjRcclxuICogQGRlcHJlY2F0ZWQgVGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxuZnVuY3Rpb24gYmFzZTY0RW5jb2RlKGlucHV0U3RyKSB7XHJcbiAgICBjb25zdCBiNjQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xyXG4gICAgbGV0IG91dHB1dFN0ciA9ICcnO1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgd2hpbGUgKGkgPCBpbnB1dFN0ci5sZW5ndGgpIHtcclxuICAgICAgICAvL2FsbCB0aHJlZSBcIiYgMHhmZlwiIGFkZGVkIGJlbG93IGFyZSB0aGVyZSB0byBmaXggYSBrbm93biBidWdcclxuICAgICAgICAvL3dpdGggYnl0ZXMgcmV0dXJuZWQgYnkgeGhyLnJlc3BvbnNlVGV4dFxyXG4gICAgICAgIGNvbnN0IGJ5dGUxID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcclxuICAgICAgICBjb25zdCBieXRlMiA9IGlucHV0U3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmY7XHJcbiAgICAgICAgY29uc3QgYnl0ZTMgPSBpbnB1dFN0ci5jaGFyQ29kZUF0KGkrKykgJiAweGZmO1xyXG4gICAgICAgIGNvbnN0IGVuYzEgPSBieXRlMSA+PiAyO1xyXG4gICAgICAgIGNvbnN0IGVuYzIgPSAoKGJ5dGUxICYgMykgPDwgNCkgfCAoYnl0ZTIgPj4gNCk7XHJcbiAgICAgICAgbGV0IGVuYzMsIGVuYzQ7XHJcbiAgICAgICAgaWYgKGlzTmFOKGJ5dGUyKSkge1xyXG4gICAgICAgICAgICBlbmMzID0gZW5jNCA9IDY0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZW5jMyA9ICgoYnl0ZTIgJiAxNSkgPDwgMikgfCAoYnl0ZTMgPj4gNik7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihieXRlMykpIHtcclxuICAgICAgICAgICAgICAgIGVuYzQgPSA2NDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVuYzQgPSBieXRlMyAmIDYzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dHB1dFN0ciArPSBiNjQuY2hhckF0KGVuYzEpICsgYjY0LmNoYXJBdChlbmMyKSArIGI2NC5jaGFyQXQoZW5jMykgKyBiNjQuY2hhckF0KGVuYzQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dFN0cjtcclxufVxyXG4vKipcclxuICogU3VnYXIgdGhhdCB3aWxsIHVzZSBgbnVsbGlzaFZhbGAgaWYgaXQncyBub3QgbnVsbCBvciB1bmRlZmluZWQuIFNpbXVsYXRlcyB0aGUgYD8/YCBvcGVyYXRvclxyXG4gKiBAcGFyYW0gbnVsbGlzaFZhbFxyXG4gKiBAcGFyYW0gZGVmYXVsdFZhbFxyXG4gKi9cclxuZnVuY3Rpb24gbnVsbGlzaChudWxsaXNoVmFsLCBkZWZhdWx0VmFsKSB7XHJcbiAgICByZXR1cm4gbnVsbGlzaFZhbCAhPT0gbnVsbCAmJiBudWxsaXNoVmFsICE9PSB1bmRlZmluZWQgPyBudWxsaXNoVmFsIDogZGVmYXVsdFZhbDtcclxufVxyXG4vKipcclxuICogQ2xhbXBzIGEgdmFsdWUgYmV0d2VlbiBhIG1pbiBhbmQgbWF4IGluY2x1c2l2ZVxyXG4gKi9cclxuZnVuY3Rpb24gY2xhbXAodmFsLCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG1pbiwgdmFsKSwgbWF4KTtcclxufVxyXG4vKipcclxuICogRmluZCBhIHJhbmRvbSBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gcmFuZ2VcclxuICovXHJcbmZ1bmN0aW9uIHJhbmRvbUluUmFuZ2UobWluLCBtYXgsIHJhbmRvbSA9IG5ldyBSYW5kb20oKSkge1xyXG4gICAgcmV0dXJuIHJhbmRvbSA/IHJhbmRvbS5mbG9hdGluZyhtaW4sIG1heCkgOiBtaW4gKyBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbik7XHJcbn1cclxuLyoqXHJcbiAqIEZpbmQgYSByYW5kb20gaW50ZWdlciBpbiBhIHJhbmdlXHJcbiAqL1xyXG5mdW5jdGlvbiByYW5kb21JbnRJblJhbmdlKG1pbiwgbWF4LCByYW5kb20gPSBuZXcgUmFuZG9tKCkpIHtcclxuICAgIHJldHVybiByYW5kb20gPyByYW5kb20uaW50ZWdlcihtaW4sIG1heCkgOiBNYXRoLnJvdW5kKHJhbmRvbUluUmFuZ2UobWluLCBtYXgpKTtcclxufVxyXG4vKipcclxuICogQ29udmVydCBhbiBhbmdsZSB0byBiZSB0aGUgZXF1aXZhbGVudCBpbiB0aGUgcmFuZ2UgWzAsIDJQSV1cclxuICovXHJcbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZUFuZ2xlKGFuZ2xlKSB7XHJcbiAgICBsZXQgdG1wQW5nbGUgPSBhbmdsZTtcclxuICAgIGlmIChhbmdsZSA+IFR3b1BJKSB7XHJcbiAgICAgICAgd2hpbGUgKHRtcEFuZ2xlID4gVHdvUEkpIHtcclxuICAgICAgICAgICAgdG1wQW5nbGUgLT0gVHdvUEk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGFuZ2xlIDwgMCkge1xyXG4gICAgICAgIHdoaWxlICh0bXBBbmdsZSA8IDApIHtcclxuICAgICAgICAgICAgdG1wQW5nbGUgKz0gVHdvUEk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRtcEFuZ2xlO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IHJhZGlhbnMgdG8gZGVncmVlc1xyXG4gKi9cclxuZnVuY3Rpb24gdG9EZWdyZWVzKHJhZGlhbnMpIHtcclxuICAgIHJldHVybiAoMTgwIC8gTWF0aC5QSSkgKiByYWRpYW5zO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IGRlZ3JlZXMgdG8gcmFkaWFuc1xyXG4gKi9cclxuZnVuY3Rpb24gdG9SYWRpYW5zKGRlZ3JlZXMpIHtcclxuICAgIHJldHVybiAoZGVncmVlcyAvIDE4MCkgKiBNYXRoLlBJO1xyXG59XHJcbi8qKlxyXG4gKiBGaW5kIHRoZSBzY3JlZW4gcG9zaXRpb24gb2YgYW4gSFRNTCBlbGVtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQb3NpdGlvbihlbCkge1xyXG4gICAgbGV0IG9MZWZ0ID0gMCwgb1RvcCA9IDA7XHJcbiAgICBjb25zdCBjYWxjT2Zmc2V0TGVmdCA9IChwYXJlbnQpID0+IHtcclxuICAgICAgICBvTGVmdCArPSBwYXJlbnQub2Zmc2V0TGVmdDtcclxuICAgICAgICBpZiAocGFyZW50Lm9mZnNldFBhcmVudCkge1xyXG4gICAgICAgICAgICBjYWxjT2Zmc2V0TGVmdChwYXJlbnQub2Zmc2V0UGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgY2FsY09mZnNldFRvcCA9IChwYXJlbnQpID0+IHtcclxuICAgICAgICBvVG9wICs9IHBhcmVudC5vZmZzZXRUb3A7XHJcbiAgICAgICAgaWYgKHBhcmVudC5vZmZzZXRQYXJlbnQpIHtcclxuICAgICAgICAgICAgY2FsY09mZnNldFRvcChwYXJlbnQub2Zmc2V0UGFyZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY2FsY09mZnNldExlZnQoZWwpO1xyXG4gICAgY2FsY09mZnNldFRvcChlbCk7XHJcbiAgICByZXR1cm4gbmV3IFZlY3RvcihvTGVmdCwgb1RvcCk7XHJcbn1cclxuLyoqXHJcbiAqIEFkZCBhbiBpdGVtIHRvIGFuIGFycmF5IGxpc3QgaWYgaXQgZG9lc24ndCBhbHJlYWR5IGV4aXN0LiBSZXR1cm5zIHRydWUgaWYgYWRkZWQsIGZhbHNlIGlmIG5vdCBhbmQgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGFycmF5LlxyXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxuZnVuY3Rpb24gYWRkSXRlbVRvQXJyYXkoaXRlbSwgYXJyYXkpIHtcclxuICAgIGlmIChhcnJheS5pbmRleE9mKGl0ZW0pID09PSAtMSkge1xyXG4gICAgICAgIGFycmF5LnB1c2goaXRlbSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZSBhbiBpdGVtIGZyb20gYW4gbGlzdFxyXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlSXRlbUZyb21BcnJheShpdGVtLCBhcnJheSkge1xyXG4gICAgbGV0IGluZGV4ID0gLTE7XHJcbiAgICBpZiAoKGluZGV4ID0gYXJyYXkuaW5kZXhPZihpdGVtKSkgPiAtMSkge1xyXG4gICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIFNlZSBpZiBhbiBhcnJheSBjb250YWlucyBzb21ldGhpbmdcclxuICovXHJcbmZ1bmN0aW9uIGNvbnRhaW5zKGFycmF5LCBvYmopIHtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoYXJyYXlbaV0gPT09IG9iaikge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmFsc2U7XHJcbn1cclxuLyoqXHJcbiAqIEdldCB0aGUgb3Bwb3NpdCBzaWRlXHJcbiAqIFRPRE86IE1vdmUgdG8gU2lkZSB0eXBlXHJcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVNpZGUoc2lkZSkge1xyXG4gICAgaWYgKHNpZGUgPT09IFNpZGUuVG9wKSB7XHJcbiAgICAgICAgcmV0dXJuIFNpZGUuQm90dG9tO1xyXG4gICAgfVxyXG4gICAgaWYgKHNpZGUgPT09IFNpZGUuQm90dG9tKSB7XHJcbiAgICAgICAgcmV0dXJuIFNpZGUuVG9wO1xyXG4gICAgfVxyXG4gICAgaWYgKHNpZGUgPT09IFNpZGUuTGVmdCkge1xyXG4gICAgICAgIHJldHVybiBTaWRlLlJpZ2h0O1xyXG4gICAgfVxyXG4gICAgaWYgKHNpZGUgPT09IFNpZGUuUmlnaHQpIHtcclxuICAgICAgICByZXR1cm4gU2lkZS5MZWZ0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFNpZGUuTm9uZTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgc2lkZSBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSB2ZWN0b3Igc3VwcGxpZWRcclxuICogQHBhcmFtIGRpcmVjdGlvbiBWZWN0b3IgdG8gY2hlY2tcclxuICogQGRlcHJlY2F0ZWRcclxuICogVE9ETzogTW92ZSB0byBTaWRlIHR5cGVcclxuICovXHJcbmZ1bmN0aW9uIGdldFNpZGVGcm9tRGlyZWN0aW9uKGRpcmVjdGlvbikge1xyXG4gICAgY29uc3QgZGlyZWN0aW9ucyA9IFtWZWN0b3IuTGVmdCwgVmVjdG9yLlJpZ2h0LCBWZWN0b3IuVXAsIFZlY3Rvci5Eb3duXTtcclxuICAgIGNvbnN0IGRpcmVjdGlvbkVudW0gPSBbU2lkZS5MZWZ0LCBTaWRlLlJpZ2h0LCBTaWRlLlRvcCwgU2lkZS5Cb3R0b21dO1xyXG4gICAgbGV0IG1heCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgbGV0IG1heEluZGV4ID0gLTE7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpcmVjdGlvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uc1tpXS5kb3QoZGlyZWN0aW9uKSA+IG1heCkge1xyXG4gICAgICAgICAgICBtYXggPSBkaXJlY3Rpb25zW2ldLmRvdChkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBtYXhJbmRleCA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRpcmVjdGlvbkVudW1bbWF4SW5kZXhdO1xyXG59XHJcbi8qKlxyXG4gKiBFeGNhbGlidXIncyBkeW5hbWljYWxseSByZXNpemluZyBjb2xsZWN0aW9uXHJcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCB2MC4yNi4wXHJcbiAqL1xyXG5jbGFzcyBDb2xsZWN0aW9uIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGluaXRpYWxTaXplICBJbml0aWFsIHNpemUgb2YgdGhlIGludGVybmFsIGJhY2tpbmcgYXJyYXlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaW5pdGlhbFNpemUgPSBDb2xsZWN0aW9uLkRlZmF1bHRTaXplKSB7XHJcbiAgICAgICAgdGhpcy5faW50ZXJuYWxBcnJheSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZW5kUG9pbnRlciA9IDA7XHJcbiAgICAgICAgdGhpcy5faW50ZXJuYWxBcnJheSA9IG5ldyBBcnJheShpbml0aWFsU2l6ZSk7XHJcbiAgICB9XHJcbiAgICBfcmVzaXplKCkge1xyXG4gICAgICAgIGNvbnN0IG5ld1NpemUgPSB0aGlzLl9pbnRlcm5hbEFycmF5Lmxlbmd0aCAqIDI7XHJcbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBuZXcgQXJyYXkobmV3U2l6ZSk7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmNvdW50KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIG5ld0FycmF5W2ldID0gdGhpcy5faW50ZXJuYWxBcnJheVtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2ludGVybmFsQXJyYXk7XHJcbiAgICAgICAgdGhpcy5faW50ZXJuYWxBcnJheSA9IG5ld0FycmF5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQdXNoIGVsZW1lbnRzIHRvIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb25cclxuICAgICAqL1xyXG4gICAgcHVzaChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2VuZFBvaW50ZXIgPT09IHRoaXMuX2ludGVybmFsQXJyYXkubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRoaXMuX2ludGVybmFsQXJyYXlbdGhpcy5fZW5kUG9pbnRlcisrXSA9IGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGVsZW1lbnRzIGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvblxyXG4gICAgICovXHJcbiAgICBwb3AoKSB7XHJcbiAgICAgICAgdGhpcy5fZW5kUG9pbnRlciA9IHRoaXMuX2VuZFBvaW50ZXIgLSAxIDwgMCA/IDAgOiB0aGlzLl9lbmRQb2ludGVyIC0gMTtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxBcnJheVt0aGlzLl9lbmRQb2ludGVyXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY291bnQgb2YgdGhlIGNvbGxlY3Rpb25cclxuICAgICAqL1xyXG4gICAgY291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuZFBvaW50ZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVtcHRpZXMgdGhlIGNvbGxlY3Rpb25cclxuICAgICAqL1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5fZW5kUG9pbnRlciA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNpemUgb2YgdGhlIGludGVybmFsIGJhY2tpbmcgYXJyYXlcclxuICAgICAqL1xyXG4gICAgaW50ZXJuYWxTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEFycmF5Lmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbiBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcclxuICAgICAqIEBwYXJhbSBpbmRleCAgSW5kZXggb2YgZWxlbWVudCB0byByZXRyaWV2ZVxyXG4gICAgICovXHJcbiAgICBlbGVtZW50QXQoaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggPj0gdGhpcy5jb3VudCgpKSB7XHJcbiAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyOiAnICsgaW5kZXgpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5kZXggJyArIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXlbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIGFuIGVsZW1lbnQgYXQgYSBzcGVjaWZpYyBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4ICBJbmRleCB0byBpbnNlcnQgdGhlIGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgRWxlbWVudCB0byBpbnNlcnRcclxuICAgICAqL1xyXG4gICAgaW5zZXJ0KGluZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmNvdW50KCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5faW50ZXJuYWxBcnJheVtpbmRleF0gPSB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gZWxlbWVudCBhdCBhIHNwZWNpZmljIGluZGV4XHJcbiAgICAgKiBAcGFyYW0gaW5kZXggIEluZGV4IG9mIGVsZW1lbnQgdG8gcmVtb3ZlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShpbmRleCkge1xyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5jb3VudCgpO1xyXG4gICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAvL0xvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdJbnZhbGlkIHBhcmFtZXRlcjogJyArIGluZGV4KTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBhcmFtZXRlciAnICsgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBPKG4pIFNoaWZ0XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IHRoaXMuX2ludGVybmFsQXJyYXlbaW5kZXhdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSBpbmRleDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5faW50ZXJuYWxBcnJheVtpXSA9IHRoaXMuX2ludGVybmFsQXJyYXlbaSArIDFdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9lbmRQb2ludGVyLS07XHJcbiAgICAgICAgcmV0dXJuIHJlbW92ZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gZWxlbWVudCBieSByZWZlcmVuY2VcclxuICAgICAqIEBwYXJhbSBlbGVtZW50ICBFbGVtZW50IHRvIHJldHJpZXZlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUVsZW1lbnQoZWxlbWVudCkge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5faW50ZXJuYWxBcnJheS5pbmRleE9mKGVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMucmVtb3ZlKGluZGV4KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGFycmF5IHJlcHJlc2VudGluZyB0aGUgY29sbGVjdGlvblxyXG4gICAgICovXHJcbiAgICB0b0FycmF5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEFycmF5LnNsaWNlKDAsIHRoaXMuX2VuZFBvaW50ZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRlIG92ZXIgZXZlcnkgZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIGZ1bmMgIENhbGxiYWNrIHRvIGNhbGwgZm9yIGVhY2ggZWxlbWVudCBwYXNzaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IGFuZCBpdHMgaW5kZXgsIHJldHVybmVkIHZhbHVlcyBhcmUgaWdub3JlZFxyXG4gICAgICovXHJcbiAgICBmb3JFYWNoKGZ1bmMpIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmNvdW50KCk7XHJcbiAgICAgICAgZm9yIChpOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBmdW5jLmNhbGwodGhpcywgdGhpcy5faW50ZXJuYWxBcnJheVtpXSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNdXRhdGUgZXZlcnkgZWxlbWVudCBpbiB0aGUgY29sbGVjdGlvblxyXG4gICAgICogQHBhcmFtIGZ1bmMgIENhbGxiYWNrIHRvIGNhbGwgZm9yIGVhY2ggZWxlbWVudCBwYXNzaW5nIGEgcmVmZXJlbmNlIHRvIHRoZSBlbGVtZW50IGFuZCBpdHMgaW5kZXgsIGFueSB2YWx1ZXMgcmV0dXJuZWQgbXV0YXRlXHJcbiAgICAgKiB0aGUgY29sbGVjdGlvblxyXG4gICAgICovXHJcbiAgICBtYXAoZnVuYykge1xyXG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5jb3VudCgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEFycmF5W2ldID0gZnVuYy5jYWxsKHRoaXMsIHRoaXMuX2ludGVybmFsQXJyYXlbaV0sIGkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogRGVmYXVsdCBjb2xsZWN0aW9uIHNpemVcclxuICovXHJcbkNvbGxlY3Rpb24uRGVmYXVsdFNpemUgPSAyMDA7XHJcbi8qKlxyXG4gKiBVc2VkIGZvciBleGhhdXN0aXZlIGNoZWNrcyBhdCBjb21waWxlIHRpbWVcclxuICovXHJcbmZ1bmN0aW9uIGZhaWwobWVzc2FnZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIHJhbmdlIG9mIG51bWJlcnNcclxuICogRm9yIGV4YW1wbGU6IHJhbmdlKDAsIDUpIC0+IFswLCAxLCAyLCAzLCA0LCA1XVxyXG4gKiBAcGFyYW0gZnJvbSBpbmNsdXNpdmVcclxuICogQHBhcmFtIHRvIGluY2x1c2l2ZVxyXG4gKi9cclxuY29uc3QgcmFuZ2UgPSAoZnJvbSwgdG8pID0+IEFycmF5LmZyb20obmV3IEFycmF5KHRvIC0gZnJvbSArIDEpLCAoX3gsIGkpID0+IGkgKyBmcm9tKTtcclxuLyoqXHJcbiAqIENyZWF0ZSBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBhIGNlcnRhaW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kc1xyXG4gKiBAcGFyYW0gbWlsbGlzZWNvbmRzXHJcbiAqL1xyXG5mdW5jdGlvbiBkZWxheShtaWxsaXNlY29uZHMpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgfSwgbWlsbGlzZWNvbmRzKTtcclxuICAgIH0pO1xyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9EZWNvcmF0b3JzLnRzXG5cclxuXHJcblxyXG5jb25zdCBtYXhNZXNzYWdlcyA9IDU7XHJcbmNvbnN0IG9ic29sZXRlTWVzc2FnZSA9IHt9O1xyXG5jb25zdCByZXNldE9ic29sZXRlQ291bnRlciA9ICgpID0+IHtcclxuICAgIGZvciAoY29uc3QgbWVzc2FnZSBpbiBvYnNvbGV0ZU1lc3NhZ2UpIHtcclxuICAgICAgICBvYnNvbGV0ZU1lc3NhZ2VbbWVzc2FnZV0gPSAwO1xyXG4gICAgfVxyXG59O1xyXG5jb25zdCBsb2dNZXNzYWdlID0gKG1lc3NhZ2UsIG9wdGlvbnMpID0+IHtcclxuICAgIGNvbnN0IHN1cHByZXNzT2Jzb2xldGVNZXNzYWdlcyA9IEZsYWdzLmlzRW5hYmxlZCgnc3VwcHJlc3Mtb2Jzb2xldGUtbWVzc2FnZScpO1xyXG4gICAgaWYgKG9ic29sZXRlTWVzc2FnZVttZXNzYWdlXSA8IG1heE1lc3NhZ2VzICYmICFzdXBwcmVzc09ic29sZXRlTWVzc2FnZXMpIHtcclxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tY29uc29sZVxyXG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlICYmIG9wdGlvbnMuc2hvd1N0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1jb25zb2xlXHJcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvYnNvbGV0ZU1lc3NhZ2VbbWVzc2FnZV0rKztcclxufTtcclxuLyoqXHJcbiAqIE9ic29sZXRlIGRlY29yYXRvciBmb3IgbWFya2luZyBFeGNhbGlidXIgbWV0aG9kcyBvYnNvbGV0ZSwgeW91IGNhbiBvcHRpb25hbGx5IHNwZWNpZnkgYSBjdXN0b20gbWVzc2FnZSBhbmQvb3IgYWx0ZXJuYXRlIHJlcGxhY2VtZW50XHJcbiAqIG1ldGhvZCBkbyB0aGUgZGVwcmVjYXRlZCBvbmUuIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9qYXlwaGVscHMvY29yZS1kZWNvcmF0b3JzLmpzXHJcbiAqL1xyXG5mdW5jdGlvbiBvYnNvbGV0ZShvcHRpb25zKSB7XHJcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCB7XHJcbiAgICAgICAgbWVzc2FnZTogJ1RoaXMgZmVhdHVyZSB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIHZlcnNpb25zIG9mIEV4Y2FsaWJ1ci4nLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogbnVsbCxcclxuICAgICAgICBzaG93U3RhY2tUcmFjazogZmFsc2VcclxuICAgIH0sIG9wdGlvbnMpO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIHByb3BlcnR5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiZcclxuICAgICAgICAgICAgISh0eXBlb2YgZGVzY3JpcHRvci52YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ID09PSAnZnVuY3Rpb24nKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ09ubHkgY2xhc3Nlcy9mdW5jdGlvbnMvZ2V0dGVycy9zZXR0ZXJzIGNhbiBiZSBtYXJrZWQgYXMgb2Jzb2xldGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbWV0aG9kU2lnbmF0dXJlID0gYCR7dGFyZ2V0Lm5hbWUgfHwgJyd9JHt0YXJnZXQubmFtZSAmJiBwcm9wZXJ0eSA/ICcuJyA6ICcnfSR7cHJvcGVydHkgPyBwcm9wZXJ0eSA6ICcnfWA7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGAke21ldGhvZFNpZ25hdHVyZX0gaXMgbWFya2VkIG9ic29sZXRlOiAke29wdGlvbnMubWVzc2FnZX1gICtcclxuICAgICAgICAgICAgKG9wdGlvbnMuYWx0ZXJuYXRlTWV0aG9kID8gYCBVc2UgJHtvcHRpb25zLmFsdGVybmF0ZU1ldGhvZH0gaW5zdGVhZGAgOiAnJyk7XHJcbiAgICAgICAgaWYgKCFvYnNvbGV0ZU1lc3NhZ2VbbWVzc2FnZV0pIHtcclxuICAgICAgICAgICAgb2Jzb2xldGVNZXNzYWdlW21lc3NhZ2VdID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgZGVzY3JpcHRvciBpcyBudWxsIGl0IGlzIGEgY2xhc3NcclxuICAgICAgICBjb25zdCBtZXRob2QgPSBkZXNjcmlwdG9yID8gT2JqZWN0LmFzc2lnbih7fSwgZGVzY3JpcHRvcikgOiB0YXJnZXQ7XHJcbiAgICAgICAgaWYgKCFkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgICAgIC8vIHdpdGggZXMyMDE1IGNsYXNzZXMgd2UgbmVlZCB0byBjaGFuZ2Ugb3VyIGRlY29yYXRpb24gdGFjdGljXHJcbiAgICAgICAgICAgIGNsYXNzIERlY29yYXRlZENsYXNzIGV4dGVuZHMgbWV0aG9kIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBsb2dNZXNzYWdlKG1lc3NhZ2UsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0ZWRDbGFzcztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci52YWx1ZSkge1xyXG4gICAgICAgICAgICBtZXRob2QudmFsdWUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBsb2dNZXNzYWdlKG1lc3NhZ2UsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3IudmFsdWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5nZXQpIHtcclxuICAgICAgICAgICAgbWV0aG9kLmdldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGxvZ01lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5zZXQpIHtcclxuICAgICAgICAgICAgbWV0aG9kLnNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGxvZ01lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci5zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG1ldGhvZDtcclxuICAgIH07XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL3ZlY3Rvci50c1xudmFyIF9fZGVjb3JhdGUgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcblxyXG4vKipcclxuICogQSAyRCB2ZWN0b3Igb24gYSBwbGFuZS5cclxuICovXHJcbmNsYXNzIFZlY3RvciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB4ICBYIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXHJcbiAgICAgKiBAcGFyYW0geSAgWSBjb21wb25lbnQgb2YgdGhlIFZlY3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5feCA9IDA7XHJcbiAgICAgICAgdGhpcy5feSA9IDA7XHJcbiAgICAgICAgdGhpcy5feCA9IHg7XHJcbiAgICAgICAgdGhpcy5feSA9IHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgKDAsIDApIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IFplcm8oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgKDEsIDEpIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IE9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigxLCAxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSAoMC41LCAwLjUpIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IEhhbGYoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMC41LCAwLjUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHVuaXQgdmVjdG9yIHBvaW50aW5nIHVwICgwLCAtMSlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBVcCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAtMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgZG93biAoMCwgMSlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBEb3duKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIDEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHVuaXQgdmVjdG9yIHBvaW50aW5nIGxlZnQgKC0xLCAwKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IExlZnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoLTEsIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBIHVuaXQgdmVjdG9yIHBvaW50aW5nIHJpZ2h0ICgxLCAwKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IFJpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDEsIDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgdmVjdG9yIG9mIHVuaXQgbGVuZ3RoIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHNwZWNpZmllZCBhbmdsZSBpbiBSYWRpYW5zLlxyXG4gICAgICogQHBhcmFtIGFuZ2xlIFRoZSBhbmdsZSB0byBnZW5lcmF0ZSB0aGUgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tQW5nbGUoYW5nbGUpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihNYXRoLmNvcyhhbmdsZSksIE1hdGguc2luKGFuZ2xlKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB2ZWN0b3IgaXMgbm90IG51bGwsIHVuZGVmaW5lZCwgb3IgaWYgYW55IG9mIGl0cyBjb21wb25lbnRzIGFyZSBOYU4gb3IgSW5maW5pdHkuXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpc1ZhbGlkKHZlYykge1xyXG4gICAgICAgIGlmICh2ZWMgPT09IG51bGwgfHwgdmVjID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNOYU4odmVjLngpIHx8IGlzTmFOKHZlYy55KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh2ZWMueCA9PT0gSW5maW5pdHkgfHwgdmVjLnkgPT09IEluZmluaXR5IHx8IHZlYy54ID09PSAtSW5maW5pdHkgfHwgdmVjLnkgPT09IC1JbmZpbml0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIGRpc3RhbmNlIGJldHdlZW4gdHdvIFZlY3RvcnNcclxuICAgICAqIEBwYXJhbSB2ZWMxXHJcbiAgICAgKiBAcGFyYW0gdmVjMlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZGlzdGFuY2UodmVjMSwgdmVjMikge1xyXG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codmVjMS54IC0gdmVjMi54LCAyKSArIE1hdGgucG93KHZlYzEueSAtIHZlYzIueSwgMikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHggY29tcG9uZW50IG9mIHRoZSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgZ2V0IHgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3g7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgeCBjb21wb25lbnQsIFRISVMgTVVUQVRFUyB0aGUgY3VycmVudCB2ZWN0b3IuIEl0IGlzIHVzdWFsbHkgYmV0dGVyIHRvIGNyZWF0ZSBhIG5ldyB2ZWN0b3IuXHJcbiAgICAgKiBAd2FybmluZyAqKkJlIHZlcnkgY2FyZWZ1bCBzZXR0aW5nIGNvbXBvbmVudHMgb24gc2hhcmVkIHZlY3RvcnMsIG11dGF0aW5nIHNoYXJlZCB2ZWN0b3JzIGNhbiBjYXVzZSBoYXJkIHRvIGZpbmQgYnVncyoqXHJcbiAgICAgKi9cclxuICAgIHNldCB4KHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3ggPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgeSBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBnZXQgeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5feTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB5IGNvbXBvbmVudCwgVEhJUyBNVVRBVEVTIHRoZSBjdXJyZW50IHZlY3Rvci4gSXQgaXMgdXN1YWxseSBiZXR0ZXIgdG8gY3JlYXRlIGEgbmV3IHZlY3Rvci5cclxuICAgICAqIEB3YXJuaW5nICoqQmUgdmVyeSBjYXJlZnVsIHNldHRpbmcgY29tcG9uZW50cyBvbiBzaGFyZWQgdmVjdG9ycywgbXV0YXRpbmcgc2hhcmVkIHZlY3RvcnMgY2FuIGNhdXNlIGhhcmQgdG8gZmluZCBidWdzKipcclxuICAgICAqL1xyXG4gICAgc2V0IHkodmFsKSB7XHJcbiAgICAgICAgdGhpcy5feSA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgeCBhbmQgeSBjb21wb25lbnRzIGF0IG9uY2UsIFRISVMgTVVUQVRFUyB0aGUgY3VycmVudCB2ZWN0b3IuIEl0IGlzIHVzdWFsbHkgYmV0dGVyIHRvIGNyZWF0ZSBhIG5ldyB2ZWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHdhcm5pbmcgKipCZSB2ZXJ5IGNhcmVmdWwgdXNpbmcgdGhpcywgbXV0YXRpbmcgdmVjdG9ycyBjYW4gY2F1c2UgaGFyZCB0byBmaW5kIGJ1Z3MqKlxyXG4gICAgICovXHJcbiAgICBzZXRUbyh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21wYXJlcyB0aGlzIHBvaW50IGFnYWluc3QgYW5vdGhlciBhbmQgdGVzdHMgZm9yIGVxdWFsaXR5XHJcbiAgICAgKiBAcGFyYW0gdmVjdG9yIFRoZSBvdGhlciBwb2ludCB0byBjb21wYXJlIHRvXHJcbiAgICAgKiBAcGFyYW0gdG9sZXJhbmNlIEFtb3VudCBvZiBldWNsaWRlYW4gZGlzdGFuY2Ugb2ZmIHdlIGFyZSB3aWxsaW5nIHRvIHRvbGVyYXRlXHJcbiAgICAgKi9cclxuICAgIGVxdWFscyh2ZWN0b3IsIHRvbGVyYW5jZSA9IDAuMDAxKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMueCAtIHZlY3Rvci54KSA8PSB0b2xlcmFuY2UgJiYgTWF0aC5hYnModGhpcy55IC0gdmVjdG9yLnkpIDw9IHRvbGVyYW5jZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGRpc3RhbmNlIHRvIGFub3RoZXIgdmVjdG9yLiBJZiBubyBvdGhlciBWZWN0b3IgaXMgc3BlY2lmaWVkLCB0aGlzIHdpbGwgcmV0dXJuIHRoZSBbW21hZ25pdHVkZV1dLlxyXG4gICAgICogQHBhcmFtIHYgIFRoZSBvdGhlciB2ZWN0b3IuIExlYXZlIGJsYW5rIHRvIHVzZSBvcmlnaW4gdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICBkaXN0YW5jZSh2KSB7XHJcbiAgICAgICAgaWYgKCF2KSB7XHJcbiAgICAgICAgICAgIHYgPSBWZWN0b3IuWmVybztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh0aGlzLnggLSB2LngsIDIpICsgTWF0aC5wb3codGhpcy55IC0gdi55LCAyKSk7XHJcbiAgICB9XHJcbiAgICBzcXVhcmVEaXN0YW5jZSh2KSB7XHJcbiAgICAgICAgaWYgKCF2KSB7XHJcbiAgICAgICAgICAgIHYgPSBWZWN0b3IuWmVybztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIE1hdGgucG93KHRoaXMueCAtIHYueCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSB2LnksIDIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbWFnbml0dWRlIChzaXplKSBvZiB0aGUgVmVjdG9yXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBtYWduaXR1ZGUgd2lsbCBiZSByZW1vdmVkIGluIGZhdm91ciBvZiAnLnNpemUnIGluIHZlcnNpb24gMC4yNS4wXHJcbiAgICAgKi9cclxuICAgIG1hZ25pdHVkZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kaXN0YW5jZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2l6ZSAobWFnbml0dWRlKSBvZiB0aGUgVmVjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldCBzaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHRpbmcgdGhlIHNpemUgbXV0YXRlcyB0aGUgY3VycmVudCB2ZWN0b3JcclxuICAgICAqXHJcbiAgICAgKiBAd2FybmluZyBDYW4gYmUgdXNlZCB0byBzZXQgdGhlIHNpemUgb2YgdGhlIHZlY3RvciwgKipiZSB2ZXJ5IGNhcmVmdWwgdXNpbmcgdGhpcywgbXV0YXRpbmcgdmVjdG9ycyBjYW4gY2F1c2UgaGFyZCB0byBmaW5kIGJ1Z3MqKlxyXG4gICAgICovXHJcbiAgICBzZXQgc2l6ZShuZXdMZW5ndGgpIHtcclxuICAgICAgICBjb25zdCB2ID0gdGhpcy5ub3JtYWxpemUoKS5zY2FsZShuZXdMZW5ndGgpO1xyXG4gICAgICAgIHRoaXMuc2V0VG8odi54LCB2LnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3JtYWxpemVzIGEgdmVjdG9yIHRvIGhhdmUgYSBtYWduaXR1ZGUgb2YgMS5cclxuICAgICAqL1xyXG4gICAgbm9ybWFsaXplKCkge1xyXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmRpc3RhbmNlKCk7XHJcbiAgICAgICAgaWYgKGQgPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAvIGQsIHRoaXMueSAvIGQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhdmVyYWdlIChtaWRwb2ludCkgYmV0d2VlbiB0aGUgY3VycmVudCBwb2ludCBhbmQgdGhlIHNwZWNpZmllZFxyXG4gICAgICovXHJcbiAgICBhdmVyYWdlKHZlYykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZCh2ZWMpLnNjYWxlKDAuNSk7XHJcbiAgICB9XHJcbiAgICBzY2FsZShzaXplT3JTY2FsZSkge1xyXG4gICAgICAgIGlmIChzaXplT3JTY2FsZSBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggKiBzaXplT3JTY2FsZS54LCB0aGlzLnkgKiBzaXplT3JTY2FsZS55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAqIHNpemVPclNjYWxlLCB0aGlzLnkgKiBzaXplT3JTY2FsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9uZSB2ZWN0b3IgdG8gYW5vdGhlclxyXG4gICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBhZGRcclxuICAgICAqL1xyXG4gICAgYWRkKHYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggKyB2LngsIHRoaXMueSArIHYueSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN1YnRyYWN0cyBhIHZlY3RvciBmcm9tIGFub3RoZXIsIGlmIHlvdSBzdWJ0cmFjdCB2ZWN0b3IgYEIuc3ViKEEpYCB0aGUgcmVzdWx0aW5nIHZlY3RvciBwb2ludHMgZnJvbSBBIC0+IEJcclxuICAgICAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gc3VidHJhY3RcclxuICAgICAqL1xyXG4gICAgc3ViKHYpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnggLSB2LngsIHRoaXMueSAtIHYueSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb25lIHZlY3RvciB0byB0aGlzIG9uZSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGFkZFxyXG4gICAgICogQHdhcm5pbmcgQmUgdmVyeSBjYXJlZnVsIHVzaW5nIHRoaXMsIG11dGF0aW5nIHZlY3RvcnMgY2FuIGNhdXNlIGhhcmQgdG8gZmluZCBidWdzXHJcbiAgICAgKi9cclxuICAgIGFkZEVxdWFsKHYpIHtcclxuICAgICAgICB0aGlzLnNldFRvKHRoaXMueCArIHYueCwgdGhpcy55ICsgdi55KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gdGhpcyBvbmUgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbFxyXG4gICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBzdWJ0cmFjdFxyXG4gICAgICogQHdhcm5pbmcgQmUgdmVyeSBjYXJlZnVsIHVzaW5nIHRoaXMsIG11dGF0aW5nIHZlY3RvcnMgY2FuIGNhdXNlIGhhcmQgdG8gZmluZCBidWdzXHJcbiAgICAgKi9cclxuICAgIHN1YkVxdWFsKHYpIHtcclxuICAgICAgICB0aGlzLnNldFRvKHRoaXMueCAtIHYueCwgdGhpcy55IC0gdi55KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGVzIHRoaXMgdmVjdG9yIGJ5IGEgZmFjdG9yIG9mIHNpemUgYW5kIG1vZGlmaWVzIHRoZSBvcmlnaW5hbFxyXG4gICAgICogQHdhcm5pbmcgQmUgdmVyeSBjYXJlZnVsIHVzaW5nIHRoaXMsIG11dGF0aW5nIHZlY3RvcnMgY2FuIGNhdXNlIGhhcmQgdG8gZmluZCBidWdzXHJcbiAgICAgKi9cclxuICAgIHNjYWxlRXF1YWwoc2l6ZSkge1xyXG4gICAgICAgIHRoaXMuc2V0VG8odGhpcy54ICogc2l6ZSwgdGhpcy55ICogc2l6ZSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBlcmZvcm1zIGEgZG90IHByb2R1Y3Qgd2l0aCBhbm90aGVyIHZlY3RvclxyXG4gICAgICogQHBhcmFtIHYgIFRoZSB2ZWN0b3IgdG8gZG90XHJcbiAgICAgKi9cclxuICAgIGRvdCh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcclxuICAgIH1cclxuICAgIGNyb3NzKHYpIHtcclxuICAgICAgICBpZiAodiBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy54ICogdi55IC0gdGhpcy55ICogdi54O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodiAqIHRoaXMueSwgLXYgKiB0aGlzLngpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0YXRpYyBjcm9zcyhudW0sIHZlYykge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKC1udW0gKiB2ZWMueSwgbnVtICogdmVjLngpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwZXJwZW5kaWN1bGFyIHZlY3RvciB0byB0aGlzIG9uZVxyXG4gICAgICovXHJcbiAgICBwZXJwZW5kaWN1bGFyKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueSwgLXRoaXMueCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5vcm1hbCB2ZWN0b3IgdG8gdGhpcyBvbmUsIHNhbWUgYXMgdGhlIHBlcnBlbmRpY3VsYXIgb2YgbGVuZ3RoIDFcclxuICAgICAqL1xyXG4gICAgbm9ybWFsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBlcnBlbmRpY3VsYXIoKS5ub3JtYWxpemUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTmVnYXRlIHRoZSBjdXJyZW50IHZlY3RvclxyXG4gICAgICovXHJcbiAgICBuZWdhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGUoLTEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBhbmdsZSBvZiB0aGlzIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgdG9BbmdsZSgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hdGFuMih0aGlzLnksIHRoaXMueCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0ZXMgdGhlIGN1cnJlbnQgdmVjdG9yIGFyb3VuZCBhIHBvaW50IGJ5IGEgY2VydGFpbiBudW1iZXIgb2ZcclxuICAgICAqIGRlZ3JlZXMgaW4gcmFkaWFuc1xyXG4gICAgICovXHJcbiAgICByb3RhdGUoYW5nbGUsIGFuY2hvcikge1xyXG4gICAgICAgIGlmICghYW5jaG9yKSB7XHJcbiAgICAgICAgICAgIGFuY2hvciA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNpbkFuZ2xlID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIGNvbnN0IGNvc0FuZ2xlID0gTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIGNvbnN0IHggPSBjb3NBbmdsZSAqICh0aGlzLnggLSBhbmNob3IueCkgLSBzaW5BbmdsZSAqICh0aGlzLnkgLSBhbmNob3IueSkgKyBhbmNob3IueDtcclxuICAgICAgICBjb25zdCB5ID0gc2luQW5nbGUgKiAodGhpcy54IC0gYW5jaG9yLngpICsgY29zQW5nbGUgKiAodGhpcy55IC0gYW5jaG9yLnkpICsgYW5jaG9yLnk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoeCwgeSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgbmV3IHZlY3RvciB0aGF0IGhhcyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlIHByZXZpb3VzLlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLngsIHRoaXMueSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZlY3Rvci5cclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoZml4ZWQpIHtcclxuICAgICAgICBpZiAoZml4ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAoJHt0aGlzLngudG9GaXhlZChmaXhlZCl9LCAke3RoaXMueS50b0ZpeGVkKGZpeGVkKX0pYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGAoJHt0aGlzLnh9LCAke3RoaXMueX0pYDtcclxuICAgIH1cclxufVxyXG5fX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHsgbWVzc2FnZTogJ3dpbGwgYmUgcmVtb3ZlZCBpbiBmYXZvdXIgb2YgYC5zaXplYCBpbiB2ZXJzaW9uIDAuMjUuMCcgfSlcclxuXSwgVmVjdG9yLnByb3RvdHlwZSwgXCJtYWduaXR1ZGVcIiwgbnVsbCk7XHJcbi8qKlxyXG4gKiBTaG9ydGhhbmQgZm9yIGNyZWF0aW5nIG5ldyBWZWN0b3JzIC0gcmV0dXJucyBhIG5ldyBWZWN0b3IgaW5zdGFuY2Ugd2l0aCB0aGVcclxuICogcHJvdmlkZWQgWCBhbmQgWSBjb21wb25lbnRzLlxyXG4gKlxyXG4gKiBAcGFyYW0geCAgWCBjb21wb25lbnQgb2YgdGhlIFZlY3RvclxyXG4gKiBAcGFyYW0geSAgWSBjb21wb25lbnQgb2YgdGhlIFZlY3RvclxyXG4gKi9cclxuZnVuY3Rpb24gdmVjKHgsIHkpIHtcclxuICAgIHJldHVybiBuZXcgVmVjdG9yKHgsIHkpO1xyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sb3IudHNcbnZhciBDb2xvcl9kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBQcm92aWRlcyBzdGFuZGFyZCBjb2xvcnMgKGUuZy4gW1tDb2xvci5CbGFja11dKVxyXG4gKiBidXQgeW91IGNhbiBhbHNvIGNyZWF0ZSBjdXN0b20gY29sb3JzIHVzaW5nIFJHQiwgSFNMLCBvciBIZXguIEFsc28gcHJvdmlkZXNcclxuICogdXNlZnVsIGNvbG9yIG9wZXJhdGlvbnMgbGlrZSBbW0NvbG9yLmxpZ2h0ZW5dXSwgW1tDb2xvci5kYXJrZW5dXSwgYW5kIG1vcmUuXHJcbiAqL1xyXG5jbGFzcyBDb2xvciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3IgZnJvbSBhbiByLCBnLCBiLCBhXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHIgIFRoZSByZWQgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAqIEBwYXJhbSBnICBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAqIEBwYXJhbSBiICBUaGUgYmx1ZSBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICogQHBhcmFtIGEgIFRoZSBhbHBoYSBjb21wb25lbnQgb2YgY29sb3IgKDAtMS4wKVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgdGhpcy5yID0gcjtcclxuICAgICAgICB0aGlzLmcgPSBnO1xyXG4gICAgICAgIHRoaXMuYiA9IGI7XHJcbiAgICAgICAgdGhpcy5hID0gYSAhPSBudWxsID8gYSA6IDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3IgZnJvbSBhbiByLCBnLCBiLCBhXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHIgIFRoZSByZWQgY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAqIEBwYXJhbSBnICBUaGUgZ3JlZW4gY29tcG9uZW50IG9mIGNvbG9yICgwLTI1NSlcclxuICAgICAqIEBwYXJhbSBiICBUaGUgYmx1ZSBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICogQHBhcmFtIGEgIFRoZSBhbHBoYSBjb21wb25lbnQgb2YgY29sb3IgKDAtMS4wKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVJHQihyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDb2xvciBmcm9tIGEgcmdiIHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzdHJpbmcgIENTUyBjb2xvciBzdHJpbmcgb2YgdGhlIGZvcm0gcmdiYSgyNTUsIDI1NSwgMjU1LCAxKSBvciByZ2IoMjU1LCAyNTUsIDI1NSlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21SR0JTdHJpbmcoc3RyaW5nKSB7XHJcbiAgICAgICAgY29uc3QgcmdiYVJlZ0V4ID0gL15yZ2JhP1xcKChcXGQrKSxcXHMqKFxcZCspLFxccyooXFxkKykoPzosXFxzKihcXGQrKD86XFwuXFxkKyk/KSk/XFwpL2k7XHJcbiAgICAgICAgbGV0IG1hdGNoID0gbnVsbDtcclxuICAgICAgICBpZiAoKG1hdGNoID0gc3RyaW5nLm1hdGNoKHJnYmFSZWdFeCkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xyXG4gICAgICAgICAgICBjb25zdCBnID0gcGFyc2VJbnQobWF0Y2hbMl0sIDEwKTtcclxuICAgICAgICAgICAgY29uc3QgYiA9IHBhcnNlSW50KG1hdGNoWzNdLCAxMCk7XHJcbiAgICAgICAgICAgIGxldCBhID0gMTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gcGFyc2VGbG9hdChtYXRjaFs0XSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZ2IvYSBzdHJpbmc6ICcgKyBzdHJpbmcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDb2xvciBmcm9tIGEgaGV4IHN0cmluZ1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBoZXggIENTUyBjb2xvciBzdHJpbmcgb2YgdGhlIGZvcm0gI2ZmZmZmZiwgdGhlIGFscGhhIGNvbXBvbmVudCBpcyBvcHRpb25hbFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcclxuICAgICAgICBjb25zdCBoZXhSZWdFeCA9IC9eIz8oWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pPyQvaTtcclxuICAgICAgICBsZXQgbWF0Y2ggPSBudWxsO1xyXG4gICAgICAgIGlmICgobWF0Y2ggPSBoZXgubWF0Y2goaGV4UmVnRXgpKSkge1xyXG4gICAgICAgICAgICBjb25zdCByID0gcGFyc2VJbnQobWF0Y2hbMV0sIDE2KTtcclxuICAgICAgICAgICAgY29uc3QgZyA9IHBhcnNlSW50KG1hdGNoWzJdLCAxNik7XHJcbiAgICAgICAgICAgIGNvbnN0IGIgPSBwYXJzZUludChtYXRjaFszXSwgMTYpO1xyXG4gICAgICAgICAgICBsZXQgYSA9IDE7XHJcbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSkge1xyXG4gICAgICAgICAgICAgICAgYSA9IHBhcnNlSW50KG1hdGNoWzRdLCAxNikgLyAyNTU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyLCBnLCBiLCBhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBoZXggc3RyaW5nOiAnICsgaGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgQ29sb3IgZnJvbSBoc2xhIHZhbHVlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBoICBIdWUgaXMgcmVwcmVzZW50ZWQgWzAtMV1cclxuICAgICAqIEBwYXJhbSBzICBTYXR1cmF0aW9uIGlzIHJlcHJlc2VudGVkIFswLTFdXHJcbiAgICAgKiBAcGFyYW0gbCAgTHVtaW5hbmNlIGlzIHJlcHJlc2VudGVkIFswLTFdXHJcbiAgICAgKiBAcGFyYW0gYSAgQWxwaGEgaXMgcmVwcmVzZW50ZWQgWzAtMV1cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21IU0woaCwgcywgbCwgYSA9IDEuMCkge1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSBuZXcgSFNMQ29sb3IoaCwgcywgbCwgYSk7XHJcbiAgICAgICAgcmV0dXJuIHRlbXAudG9SR0JBKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExpZ2h0ZW5zIHRoZSBjdXJyZW50IGNvbG9yIGJ5IGEgc3BlY2lmaWVkIGFtb3VudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBhbW91bnQgdG8gbGlnaHRlbiBieSBbMC0xXVxyXG4gICAgICovXHJcbiAgICBsaWdodGVuKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgICAgIHRlbXAubCArPSAoMSAtIHRlbXAubCkgKiBmYWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIHRlbXAudG9SR0JBKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERhcmtlbnMgdGhlIGN1cnJlbnQgY29sb3IgYnkgYSBzcGVjaWZpZWQgYW1vdW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGFtb3VudCB0byBkYXJrZW4gYnkgWzAtMV1cclxuICAgICAqL1xyXG4gICAgZGFya2VuKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgICAgIHRlbXAubCAtPSB0ZW1wLmwgKiBmYWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIHRlbXAudG9SR0JBKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhdHVyYXRlcyB0aGUgY3VycmVudCBjb2xvciBieSBhIHNwZWNpZmllZCBhbW91bnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgYW1vdW50IHRvIHNhdHVyYXRlIGJ5IFswLTFdXHJcbiAgICAgKi9cclxuICAgIHNhdHVyYXRlKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgICAgIHRlbXAucyArPSB0ZW1wLnMgKiBmYWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIHRlbXAudG9SR0JBKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERlc2F0dXJhdGVzIHRoZSBjdXJyZW50IGNvbG9yIGJ5IGEgc3BlY2lmaWVkIGFtb3VudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBhbW91bnQgdG8gZGVzYXR1cmF0ZSBieSBbMC0xXVxyXG4gICAgICovXHJcbiAgICBkZXNhdHVyYXRlKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgICAgIHRlbXAucyAtPSB0ZW1wLnMgKiBmYWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIHRlbXAudG9SR0JBKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGxpZXMgYSBjb2xvciBieSBhbm90aGVyLCByZXN1bHRzIGluIGEgZGFya2VyIGNvbG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbG9yICBUaGUgb3RoZXIgY29sb3JcclxuICAgICAqL1xyXG4gICAgbXVsdGlwbHkoY29sb3IpIHtcclxuICAgICAgICBjb25zdCBuZXdSID0gKCgoY29sb3IuciAvIDI1NSkgKiB0aGlzLnIpIC8gMjU1KSAqIDI1NTtcclxuICAgICAgICBjb25zdCBuZXdHID0gKCgoY29sb3IuZyAvIDI1NSkgKiB0aGlzLmcpIC8gMjU1KSAqIDI1NTtcclxuICAgICAgICBjb25zdCBuZXdCID0gKCgoY29sb3IuYiAvIDI1NSkgKiB0aGlzLmIpIC8gMjU1KSAqIDI1NTtcclxuICAgICAgICBjb25zdCBuZXdBID0gY29sb3IuYSAqIHRoaXMuYTtcclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ld1IsIG5ld0csIG5ld0IsIG5ld0EpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNdWx0aXBsaWVzIGEgY29sb3IgYnkgYW5vdGhlciwgcmVzdWx0cyBpbiBhIGRhcmtlciBjb2xvclxyXG4gICAgICogQHBhcmFtIGNvbG9yXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBBbGlhcyBmb3IgaW5jb3JyZWN0IHNwZWxsaW5nIHVzZWQgaW4gb2xkZXIgdmVyc2lvbnMsIHVzZSBtdWx0aXBseSBpbnN0ZWFkLCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjUuMFxyXG4gICAgICovXHJcbiAgICBtdWxpdGlwbHkoY29sb3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShjb2xvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjcmVlbnMgYSBjb2xvciBieSBhbm90aGVyLCByZXN1bHRzIGluIGEgbGlnaHRlciBjb2xvclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIG90aGVyIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIHNjcmVlbihjb2xvcikge1xyXG4gICAgICAgIGNvbnN0IGNvbG9yMSA9IGNvbG9yLmludmVydCgpO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yMiA9IGNvbG9yLmludmVydCgpO1xyXG4gICAgICAgIHJldHVybiBjb2xvcjEubXVsdGlwbHkoY29sb3IyKS5pbnZlcnQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW52ZXJ0cyB0aGUgY3VycmVudCBjb2xvclxyXG4gICAgICovXHJcbiAgICBpbnZlcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcigyNTUgLSB0aGlzLnIsIDI1NSAtIHRoaXMuZywgMjU1IC0gdGhpcy5iLCAxLjAgLSB0aGlzLmEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBdmVyYWdlcyB0aGUgY3VycmVudCBjb2xvciB3aXRoIGFub3RoZXJcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgIFRoZSBvdGhlciBjb2xvclxyXG4gICAgICovXHJcbiAgICBhdmVyYWdlKGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgbmV3UiA9IChjb2xvci5yICsgdGhpcy5yKSAvIDI7XHJcbiAgICAgICAgY29uc3QgbmV3RyA9IChjb2xvci5nICsgdGhpcy5nKSAvIDI7XHJcbiAgICAgICAgY29uc3QgbmV3QiA9IChjb2xvci5iICsgdGhpcy5iKSAvIDI7XHJcbiAgICAgICAgY29uc3QgbmV3QSA9IChjb2xvci5hICsgdGhpcy5hKSAvIDI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihuZXdSLCBuZXdHLCBuZXdCLCBuZXdBKTtcclxuICAgIH1cclxuICAgIGVxdWFsKGNvbG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKSA9PT0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIENTUyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZm9ybWF0IENvbG9yIHJlcHJlc2VudGF0aW9uLCBhY2NlcHRzOiByZ2IsIGhzbCwgb3IgaGV4XHJcbiAgICAgKi9cclxuICAgIHRvU3RyaW5nKGZvcm1hdCA9ICdyZ2InKSB7XHJcbiAgICAgICAgc3dpdGNoIChmb3JtYXQpIHtcclxuICAgICAgICAgICAgY2FzZSAncmdiJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvUkdCQSgpO1xyXG4gICAgICAgICAgICBjYXNlICdoc2wnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9IU0xBKCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2hleCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIENvbG9yIGZvcm1hdCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBIZXggVmFsdWUgb2YgYSBjb2xvciBjb21wb25lbnRcclxuICAgICAqIEBwYXJhbSBjIGNvbG9yIGNvbXBvbmVudFxyXG4gICAgICogQHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NjIzODM4L3JnYi10by1oZXgtYW5kLWhleC10by1yZ2JcclxuICAgICAqL1xyXG4gICAgX2NvbXBvbmVudFRvSGV4KGMpIHtcclxuICAgICAgICBjb25zdCBoZXggPSBjLnRvU3RyaW5nKDE2KTtcclxuICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIEhleCByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICB0b0hleCgpIHtcclxuICAgICAgICByZXR1cm4gJyMnICsgdGhpcy5fY29tcG9uZW50VG9IZXgodGhpcy5yKSArIHRoaXMuX2NvbXBvbmVudFRvSGV4KHRoaXMuZykgKyB0aGlzLl9jb21wb25lbnRUb0hleCh0aGlzLmIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gUkdCQSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICB0b1JHQkEoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gU3RyaW5nKHRoaXMuci50b0ZpeGVkKDApKSArICcsICcgKyBTdHJpbmcodGhpcy5nLnRvRml4ZWQoMCkpICsgJywgJyArIFN0cmluZyh0aGlzLmIudG9GaXhlZCgwKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuYSAhPT0gdW5kZWZpbmVkIHx8IHRoaXMuYSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ3JnYmEoJyArIHJlc3VsdCArICcsICcgKyBTdHJpbmcodGhpcy5hKSArICcpJztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICdyZ2IoJyArIHJlc3VsdCArICcpJztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIEhTTEEgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cclxuICAgICAqL1xyXG4gICAgdG9IU0xBKCkge1xyXG4gICAgICAgIHJldHVybiBIU0xDb2xvci5mcm9tUkdCQSh0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBDU1Mgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIGZpbGxTdHlsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhlIGN1cnJlbnQgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IodGhpcy5yLCB0aGlzLmcsIHRoaXMuYiwgdGhpcy5hKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmxhY2sgKCMwMDAwMDApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgQmxhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyMwMDAwMDAnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2hpdGUgKCNGRkZGRkYpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgV2hpdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyNGRkZGRkYnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR3JheSAoIzgwODA4MClcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBHcmF5KCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjODA4MDgwJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExpZ2h0IGdyYXkgKCNEM0QzRDMpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgTGlnaHRHcmF5KCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjRDNEM0QzJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERhcmsgZ3JheSAoI0E5QTlBOSlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBEYXJrR3JheSgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnI0E5QTlBOScpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBZZWxsb3cgKCNGRkZGMDApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgWWVsbG93KCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjRkZGRjAwJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9yYW5nZSAoI0ZGQTUwMClcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBPcmFuZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyNGRkE1MDAnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVkICgjRkYwMDAwKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IFJlZCgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnI0ZGMDAwMCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBWZXJtaWxpb24gKCNGRjVCMzEpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgVmVybWlsaW9uKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjRkY1QjMxJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZlcm1pbGlvbiAoI0ZGNUIzMSlcclxuICAgICAqIEBkZXByZWNhdGVkIEFsaWFzIGZvciBpbmNvcnJlY3Qgc3BlbGxpbmcgdXNlZCBpbiBvbGRlciB2ZXJzaW9ucywgdXNlIG11bHRpcGx5IGluc3RlYWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNS4wXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgVmVybWlsbGlvbigpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuVmVybWlsaW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3NlICgjRkYwMDdGKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IFJvc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyNGRjAwN0YnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWFnZW50YSAoI0ZGMDBGRilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBNYWdlbnRhKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjRkYwMEZGJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZpb2xldCAoIzdGMDBGRilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBWaW9sZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyM3RjAwRkYnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmx1ZSAoIzAwMDBGRilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBCbHVlKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjMDAwMEZGJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF6dXJlICgjMDA3RkZGKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IEF6dXJlKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjMDA3RkZGJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEN5YW4gKCMwMEZGRkYpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgQ3lhbigpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnIzAwRkZGRicpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBWaXJpZGlhbiAoIzU5OTc4RilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBWaXJpZGlhbigpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnIzU5OTc4RicpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmVlbiAoIzAwRkYwMClcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBHcmVlbigpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnIzAwRkYwMCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFydHJldXNlICgjN0ZGRjAwKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IENoYXJ0cmV1c2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyM3RkZGMDAnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNwYXJlbnQgKCNGRkZGRkYwMClcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBUcmFuc3BhcmVudCgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnI0ZGRkZGRjAwJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV4Y2FsaWJ1ckJsdWUgKCMxNzZCQUEpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgRXhjYWxpYnVyQmx1ZSgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnIzE3NkJBQScpO1xyXG4gICAgfVxyXG59XHJcbkNvbG9yX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHsgbWVzc2FnZTogJ0FsaWFzIGZvciBpbmNvcnJlY3Qgc3BlbGxpbmcgdXNlZCBpbiBvbGRlciB2ZXJzaW9ucywgdXNlIG11bHRpcGx5IGluc3RlYWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNS4wJyB9KVxyXG5dLCBDb2xvci5wcm90b3R5cGUsIFwibXVsaXRpcGx5XCIsIG51bGwpO1xyXG5Db2xvcl9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0FsaWFzIGZvciBpbmNvcnJlY3Qgc3BlbGxpbmcgdXNlZCBpbiBvbGRlciB2ZXJzaW9ucycsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVmVybWlsaW9uJ1xyXG4gICAgfSlcclxuXSwgQ29sb3IsIFwiVmVybWlsbGlvblwiLCBudWxsKTtcclxuLyoqXHJcbiAqIEludGVybmFsIEhTTCBDb2xvciByZXByZXNlbnRhdGlvblxyXG4gKlxyXG4gKiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hTTF9hbmRfSFNWXHJcbiAqIGh0dHA6Ly9heG9uZmx1eC5jb20vaGFuZHktcmdiLXRvLWhzbC1hbmQtcmdiLXRvLWhzdi1jb2xvci1tb2RlbC1jXHJcbiAqL1xyXG5jbGFzcyBIU0xDb2xvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihoLCBzLCBsLCBhKSB7XHJcbiAgICAgICAgdGhpcy5oID0gaDtcclxuICAgICAgICB0aGlzLnMgPSBzO1xyXG4gICAgICAgIHRoaXMubCA9IGw7XHJcbiAgICAgICAgdGhpcy5hID0gYTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBodWUycmdiKHAsIHEsIHQpIHtcclxuICAgICAgICBpZiAodCA8IDApIHtcclxuICAgICAgICAgICAgdCArPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodCA+IDEpIHtcclxuICAgICAgICAgICAgdCAtPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodCA8IDEgLyA2KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodCA8IDEgLyAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodCA8IDIgLyAzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVJHQkEociwgZywgYiwgYSkge1xyXG4gICAgICAgIHIgLz0gMjU1O1xyXG4gICAgICAgIGcgLz0gMjU1O1xyXG4gICAgICAgIGIgLz0gMjU1O1xyXG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcclxuICAgICAgICBsZXQgaCwgcztcclxuICAgICAgICBjb25zdCBsID0gKG1heCArIG1pbikgLyAyO1xyXG4gICAgICAgIGlmIChtYXggPT09IG1pbikge1xyXG4gICAgICAgICAgICBoID0gcyA9IDA7IC8vIGFjaHJvbWF0aWNcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGQgPSBtYXggLSBtaW47XHJcbiAgICAgICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcclxuICAgICAgICAgICAgc3dpdGNoIChtYXgpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgcjpcclxuICAgICAgICAgICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIGc6XHJcbiAgICAgICAgICAgICAgICAgICAgaCA9IChiIC0gcikgLyBkICsgMjtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgYjpcclxuICAgICAgICAgICAgICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGggLz0gNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBIU0xDb2xvcihoLCBzLCBsLCBhKTtcclxuICAgIH1cclxuICAgIHRvUkdCQSgpIHtcclxuICAgICAgICBsZXQgciwgZywgYjtcclxuICAgICAgICBpZiAodGhpcy5zID09PSAwKSB7XHJcbiAgICAgICAgICAgIHIgPSBnID0gYiA9IHRoaXMubDsgLy8gYWNocm9tYXRpY1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgcSA9IHRoaXMubCA8IDAuNSA/IHRoaXMubCAqICgxICsgdGhpcy5zKSA6IHRoaXMubCArIHRoaXMucyAtIHRoaXMubCAqIHRoaXMucztcclxuICAgICAgICAgICAgY29uc3QgcCA9IDIgKiB0aGlzLmwgLSBxO1xyXG4gICAgICAgICAgICByID0gSFNMQ29sb3IuaHVlMnJnYihwLCBxLCB0aGlzLmggKyAxIC8gMyk7XHJcbiAgICAgICAgICAgIGcgPSBIU0xDb2xvci5odWUycmdiKHAsIHEsIHRoaXMuaCk7XHJcbiAgICAgICAgICAgIGIgPSBIU0xDb2xvci5odWUycmdiKHAsIHEsIHRoaXMuaCAtIDEgLyAzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcihyICogMjU1LCBnICogMjU1LCBiICogMjU1LCB0aGlzLmEpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgY29uc3QgaCA9IHRoaXMuaC50b0ZpeGVkKDApLCBzID0gdGhpcy5zLnRvRml4ZWQoMCksIGwgPSB0aGlzLmwudG9GaXhlZCgwKSwgYSA9IHRoaXMuYS50b0ZpeGVkKDApO1xyXG4gICAgICAgIHJldHVybiBgaHNsYSgke2h9LCAke3N9LCAke2x9LCAke2F9KWA7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQm91bmRpbmdCb3gudHNcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBeGlzIEFsaWduZWQgY29sbGlzaW9uIHByaW1pdGl2ZSBmb3IgRXhjYWxpYnVyLlxyXG4gKi9cclxuY2xhc3MgQm91bmRpbmdCb3gge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdHJ1Y3RvciBhbGxvd3MgcGFzc2luZyBvZiBlaXRoZXIgYW4gb2JqZWN0IHdpdGggYWxsIGNvb3JkaW5hdGUgY29tcG9uZW50cyxcclxuICAgICAqIG9yIHRoZSBjb29yZGluYXRlIGNvbXBvbmVudHMgcGFzc2VkIHNlcGFyYXRlbHkuXHJcbiAgICAgKiBAcGFyYW0gbGVmdE9yT3B0aW9ucyAgICBFaXRoZXIgeCBjb29yZGluYXRlIG9mIHRoZSBsZWZ0IGVkZ2Ugb3IgYW4gb3B0aW9ucyBvYmplY3RcclxuICAgICAqIGNvbnRhaW5pbmcgdGhlIGZvdXIgY29vcmRpbmF0ZSBjb21wb25lbnRzLlxyXG4gICAgICogQHBhcmFtIHRvcCAgICAgeSBjb29yZGluYXRlIG9mIHRoZSB0b3AgZWRnZVxyXG4gICAgICogQHBhcmFtIHJpZ2h0ICAgeCBjb29yZGluYXRlIG9mIHRoZSByaWdodCBlZGdlXHJcbiAgICAgKiBAcGFyYW0gYm90dG9tICB5IGNvb3JkaW5hdGUgb2YgdGhlIGJvdHRvbSBlZGdlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxlZnRPck9wdGlvbnMgPSAwLCB0b3AgPSAwLCByaWdodCA9IDAsIGJvdHRvbSA9IDApIHtcclxuICAgICAgICBpZiAodHlwZW9mIGxlZnRPck9wdGlvbnMgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnRPck9wdGlvbnMubGVmdDtcclxuICAgICAgICAgICAgdGhpcy50b3AgPSBsZWZ0T3JPcHRpb25zLnRvcDtcclxuICAgICAgICAgICAgdGhpcy5yaWdodCA9IGxlZnRPck9wdGlvbnMucmlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gbGVmdE9yT3B0aW9ucy5ib3R0b207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBsZWZ0T3JPcHRpb25zID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0T3JPcHRpb25zO1xyXG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRvcDtcclxuICAgICAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmJvdHRvbSA9IGJvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGJvdW5kaW5nIGJveCBBICYgQiwgcmV0dXJucyB0aGUgc2lkZSByZWxhdGl2ZSB0byBBIHdoZW4gaW50ZXJzZWN0aW9uIGlzIHBlcmZvcm1lZC5cclxuICAgICAqIEBwYXJhbSBpbnRlcnNlY3Rpb24gSW50ZXJzZWN0aW9uIHZlY3RvciBiZXR3ZWVuIDIgYm91bmRpbmcgYm94ZXNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldFNpZGVGcm9tSW50ZXJzZWN0aW9uKGludGVyc2VjdGlvbikge1xyXG4gICAgICAgIGlmICghaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlLk5vbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpbnRlcnNlY3Rpb24pIHtcclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKGludGVyc2VjdGlvbi54KSA+IE1hdGguYWJzKGludGVyc2VjdGlvbi55KSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbi54IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlLlJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFNpZGUuTGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb24ueSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2lkZS5Cb3R0b207XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2lkZS5Ub3A7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNpZGUuTm9uZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tUG9pbnRzKHBvaW50cykge1xyXG4gICAgICAgIGxldCBtaW5YID0gSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IG1pblkgPSBJbmZpbml0eTtcclxuICAgICAgICBsZXQgbWF4WCA9IC1JbmZpbml0eTtcclxuICAgICAgICBsZXQgbWF4WSA9IC1JbmZpbml0eTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocG9pbnRzW2ldLnggPCBtaW5YKSB7XHJcbiAgICAgICAgICAgICAgICBtaW5YID0gcG9pbnRzW2ldLng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvaW50c1tpXS54ID4gbWF4WCkge1xyXG4gICAgICAgICAgICAgICAgbWF4WCA9IHBvaW50c1tpXS54O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludHNbaV0ueSA8IG1pblkpIHtcclxuICAgICAgICAgICAgICAgIG1pblkgPSBwb2ludHNbaV0ueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9pbnRzW2ldLnkgPiBtYXhZKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhZID0gcG9pbnRzW2ldLnk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tRGltZW5zaW9uKHdpZHRoLCBoZWlnaHQsIGFuY2hvciA9IFZlY3Rvci5IYWxmLCBwb3MgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goLXdpZHRoICogYW5jaG9yLnggKyBwb3MueCwgLWhlaWdodCAqIGFuY2hvci55ICsgcG9zLnksIHdpZHRoIC0gd2lkdGggKiBhbmNob3IueCArIHBvcy54LCBoZWlnaHQgLSBoZWlnaHQgKiBhbmNob3IueSArIHBvcy55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCB3aWR0aCBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgKi9cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yaWdodCAtIHRoaXMubGVmdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2FsY3VsYXRlZCBoZWlnaHQgb2YgdGhlIGJvdW5kaW5nIGJveFxyXG4gICAgICovXHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbSAtIHRoaXMudG9wO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gd2hldGhlciB0aGUgYm91bmRpbmcgYm94IGhhcyB6ZXJvIGRpbWVuc2lvbnMgaW4gaGVpZ2h0LHdpZHRoIG9yIGJvdGhcclxuICAgICAqL1xyXG4gICAgaGFzWmVyb0RpbWVuc2lvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud2lkdGggPT09IDAgfHwgdGhpcy5oZWlnaHQgPT09IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNlbnRlciBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgKi9cclxuICAgIGdldCBjZW50ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoKHRoaXMubGVmdCArIHRoaXMucmlnaHQpIC8gMiwgKHRoaXMudG9wICsgdGhpcy5ib3R0b20pIC8gMik7XHJcbiAgICB9XHJcbiAgICB0cmFuc2xhdGUocG9zKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0aGlzLmxlZnQgKyBwb3MueCwgdGhpcy50b3AgKyBwb3MueSwgdGhpcy5yaWdodCArIHBvcy54LCB0aGlzLmJvdHRvbSArIHBvcy55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlcyBhIGJvdW5kaW5nIGJveCBieSBhbmQgYW5nbGUgYW5kIGFyb3VuZCBhIHBvaW50LCBpZiBubyBwb2ludCBpcyBzcGVjaWZpZWQgKDAsIDApIGlzIHVzZWQgYnkgZGVmYXVsdC4gVGhlIHJlc3VsdGluZyBib3VuZGluZ1xyXG4gICAgICogYm94IGlzIGFsc28gYXhpcy1hbGlnbi4gVGhpcyBpcyB1c2VmdWwgd2hlbiBhIG5ldyBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94IGlzIG5lZWRlZCBmb3Igcm90YXRlZCBnZW9tZXRyeS5cclxuICAgICAqL1xyXG4gICAgcm90YXRlKGFuZ2xlLCBwb2ludCA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKS5tYXAoKHApID0+IHAucm90YXRlKGFuZ2xlLCBwb2ludCkpO1xyXG4gICAgICAgIHJldHVybiBCb3VuZGluZ0JveC5mcm9tUG9pbnRzKHBvaW50cyk7XHJcbiAgICB9XHJcbiAgICBzY2FsZShzY2FsZSwgcG9pbnQgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIGNvbnN0IHNoaWZ0ZWQgPSB0aGlzLnRyYW5zbGF0ZShwb2ludCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChzaGlmdGVkLmxlZnQgKiBzY2FsZS54LCBzaGlmdGVkLnRvcCAqIHNjYWxlLnksIHNoaWZ0ZWQucmlnaHQgKiBzY2FsZS54LCBzaGlmdGVkLmJvdHRvbSAqIHNjYWxlLnkpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNmb3JtKG1hdHJpeCkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuZ2V0UG9pbnRzKCkubWFwKChwKSA9PiBtYXRyaXgubXVsdHYocCkpO1xyXG4gICAgICAgIHJldHVybiBCb3VuZGluZ0JveC5mcm9tUG9pbnRzKHBvaW50cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBlcmltZXRlciBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgKi9cclxuICAgIGdldFBlcmltZXRlcigpIHtcclxuICAgICAgICBjb25zdCB3eCA9IHRoaXMud2lkdGg7XHJcbiAgICAgICAgY29uc3Qgd3kgPSB0aGlzLmhlaWdodDtcclxuICAgICAgICByZXR1cm4gMiAqICh3eCArIHd5KTtcclxuICAgIH1cclxuICAgIGdldFBvaW50cygpIHtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBWZWN0b3IodGhpcy5sZWZ0LCB0aGlzLnRvcCkpO1xyXG4gICAgICAgIHJlc3VsdHMucHVzaChuZXcgVmVjdG9yKHRoaXMucmlnaHQsIHRoaXMudG9wKSk7XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBWZWN0b3IodGhpcy5yaWdodCwgdGhpcy5ib3R0b20pKTtcclxuICAgICAgICByZXN1bHRzLnB1c2gobmV3IFZlY3Rvcih0aGlzLmxlZnQsIHRoaXMuYm90dG9tKSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluZXMgd2hldGhlciBhIHJheSBpbnRlcnNlY3RzIHdpdGggYSBib3VuZGluZyBib3hcclxuICAgICAqL1xyXG4gICAgcmF5Q2FzdChyYXksIGZhckNsaXBEaXN0YW5jZSA9IEluZmluaXR5KSB7XHJcbiAgICAgICAgLy8gYWxnb3JpdGhtIGZyb20gaHR0cHM6Ly90YXZpYW5hdG9yLmNvbS9mYXN0LWJyYW5jaGxlc3MtcmF5Ym91bmRpbmctYm94LWludGVyc2VjdGlvbnMvXHJcbiAgICAgICAgbGV0IHRtaW4gPSAtSW5maW5pdHk7XHJcbiAgICAgICAgbGV0IHRtYXggPSArSW5maW5pdHk7XHJcbiAgICAgICAgY29uc3QgeGludiA9IHJheS5kaXIueCA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiAxIC8gcmF5LmRpci54O1xyXG4gICAgICAgIGNvbnN0IHlpbnYgPSByYXkuZGlyLnkgPT09IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogMSAvIHJheS5kaXIueTtcclxuICAgICAgICBjb25zdCB0eDEgPSAodGhpcy5sZWZ0IC0gcmF5LnBvcy54KSAqIHhpbnY7XHJcbiAgICAgICAgY29uc3QgdHgyID0gKHRoaXMucmlnaHQgLSByYXkucG9zLngpICogeGludjtcclxuICAgICAgICB0bWluID0gTWF0aC5taW4odHgxLCB0eDIpO1xyXG4gICAgICAgIHRtYXggPSBNYXRoLm1heCh0eDEsIHR4Mik7XHJcbiAgICAgICAgY29uc3QgdHkxID0gKHRoaXMudG9wIC0gcmF5LnBvcy55KSAqIHlpbnY7XHJcbiAgICAgICAgY29uc3QgdHkyID0gKHRoaXMuYm90dG9tIC0gcmF5LnBvcy55KSAqIHlpbnY7XHJcbiAgICAgICAgdG1pbiA9IE1hdGgubWF4KHRtaW4sIE1hdGgubWluKHR5MSwgdHkyKSk7XHJcbiAgICAgICAgdG1heCA9IE1hdGgubWluKHRtYXgsIE1hdGgubWF4KHR5MSwgdHkyKSk7XHJcbiAgICAgICAgcmV0dXJuIHRtYXggPj0gTWF0aC5tYXgoMCwgdG1pbikgJiYgdG1pbiA8IGZhckNsaXBEaXN0YW5jZTtcclxuICAgIH1cclxuICAgIHJheUNhc3RUaW1lKHJheSwgZmFyQ2xpcERpc3RhbmNlID0gSW5maW5pdHkpIHtcclxuICAgICAgICAvLyBhbGdvcml0aG0gZnJvbSBodHRwczovL3RhdmlhbmF0b3IuY29tL2Zhc3QtYnJhbmNobGVzcy1yYXlib3VuZGluZy1ib3gtaW50ZXJzZWN0aW9ucy9cclxuICAgICAgICBsZXQgdG1pbiA9IC1JbmZpbml0eTtcclxuICAgICAgICBsZXQgdG1heCA9ICtJbmZpbml0eTtcclxuICAgICAgICBjb25zdCB4aW52ID0gcmF5LmRpci54ID09PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6IDEgLyByYXkuZGlyLng7XHJcbiAgICAgICAgY29uc3QgeWludiA9IHJheS5kaXIueSA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiAxIC8gcmF5LmRpci55O1xyXG4gICAgICAgIGNvbnN0IHR4MSA9ICh0aGlzLmxlZnQgLSByYXkucG9zLngpICogeGludjtcclxuICAgICAgICBjb25zdCB0eDIgPSAodGhpcy5yaWdodCAtIHJheS5wb3MueCkgKiB4aW52O1xyXG4gICAgICAgIHRtaW4gPSBNYXRoLm1pbih0eDEsIHR4Mik7XHJcbiAgICAgICAgdG1heCA9IE1hdGgubWF4KHR4MSwgdHgyKTtcclxuICAgICAgICBjb25zdCB0eTEgPSAodGhpcy50b3AgLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICBjb25zdCB0eTIgPSAodGhpcy5ib3R0b20gLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICB0bWluID0gTWF0aC5tYXgodG1pbiwgTWF0aC5taW4odHkxLCB0eTIpKTtcclxuICAgICAgICB0bWF4ID0gTWF0aC5taW4odG1heCwgTWF0aC5tYXgodHkxLCB0eTIpKTtcclxuICAgICAgICBpZiAodG1heCA+PSBNYXRoLm1heCgwLCB0bWluKSAmJiB0bWluIDwgZmFyQ2xpcERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0bWluO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBjb250YWlucyh2YWwpIHtcclxuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxlZnQgPD0gdmFsLnggJiYgdGhpcy50b3AgPD0gdmFsLnkgJiYgdGhpcy5ib3R0b20gPj0gdmFsLnkgJiYgdGhpcy5yaWdodCA+PSB2YWwueDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgQm91bmRpbmdCb3gpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubGVmdCA8IHZhbC5sZWZ0ICYmIHRoaXMudG9wIDwgdmFsLnRvcCAmJiB2YWwuYm90dG9tIDwgdGhpcy5ib3R0b20gJiYgdmFsLnJpZ2h0IDwgdGhpcy5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmVzIHRoaXMgYm91bmRpbmcgYm94IGFuZCBhbm90aGVyIHRvZ2V0aGVyIHJldHVybmluZyBhIG5ldyBib3VuZGluZyBib3hcclxuICAgICAqIEBwYXJhbSBvdGhlciAgVGhlIGJvdW5kaW5nIGJveCB0byBjb21iaW5lXHJcbiAgICAgKi9cclxuICAgIGNvbWJpbmUob3RoZXIpIHtcclxuICAgICAgICBjb25zdCBjb21wb3NpdGVCQiA9IG5ldyBCb3VuZGluZ0JveChNYXRoLm1pbih0aGlzLmxlZnQsIG90aGVyLmxlZnQpLCBNYXRoLm1pbih0aGlzLnRvcCwgb3RoZXIudG9wKSwgTWF0aC5tYXgodGhpcy5yaWdodCwgb3RoZXIucmlnaHQpLCBNYXRoLm1heCh0aGlzLmJvdHRvbSwgb3RoZXIuYm90dG9tKSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0ZUJCO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRpbWVuc2lvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IHdldGhlciB0aGlzIGJvdW5kaW5nIGJveCBpbnRlcnNlY3RzIHdpdGggYW5vdGhlciByZXR1cm5pbmdcclxuICAgICAqIHRoZSBpbnRlcnNlY3Rpb24gdmVjdG9yIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVzb2x2ZSB0aGUgY29sbGlzaW9uLiBJZiB0aGVyZVxyXG4gICAgICogaXMgbm8gaW50ZXJzZWN0aW9uIG51bGwgaXMgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIG90aGVyICBPdGhlciBbW0JvdW5kaW5nQm94XV0gdG8gdGVzdCBpbnRlcnNlY3Rpb24gd2l0aFxyXG4gICAgICogQHJldHVybnMgQSBWZWN0b3IgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgY3VycmVudCBCb3VuZGluZ0JveCwgdGhpcyA8LSBvdGhlclxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3Qob3RoZXIpIHtcclxuICAgICAgICBjb25zdCB0b3RhbEJvdW5kaW5nQm94ID0gdGhpcy5jb21iaW5lKG90aGVyKTtcclxuICAgICAgICAvLyBJZiB0aGUgdG90YWwgYm91bmRpbmcgYm94IGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0aGUgc3VtIG9mIHRoZSAyIGJvdW5kcyB0aGVuIHRoZXJlIGlzIGNvbGxpc2lvblxyXG4gICAgICAgIGlmICh0b3RhbEJvdW5kaW5nQm94LndpZHRoIDwgb3RoZXIud2lkdGggKyB0aGlzLndpZHRoICYmXHJcbiAgICAgICAgICAgIHRvdGFsQm91bmRpbmdCb3guaGVpZ2h0IDwgb3RoZXIuaGVpZ2h0ICsgdGhpcy5oZWlnaHQgJiZcclxuICAgICAgICAgICAgIXRvdGFsQm91bmRpbmdCb3guZGltZW5zaW9ucy5lcXVhbHMob3RoZXIuZGltZW5zaW9ucykgJiZcclxuICAgICAgICAgICAgIXRvdGFsQm91bmRpbmdCb3guZGltZW5zaW9ucy5lcXVhbHModGhpcy5kaW1lbnNpb25zKSkge1xyXG4gICAgICAgICAgICAvLyBjb2xsaXNpb25cclxuICAgICAgICAgICAgbGV0IG92ZXJsYXBYID0gMDtcclxuICAgICAgICAgICAgLy8gcmlnaHQgZWRnZSBpcyBiZXR3ZWVuIHRoZSBvdGhlcidzIGxlZnQgYW5kIHJpZ2h0IGVkZ2VcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqICAgICArLXRoaXMtK1xyXG4gICAgICAgICAgICAgKiAgICAgfCAgICAgIHxcclxuICAgICAgICAgICAgICogICAgIHwgICAgKy1vdGhlci0rXHJcbiAgICAgICAgICAgICAqICAgICArLS0tLXwtKyAgICAgfFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB8ICAgICAgIHxcclxuICAgICAgICAgICAgICogICAgICAgICAgKy0tLS0tLS0rXHJcbiAgICAgICAgICAgICAqICAgICAgICAgPC0tLVxyXG4gICAgICAgICAgICAgKiAgICAgICAgICBeIG92ZXJsYXBcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnJpZ2h0ID49IG90aGVyLmxlZnQgJiYgdGhpcy5yaWdodCA8PSBvdGhlci5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5sZWZ0IC0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgIC8vIHJpZ2h0IGVkZ2UgaXMgcGFzdCB0aGUgb3RoZXIncyByaWdodCBlZGdlXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqICAgICArLW90aGVyLStcclxuICAgICAgICAgICAgICAgICAqICAgICB8ICAgICAgIHxcclxuICAgICAgICAgICAgICAgICAqICAgICB8ICAgICstdGhpcy0rXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgKy0tLS18LS0rICAgfFxyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgfCAgICAgIHxcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgICstLS0tLS0rXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICAtLS0+XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICBeIG92ZXJsYXBcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5yaWdodCAtIHRoaXMubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgb3ZlcmxhcFkgPSAwO1xyXG4gICAgICAgICAgICAvLyB0b3AgZWRnZSBpcyBiZXR3ZWVuIHRoZSBvdGhlcidzIHRvcCBhbmQgYm90dG9tIGVkZ2VcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqICAgICArLW90aGVyLStcclxuICAgICAgICAgICAgICogICAgIHwgICAgICAgfFxyXG4gICAgICAgICAgICAgKiAgICAgfCAgICArLXRoaXMtKyAgIHwgPC0gb3ZlcmxhcFxyXG4gICAgICAgICAgICAgKiAgICAgKy0tLS18LS0rICAgfCAgIHxcclxuICAgICAgICAgICAgICogICAgICAgICAgfCAgICAgIHwgIFxcIC9cclxuICAgICAgICAgICAgICogICAgICAgICAgKy0tLS0tLSsgICAnXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZiAodGhpcy50b3AgPD0gb3RoZXIuYm90dG9tICYmIHRoaXMudG9wID49IG90aGVyLnRvcCkge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci5ib3R0b20gLSB0aGlzLnRvcDtcclxuICAgICAgICAgICAgICAgIC8vIHRvcCBlZGdlIGlzIGFib3ZlIHRoZSBvdGhlciB0b3AgZWRnZVxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgKy10aGlzLSsgICAgICAgICAuXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgfCAgICAgIHwgICAgICAgIC8gXFxcclxuICAgICAgICAgICAgICAgICAqICAgICB8ICAgICstb3RoZXItKyAgIHwgPC0gb3ZlcmxhcFxyXG4gICAgICAgICAgICAgICAgICogICAgICstLS0tfC0rICAgICB8ICAgfFxyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgfCAgICAgICB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICArLS0tLS0tLStcclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci50b3AgLSB0aGlzLmJvdHRvbTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMob3ZlcmxhcFgpIDwgTWF0aC5hYnMob3ZlcmxhcFkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihvdmVybGFwWCwgMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCBvdmVybGFwWSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQ2FzZSBvZiB0b3RhbCBjb250YWlubWVudCBvZiBvbmUgYm91bmRpbmcgYm94IGJ5IGFub3RoZXJcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodG90YWxCb3VuZGluZ0JveC5kaW1lbnNpb25zLmVxdWFscyhvdGhlci5kaW1lbnNpb25zKSB8fCB0b3RhbEJvdW5kaW5nQm94LmRpbWVuc2lvbnMuZXF1YWxzKHRoaXMuZGltZW5zaW9ucykpIHtcclxuICAgICAgICAgICAgbGV0IG92ZXJsYXBYID0gMDtcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyB3aWRlciB0aGFuIHRoZSBvdGhlclxyXG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCAtIG90aGVyLndpZHRoID49IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgcmlnaHQgZWRnZSBpcyBjbG9zZXN0IHRvIHRoZSBvdGhlcnMgcmlnaHQgZWRnZVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgLSBvdGhlci5yaWdodCA8PSBvdGhlci5sZWZ0IC0gdGhpcy5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFggPSBvdGhlci5sZWZ0IC0gdGhpcy5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGxlZnQgZWRnZSBpcyBjbG9zZXN0IHRvIHRoZSBvdGhlcnMgbGVmdCBlZGdlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwWCA9IG90aGVyLnJpZ2h0IC0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgaXMgd2lkZXIgdGhhbiB0aGlzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJpZ2h0IGVkZ2UgaXMgY2xvc2VzdCB0byB0aGUgb3RoZXJzIHJpZ2h0IGVkZ2VcclxuICAgICAgICAgICAgICAgIGlmIChvdGhlci5yaWdodCAtIHRoaXMucmlnaHQgPD0gdGhpcy5sZWZ0IC0gb3RoZXIubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBYID0gdGhpcy5sZWZ0IC0gb3RoZXIucmlnaHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBsZWZ0IGVkZ2UgaXMgY2xvc2VzdCB0byB0aGUgb3RoZXJzIGxlZnQgZWRnZVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFggPSB0aGlzLnJpZ2h0IC0gb3RoZXIubGVmdDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgb3ZlcmxhcFkgPSAwO1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRhbGxlciB0aGFuIG90aGVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCAtIG90aGVyLmhlaWdodCA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgYm90dG9tIGVkZ2UgaXMgY2xvc2VzdCB0byB0aGUgb3RoZXJzIGJvdHRvbSBlZGdlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ib3R0b20gLSBvdGhlci5ib3R0b20gPD0gb3RoZXIudG9wIC0gdGhpcy50b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwWSA9IG90aGVyLnRvcCAtIHRoaXMuYm90dG9tO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSBvdGhlci5ib3R0b20gLSB0aGlzLnRvcDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIG90aGVyIGlzIHRhbGxlciB0aGFuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBib3R0b20gZWRnZSBpcyBjbG9zZXN0IHRvIHRoZSBvdGhlcnMgYm90dG9tIGVkZ2VcclxuICAgICAgICAgICAgICAgIGlmIChvdGhlci5ib3R0b20gLSB0aGlzLmJvdHRvbSA8PSB0aGlzLnRvcCAtIG90aGVyLnRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBZID0gdGhpcy50b3AgLSBvdGhlci5ib3R0b207XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwWSA9IHRoaXMuYm90dG9tIC0gb3RoZXIudG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhvdmVybGFwWCkgPCBNYXRoLmFicyhvdmVybGFwWSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG92ZXJsYXBYLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIG92ZXJsYXBZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0IHdoZXRoZXIgdGhlIGJvdW5kaW5nIGJveCBoYXMgaW50ZXJzZWN0ZWQgd2l0aCBhbm90aGVyIGJvdW5kaW5nIGJveCwgcmV0dXJucyB0aGUgc2lkZSBvZiB0aGUgY3VycmVudCBiYiB0aGF0IGludGVyc2VjdGVkLlxyXG4gICAgICogQHBhcmFtIGJiIFRoZSBvdGhlciBhY3RvciB0byB0ZXN0XHJcbiAgICAgKi9cclxuICAgIGludGVyc2VjdFdpdGhTaWRlKGJiKSB7XHJcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0ID0gdGhpcy5pbnRlcnNlY3QoYmIpO1xyXG4gICAgICAgIHJldHVybiBCb3VuZGluZ0JveC5nZXRTaWRlRnJvbUludGVyc2VjdGlvbihpbnRlcnNlY3QpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGRlYnVnRHJhdyhjdHgsIGNvbG9yID0gQ29sb3IuWWVsbG93KSB7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguc3Ryb2tlUmVjdCh0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgYSBkZWJ1ZyBib3VuZGluZyBib3hcclxuICAgICAqIEBwYXJhbSBleFxyXG4gICAgICogQHBhcmFtIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIGRyYXcoZXgsIGNvbG9yID0gQ29sb3IuWWVsbG93KSB7XHJcbiAgICAgICAgZXguZGVidWcuZHJhd1JlY3QodGhpcy5sZWZ0LCB0aGlzLnRvcCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHsgY29sb3IgfSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL21hdHJpeC50c1xuXHJcblxyXG5cclxudmFyIE1hdHJpeExvY2F0aW9ucztcclxuKGZ1bmN0aW9uIChNYXRyaXhMb2NhdGlvbnMpIHtcclxuICAgIE1hdHJpeExvY2F0aW9uc1tNYXRyaXhMb2NhdGlvbnNbXCJYXCJdID0gMTJdID0gXCJYXCI7XHJcbiAgICBNYXRyaXhMb2NhdGlvbnNbTWF0cml4TG9jYXRpb25zW1wiWVwiXSA9IDEzXSA9IFwiWVwiO1xyXG59KShNYXRyaXhMb2NhdGlvbnMgfHwgKE1hdHJpeExvY2F0aW9ucyA9IHt9KSk7XHJcbmNvbnN0IHNpZ24gPSAodmFsKSA9PiB7XHJcbiAgICBpZiAodmFsID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdmFsIDwgMCA/IC0xIDogMTtcclxufTtcclxuLy8gY29uc3QgbXVsdE1hdGNoID0gKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiB7XHJcbi8vICAgaWYgKHNpZ24oYSkgPCAwICYmIHNpZ24oYikgPCAwKSB7XHJcbi8vICAgICByZXR1cm4gLU1hdGguYWJzKGEgKiBiKTtcclxuLy8gICB9XHJcbi8vICAgcmV0dXJuIGEgKiBiO1xyXG4vLyB9XHJcbi8vIGNvbnN0IGVwc2lsb24gPSAodmFsOiBudW1iZXIpID0+IHtcclxuLy8gICBpZiAodmFsICogdmFsIDwgLjAwMDEpIHtcclxuLy8gICAgIHJldHVybiAwO1xyXG4vLyAgIH1cclxuLy8gICByZXR1cm4gdmFsO1xyXG4vLyB9XHJcbi8qKlxyXG4gKiBFeGNhbGlidXIgTWF0cml4IGhlbHBlciBmb3IgNHg0IG1hdHJpY2VzXHJcbiAqXHJcbiAqIFVzZWZ1bCBmb3Igd2ViZ2wgNHg0IG1hdHJpY2VzXHJcbiAqL1xyXG5jbGFzcyBNYXRyaXgge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogIDR4NCBtYXRyaXggaW4gY29sdW1uIG1ham9yIG9yZGVyXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiB8ICAgICAgICAgfCAgICAgICAgIHwgICAgICAgICAgfCAgICAgICAgICB8XHJcbiAgICAgICAgICogfCAtLS0tLS0tIHwgLS0tLS0tLSB8IC0tLS0tLS0tIHwgICAgICAgICAgfFxyXG4gICAgICAgICAqIHwgZGF0YVswXSB8IGRhdGFbNF0gfCBkYXRhWzhdICB8IGRhdGFbMTJdIHxcclxuICAgICAgICAgKiB8IGRhdGFbMV0gfCBkYXRhWzVdIHwgZGF0YVs5XSAgfCBkYXRhWzEzXSB8XHJcbiAgICAgICAgICogfCBkYXRhWzJdIHwgZGF0YVs2XSB8IGRhdGFbMTBdIHwgZGF0YVsxNF0gfFxyXG4gICAgICAgICAqIHwgZGF0YVszXSB8IGRhdGFbN10gfCBkYXRhWzExXSB8IGRhdGFbMTVdIHxcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBGbG9hdDMyQXJyYXkoMTYpO1xyXG4gICAgICAgIHRoaXMuX3NjYWxlU2lnblggPSAxO1xyXG4gICAgICAgIHRoaXMuX3NjYWxlU2lnblkgPSAxO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuIG9ydGhvZ3JhcGhpYyAoZmxhdCBub24tcGVyc3BlY3RpdmUpIHByb2plY3Rpb25cclxuICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL09ydGhvZ3JhcGhpY19wcm9qZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gbGVmdFxyXG4gICAgICogQHBhcmFtIHJpZ2h0XHJcbiAgICAgKiBAcGFyYW0gYm90dG9tXHJcbiAgICAgKiBAcGFyYW0gdG9wXHJcbiAgICAgKiBAcGFyYW0gbmVhclxyXG4gICAgICogQHBhcmFtIGZhclxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgb3J0aG8obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcclxuICAgICAgICBjb25zdCBtYXQgPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgbWF0LmRhdGFbMF0gPSAyIC8gKHJpZ2h0IC0gbGVmdCk7XHJcbiAgICAgICAgbWF0LmRhdGFbMV0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzJdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVszXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbNF0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzVdID0gMiAvICh0b3AgLSBib3R0b20pO1xyXG4gICAgICAgIG1hdC5kYXRhWzZdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs3XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbOF0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzldID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsxMF0gPSAtMiAvIChmYXIgLSBuZWFyKTtcclxuICAgICAgICBtYXQuZGF0YVsxMV0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzEyXSA9IC0ocmlnaHQgKyBsZWZ0KSAvIChyaWdodCAtIGxlZnQpO1xyXG4gICAgICAgIG1hdC5kYXRhWzEzXSA9IC0odG9wICsgYm90dG9tKSAvICh0b3AgLSBib3R0b20pO1xyXG4gICAgICAgIG1hdC5kYXRhWzE0XSA9IC0oZmFyICsgbmVhcikgLyAoZmFyIC0gbmVhcik7XHJcbiAgICAgICAgbWF0LmRhdGFbMTVdID0gMTtcclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IE1hdHJpeCB3aXRoIHRoZSBzYW1lIGRhdGEgYXMgdGhlIGN1cnJlbnQgNHg0XHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICBtYXQuZGF0YVswXSA9IHRoaXMuZGF0YVswXTtcclxuICAgICAgICBtYXQuZGF0YVsxXSA9IHRoaXMuZGF0YVsxXTtcclxuICAgICAgICBtYXQuZGF0YVsyXSA9IHRoaXMuZGF0YVsyXTtcclxuICAgICAgICBtYXQuZGF0YVszXSA9IHRoaXMuZGF0YVszXTtcclxuICAgICAgICBtYXQuZGF0YVs0XSA9IHRoaXMuZGF0YVs0XTtcclxuICAgICAgICBtYXQuZGF0YVs1XSA9IHRoaXMuZGF0YVs1XTtcclxuICAgICAgICBtYXQuZGF0YVs2XSA9IHRoaXMuZGF0YVs2XTtcclxuICAgICAgICBtYXQuZGF0YVs3XSA9IHRoaXMuZGF0YVs3XTtcclxuICAgICAgICBtYXQuZGF0YVs4XSA9IHRoaXMuZGF0YVs4XTtcclxuICAgICAgICBtYXQuZGF0YVs5XSA9IHRoaXMuZGF0YVs5XTtcclxuICAgICAgICBtYXQuZGF0YVsxMF0gPSB0aGlzLmRhdGFbMTBdO1xyXG4gICAgICAgIG1hdC5kYXRhWzExXSA9IHRoaXMuZGF0YVsxMV07XHJcbiAgICAgICAgbWF0LmRhdGFbMTJdID0gdGhpcy5kYXRhWzEyXTtcclxuICAgICAgICBtYXQuZGF0YVsxM10gPSB0aGlzLmRhdGFbMTNdO1xyXG4gICAgICAgIG1hdC5kYXRhWzE0XSA9IHRoaXMuZGF0YVsxNF07XHJcbiAgICAgICAgbWF0LmRhdGFbMTVdID0gdGhpcy5kYXRhWzE1XTtcclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGlkZW50aXR5IG1hdHJpeCAoYSBtYXRyaXggdGhhdCB3aGVuIGFwcGxpZWQgZG9lcyBub3RoaW5nKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaWRlbnRpdHkoKSB7XHJcbiAgICAgICAgY29uc3QgbWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgIG1hdC5kYXRhWzBdID0gMTtcclxuICAgICAgICBtYXQuZGF0YVsxXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbMl0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzNdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs0XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbNV0gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzZdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs3XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbOF0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzldID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsxMF0gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzExXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbMTJdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsxM10gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzE0XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbMTVdID0gMTtcclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYnJhbmQgbmV3IHRyYW5zbGF0aW9uIG1hdHJpeCBhdCB0aGUgc3BlY2lmaWVkIDNkIHBvaW50XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHRyYW5zbGF0aW9uKHgsIHkpIHtcclxuICAgICAgICBjb25zdCBtYXQgPSBNYXRyaXguaWRlbnRpdHkoKTtcclxuICAgICAgICBtYXQuZGF0YVsxMl0gPSB4O1xyXG4gICAgICAgIG1hdC5kYXRhWzEzXSA9IHk7XHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGJyYW5kIG5ldyBzY2FsaW5nIG1hdHJpeCB3aXRoIHRoZSBzcGVjaWZpZWQgc2NhbGluZyBmYWN0b3JcclxuICAgICAqIEBwYXJhbSBzeFxyXG4gICAgICogQHBhcmFtIHN5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzY2FsZShzeCwgc3kpIHtcclxuICAgICAgICBjb25zdCBtYXQgPSBNYXRyaXguaWRlbnRpdHkoKTtcclxuICAgICAgICBtYXQuZGF0YVswXSA9IHN4O1xyXG4gICAgICAgIG1hdC5kYXRhWzVdID0gc3k7XHJcbiAgICAgICAgbWF0LmRhdGFbMTBdID0gMTtcclxuICAgICAgICBtYXQuZGF0YVsxNV0gPSAxO1xyXG4gICAgICAgIHJldHVybiBtYXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBicmFuZCBuZXcgcm90YXRpb24gbWF0cml4IHdpdGggdGhlIHNwZWNpZmllZCBhbmdsZVxyXG4gICAgICogQHBhcmFtIGFuZ2xlUmFkaWFuc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcm90YXRpb24oYW5nbGVSYWRpYW5zKSB7XHJcbiAgICAgICAgY29uc3QgbWF0ID0gTWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICAgICAgbWF0LmRhdGFbMF0gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xyXG4gICAgICAgIG1hdC5kYXRhWzRdID0gLU1hdGguc2luKGFuZ2xlUmFkaWFucyk7XHJcbiAgICAgICAgbWF0LmRhdGFbMV0gPSBNYXRoLnNpbihhbmdsZVJhZGlhbnMpO1xyXG4gICAgICAgIG1hdC5kYXRhWzVdID0gTWF0aC5jb3MoYW5nbGVSYWRpYW5zKTtcclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfVxyXG4gICAgbXVsdHYob3RoZXIpIHtcclxuICAgICAgICBjb25zdCB6ID0gMDtcclxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3Iob3RoZXIueCAqIHRoaXMuZGF0YVswXSArIG90aGVyLnkgKiB0aGlzLmRhdGFbNF0gKyB6ICogdGhpcy5kYXRhWzZdICsgMSAqIHRoaXMuZGF0YVsxMl0sIG90aGVyLnggKiB0aGlzLmRhdGFbMV0gKyBvdGhlci55ICogdGhpcy5kYXRhWzVdICsgeiAqIHRoaXMuZGF0YVs5XSArIDEgKiB0aGlzLmRhdGFbMTNdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlc3QgPSBbXHJcbiAgICAgICAgICAgICAgICBvdGhlclswXSAqIHRoaXMuZGF0YVswXSArIG90aGVyWzFdICogdGhpcy5kYXRhWzRdICsgeiAqIHRoaXMuZGF0YVs2XSArIDEgKiB0aGlzLmRhdGFbMTJdLFxyXG4gICAgICAgICAgICAgICAgb3RoZXJbMF0gKiB0aGlzLmRhdGFbMV0gKyBvdGhlclsxXSAqIHRoaXMuZGF0YVs1XSArIHogKiB0aGlzLmRhdGFbOV0gKyAxICogdGhpcy5kYXRhWzEzXVxyXG4gICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGxpZXMgdGhlIGN1cnJlbnQgbWF0cml4IGJ5IGFub3RoZXIgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBtYXRyaXhcclxuICAgICAqIEBwYXJhbSBvdGhlclxyXG4gICAgICovXHJcbiAgICBtdWx0bShvdGhlcikge1xyXG4gICAgICAgIGNvbnN0IGRlc3QgPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgY29uc3QgYTExID0gdGhpcy5kYXRhWzBdO1xyXG4gICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuZGF0YVsxXTtcclxuICAgICAgICBjb25zdCBhMzEgPSB0aGlzLmRhdGFbMl07XHJcbiAgICAgICAgY29uc3QgYTQxID0gdGhpcy5kYXRhWzNdO1xyXG4gICAgICAgIGNvbnN0IGExMiA9IHRoaXMuZGF0YVs0XTtcclxuICAgICAgICBjb25zdCBhMjIgPSB0aGlzLmRhdGFbNV07XHJcbiAgICAgICAgY29uc3QgYTMyID0gdGhpcy5kYXRhWzZdO1xyXG4gICAgICAgIGNvbnN0IGE0MiA9IHRoaXMuZGF0YVs3XTtcclxuICAgICAgICBjb25zdCBhMTMgPSB0aGlzLmRhdGFbOF07XHJcbiAgICAgICAgY29uc3QgYTIzID0gdGhpcy5kYXRhWzldO1xyXG4gICAgICAgIGNvbnN0IGEzMyA9IHRoaXMuZGF0YVsxMF07XHJcbiAgICAgICAgY29uc3QgYTQzID0gdGhpcy5kYXRhWzExXTtcclxuICAgICAgICBjb25zdCBhMTQgPSB0aGlzLmRhdGFbMTJdO1xyXG4gICAgICAgIGNvbnN0IGEyNCA9IHRoaXMuZGF0YVsxM107XHJcbiAgICAgICAgY29uc3QgYTM0ID0gdGhpcy5kYXRhWzE0XTtcclxuICAgICAgICBjb25zdCBhNDQgPSB0aGlzLmRhdGFbMTVdO1xyXG4gICAgICAgIGNvbnN0IGIxMSA9IG90aGVyLmRhdGFbMF07XHJcbiAgICAgICAgY29uc3QgYjIxID0gb3RoZXIuZGF0YVsxXTtcclxuICAgICAgICBjb25zdCBiMzEgPSBvdGhlci5kYXRhWzJdO1xyXG4gICAgICAgIGNvbnN0IGI0MSA9IG90aGVyLmRhdGFbM107XHJcbiAgICAgICAgY29uc3QgYjEyID0gb3RoZXIuZGF0YVs0XTtcclxuICAgICAgICBjb25zdCBiMjIgPSBvdGhlci5kYXRhWzVdO1xyXG4gICAgICAgIGNvbnN0IGIzMiA9IG90aGVyLmRhdGFbNl07XHJcbiAgICAgICAgY29uc3QgYjQyID0gb3RoZXIuZGF0YVs3XTtcclxuICAgICAgICBjb25zdCBiMTMgPSBvdGhlci5kYXRhWzhdO1xyXG4gICAgICAgIGNvbnN0IGIyMyA9IG90aGVyLmRhdGFbOV07XHJcbiAgICAgICAgY29uc3QgYjMzID0gb3RoZXIuZGF0YVsxMF07XHJcbiAgICAgICAgY29uc3QgYjQzID0gb3RoZXIuZGF0YVsxMV07XHJcbiAgICAgICAgY29uc3QgYjE0ID0gb3RoZXIuZGF0YVsxMl07XHJcbiAgICAgICAgY29uc3QgYjI0ID0gb3RoZXIuZGF0YVsxM107XHJcbiAgICAgICAgY29uc3QgYjM0ID0gb3RoZXIuZGF0YVsxNF07XHJcbiAgICAgICAgY29uc3QgYjQ0ID0gb3RoZXIuZGF0YVsxNV07XHJcbiAgICAgICAgZGVzdC5kYXRhWzBdID0gYTExICogYjExICsgYTEyICogYjIxICsgYTEzICogYjMxICsgYTE0ICogYjQxO1xyXG4gICAgICAgIGRlc3QuZGF0YVsxXSA9IGEyMSAqIGIxMSArIGEyMiAqIGIyMSArIGEyMyAqIGIzMSArIGEyNCAqIGI0MTtcclxuICAgICAgICBkZXN0LmRhdGFbMl0gPSBhMzEgKiBiMTEgKyBhMzIgKiBiMjEgKyBhMzMgKiBiMzEgKyBhMzQgKiBiNDE7XHJcbiAgICAgICAgZGVzdC5kYXRhWzNdID0gYTQxICogYjExICsgYTQyICogYjIxICsgYTQzICogYjMxICsgYTQ0ICogYjQxO1xyXG4gICAgICAgIGRlc3QuZGF0YVs0XSA9IGExMSAqIGIxMiArIGExMiAqIGIyMiArIGExMyAqIGIzMiArIGExNCAqIGI0MjtcclxuICAgICAgICBkZXN0LmRhdGFbNV0gPSBhMjEgKiBiMTIgKyBhMjIgKiBiMjIgKyBhMjMgKiBiMzIgKyBhMjQgKiBiNDI7XHJcbiAgICAgICAgZGVzdC5kYXRhWzZdID0gYTMxICogYjEyICsgYTMyICogYjIyICsgYTMzICogYjMyICsgYTM0ICogYjQyO1xyXG4gICAgICAgIGRlc3QuZGF0YVs3XSA9IGE0MSAqIGIxMiArIGE0MiAqIGIyMiArIGE0MyAqIGIzMiArIGE0NCAqIGI0MjtcclxuICAgICAgICBkZXN0LmRhdGFbOF0gPSBhMTEgKiBiMTMgKyBhMTIgKiBiMjMgKyBhMTMgKiBiMzMgKyBhMTQgKiBiNDM7XHJcbiAgICAgICAgZGVzdC5kYXRhWzldID0gYTIxICogYjEzICsgYTIyICogYjIzICsgYTIzICogYjMzICsgYTI0ICogYjQzO1xyXG4gICAgICAgIGRlc3QuZGF0YVsxMF0gPSBhMzEgKiBiMTMgKyBhMzIgKiBiMjMgKyBhMzMgKiBiMzMgKyBhMzQgKiBiNDM7XHJcbiAgICAgICAgZGVzdC5kYXRhWzExXSA9IGE0MSAqIGIxMyArIGE0MiAqIGIyMyArIGE0MyAqIGIzMyArIGE0NCAqIGI0MztcclxuICAgICAgICBkZXN0LmRhdGFbMTJdID0gYTExICogYjE0ICsgYTEyICogYjI0ICsgYTEzICogYjM0ICsgYTE0ICogYjQ0O1xyXG4gICAgICAgIGRlc3QuZGF0YVsxM10gPSBhMjEgKiBiMTQgKyBhMjIgKiBiMjQgKyBhMjMgKiBiMzQgKyBhMjQgKiBiNDQ7XHJcbiAgICAgICAgZGVzdC5kYXRhWzE0XSA9IGEzMSAqIGIxNCArIGEzMiAqIGIyNCArIGEzMyAqIGIzNCArIGEzNCAqIGI0NDtcclxuICAgICAgICBkZXN0LmRhdGFbMTVdID0gYTQxICogYjE0ICsgYTQyICogYjI0ICsgYTQzICogYjM0ICsgYTQ0ICogYjQ0O1xyXG4gICAgICAgIGNvbnN0IHMgPSB0aGlzLmdldFNjYWxlKCk7XHJcbiAgICAgICAgZGVzdC5fc2NhbGVTaWduWCA9IHNpZ24ocy54KSAqIHNpZ24oZGVzdC5fc2NhbGVTaWduWCk7XHJcbiAgICAgICAgZGVzdC5fc2NhbGVTaWduWSA9IHNpZ24ocy55KSAqIHNpZ24oZGVzdC5fc2NhbGVTaWduWSk7XHJcbiAgICAgICAgcmV0dXJuIGRlc3Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdHJhbnNsYXRpb24gdG8gdGhlIGN1cnJlbnQgbWF0cml4IG11dGF0aW5nIGl0XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgdHJhbnNsYXRlKHgsIHkpIHtcclxuICAgICAgICBjb25zdCBhMTEgPSB0aGlzLmRhdGFbMF07XHJcbiAgICAgICAgY29uc3QgYTIxID0gdGhpcy5kYXRhWzFdO1xyXG4gICAgICAgIGNvbnN0IGEzMSA9IHRoaXMuZGF0YVsyXTtcclxuICAgICAgICBjb25zdCBhNDEgPSB0aGlzLmRhdGFbM107XHJcbiAgICAgICAgY29uc3QgYTEyID0gdGhpcy5kYXRhWzRdO1xyXG4gICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuZGF0YVs1XTtcclxuICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmRhdGFbNl07XHJcbiAgICAgICAgY29uc3QgYTQyID0gdGhpcy5kYXRhWzddO1xyXG4gICAgICAgIGNvbnN0IGExMyA9IHRoaXMuZGF0YVs4XTtcclxuICAgICAgICBjb25zdCBhMjMgPSB0aGlzLmRhdGFbOV07XHJcbiAgICAgICAgY29uc3QgYTMzID0gdGhpcy5kYXRhWzEwXTtcclxuICAgICAgICBjb25zdCBhNDMgPSB0aGlzLmRhdGFbMTFdO1xyXG4gICAgICAgIGNvbnN0IGExNCA9IHRoaXMuZGF0YVsxMl07XHJcbiAgICAgICAgY29uc3QgYTI0ID0gdGhpcy5kYXRhWzEzXTtcclxuICAgICAgICBjb25zdCBhMzQgPSB0aGlzLmRhdGFbMTRdO1xyXG4gICAgICAgIGNvbnN0IGE0NCA9IHRoaXMuZGF0YVsxNV07XHJcbiAgICAgICAgLy8gRG9lc24ndCBjaGFuZ2UgelxyXG4gICAgICAgIGNvbnN0IHogPSAwO1xyXG4gICAgICAgIGNvbnN0IHcgPSAxO1xyXG4gICAgICAgIHRoaXMuZGF0YVsxMl0gPSBhMTEgKiB4ICsgYTEyICogeSArIGExMyAqIHogKyBhMTQgKiB3O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxM10gPSBhMjEgKiB4ICsgYTIyICogeSArIGEyMyAqIHogKyBhMjQgKiB3O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxNF0gPSBhMzEgKiB4ICsgYTMyICogeSArIGEzMyAqIHogKyBhMzQgKiB3O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxNV0gPSBhNDEgKiB4ICsgYTQyICogeSArIGE0MyAqIHogKyBhNDQgKiB3O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0UG9zaXRpb24oeCwgeSkge1xyXG4gICAgICAgIHRoaXMuZGF0YVsxMl0gPSB4O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxM10gPSB5O1xyXG4gICAgfVxyXG4gICAgZ2V0UG9zaXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHZlYyh0aGlzLmRhdGFbMTJdLCB0aGlzLmRhdGFbMTNdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyByb3RhdGlvbiB0byB0aGUgY3VycmVudCBtYXRyaXggbXV0YXRpbmcgaXRcclxuICAgICAqIEBwYXJhbSBhbmdsZSBpbiBSYWRpYW5zXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZShhbmdsZSkge1xyXG4gICAgICAgIGNvbnN0IGExMSA9IHRoaXMuZGF0YVswXTtcclxuICAgICAgICBjb25zdCBhMjEgPSB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgY29uc3QgYTMxID0gdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgIGNvbnN0IGE0MSA9IHRoaXMuZGF0YVszXTtcclxuICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmRhdGFbNF07XHJcbiAgICAgICAgY29uc3QgYTIyID0gdGhpcy5kYXRhWzVdO1xyXG4gICAgICAgIGNvbnN0IGEzMiA9IHRoaXMuZGF0YVs2XTtcclxuICAgICAgICBjb25zdCBhNDIgPSB0aGlzLmRhdGFbN107XHJcbiAgICAgICAgY29uc3Qgc2luZSA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICBjb25zdCBjb3NpbmUgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gY29zaW5lICogYTExICsgc2luZSAqIGExMjtcclxuICAgICAgICB0aGlzLmRhdGFbMV0gPSBjb3NpbmUgKiBhMjEgKyBzaW5lICogYTIyO1xyXG4gICAgICAgIHRoaXMuZGF0YVsyXSA9IGNvc2luZSAqIGEzMSArIHNpbmUgKiBhMzI7XHJcbiAgICAgICAgdGhpcy5kYXRhWzNdID0gY29zaW5lICogYTQxICsgc2luZSAqIGE0MjtcclxuICAgICAgICB0aGlzLmRhdGFbNF0gPSBjb3NpbmUgKiBhMTIgLSBzaW5lICogYTExO1xyXG4gICAgICAgIHRoaXMuZGF0YVs1XSA9IGNvc2luZSAqIGEyMiAtIHNpbmUgKiBhMjE7XHJcbiAgICAgICAgdGhpcy5kYXRhWzZdID0gY29zaW5lICogYTMyIC0gc2luZSAqIGEzMTtcclxuICAgICAgICB0aGlzLmRhdGFbN10gPSBjb3NpbmUgKiBhNDIgLSBzaW5lICogYTQxO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHNjYWxpbmcgdG8gdGhlIGN1cnJlbnQgbWF0cml4IG11dGF0aW5nIGl0XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgc2NhbGUoeCwgeSkge1xyXG4gICAgICAgIGNvbnN0IGExMSA9IHRoaXMuZGF0YVswXTtcclxuICAgICAgICBjb25zdCBhMjEgPSB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgY29uc3QgYTMxID0gdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgIGNvbnN0IGE0MSA9IHRoaXMuZGF0YVszXTtcclxuICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmRhdGFbNF07XHJcbiAgICAgICAgY29uc3QgYTIyID0gdGhpcy5kYXRhWzVdO1xyXG4gICAgICAgIGNvbnN0IGEzMiA9IHRoaXMuZGF0YVs2XTtcclxuICAgICAgICBjb25zdCBhNDIgPSB0aGlzLmRhdGFbN107XHJcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gYTExICogeDtcclxuICAgICAgICB0aGlzLmRhdGFbMV0gPSBhMjEgKiB4O1xyXG4gICAgICAgIHRoaXMuZGF0YVsyXSA9IGEzMSAqIHg7XHJcbiAgICAgICAgdGhpcy5kYXRhWzNdID0gYTQxICogeDtcclxuICAgICAgICB0aGlzLmRhdGFbNF0gPSBhMTIgKiB5O1xyXG4gICAgICAgIHRoaXMuZGF0YVs1XSA9IGEyMiAqIHk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzZdID0gYTMyICogeTtcclxuICAgICAgICB0aGlzLmRhdGFbN10gPSBhNDIgKiB5O1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2V0Um90YXRpb24oYW5nbGUpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50U2NhbGUgPSB0aGlzLmdldFNjYWxlKCk7XHJcbiAgICAgICAgY29uc3Qgc2luZSA9IE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICBjb25zdCBjb3NpbmUgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gY29zaW5lICogY3VycmVudFNjYWxlLng7XHJcbiAgICAgICAgdGhpcy5kYXRhWzFdID0gc2luZSAqIGN1cnJlbnRTY2FsZS55O1xyXG4gICAgICAgIHRoaXMuZGF0YVs0XSA9IC1zaW5lICogY3VycmVudFNjYWxlLng7XHJcbiAgICAgICAgdGhpcy5kYXRhWzVdID0gY29zaW5lICogY3VycmVudFNjYWxlLnk7XHJcbiAgICB9XHJcbiAgICBnZXRSb3RhdGlvbigpIHtcclxuICAgICAgICBjb25zdCBhbmdsZSA9IE1hdGguYXRhbjIodGhpcy5kYXRhWzFdIC8gdGhpcy5nZXRTY2FsZVkoKSwgdGhpcy5kYXRhWzBdIC8gdGhpcy5nZXRTY2FsZVgoKSk7XHJcbiAgICAgICAgcmV0dXJuIGNhbm9uaWNhbGl6ZUFuZ2xlKGFuZ2xlKTtcclxuICAgIH1cclxuICAgIGdldFNjYWxlWCgpIHtcclxuICAgICAgICAvLyBhYnNvbHV0ZSBzY2FsZSBvZiB0aGUgbWF0cml4ICh3ZSBsb3NlIHNpZ24gc28gbmVlZCB0byBhZGQgaXQgYmFjaylcclxuICAgICAgICBjb25zdCB4c2NhbGUgPSB2ZWModGhpcy5kYXRhWzBdLCB0aGlzLmRhdGFbNF0pLnNpemU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlU2lnblggKiB4c2NhbGU7XHJcbiAgICB9XHJcbiAgICBnZXRTY2FsZVkoKSB7XHJcbiAgICAgICAgLy8gYWJzb2x1dGUgc2NhbGUgb2YgdGhlIG1hdHJpeCAod2UgbG9zZSBzaWduIHNvIG5lZWQgdG8gYWRkIGl0IGJhY2spXHJcbiAgICAgICAgY29uc3QgeXNjYWxlID0gdmVjKHRoaXMuZGF0YVsxXSwgdGhpcy5kYXRhWzVdKS5zaXplO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZVNpZ25ZICogeXNjYWxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHNjYWxlIG9mIHRoZSBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgZ2V0U2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHZlYyh0aGlzLmdldFNjYWxlWCgpLCB0aGlzLmdldFNjYWxlWSgpKTtcclxuICAgIH1cclxuICAgIHNldFNjYWxlWCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9zY2FsZVNpZ25YID0gc2lnbih2YWwpO1xyXG4gICAgICAgIC8vIG5lZ2F0aXZlIHNjYWxlIGFjdHMgbGlrZSBhIDE4MCByb3RhdGlvbiwgc28gZmxpcFxyXG4gICAgICAgIGNvbnN0IHhzY2FsZSA9IHZlYyh0aGlzLmRhdGFbMF0gKiB0aGlzLl9zY2FsZVNpZ25YLCB0aGlzLmRhdGFbNF0gKiB0aGlzLl9zY2FsZVNpZ25YKS5ub3JtYWxpemUoKTtcclxuICAgICAgICB0aGlzLmRhdGFbMF0gPSB4c2NhbGUueCAqIHZhbDtcclxuICAgICAgICB0aGlzLmRhdGFbNF0gPSB4c2NhbGUueSAqIHZhbDtcclxuICAgIH1cclxuICAgIHNldFNjYWxlWSh2YWwpIHtcclxuICAgICAgICB0aGlzLl9zY2FsZVNpZ25ZID0gc2lnbih2YWwpO1xyXG4gICAgICAgIC8vIG5lZ2F0aXZlIHNjYWxlIGFjdHMgbGlrZSBhIDE4MCByb3RhdGlvbiwgc28gZmxpcFxyXG4gICAgICAgIGNvbnN0IHlzY2FsZSA9IHZlYyh0aGlzLmRhdGFbMV0gKiB0aGlzLl9zY2FsZVNpZ25ZLCB0aGlzLmRhdGFbNV0gKiB0aGlzLl9zY2FsZVNpZ25ZKS5ub3JtYWxpemUoKTtcclxuICAgICAgICB0aGlzLmRhdGFbMV0gPSB5c2NhbGUueCAqIHZhbDtcclxuICAgICAgICB0aGlzLmRhdGFbNV0gPSB5c2NhbGUueSAqIHZhbDtcclxuICAgIH1cclxuICAgIHNldFNjYWxlKHNjYWxlKSB7XHJcbiAgICAgICAgdGhpcy5zZXRTY2FsZVgoc2NhbGUueCk7XHJcbiAgICAgICAgdGhpcy5zZXRTY2FsZVkoc2NhbGUueSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERldGVybWluYW50IG9mIHRoZSB1cHBlciBsZWZ0IDJ4MiBtYXRyaXhcclxuICAgICAqL1xyXG4gICAgZ2V0QmFzaXNEZXRlcm1pbmFudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhWzBdICogdGhpcy5kYXRhWzVdIC0gdGhpcy5kYXRhWzFdICogdGhpcy5kYXRhWzRdO1xyXG4gICAgfVxyXG4gICAgZ2V0QWZmaW5lSW52ZXJzZSgpIHtcclxuICAgICAgICAvLyBTZWUgaHR0cDovL25lZ2F0aXZlcHJvYmFiaWxpdHkuYmxvZ3Nwb3QuY29tLzIwMTEvMTEvYWZmaW5lLXRyYW5zZm9ybWF0aW9ucy1hbmQtdGhlaXIuaHRtbFxyXG4gICAgICAgIC8vIFNlZSBodHRwczovL3d3dy5tYXRoc2lzZnVuLmNvbS9hbGdlYnJhL21hdHJpeC1pbnZlcnNlLmh0bWxcclxuICAgICAgICAvLyBTaW5jZSB3ZSBhcmUgYWN0dWFsbHkgb25seSBkb2luZyAyRCB0cmFuc2Zvcm1hdGlvbnMgd2UgY2FuIHVzZSB0aGlzIGhhY2tcclxuICAgICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSB1c2UgdGhlIDNyZCBvciA0dGggZGltZW5zaW9uXHJcbiAgICAgICAgY29uc3QgZGV0ID0gdGhpcy5nZXRCYXNpc0RldGVybWluYW50KCk7XHJcbiAgICAgICAgY29uc3QgaW52ZXJzZURldCA9IDEgLyBkZXQ7IC8vIHRvZG8gemVybyBjaGVja1xyXG4gICAgICAgIGNvbnN0IGEgPSB0aGlzLmRhdGFbMF07XHJcbiAgICAgICAgY29uc3QgYiA9IHRoaXMuZGF0YVs0XTtcclxuICAgICAgICBjb25zdCBjID0gdGhpcy5kYXRhWzFdO1xyXG4gICAgICAgIGNvbnN0IGQgPSB0aGlzLmRhdGFbNV07XHJcbiAgICAgICAgY29uc3QgbSA9IE1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgICAgIC8vIGludmVydHMgcm90YXRpb24gYW5kIHNjYWxlXHJcbiAgICAgICAgbS5kYXRhWzBdID0gZCAqIGludmVyc2VEZXQ7XHJcbiAgICAgICAgbS5kYXRhWzFdID0gLWMgKiBpbnZlcnNlRGV0O1xyXG4gICAgICAgIG0uZGF0YVs0XSA9IC1iICogaW52ZXJzZURldDtcclxuICAgICAgICBtLmRhdGFbNV0gPSBhICogaW52ZXJzZURldDtcclxuICAgICAgICBjb25zdCB0eCA9IHRoaXMuZGF0YVsxMl07XHJcbiAgICAgICAgY29uc3QgdHkgPSB0aGlzLmRhdGFbMTNdO1xyXG4gICAgICAgIC8vIGludmVydCB0cmFuc2xhdGlvblxyXG4gICAgICAgIC8vIHRyYW5zZm9ybSB0cmFuc2xhdGlvbiBpbnRvIHRoZSBtYXRyaXggYmFzaXMgY3JlYXRlZCBieSByb3Qvc2NhbGVcclxuICAgICAgICBtLmRhdGFbMTJdID0gLSh0eCAqIG0uZGF0YVswXSArIHR5ICogbS5kYXRhWzRdKTtcclxuICAgICAgICBtLmRhdGFbMTNdID0gLSh0eCAqIG0uZGF0YVsxXSArIHR5ICogbS5kYXRhWzVdKTtcclxuICAgICAgICByZXR1cm4gbTtcclxuICAgIH1cclxuICAgIGlzSWRlbnRpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmRhdGFbMF0gPT09IDEgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzFdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVsyXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbM10gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzRdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVs1XSA9PT0gMSAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbNl0gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzddID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVs4XSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbOV0gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzEwXSA9PT0gMSAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbMTFdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVsxMl0gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzEzXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbMTRdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVsxNV0gPT09IDEpO1xyXG4gICAgfVxyXG4gICAgdG9TdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGBcblske3RoaXMuZGF0YVswXX0gJHt0aGlzLmRhdGFbNF19ICR7dGhpcy5kYXRhWzhdfSAke3RoaXMuZGF0YVsxMl19XVxuWyR7dGhpcy5kYXRhWzFdfSAke3RoaXMuZGF0YVs1XX0gJHt0aGlzLmRhdGFbOV19ICR7dGhpcy5kYXRhWzEzXX1dXG5bJHt0aGlzLmRhdGFbMl19ICR7dGhpcy5kYXRhWzZdfSAke3RoaXMuZGF0YVsxMF19ICR7dGhpcy5kYXRhWzE0XX1dXG5bJHt0aGlzLmRhdGFbM119ICR7dGhpcy5kYXRhWzddfSAke3RoaXMuZGF0YVsxMV19ICR7dGhpcy5kYXRhWzE1XX1dXG5gO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC90cmFuc2Zvcm0tc3RhY2sudHNcblxyXG5jbGFzcyBUcmFuc2Zvcm1TdGFjayB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1zID0gW107XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IE1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgfVxyXG4gICAgc2F2ZSgpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1zLnB1c2godGhpcy5fY3VycmVudFRyYW5zZm9ybSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0uY2xvbmUoKTtcclxuICAgIH1cclxuICAgIHJlc3RvcmUoKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFRyYW5zZm9ybSA9IHRoaXMuX3RyYW5zZm9ybXMucG9wKCk7XHJcbiAgICB9XHJcbiAgICB0cmFuc2xhdGUoeCwgeSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgIH1cclxuICAgIHJvdGF0ZShhbmdsZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50VHJhbnNmb3JtLnJvdGF0ZShhbmdsZSk7XHJcbiAgICB9XHJcbiAgICBzY2FsZSh4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0uc2NhbGUoeCwgeSk7XHJcbiAgICB9XHJcbiAgICBzZXQgY3VycmVudChtYXRyaXgpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgZ2V0IGN1cnJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm07XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3N0YXRlLXN0YWNrLnRzXG5jbGFzcyBTdGF0ZVN0YWNrIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRoaXMuX2dldERlZmF1bHRTdGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgX2dldERlZmF1bHRTdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBvcGFjaXR5OiAxXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIF9jbG9uZVN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMuX2N1cnJlbnRTdGF0ZS5vcGFjaXR5XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHNhdmUoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhdGVzLnB1c2godGhpcy5fY3VycmVudFN0YXRlKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUgPSB0aGlzLl9jbG9uZVN0YXRlKCk7XHJcbiAgICB9XHJcbiAgICByZXN0b3JlKCkge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRoaXMuX3N0YXRlcy5wb3AoKTtcclxuICAgIH1cclxuICAgIGdldCBjdXJyZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3NoYWRlci50c1xuLyoqXHJcbiAqIENyZWF0ZSBhIHNoYWRlciBwcm9ncmFtIGZvciB0aGUgRXhjYWxpYnVyIFdlYkdMIEdyYXBoaWNzIENvbnRleHRcclxuICovXHJcbmNsYXNzIFNoYWRlciB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIHNoYWRlciBwcm9ncmFtIGluIGV4Y2FsaWJ1clxyXG4gICAgICogQHBhcmFtIF9nbCBXZWJHTCBncmFwaGljcyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gX3ZlcnRleFNvdXJjZSBWZXJ0ZXggc2hhZGVyIHNvdXJjZSBhcyBhIHN0cmluZ1xyXG4gICAgICogQHBhcmFtIF9mcmFnbWVudFNvdXJjZSBGcmFnbWVudCBzaGFkZXIgc291cmNlIGFzIGEgc3RyaW5nXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKF9nbCwgX3ZlcnRleFNvdXJjZSwgX2ZyYWdtZW50U291cmNlKSB7XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBfZ2w7XHJcbiAgICAgICAgdGhpcy5fdmVydGV4U291cmNlID0gX3ZlcnRleFNvdXJjZTtcclxuICAgICAgICB0aGlzLl9mcmFnbWVudFNvdXJjZSA9IF9mcmFnbWVudFNvdXJjZTtcclxuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXMgPSB7fTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXMgPSB7fTtcclxuICAgICAgICB0aGlzLmxheW91dCA9IFtdO1xyXG4gICAgICAgIHRoaXMuY29tcGlsZShfZ2wpO1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpIHtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIGlmIChwcm9ncmFtID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDb3VsZCBub3QgY3JlYXRlIGdyYXBoaWNzIHNoYWRlciBwcm9ncmFtJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGF0dGFjaCB0aGUgc2hhZGVycy5cclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdmVydGV4U2hhZGVyKTtcclxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICAgIC8vIGxpbmsgdGhlIHByb2dyYW0uXHJcbiAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xyXG4gICAgICAgIGlmICghc3VjY2Vzcykge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90IGxpbmsgdGhlIHByb2dyYW06IFske2dsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pfV1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHByb2dyYW07XHJcbiAgICB9XHJcbiAgICBfY29tcGlsZVNoYWRlcihnbCwgc291cmNlLCB0eXBlKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKHR5cGUpO1xyXG4gICAgICAgIGlmIChzaGFkZXIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvdWxkIG5vdCBidWlsZCBzaGFkZXI6IFske3NvdXJjZX1dYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XHJcbiAgICAgICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xyXG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyk7XHJcbiAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb3VsZCBub3QgY29tcGlsZSBzaGFkZXIgWyR7Z2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpfV1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tcGlsZSB0aGUgY3VycmVudCBzaGFkZXIgYWdhaW5zdCBhIHdlYmdsIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBnbCBXZWJHTCBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIGNvbXBpbGUoZ2wpIHtcclxuICAgICAgICBjb25zdCB2ZXJ0ZXhTaGFkZXIgPSB0aGlzLl9jb21waWxlU2hhZGVyKGdsLCB0aGlzLl92ZXJ0ZXhTb3VyY2UsIGdsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5fY29tcGlsZVNoYWRlcihnbCwgdGhpcy5fZnJhZ21lbnRTb3VyY2UsIGdsLkZSQUdNRU5UX1NIQURFUik7XHJcbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMuX2NyZWF0ZVByb2dyYW0oZ2wsIHZlcnRleFNoYWRlciwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgICAgIHJldHVybiAodGhpcy5wcm9ncmFtID0gcHJvZ3JhbSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHVuaWZvcm0gW1tNYXRyaXhdXSB0byB0aGUgc2hhZGVyXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtIGluIHRoZSBzaGFkZXIgc291cmNlXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAoNHg0KSBtYXRyaXggaW4gY29sdW1uIG1ham9yIG9yZGVyXHJcbiAgICAgKi9cclxuICAgIGFkZFVuaWZvcm1NYXRyaXgobmFtZSwgZGF0YSkge1xyXG4gICAgICAgIGlmICghZGF0YSkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgU2hhZGVyIFVuaWZvcm0gTWF0cml4ICcke25hbWV9JyB3YXMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtc1tuYW1lXSA9IHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgdHlwZTogJ21hdHJpeCcsXHJcbiAgICAgICAgICAgIGxvY2F0aW9uOiBnbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKSxcclxuICAgICAgICAgICAgZGF0YTogZGF0YVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHVuaWZvcm0gYXJyYXkgb2YgbnVtYmVycyB0byB0aGUgc2hhZGVyXHJcbiAgICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB1bmlmb3JtIGluIHRoZSBzaGFkZXIgc291cmNlXHJcbiAgICAgKiBAcGFyYW0gZGF0YSBMaXN0IG9mIG51bWJlcnNcclxuICAgICAqL1xyXG4gICAgYWRkVW5pZm9ybUludGVnZXJBcnJheShuYW1lLCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBTaGFkZXIgVW5pZm9ybSBJbnRlZ2VyeSBBcnJheSAnJHtuYW1lfScgd2FzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZGApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX2dsO1xyXG4gICAgICAgIHRoaXMudW5pZm9ybXNbbmFtZV0gPSB7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIHR5cGU6ICdudW1iZXJzJyxcclxuICAgICAgICAgICAgbG9jYXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGF0dHJpYnV0ZXMgaW4gdGhlIG9yZGVyIHRoZXkgYXBwZWFyIGluIHRoZSBWQk9cclxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZSBpbiB0aGUgc2hhZGVyIHNvdXJjZVxyXG4gICAgICogQHBhcmFtIHNpemUgVGhlIHNpemUgb2YgdGhlIGF0dHJpYnV0ZSBpbiBnbC5UeXBlIHVuaXRzLCBmb3IgZXhhbXBsZSBgdmVjMiBhX3Bvc2Agd291bGQgYmUgMiBnbC5GTE9BVFxyXG4gICAgICogQHBhcmFtIGdsVHlwZSBUaGUgZ2wuVHlwZSBvZiB0aGUgYXR0cmlidXRlXHJcbiAgICAgKi9cclxuICAgIGFkZEF0dHJpYnV0ZShuYW1lLCBzaXplLCBnbFR5cGUsIG5vcm1hbGl6ZWQgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgLy8gVE9ETyBuZWVkcyB0byBiZSBjb21waWxlZCBmaXJzdFxyXG4gICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24odGhpcy5wcm9ncmFtLCBuYW1lKTtcclxuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbbmFtZV0gPSB7XHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgIHNpemUsXHJcbiAgICAgICAgICAgIGdsVHlwZSxcclxuICAgICAgICAgICAgbm9ybWFsaXplZCxcclxuICAgICAgICAgICAgbG9jYXRpb25cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMubGF5b3V0LnB1c2godGhpcy5hdHRyaWJ1dGVzW25hbWVdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTnVtYmVyIG9mIGphdmFzY3JpcHQgZmxvYXRzIGEgdmVydGV4IHdpbGwgdGFrZSB1cFxyXG4gICAgICovXHJcbiAgICBnZXQgdmVydGV4QXR0cmlidXRlU2l6ZSgpIHtcclxuICAgICAgICBsZXQgdmVydGV4U2l6ZSA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCB2ZXJ0IG9mIHRoaXMubGF5b3V0KSB7XHJcbiAgICAgICAgICAgIHZlcnRleFNpemUgKz0gdmVydC5zaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmVydGV4U2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRoYXQgdGhlIHZlcnRleCB3aWxsIHRha2UgdXBcclxuICAgICAqL1xyXG4gICAgZ2V0IHRvdGFsVmVydGV4U2l6ZUJ5dGVzKCkge1xyXG4gICAgICAgIGxldCB2ZXJ0ZXhTaXplID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IHZlcnQgb2YgdGhpcy5sYXlvdXQpIHtcclxuICAgICAgICAgICAgbGV0IHR5cGVTaXplID0gMTtcclxuICAgICAgICAgICAgc3dpdGNoICh2ZXJ0LmdsVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSB0aGlzLl9nbC5GTE9BVDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVTaXplID0gNDtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlU2l6ZSA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdmVydGV4U2l6ZSArPSB0eXBlU2l6ZSAqIHZlcnQuc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZlcnRleFNpemU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIHByZXZpb3VzbHkgZGVmaW5lZCBhdHRyaWJ1dGUgc2l6ZSBpbiBieXRlc1xyXG4gICAgICogQHBhcmFtIG5hbWVcclxuICAgICAqL1xyXG4gICAgZ2V0QXR0cmlidXRlU2l6ZShuYW1lKSB7XHJcbiAgICAgICAgbGV0IHR5cGVTaXplID0gMTtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuYXR0cmlidXRlc1tuYW1lXS5nbFR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSB0aGlzLl9nbC5GTE9BVDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZVNpemUgPSA0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgdHlwZVNpemUgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0eXBlU2l6ZSAqIHRoaXMuYXR0cmlidXRlc1tuYW1lXS5zaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoaXMgc2hhZGVyIHByb2dyYW0gYXMgdGhlIGN1cnJlbnQgaW4gdGhlIHVuZGVybHlpbmcgd2ViZ2wgY29udGV4dFxyXG4gICAgICpcclxuICAgICAqICoqTXVzdCoqIHNwZWNpZnkgYWxsIGF0dHJpYnV0ZXMgYW5kIHVuaWZvcm1zIGJlZm9yZSBjYWxsaW5nIHRoaXNcclxuICAgICAqL1xyXG4gICAgdXNlKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW0pO1xyXG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgdmVydCBvZiB0aGlzLmxheW91dCkge1xyXG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHZlcnQubG9jYXRpb24sIHZlcnQuc2l6ZSwgdmVydC5nbFR5cGUsIHZlcnQubm9ybWFsaXplZCwgdGhpcy50b3RhbFZlcnRleFNpemVCeXRlcywgb2Zmc2V0KTtcclxuICAgICAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodmVydC5sb2NhdGlvbik7XHJcbiAgICAgICAgICAgIG9mZnNldCArPSB0aGlzLmdldEF0dHJpYnV0ZVNpemUodmVydC5uYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy51bmlmb3Jtcykge1xyXG4gICAgICAgICAgICBjb25zdCB1bmlmb3JtID0gdGhpcy51bmlmb3Jtc1trZXldO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHVuaWZvcm0udHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbWF0cml4Jzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYodW5pZm9ybS5sb2NhdGlvbiwgZmFsc2UsIHVuaWZvcm0uZGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXNlICdudW1iZXJzJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xaXYodW5pZm9ybS5sb2NhdGlvbiwgdW5pZm9ybS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvc2hhZGVycy9saW5lLXZlcnRleC5nbHNsXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGxpbmVfdmVydGV4ID0gKFwiYXR0cmlidXRlIHZlYzQgYV9wb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcclxcblxcclxcbnZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcclxcblxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG4gICAvLyBTZXQgdGhlIHZlcnRleCBwb3NpdGlvbiB1c2luZyB0aGUgb3J0aG8gdHJhbnNmb3JtIG1hdHJpeFxcclxcbiAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiBhX3Bvc2l0aW9uO1xcclxcblxcclxcbiAgIC8vIFBhc3N0aHJvdWdoIHRoZSBjb2xvclxcclxcbiAgIHZfY29sb3IgPSBhX2NvbG9yO1xcclxcbn1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3NoYWRlcnMvbGluZS1mcmFnbWVudC5nbHNsXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGxpbmVfZnJhZ21lbnQgPSAoXCJwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXHJcXG5cXHJcXG4vLyBDb2xvclxcclxcbnZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxyXFxuXFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcXHJcXG59XCIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9iYXRjaC50c1xuY2xhc3MgQmF0Y2hDb21tYW5kIHtcclxuICAgIGNvbnN0cnVjdG9yKG1heCkge1xyXG4gICAgICAgIHRoaXMubWF4ID0gbWF4O1xyXG4gICAgICAgIHRoaXMuX3Bvb2wgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgaXNGdWxsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbW1hbmRzLmxlbmd0aCA+PSB0aGlzLm1heCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY2FuQWRkKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5pc0Z1bGwoKTtcclxuICAgIH1cclxuICAgIGFkZChjbWQpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goY21kKTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvR3JhcGhpY3NEaWFnbm9zdGljcy50c1xuY2xhc3MgR3JhcGhpY3NEaWFnbm9zdGljcyB7XHJcbiAgICBzdGF0aWMgY2xlYXIoKSB7XHJcbiAgICAgICAgR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3Q2FsbENvdW50ID0gMDtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXduSW1hZ2VzQ291bnQgPSAwO1xyXG4gICAgfVxyXG59XHJcbkdyYXBoaWNzRGlhZ25vc3RpY3MuRHJhd0NhbGxDb3VudCA9IDA7XHJcbkdyYXBoaWNzRGlhZ25vc3RpY3MuRHJhd25JbWFnZXNDb3VudCA9IDA7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9Qb29sLnRzXG5cclxuY2xhc3MgUG9vbCB7XHJcbiAgICBjb25zdHJ1Y3RvcihidWlsZGVyLCByZWN5Y2xlciwgbWF4T2JqZWN0cyA9IDEwMCkge1xyXG4gICAgICAgIHRoaXMuYnVpbGRlciA9IGJ1aWxkZXI7XHJcbiAgICAgICAgdGhpcy5yZWN5Y2xlciA9IHJlY3ljbGVyO1xyXG4gICAgICAgIHRoaXMubWF4T2JqZWN0cyA9IG1heE9iamVjdHM7XHJcbiAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRpb25zID0gMDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLm9iamVjdHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlIG1hbnkgaW5zdGFuY2VzIG91dCBvZiB0aGUgaW4gdGhlIGNvbnRleHQgYW5kIHJldHVybiBhbGwgdG8gdGhlIHBvb2wuXHJcbiAgICAgKlxyXG4gICAgICogQnkgcmV0dXJuaW5nIHZhbHVlcyBvdXQgb2YgdGhlIGNvbnRleCB0aGV5IHdpbGwgYmUgdW4taG9va2VkIGZyb20gdGhlIHBvb2wgYW5kIGFyZSBmcmVlIHRvIGJlIHBhc3NlZCB0byBjb25zdW1lcnNcclxuICAgICAqIEBwYXJhbSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIHVzaW5nKGNvbnRleHQpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBjb250ZXh0KHRoaXMpO1xyXG4gICAgICAgIGlmIChyZXN1bHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9uZSguLi5yZXN1bHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5kb25lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZSBhIHNpbmdsZSBpbnN0YW5jZSBvdXQgb2YgdGggcG9vbCBhbmQgaW1tZWRpYXRlbHkgcmV0dXJuIGl0IHRvIHRoZSBwb29sXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dFxyXG4gICAgICovXHJcbiAgICBib3Jyb3coY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IG9iamVjdCA9IHRoaXMuZ2V0KCk7XHJcbiAgICAgICAgY29udGV4dChvYmplY3QpO1xyXG4gICAgICAgIHRoaXMuaW5kZXgtLTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgYSB2YWx1ZSBmcm9tIHRoZSBwb29sLCB3aWxsIGFsbG9jYXRlIGEgbmV3IGluc3RhbmNlIGlmIG5lY2Vzc2FyeSBvciByZWN5Y2xlIGZyb20gdGhlIHBvb2xcclxuICAgICAqIEBwYXJhbSBhcmdzXHJcbiAgICAgKi9cclxuICAgIGdldCguLi5hcmdzKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT09IHRoaXMubWF4T2JqZWN0cykge1xyXG4gICAgICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBoYXJkIG9yIHNvZnQgY2FwXHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdNYXggcG9vbGVkIG9iamVjdHMgcmVhY2hlZCwgcG9zc2libGUgbWVtb3J5IGxlYWs/IERvdWJsaW5nJyk7XHJcbiAgICAgICAgICAgIHRoaXMubWF4T2JqZWN0cyA9IHRoaXMubWF4T2JqZWN0cyAqIDI7XHJcbiAgICAgICAgICAgIC8vIHRocm93IG5ldyBFcnJvcignTWF4IHBvb2xlZCBvYmplY3RzIHJlYWNoZWQsIHBvc3NpYmxlIG1lbW9yeSBsZWFrPycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5vYmplY3RzW3RoaXMuaW5kZXhdKSB7XHJcbiAgICAgICAgICAgIC8vIFBvb2wgaGFzIGFuIGF2YWlsYWJsZSBvYmplY3QgYWxyZWFkeSBjb25zdHJ1Y3RlZFxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWN5Y2xlcih0aGlzLm9iamVjdHNbdGhpcy5pbmRleCsrXSwgLi4uYXJncyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBOZXcgYWxsb2NhdGlvblxyXG4gICAgICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGlvbnMrKztcclxuICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gKHRoaXMub2JqZWN0c1t0aGlzLmluZGV4KytdID0gdGhpcy5idWlsZGVyKC4uLmFyZ3MpKTtcclxuICAgICAgICAgICAgb2JqZWN0Ll9wb29sID0gdGhpcztcclxuICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkb25lKC4uLm9iamVjdHMpIHtcclxuICAgICAgICAvLyBBbGwgb2JqZWN0cyBpbiBwb29sIG5vdyBjb25zaWRlcmVkIFwiZnJlZVwiXHJcbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBvYmplY3Qgb2Ygb2JqZWN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBwb29sSW5kZXggPSB0aGlzLm9iamVjdHMuaW5kZXhPZihvYmplY3QpO1xyXG4gICAgICAgICAgICAvLyBCdWlsZCBhIG5ldyBvYmplY3QgdG8gdGFrZSB0aGUgcG9vbCBwbGFjZVxyXG4gICAgICAgICAgICB0aGlzLm9iamVjdHNbcG9vbEluZGV4XSA9IHRoaXMuYnVpbGRlcigpOyAvLyBUT0RPIHByb2JsZW1hdGljIDAtYXJnIG9ubHkgc3VwcG9ydFxyXG4gICAgICAgICAgICB0aGlzLm9iamVjdHNbcG9vbEluZGV4XS5fcG9vbCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMudG90YWxBbGxvY2F0aW9ucysrO1xyXG4gICAgICAgICAgICAvLyBVbmhvb2sgb2JqZWN0IGZyb20gdGhlIHBvb2xcclxuICAgICAgICAgICAgb2JqZWN0Ll9wb29sID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gb2JqZWN0cztcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvcmVuZGVyZXIudHNcblxyXG4vLyBpbXBvcnQgeyBQb29sLCBQb29sYWJsZSB9IGZyb20gJy4vcG9vbCc7XHJcblxyXG5cclxuY2xhc3MgQmF0Y2hSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IDA7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9tYXhDb21tYW5kc1BlckJhdGNoID0gMjAwMDtcclxuICAgICAgICB0aGlzLl9iYXRjaGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fZ2wgPSBvcHRpb25zLmdsO1xyXG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSBvcHRpb25zLmNvbW1hbmQ7XHJcbiAgICAgICAgdGhpcy5fdmVydGljZXNQZXJDb21tYW5kID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZlcnRpY2VzUGVyQ29tbWFuZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcclxuICAgICAgICB0aGlzLl9tYXhDb21tYW5kc1BlckJhdGNoID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1heENvbW1hbmRzUGVyQmF0Y2gpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuX21heENvbW1hbmRzUGVyQmF0Y2g7XHJcbiAgICAgICAgY29uc3QgYmF0Y2hGYWN0b3J5ID0gKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmJhdGNoRmFjdG9yeSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKCgpID0+IG5ldyBCYXRjaENvbW1hbmQodGhpcy5fbWF4Q29tbWFuZHNQZXJCYXRjaCkpO1xyXG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBuZXcgUG9vbCgoKSA9PiBuZXcgY29tbWFuZCgpLCAoYykgPT4gYy5kaXNwb3NlKCksIHRoaXMuX21heENvbW1hbmRzUGVyQmF0Y2gpO1xyXG4gICAgICAgIHRoaXMuX2JhdGNoUG9vbCA9IG5ldyBQb29sKGJhdGNoRmFjdG9yeSwgKGIpID0+IGIuZGlzcG9zZSgpLCAxMDApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplIHJlbmRlciwgYnVpbGRzIHNoYWRlciBhbmQgaW5pdGlhbGl6ZWQgd2ViZ2wgYnVmZmVyc1xyXG4gICAgICovXHJcbiAgICBpbml0KCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIgPSB0aGlzLmJ1aWxkU2hhZGVyKGdsKTtcclxuICAgICAgICAvLyBJbml0aWFsaXplIFZCT1xyXG4gICAgICAgIC8vIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZm9ydW0vIyF0b3BpYy93ZWJnbC1kZXYtbGlzdC92TU5YU05SQWc4TVxyXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLnNoYWRlci52ZXJ0ZXhBdHRyaWJ1dGVTaXplICogdGhpcy5fdmVydGljZXNQZXJDb21tYW5kICogdGhpcy5fbWF4Q29tbWFuZHNQZXJCYXRjaCk7XHJcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX2J1ZmZlcik7XHJcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX3ZlcnRpY2VzLCBnbC5EWU5BTUlDX0RSQVcpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZlcnRleFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhZGVyLnZlcnRleEF0dHJpYnV0ZVNpemU7XHJcbiAgICB9XHJcbiAgICBhZGRDb21tYW5kKGNtZCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9iYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9iYXRjaGVzLnB1c2godGhpcy5fYmF0Y2hQb29sLmdldCgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGFzdEJhdGNoID0gdGhpcy5fYmF0Y2hlc1t0aGlzLl9iYXRjaGVzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgIGlmIChsYXN0QmF0Y2guY2FuQWRkKCkpIHtcclxuICAgICAgICAgICAgbGFzdEJhdGNoLmFkZChjbWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3QmF0Y2ggPSB0aGlzLl9iYXRjaFBvb2wuZ2V0KCk7XHJcbiAgICAgICAgICAgIG5ld0JhdGNoLmFkZChjbWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9iYXRjaGVzLnB1c2gobmV3QmF0Y2gpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgYmF0Y2ggZ2VvbWV0cnksIHN1Ym1pdCB0byB0aGUgZ3B1LCBhbmQgaXNzdWUgZHJhdyBjb21tYW5kIHRvIHVuZGVybHlpbmcgd2ViZ2xcclxuICAgICAqL1xyXG4gICAgcmVuZGVyKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRoaXMuX2J1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5zaGFkZXIudXNlKCk7XHJcbiAgICAgICAgbGV0IGRyYXdDYWxsQ291bnQgPSAwO1xyXG4gICAgICAgIGxldCBkcmF3bkltYWdlc0NvdW50ID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IGJhdGNoIG9mIHRoaXMuX2JhdGNoZXMpIHtcclxuICAgICAgICAgICAgLy8gQnVpbGQgYWxsIGdlb21ldHJ5IGFuZCBzaGlwIHRvIEdQVVxyXG4gICAgICAgICAgICAvLyBpbnRlcmxlYXZlIFZCT3MgaHR0cHM6Ly9nb2hhcnNoYS5jb20vbHdqZ2wtdHV0b3JpYWwtc2VyaWVzL2ludGVybGVhdmluZy1idWZmZXItb2JqZWN0cy9cclxuICAgICAgICAgICAgY29uc3QgdmVydGV4Q291bnQgPSB0aGlzLmJ1aWxkQmF0Y2hWZXJ0aWNlcyh0aGlzLl92ZXJ0aWNlcywgYmF0Y2gpO1xyXG4gICAgICAgICAgICBnbC5idWZmZXJTdWJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgMCwgdGhpcy5fdmVydGljZXMpO1xyXG4gICAgICAgICAgICB0aGlzLnJlbmRlckJhdGNoKGdsLCBiYXRjaCwgdmVydGV4Q291bnQpO1xyXG4gICAgICAgICAgICBkcmF3bkltYWdlc0NvdW50ICs9IGJhdGNoLmNvbW1hbmRzLmxlbmd0aDtcclxuICAgICAgICAgICAgZHJhd0NhbGxDb3VudCsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbW1hbmRzLmRvbmUoKTtcclxuICAgICAgICB0aGlzLl9iYXRjaFBvb2wuZG9uZSgpO1xyXG4gICAgICAgIHRoaXMuX2JhdGNoZXMubGVuZ3RoID0gMDtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXdDYWxsQ291bnQgKz0gZHJhd0NhbGxDb3VudDtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXduSW1hZ2VzQ291bnQgKz0gZHJhd25JbWFnZXNDb3VudDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvbGluZS1yZW5kZXJlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgRHJhd0xpbmUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbG9yLkJsYWNrO1xyXG4gICAgICAgIHRoaXMuc3RhcnQgPSBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLmVuZCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmNvbG9yLnIgPSAwO1xyXG4gICAgICAgIHRoaXMuY29sb3IuZyA9IDA7XHJcbiAgICAgICAgdGhpcy5jb2xvci5iID0gMDtcclxuICAgICAgICB0aGlzLmNvbG9yLmEgPSAxO1xyXG4gICAgICAgIHRoaXMuc3RhcnQuc2V0VG8oMCwgMCk7XHJcbiAgICAgICAgdGhpcy5lbmQuc2V0VG8oMCwgMCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgTGluZVJlbmRlcmVyIGV4dGVuZHMgQmF0Y2hSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgX2NvbnRleHRJbmZvKSB7XHJcbiAgICAgICAgc3VwZXIoeyBnbCwgY29tbWFuZDogRHJhd0xpbmUsIHZlcnRpY2VzUGVyQ29tbWFuZDogMiB9KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0SW5mbyA9IF9jb250ZXh0SW5mbztcclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH1cclxuICAgIGJ1aWxkU2hhZGVyKGdsKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcihnbCwgbGluZV92ZXJ0ZXgsIGxpbmVfZnJhZ21lbnQpO1xyXG4gICAgICAgIHNoYWRlci5hZGRBdHRyaWJ1dGUoJ2FfcG9zaXRpb24nLCAyLCBnbC5GTE9BVCk7XHJcbiAgICAgICAgc2hhZGVyLmFkZEF0dHJpYnV0ZSgnYV9jb2xvcicsIDQsIGdsLkZMT0FUKTtcclxuICAgICAgICBzaGFkZXIuYWRkVW5pZm9ybU1hdHJpeCgndV9tYXRyaXgnLCB0aGlzLl9jb250ZXh0SW5mby5tYXRyaXguZGF0YSk7XHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgIH1cclxuICAgIGFkZExpbmUoc3RhcnQsIGVuZCwgY29sb3IpIHtcclxuICAgICAgICBjb25zdCBjbWQgPSB0aGlzLmNvbW1hbmRzLmdldCgpO1xyXG4gICAgICAgIGNtZC5zdGFydCA9IHRoaXMuX2NvbnRleHRJbmZvLnRyYW5zZm9ybS5jdXJyZW50Lm11bHR2KHN0YXJ0KTtcclxuICAgICAgICBjbWQuZW5kID0gdGhpcy5fY29udGV4dEluZm8udHJhbnNmb3JtLmN1cnJlbnQubXVsdHYoZW5kKTtcclxuICAgICAgICBjbWQuY29sb3IuciA9IGNvbG9yLnI7XHJcbiAgICAgICAgY21kLmNvbG9yLmcgPSBjb2xvci5nO1xyXG4gICAgICAgIGNtZC5jb2xvci5iID0gY29sb3IuYjtcclxuICAgICAgICBjbWQuY29sb3IuYSA9IGNtZC5jb2xvci5hICogdGhpcy5fY29udGV4dEluZm8uc3RhdGUuY3VycmVudC5vcGFjaXR5O1xyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZChjbWQpO1xyXG4gICAgfVxyXG4gICAgYnVpbGRCYXRjaFZlcnRpY2VzKHZlcnRleEJ1ZmZlciwgYmF0Y2gpIHtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBiYXRjaC5jb21tYW5kcykge1xyXG4gICAgICAgICAgICAvLyBTdGFydFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLnN0YXJ0Lng7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcltpbmRleCsrXSA9IGNvbW1hbmQuc3RhcnQueTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5jb2xvci5yIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLmNvbG9yLmcgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcltpbmRleCsrXSA9IGNvbW1hbmQuY29sb3IuYiAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5jb2xvci5hO1xyXG4gICAgICAgICAgICAvLyBFbmRcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5lbmQueDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5lbmQueTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5jb2xvci5yIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLmNvbG9yLmcgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcltpbmRleCsrXSA9IGNvbW1hbmQuY29sb3IuYiAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5jb2xvci5hO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5kZXggLyB0aGlzLnZlcnRleFNpemU7XHJcbiAgICB9XHJcbiAgICByZW5kZXJCYXRjaChnbCwgX2JhdGNoLCB2ZXJ0ZXhDb3VudCkge1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuTElORVMsIDAsIHZlcnRleENvdW50KTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvc2hhZGVycy9pbWFnZS12ZXJ0ZXguZ2xzbFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBpbWFnZV92ZXJ0ZXggPSAoXCJhdHRyaWJ1dGUgdmVjNCBhX3Bvc2l0aW9uO1xcclxcblxcclxcbi8vIE9wYWNpdHkgXFxyXFxuYXR0cmlidXRlIGZsb2F0IGFfb3BhY2l0eTtcXHJcXG52YXJ5aW5nIGZsb2F0IHZfb3BhY2l0eTtcXHJcXG5cXHJcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcclxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcclxcblxcclxcbi8vIFVWIGNvb3JkaW5hdGVcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhX3RleGNvb3JkO1xcclxcbnZhcnlpbmcgdmVjMiB2X3RleGNvb3JkO1xcclxcblxcclxcbi8vIFRleHR1cmUgbnVtYmVyXFxyXFxuYXR0cmlidXRlIGxvd3AgZmxvYXQgYV90ZXh0dXJlSW5kZXg7XFxyXFxudmFyeWluZyBsb3dwIGZsb2F0IHZfdGV4dHVyZUluZGV4O1xcclxcblxcclxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXHJcXG5cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICAgLy8gU2V0IHRoZSB2ZXJ0ZXggcG9zaXRpb24gdXNpbmcgdGhlIG9ydGhvIHRyYW5zZm9ybSBtYXRyaXhcXHJcXG4gICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogYV9wb3NpdGlvbjtcXHJcXG5cXHJcXG4gICAvLyBQYXNzIHRocm91Z2ggdGhlIE9wYWNpdHkgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxcclxcbiAgIHZfb3BhY2l0eSA9IGFfb3BhY2l0eTtcXHJcXG4gICAvLyBQYXNzIHRocm91Z2ggdGhlIFVWIGNvb3JkIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcXHJcXG4gICB2X3RleGNvb3JkID0gYV90ZXhjb29yZDtcXHJcXG4gICAvLyBQYXNzIHRocm91Z2ggdGhlIHRleHR1cmUgbnVtYmVyIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcXHJcXG4gICB2X3RleHR1cmVJbmRleCA9IGFfdGV4dHVyZUluZGV4O1xcclxcbiAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgY29sb3IgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxcclxcbiAgIHZfY29sb3IgPSBhX2NvbG9yO1xcclxcbn1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3NoYWRlcnMvaW1hZ2UtZnJhZ21lbnQuZ2xzbFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBpbWFnZV9mcmFnbWVudCA9IChcIiNpZmRlZiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXHJcXG4jZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcclxcbiNlbmRpZlxcclxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbi8vIFVWIGNvb3JkXFxyXFxudmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxyXFxuXFxyXFxuLy8gVGV4dHVyZSBpbmRleFxcclxcbnZhcnlpbmcgbG93cCBmbG9hdCB2X3RleHR1cmVJbmRleDtcXHJcXG5cXHJcXG4vLyBDb2xvciBjb29yZCB0byBibGVuZCB3aXRoIGltYWdlXFxyXFxudmFyeWluZyBsb3dwIHZlYzQgdl9jb2xvcjtcXHJcXG5cXHJcXG4vLyBPcGFjaXR5XFxyXFxudmFyeWluZyBmbG9hdCB2X29wYWNpdHk7XFxyXFxuXFxyXFxudW5pZm9ybSBzYW1wbGVyMkQgdV90ZXh0dXJlc1slJWNvdW50JSVdO1xcclxcblxcclxcbmZsb2F0IGNpcmNsZShpbiB2ZWMyIHN0LCBpbiBmbG9hdCByYWRpdXMpIHtcXHJcXG4gIHZlYzIgZGlzdCA9IHN0IC0gdmVjMigwLjUpO1xcclxcbiAgZmxvYXQgciA9IGRvdChkaXN0LCBkaXN0KSAqIDQuMDtcXHJcXG4gIGZsb2F0IGRlbHRhID0gZndpZHRoKHIpO1xcclxcbiAgcmV0dXJuIDEuMCAtIHNtb290aHN0ZXAocmFkaXVzIC0gZGVsdGEsIHJhZGl1cyArIGRlbHRhLCByKTtcXHJcXG59XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgZmxvYXQgciA9IDAuMCwgZGVsdGEgPSAwLjAsIGFscGhhID0gMS4wO1xcclxcbiAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgdGhlIG1vc3QgZWZmaWNpZW50IHNwcml0ZSBiYXRjaGluZywgd2UgaGF2ZSBtdWx0aXBsZVxcclxcbiAgIC8vIHRleHR1cmVzIGxvYWRlZCBpbnRvIHRoZSBncHUgKHVzdWFsbHkgOCkgdGhpcyBwaWNrZXIgbG9naWMgc2tpcHMgb3ZlciB0ZXh0dXJlc1xcclxcbiAgIC8vIHRoYXQgZG8gbm90IGFwcGx5IHRvIGEgcGFydGljdWxhciBzcHJpdGUuXFxyXFxuXFxyXFxuICAgdmVjNCBjb2xvcjtcXHJcXG4gICAvLyAtMSBJZiB0aGVyZSBpcyBubyB0ZXh0dXJlIHRvIHNhbXBsZSB3ZSBhcmUgZHJhd2luZyBhIHNvbGlkIGdlb21ldHJ5IChyZWN0YW5nbGVzKVxcclxcbiAgIGlmICh2X3RleHR1cmVJbmRleCA9PSAtMS4wKSB7XFxyXFxuICAgICBjb2xvciA9IHZfY29sb3I7XFxyXFxuICAgICBjb2xvci53ID0gY29sb3IudyAqIHZfb3BhY2l0eTtcXHJcXG4gICAvLyAtMiBJZiB0aGVyZSBpcyBubyB0ZXh0dXJlIHdlIGFyZSBkcmF3aW5nIGEgY2lyY2xlXFxyXFxuICAgfSBlbHNlIGlmICh2X3RleHR1cmVJbmRleCA9PSAtMi4wKSB7XFxyXFxuICAgICBjb2xvciA9IHZfY29sb3I7XFxyXFxuICAgICBjb2xvci5hID0gY29sb3IuYSAqIGNpcmNsZSh2X3RleGNvb3JkLCAuOTUpO1xcclxcbiAgIH0gZWxzZSB7XFxyXFxuICAgICAvLyBHTFNMIGlzIHRlbXBsYXRlZCBvdXQgdG8gcGljayB0aGUgcmlnaHQgdGV4dHVyZSBhbmQgc2V0IHRoZSB2ZWM0IGNvbG9yXFxyXFxuICAgICAgJSV0ZXh0dXJlX3BpY2tlciUlXFxyXFxuICAgfVxcclxcbiAgIGNvbG9yLncgPSBjb2xvci53ICogdl9vcGFjaXR5O1xcclxcbiAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcclxcbn1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2RyYXctaW1hZ2UtY29tbWFuZC50c1xuXHJcbnZhciBEcmF3Q29tbWFuZFR5cGU7XHJcbihmdW5jdGlvbiAoRHJhd0NvbW1hbmRUeXBlKSB7XHJcbiAgICBEcmF3Q29tbWFuZFR5cGVbXCJJbWFnZVwiXSA9IFwiaW1hZ2VcIjtcclxuICAgIERyYXdDb21tYW5kVHlwZVtcIkxpbmVcIl0gPSBcImxpbmVcIjtcclxuICAgIERyYXdDb21tYW5kVHlwZVtcIlJlY3RhbmdsZVwiXSA9IFwicmVjdGFuZ2xlXCI7XHJcbiAgICBEcmF3Q29tbWFuZFR5cGVbXCJDaXJjbGVcIl0gPSBcImNpcmNsZVwiO1xyXG59KShEcmF3Q29tbWFuZFR5cGUgfHwgKERyYXdDb21tYW5kVHlwZSA9IHt9KSk7XHJcbmNsYXNzIERyYXdJbWFnZUNvbW1hbmQge1xyXG4gICAgY29uc3RydWN0b3IoaW1hZ2UsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0LCBkeCwgZHksIGR3aWR0aCwgZGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX3Bvb2wgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5zbmFwVG9QaXhlbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy50eXBlID0gRHJhd0NvbW1hbmRUeXBlLkltYWdlO1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMuZGVzdCA9IFswLCAwXTsgLy8geCwgeVxyXG4gICAgICAgIHRoaXMudmlldyA9IFswLCAwLCAwLCAwXTsgLy8gc3gsIHN5LCBzdywgc2hcclxuICAgICAgICB0aGlzLl9nZW9tID0gW1xyXG4gICAgICAgICAgICBbMCwgMF0sXHJcbiAgICAgICAgICAgIFswLCAwXSxcclxuICAgICAgICAgICAgWzAsIDBdLFxyXG4gICAgICAgICAgICBbMCwgMF0sXHJcbiAgICAgICAgICAgIFswLCAwXSxcclxuICAgICAgICAgICAgWzAsIDBdXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLmluaXQoaW1hZ2UsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0LCBkeCwgZHksIGR3aWR0aCwgZGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBpbml0KGltYWdlLCBzeCwgc3ksIHN3aWR0aCwgc2hlaWdodCwgZHgsIGR5LCBkd2lkdGgsIGRoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBEcmF3Q29tbWFuZFR5cGUuSW1hZ2U7XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IGltYWdlO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSAoaW1hZ2UgPT09IG51bGwgfHwgaW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGltYWdlLndpZHRoKSB8fCBzd2lkdGggfHwgMDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IChpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2UuaGVpZ2h0KSB8fCBzaGVpZ2h0IHx8IDA7XHJcbiAgICAgICAgdGhpcy52aWV3ID0gWzAsIDAsIHN3aWR0aCAhPT0gbnVsbCAmJiBzd2lkdGggIT09IHZvaWQgMCA/IHN3aWR0aCA6IGltYWdlID09PSBudWxsIHx8IGltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbWFnZS53aWR0aCwgc2hlaWdodCAhPT0gbnVsbCAmJiBzaGVpZ2h0ICE9PSB2b2lkIDAgPyBzaGVpZ2h0IDogaW1hZ2UgPT09IG51bGwgfHwgaW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGltYWdlLmhlaWdodF07XHJcbiAgICAgICAgdGhpcy5kZXN0ID0gW3N4LCBzeV07XHJcbiAgICAgICAgLy8gSWYgZGVzdGluYXRpb24gaXMgc3BlY2lmaWVkLCB1cGRhdGUgdmlldyBhbmQgZGVzdFxyXG4gICAgICAgIGlmIChkeCAhPT0gdW5kZWZpbmVkICYmIGR5ICE9PSB1bmRlZmluZWQgJiYgZHdpZHRoICE9PSB1bmRlZmluZWQgJiYgZGhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMudmlldyA9IFtzeCwgc3ksIHN3aWR0aCAhPT0gbnVsbCAmJiBzd2lkdGggIT09IHZvaWQgMCA/IHN3aWR0aCA6IGltYWdlID09PSBudWxsIHx8IGltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbWFnZS53aWR0aCwgc2hlaWdodCAhPT0gbnVsbCAmJiBzaGVpZ2h0ICE9PSB2b2lkIDAgPyBzaGVpZ2h0IDogaW1hZ2UgPT09IG51bGwgfHwgaW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGltYWdlLmhlaWdodF07XHJcbiAgICAgICAgICAgIHRoaXMuZGVzdCA9IFtkeCwgZHldO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gZHdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGRoZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0aGlzLmRlc3RbMF0sIHRoaXMuZGVzdFsxXV07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0aGlzLmRlc3RbMF0sIHRoaXMuZGVzdFsxXSArIHRoaXMuaGVpZ2h0XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RoaXMuZGVzdFswXSArIHRoaXMud2lkdGgsIHRoaXMuZGVzdFsxXV07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0aGlzLmRlc3RbMF0gKyB0aGlzLndpZHRoLCB0aGlzLmRlc3RbMV1dO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbdGhpcy5kZXN0WzBdLCB0aGlzLmRlc3RbMV0gKyB0aGlzLmhlaWdodF07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0aGlzLmRlc3RbMF0gKyB0aGlzLndpZHRoLCB0aGlzLmRlc3RbMV0gKyB0aGlzLmhlaWdodF07XHJcbiAgICAgICAgaWYgKHRoaXMuc25hcFRvUGl4ZWwpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiB0aGlzLl9nZW9tKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludFswXSA9IH5+cG9pbnRbMF07XHJcbiAgICAgICAgICAgICAgICBwb2ludFsxXSA9IH5+cG9pbnRbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBpbml0UmVjdChjb2xvciwgc3RhcnQsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBEcmF3Q29tbWFuZFR5cGUuUmVjdGFuZ2xlO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3N0YXJ0LngsIHN0YXJ0LnldO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbc3RhcnQueCwgc3RhcnQueSArIHRoaXMuaGVpZ2h0XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3N0YXJ0LnggKyB0aGlzLndpZHRoLCBzdGFydC55XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3N0YXJ0LnggKyB0aGlzLndpZHRoLCBzdGFydC55XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3N0YXJ0LngsIHN0YXJ0LnkgKyB0aGlzLmhlaWdodF07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFtzdGFydC54ICsgdGhpcy53aWR0aCwgc3RhcnQueSArIHRoaXMuaGVpZ2h0XTtcclxuICAgICAgICBpZiAodGhpcy5zbmFwVG9QaXhlbCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHRoaXMuX2dlb20pIHtcclxuICAgICAgICAgICAgICAgIHBvaW50WzBdID0gfn5wb2ludFswXTtcclxuICAgICAgICAgICAgICAgIHBvaW50WzFdID0gfn5wb2ludFsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGluaXRMaW5lKGNvbG9yLCBzdGFydCwgZW5kLCB0aGlja25lc3MpIHtcclxuICAgICAgICB0aGlzLnR5cGUgPSBEcmF3Q29tbWFuZFR5cGUuTGluZTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgY29uc3QgZGlyID0gZW5kLnN1YihzdGFydCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gZGlyLnBlcnBlbmRpY3VsYXIoKTtcclxuICAgICAgICBjb25zdCBoYWxmVGhpY2sgPSB0aGlja25lc3MgLyAyO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0VG9wID0gbm9ybWFsLnNjYWxlKGhhbGZUaGljaykuYWRkKHN0YXJ0KTtcclxuICAgICAgICBjb25zdCBzdGFydEJvdHRvbSA9IG5vcm1hbC5zY2FsZSgtaGFsZlRoaWNrKS5hZGQoc3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IGVuZFRvcCA9IG5vcm1hbC5zY2FsZShoYWxmVGhpY2spLmFkZChlbmQpO1xyXG4gICAgICAgIGNvbnN0IGVuZEJvdHRvbSA9IG5vcm1hbC5zY2FsZSgtaGFsZlRoaWNrKS5hZGQoZW5kKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tXi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXHJcbiAgICAgICAgICogICAgfCAgICAgICAgICAgICAgICAgICAgIHwgKG5vcm1hbCkgICAgICAgICAgICAgfFxyXG4gICAgICAgICAqICAgKHN0YXJ0eCwgc3RhcnR5KS0tLS0tLS0tLS0tLS0tLS0tLT4oZW5keCwgZW5keSlcclxuICAgICAgICAgKiAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XHJcbiAgICAgICAgICogICAgKyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFtzdGFydFRvcC54LCBzdGFydFRvcC55XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW2VuZFRvcC54LCBlbmRUb3AueV07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFtzdGFydEJvdHRvbS54LCBzdGFydEJvdHRvbS55XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3N0YXJ0Qm90dG9tLngsIHN0YXJ0Qm90dG9tLnldO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbZW5kVG9wLngsIGVuZFRvcC55XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW2VuZEJvdHRvbS54LCBlbmRCb3R0b20ueV07XHJcbiAgICAgICAgaWYgKHRoaXMuc25hcFRvUGl4ZWwpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiB0aGlzLl9nZW9tKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludFswXSA9IH5+cG9pbnRbMF07XHJcbiAgICAgICAgICAgICAgICBwb2ludFsxXSA9IH5+cG9pbnRbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBpbml0Q2lyY2xlKHBvcywgcmFkaXVzLCBjb2xvcikge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IERyYXdDb21tYW5kVHlwZS5DaXJjbGU7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIGNvbnN0IHRvcExlZnQgPSBwb3MuYWRkKHZlYygtcmFkaXVzLCAtcmFkaXVzKSk7XHJcbiAgICAgICAgY29uc3QgdG9wUmlnaHQgPSBwb3MuYWRkKHZlYyhyYWRpdXMsIC1yYWRpdXMpKTtcclxuICAgICAgICBjb25zdCBib3R0b21SaWdodCA9IHBvcy5hZGQodmVjKHJhZGl1cywgcmFkaXVzKSk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tTGVmdCA9IHBvcy5hZGQodmVjKC1yYWRpdXMsIHJhZGl1cykpO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0b3BMZWZ0LngsIHRvcExlZnQueV07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0b3BSaWdodC54LCB0b3BSaWdodC55XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW2JvdHRvbUxlZnQueCwgYm90dG9tTGVmdC55XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW2JvdHRvbUxlZnQueCwgYm90dG9tTGVmdC55XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RvcFJpZ2h0LngsIHRvcFJpZ2h0LnldO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbYm90dG9tUmlnaHQueCwgYm90dG9tUmlnaHQueV07XHJcbiAgICAgICAgaWYgKHRoaXMuc25hcFRvUGl4ZWwpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiB0aGlzLl9nZW9tKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludFswXSA9IH5+cG9pbnRbMF07XHJcbiAgICAgICAgICAgICAgICBwb2ludFsxXSA9IH5+cG9pbnRbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuaW1hZ2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLnZpZXcgPSBbMCwgMCwgMCwgMF07XHJcbiAgICAgICAgdGhpcy5kZXN0ID0gWzAsIDBdO1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0aGlzLmRlc3RbMF0sIHRoaXMuZGVzdFsxXV07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0aGlzLmRlc3RbMF0sIHRoaXMuZGVzdFsxXSArIHRoaXMuaGVpZ2h0XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RoaXMuZGVzdFswXSArIHRoaXMud2lkdGgsIHRoaXMuZGVzdFsxXV07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0aGlzLmRlc3RbMF0gKyB0aGlzLndpZHRoLCB0aGlzLmRlc3RbMV1dO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbdGhpcy5kZXN0WzBdLCB0aGlzLmRlc3RbMV0gKyB0aGlzLmhlaWdodF07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0aGlzLmRlc3RbMF0gKyB0aGlzLndpZHRoLCB0aGlzLmRlc3RbMV0gKyB0aGlzLmhlaWdodF07XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvLyB0b2RvIHdlaXJkXHJcbiAgICBhcHBseVRyYW5zZm9ybSh0cmFuc2Zvcm0sIG9wYWNpdHkpIHtcclxuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ2VvbS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VvbVtpXSA9IHRyYW5zZm9ybS5tdWx0dih0aGlzLl9nZW9tW2ldKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNuYXBUb1BpeGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ2VvbVtpXSA9IFt+fnRoaXMuX2dlb21baV1bMF0sIH5+dGhpcy5fZ2VvbVtpXVsxXV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuICAgIH1cclxuICAgIGdldCBnZW9tZXRyeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2VvbTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBEcmF3UmVjdENvbW1hbmQge1xyXG4gICAgY29uc3RydWN0b3IoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuZGVzdCA9IFswLCAwXTtcclxuICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy5kZXN0ID0gW3gsIHldO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBEcmF3RGVidWdSZWN0Q29tbWFuZCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihib3VuZHMsIGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5ib3VuZHMgPSBib3VuZHM7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC93ZWJnbC11dGlsLnRzXG4vKipcclxuICogQ2hlY2tzIGlmIHRoZSBjdXJyZW50IG51bWJlciBpcyBhIHBvd2VyIG9mIHR3b1xyXG4gKi9cclxuZnVuY3Rpb24gaXNQb3dlck9mVHdvKHgpIHtcclxuICAgIHJldHVybiAoeCAmICh4IC0gMSkpID09PSAwO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgdHdvXHJcbiAqL1xyXG5mdW5jdGlvbiBuZXh0SGlnaGVzdFBvd2VyT2ZUd28oeCkge1xyXG4gICAgLS14O1xyXG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCAzMjsgaSA8PD0gMSkge1xyXG4gICAgICAgIHggPSB4IHwgKHggPj4gaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4geCArIDE7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIGlucHV0IG51bWJlciBpZiBhIHBvd2VyIG9mIHR3bywgb3RoZXJ3aXNlIHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgdHdvXHJcbiAqL1xyXG5mdW5jdGlvbiBlbnN1cmVQb3dlck9mVHdvKHgpIHtcclxuICAgIGlmICghaXNQb3dlck9mVHdvKHgpKSB7XHJcbiAgICAgICAgcmV0dXJuIG5leHRIaWdoZXN0UG93ZXJPZlR3byh4KTtcclxuICAgIH1cclxuICAgIHJldHVybiB4O1xyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC90ZXh0dXJlLWxvYWRlci50c1xuXHJcbi8qKlxyXG4gKiBNYW5hZ2VzIGxvYWRpbmcgaW1hZ2Ugc291cmNlcyBpbnRvIHdlYmdsIHRleHR1cmVzLCBhIHVuaXF1ZSBpZCBpcyBhc3NvY2lhdGVkIHdpdGggYWxsIHNvdXJjZXNcclxuICovXHJcbmNsYXNzIFRleHR1cmVMb2FkZXIge1xyXG4gICAgc3RhdGljIHJlZ2lzdGVyQ29udGV4dChjb250ZXh0KSB7XHJcbiAgICAgICAgVGV4dHVyZUxvYWRlci5fR0wgPSBjb250ZXh0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIFdlYkdMIFRleHR1cmUgZnJvbSBhIHNvdXJjZSBpbWFnZVxyXG4gICAgICogQHBhcmFtIGltYWdlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQoaW1hZ2UpIHtcclxuICAgICAgICByZXR1cm4gVGV4dHVyZUxvYWRlci5fVEVYVFVSRV9NQVAuZ2V0KGltYWdlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGEgc291cmNlIGltYWdlIGhhcyBiZWVuIGxvYWRlZCBhcyBhIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSBpbWFnZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaGFzKGltYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIFRleHR1cmVMb2FkZXIuX1RFWFRVUkVfTUFQLmhhcyhpbWFnZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvYWRzIGEgZ3JhcGhpYyBpbnRvIHdlYmdsIGFuZCByZXR1cm5zIGl0J3MgdGV4dHVyZSBpbmZvLCBhIHdlYmdsIGNvbnRleHQgbXVzdCBiZSBwcmV2aW91c2x5IHJlZ2lzdGVyZWRcclxuICAgICAqIEBwYXJhbSBpbWFnZSBTb3VyY2UgZ3JhcGhpY1xyXG4gICAgICogQHBhcmFtIGZvcmNlVXBkYXRlIE9wdGlvbmFsbHkgZm9yY2UgYSB0ZXh0dXJlIHRvIGJlIHJlbG9hZGVkLCB1c2VmdWwgaWYgdGhlIHNvdXJjZSBncmFwaGljIGhhcyBjaGFuZ2VkXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBsb2FkKGltYWdlLCBmb3JjZVVwZGF0ZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgLy8gSWdub3JlIGxvYWRpbmcgaWYgd2ViZ2wgaXMgbm90IHJlZ2lzdGVyZWRcclxuICAgICAgICBjb25zdCBnbCA9IFRleHR1cmVMb2FkZXIuX0dMO1xyXG4gICAgICAgIGlmICghZ2wpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB0ZXggPSBudWxsO1xyXG4gICAgICAgIC8vIElmIHJldXNlIHRoZSB0ZXh0dXJlIGlmIGl0J3MgZnJvbSB0aGUgc2FtZSBzb3VyY2VcclxuICAgICAgICBpZiAoVGV4dHVyZUxvYWRlci5oYXMoaW1hZ2UpKSB7XHJcbiAgICAgICAgICAgIHRleCA9IFRleHR1cmVMb2FkZXIuZ2V0KGltYWdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXBkYXRlIGV4aXN0aW5nIHdlYmdsIHRleHR1cmUgYW5kIHJldHVybiBlYXJseVxyXG4gICAgICAgIGlmICh0ZXgpIHtcclxuICAgICAgICAgICAgaWYgKGZvcmNlVXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gVGV4dHVyZUxvYWRlci50b1Bvd2VyT2ZUd29JbWFnZShpbWFnZSk7XHJcbiAgICAgICAgICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHNvdXJjZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRleDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTm8gdGV4dHVyZSBleGlzdHMgY3JlYXRlIGEgbmV3IG9uZVxyXG4gICAgICAgIHRleCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSBUZXh0dXJlTG9hZGVyLnRvUG93ZXJPZlR3b0ltYWdlKGltYWdlKTtcclxuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXgpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgIC8vIE5FQVJFU1QgZm9yIHBpeGVsc1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcclxuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBzb3VyY2UpO1xyXG4gICAgICAgIFRleHR1cmVMb2FkZXIuX1RFWFRVUkVfTUFQLnNldChpbWFnZSwgdGV4KTtcclxuICAgICAgICByZXR1cm4gdGV4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBzb3VyY2UgaW1hZ2VzIGludG8gcG93ZXIgb2YgdHdvIGltYWdlcywgV2ViR0wgb25seSBzdXBwb3J0cyBQT1QgaW1hZ2VzXHJcbiAgICAgKiBodHRwczovL3d3dy5raHJvbm9zLm9yZy93ZWJnbC93aWtpL1dlYkdMX2FuZF9PcGVuR0xfRGlmZmVyZW5jZXMjTm9uLVBvd2VyX29mX1R3b19UZXh0dXJlX1N1cHBvcnRcclxuICAgICAqIEBwYXJhbSBpbWFnZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdG9Qb3dlck9mVHdvSW1hZ2UoaW1hZ2UpIHtcclxuICAgICAgICBjb25zdCBwb3RDYW52YXMgPSBUZXh0dXJlTG9hZGVyLl9QT1RfQ0FOVkFTO1xyXG4gICAgICAgIGNvbnN0IHBvdEN0eCA9IFRleHR1cmVMb2FkZXIuX1BPVF9DVFg7XHJcbiAgICAgICAgaWYgKCFpc1Bvd2VyT2ZUd28oaW1hZ2Uud2lkdGgpIHx8ICFpc1Bvd2VyT2ZUd28oaW1hZ2UuaGVpZ2h0KSkge1xyXG4gICAgICAgICAgICAvLyBTY2FsZSB1cCB0aGUgdGV4dHVyZSB0byB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIHR3byBkaW1lbnNpb25zLlxyXG4gICAgICAgICAgICBwb3RDYW52YXMud2lkdGggPSBlbnN1cmVQb3dlck9mVHdvKGltYWdlLndpZHRoKTtcclxuICAgICAgICAgICAgcG90Q2FudmFzLmhlaWdodCA9IGVuc3VyZVBvd2VyT2ZUd28oaW1hZ2UuaGVpZ2h0KTtcclxuICAgICAgICAgICAgcG90Q3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBwb3RDdHguY2xlYXJSZWN0KDAsIDAsIHBvdENhbnZhcy53aWR0aCwgcG90Q2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHBvdEN0eC5kcmF3SW1hZ2UoaW1hZ2UsIDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICBpbWFnZSA9IHBvdENhbnZhcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGltYWdlO1xyXG4gICAgfVxyXG59XHJcblRleHR1cmVMb2FkZXIuX1BPVF9DQU5WQVMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuVGV4dHVyZUxvYWRlci5fUE9UX0NUWCA9IFRleHR1cmVMb2FkZXIuX1BPVF9DQU5WQVMuZ2V0Q29udGV4dCgnMmQnKTtcclxuVGV4dHVyZUxvYWRlci5fVEVYVFVSRV9NQVAgPSBuZXcgTWFwKCk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9pbWFnZS1yZW5kZXJlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQmF0Y2hJbWFnZSBleHRlbmRzIEJhdGNoQ29tbWFuZCB7XHJcbiAgICBjb25zdHJ1Y3RvcihtYXhEcmF3cywgbWF4VGV4dHVyZXMpIHtcclxuICAgICAgICBzdXBlcihtYXhEcmF3cyk7XHJcbiAgICAgICAgdGhpcy5tYXhEcmF3cyA9IG1heERyYXdzO1xyXG4gICAgICAgIHRoaXMubWF4VGV4dHVyZXMgPSBtYXhUZXh0dXJlcztcclxuICAgICAgICB0aGlzLnRleHR1cmVzID0gW107XHJcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNNYXAgPSB7fTtcclxuICAgIH1cclxuICAgIGlzRnVsbCgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21tYW5kcy5sZW5ndGggPj0gdGhpcy5tYXhEcmF3cykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZXMubGVuZ3RoID49IHRoaXMubWF4VGV4dHVyZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNhbkFkZCgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb21tYW5kcy5sZW5ndGggPj0gdGhpcy5tYXhEcmF3cykge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnRleHR1cmVzLmxlbmd0aCA8IHRoaXMubWF4VGV4dHVyZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIF9pc0NvbW1hbmRGdWxsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRzLmxlbmd0aCA+PSB0aGlzLm1heERyYXdzO1xyXG4gICAgfVxyXG4gICAgX2lzVGV4dHVyZUZ1bGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZXMubGVuZ3RoID49IHRoaXMubWF4VGV4dHVyZXM7XHJcbiAgICB9XHJcbiAgICBfd291bGRBZGRUZXh0dXJlKGNvbW1hbmQpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuX2dyYXBoaWNNYXBbY29tbWFuZC5pbWFnZS5pZF07XHJcbiAgICB9XHJcbiAgICBtYXliZUFkZChjb21tYW5kKSB7XHJcbiAgICAgICAgaWYgKCh0aGlzLl9pc0NvbW1hbmRGdWxsKCkgfHwgdGhpcy5faXNUZXh0dXJlRnVsbCgpKSAmJiB0aGlzLl93b3VsZEFkZFRleHR1cmUoY29tbWFuZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZChjb21tYW5kKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGFkZChjb21tYW5kKSB7XHJcbiAgICAgICAgaWYgKGNvbW1hbmQudHlwZSA9PT0gRHJhd0NvbW1hbmRUeXBlLkltYWdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBUZXh0dXJlTG9hZGVyLmxvYWQoY29tbWFuZC5pbWFnZSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHR1cmVzLmluZGV4T2YodGV4dHVyZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRleHR1cmVzLnB1c2godGV4dHVyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21tYW5kcy5wdXNoKGNvbW1hbmQpO1xyXG4gICAgfVxyXG4gICAgYmluZFRleHR1cmVzKGdsKSB7XHJcbiAgICAgICAgLy8gQmluZCB0ZXh0dXJlcyBpbiB0aGUgY29ycmVjdCBvcmRlclxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tYXhUZXh0dXJlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyBpKTtcclxuICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXh0dXJlc1tpXSB8fCB0aGlzLnRleHR1cmVzWzBdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRCYXRjaFRleHR1cmVJZChjb21tYW5kKSB7XHJcbiAgICAgICAgaWYgKGNvbW1hbmQuaW1hZ2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZXMuaW5kZXhPZihUZXh0dXJlTG9hZGVyLmdldChjb21tYW5kLmltYWdlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9ncmFwaGljTWFwID0ge307XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgSW1hZ2VSZW5kZXJlciBleHRlbmRzIEJhdGNoUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2wsIF9jb250ZXh0SW5mbykge1xyXG4gICAgICAgIHN1cGVyKHtcclxuICAgICAgICAgICAgZ2wsXHJcbiAgICAgICAgICAgIGNvbW1hbmQ6IERyYXdJbWFnZUNvbW1hbmQsXHJcbiAgICAgICAgICAgIC8vIDYgdmVydHMgcGVyIHF1YWRcclxuICAgICAgICAgICAgdmVydGljZXNQZXJDb21tYW5kOiA2LFxyXG4gICAgICAgICAgICBtYXhDb21tYW5kc1BlckJhdGNoOiAyMDAwLFxyXG4gICAgICAgICAgICBiYXRjaEZhY3Rvcnk6ICgpID0+IG5ldyBCYXRjaEltYWdlKDIwMDAsIGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUykpXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fY29udGV4dEluZm8gPSBfY29udGV4dEluZm87XHJcbiAgICAgICAgVGV4dHVyZUxvYWRlci5yZWdpc3RlckNvbnRleHQoZ2wpO1xyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgfVxyXG4gICAgYnVpbGRTaGFkZXIoZ2wpIHtcclxuICAgICAgICAvLyBJbml0aWFsaWx6ZSBkZWZhdWx0IGJhdGNoIHJlbmRlcmluZyBzaGFkZXJcclxuICAgICAgICBjb25zdCBtYXhHUFVUZXh0dXJlcyA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9JTUFHRV9VTklUUyk7XHJcbiAgICAgICAgY29uc3Qgc2hhZGVyID0gbmV3IFNoYWRlcihnbCwgaW1hZ2VfdmVydGV4LCB0aGlzLl90cmFuc2Zvcm1GcmFnbWVudFNvdXJjZShpbWFnZV9mcmFnbWVudCwgbWF4R1BVVGV4dHVyZXMpKTtcclxuICAgICAgICBzaGFkZXIuYWRkQXR0cmlidXRlKCdhX3Bvc2l0aW9uJywgMywgZ2wuRkxPQVQpO1xyXG4gICAgICAgIHNoYWRlci5hZGRBdHRyaWJ1dGUoJ2FfdGV4Y29vcmQnLCAyLCBnbC5GTE9BVCk7XHJcbiAgICAgICAgc2hhZGVyLmFkZEF0dHJpYnV0ZSgnYV90ZXh0dXJlSW5kZXgnLCAxLCBnbC5GTE9BVCk7XHJcbiAgICAgICAgc2hhZGVyLmFkZEF0dHJpYnV0ZSgnYV9vcGFjaXR5JywgMSwgZ2wuRkxPQVQpO1xyXG4gICAgICAgIHNoYWRlci5hZGRBdHRyaWJ1dGUoJ2FfY29sb3InLCA0LCBnbC5GTE9BVCk7XHJcbiAgICAgICAgc2hhZGVyLmFkZFVuaWZvcm1NYXRyaXgoJ3VfbWF0cml4JywgdGhpcy5fY29udGV4dEluZm8ubWF0cml4LmRhdGEpO1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgdGV4dHVyZSBzbG90cyB0byBbMCwgMSwgMiwgMywgNCwgLi4uLiBtYXhHUFVUZXh0dXJlc11cclxuICAgICAgICBzaGFkZXIuYWRkVW5pZm9ybUludGVnZXJBcnJheSgndV90ZXh0dXJlcycsIFsuLi5BcnJheShtYXhHUFVUZXh0dXJlcyldLm1hcCgoXywgaSkgPT4gaSkpO1xyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICB9XHJcbiAgICBfdHJhbnNmb3JtRnJhZ21lbnRTb3VyY2Uoc291cmNlLCBtYXhUZXh0dXJlcykge1xyXG4gICAgICAgIGxldCBuZXdTb3VyY2UgPSBzb3VyY2UucmVwbGFjZSgnJSVjb3VudCUlJywgbWF4VGV4dHVyZXMudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgbGV0IHRleHR1cmVQaWNrZXJCdWlsZGVyID0gJyc7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhUZXh0dXJlczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlUGlja2VyQnVpbGRlciArPSBgaWYgKHZfdGV4dHVyZUluZGV4IDw9ICR7aX0uNSkge1xcbmA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlUGlja2VyQnVpbGRlciArPSBgICAgZWxzZSBpZiAodl90ZXh0dXJlSW5kZXggPD0gJHtpfS41KSB7XFxuYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0ZXh0dXJlUGlja2VyQnVpbGRlciArPSBgICAgICAgY29sb3IgPSB0ZXh0dXJlMkQodV90ZXh0dXJlc1ske2l9XSwgdl90ZXhjb29yZCk7XFxuYDtcclxuICAgICAgICAgICAgdGV4dHVyZVBpY2tlckJ1aWxkZXIgKz0gYCAgIH1cXG5gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBuZXdTb3VyY2UgPSBuZXdTb3VyY2UucmVwbGFjZSgnJSV0ZXh0dXJlX3BpY2tlciUlJywgdGV4dHVyZVBpY2tlckJ1aWxkZXIpO1xyXG4gICAgICAgIHJldHVybiBuZXdTb3VyY2U7XHJcbiAgICB9XHJcbiAgICBhZGRDaXJjbGUocG9zLCByYWRpdXMsIGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IHRoaXMuY29tbWFuZHMuZ2V0KCkuaW5pdENpcmNsZShwb3MsIHJhZGl1cywgY29sb3IpO1xyXG4gICAgICAgIGNvbW1hbmQuYXBwbHlUcmFuc2Zvcm0odGhpcy5fY29udGV4dEluZm8udHJhbnNmb3JtLmN1cnJlbnQsIHRoaXMuX2NvbnRleHRJbmZvLnN0YXRlLmN1cnJlbnQub3BhY2l0eSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKGNvbW1hbmQpO1xyXG4gICAgfVxyXG4gICAgYWRkUmVjdGFuZ2xlKGNvbG9yLCBwb3MsIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCBjb21tYW5kID0gdGhpcy5jb21tYW5kcy5nZXQoKS5pbml0UmVjdChjb2xvciwgcG9zLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgICAgICBjb21tYW5kLmFwcGx5VHJhbnNmb3JtKHRoaXMuX2NvbnRleHRJbmZvLnRyYW5zZm9ybS5jdXJyZW50LCB0aGlzLl9jb250ZXh0SW5mby5zdGF0ZS5jdXJyZW50Lm9wYWNpdHkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZChjb21tYW5kKTtcclxuICAgIH1cclxuICAgIGFkZExpbmUoY29sb3IsIHN0YXJ0LCBlbmQsIHRoaWNrbmVzcyA9IDEpIHtcclxuICAgICAgICBjb25zdCBjb21tYW5kID0gdGhpcy5jb21tYW5kcy5nZXQoKS5pbml0TGluZShjb2xvciwgc3RhcnQsIGVuZCwgdGhpY2tuZXNzKTtcclxuICAgICAgICBjb21tYW5kLmFwcGx5VHJhbnNmb3JtKHRoaXMuX2NvbnRleHRJbmZvLnRyYW5zZm9ybS5jdXJyZW50LCB0aGlzLl9jb250ZXh0SW5mby5zdGF0ZS5jdXJyZW50Lm9wYWNpdHkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZChjb21tYW5kKTtcclxuICAgIH1cclxuICAgIGFkZEltYWdlKGdyYXBoaWMsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0LCBkeCwgZHksIGR3aWR0aCwgZGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzLmdldCgpLmluaXQoZ3JhcGhpYywgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQsIGR4LCBkeSwgZHdpZHRoLCBkaGVpZ2h0KTtcclxuICAgICAgICBjb21tYW5kLmFwcGx5VHJhbnNmb3JtKHRoaXMuX2NvbnRleHRJbmZvLnRyYW5zZm9ybS5jdXJyZW50LCB0aGlzLl9jb250ZXh0SW5mby5zdGF0ZS5jdXJyZW50Lm9wYWNpdHkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZChjb21tYW5kKTtcclxuICAgIH1cclxuICAgIHJlbmRlckJhdGNoKGdsLCBiYXRjaCwgdmVydGV4Q291bnQpIHtcclxuICAgICAgICAvLyBCaW5kIHRleHR1cmVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXHJcbiAgICAgICAgYmF0Y2guYmluZFRleHR1cmVzKGdsKTtcclxuICAgICAgICAvLyBkcmF3IHRoZSBxdWFkc1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCB2ZXJ0ZXhDb3VudCk7XHJcbiAgICB9XHJcbiAgICBidWlsZEJhdGNoVmVydGljZXModmVydGV4QnVmZmVyLCBiYXRjaCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgbGV0IHZlcnRJbmRleCA9IDA7XHJcbiAgICAgICAgbGV0IHN4ID0gMDtcclxuICAgICAgICBsZXQgc3kgPSAwO1xyXG4gICAgICAgIGxldCBzdyA9IDA7XHJcbiAgICAgICAgbGV0IHNoID0gMDtcclxuICAgICAgICBsZXQgcG90V2lkdGggPSAxO1xyXG4gICAgICAgIGxldCBwb3RIZWlnaHQgPSAxO1xyXG4gICAgICAgIGxldCB0ZXh0dXJlSWQgPSAwO1xyXG4gICAgICAgIGxldCBjb21tYW5kQ29sb3IgPSBDb2xvci5UcmFuc3BhcmVudDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgYmF0Y2guY29tbWFuZHMpIHtcclxuICAgICAgICAgICAgc3ggPSBjb21tYW5kLnZpZXdbMF07XHJcbiAgICAgICAgICAgIHN5ID0gY29tbWFuZC52aWV3WzFdO1xyXG4gICAgICAgICAgICBzdyA9IGNvbW1hbmQudmlld1syXTtcclxuICAgICAgICAgICAgc2ggPSBjb21tYW5kLnZpZXdbM107XHJcbiAgICAgICAgICAgIHBvdFdpZHRoID0gZW5zdXJlUG93ZXJPZlR3bygoKF9hID0gY29tbWFuZC5pbWFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpZHRoKSB8fCBjb21tYW5kLndpZHRoKTtcclxuICAgICAgICAgICAgcG90SGVpZ2h0ID0gZW5zdXJlUG93ZXJPZlR3bygoKF9iID0gY29tbWFuZC5pbWFnZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodCkgfHwgY29tbWFuZC5oZWlnaHQpO1xyXG4gICAgICAgICAgICB0ZXh0dXJlSWQgPSBiYXRjaC5nZXRCYXRjaFRleHR1cmVJZChjb21tYW5kKTtcclxuICAgICAgICAgICAgaWYgKGNvbW1hbmQudHlwZSA9PT0gRHJhd0NvbW1hbmRUeXBlLkxpbmUgfHwgY29tbWFuZC50eXBlID09PSBEcmF3Q29tbWFuZFR5cGUuUmVjdGFuZ2xlKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlSWQgPSAtMTsgLy8gc2VudGluZWwgZm9yIG5vIGltYWdlIHJlY3RcclxuICAgICAgICAgICAgICAgIGNvbW1hbmRDb2xvciA9IGNvbW1hbmQuY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbW1hbmQudHlwZSA9PT0gRHJhd0NvbW1hbmRUeXBlLkNpcmNsZSkge1xyXG4gICAgICAgICAgICAgICAgdGV4dHVyZUlkID0gLTI7IC8vIHNlbnRpbmVsIGZvciBjaXJjbGVcclxuICAgICAgICAgICAgICAgIGNvbW1hbmRDb2xvciA9IGNvbW1hbmQuY29sb3I7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcG90ZW50aWFsIG9wdGltaXphdGlvbiB3aGVuIGRpdmRpbmcgYnkgMiAoYml0c2hpZnQpXHJcbiAgICAgICAgICAgIC8vIE1vZGlmeWluZyB0aGUgaW1hZ2VzIHRvIHBvd2Vyb2Z0d28gaW1hZ2VzIHdhcnAgdGhlIFVWIGNvb3JkaW5hdGVzXHJcbiAgICAgICAgICAgIGxldCB1dngwID0gc3ggLyBwb3RXaWR0aDtcclxuICAgICAgICAgICAgbGV0IHV2eTAgPSBzeSAvIHBvdEhlaWdodDtcclxuICAgICAgICAgICAgbGV0IHV2eDEgPSAoc3ggKyBzdykgLyBwb3RXaWR0aDtcclxuICAgICAgICAgICAgbGV0IHV2eTEgPSAoc3kgKyBzaCkgLyBwb3RIZWlnaHQ7XHJcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlSWQgPT09IC0yKSB7XHJcbiAgICAgICAgICAgICAgICB1dngwID0gMDtcclxuICAgICAgICAgICAgICAgIHV2eTAgPSAwO1xyXG4gICAgICAgICAgICAgICAgdXZ4MSA9IDE7XHJcbiAgICAgICAgICAgICAgICB1dnkxID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBRdWFkIHVwZGF0ZVxyXG4gICAgICAgICAgICAvLyAoMCwgMCwgeikgei1pbmRleCBkb2Vzbid0IHdvcmsgaW4gYmF0Y2ggcmVuZGVyaW5nIGJldHdlZW4gYmF0Y2hlc1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5nZW9tZXRyeVswXVswXTsgLy8geCArIDAgKiB3aWR0aDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmQuZ2VvbWV0cnlbMF1bMV07IC8veSArIDAgKiBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSAwO1xyXG4gICAgICAgICAgICAvLyBVViBjb29yZHNcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHV2eDA7IC8vIDA7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSB1dnkwOyAvLyAwO1xyXG4gICAgICAgICAgICAvLyB0ZXh0dXJlIGlkXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSB0ZXh0dXJlSWQ7XHJcbiAgICAgICAgICAgIC8vIG9wYWNpdHlcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmQub3BhY2l0eTtcclxuICAgICAgICAgICAgLy8gY29sb3JcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5yIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmcgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuYiAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5hO1xyXG4gICAgICAgICAgICAvLyAoMCwgMSlcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmQuZ2VvbWV0cnlbMV1bMF07IC8vIHggKyAwICogd2lkdGg7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kLmdlb21ldHJ5WzFdWzFdOyAvLyB5ICsgMSAqIGhlaWdodDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IDA7XHJcbiAgICAgICAgICAgIC8vIFVWIGNvb3Jkc1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gdXZ4MDsgLy8gMDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHV2eTE7IC8vIDE7XHJcbiAgICAgICAgICAgIC8vIHRleHR1cmUgaWRcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHRleHR1cmVJZDtcclxuICAgICAgICAgICAgLy8gb3BhY2l0eVxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5vcGFjaXR5O1xyXG4gICAgICAgICAgICAvLyBjb2xvclxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuZyAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5iIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmE7XHJcbiAgICAgICAgICAgIC8vICgxLCAwKVxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5nZW9tZXRyeVsyXVswXTsgLy8geCArIDEgKiB3aWR0aDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmQuZ2VvbWV0cnlbMl1bMV07IC8vIHkgKyAwICogaGVpZ2h0O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gMDtcclxuICAgICAgICAgICAgLy8gVVYgY29vcmRzXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSB1dngxOyAvLzE7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSB1dnkwOyAvLzA7XHJcbiAgICAgICAgICAgIC8vIHRleHR1cmUgaWRcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHRleHR1cmVJZDtcclxuICAgICAgICAgICAgLy8gb3BhY2l0eVxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5vcGFjaXR5O1xyXG4gICAgICAgICAgICAvLyBjb2xvclxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuZyAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5iIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmE7XHJcbiAgICAgICAgICAgIC8vICgxLCAwKVxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5nZW9tZXRyeVszXVswXTsgLy8geCArIDEgKiB3aWR0aDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmQuZ2VvbWV0cnlbM11bMV07IC8vIHkgKyAwICogaGVpZ2h0O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gMDtcclxuICAgICAgICAgICAgLy8gVVYgY29vcmRzXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSB1dngxOyAvLzE7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSB1dnkwOyAvLzA7XHJcbiAgICAgICAgICAgIC8vIHRleHR1cmUgaWRcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHRleHR1cmVJZDtcclxuICAgICAgICAgICAgLy8gb3BhY2l0eVxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5vcGFjaXR5O1xyXG4gICAgICAgICAgICAvLyBjb2xvclxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuZyAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5iIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmE7XHJcbiAgICAgICAgICAgIC8vICgwLCAxKVxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5nZW9tZXRyeVs0XVswXTsgLy8geCArIDAgKiB3aWR0aDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmQuZ2VvbWV0cnlbNF1bMV07IC8vIHkgKyAxICogaGVpZ2h0XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSAwO1xyXG4gICAgICAgICAgICAvLyBVViBjb29yZHNcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHV2eDA7IC8vIDA7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSB1dnkxOyAvLyAxO1xyXG4gICAgICAgICAgICAvLyB0ZXh0dXJlIGlkXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSB0ZXh0dXJlSWQ7XHJcbiAgICAgICAgICAgIC8vIG9wYWNpdHlcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmQub3BhY2l0eTtcclxuICAgICAgICAgICAgLy8gY29sb3JcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5yIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmcgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuYiAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5hO1xyXG4gICAgICAgICAgICAvLyAoMSwgMSlcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmQuZ2VvbWV0cnlbNV1bMF07IC8vIHggKyAxICogd2lkdGg7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kLmdlb21ldHJ5WzVdWzFdOyAvLyB5ICsgMSAqIGhlaWdodDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IDA7XHJcbiAgICAgICAgICAgIC8vIFVWIGNvb3Jkc1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gdXZ4MTsgLy8gMTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHV2eTE7IC8vIDE7XHJcbiAgICAgICAgICAgIC8vIHRleHR1cmUgaWRcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHRleHR1cmVJZDtcclxuICAgICAgICAgICAgLy8gb3BhY2l0eVxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5vcGFjaXR5O1xyXG4gICAgICAgICAgICAvLyBjb2xvclxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuZyAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5iIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2ZXJ0SW5kZXggLyB0aGlzLnZlcnRleFNpemU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3NoYWRlcnMvcG9pbnQtdmVydGV4Lmdsc2xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgcG9pbnRfdmVydGV4ID0gKFwiYXR0cmlidXRlIHZlYzQgYV9wb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcclxcbmF0dHJpYnV0ZSBmbG9hdCBhX3NpemU7XFxyXFxudmFyeWluZyBsb3dwIHZlYzQgdl9jb2xvcjtcXHJcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIGFfcG9zaXRpb247XFxyXFxuICBnbF9Qb2ludFNpemUgPSBhX3NpemUgKiAyLjA7XFxyXFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXHJcXG59XCIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9zaGFkZXJzL3BvaW50LWZyYWdtZW50Lmdsc2xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgcG9pbnRfZnJhZ21lbnQgPSAoXCIjaWZkZWYgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFxyXFxuI2V4dGVuc2lvbiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMgOiBlbmFibGVcXHJcXG4jZW5kaWZcXHJcXG5cXHJcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXHJcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG4gIGZsb2F0IHIgPSAwLjAsIGRlbHRhID0gMC4wLCBhbHBoYSA9IDEuMDtcXHJcXG4gIHZlYzIgY3h5ID0gMi4wICogZ2xfUG9pbnRDb29yZCAtIDEuMDtcXHJcXG4gIHIgPSBkb3QoY3h5LCBjeHkpO1xcclxcbiAgXFxyXFxuI2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcclxcbiAgZGVsdGEgPSBmd2lkdGgocik7XFxyXFxuICBhbHBoYSA9IDEuMCAtIHNtb290aHN0ZXAoMS4wIC0gZGVsdGEsIDEuMCArIGRlbHRhLCByKTtcXHJcXG4jZWxzZVxcclxcbiAgaWYgKHIgPiAxLjApIHtcXHJcXG4gICAgZGlzY2FyZDtcXHJcXG4gIH1cXHJcXG4jZW5kaWZcXHJcXG4gIGdsX0ZyYWdDb2xvciA9IHZlYzQodl9jb2xvci5yZ2IsIHZfY29sb3IuYSAqIGFscGhhKTtcXHJcXG59XCIpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9wb2ludC1yZW5kZXJlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gaW1wb3J0IHsgUmFuZG9tIH0gZnJvbSAnLi4vLi4vTWF0aC9JbmRleCc7XHJcbmNsYXNzIERyYXdQb2ludCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLnBvaW50ID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IENvbG9yLkJsYWNrO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDE7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMucG9pbnQuc2V0VG8oMCwgMCk7XHJcbiAgICAgICAgdGhpcy5jb2xvci5yID0gMDtcclxuICAgICAgICB0aGlzLmNvbG9yLmcgPSAwO1xyXG4gICAgICAgIHRoaXMuY29sb3IuYiA9IDA7XHJcbiAgICAgICAgdGhpcy5jb2xvci5hID0gMTtcclxuICAgICAgICB0aGlzLnNpemUgPSAxO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBvaW50UmVuZGVyZXIgZXh0ZW5kcyBCYXRjaFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsLCBfY29udGV4dEluZm8pIHtcclxuICAgICAgICBzdXBlcih7IGdsLCBjb21tYW5kOiBEcmF3UG9pbnQsIHZlcnRpY2VzUGVyQ29tbWFuZDogMSB9KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0SW5mbyA9IF9jb250ZXh0SW5mbztcclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH1cclxuICAgIGJ1aWxkU2hhZGVyKGdsKSB7XHJcbiAgICAgICAgZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXMnKTtcclxuICAgICAgICBjb25zdCBzaGFkZXIgPSBuZXcgU2hhZGVyKGdsLCBwb2ludF92ZXJ0ZXgsIHBvaW50X2ZyYWdtZW50KTtcclxuICAgICAgICBzaGFkZXIuYWRkQXR0cmlidXRlKCdhX3Bvc2l0aW9uJywgMiwgZ2wuRkxPQVQpO1xyXG4gICAgICAgIHNoYWRlci5hZGRBdHRyaWJ1dGUoJ2FfY29sb3InLCA0LCBnbC5GTE9BVCk7XHJcbiAgICAgICAgc2hhZGVyLmFkZEF0dHJpYnV0ZSgnYV9zaXplJywgMSwgZ2wuRkxPQVQpO1xyXG4gICAgICAgIHNoYWRlci5hZGRVbmlmb3JtTWF0cml4KCd1X21hdHJpeCcsIHRoaXMuX2NvbnRleHRJbmZvLm1hdHJpeC5kYXRhKTtcclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfVxyXG4gICAgYWRkUG9pbnQocG9pbnQsIGNvbG9yLCBzaXplKSB7XHJcbiAgICAgICAgY29uc3QgY21kID0gdGhpcy5jb21tYW5kcy5nZXQoKTtcclxuICAgICAgICBjbWQucG9pbnQgPSB0aGlzLl9jb250ZXh0SW5mby50cmFuc2Zvcm0uY3VycmVudC5tdWx0dihwb2ludCk7XHJcbiAgICAgICAgY21kLmNvbG9yLnIgPSBjb2xvci5yO1xyXG4gICAgICAgIGNtZC5jb2xvci5nID0gY29sb3IuZztcclxuICAgICAgICBjbWQuY29sb3IuYiA9IGNvbG9yLmI7XHJcbiAgICAgICAgY21kLmNvbG9yLmEgPSBjb2xvci5hICogdGhpcy5fY29udGV4dEluZm8uc3RhdGUuY3VycmVudC5vcGFjaXR5O1xyXG4gICAgICAgIGNtZC5zaXplID0gc2l6ZSAqIE1hdGgubWF4KHRoaXMuX2NvbnRleHRJbmZvLnRyYW5zZm9ybS5jdXJyZW50LmdldFNjYWxlWCgpLCB0aGlzLl9jb250ZXh0SW5mby50cmFuc2Zvcm0uY3VycmVudC5nZXRTY2FsZVkoKSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKGNtZCk7XHJcbiAgICB9XHJcbiAgICBidWlsZEJhdGNoVmVydGljZXModmVydGV4QnVmZmVyLCBiYXRjaCkge1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb21tYW5kIG9mIGJhdGNoLmNvbW1hbmRzKSB7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcltpbmRleCsrXSA9IGNvbW1hbmQucG9pbnQueDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5wb2ludC55O1xyXG4gICAgICAgICAgICAvLyBub3JtYWxpemUgdG8gWzAsIDFdIGZvciB3ZWJnbFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLmNvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcltpbmRleCsrXSA9IGNvbW1hbmQuY29sb3IuZyAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5jb2xvci5iIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLmNvbG9yLmE7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcltpbmRleCsrXSA9IGNvbW1hbmQuc2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGluZGV4IC8gdGhpcy52ZXJ0ZXhTaXplO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyQmF0Y2goZ2wsIF9iYXRjaCwgdmVydGV4Q291bnQpIHtcclxuICAgICAgICBnbC5kcmF3QXJyYXlzKGdsLlBPSU5UUywgMCwgdmVydGV4Q291bnQpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvR3JhcGhpYy50c1xuXHJcblxyXG4vKipcclxuICogQSBHcmFwaGljIGlzIHRoZSBiYXNlIEV4Y2FsaWJ1ciBwcmltaXRpdmUgZm9yIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBkcmF3biB0byB0aGUgW1tFeGNhbGlidXJHcmFwaGljc0NvbnRleHRdXS5cclxuICogW1tTcHJpdGVdXSwgW1tBbmltYXRpb25dXSwgW1tHcmFwaGljc0dyb3VwXV0sIFtbQ2FudmFzXV0sIFtbUmVjdGFuZ2xlXV0sIFtbQ2lyY2xlXV0sIGFuZCBbW1BvbHlnb25dXSBhbGwgZGVyaXZlIGZyb20gdGhlXHJcbiAqIFtbR3JhcGhpY11dIGFic3RyYWN0IGNsYXNzLlxyXG4gKlxyXG4gKiBJbXBsZW1lbnRvcnMgb2YgYSBHcmFwaGljIG11c3Qgb3ZlcnJpZGUgdGhlIGFic3RyYWN0IFtbR3JhcGhpYy5fZHJhd0ltYWdlXV0gbWV0aG9kIHRvIHJlbmRlciBhbiBpbWFnZSB0byB0aGUgZ3JhcGhpY3MgY29udGV4dC4gR3JhcGhpY1xyXG4gKiBoYW5kbGVzIGFsbCB0aGUgcG9zaXRpb24sIHJvdGF0aW9uLCBhbmQgc2NhbGUgdHJhbnNmb3JtYXRpb25zIGluIFtbR3JhcGhpYy5fcHJlRHJhd11dIGFuZCBbW0dyYXBoaWMuX3Bvc3REcmF3XV1cclxuICovXHJcbmNsYXNzIEdyYXBoaWMge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIHRoaXMuaWQgPSBHcmFwaGljLl9JRCsrO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB3ZXRoZXIgdG8gc2hvdyBkZWJ1ZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZ3JhcGhpY1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2hvd0RlYnVnID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBmbGlwSG9yaXpvbnRhbCwgd2hpY2ggd2lsbCBmbGlwIHRoZSBncmFwaGljIGhvcml6b250YWxseSAoYWNyb3NzIHRoZSB5IGF4aXMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZmxpcFZlcnRpY2FsLCB3aGljaCB3aWxsIGZsaXAgdGhlIGdyYXBoaWMgdmVydGljYWxseSAoYWNyb3NzIHRoZSB4IGF4aXMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mbGlwVmVydGljYWwgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHJvdGF0aW9uIG9mIHRoZSBncmFwaGljXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcGFjaXR5IG9mIHRoZSBncmFwaGljLCAwIGlzIHRyYW5zcGFyZW50LCAxIGlzIHNvbGlkIChvcGFxdWUpLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBzY2FsZSBvZiB0aGUgZ3JhcGhpYywgdGhpcyBhZmZlY3RzIHRoZSB3aWR0aCBhbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjYWxlID0gVmVjdG9yLk9uZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9yaWdpbiBvZiB0aGUgZ3JhcGhpYywgaWYgbm90IHNldCB0aGUgY2VudGVyIG9mIHRoZSBncmFwaGljIGlzIHRoZSBvcmlnaW5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9yaWdpbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fd2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IDA7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5vcmlnaW4gPSAoX2EgPSBvcHRpb25zLm9yaWdpbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5vcmlnaW47XHJcbiAgICAgICAgICAgIHRoaXMuZmxpcEhvcml6b250YWwgPSAoX2IgPSBvcHRpb25zLmZsaXBIb3Jpem9udGFsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmZsaXBIb3Jpem9udGFsO1xyXG4gICAgICAgICAgICB0aGlzLmZsaXBWZXJ0aWNhbCA9IChfYyA9IG9wdGlvbnMuZmxpcFZlcnRpY2FsKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLmZsaXBWZXJ0aWNhbDtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IChfZCA9IG9wdGlvbnMucm90YXRpb24pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRoaXMucm90YXRpb247XHJcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IChfZSA9IG9wdGlvbnMub3BhY2l0eSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gKF9mID0gb3B0aW9ucy5zY2FsZSkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdGhpcy5zY2FsZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbG9uZUdyYXBoaWNPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9yaWdpbjogdGhpcy5vcmlnaW4gPyB0aGlzLm9yaWdpbi5jbG9uZSgpIDogbnVsbCxcclxuICAgICAgICAgICAgZmxpcEhvcml6b250YWw6IHRoaXMuZmxpcEhvcml6b250YWwsXHJcbiAgICAgICAgICAgIGZsaXBWZXJ0aWNhbDogdGhpcy5mbGlwVmVydGljYWwsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxyXG4gICAgICAgICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHksXHJcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLnNjYWxlID8gdGhpcy5zY2FsZS5jbG9uZSgpIDogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgd2lkdGggb2YgdGhlIGdyYXBoaWMgKGFsd2F5cyBwb3NpdGl2ZSlcclxuICAgICAqL1xyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLl93aWR0aCAqIHRoaXMuc2NhbGUueCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBncmFwaGljIChhbHdheXMgcG9zaXRpdmUpXHJcbiAgICAgKi9cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuX2hlaWdodCAqIHRoaXMuc2NhbGUueSk7XHJcbiAgICB9XHJcbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgc2V0IGhlaWdodCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2hlaWdodCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGEgY29weSBvZiB0aGUgYm91bmRzIGluIHBpeGVscyBvY2N1cGllZCBieSB0aGUgZ3JhcGhpYyBvbiB0aGUgdGhlIHNjcmVlbi4gVGhpcyBpbmNsdWRlcyBzY2FsZS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGxvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiBCb3VuZGluZ0JveC5mcm9tRGltZW5zaW9uKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBWZWN0b3IuWmVybyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgdGhlIHdob2xlIGdyYXBoaWMgdG8gdGhlIGNvbnRleHQgaW5jbHVkaW5nIHRyYW5zZm9ybVxyXG4gICAgICogQHBhcmFtIGV4IFRoZSBleGNhbGlidXIgZ3JhcGhpY3MgY29udGV4dFxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKi9cclxuICAgIGRyYXcoZXgsIHgsIHkpIHtcclxuICAgICAgICB0aGlzLl9wcmVEcmF3KGV4LCB4LCB5KTtcclxuICAgICAgICB0aGlzLl9kcmF3SW1hZ2UoZXgsIDAsIDApO1xyXG4gICAgICAgIHRoaXMuX3Bvc3REcmF3KGV4KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgYWZmaW5lIHRyYW5zZm9ybWF0aW9ucyB0byB0aGUgZ3JhcGhpY3MgY29udGV4dCB0byBtYW5pcHVsYXRlIHRoZSBncmFwaGljIGJlZm9yZSBbW0dyYXBoaWMuX2RyYXdJbWFnZV1dXHJcbiAgICAgKiBAcGFyYW0gZXhcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICovXHJcbiAgICBfcHJlRHJhdyhleCwgeCwgeSkge1xyXG4gICAgICAgIGV4LnNhdmUoKTtcclxuICAgICAgICBleC50cmFuc2xhdGUoeCwgeSk7XHJcbiAgICAgICAgZXguc2NhbGUoTWF0aC5hYnModGhpcy5zY2FsZS54KSwgTWF0aC5hYnModGhpcy5zY2FsZS55KSk7XHJcbiAgICAgICAgdGhpcy5fcm90YXRlKGV4KTtcclxuICAgICAgICB0aGlzLl9mbGlwKGV4KTtcclxuICAgICAgICAvLyBpdCBpcyBpbXBvcnRhbnQgdG8gbXVsdGlwbHkgYWxwaGFzIHNvIGdyYXBoaWNzIHJlc3BlY3QgdGhlIGN1cnJlbnQgY29udGV4dFxyXG4gICAgICAgIGV4Lm9wYWNpdHkgPSBleC5vcGFjaXR5ICogdGhpcy5vcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgX3JvdGF0ZShleCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBzY2FsZURpclggPSB0aGlzLnNjYWxlLnggPiAwID8gMSA6IC0xO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlRGlyWSA9IHRoaXMuc2NhbGUueSA+IDAgPyAxIDogLTE7XHJcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gKF9hID0gdGhpcy5vcmlnaW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZlYyh0aGlzLndpZHRoIC8gMiwgdGhpcy5oZWlnaHQgLyAyKTtcclxuICAgICAgICBleC50cmFuc2xhdGUob3JpZ2luLngsIG9yaWdpbi55KTtcclxuICAgICAgICBleC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBmb3IgaGFuZGxpbmcgZGlyZWN0aW9uIGNoYW5nZXMgMSBvciAtMSwgdGhhdCB3YXkgd2UgZG9uJ3QgaGF2ZSBtaXNtYXRjaGVkIHRyYW5zbGF0ZXMoKVxyXG4gICAgICAgIGV4LnNjYWxlKHNjYWxlRGlyWCwgc2NhbGVEaXJZKTtcclxuICAgICAgICBleC50cmFuc2xhdGUoLW9yaWdpbi54LCAtb3JpZ2luLnkpO1xyXG4gICAgfVxyXG4gICAgX2ZsaXAoZXgpIHtcclxuICAgICAgICBpZiAodGhpcy5mbGlwSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICBleC50cmFuc2xhdGUodGhpcy53aWR0aCAvIHRoaXMuc2NhbGUueCwgMCk7XHJcbiAgICAgICAgICAgIGV4LnNjYWxlKC0xLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZmxpcFZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIGV4LnRyYW5zbGF0ZSgwLCB0aGlzLmhlaWdodCAvIHRoaXMuc2NhbGUueSk7XHJcbiAgICAgICAgICAgIGV4LnNjYWxlKDEsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IGFueSBhZGR0aW9uYWwgd29yayBhZnRlciBbW0dyYXBoaWMuX2RyYXdJbWFnZV1dIGFuZCByZXN0b3JlIHRoZSBjb250ZXh0IHN0YXRlLlxyXG4gICAgICogQHBhcmFtIGV4XHJcbiAgICAgKi9cclxuICAgIF9wb3N0RHJhdyhleCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNob3dEZWJ1Zykge1xyXG4gICAgICAgICAgICBleC5kZWJ1Zy5kcmF3UmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4LnJlc3RvcmUoKTtcclxuICAgIH1cclxufVxyXG5HcmFwaGljLl9JRCA9IDA7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9XYXRjaC50c1xuLyoqXHJcbiAqIFdhdGNoIGFuIG9iamVjdCB3aXRoIGEgcHJveHksIG9ubHkgZmlyZXMgaWYgcHJvcGVydHkgdmFsdWUgaXMgZGlmZmVyZW50XHJcbiAqL1xyXG5mdW5jdGlvbiB3YXRjaCh0eXBlLCBjaGFuZ2UpIHtcclxuICAgIGlmICghdHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0eXBlO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGUuX19pc1Byb3h5ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAvLyBleHBhbmRvIGhhY2sgdG8gbWFyayBhIHByb3h5XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0eXBlLCB7XHJcbiAgICAgICAgICAgIHNldDogKG9iaiwgcHJvcCwgdmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGJlaGF2aW9yIHRvIHN0b3JlIHRoZSB2YWx1ZVxyXG4gICAgICAgICAgICAgICAgaWYgKG9ialtwcm9wXSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCB3YXRjaGluZyBwcml2YXRlIGp1bmtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wWzBdICE9PSAnXycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZShvYmopO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSW5kaWNhdGUgc3VjY2Vzc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldDogKG9iaiwgcHJvcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3AgIT09ICdfX2lzUHJveHknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtwcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHlwZTtcclxufVxyXG4vKipcclxuICogV2F0Y2ggYW4gb2JqZWN0IHdpdGggYSBwcm94eSwgZmlyZXMgY2hhbmdlIG9uIGFueSBwcm9wZXJ0eSB2YWx1ZSBjaGFuZ2VcclxuICovXHJcbmZ1bmN0aW9uIHdhdGNoQW55KHR5cGUsIGNoYW5nZSkge1xyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZS5fX2lzUHJveHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIGV4cGFuZG8gaGFjayB0byBtYXJrIGEgcHJveHlcclxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHR5cGUsIHtcclxuICAgICAgICAgICAgc2V0OiAob2JqLCBwcm9wLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgYmVoYXZpb3IgdG8gc3RvcmUgdGhlIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBvYmpbcHJvcF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgICAgIC8vIEF2b2lkIHdhdGNoaW5nIHByaXZhdGUganVua1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wWzBdICE9PSAnXycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gSW5kaWNhdGUgc3VjY2Vzc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldDogKG9iaiwgcHJvcCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHByb3AgIT09ICdfX2lzUHJveHknKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtwcm9wXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHlwZTtcclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL1Jhc3Rlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBIFJhc3RlciBpcyBhIEdyYXBoaWMgdGhhdCBuZWVkcyB0byBiZSBmaXJzdCBwYWludGVkIHRvIGEgSFRNTENhbnZhc0VsZW1lbnQgYmVmb3JlIGl0IGNhbiBiZSBkcmF3biB0byB0aGVcclxuICogW1tFeGNhbGlidXJHcmFwaGljc0NvbnRleHRdXS4gVGhpcyBpcyB1c2VmdWwgZm9yIGdlbmVyYXRpbmcgY3VzdG9tIGltYWdlcyB1c2luZyB0aGUgMkQgY2FudmFzIGFwaS5cclxuICpcclxuICogSW1wbGVtZW50b3JzIG11c3QgaW1wbGVtZW5ldCB0aGUgW1tSYXN0ZXIuZXhlY3V0ZV1dIG1ldGhvZCB0byByYXN0ZXJpemUgdGhlaXIgZHJhd2luZy5cclxuICovXHJcbmNsYXNzIFJhc3RlciBleHRlbmRzIEdyYXBoaWMge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fc21vb3RoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY29sb3IgPSB3YXRjaChDb2xvci5CbGFjaywgKCkgPT4gdGhpcy5mbGFnRGlydHkoKSk7XHJcbiAgICAgICAgdGhpcy5fbGluZVdpZHRoID0gMTtcclxuICAgICAgICB0aGlzLl9saW5lRGFzaCA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSAwO1xyXG4gICAgICAgIGlmIChvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29sb3IgPSAoX2EgPSBvcHRpb25zLmNvbG9yKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBDb2xvci5CbGFjaztcclxuICAgICAgICAgICAgdGhpcy5zdHJva2VDb2xvciA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdHJva2VDb2xvcjtcclxuICAgICAgICAgICAgdGhpcy5zbW9vdGhpbmcgPSAoX2IgPSBvcHRpb25zLnNtb290aGluZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5zbW9vdGhpbmc7XHJcbiAgICAgICAgICAgIHRoaXMubGluZVdpZHRoID0gKF9jID0gb3B0aW9ucy5saW5lV2lkdGgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMubGluZVdpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmxpbmVEYXNoID0gKF9kID0gb3B0aW9ucy5saW5lRGFzaCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpcy5saW5lRGFzaDtcclxuICAgICAgICAgICAgdGhpcy5wYWRkaW5nID0gKF9lID0gb3B0aW9ucy5wYWRkaW5nKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0aGlzLnBhZGRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2JpdG1hcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIC8vIGdldCB0aGUgZGVmYXVsdCBjYW52YXMgd2lkdGgvaGVpZ2h0IGFzIGEgZmFsbGJhY2tcclxuICAgICAgICBjb25zdCBiaXRtYXBXaWR0aCA9IChfZiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy53aWR0aCkgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdGhpcy5fYml0bWFwLndpZHRoO1xyXG4gICAgICAgIGNvbnN0IGJpdG1hcEhlaWdodCA9IChfZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWlnaHQpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IHRoaXMuX2JpdG1hcC5oZWlnaHQ7XHJcbiAgICAgICAgLy8gUmFzdGVycyB1c2UgcG93ZXIgb2YgdHdvIGltYWdlcyBhcyBhbiBvcHRpbWl6YXRpb24gZm9yIHdlYmdsXHJcbiAgICAgICAgdGhpcy53aWR0aCA9IGVuc3VyZVBvd2VyT2ZUd28oYml0bWFwV2lkdGgpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gZW5zdXJlUG93ZXJPZlR3byhiaXRtYXBIZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IG1heWJlQ3R4ID0gdGhpcy5fYml0bWFwLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgaWYgKCFtYXliZUN0eCkge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCAyZCBjYW52YXMgZHJhd2luZywgY2Fubm90IGNyZWF0ZSBSYXN0ZXIgZ3JhcGhpYycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fY3R4ID0gbWF5YmVDdHg7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xvbmVSYXN0ZXJPcHRpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yID8gdGhpcy5jb2xvci5jbG9uZSgpIDogbnVsbCxcclxuICAgICAgICAgICAgc3Ryb2tlQ29sb3I6IHRoaXMuc3Ryb2tlQ29sb3IgPyB0aGlzLnN0cm9rZUNvbG9yLmNsb25lKCkgOiBudWxsLFxyXG4gICAgICAgICAgICBzbW9vdGhpbmc6IHRoaXMuc21vb3RoaW5nLFxyXG4gICAgICAgICAgICBsaW5lV2lkdGg6IHRoaXMubGluZVdpZHRoLFxyXG4gICAgICAgICAgICBsaW5lRGFzaDogdGhpcy5saW5lRGFzaCxcclxuICAgICAgICAgICAgcGFkZGluZzogdGhpcy5wYWRkaW5nXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBncmFwaGljIGlzIGRpcnR5LCB0aGlzIG1lYW5zIHRoZXJlIGFyZSBjaGFuZ2VzIHRoYXQgaGF2ZW4ndCBiZWVuIHJlLXJhc3Rlcml6ZWRcclxuICAgICAqL1xyXG4gICAgZ2V0IGRpcnR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJ0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmxhZ3MgdGhlIGdyYXBoaWMgYXMgZGlydHksIG1lYW5pbmcgaXQgbXVzdCBiZSByZS1yYXN0ZXJpemVkIGJlZm9yZSBkcmF3LlxyXG4gICAgICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFueSB0aW1lIHRoZSBncmFwaGljcyBzdGF0ZSBjaGFuZ2VzIHN1Y2ggdGhhdCBpdCBhZmZlY3RzIHRoZSBvdXRwdXRlZCBkcmF3aW5nXHJcbiAgICAgKi9cclxuICAgIGZsYWdEaXJ0eSgpIHtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCB3aWR0aCBvZiB0aGUgUmFzdGVyIGdyYXBoaWMuIFNldHRpbmcgdGhlIHdpZHRoIHdpbGwgY2F1c2UgdGhlIHJhc3RlclxyXG4gICAgICogdG8gYmUgZmxhZ2dlZCBkaXJ0eSBjYXVzaW5nIGEgcmUtcmFzdGVyIG9uIHRoZSBuZXh0IGRyYXcuXHJcbiAgICAgKlxyXG4gICAgICogQW55IGBwYWRkaW5nYHMgc2V0IHdpbGwgYmUgZmFjdG9yZWQgaW50byB0aGUgd2lkdGhcclxuICAgICAqL1xyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRUb3RhbFdpZHRoKCk7XHJcbiAgICB9XHJcbiAgICBzZXQgd2lkdGgodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9iaXRtYXAud2lkdGggPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbFdpZHRoID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IGhlaWdodCBvZiB0aGUgUmFzdGVyIGdyYXBoaWMuIFNldHRpbmcgdGhlIGhlaWdodCB3aWxsIGNhdXNlIHRoZSByYXN0ZXJcclxuICAgICAqIHRvIGJlIGZsYWdnZWQgZGlydHkgY2F1c2luZyBhIHJlLXJhc3RlciBvbiB0aGUgbmV4dCBkcmF3LlxyXG4gICAgICpcclxuICAgICAqIEFueSBgcGFkZGluZ2Agc2V0IHdpbGwgYmUgZmFjdG9yZWQgaW50byB0aGUgaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRvdGFsSGVpZ2h0KCk7XHJcbiAgICB9XHJcbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fYml0bWFwLmhlaWdodCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsSGVpZ2h0ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgIH1cclxuICAgIF9nZXRUb3RhbFdpZHRoKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX29yaWdpbmFsV2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX2JpdG1hcC53aWR0aCkgKyB0aGlzLnBhZGRpbmcgKiAyO1xyXG4gICAgfVxyXG4gICAgX2dldFRvdGFsSGVpZ2h0KCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX29yaWdpbmFsSGVpZ2h0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLl9iaXRtYXAuaGVpZ2h0KSArIHRoaXMucGFkZGluZyAqIDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxvY2FsIGJvdW5kcyBvZiB0aGUgUmFzdGVyIGluY2x1ZGluZyB0aGUgcGFkZGluZ1xyXG4gICAgICovXHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94LmZyb21EaW1lbnNpb24odGhpcy5fZ2V0VG90YWxXaWR0aCgpICogdGhpcy5zY2FsZS54LCB0aGlzLl9nZXRUb3RhbEhlaWdodCgpICogdGhpcy5zY2FsZS55LCBWZWN0b3IuWmVybyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc21vb3RoaW5nIChhbnRpLWFsaWFzaW5nIG9mIHRoZSBncmFwaGljKS4gU2V0dGluZyB0aGUgaGVpZ2h0IHdpbGwgY2F1c2UgdGhlIHJhc3RlclxyXG4gICAgICogdG8gYmUgZmxhZ2dlZCBkaXJ0eSBjYXVzaW5nIGEgcmUtcmFzdGVyIG9uIHRoZSBuZXh0IGRyYXcuXHJcbiAgICAgKi9cclxuICAgIGdldCBzbW9vdGhpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Ntb290aGluZztcclxuICAgIH1cclxuICAgIHNldCBzbW9vdGhpbmcodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9zbW9vdGhpbmcgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGZpbGxTdHlsZSBvZiB0aGUgUmFzdGVyIGdyYXBoaWMuIFNldHRpbmcgdGhlIGZpbGxTdHlsZSB3aWxsIGNhdXNlIHRoZSByYXN0ZXIgdG8gYmVcclxuICAgICAqIGZsYWdnZWQgZGlydHkgY2F1c2luZyBhIHJlLXJhc3RlciBvbiB0aGUgbmV4dCBkcmF3LlxyXG4gICAgICovXHJcbiAgICBnZXQgY29sb3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbG9yO1xyXG4gICAgfVxyXG4gICAgc2V0IGNvbG9yKHZhbHVlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICghKChfYSA9IHRoaXMuX2NvbG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXF1YWwodmFsdWUpKSkge1xyXG4gICAgICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jb2xvciA9IHdhdGNoKHZhbHVlLCAoKSA9PiB0aGlzLmZsYWdEaXJ0eSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBzdHJva2VTdHlsZSBvZiB0aGUgUmFzdGVyIGdyYXBoaWMuIFNldHRpbmcgdGhlIHN0cm9rZVN0eWxlIHdpbGwgY2F1c2UgdGhlIHJhc3RlciB0byBiZVxyXG4gICAgICogZmxhZ2dlZCBkaXJ0eSBjYXVzaW5nIGEgcmUtcmFzdGVyIG9uIHRoZSBuZXh0IGRyYXcuXHJcbiAgICAgKi9cclxuICAgIGdldCBzdHJva2VDb2xvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3Ryb2tlQ29sb3I7XHJcbiAgICB9XHJcbiAgICBzZXQgc3Ryb2tlQ29sb3IodmFsdWUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5fc3Ryb2tlQ29sb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lcXVhbCh2YWx1ZSkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3N0cm9rZUNvbG9yID0gd2F0Y2godmFsdWUsICgpID0+IHRoaXMuZmxhZ0RpcnR5KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGxpbmUgd2lkdGggb2YgdGhlIFJhc3RlciBncmFwaGljLiBTZXR0aW5nIHRoZSBsaW5lV2lkdGggd2lsbCBjYXVzZSB0aGUgcmFzdGVyIHRvIGJlXHJcbiAgICAgKiBmbGFnZ2VkIGRpcnR5IGNhdXNpbmcgYSByZS1yYXN0ZXIgb24gdGhlIG5leHQgZHJhdy5cclxuICAgICAqL1xyXG4gICAgZ2V0IGxpbmVXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZVdpZHRoO1xyXG4gICAgfVxyXG4gICAgc2V0IGxpbmVXaWR0aCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2xpbmVXaWR0aCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgbGluZURhc2goKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVEYXNoO1xyXG4gICAgfVxyXG4gICAgc2V0IGxpbmVEYXNoKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbGluZURhc2ggPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhZGRpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZGRpbmc7XHJcbiAgICB9XHJcbiAgICBzZXQgcGFkZGluZyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3BhZGRpbmcgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSYXN0ZXJpemUgdGhlIGdyYXBoaWMgdG8gYSBiaXRtYXAgbWFraW5nIGl0IHVzdWFibGUgYXMgaW4gZXhjYWxpYnVyLiBSYXN0ZXJpemUgaXMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgaWZcclxuICAgICAqIHRoZSBncmFwaGljIGlzIFtbUmFzdGVyLmRpcnR5XV0gb24gdGhlIG5leHQgW1tHcmFwaGljLmRyYXddXSBjYWxsXHJcbiAgICAgKi9cclxuICAgIHJhc3Rlcml6ZSgpIHtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fZ2V0VG90YWxXaWR0aCgpLCB0aGlzLl9nZXRUb3RhbEhlaWdodCgpKTtcclxuICAgICAgICB0aGlzLl9jdHguc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuX2FwcGx5UmFzdGVyUHJvcGVyaXRlcyh0aGlzLl9jdHgpO1xyXG4gICAgICAgIHRoaXMuZXhlY3V0ZSh0aGlzLl9jdHgpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgLy8gVGhlIHdlYmdsIHRleHR1cmUgbmVlZHMgdG8gYmUgdXBkYXRlZCBpZiBpdCBleGlzdHMgYWZ0ZXIgYSByYXN0ZXIgY3ljbGVcclxuICAgICAgICBUZXh0dXJlTG9hZGVyLmxvYWQodGhpcy5fYml0bWFwLCB0cnVlKTtcclxuICAgIH1cclxuICAgIF9hcHBseVJhc3RlclByb3Blcml0ZXMoY3R4KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgdGhpcy5fYml0bWFwLndpZHRoID0gdGhpcy5fZ2V0VG90YWxXaWR0aCgpO1xyXG4gICAgICAgIHRoaXMuX2JpdG1hcC5oZWlnaHQgPSB0aGlzLl9nZXRUb3RhbEhlaWdodCgpO1xyXG4gICAgICAgIGN0eC50cmFuc2xhdGUodGhpcy5wYWRkaW5nLCB0aGlzLnBhZGRpbmcpO1xyXG4gICAgICAgIGN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB0aGlzLnNtb290aGluZztcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XHJcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKChfYSA9IHRoaXMubGluZURhc2gpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGN0eC5nZXRMaW5lRGFzaCgpKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSAoX2IgPSB0aGlzLnN0cm9rZUNvbG9yKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gKF9jID0gdGhpcy5jb2xvcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICBfZHJhd0ltYWdlKGV4LCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFzdGVyaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4LmRyYXdJbWFnZSh0aGlzLl9iaXRtYXAsIHgsIHkpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ2FudmFzLnRzXG5cclxuLyoqXHJcbiAqIEEgY2FudmFzIFtbR3JhcGhpY11dIHRvIHByb3ZpZGUgYW4gYWRhcHRlciBiZXR3ZWVuIHRoZSAyRCBDYW52YXMgQVBJIGFuZCB0aGUgW1tFeGNhbGlidXJHcmFwaGljc0NvbnRleHRdXS5cclxuICpcclxuICogVGhlIFtbQ2FudmFzXV0gd29ya3MgYnkgcmUtcmFzdGVyaW5nIGEgZHJhdyBoYW5kbGVyIHRvIGEgSFRNTENhbnZhc0VsZW1lbnQgZm9yIGV2ZXJ5IGRyYXcgd2hpY2ggaXMgdGhlbiBwYXNzZWRcclxuICogdG8gdGhlIFtbRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0XV0gaW1wbGVtZW50YXRpb24gYXMgYSByZW5kZXJlZCBpbWFnZS5cclxuICpcclxuICogKipMb3cgcGVyZm9ybWFuY2UgQVBJKipcclxuICovXHJcbmNsYXNzIENhbnZhcyBleHRlbmRzIFJhc3RlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfb3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKF9vcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9vcHRpb25zID0gX29wdGlvbnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgMkQgZ3JhcGhpY3MgY29udGV4dCBvZiB0aGlzIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBnZXQgY3R4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHg7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENhbnZhcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fb3B0aW9ucyksIHRoaXMuY2xvbmVHcmFwaGljT3B0aW9ucygpKSwgdGhpcy5jbG9uZVJhc3Rlck9wdGlvbnMoKSkpO1xyXG4gICAgfVxyXG4gICAgZXhlY3V0ZShjdHgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHJhdykge1xyXG4gICAgICAgICAgICAoX2IgPSB0aGlzLl9vcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZHJhdyhjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuY2FjaGUpIHtcclxuICAgICAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FdmVudHMudHNcbnZhciBFdmVudFR5cGVzO1xyXG4oZnVuY3Rpb24gKEV2ZW50VHlwZXMpIHtcclxuICAgIEV2ZW50VHlwZXNbXCJLaWxsXCJdID0gXCJraWxsXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUHJlS2lsbFwiXSA9IFwicHJla2lsbFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvc3RLaWxsXCJdID0gXCJwb3N0a2lsbFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlByZURyYXdcIl0gPSBcInByZWRyYXdcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb3N0RHJhd1wiXSA9IFwicG9zdGRyYXdcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQcmVEZWJ1Z0RyYXdcIl0gPSBcInByZWRlYnVnZHJhd1wiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvc3REZWJ1Z0RyYXdcIl0gPSBcInBvc3RkZWJ1Z2RyYXdcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQcmVVcGRhdGVcIl0gPSBcInByZXVwZGF0ZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvc3RVcGRhdGVcIl0gPSBcInBvc3R1cGRhdGVcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQcmVGcmFtZVwiXSA9IFwicHJlZnJhbWVcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb3N0RnJhbWVcIl0gPSBcInBvc3RmcmFtZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlByZUNvbGxpc2lvblwiXSA9IFwicHJlY29sbGlzaW9uXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiQ29sbGlzaW9uU3RhcnRcIl0gPSBcImNvbGxpc2lvbnN0YXJ0XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiQ29sbGlzaW9uRW5kXCJdID0gXCJjb2xsaXNpb25lbmRcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb3N0Q29sbGlzaW9uXCJdID0gXCJwb3N0Y29sbGlzaW9uXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiSW5pdGlhbGl6ZVwiXSA9IFwiaW5pdGlhbGl6ZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkFjdGl2YXRlXCJdID0gXCJhY3RpdmF0ZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkRlYWN0aXZhdGVcIl0gPSBcImRlYWN0aXZhdGVcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJFeGl0Vmlld3BvcnRcIl0gPSBcImV4aXR2aWV3cG9ydFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkVudGVyVmlld3BvcnRcIl0gPSBcImVudGVydmlld3BvcnRcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJFeGl0VHJpZ2dlclwiXSA9IFwiZXhpdFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkVudGVyVHJpZ2dlclwiXSA9IFwiZW50ZXJcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJDb25uZWN0XCJdID0gXCJjb25uZWN0XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiRGlzY29ubmVjdFwiXSA9IFwiZGlzY29ubmVjdFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkJ1dHRvblwiXSA9IFwiYnV0dG9uXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiQXhpc1wiXSA9IFwiYXhpc1wiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlN1YnNjcmliZVwiXSA9IFwic3Vic2NyaWJlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiVW5zdWJzY3JpYmVcIl0gPSBcInVuc3Vic2NyaWJlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiVmlzaWJsZVwiXSA9IFwidmlzaWJsZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkhpZGRlblwiXSA9IFwiaGlkZGVuXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiU3RhcnRcIl0gPSBcInN0YXJ0XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiU3RvcFwiXSA9IFwic3RvcFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJVcFwiXSA9IFwicG9pbnRlcnVwXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlckRvd25cIl0gPSBcInBvaW50ZXJkb3duXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlck1vdmVcIl0gPSBcInBvaW50ZXJtb3ZlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlckVudGVyXCJdID0gXCJwb2ludGVyZW50ZXJcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyTGVhdmVcIl0gPSBcInBvaW50ZXJsZWF2ZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJDYW5jZWxcIl0gPSBcInBvaW50ZXJjYW5jZWxcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyV2hlZWxcIl0gPSBcInBvaW50ZXJ3aGVlbFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlVwXCJdID0gXCJ1cFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkRvd25cIl0gPSBcImRvd25cIjtcclxuICAgIEV2ZW50VHlwZXNbXCJNb3ZlXCJdID0gXCJtb3ZlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiRW50ZXJcIl0gPSBcImVudGVyXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiTGVhdmVcIl0gPSBcImxlYXZlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiQ2FuY2VsXCJdID0gXCJjYW5jZWxcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJXaGVlbFwiXSA9IFwid2hlZWxcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQcmVzc1wiXSA9IFwicHJlc3NcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJSZWxlYXNlXCJdID0gXCJyZWxlYXNlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiSG9sZFwiXSA9IFwiaG9sZFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJEcmFnU3RhcnRcIl0gPSBcInBvaW50ZXJkcmFnc3RhcnRcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyRHJhZ0VuZFwiXSA9IFwicG9pbnRlcmRyYWdlbmRcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyRHJhZ0VudGVyXCJdID0gXCJwb2ludGVyZHJhZ2VudGVyXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlckRyYWdMZWF2ZVwiXSA9IFwicG9pbnRlcmRyYWdsZWF2ZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJEcmFnTW92ZVwiXSA9IFwicG9pbnRlcmRyYWdtb3ZlXCI7XHJcbn0pKEV2ZW50VHlwZXMgfHwgKEV2ZW50VHlwZXMgPSB7fSkpO1xyXG4vKipcclxuICogQmFzZSBldmVudCB0eXBlIGluIEV4Y2FsaWJ1ciB0aGF0IGFsbCBvdGhlciBldmVudCB0eXBlcyBkZXJpdmUgZnJvbS4gTm90IGFsbCBldmVudCB0eXBlcyBhcmUgdGhyb3duIG9uIGFsbCBFeGNhbGlidXIgZ2FtZSBvYmplY3RzLFxyXG4gKiBzb21lIGV2ZW50cyBhcmUgdW5pcXVlIHRvIGEgdHlwZSwgb3RoZXJzIGFyZSBub3QuXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fYnViYmxlcyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElmIHNldCB0byBmYWxzZSwgcHJldmVudHMgZXZlbnQgZnJvbSBwcm9wYWdhdGluZyB0byBvdGhlciBhY3RvcnMuIElmIHRydWUgaXQgd2lsbCBiZSBwcm9wYWdhdGVkXHJcbiAgICAgKiB0byBhbGwgYWN0b3JzIHRoYXQgYXBwbHkuXHJcbiAgICAgKi9cclxuICAgIGdldCBidWJibGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idWJibGVzO1xyXG4gICAgfVxyXG4gICAgc2V0IGJ1YmJsZXModmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9idWJibGVzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByZXZlbnRzIGV2ZW50IGZyb20gYnViYmxpbmdcclxuICAgICAqL1xyXG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuYnViYmxlcyA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ2tpbGwnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzIHdoZW4gaXQgaXMga2lsbGVkLiBUaGUgdGFyZ2V0IGlzIHRoZSBhY3RvciB0aGF0IHdhcyBraWxsZWQuXHJcbiAqL1xyXG5jbGFzcyBLaWxsRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwcmVraWxsJyBldmVudCBpcyBlbWl0dGVkIGRpcmVjdGx5IGJlZm9yZSBhbiBhY3RvciBpcyBraWxsZWQuXHJcbiAqL1xyXG5jbGFzcyBQcmVLaWxsRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwb3N0a2lsbCcgZXZlbnQgaXMgZW1pdHRlZCBkaXJlY3RseSBhZnRlciB0aGUgYWN0b3IgaXMga2lsbGVkLlxyXG4gKi9cclxuY2xhc3MgUG9zdEtpbGxFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3N0YXJ0JyBldmVudCBpcyBlbWl0dGVkIG9uIGVuZ2luZSB3aGVuIGhhcyBzdGFydGVkIGFuZCBpcyByZWFkeSBmb3IgaW50ZXJhY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBHYW1lU3RhcnRFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3N0b3AnIGV2ZW50IGlzIGVtaXR0ZWQgb24gZW5naW5lIHdoZW4gaGFzIGJlZW4gc3RvcHBlZCBhbmQgd2lsbCBubyBsb25nZXIgdGFrZSBpbnB1dCwgdXBkYXRlIG9yIGRyYXcuXHJcbiAqL1xyXG5jbGFzcyBHYW1lU3RvcEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSAncHJlZHJhdycgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMsIHNjZW5lcywgYW5kIGVuZ2luZSBiZWZvcmUgZHJhd2luZyBzdGFydHMuIEFjdG9ycycgcHJlZHJhdyBoYXBwZW5zIGluc2lkZSB0aGVpciBncmFwaGljc1xyXG4gKiB0cmFuc2Zvcm0gc28gdGhhdCBhbGwgZHJhd2luZyB0YWtlcyBwbGFjZSB3aXRoIHRoZSBhY3RvciBhcyB0aGUgb3JpZ2luLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgUHJlRHJhd0V2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGN0eCwgZGVsdGEsIHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jdHggPSBjdHg7XHJcbiAgICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3Bvc3RkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGFmdGVyIGRyYXdpbmcgZmluaXNoZXMuIEFjdG9ycycgcG9zdGRyYXcgaGFwcGVucyBpbnNpZGUgdGhlaXIgZ3JhcGhpY3NcclxuICogdHJhbnNmb3JtIHNvIHRoYXQgYWxsIGRyYXdpbmcgdGFrZXMgcGxhY2Ugd2l0aCB0aGUgYWN0b3IgYXMgdGhlIG9yaWdpbi5cclxuICpcclxuICovXHJcbmNsYXNzIFBvc3REcmF3RXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoY3R4LCBkZWx0YSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICB0aGlzLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSAncHJlZGVidWdkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGJlZm9yZSBkZWJ1ZyBkcmF3aW5nIHN0YXJ0cy5cclxuICovXHJcbmNsYXNzIFByZURlYnVnRHJhd0V2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGN0eCwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwb3N0ZGVidWdkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGFmdGVyIGRlYnVnIGRyYXdpbmcgc3RhcnRzLlxyXG4gKi9cclxuY2xhc3MgUG9zdERlYnVnRHJhd0V2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGN0eCwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwcmV1cGRhdGUnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGNhbWVyYSwgYW5kIGVuZ2luZSBiZWZvcmUgdGhlIHVwZGF0ZSBzdGFydHMuXHJcbiAqL1xyXG5jbGFzcyBQcmVVcGRhdGVFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIGRlbHRhLCB0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwb3N0dXBkYXRlJyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBjYW1lcmEsIGFuZCBlbmdpbmUgYWZ0ZXIgdGhlIHVwZGF0ZSBlbmRzLlxyXG4gKi9cclxuY2xhc3MgUG9zdFVwZGF0ZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgZGVsdGEsIHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3ByZWZyYW1lJyBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBlbmdpbmUsIGJlZm9yZSB0aGUgZnJhbWUgYmVnaW5zLlxyXG4gKi9cclxuY2xhc3MgUHJlRnJhbWVFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIHByZXZTdGF0cykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgdGhpcy5wcmV2U3RhdHMgPSBwcmV2U3RhdHM7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBlbmdpbmU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSAncG9zdGZyYW1lJyBldmVudCBpcyBlbWl0dGVkIG9uIHRoZSBlbmdpbmUsIGFmdGVyIGEgZnJhbWUgZW5kcy5cclxuICovXHJcbmNsYXNzIFBvc3RGcmFtZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgc3RhdHMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuc3RhdHMgPSBzdGF0cztcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGVuZ2luZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgcmVjZWl2ZWQgd2hlbiBhIGdhbWVwYWQgaXMgY29ubmVjdGVkIHRvIEV4Y2FsaWJ1ci4gW1tHYW1lcGFkc11dIHJlY2VpdmVzIHRoaXMgZXZlbnQuXHJcbiAqL1xyXG5jbGFzcyBHYW1lcGFkQ29ubmVjdEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4LCBnYW1lcGFkKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5nYW1lcGFkID0gZ2FtZXBhZDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGdhbWVwYWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHJlY2VpdmVkIHdoZW4gYSBnYW1lcGFkIGlzIGRpc2Nvbm5lY3RlZCBmcm9tIEV4Y2FsaWJ1ci4gW1tHYW1lcGFkc11dIHJlY2VpdmVzIHRoaXMgZXZlbnQuXHJcbiAqL1xyXG5jbGFzcyBHYW1lcGFkRGlzY29ubmVjdEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGluZGV4LCBnYW1lcGFkKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5nYW1lcGFkID0gZ2FtZXBhZDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGdhbWVwYWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdhbWVwYWQgYnV0dG9uIGV2ZW50LiBTZWUgW1tHYW1lcGFkc11dIGZvciBpbmZvcm1hdGlvbiBvbiByZXNwb25kaW5nIHRvIGNvbnRyb2xsZXIgaW5wdXQuIFtbR2FtZXBhZF1dIGluc3RhbmNlcyByZWNlaXZlIHRoaXMgZXZlbnQ7XHJcbiAqL1xyXG5jbGFzcyBHYW1lcGFkQnV0dG9uRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYnV0dG9uICBUaGUgR2FtZXBhZCBidXR0b25cclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgIEEgbnVtZXJpYyB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYnV0dG9uLCB2YWx1ZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdhbWVwYWQgYXhpcyBldmVudC4gU2VlIFtbR2FtZXBhZHNdXSBmb3IgaW5mb3JtYXRpb24gb24gcmVzcG9uZGluZyB0byBjb250cm9sbGVyIGlucHV0LiBbW0dhbWVwYWRdXSBpbnN0YW5jZXMgcmVjZWl2ZSB0aGlzIGV2ZW50O1xyXG4gKi9cclxuY2xhc3MgR2FtZXBhZEF4aXNFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBheGlzICBUaGUgR2FtZXBhZCBheGlzXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgQSBudW1lcmljIHZhbHVlIGJldHdlZW4gLTEgYW5kIDFcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYXhpcywgdmFsdWUsIHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5heGlzID0gYXhpcztcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFN1YnNjcmliZSBldmVudCB0aHJvd24gd2hlbiBoYW5kbGVycyBmb3IgZXZlbnRzIG90aGVyIHRoYW4gc3Vic2NyaWJlIGFyZSBhZGRlZC4gTWV0YSBldmVudCB0aGF0IGlzIHJlY2VpdmVkIGJ5XHJcbiAqIFtbRXZlbnREaXNwYXRjaGVyfGV2ZW50IGRpc3BhdGNoZXJzXV0uXHJcbiAqL1xyXG5jbGFzcyBTdWJzY3JpYmVFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0b3BpYywgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50b3BpYyA9IHRvcGljO1xyXG4gICAgICAgIHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFVuc3Vic2NyaWJlIGV2ZW50IHRocm93biB3aGVuIGhhbmRsZXJzIGZvciBldmVudHMgb3RoZXIgdGhhbiB1bnN1YnNjcmliZSBhcmUgcmVtb3ZlZC4gTWV0YSBldmVudCB0aGF0IGlzIHJlY2VpdmVkIGJ5XHJcbiAqIFtbRXZlbnREaXNwYXRjaGVyfGV2ZW50IGRpc3BhdGNoZXJzXV0uXHJcbiAqL1xyXG5jbGFzcyBVbnN1YnNjcmliZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRvcGljLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRvcGljID0gdG9waWM7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgcmVjZWl2ZWQgYnkgdGhlIFtbRW5naW5lXV0gd2hlbiB0aGUgYnJvd3NlciB3aW5kb3cgaXMgdmlzaWJsZSBvbiBhIHNjcmVlbi5cclxuICovXHJcbmNsYXNzIFZpc2libGVFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCByZWNlaXZlZCBieSB0aGUgW1tFbmdpbmVdXSB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBpcyBoaWRkZW4gZnJvbSBhbGwgc2NyZWVucy5cclxuICovXHJcbmNsYXNzIEhpZGRlbkV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yfGFjdG9yXV0gd2hlbiBhIGNvbGxpc2lvbiB3aWxsIG9jY3VyIHRoaXMgZnJhbWUgaWYgaXQgcmVzb2x2ZXNcclxuICovXHJcbmNsYXNzIFByZUNvbGxpc2lvbkV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGFjdG9yICAgICAgICAgVGhlIGFjdG9yIHRoZSBldmVudCB3YXMgdGhyb3duIG9uXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgICAgICAgICBUaGUgYWN0b3IgdGhhdCB3aWxsIGNvbGxpZGVkIHdpdGggdGhlIGN1cnJlbnQgYWN0b3JcclxuICAgICAqIEBwYXJhbSBzaWRlICAgICAgICAgIFRoZSBzaWRlIHRoYXQgd2lsbCBiZSBjb2xsaWRlZCB3aXRoIHRoZSBjdXJyZW50IGFjdG9yXHJcbiAgICAgKiBAcGFyYW0gaW50ZXJzZWN0aW9uICBJbnRlcnNlY3Rpb24gdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFjdG9yLCBvdGhlciwgc2lkZSwgaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcclxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3RvcnxhY3Rvcl1dIHdoZW4gYSBjb2xsaXNpb24gaGFzIGJlZW4gcmVzb2x2ZWQgKGJvZHkgcmVhY3RlZCkgdGhpcyBmcmFtZVxyXG4gKi9cclxuY2xhc3MgUG9zdENvbGxpc2lvbkV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGFjdG9yICAgICAgICAgVGhlIGFjdG9yIHRoZSBldmVudCB3YXMgdGhyb3duIG9uXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgICAgICAgICBUaGUgYWN0b3IgdGhhdCBkaWQgY29sbGlkZSB3aXRoIHRoZSBjdXJyZW50IGFjdG9yXHJcbiAgICAgKiBAcGFyYW0gc2lkZSAgICAgICAgICBUaGUgc2lkZSB0aGF0IGRpZCBjb2xsaWRlIHdpdGggdGhlIGN1cnJlbnQgYWN0b3JcclxuICAgICAqIEBwYXJhbSBpbnRlcnNlY3Rpb24gIEludGVyc2VjdGlvbiB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWN0b3IsIG90aGVyLCBzaWRlLCBpbnRlcnNlY3Rpb24pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xyXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICB9XHJcbiAgICBnZXQgYWN0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgc2V0IGFjdG9yKGFjdG9yKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDb250YWN0U3RhcnRFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIG90aGVyLCBjb250YWN0KSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgIHRoaXMuY29udGFjdCA9IGNvbnRhY3Q7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ29udGFjdEVuZEV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgb3RoZXIpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ29sbGlzaW9uUHJlU29sdmVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIG90aGVyLCBzaWRlLCBpbnRlcnNlY3Rpb24sIGNvbnRhY3QpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgdGhpcy5zaWRlID0gc2lkZTtcclxuICAgICAgICB0aGlzLmludGVyc2VjdGlvbiA9IGludGVyc2VjdGlvbjtcclxuICAgICAgICB0aGlzLmNvbnRhY3QgPSBjb250YWN0O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbGxpc2lvblBvc3RTb2x2ZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgb3RoZXIsIHNpZGUsIGludGVyc2VjdGlvbiwgY29udGFjdCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xyXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuY29udGFjdCA9IGNvbnRhY3Q7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHRocm93biB0aGUgZmlyc3QgdGltZSBhbiBbW0FjdG9yfGFjdG9yXV0gY29sbGlkZXMgd2l0aCBhbm90aGVyLCBhZnRlciBhbiBhY3RvciBpcyBpbiBjb250YWN0IG5vcm1hbCBjb2xsaXNpb24gZXZlbnRzIGFyZSBmaXJlZC5cclxuICovXHJcbmNsYXNzIENvbGxpc2lvblN0YXJ0RXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdG9yXHJcbiAgICAgKiBAcGFyYW0gb3RoZXJcclxuICAgICAqIEBwYXJhbSBjb250YWN0XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFjdG9yLCBvdGhlciwgY29udGFjdCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgIHRoaXMuY29udGFjdCA9IGNvbnRhY3Q7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgIH1cclxuICAgIGdldCBhY3RvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBzZXQgYWN0b3IoYWN0b3IpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCB0aHJvd24gd2hlbiB0aGUgW1tBY3RvcnxhY3Rvcl1dIGlzIG5vIGxvbmdlciBjb2xsaWRpbmcgd2l0aCBhbm90aGVyXHJcbiAqL1xyXG5jbGFzcyBDb2xsaXNpb25FbmRFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGFjdG9yLCBvdGhlcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICB9XHJcbiAgICBnZXQgYWN0b3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgc2V0IGFjdG9yKGFjdG9yKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgdGhyb3duIG9uIGFuIFtbQWN0b3JdXSBhbmQgYSBbW1NjZW5lXV0gb25seSBvbmNlIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlIGNhbGxcclxuICovXHJcbmNsYXNzIEluaXRpYWxpemVFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBlbmdpbmUgIFRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZW5naW5lXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgdGhyb3duIG9uIGEgW1tTY2VuZV1dIG9uIGFjdGl2YXRpb25cclxuICovXHJcbmNsYXNzIEFjdGl2YXRlRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb2xkU2NlbmUgIFRoZSByZWZlcmVuY2UgdG8gdGhlIG9sZCBzY2VuZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvbGRTY2VuZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm9sZFNjZW5lID0gb2xkU2NlbmU7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHRocm93biBvbiBhIFtbU2NlbmVdXSBvbiBkZWFjdGl2YXRpb25cclxuICovXHJcbmNsYXNzIERlYWN0aXZhdGVFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBuZXdTY2VuZSAgVGhlIHJlZmVyZW5jZSB0byB0aGUgbmV3IHNjZW5lXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5ld1NjZW5lLCB0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubmV3U2NlbmUgPSBuZXdTY2VuZTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgdGhyb3duIG9uIGFuIFtbQWN0b3JdXSB3aGVuIGl0IGNvbXBsZXRlbHkgbGVhdmVzIHRoZSBzY3JlZW4uXHJcbiAqL1xyXG5jbGFzcyBFeGl0Vmlld1BvcnRFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3Rvcl1dIHdoZW4gaXQgY29tcGxldGVseSBsZWF2ZXMgdGhlIHNjcmVlbi5cclxuICovXHJcbmNsYXNzIEVudGVyVmlld1BvcnRFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEVudGVyVHJpZ2dlckV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgYWN0b3IpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBFeGl0VHJpZ2dlckV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgYWN0b3IpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuYWN0b3IgPSBhY3RvcjtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0V2ZW50RGlzcGF0Y2hlci50c1xuXHJcbmNsYXNzIEV2ZW50RGlzcGF0Y2hlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB0YXJnZXQgIFRoZSBvYmplY3QgdGhhdCB3aWxsIGJlIHRoZSByZWNpcGllbnQgb2YgZXZlbnRzIGZyb20gdGhpcyBldmVudCBkaXNwYXRjaGVyXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5fd2lyZWRFdmVudERpc3BhdGNoZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYW55IGV4aXN0aW5nIGhhbmRsZXJzIG9yIHdpcmVkIGV2ZW50IGRpc3BhdGNoZXJzIG9uIHRoaXMgZXZlbnQgZGlzcGF0Y2hlclxyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3dpcmVkRXZlbnREaXNwYXRjaGVycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0cyBhbiBldmVudCBmb3IgdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gcHVibGlzaFxyXG4gICAgICogQHBhcmFtIGV2ZW50ICAgICAgT3B0aW9uYWxseSBwYXNzIGFuIGV2ZW50IGRhdGEgb2JqZWN0IHRvIHRoZSBoYW5kbGVyXHJcbiAgICAgKi9cclxuICAgIGVtaXQoZXZlbnROYW1lLCBldmVudCkge1xyXG4gICAgICAgIGlmICghZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgIC8vIGtleSBub3QgbWFwcGVkXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXZlbnROYW1lID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xyXG4gICAgICAgIGlmICghZXZlbnQpIHtcclxuICAgICAgICAgICAgZXZlbnQgPSBuZXcgR2FtZUV2ZW50KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmICghZXZlbnQudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgIC8vIHBhc3NcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGksIGxlbjtcclxuICAgICAgICBpZiAodGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSkge1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgbGVuID0gdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdW2ldLmNhbGwodGFyZ2V0LCBldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgbGVuID0gdGhpcy5fd2lyZWRFdmVudERpc3BhdGNoZXJzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnNbaV0uZW1pdChldmVudE5hbWUsIGV2ZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN1YnNjcmliZSBhbiBldmVudCBoYW5kbGVyIHRvIGEgcGFydGljdWxhciBldmVudCBuYW1lLCBtdWx0aXBsZSBoYW5kbGVycyBwZXIgZXZlbnQgbmFtZSBhcmUgYWxsb3dlZC5cclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG9cclxuICAgICAqIEBwYXJhbSBoYW5kbGVyICAgIFRoZSBoYW5kbGVyIGNhbGxiYWNrIHRvIGZpcmUgb24gdGhpcyBldmVudFxyXG4gICAgICovXHJcbiAgICBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLnB1c2goaGFuZGxlcik7XHJcbiAgICAgICAgLy8gbWV0YSBldmVudCBoYW5kbGVyc1xyXG4gICAgICAgIGlmIChldmVudE5hbWUgIT09ICd1bnN1YnNjcmliZScgJiYgZXZlbnROYW1lICE9PSAnc3Vic2NyaWJlJykge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N1YnNjcmliZScsIG5ldyBTdWJzY3JpYmVFdmVudChldmVudE5hbWUsIGhhbmRsZXIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVuc3Vic2NyaWJlIGFuIGV2ZW50IGhhbmRsZXIocykgZnJvbSBhbiBldmVudC4gSWYgYSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgICAgKiBpcyBzcGVjaWZpZWQgZm9yIGFuIGV2ZW50LCBvbmx5IHRoYXQgaGFuZGxlciB3aWxsIGJlIHVuc3Vic2NyaWJlZC5cclxuICAgICAqIE90aGVyd2lzZSBhbGwgaGFuZGxlcnMgd2lsbCBiZSB1bnN1YnNjcmliZWQgZm9yIHRoYXQgZXZlbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHVuc3Vic2NyaWJlXHJcbiAgICAgKiBAcGFyYW0gaGFuZGxlciAgICBPcHRpb25hbGx5IHRoZSBzcGVjaWZpYyBoYW5kbGVyIHRvIHVuc3Vic2NyaWJlXHJcbiAgICAgKi9cclxuICAgIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCBldmVudEhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXTtcclxuICAgICAgICBpZiAoZXZlbnRIYW5kbGVycykge1xyXG4gICAgICAgICAgICAvLyBpZiBubyBleHBsaWNpdCBoYW5kbGVyIGlzIGdpdmUgd2l0aCB0aGUgZXZlbnQgbmFtZSBjbGVhciBhbGwgaGFuZGxlcnNcclxuICAgICAgICAgICAgaWYgKCFoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IGV2ZW50SGFuZGxlcnMuaW5kZXhPZihoYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0uc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtZXRhIGV2ZW50IGhhbmRsZXJzXHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gJ3Vuc3Vic2NyaWJlJyAmJiBldmVudE5hbWUgIT09ICdzdWJzY3JpYmUnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgndW5zdWJzY3JpYmUnLCBuZXcgVW5zdWJzY3JpYmVFdmVudChldmVudE5hbWUsIGhhbmRsZXIpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9uY2UgbGlzdGVucyB0byBhbiBldmVudCBvbmUgdGltZSwgdGhlbiB1bnN1YnNjcmliZXMgZnJvbSB0aGF0IGV2ZW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvIG9uY2VcclxuICAgICAqIEBwYXJhbSBoYW5kbGVyICAgVGhlIGhhbmRsZXIgb2YgdGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBhdXRvIHVuc3Vic2NyaWJlZFxyXG4gICAgICovXHJcbiAgICBvbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIGNvbnN0IG1ldGFIYW5kbGVyID0gKGV2ZW50KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV2ID0gZXZlbnQgfHwgbmV3IEdhbWVFdmVudCgpO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZXYudGFyZ2V0ID0gZXYudGFyZ2V0IHx8IHRoaXMuX3RhcmdldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgIC8vIHBhc3NcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwoZXYudGFyZ2V0LCBldik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLm9uKGV2ZW50TmFtZSwgbWV0YUhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaXJlcyB0aGlzIGV2ZW50IGRpc3BhdGNoZXIgdG8gYWxzbyByZWNlaXZlIGV2ZW50cyBmcm9tIGFub3RoZXJcclxuICAgICAqL1xyXG4gICAgd2lyZShldmVudERpc3BhdGNoZXIpIHtcclxuICAgICAgICBldmVudERpc3BhdGNoZXIuX3dpcmVkRXZlbnREaXNwYXRjaGVycy5wdXNoKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbndpcmVzIHRoaXMgZXZlbnQgZGlzcGF0Y2hlciBmcm9tIGFub3RoZXJcclxuICAgICAqL1xyXG4gICAgdW53aXJlKGV2ZW50RGlzcGF0Y2hlcikge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnREaXNwYXRjaGVyLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnMuaW5kZXhPZih0aGlzKTtcclxuICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICBldmVudERpc3BhdGNoZXIuX3dpcmVkRXZlbnREaXNwYXRjaGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1Jlc291cmNlcy9SZXNvdXJjZS50c1xuXHJcblxyXG4vKipcclxuICogVGhlIFtbUmVzb3VyY2VdXSB0eXBlIGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBnZW5lcmljIHJlc291cmNlcy5cclxuICogRm9yIGFueSB0eXBlIG9mIHJlbW90ZSByZXNvdXJjZSBpdCBpcyByZWNvbW1lbmRlZCB0byB1c2UgW1tSZXNvdXJjZV1dIGZvciBwcmVsb2FkaW5nLlxyXG4gKi9cclxuY2xhc3MgUmVzb3VyY2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAgICAgICAgICBQYXRoIHRvIHRoZSByZW1vdGUgcmVzb3VyY2VcclxuICAgICAqIEBwYXJhbSByZXNwb25zZVR5cGUgIFRoZSB0eXBlIHRvIGV4cGVjdCBhcyBhIHJlc3BvbnNlOiBcIlwiIHwgXCJhcnJheWJ1ZmZlclwiIHwgXCJibG9iXCIgfCBcImRvY3VtZW50XCIgfCBcImpzb25cIiB8IFwidGV4dFwiO1xyXG4gICAgICogQHBhcmFtIGJ1c3RDYWNoZSAgICAgV2hldGhlciBvciBub3QgdG8gY2FjaGUtYnVzdCByZXF1ZXN0c1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCByZXNwb25zZVR5cGUsIGJ1c3RDYWNoZSA9IHRydWUpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xyXG4gICAgICAgIHRoaXMuYnVzdENhY2hlID0gYnVzdENhY2hlO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgUmVzb3VyY2UgaXMgY29tcGxldGVseSBsb2FkZWQgYW5kIGlzIHJlYWR5XHJcbiAgICAgKiB0byBiZSBkcmF3bi5cclxuICAgICAqL1xyXG4gICAgaXNMb2FkZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YSAhPT0gbnVsbDtcclxuICAgIH1cclxuICAgIF9jYWNoZUJ1c3QodXJpKSB7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSAvXFw/XFx3Kj1cXHcqLztcclxuICAgICAgICBpZiAocXVlcnkudGVzdCh1cmkpKSB7XHJcbiAgICAgICAgICAgIHVyaSArPSAnJl9fPScgKyBEYXRlLm5vdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdXJpICs9ICc/X189JyArIERhdGUubm93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1cmk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJlZ2luIGxvYWRpbmcgdGhlIHJlc291cmNlIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uXHJcbiAgICAgKi9cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBpZiB3ZSBhbHJlYWR5IGhhdmUgZGF0YVxyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnQWxyZWFkeSBoYXZlIGRhdGEgZm9yIHJlc291cmNlJywgdGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NvbXBsZXRlJywgdGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgIHJlcXVlc3Qub3BlbignR0VUJywgdGhpcy5idXN0Q2FjaGUgPyB0aGlzLl9jYWNoZUJ1c3QodGhpcy5wYXRoKSA6IHRoaXMucGF0aCwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gdGhpcy5yZXNwb25zZVR5cGU7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgKGUpID0+IHRoaXMuZXZlbnRzLmVtaXQoJ2xvYWRzdGFydCcsIGUpKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIChlKSA9PiB0aGlzLmV2ZW50cy5lbWl0KCdwcm9ncmVzcycsIGUpKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIChlKSA9PiB0aGlzLmV2ZW50cy5lbWl0KCdlcnJvcicsIGUpKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKGUpID0+IHRoaXMuZXZlbnRzLmVtaXQoJ2xvYWQnLCBlKSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIFhIUiBvbiBmaWxlOi8vIHN1Y2Nlc3Mgc3RhdHVzIGlzIDAsIHN1Y2ggYXMgd2l0aCBQaGFudG9tSlNcclxuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyAhPT0gMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHJlc291cmNlICcsIHRoaXMucGF0aCwgJyBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGggZXJyb3IgY29kZScsIHJlcXVlc3Quc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdlcnJvcicsIHJlcXVlc3QucmVzcG9uc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gcmVxdWVzdC5yZXNwb25zZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2NvbXBsZXRlJywgdGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdDb21wbGV0ZWQgbG9hZGluZyByZXNvdXJjZScsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXF1ZXN0LnNlbmQoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0RyYXdpbmcvU3ByaXRlRWZmZWN0cy50c1xuLyoqXHJcbiAqIEBtb2R1bGVcclxuICogQGRlcHJlY2F0ZWRcclxuICogVGhlc2UgZWZmZWN0cyBjYW4gYmUgYXBwbGllZCB0byBhbnkgYml0bWFwIGltYWdlIGJ1dCBhcmUgbWFpbmx5IHVzZWRcclxuICogZm9yIFtbU3ByaXRlXV0gZWZmZWN0cyBvciBbW0FuaW1hdGlvbl1dIGVmZmVjdHMuXHJcbiAqL1xyXG52YXIgU3ByaXRlRWZmZWN0c19kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuLyoqXHJcbiAqIEB0eXBlZG9jXHJcbiAqL1xyXG5cclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBcIkdyYXlzY2FsZVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgcmVtb3ZpbmcgY29sb3IgaW5mb3JtYXRpb24uXHJcbiAqIEBkZXByZWNhdGVkIFtbR3JheXNjYWxlXV0gd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmxldCBHcmF5c2NhbGUgPSBjbGFzcyBHcmF5c2NhbGUge1xyXG4gICAgdXBkYXRlUGl4ZWwoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgIGNvbnN0IHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgY29uc3QgYXZnID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSArIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSArIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSkgLyAzO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGF2ZztcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSBhdmc7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gYXZnO1xyXG4gICAgfVxyXG59O1xyXG5HcmF5c2NhbGUgPSBTcHJpdGVFZmZlY3RzX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnR3JheXNjYWxlIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJ1xyXG4gICAgfSlcclxuXSwgR3JheXNjYWxlKTtcclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBcIkludmVydFwiIGVmZmVjdCB0byBhIHNwcml0ZSwgaW52ZXJ0aW5nIHRoZSBwaXhlbCBjb2xvcnMuXHJcbiAqIEBkZXByZWNhdGVkIFtbSW52ZXJ0XV0gd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmxldCBJbnZlcnQgPSBjbGFzcyBJbnZlcnQge1xyXG4gICAgdXBkYXRlUGl4ZWwoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgIGNvbnN0IHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gMjU1IC0gcGl4ZWxbZmlyc3RQaXhlbCArIDBdO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IDI1NSAtIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXTtcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSAyNTUgLSBwaXhlbFtmaXJzdFBpeGVsICsgMl07XHJcbiAgICB9XHJcbn07XHJcbkludmVydCA9IFNwcml0ZUVmZmVjdHNfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdJbnZlcnQgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnXHJcbiAgICB9KVxyXG5dLCBJbnZlcnQpO1xyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIFwiT3BhY2l0eVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgc2V0dGluZyB0aGUgYWxwaGEgb2YgYWxsIHBpeGVscyB0byBhIGdpdmVuIHZhbHVlLlxyXG4gKiBAZGVwcmVjYXRlZCBbW09wYWNpdHldXSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxubGV0IE9wYWNpdHkgPSBjbGFzcyBPcGFjaXR5IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG9wYWNpdHkgIFRoZSBuZXcgb3BhY2l0eSBvZiB0aGUgc3ByaXRlIGZyb20gMC0xLjBcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3BhY2l0eSkge1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQaXhlbCh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICBjb25zdCBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgY29uc3QgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICBpZiAocGl4ZWxbZmlyc3RQaXhlbCArIDNdICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IE1hdGgucm91bmQodGhpcy5vcGFjaXR5ICogcGl4ZWxbZmlyc3RQaXhlbCArIDNdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcbk9wYWNpdHkgPSBTcHJpdGVFZmZlY3RzX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnT3BhY2l0eSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCdcclxuICAgIH0pXHJcbl0sIE9wYWNpdHkpO1xyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIFwiQ29sb3JpemVcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgdGhlIHBpeGVscyB0byBhblxyXG4gKiBhdmVyYWdlIG9mIHRoZSBvcmlnaW5hbCBjb2xvciBhbmQgdGhlIHByb3ZpZGVkIGNvbG9yXHJcbiAqIEBkZXByZWNhdGVkIFtbQ29sb3JpemVdXSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxubGV0IENvbG9yaXplID0gY2xhc3MgQ29sb3JpemUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgIFRoZSBjb2xvciB0byBhcHBseSB0byB0aGUgc3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGl4ZWwoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgIGNvbnN0IHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDBdICsgdGhpcy5jb2xvci5yKSAvIDI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IChwaXhlbFtmaXJzdFBpeGVsICsgMV0gKyB0aGlzLmNvbG9yLmcpIC8gMjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSArIHRoaXMuY29sb3IuYikgLyAyO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuQ29sb3JpemUgPSBTcHJpdGVFZmZlY3RzX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnQ29sb3JpemUgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnXHJcbiAgICB9KVxyXG5dLCBDb2xvcml6ZSk7XHJcblxyXG4vKipcclxuICogQXBwbGllcyB0aGUgXCJMaWdodGVuXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBsaWdodG5lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICogQGRlcHJlY2F0ZWQgW1tMaWdodGVuXV0gd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmxldCBMaWdodGVuID0gY2xhc3MgTGlnaHRlbiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBmYWN0b3Igb2YgdGhlIGVmZmVjdCBiZXR3ZWVuIDAtMVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcclxuICAgIH1cclxuICAgIHVwZGF0ZVBpeGVsKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICBjb25zdCBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gQ29sb3IuZnJvbVJHQihwaXhlbFtmaXJzdFBpeGVsICsgMF0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDJdLCBwaXhlbFtmaXJzdFBpeGVsICsgM10pLmxpZ2h0ZW4odGhpcy5mYWN0b3IpO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGNvbG9yLnI7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gY29sb3IuZztcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IGNvbG9yLmE7XHJcbiAgICB9XHJcbn07XHJcbkxpZ2h0ZW4gPSBTcHJpdGVFZmZlY3RzX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnTGlnaHRlbiB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCdcclxuICAgIH0pXHJcbl0sIExpZ2h0ZW4pO1xyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIFwiRGFya2VuXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBkYXJrbmVzcyBvZiB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gKiBAZGVwcmVjYXRlZCBbW0Rhcmtlbl1dIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG5sZXQgRGFya2VuID0gY2xhc3MgRGFya2VuIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGZhY3RvciBvZiB0aGUgZWZmZWN0IGJldHdlZW4gMC0xXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIHRoaXMuZmFjdG9yID0gZmFjdG9yO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGl4ZWwoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgIGNvbnN0IHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBDb2xvci5mcm9tUkdCKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDFdLCBwaXhlbFtmaXJzdFBpeGVsICsgMl0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSkuZGFya2VuKHRoaXMuZmFjdG9yKTtcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSBjb2xvci5yO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gY29sb3IuYjtcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgM10gPSBjb2xvci5hO1xyXG4gICAgfVxyXG59O1xyXG5EYXJrZW4gPSBTcHJpdGVFZmZlY3RzX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnRGFya2VuIHdpbGwgYmUgcmVtb3ZlZCB2MC4yNi4wJ1xyXG4gICAgfSlcclxuXSwgRGFya2VuKTtcclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBcIlNhdHVyYXRlXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBzYXR1cmF0ZXMgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICogQGRlcHJlY2F0ZWQgW1tTYXR1cmF0ZV1dIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG5sZXQgU2F0dXJhdGUgPSBjbGFzcyBTYXR1cmF0ZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBmYWN0b3Igb2YgdGhlIGVmZmVjdCBiZXR3ZWVuIDAtMVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcclxuICAgIH1cclxuICAgIHVwZGF0ZVBpeGVsKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICBjb25zdCBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gQ29sb3IuZnJvbVJHQihwaXhlbFtmaXJzdFBpeGVsICsgMF0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDJdLCBwaXhlbFtmaXJzdFBpeGVsICsgM10pLnNhdHVyYXRlKHRoaXMuZmFjdG9yKTtcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSBjb2xvci5yO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gY29sb3IuYjtcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgM10gPSBjb2xvci5hO1xyXG4gICAgfVxyXG59O1xyXG5TYXR1cmF0ZSA9IFNwcml0ZUVmZmVjdHNfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdTYXR1cmF0ZSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCdcclxuICAgIH0pXHJcbl0sIFNhdHVyYXRlKTtcclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBcIkRlc2F0dXJhdGVcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGRlc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAqIEBkZXByZWNhdGVkIFtbRGVzYXR1cmF0ZV1dIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG5sZXQgRGVzYXR1cmF0ZSA9IGNsYXNzIERlc2F0dXJhdGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgZmFjdG9yIG9mIHRoZSBlZmZlY3QgYmV0d2VlbiAwLTFcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgdGhpcy5mYWN0b3IgPSBmYWN0b3I7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQaXhlbCh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICBjb25zdCBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgY29uc3QgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICBjb25zdCBjb2xvciA9IENvbG9yLmZyb21SR0IocGl4ZWxbZmlyc3RQaXhlbCArIDBdLCBwaXhlbFtmaXJzdFBpeGVsICsgMV0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDNdKS5kZXNhdHVyYXRlKHRoaXMuZmFjdG9yKTtcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSBjb2xvci5yO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGNvbG9yLmc7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gY29sb3IuYjtcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgM10gPSBjb2xvci5hO1xyXG4gICAgfVxyXG59O1xyXG5EZXNhdHVyYXRlID0gU3ByaXRlRWZmZWN0c19kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0Rlc2F0dXJhdGUgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnXHJcbiAgICB9KVxyXG5dLCBEZXNhdHVyYXRlKTtcclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBcIkZpbGxcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgbm9uLXRyYW5zcGFyZW50IHBpeGVscyB0byBtYXRjaFxyXG4gKiBhIGdpdmVuIGNvbG9yXHJcbiAqIEBkZXByZWNhdGVkIFtbRmlsbF1dIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG5sZXQgRmlsbCA9IGNsYXNzIEZpbGwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgIFRoZSBjb2xvciB0byBhcHBseSB0byB0aGUgc3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGl4ZWwoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgIGNvbnN0IHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgaWYgKHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSAhPT0gMCkge1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSB0aGlzLmNvbG9yLnI7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IHRoaXMuY29sb3IuZztcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDJdID0gdGhpcy5jb2xvci5iO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuRmlsbCA9IFNwcml0ZUVmZmVjdHNfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdGaWxsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJ1xyXG4gICAgfSlcclxuXSwgRmlsbCk7XHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0RyYXdpbmcvVGV4dHVyZS50c1xudmFyIF9fYXdhaXRlciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogVGhlIFtbVGV4dHVyZV1dIG9iamVjdCBhbGxvd3MgZ2FtZXMgYnVpbHQgaW4gRXhjYWxpYnVyIHRvIGxvYWQgaW1hZ2UgcmVzb3VyY2VzLlxyXG4gKiBbW1RleHR1cmVdXSBpcyBhbiBbW0xvYWRhYmxlXV0gd2hpY2ggbWVhbnMgaXQgY2FuIGJlIHBhc3NlZCB0byBhIFtbTG9hZGVyXV1cclxuICogdG8gcHJlLWxvYWQgYmVmb3JlIHN0YXJ0aW5nIGEgbGV2ZWwgb3IgZ2FtZS5cclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbmNsYXNzIFRleHR1cmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAgICAgICBQYXRoIHRvIHRoZSBpbWFnZSByZXNvdXJjZSBvciBhIGJhc2U2NCBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGltYWdlIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQi4uLlwiXHJcbiAgICAgKiBAcGFyYW0gYnVzdENhY2hlICBPcHRpb25hbGx5IGxvYWQgdGV4dHVyZSB3aXRoIGNhY2hlIGJ1c3RpbmdcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGF0aCwgYnVzdENhY2hlID0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5idXN0Q2FjaGUgPSBidXN0Q2FjaGU7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxvYWRlZCA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZWRSZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9yZXNvdXJjZSA9IG5ldyBSZXNvdXJjZShwYXRoLCAnYmxvYicsIGJ1c3RDYWNoZSk7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlID0gbmV3IFNwcml0ZV9TcHJpdGUodGhpcywgMCwgMCwgMCwgMCk7XHJcbiAgICB9XHJcbiAgICBnZXQgaW1hZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBUZXh0dXJlIGlzIGNvbXBsZXRlbHkgbG9hZGVkIGFuZCBpcyByZWFkeVxyXG4gICAgICogdG8gYmUgZHJhd24uXHJcbiAgICAgKi9cclxuICAgIGlzTG9hZGVkKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmVnaW5zIGxvYWRpbmcgdGhlIHRleHR1cmUgYW5kIHJldHVybnMgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIG9uIGNvbXBsZXRpb25cclxuICAgICAqL1xyXG4gICAgbG9hZCgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9hZCBiYXNlNjQgb3IgYmxvYiBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGxldCB1cmw7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGF0aC5pbmNsdWRlcygnZGF0YTppbWFnZS8nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSB5aWVsZCB0aGlzLl9yZXNvdXJjZS5sb2FkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHRoaXMucGF0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIERlY29kZSB0aGUgaW1hZ2VcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBpbWFnZS5kZWNvZGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCByZXN1bHRzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBpbWFnZTtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9zcHJpdGUud2lkdGggPSBpbWFnZS5uYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX3Nwcml0ZS5oZWlnaHQgPSBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlID0gbmV3IFNwcml0ZV9TcHJpdGUodGhpcywgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5yZWplY3QoJ0Vycm9yIGxvYWRpbmcgdGV4dHVyZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRvZG8gZW1pdCBjb21wbGV0ZVxyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZWRSZXNvbHZlKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBhc1Nwcml0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3ByaXRlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29uZmlndXJhYmxlLnRzXG4vKipcclxuICogQ29uZmlndXJhYmxlIGhlbHBlciBleHRlbmRzIGJhc2UgdHlwZSBhbmQgbWFrZXMgYWxsIHByb3BlcnRpZXMgYXZhaWxhYmxlIGFzIG9wdGlvbiBiYWcgYXJndW1lbnRzXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAcGFyYW0gYmFzZVxyXG4gKi9cclxuZnVuY3Rpb24gQ29uZmlndXJhYmxlKGJhc2UpIHtcclxuICAgIHJldHVybiBjbGFzcyBleHRlbmRzIGJhc2Uge1xyXG4gICAgICAgIGFzc2lnbihwcm9wcykge1xyXG4gICAgICAgICAgICAvL3NldCB0aGUgdmFsdWUgb2YgZXZlcnkgcHJvcGVydHkgdGhhdCB3YXMgcGFzc2VkIGluLFxyXG4gICAgICAgICAgICAvL2lmIHRoZSBjb25zdHJ1Y3RvciBwcmV2aW91c2x5IHNldCB0aGlzIHZhbHVlLCBpdCB3aWxsIGJlIG92ZXJyaWRkZW4gaGVyZVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzW2tdICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trXSA9IHByb3BzW2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcclxuICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XHJcbiAgICAgICAgICAgIC8vZ2V0IHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoYXQgYXJlbid0IHVuZGVmaW5lZC4gVFMgcGFzc2VzIGEgdmFsdWUgdG8gYWxsIHBhcmFtZXRlcnNcclxuICAgICAgICAgICAgLy9vZiB3aGF0ZXZlciBjdG9yIGlzIHRoZSBpbXBsZW1lbnRhdGlvbiwgc28gYXJncy5sZW5ndGggZG9lc24ndCB3b3JrIGhlcmUuXHJcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBhcmdzLmZpbHRlcihmdW5jdGlvbiAodmFsdWUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9KS5sZW5ndGg7XHJcbiAgICAgICAgICAgIGlmIChzaXplID09PSAxICYmIGFyZ3NbMF0gJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICYmICEoYXJnc1swXSBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hc3NpZ24oYXJnc1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRHJhd2luZy9TcHJpdGUudHNcbnZhciBTcHJpdGVfZGVjb3JhdGUgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcbnZhciBTcHJpdGVfYXdhaXRlciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogQGhpZGRlblxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgW1tTcHJpdGVdXVxyXG4gKi9cclxuY2xhc3MgU3ByaXRlSW1wbCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBpbWFnZU9yQ29uZmlnICBUaGUgYmFja2luZyBpbWFnZSB0ZXh0dXJlIHRvIGJ1aWxkIHRoZSBTcHJpdGUsIG9yIFNwcml0ZSBvcHRpb24gYmFnXHJcbiAgICAgKiBAcGFyYW0geCAgICAgIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSBzcHJpdGVcclxuICAgICAqIEBwYXJhbSB5ICAgICAgVGhlIHkgcG9zaXRpb24gb2YgdGhlIHNwcml0ZVxyXG4gICAgICogQHBhcmFtIHdpZHRoICBUaGUgd2lkdGggb2YgdGhlIHNwcml0ZSBpbiBwaXhlbHNcclxuICAgICAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgc3ByaXRlIGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihpbWFnZU9yQ29uZmlnLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy54ID0gMDtcclxuICAgICAgICB0aGlzLnkgPSAwO1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSAwLjA7XHJcbiAgICAgICAgdGhpcy5hbmNob3IgPSBWZWN0b3IuSGFsZjtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBWZWN0b3IuT25lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZmF1bHQ6IGZhbHNlLCBzaG91bGQgdGhlIHNwcml0ZSBiZSBkcmF3biBhcm91bmQgdGhlIGFuY2hvciBvciBmcm9tIHRoZSB0b3AgbGVmdC5cclxuICAgICAgICAgKiBTcHJpdGUgcm90YXRpb25zL3NjYWxpbmcgc3RpbGwgaGFwcGVuIGFyb3VuZCB0aGUgYW5jaG9yIHJlZ2FyZGxlc3Mgb2YgdGhpcyBzZXR0aW5nLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZHJhd0Fyb3VuZEFuY2hvciA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgdGhlIHNwcml0ZSBmbGlwcGVkIHZlcnRpY2FsbHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZsaXBWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYXdzIHRoZSBzcHJpdGUgZmxpcHBlZCBob3Jpem9udGFsbHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZsaXBIb3Jpem9udGFsID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gW107XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZUNhbnZhcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlQ3R4ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9waXhlbERhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3BpeGVsc0xvYWRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5RWZmZWN0ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9vcGFjaXR5ID0gMTtcclxuICAgICAgICBsZXQgaW1hZ2UgPSBpbWFnZU9yQ29uZmlnO1xyXG4gICAgICAgIGlmIChpbWFnZU9yQ29uZmlnICYmICEoaW1hZ2VPckNvbmZpZyBpbnN0YW5jZW9mIFRleHR1cmUpKSB7XHJcbiAgICAgICAgICAgIHggPSBpbWFnZU9yQ29uZmlnLnggfCAwO1xyXG4gICAgICAgICAgICB5ID0gaW1hZ2VPckNvbmZpZy55IHwgMDtcclxuICAgICAgICAgICAgd2lkdGggPSBpbWFnZU9yQ29uZmlnLndpZHRoIHwgMDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gaW1hZ2VPckNvbmZpZy5oZWlnaHQgfCAwO1xyXG4gICAgICAgICAgICBpbWFnZSA9IGltYWdlT3JDb25maWcuaW1hZ2U7XHJcbiAgICAgICAgICAgIGlmICghaW1hZ2UpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnQW4gaW1hZ2UgdGV4dHVyZSBpcyByZXF1aXJlZCB0byBjb25zdHJ1Y3QgYSBzcHJpdGUnO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueCA9IHggfHwgMDtcclxuICAgICAgICB0aGlzLnkgPSB5IHx8IDA7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gaW1hZ2U7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlQ2FudmFzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlQ2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLl9zcHJpdGVDdHggPSB0aGlzLl9zcHJpdGVDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICB0aGlzLl9pbml0UGl4ZWxzRnJvbVRleHR1cmUoKTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBnZXQgZHJhd1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLndpZHRoICogdGhpcy5zY2FsZS54KTtcclxuICAgIH1cclxuICAgIGdldCBkcmF3SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmFicyh0aGlzLmhlaWdodCAqIHRoaXMuc2NhbGUueSk7XHJcbiAgICB9XHJcbiAgICBfaW5pdFBpeGVsc0Zyb21UZXh0dXJlKCkge1xyXG4gICAgICAgIHJldHVybiBTcHJpdGVfYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0geWllbGQgdGhpcy50ZXh0dXJlLmxvYWRlZDtcclxuICAgICAgICAgICAgICAgIHRoaXMud2lkdGggPSB0aGlzLndpZHRoIHx8IGltYWdlLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgaW1hZ2UubmF0dXJhbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUNhbnZhcy53aWR0aCA9IHRoaXMuX3Nwcml0ZUNhbnZhcy53aWR0aCB8fCBpbWFnZS5uYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGVDYW52YXMuaGVpZ2h0ID0gdGhpcy5fc3ByaXRlQ2FudmFzLmhlaWdodCB8fCBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZFBpeGVscygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlydHlFZmZlY3QgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignRXJyb3IgbG9hZGluZyB0ZXh0dXJlICcsIHRoaXMudGV4dHVyZS5wYXRoLCBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2xvYWRQaXhlbHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZS5pc0xvYWRlZCgpICYmICF0aGlzLl9waXhlbHNMb2FkZWQpIHtcclxuICAgICAgICAgICAgY29uc3QgbmF0dXJhbFdpZHRoID0gdGhpcy50ZXh0dXJlLmltYWdlLm5hdHVyYWxXaWR0aCB8fCAwO1xyXG4gICAgICAgICAgICBjb25zdCBuYXR1cmFsSGVpZ2h0ID0gdGhpcy50ZXh0dXJlLmltYWdlLm5hdHVyYWxIZWlnaHQgfHwgMDtcclxuICAgICAgICAgICAgaWYgKHRoaXMud2lkdGggPiBuYXR1cmFsV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oYFRoZSBzcHJpdGUgd2lkdGggJHt0aGlzLndpZHRofSBleGNlZWRzIHRoZSB3aWR0aCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtuYXR1cmFsV2lkdGh9IG9mIHRoZSBiYWNraW5nIHRleHR1cmUgJHt0aGlzLnRleHR1cmUucGF0aH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCA8PSAwIHx8IG5hdHVyYWxXaWR0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB3aWR0aCBvZiBhIHNwcml0ZSBjYW5ub3QgYmUgMCBvciBuZWdhdGl2ZSwgc3ByaXRlIHdpZHRoOiAke3RoaXMud2lkdGh9LCBvcmlnaW5hbCB3aWR0aDogJHtuYXR1cmFsV2lkdGh9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0ID4gbmF0dXJhbEhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgVGhlIHNwcml0ZSBoZWlnaHQgJHt0aGlzLmhlaWdodH0gZXhjZWVkcyB0aGUgaGVpZ2h0IFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke25hdHVyYWxIZWlnaHR9IG9mIHRoZSBiYWNraW5nIHRleHR1cmUgJHt0aGlzLnRleHR1cmUucGF0aH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPD0gMCB8fCBuYXR1cmFsSGVpZ2h0IDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGhlaWdodCBvZiBhIHNwcml0ZSBjYW5ub3QgYmUgMCBvciBuZWdhdGl2ZSwgc3ByaXRlIGhlaWdodDogJHt0aGlzLmhlaWdodH0sIG9yaWdpbmFsIGhlaWdodDogJHtuYXR1cmFsSGVpZ2h0fWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2ZsdXNoVGV4dHVyZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9waXhlbHNMb2FkZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9mbHVzaFRleHR1cmUoKSB7XHJcbiAgICAgICAgY29uc3QgbmF0dXJhbFdpZHRoID0gdGhpcy50ZXh0dXJlLmltYWdlLm5hdHVyYWxXaWR0aCB8fCAwO1xyXG4gICAgICAgIGNvbnN0IG5hdHVyYWxIZWlnaHQgPSB0aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbEhlaWdodCB8fCAwO1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5kcmF3SW1hZ2UodGhpcy50ZXh0dXJlLmltYWdlLCBjbGFtcCh0aGlzLngsIDAsIG5hdHVyYWxXaWR0aCksIGNsYW1wKHRoaXMueSwgMCwgbmF0dXJhbEhlaWdodCksIGNsYW1wKHRoaXMud2lkdGgsIDAsIG5hdHVyYWxXaWR0aCksIGNsYW1wKHRoaXMuaGVpZ2h0LCAwLCBuYXR1cmFsSGVpZ2h0KSwgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBbW09wYWNpdHldXSBlZmZlY3QgdG8gYSBzcHJpdGUsIHNldHRpbmcgdGhlIGFscGhhIG9mIGFsbCBwaXhlbHMgdG8gYSBnaXZlbiB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBvcGFjaXR5KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fb3BhY2l0eSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBbW0dyYXlzY2FsZV1dIGVmZmVjdCB0byBhIHNwcml0ZSwgcmVtb3ZpbmcgY29sb3IgaW5mb3JtYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdyYXlzY2FsZSgpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgR3JheXNjYWxlKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBbW0ludmVydF1dIGVmZmVjdCB0byBhIHNwcml0ZSwgaW52ZXJ0aW5nIHRoZSBwaXhlbCBjb2xvcnMuXHJcbiAgICAgKi9cclxuICAgIGludmVydCgpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgSW52ZXJ0KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBbW0ZpbGxdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgbm9uLXRyYW5zcGFyZW50IHBpeGVscyB0byBtYXRjaCBhIGdpdmVuIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIGZpbGwoY29sb3IpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRmlsbChjb2xvcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBbW0NvbG9yaXplXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIHBpeGVscyB0byBiZSB0aGUgYXZlcmFnZSBvZiB0aGUgb3JpZ2luYWwgY29sb3JcclxuICAgICAqIGFuZCB0aGUgcHJvdmlkZWQgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIGNvbG9yaXplKGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IENvbG9yaXplKGNvbG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFtbTGlnaHRlbl1dIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdlcyB0aGUgbGlnaHRuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgKi9cclxuICAgIGxpZ2h0ZW4oZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IExpZ2h0ZW4oZmFjdG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFtbRGFya2VuXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBkYXJrbmVzcyBvZiB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICovXHJcbiAgICBkYXJrZW4oZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IERhcmtlbihmYWN0b3IpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgW1tTYXR1cmF0ZV1dIGVmZmVjdCB0byBhIHNwcml0ZSwgc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgKi9cclxuICAgIHNhdHVyYXRlKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBTYXR1cmF0ZShmYWN0b3IpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgW1tEZXNhdHVyYXRlXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBkZXNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gICAgICovXHJcbiAgICBkZXNhdHVyYXRlKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBEZXNhdHVyYXRlKGZhY3RvcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IFtbU3ByaXRlRWZmZWN0XV0gdG8gdGhpcyBkcmF3aW5nLlxyXG4gICAgICogQHBhcmFtIGVmZmVjdCAgRWZmZWN0IHRvIGFkZCB0byB0aGUgdGhpcyBkcmF3aW5nXHJcbiAgICAgKi9cclxuICAgIGFkZEVmZmVjdChlZmZlY3QpIHtcclxuICAgICAgICB0aGlzLmVmZmVjdHMucHVzaChlZmZlY3QpO1xyXG4gICAgICAgIC8vIFdlIG11c3QgY2hlY2sgaWYgdGhlIHRleHR1cmUgYW5kIHRoZSBiYWNraW5nIHNwcml0ZSBwaXhlbHMgYXJlIGxvYWRlZCBhcyB3ZWxsIGJlZm9yZVxyXG4gICAgICAgIC8vIGFuIGVmZmVjdCBjYW4gYmUgYXBwbGllZFxyXG4gICAgICAgIGlmICghdGhpcy50ZXh0dXJlLmlzTG9hZGVkKCkgfHwgIXRoaXMuX3BpeGVsc0xvYWRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUVmZmVjdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUVmZmVjdHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVFZmZlY3QocGFyYW0pIHtcclxuICAgICAgICBsZXQgaW5kZXhUb1JlbW92ZSA9IC0xO1xyXG4gICAgICAgIGlmICh0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGluZGV4VG9SZW1vdmUgPSBwYXJhbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGluZGV4VG9SZW1vdmUgPSB0aGlzLmVmZmVjdHMuaW5kZXhPZihwYXJhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJvdW5kcyBjaGVja1xyXG4gICAgICAgIGlmIChpbmRleFRvUmVtb3ZlIDwgMCB8fCBpbmRleFRvUmVtb3ZlID49IHRoaXMuZWZmZWN0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVmZmVjdHMuc3BsaWNlKGluZGV4VG9SZW1vdmUsIDEpO1xyXG4gICAgICAgIC8vIFdlIG11c3QgY2hlY2sgaWYgdGhlIHRleHR1cmUgYW5kIHRoZSBiYWNraW5nIHNwcml0ZSBwaXhlbHMgYXJlIGxvYWRlZCBhcyB3ZWxsIGJlZm9yZVxyXG4gICAgICAgIC8vIGFuIGVmZmVjdCBjYW4gYmUgYXBwbGllZFxyXG4gICAgICAgIGlmICghdGhpcy50ZXh0dXJlLmlzTG9hZGVkKCkgfHwgIXRoaXMuX3BpeGVsc0xvYWRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eUVmZmVjdCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUVmZmVjdHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYXBwbHlFZmZlY3RzKCkge1xyXG4gICAgICAgIHRoaXMuX2ZsdXNoVGV4dHVyZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmVmZmVjdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9waXhlbERhdGEgPSB0aGlzLl9zcHJpdGVDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgY29uc3QgbGVuID0gdGhpcy5lZmZlY3RzLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lZmZlY3RzW2ldLnVwZGF0ZVBpeGVsKHgsIHksIHRoaXMuX3BpeGVsRGF0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVDdHgucHV0SW1hZ2VEYXRhKHRoaXMuX3BpeGVsRGF0YSwgMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2RpcnR5RWZmZWN0ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbGwgZWZmZWN0cyBmcm9tIHRoZSBkcmF3aW5nIGFuZCByZXR1cm4gaXQgdG8gaXRzIG9yaWdpbmFsIHN0YXRlLlxyXG4gICAgICovXHJcbiAgICBjbGVhckVmZmVjdHMoKSB7XHJcbiAgICAgICAgdGhpcy5lZmZlY3RzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fYXBwbHlFZmZlY3RzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGRyYXdpbmcgKGlmIGFueSlcclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgLy8gZG8gbm90aGluZ1xyXG4gICAgfVxyXG4gICAgZGVidWdEcmF3KGN0eCwgeCwgeSkge1xyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICBjdHgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgIGNvbnN0IHhwb2ludCA9IHRoaXMuZHJhd1dpZHRoICogdGhpcy5hbmNob3IueDtcclxuICAgICAgICBjb25zdCB5cG9pbnQgPSB0aGlzLmRyYXdIZWlnaHQgKiB0aGlzLmFuY2hvci55O1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9yLkJsYWNrLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVJlY3QoLXhwb2ludCwgLXlwb2ludCwgdGhpcy5kcmF3V2lkdGgsIHRoaXMuZHJhd0hlaWdodCk7XHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIGRyYXcoY3R4T3JPcHRpb25zLCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKGN0eE9yT3B0aW9ucyBpbnN0YW5jZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kcmF3V2l0aE9wdGlvbnMoeyBjdHg6IGN0eE9yT3B0aW9ucywgeCwgeSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYXdXaXRoT3B0aW9ucyhjdHhPck9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kcmF3V2l0aE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xyXG4gICAgICAgIGNvbnN0IHsgY3R4LCB4LCB5LCByb3RhdGlvbiwgZHJhd1dpZHRoLCBkcmF3SGVpZ2h0LCBhbmNob3IsIG9mZnNldCwgb3BhY2l0eSwgZmxpcEhvcml6b250YWwsIGZsaXBWZXJ0aWNhbCB9ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyByb3RhdGlvbjogKF9hID0gb3B0aW9ucy5yb3RhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5yb3RhdGlvbiwgZHJhd1dpZHRoOiAoX2IgPSBvcHRpb25zLmRyYXdXaWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy53aWR0aCwgZHJhd0hlaWdodDogKF9jID0gb3B0aW9ucy5kcmF3SGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLmhlaWdodCwgZmxpcEhvcml6b250YWw6IChfZCA9IG9wdGlvbnMuZmxpcEhvcml6b250YWwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRoaXMuZmxpcEhvcml6b250YWwsIGZsaXBWZXJ0aWNhbDogKF9lID0gb3B0aW9ucy5mbGlwVmVydGljYWwpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMuZmxpcFZlcnRpY2FsLCBhbmNob3I6IChfZiA9IG9wdGlvbnMuYW5jaG9yKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0aGlzLmFuY2hvciwgb2Zmc2V0OiAoX2cgPSBvcHRpb25zLm9mZnNldCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdGhpcy5vZmZzZXQsIG9wYWNpdHk6ICgoX2ggPSBvcHRpb25zLm9wYWNpdHkpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IDEpICogKChfaiA9IHRoaXMuX29wYWNpdHkpICE9PSBudWxsICYmIF9qICE9PSB2b2lkIDAgPyBfaiA6IDEpIH0pO1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eUVmZmVjdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUVmZmVjdHMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2FsY3VsYXRpbmcgY3VycmVudCBkaW1lbnNpb25zXHJcbiAgICAgICAgY29uc3QgYW5jaG9yWCA9IGRyYXdXaWR0aCAqIGFuY2hvci54ICsgb2Zmc2V0Lng7XHJcbiAgICAgICAgY29uc3QgYW5jaG9yWSA9IGRyYXdIZWlnaHQgKiBhbmNob3IueSArIG9mZnNldC55O1xyXG4gICAgICAgIGNvbnN0IHNjYWxlRGlyWCA9IHRoaXMuc2NhbGUueCA+IDAgPyAxIDogLTE7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVEaXJZID0gdGhpcy5zY2FsZS55ID4gMCA/IDEgOiAtMTtcclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIC8vIE1vdmUgdGhlIGRyYXcgcG9pbnQgb2Ygb3JpZ2luXHJcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICAvLyBSb3RhdGUgYW5kIHNjYWxlIGFyb3VuZCBhbmNob3IgcG9pbnRcclxuICAgICAgICAvLyBUaGlzIHJlcXVpcmVzIGEgYml0IG9mIGV4cGxhaW5hdGlvbiwgc2NhbGUgY29vcmRpbmF0ZXMgZmlyc3QgcG9zaXRpdmUgZmxpcHBpbmcgb3Igcm90YXRpbmdcclxuICAgICAgICBjdHguc2NhbGUoTWF0aC5hYnModGhpcy5zY2FsZS54KSwgTWF0aC5hYnModGhpcy5zY2FsZS55KSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZHJhd0Fyb3VuZEFuY2hvcikge1xyXG4gICAgICAgICAgICAvLyBJbiB0aGUgY2FzZSB3aGVyZSB5b3Ugd2FudCB0aGUgYW5jaG9yIHRvIG1hdGNoIHdpdGggdGhlIHBvaW50IG9mIGRyYXdcclxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHNwcml0ZXMgYXJlIGFsd2F5cyBkcmF3biBmcm9tIHRvcC1sZWZ0XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLWFuY2hvclgsIC1hbmNob3JZKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LnRyYW5zbGF0ZShhbmNob3JYLCBhbmNob3JZKTtcclxuICAgICAgICBjdHgucm90YXRlKHJvdGF0aW9uKTtcclxuICAgICAgICAvLyBUaGlzIGlzIGZvciBoYW5kbGluZyBkaXJlY3Rpb24gY2hhbmdlcyAxIG9yIC0xLCB0aGF0IHdheSB3ZSBkb24ndCBoYXZlIG1pc21hdGNoZWQgdHJhbnNsYXRlcygpXHJcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlRGlyWCwgc2NhbGVEaXJZKTtcclxuICAgICAgICBjdHgudHJhbnNsYXRlKC1hbmNob3JYLCAtYW5jaG9yWSk7XHJcbiAgICAgICAgaWYgKGZsaXBIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoZHJhd1dpZHRoLCAwKTtcclxuICAgICAgICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZsaXBWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGRyYXdIZWlnaHQpO1xyXG4gICAgICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBvbGRBbHBoYSA9IGN0eC5nbG9iYWxBbHBoYTtcclxuICAgICAgICBjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xyXG4gICAgICAgIC8vIENvbnRleHQgaXMgYWxyZWFkeSByb3RhdGVkIGFuZCBzY2FsZWRcclxuICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX3Nwcml0ZUNhbnZhcywgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIC8vIHNvdXJjZVxyXG4gICAgICAgIDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTsgLy8gZGVzdFxyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9sZEFscGhhO1xyXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb2R1Y2VzIGEgY29weSBvZiB0aGUgY3VycmVudCBzcHJpdGVcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFNwcml0ZV9TcHJpdGUodGhpcy50ZXh0dXJlLCB0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIHJlc3VsdC5hbmNob3IgPSB0aGlzLmFuY2hvci5jbG9uZSgpO1xyXG4gICAgICAgIHJlc3VsdC5zY2FsZSA9IHRoaXMuc2NhbGUuY2xvbmUoKTtcclxuICAgICAgICByZXN1bHQucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICAgIHJlc3VsdC5mbGlwSG9yaXpvbnRhbCA9IHRoaXMuZmxpcEhvcml6b250YWw7XHJcbiAgICAgICAgcmVzdWx0LmZsaXBWZXJ0aWNhbCA9IHRoaXMuZmxpcFZlcnRpY2FsO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuZWZmZWN0cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICByZXN1bHQuYWRkRWZmZWN0KHRoaXMuZWZmZWN0c1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEEgW1tMZWdhY3lEcmF3aW5nLlNwcml0ZV1dIGlzIG9uZSBvZiB0aGUgbWFpbiBkcmF3aW5nIHByaW1pdGl2ZXMuIEl0IGlzIHJlc3BvbnNpYmxlIGZvciBkcmF3aW5nXHJcbiAqIGltYWdlcyBvciBwYXJ0cyBvZiBpbWFnZXMgZnJvbSBhIFtbTGVnYWN5RHJhd2luZy5UZXh0dXJlXV0gcmVzb3VyY2UgdG8gdGhlIHNjcmVlbi5cclxuICogQGRlcHJlY2F0ZWQgVXNlIFtbU3ByaXRlXV1cclxuICovXHJcbmxldCBTcHJpdGVfU3ByaXRlID0gY2xhc3MgU3ByaXRlIGV4dGVuZHMgQ29uZmlndXJhYmxlKFNwcml0ZUltcGwpIHtcclxuICAgIGNvbnN0cnVjdG9yKGltYWdlT3JDb25maWcsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBzdXBlcihpbWFnZU9yQ29uZmlnLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxufTtcclxuU3ByaXRlX1Nwcml0ZSA9IFNwcml0ZV9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0xhYmVsLmNsZWFyVGV4dFNoYWRvdyB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIExhYmVsLmZvbnQuc2hhZG93J1xyXG4gICAgfSlcclxuXSwgU3ByaXRlX1Nwcml0ZSk7XHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL1Nwcml0ZS50c1xuXHJcblxyXG5cclxuXHJcbmNsYXNzIFNwcml0ZSBleHRlbmRzIEdyYXBoaWMge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IG9wdGlvbnMuaW1hZ2U7XHJcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuc291cmNlVmlldyA9IChfYSA9IG9wdGlvbnMuc291cmNlVmlldykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogeyB4OiAwLCB5OiAwLCB3aWR0aDogd2lkdGggIT09IG51bGwgJiYgd2lkdGggIT09IHZvaWQgMCA/IHdpZHRoIDogMCwgaGVpZ2h0OiBoZWlnaHQgIT09IG51bGwgJiYgaGVpZ2h0ICE9PSB2b2lkIDAgPyBoZWlnaHQgOiAwIH07XHJcbiAgICAgICAgdGhpcy5kZXN0U2l6ZSA9IChfYiA9IG9wdGlvbnMuZGVzdFNpemUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHsgd2lkdGg6IHdpZHRoICE9PSBudWxsICYmIHdpZHRoICE9PSB2b2lkIDAgPyB3aWR0aCA6IDAsIGhlaWdodDogaGVpZ2h0ICE9PSBudWxsICYmIGhlaWdodCAhPT0gdm9pZCAwID8gaGVpZ2h0IDogMCB9O1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVNwcml0ZURpbWVuc2lvbnMoKTtcclxuICAgICAgICB0aGlzLmltYWdlLnJlYWR5LnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTcHJpdGVEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbShpbWFnZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlKHtcclxuICAgICAgICAgICAgaW1hZ2U6IGltYWdlXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlU3ByaXRlRGltZW5zaW9ucygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcclxuICAgICAgICBjb25zdCB7IHdpZHRoOiBuYXRpdmVXaWR0aCwgaGVpZ2h0OiBuYXRpdmVIZWlnaHQgfSA9IHRoaXMuaW1hZ2U7XHJcbiAgICAgICAgLy8gVGhpcyBjb2RlIHVzZXMgfHwgdG8gYXZvaWQgMCdzXHJcbiAgICAgICAgLy8gSWYgdGhlIHNvdXJjZSBpcyBub3Qgc3BlY2lmaWVkLCB1c2UgdGhlIG5hdGl2ZSBkaW1lbnNpb25cclxuICAgICAgICB0aGlzLnNvdXJjZVZpZXcud2lkdGggPSAoKF9hID0gdGhpcy5zb3VyY2VWaWV3KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGgpIHx8IG5hdGl2ZVdpZHRoO1xyXG4gICAgICAgIHRoaXMuc291cmNlVmlldy5oZWlnaHQgPSAoKF9iID0gdGhpcy5zb3VyY2VWaWV3KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSB8fCBuYXRpdmVIZWlnaHQ7XHJcbiAgICAgICAgLy8gSWYgdGhlIGRlc3RpbmF0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIHVzZSB0aGUgc291cmNlIGlmIHNwZWNpZmllZCwgdGhlbiBuYXRpdmVcclxuICAgICAgICB0aGlzLmRlc3RTaXplLndpZHRoID0gKChfYyA9IHRoaXMuZGVzdFNpemUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy53aWR0aCkgfHwgKChfZCA9IHRoaXMuc291cmNlVmlldykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLndpZHRoKSB8fCBuYXRpdmVXaWR0aDtcclxuICAgICAgICB0aGlzLmRlc3RTaXplLmhlaWdodCA9ICgoX2UgPSB0aGlzLmRlc3RTaXplKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuaGVpZ2h0KSB8fCAoKF9mID0gdGhpcy5zb3VyY2VWaWV3KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuaGVpZ2h0KSB8fCBuYXRpdmVIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IE1hdGguY2VpbCh0aGlzLmRlc3RTaXplLndpZHRoKTtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IE1hdGguY2VpbCh0aGlzLmRlc3RTaXplLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBfcHJlRHJhdyhleCwgeCwgeSkge1xyXG4gICAgICAgIGlmICh0aGlzLmltYWdlLmlzTG9hZGVkKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3ByaXRlRGltZW5zaW9ucygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzdXBlci5fcHJlRHJhdyhleCwgeCwgeSk7XHJcbiAgICB9XHJcbiAgICBfZHJhd0ltYWdlKGV4LCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2UuaXNMb2FkZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTcHJpdGVEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgICAgIGV4LmRyYXdJbWFnZSh0aGlzLmltYWdlLmltYWdlLCB0aGlzLnNvdXJjZVZpZXcueCwgdGhpcy5zb3VyY2VWaWV3LnksIHRoaXMuc291cmNlVmlldy53aWR0aCwgdGhpcy5zb3VyY2VWaWV3LmhlaWdodCwgeCwgeSwgdGhpcy5kZXN0U2l6ZS53aWR0aCwgdGhpcy5kZXN0U2l6ZS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgSW1hZ2VTb3VyY2UgZnJvbSBsZWdhY3kgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHNwcml0ZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUxlZ2FjeVNwcml0ZShzcHJpdGUpIHtcclxuICAgICAgICBjb25zdCB0ZXggPSBzcHJpdGUudGV4dHVyZTtcclxuICAgICAgICBjb25zdCBpbWFnZSA9IEltYWdlU291cmNlLmZyb21MZWdhY3lUZXh0dXJlKHRleCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGUoe1xyXG4gICAgICAgICAgICBpbWFnZSxcclxuICAgICAgICAgICAgc291cmNlVmlldzoge1xyXG4gICAgICAgICAgICAgICAgeDogc3ByaXRlLngsXHJcbiAgICAgICAgICAgICAgICB5OiBzcHJpdGUueSxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBzcHJpdGUud2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNwcml0ZS5oZWlnaHRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb252ZXJ0cyBhIHNwcml0ZSB0byBhIExlZ2FjeSBzcHJpdGVcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcGFyYW0gc3ByaXRlXHJcbiAgICAgKiBAcmV0dXJucyBMZWdhY3lEcmF3aW5nLlNwcml0ZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdG9MZWdhY3lTcHJpdGUoc3ByaXRlKSB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBzcHJpdGUuaW1hZ2U7XHJcbiAgICAgICAgY29uc3QgdGV4ID0gbmV3IFRleHR1cmUoaW1hZ2UucGF0aCk7XHJcbiAgICAgICAgdGV4LmRhdGEgPSBpbWFnZS5pbWFnZTtcclxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZV9TcHJpdGUodGV4LCBzcHJpdGUuc291cmNlVmlldy54LCBzcHJpdGUuc291cmNlVmlldy55LCBzcHJpdGUuc291cmNlVmlldy53aWR0aCwgc3ByaXRlLnNvdXJjZVZpZXcuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlKE9iamVjdC5hc3NpZ24oeyBpbWFnZTogdGhpcy5pbWFnZSwgc291cmNlVmlldzogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zb3VyY2VWaWV3KSwgZGVzdFNpemU6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVzdFNpemUpIH0sIHRoaXMuY2xvbmVHcmFwaGljT3B0aW9ucygpKSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9JbWFnZVNvdXJjZS50c1xudmFyIEltYWdlU291cmNlX2F3YWl0ZXIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5cclxuXHJcbmNsYXNzIEltYWdlU291cmNlIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHBhdGggdG8gdGhlIGltYWdlLCBjYW4gYWxzbyBiZSBhIGRhdGEgdXJsIGxpa2UgJ2RhdGE6aW1hZ2UvJ1xyXG4gICAgICogQHBhcmFtIHBhdGhcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocGF0aCwgYnVzdENhY2hlID0gZmFsc2UpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjY2VzcyB0byB0aGUgdW5kZXJseWluZyBodG1sIGltYWdlIGVsbWVlbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICB0aGlzLl9yZXNvdXJjZSA9IG5ldyBSZXNvdXJjZShwYXRoLCAnYmxvYicsIGJ1c3RDYWNoZSk7XHJcbiAgICAgICAgaWYgKHBhdGguZW5kc1dpdGgoJy5zdmcnKSB8fCBwYXRoLmVuZHNXaXRoKCcuZ2lmJykpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYEltYWdlIHR5cGUgaXMgbm90IGZ1bGx5IHN1cHBvcnRlZCwgeW91IG1heSBoYXZlIG1peGVkIHJlc3VsdHMgJHtwYXRofS4gRnVsbHkgc3VwcG9ydGVkOiBqcGcsIGJtcCwgYW5kIHBuZ2ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlYWR5ID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVkUmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcmlnaW5hbCBzaXplIG9mIHRoZSBzb3VyY2UgaW1hZ2UgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZS5uYXR1cmFsV2lkdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBvcmlnaW5hbCBoZWlnaHQgb2YgdGhlIHNvdXJjZSBpbWFnZSBpbiBwaXhlbHNcclxuICAgICAqL1xyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZS5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIFRleHR1cmUgaXMgY29tcGxldGVseSBsb2FkZWQgYW5kIGlzIHJlYWR5XHJcbiAgICAgKiB0byBiZSBkcmF3bi5cclxuICAgICAqL1xyXG4gICAgaXNMb2FkZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5kYXRhLnNyYztcclxuICAgIH1cclxuICAgIGdldCBpbWFnZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCZWdpbnMgbG9hZGluZyB0aGUgaW1hZ2UgYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgaW1hZ2UgaXMgbG9hZGVkXHJcbiAgICAgKi9cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIEltYWdlU291cmNlX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmlzTG9hZGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIExvYWQgYmFzZTY0IG9yIGJsb2IgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgICAgICBsZXQgdXJsO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnBhdGguaW5jbHVkZXMoJ2RhdGE6aW1hZ2UvJykpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBibG9iID0geWllbGQgdGhpcy5fcmVzb3VyY2UubG9hZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLnBhdGg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBEZWNvZGUgdGhlIGltYWdlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICAgICAgaW1hZ2Uuc3JjID0gdXJsO1xyXG4gICAgICAgICAgICAgICAgeWllbGQgaW1hZ2UuZGVjb2RlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgcmVzdWx0c1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gaW1hZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBgRXJyb3IgbG9hZGluZyBJbWFnZVNvdXJjZSBmcm9tIHBhdGggJyR7dGhpcy5wYXRofScgd2l0aCBlcnJvciBbJHtlcnJvci5tZXNzYWdlfV1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHRvZG8gZW1pdCBjb21wbGV0ZVxyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZWRSZXNvbHZlKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkIGEgc3ByaXRlIGZyb20gdGhpcyBJbWFnZVNvdXJjZVxyXG4gICAgICovXHJcbiAgICB0b1Nwcml0ZSgpIHtcclxuICAgICAgICByZXR1cm4gU3ByaXRlLmZyb20odGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIEltYWdlU291cmNlIGZyb20gbGVnYWN5IHRleHR1cmVcclxuICAgICAqIEBwYXJhbSB0ZXhcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21MZWdhY3lUZXh0dXJlKHRleCkge1xyXG4gICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlU291cmNlKHRleC5wYXRoKTtcclxuICAgICAgICBpZiAodGV4LmlzTG9hZGVkKCkpIHtcclxuICAgICAgICAgICAgaW1hZ2UuZGF0YSA9IHRleC5kYXRhO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGV4LmxvYWRlZC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGltYWdlLmRhdGEgPSB0ZXguZGF0YTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbWFnZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW5sb2FkIGltYWdlcyBmcm9tIG1lbW9yeVxyXG4gICAgICovXHJcbiAgICB1bmxvYWQoKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEltYWdlKCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9EcmF3aW5nL0FuaW1hdGlvbi50c1xudmFyIEFuaW1hdGlvbl9kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICogQGRlcHJlY2F0ZWQgVXNlIFtbQW5pbWF0aW9uXV1cclxuICovXHJcbmNsYXNzIEFuaW1hdGlvbkltcGwge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUeXBpY2FsbHkgeW91IHdpbGwgdXNlIGEgW1tTcHJpdGVTaGVldF1dIHRvIGdlbmVyYXRlIGFuIFtbQW5pbWF0aW9uXV0uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGVuZ2luZU9yQ29uZmlnICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBlbmdpbmVcclxuICAgICAqIEBwYXJhbSBzcHJpdGVzICBBbiBhcnJheSBvZiBzcHJpdGVzIHRvIGNyZWF0ZSB0aGUgZnJhbWVzIGZvciB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gc3BlZWQgICBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIGxvb3AgICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBzaG91bGQgbG9vcCBhZnRlciBpdCBpcyBjb21wbGV0ZWRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lT3JDb25maWcsIHNwcml0ZXMsIHNwZWVkLCBsb29wKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNwcml0ZSBmcmFtZXMgdG8gcGxheSwgaW4gb3JkZXIuIFNlZSBbW1Nwcml0ZVNoZWV0LmdldEFuaW1hdGlvbkZvckFsbF1dIHRvIHF1aWNrbHlcclxuICAgICAgICAgKiBnZW5lcmF0ZSBhbiBbW0FuaW1hdGlvbl1dLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3ByaXRlcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgZnJhbWUgaW5kZXggYmVpbmcgc2hvd25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fdGltZUxlZnRJbkZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLl9pZGVtcG90ZW5jeVRva2VuID0gLTE7XHJcbiAgICAgICAgdGhpcy5hbmNob3IgPSBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMC4wO1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBWZWN0b3IuT25lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBhbmltYXRpb24gc2hvdWxkIGxvb3AgYWZ0ZXIgaXQgaXMgY29tcGxldGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb29wID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgdGhlIGZyYW1lIGluZGV4IHRoZSBhbmltYXRpb24gc2hvdWxkIGZyZWV6ZSBvbiBmb3IgYSBub24tbG9vcGluZ1xyXG4gICAgICAgICAqIGFuaW1hdGlvbi4gQnkgZGVmYXVsdCBpdCBpcyB0aGUgbGFzdCBmcmFtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZyZWV6ZUZyYW1lID0gLTE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmxpcCBlYWNoIGZyYW1lIHZlcnRpY2FsbHkuIFNldHMgW1tTcHJpdGUuZmxpcFZlcnRpY2FsXV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mbGlwVmVydGljYWwgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGbGlwIGVhY2ggZnJhbWUgaG9yaXpvbnRhbGx5LiBTZXRzIFtbU3ByaXRlLmZsaXBIb3Jpem9udGFsXV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZHJhd1dpZHRoID0gMDtcclxuICAgICAgICB0aGlzLmRyYXdIZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLl9vcGFjaXR5ID0gMTtcclxuICAgICAgICBsZXQgZW5naW5lID0gZW5naW5lT3JDb25maWc7XHJcbiAgICAgICAgaWYgKGVuZ2luZU9yQ29uZmlnICYmICEoZW5naW5lT3JDb25maWcgaW5zdGFuY2VvZiBFbmdpbmUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGVuZ2luZU9yQ29uZmlnO1xyXG4gICAgICAgICAgICBlbmdpbmUgPSBjb25maWcuZW5naW5lO1xyXG4gICAgICAgICAgICBzcHJpdGVzID0gY29uZmlnLnNwcml0ZXM7XHJcbiAgICAgICAgICAgIHNwZWVkID0gY29uZmlnLnNwZWVkO1xyXG4gICAgICAgICAgICBsb29wID0gY29uZmlnLmxvb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3ByaXRlcyA9IHNwcml0ZXM7XHJcbiAgICAgICAgdGhpcy5zcGVlZCA9IHNwZWVkO1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLl90aW1lTGVmdEluRnJhbWUgPSB0aGlzLnNwZWVkO1xyXG4gICAgICAgIGlmIChsb29wICE9IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5sb29wID0gbG9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNwcml0ZXMgJiYgc3ByaXRlc1swXSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdIZWlnaHQgPSBzcHJpdGVzWzBdID8gc3ByaXRlc1swXS5kcmF3SGVpZ2h0IDogMDtcclxuICAgICAgICAgICAgdGhpcy5kcmF3V2lkdGggPSBzcHJpdGVzWzBdID8gc3ByaXRlc1swXS5kcmF3V2lkdGggOiAwO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gc3ByaXRlc1swXSA/IHNwcml0ZXNbMF0ud2lkdGggOiAwO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IHNwcml0ZXNbMF0gPyBzcHJpdGVzWzBdLmhlaWdodCA6IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZnJlZXplRnJhbWUgPSBzcHJpdGVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBvcGFjaXR5IGVmZmVjdCB0byBhIHNwcml0ZSwgc2V0dGluZyB0aGUgYWxwaGEgb2YgYWxsIHBpeGVscyB0byBhIGdpdmVuIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIG9wYWNpdHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9vcGFjaXR5ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGdyYXlzY2FsZSBlZmZlY3QgdG8gYSBzcHJpdGUsIHJlbW92aW5nIGNvbG9yIGluZm9ybWF0aW9uLlxyXG4gICAgICovXHJcbiAgICBncmF5c2NhbGUoKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEdyYXlzY2FsZSgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgaW52ZXJ0IGVmZmVjdCB0byBhIHNwcml0ZSwgaW52ZXJ0aW5nIHRoZSBwaXhlbCBjb2xvcnMuXHJcbiAgICAgKi9cclxuICAgIGludmVydCgpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgSW52ZXJ0KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBmaWxsIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBub24tdHJhbnNwYXJlbnQgcGl4ZWxzIHRvIG1hdGNoIGEgZ2l2ZW4gY29sb3JcclxuICAgICAqL1xyXG4gICAgZmlsbChjb2xvcikge1xyXG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBGaWxsKGNvbG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGNvbG9yaXplIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBwaXhlbHMgdG8gYmUgdGhlIGF2ZXJhZ2Ugb2YgdGhlIG9yaWdpbmFsIGNvbG9yIGFuZCB0aGVcclxuICAgICAqIHByb3ZpZGVkIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICBjb2xvcml6ZShjb2xvcikge1xyXG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBDb2xvcml6ZShjb2xvcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBsaWdodGVuIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdlcyB0aGUgbGlnaHRuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gaHNsXHJcbiAgICAgKi9cclxuICAgIGxpZ2h0ZW4oZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IExpZ2h0ZW4oZmFjdG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGRhcmtlbiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGRhcmtuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gaHNsXHJcbiAgICAgKi9cclxuICAgIGRhcmtlbihmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRGFya2VuKGZhY3RvcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBzYXR1cmF0ZSBlZmZlY3QgdG8gYSBzcHJpdGUsIHNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIGhzbFxyXG4gICAgICovXHJcbiAgICBzYXR1cmF0ZShmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgU2F0dXJhdGUoZmFjdG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGRlc2F0dXJhdGUgZWZmZWN0IHRvIGEgc3ByaXRlLCBkZXNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIGhzbFxyXG4gICAgICovXHJcbiAgICBkZXNhdHVyYXRlKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBEZXNhdHVyYXRlKGZhY3RvcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBbW1Nwcml0ZUVmZmVjdF1dIG1hbnVhbGx5XHJcbiAgICAgKi9cclxuICAgIGFkZEVmZmVjdChlZmZlY3QpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5hZGRFZmZlY3QoZWZmZWN0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVFZmZlY3QocGFyYW0pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5yZW1vdmVFZmZlY3QocGFyYW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgYWxsIHNwcml0ZSBlZmZlY3RzXHJcbiAgICAgKi9cclxuICAgIGNsZWFyRWZmZWN0cygpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5jbGVhckVmZmVjdHMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2V0QW5jaG9yKHBvaW50KSB7XHJcbiAgICAgICAgLy9pZiAoIXRoaXMuYW5jaG9yLmVxdWFscyhwb2ludCkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5hbmNob3Iuc2V0VG8ocG9pbnQueCwgcG9pbnQueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vfVxyXG4gICAgfVxyXG4gICAgX3NldFJvdGF0aW9uKHJhZGlhbnMpIHtcclxuICAgICAgICAvL2lmICh0aGlzLnJvdGF0aW9uICE9PSByYWRpYW5zKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBpIGluIHRoaXMuc3ByaXRlcykge1xyXG4gICAgICAgICAgICB0aGlzLnNwcml0ZXNbaV0ucm90YXRpb24gPSByYWRpYW5zO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL31cclxuICAgIH1cclxuICAgIF9zZXRTY2FsZShzY2FsZSkge1xyXG4gICAgICAgIC8vaWYgKCF0aGlzLnNjYWxlLmVxdWFscyhzY2FsZSkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5zY2FsZSA9IHNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvL31cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBhbmltYXRpb24gdG8gZmlyc3QgZnJhbWUuXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgYW5pbWF0aW9ucyB0aGF0IGxvb3AgYXJlIG5ldmVyIGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICBpc0RvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmxvb3AgJiYgdGhpcy5jdXJyZW50RnJhbWUgPj0gdGhpcy5zcHJpdGVzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTm90IG1lYW50IHRvIGJlIGNhbGxlZCBieSBnYW1lIGRldmVsb3BlcnMuIFRpY2tzIHRoZSBhbmltYXRpb24gZm9yd2FyZCBpbnRlcm5hbGx5IGFuZFxyXG4gICAgICogY2FsY3VsYXRlcyB3aGV0aGVyIHRvIGNoYW5nZSB0byB0aGUgZnJhbWUuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdGljayhlbGFwc2VkLCBpZGVtcG90ZW5jeVRva2VuKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lkZW1wb3RlbmN5VG9rZW4gPT09IGlkZW1wb3RlbmN5VG9rZW4pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pZGVtcG90ZW5jeVRva2VuID0gaWRlbXBvdGVuY3lUb2tlbjtcclxuICAgICAgICB0aGlzLl90aW1lTGVmdEluRnJhbWUgLT0gZWxhcHNlZDtcclxuICAgICAgICBpZiAodGhpcy5fdGltZUxlZnRJbkZyYW1lIDw9IDApIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLmxvb3AgPyAodGhpcy5jdXJyZW50RnJhbWUgKyAxKSAlIHRoaXMuc3ByaXRlcy5sZW5ndGggOiB0aGlzLmN1cnJlbnRGcmFtZSArIDE7XHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVMZWZ0SW5GcmFtZSA9IHRoaXMuc3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlcygpO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLnNwcml0ZXNbdGhpcy5jdXJyZW50RnJhbWVdO1xyXG4gICAgICAgIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBjdXJyZW50LndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IGN1cnJlbnQuaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdXaWR0aCA9IGN1cnJlbnQuZHJhd1dpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdIZWlnaHQgPSBjdXJyZW50LmRyYXdIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZVZhbHVlcygpIHtcclxuICAgICAgICB0aGlzLl9zZXRBbmNob3IodGhpcy5hbmNob3IpO1xyXG4gICAgICAgIHRoaXMuX3NldFJvdGF0aW9uKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgIHRoaXMuX3NldFNjYWxlKHRoaXMuc2NhbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTa2lwcyBhaGVhZCBhIHNwZWNpZmllZCBudW1iZXIgb2YgZnJhbWVzIGluIHRoZSBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBmcmFtZXMgIEZyYW1lcyB0byBza2lwIGFoZWFkXHJcbiAgICAgKi9cclxuICAgIHNraXAoZnJhbWVzKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAodGhpcy5jdXJyZW50RnJhbWUgKyBmcmFtZXMpICUgdGhpcy5zcHJpdGVzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGRyYXcoY3R4T3JPcHRpb25zLCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKGN0eE9yT3B0aW9ucyBpbnN0YW5jZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kcmF3V2l0aE9wdGlvbnMoeyBjdHg6IGN0eE9yT3B0aW9ucywgeCwgeSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYXdXaXRoT3B0aW9ucyhjdHhPck9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kcmF3V2l0aE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2g7XHJcbiAgICAgICAgY29uc3QgYW5pbU9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHJvdGF0aW9uOiAoX2EgPSBvcHRpb25zLnJvdGF0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnJvdGF0aW9uLCBkcmF3V2lkdGg6IChfYiA9IG9wdGlvbnMuZHJhd1dpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmRyYXdXaWR0aCwgZHJhd0hlaWdodDogKF9jID0gb3B0aW9ucy5kcmF3SGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLmRyYXdIZWlnaHQsIGZsaXBIb3Jpem9udGFsOiAoX2QgPSBvcHRpb25zLmZsaXBIb3Jpem9udGFsKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLmZsaXBIb3Jpem9udGFsLCBmbGlwVmVydGljYWw6IChfZSA9IG9wdGlvbnMuZmxpcFZlcnRpY2FsKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0aGlzLmZsaXBWZXJ0aWNhbCwgYW5jaG9yOiAoX2YgPSBvcHRpb25zLmFuY2hvcikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdGhpcy5hbmNob3IsIG9wYWNpdHk6ICgoX2cgPSBvcHRpb25zLm9wYWNpdHkpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IDEpICogKChfaCA9IHRoaXMuX29wYWNpdHkpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IDEpIH0pO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZVZhbHVlcygpO1xyXG4gICAgICAgIGxldCBjdXJyU3ByaXRlO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRGcmFtZSA8IHRoaXMuc3ByaXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY3VyclNwcml0ZSA9IHRoaXMuc3ByaXRlc1t0aGlzLmN1cnJlbnRGcmFtZV07XHJcbiAgICAgICAgICAgIGN1cnJTcHJpdGUuZHJhdyhhbmltT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZyZWV6ZUZyYW1lICE9PSAtMSAmJiB0aGlzLmN1cnJlbnRGcmFtZSA+PSB0aGlzLnNwcml0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGN1cnJTcHJpdGUgPSB0aGlzLnNwcml0ZXNbY2xhbXAodGhpcy5mcmVlemVGcmFtZSwgMCwgdGhpcy5zcHJpdGVzLmxlbmd0aCAtIDEpXTtcclxuICAgICAgICAgICAgY3VyclNwcml0ZS5kcmF3KGFuaW1PcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYWRkIHRoZSBjYWxjdWxhdGVkIHdpZHRoXHJcbiAgICAgICAgaWYgKGN1cnJTcHJpdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5kcmF3V2lkdGggPSBjdXJyU3ByaXRlLmRyYXdXaWR0aDtcclxuICAgICAgICAgICAgdGhpcy5kcmF3SGVpZ2h0ID0gY3VyclNwcml0ZS5kcmF3SGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGxheXMgYW4gYW5pbWF0aW9uIGF0IGFuIGFyYml0cmFyeSBsb2NhdGlvbiBpbiB0aGUgZ2FtZS5cclxuICAgICAqIEBwYXJhbSB4ICBUaGUgeCBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB0byBwbGF5XHJcbiAgICAgKiBAcGFyYW0geSAgVGhlIHkgcG9zaXRpb24gaW4gdGhlIGdhbWUgdG8gcGxheVxyXG4gICAgICovXHJcbiAgICBwbGF5KHgsIHkpIHtcclxuICAgICAgICB0aGlzLnJlc2V0KCk7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnBsYXlBbmltYXRpb24odGhpcywgeCwgeSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEFuaW1hdGlvbnMgYWxsb3cgeW91IHRvIGRpc3BsYXkgYSBzZXJpZXMgb2YgaW1hZ2VzIG9uZSBhZnRlciBhbm90aGVyLFxyXG4gKiBjcmVhdGluZyB0aGUgaWxsdXNpb24gb2YgY2hhbmdlLiBHZW5lcmFsbHkgdGhlc2UgaW1hZ2VzIHdpbGwgY29tZSBmcm9tIGEgW1tTcHJpdGVTaGVldF1dIHNvdXJjZS5cclxuICogQGRlcHJlY2F0ZWQgVXNlIFtbQW5pbWF0aW9uXV1cclxuICovXHJcbmxldCBBbmltYXRpb25fQW5pbWF0aW9uID0gY2xhc3MgQW5pbWF0aW9uIGV4dGVuZHMgQ29uZmlndXJhYmxlKEFuaW1hdGlvbkltcGwpIHtcclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZU9yQ29uZmlnLCBpbWFnZXMsIHNwZWVkLCBsb29wKSB7XHJcbiAgICAgICAgc3VwZXIoZW5naW5lT3JDb25maWcsIGltYWdlcywgc3BlZWQsIGxvb3ApO1xyXG4gICAgfVxyXG59O1xyXG5BbmltYXRpb25fQW5pbWF0aW9uID0gQW5pbWF0aW9uX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnQW5pbWF0aW9uIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgR3JhcGhpY3MuQW5pbWF0aW9uJ1xyXG4gICAgfSlcclxuXSwgQW5pbWF0aW9uX0FuaW1hdGlvbik7XHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0ZvbnRDb21tb24udHNcbi8qKlxyXG4gKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IGZvbnQgc2l6ZSB1bml0c1xyXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvZm9udC1zaXplXHJcbiAqL1xyXG52YXIgRm9udFVuaXQ7XHJcbihmdW5jdGlvbiAoRm9udFVuaXQpIHtcclxuICAgIC8qKlxyXG4gICAgICogRW0gaXMgYSBzY2FsYWJsZSB1bml0LCAxIGVtIGlzIGVxdWFsIHRvIHRoZSBjdXJyZW50IGZvbnQgc2l6ZSBvZiB0aGUgY3VycmVudCBlbGVtZW50LCBwYXJlbnQgZWxlbWVudHMgY2FuIGVmZmVjdCBlbSB2YWx1ZXNcclxuICAgICAqL1xyXG4gICAgRm9udFVuaXRbXCJFbVwiXSA9IFwiZW1cIjtcclxuICAgIC8qKlxyXG4gICAgICogUmVtIGlzIHNpbWlsYXIgdG8gdGhlIEVtLCBpdCBpcyBhIHNjYWxhYmxlIHVuaXQuIDEgcmVtIGlzIGVxdWFsIHRvIHRoZSBmb250IHNpemUgb2YgdGhlIHJvb3QgZWxlbWVudFxyXG4gICAgICovXHJcbiAgICBGb250VW5pdFtcIlJlbVwiXSA9IFwicmVtXCI7XHJcbiAgICAvKipcclxuICAgICAqIFBpeGVsIGlzIGEgdW5pdCBvZiBsZW5ndGggaW4gc2NyZWVuIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBGb250VW5pdFtcIlB4XCJdID0gXCJweFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQb2ludCBpcyBhIHBoeXNpY2FsIHVuaXQgbGVuZ3RoICgxLzcyIG9mIGFuIGluY2gpXHJcbiAgICAgKi9cclxuICAgIEZvbnRVbml0W1wiUHRcIl0gPSBcInB0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFBlcmNlbnQgaXMgYSBzY2FsYWJsZSB1bml0IHNpbWlsYXIgdG8gRW0sIHRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgdGhlIEVtIHVuaXRzIHNjYWxlIGZhc3RlciB3aGVuIFRleHQtU2l6ZSBzdHVmZlxyXG4gICAgICovXHJcbiAgICBGb250VW5pdFtcIlBlcmNlbnRcIl0gPSBcIiVcIjtcclxufSkoRm9udFVuaXQgfHwgKEZvbnRVbml0ID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgaG9yaXpvbnRhbCB0ZXh0IGFsaWdubWVudHNcclxuICovXHJcbnZhciBUZXh0QWxpZ247XHJcbihmdW5jdGlvbiAoVGV4dEFsaWduKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IGlzIGxlZnQtYWxpZ25lZC5cclxuICAgICAqL1xyXG4gICAgVGV4dEFsaWduW1wiTGVmdFwiXSA9IFwibGVmdFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBpcyByaWdodC1hbGlnbmVkLlxyXG4gICAgICovXHJcbiAgICBUZXh0QWxpZ25bXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgaXMgY2VudGVyZWQuXHJcbiAgICAgKi9cclxuICAgIFRleHRBbGlnbltcIkNlbnRlclwiXSA9IFwiY2VudGVyXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IGlzIGFsaWduZWQgYXQgdGhlIG5vcm1hbCBzdGFydCBvZiB0aGUgbGluZSAobGVmdC1hbGlnbmVkIGZvciBsZWZ0LXRvLXJpZ2h0IGxvY2FsZXMsXHJcbiAgICAgKiByaWdodC1hbGlnbmVkIGZvciByaWdodC10by1sZWZ0IGxvY2FsZXMpLlxyXG4gICAgICovXHJcbiAgICBUZXh0QWxpZ25bXCJTdGFydFwiXSA9IFwic3RhcnRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgaXMgYWxpZ25lZCBhdCB0aGUgbm9ybWFsIGVuZCBvZiB0aGUgbGluZSAocmlnaHQtYWxpZ25lZCBmb3IgbGVmdC10by1yaWdodCBsb2NhbGVzLFxyXG4gICAgICogbGVmdC1hbGlnbmVkIGZvciByaWdodC10by1sZWZ0IGxvY2FsZXMpLlxyXG4gICAgICovXHJcbiAgICBUZXh0QWxpZ25bXCJFbmRcIl0gPSBcImVuZFwiO1xyXG59KShUZXh0QWxpZ24gfHwgKFRleHRBbGlnbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IGJhc2VsaW5lIHRleHQgYWxpZ25tZW50c1xyXG4gKi9cclxudmFyIEJhc2VBbGlnbjtcclxuKGZ1bmN0aW9uIChCYXNlQWxpZ24pIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIHRvcCBvZiB0aGUgZW0gc3F1YXJlLlxyXG4gICAgICovXHJcbiAgICBCYXNlQWxpZ25bXCJUb3BcIl0gPSBcInRvcFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgaGFuZ2luZyBiYXNlbGluZS4gIEN1cnJlbnRseSB1bnN1cHBvcnRlZDsgdGhpcyB3aWxsIGFjdCBsaWtlXHJcbiAgICAgKiBhbHBoYWJldGljLlxyXG4gICAgICovXHJcbiAgICBCYXNlQWxpZ25bXCJIYW5naW5nXCJdID0gXCJoYW5naW5nXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBtaWRkbGUgb2YgdGhlIGVtIHNxdWFyZS5cclxuICAgICAqL1xyXG4gICAgQmFzZUFsaWduW1wiTWlkZGxlXCJdID0gXCJtaWRkbGVcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIG5vcm1hbCBhbHBoYWJldGljIGJhc2VsaW5lLlxyXG4gICAgICovXHJcbiAgICBCYXNlQWxpZ25bXCJBbHBoYWJldGljXCJdID0gXCJhbHBoYWJldGljXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBpZGVvZ3JhcGhpYyBiYXNlbGluZTsgdGhpcyBpcyB0aGUgYm90dG9tIG9mXHJcbiAgICAgKiB0aGUgYm9keSBvZiB0aGUgY2hhcmFjdGVycywgaWYgdGhlIG1haW4gYm9keSBvZiBjaGFyYWN0ZXJzIHByb3RydWRlc1xyXG4gICAgICogYmVuZWF0aCB0aGUgYWxwaGFiZXRpYyBiYXNlbGluZS4gIEN1cnJlbnRseSB1bnN1cHBvcnRlZDsgdGhpcyB3aWxsXHJcbiAgICAgKiBhY3QgbGlrZSBhbHBoYWJldGljLlxyXG4gICAgICovXHJcbiAgICBCYXNlQWxpZ25bXCJJZGVvZ3JhcGhpY1wiXSA9IFwiaWRlb2dyYXBoaWNcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIGJvdHRvbSBvZiB0aGUgYm91bmRpbmcgYm94LiAgVGhpcyBkaWZmZXJzXHJcbiAgICAgKiBmcm9tIHRoZSBpZGVvZ3JhcGhpYyBiYXNlbGluZSBpbiB0aGF0IHRoZSBpZGVvZ3JhcGhpYyBiYXNlbGluZVxyXG4gICAgICogZG9lc24ndCBjb25zaWRlciBkZXNjZW5kZXJzLlxyXG4gICAgICovXHJcbiAgICBCYXNlQWxpZ25bXCJCb3R0b21cIl0gPSBcImJvdHRvbVwiO1xyXG59KShCYXNlQWxpZ24gfHwgKEJhc2VBbGlnbiA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFbnVtIHJlcHJlc2VudGluZyB0aGUgZGlmZmVyZW50IHBvc3NpYmxlIGZvbnQgc3R5bGVzXHJcbiAqL1xyXG52YXIgRm9udFN0eWxlO1xyXG4oZnVuY3Rpb24gKEZvbnRTdHlsZSkge1xyXG4gICAgRm9udFN0eWxlW1wiTm9ybWFsXCJdID0gXCJub3JtYWxcIjtcclxuICAgIEZvbnRTdHlsZVtcIkl0YWxpY1wiXSA9IFwiaXRhbGljXCI7XHJcbiAgICBGb250U3R5bGVbXCJPYmxpcXVlXCJdID0gXCJvYmxpcXVlXCI7XHJcbn0pKEZvbnRTdHlsZSB8fCAoRm9udFN0eWxlID0ge30pKTtcclxudmFyIERpcmVjdGlvbjtcclxuKGZ1bmN0aW9uIChEaXJlY3Rpb24pIHtcclxuICAgIERpcmVjdGlvbltcIkxlZnRUb1JpZ2h0XCJdID0gXCJsdHJcIjtcclxuICAgIERpcmVjdGlvbltcIlJpZ2h0VG9MZWZ0XCJdID0gXCJydGxcIjtcclxufSkoRGlyZWN0aW9uIHx8IChEaXJlY3Rpb24gPSB7fSkpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0RyYXdpbmcvU3ByaXRlU2hlZXQudHNcbnZhciBTcHJpdGVTaGVldF9kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFNwcml0ZSBzaGVldHMgYXJlIGEgdXNlZnVsIG1lY2hhbmlzbSBmb3Igc2xpY2luZyB1cCBpbWFnZSByZXNvdXJjZXMgaW50b1xyXG4gKiBzZXBhcmF0ZSBzcHJpdGVzIG9yIGZvciBnZW5lcmF0aW5nIGluIGdhbWUgYW5pbWF0aW9ucy4gW1tTcHJpdGV8U3ByaXRlc11dIGFyZSBvcmdhbml6ZWRcclxuICogaW4gcm93IG1ham9yIG9yZGVyIGluIHRoZSBbW1Nwcml0ZVNoZWV0XV0uXHJcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG5jbGFzcyBTcHJpdGVTaGVldF9TcHJpdGVTaGVldCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzIFRoZSBiYWNraW5nIGltYWdlIHRleHR1cmUgdG8gYnVpbGQgdGhlIFNwcml0ZVNoZWV0LCBvcHRpb24gYmFnLCBvciBzcHJpdGUgbGlzdFxyXG4gICAgICogQHBhcmFtIGNvbHVtbnMgICBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIGltYWdlIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSByb3dzICAgICAgVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBpbWFnZSB0ZXh0dXJlXHJcbiAgICAgKiBAcGFyYW0gc3BXaWR0aCAgIFRoZSB3aWR0aCBvZiBlYWNoIGluZGl2aWR1YWwgc3ByaXRlIGluIHBpeGVsc1xyXG4gICAgICogQHBhcmFtIHNwSGVpZ2h0ICBUaGUgaGVpZ2h0IG9mIGVhY2ggaW5kaXZpZHVhbCBzcHJpdGUgaW4gcGl4ZWxzXHJcbiAgICAgKiBAcGFyYW0gc3BhY2luZyAgIFRoZSBzcGFjaW5nIGJldHdlZW4gZXZlcnkgc3ByaXRlIGluIGEgc3ByaXRlc2hlZXRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaW1hZ2VPckNvbmZpZ09yU3ByaXRlcywgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQsIHNwYWNpbmcpIHtcclxuICAgICAgICB0aGlzLl9zcHJpdGVzID0gW107XHJcbiAgICAgICAgdGhpcy5faW1hZ2UgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2NvbHVtbnMgPSAwO1xyXG4gICAgICAgIHRoaXMuX3Jvd3MgPSAwO1xyXG4gICAgICAgIHRoaXMuX3NwV2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3NwSGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLl9zcGFjaW5nID0gMDtcclxuICAgICAgICBsZXQgbG9hZEZyb21JbWFnZSA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChpbWFnZU9yQ29uZmlnT3JTcHJpdGVzIGluc3RhbmNlb2YgQXJyYXkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlcyA9IGltYWdlT3JDb25maWdPclNwcml0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoaW1hZ2VPckNvbmZpZ09yU3ByaXRlcyAmJiAhKGltYWdlT3JDb25maWdPclNwcml0ZXMgaW5zdGFuY2VvZiBUZXh0dXJlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sdW1ucyA9IGltYWdlT3JDb25maWdPclNwcml0ZXMuY29sdW1ucztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvd3MgPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLnJvd3M7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcFdpZHRoID0gaW1hZ2VPckNvbmZpZ09yU3ByaXRlcy5zcFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BIZWlnaHQgPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLnNwSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLmltYWdlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BhY2luZyA9IGltYWdlT3JDb25maWdPclNwcml0ZXMuc3BhY2luZyB8fCAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faW1hZ2UgPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sdW1ucyA9IGNvbHVtbnM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3dzID0gcm93cztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwV2lkdGggPSBzcFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BIZWlnaHQgPSBzcEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwYWNpbmcgPSBzcGFjaW5nIHx8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlcyA9IG5ldyBBcnJheSh0aGlzLl9jb2x1bW5zICogdGhpcy5fcm93cyk7XHJcbiAgICAgICAgICAgIGxvYWRGcm9tSW1hZ2UgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbnNwZWN0IGFjdHVhbCBpbWFnZSBkaW1lbnNpb25zIHdpdGggcHJlbG9hZGluZ1xyXG4gICAgICAgIGlmICh0aGlzLmltYWdlIGluc3RhbmNlb2YgVGV4dHVyZSkge1xyXG4gICAgICAgICAgICBsZXQgaXNXaWR0aEVycm9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGxldCBpc0hlaWdodEVycm9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmltYWdlLmlzTG9hZGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIGlzV2lkdGhFcnJvciA9IHRoaXMuc3BXaWR0aCAqIHRoaXMuY29sdW1ucyA+IHRoaXMuaW1hZ2UuaW1hZ2UubmF0dXJhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgaXNIZWlnaHRFcnJvciA9IHRoaXMuc3BIZWlnaHQgKiB0aGlzLnJvd3MgPiB0aGlzLmltYWdlLmltYWdlLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNXaWR0aEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFNwcml0ZVNoZWV0IHNwZWNpZmllZCBpcyB3aWRlciwgYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGAke3RoaXMuY29sdW1uc30gY29scyB4ICR7dGhpcy5zcFdpZHRofSBwaXhlbHMgPiAke3RoaXMuaW1hZ2UuaW1hZ2UubmF0dXJhbFdpZHRofSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHBpeGVscyB0aGFuIGltYWdlIHdpZHRoYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNIZWlnaHRFcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBTcHJpdGVTaGVldCBzcGVjaWZpZWQgaXMgdGFsbGVyLCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5yb3dzfSByb3dzIHggJHt0aGlzLnNwSGVpZ2h0fSBwaXhlbHMgPiAke3RoaXMuaW1hZ2UuaW1hZ2UubmF0dXJhbEhlaWdodH0gYCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBwaXhlbHMgdGhhbiBpbWFnZSBoZWlnaHRgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobG9hZEZyb21JbWFnZSkge1xyXG4gICAgICAgICAgICBjb25zdCBzcGFjaW5nID0gdGhpcy5nZXRTcGFjaW5nRGltZW5zaW9ucygpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLnJvd3M7IHJvdysrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbHVtbnM7IGNvbCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlc1tjb2wgKyByb3cgKiB0aGlzLmNvbHVtbnNdID0gbmV3IFNwcml0ZV9TcHJpdGUodGhpcy5pbWFnZSwgY29sICogdGhpcy5zcFdpZHRoICsgc3BhY2luZy5tYXJnaW4gKiBjb2wgKyBzcGFjaW5nLmxlZnQsIHJvdyAqIHRoaXMuc3BIZWlnaHQgKyBzcGFjaW5nLm1hcmdpbiAqIHJvdyArIHNwYWNpbmcudG9wLCB0aGlzLnNwV2lkdGgsIHRoaXMuc3BIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByYXcgc3BhY2luZyBkaW1lbnNpb25zIGZvciB0aGUgc3ByaXRlcyBpbiB0aGUgc2hlZXQsIHdoaWNoIGNhbiBiZSBhIGZpeGVkIG51bWJlciBvciBjdXN0b20gZGltZW5zaW9ucy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNwYWNpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NwYWNpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIGNvcHkgb2YgdGhlIGJhY2tpbmcgc3ByaXRlIGFycmF5XHJcbiAgICAgKi9cclxuICAgIGdldCBzcHJpdGVzKCkge1xyXG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fc3ByaXRlc107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBiYWNraW5nIHRleHR1cmUgdXNlZCBmb3IgdGhlIHNwcml0ZSBzaGVldFxyXG4gICAgICovXHJcbiAgICBnZXQgaW1hZ2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHNoZWV0XHJcbiAgICAgKi9cclxuICAgIGdldCBjb2x1bW5zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2x1bW5zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIHNoZWV0XHJcbiAgICAgKi9cclxuICAgIGdldCByb3dzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb3dzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGluZGl2aWR1YWwgc3ByaXRlc1xyXG4gICAgICovXHJcbiAgICBnZXQgc3BXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3BXaWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgaW5kaXZpZHVhbCBzcHJpdGVzXHJcbiAgICAgKi9cclxuICAgIGdldCBzcEhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3BIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGNhbGN1bGF0ZWQgc3BhY2luZyBkaW1lbnNpb25zIGJhc2VkIG9uIHdoZXRoZXIgc3BhY2luZ1xyXG4gICAgICogaXMgYSBmaXhlZCBudW1iZXIgb3IgaGFzIGRpZmZlcmVudCB2YWx1ZXMgZm9yIGVhY2ggZGltZW5zaW9uXHJcbiAgICAgKi9cclxuICAgIGdldFNwYWNpbmdEaW1lbnNpb25zKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zcGFjaW5nID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogdGhpcy5zcGFjaW5nLFxyXG4gICAgICAgICAgICAgICAgdG9wOiB0aGlzLnNwYWNpbmcsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IHRoaXMuc3BhY2luZ1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGxlZnQ6IChfYSA9IHRoaXMuc3BhY2luZy5sZWZ0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxyXG4gICAgICAgICAgICAgICAgdG9wOiAoX2IgPSB0aGlzLnNwYWNpbmcudG9wKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwLFxyXG4gICAgICAgICAgICAgICAgbWFyZ2luOiAoX2MgPSB0aGlzLnNwYWNpbmcubWFyZ2luKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gYW5pbWF0aW9uIGZyb20gdGhlIHRoaXMgU3ByaXRlU2hlZXQgYnkgbGlzdGluZyBvdXQgdGhlXHJcbiAgICAgKiBzcHJpdGUgaW5kaWNlcy4gU3ByaXRlcyBhcmUgb3JnYW5pemVkIGluIHJvdyBtYWpvciBvcmRlciBpbiB0aGUgU3ByaXRlU2hlZXQuXHJcbiAgICAgKiBAcGFyYW0gZW5naW5lICAgUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgW1tFbmdpbmVdXVxyXG4gICAgICogQHBhcmFtIGluZGljZXMgIEFuIGFycmF5IG9mIHNwcml0ZSBpbmRpY2VzIHRvIHVzZSBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gc3BlZWQgICAgVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIGluIHRoZSBhbmltYXRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0QW5pbWF0aW9uQnlJbmRpY2VzKGVuZ2luZSwgaW5kaWNlcywgc3BlZWQpIHtcclxuICAgICAgICBsZXQgaW1hZ2VzID0gaW5kaWNlcy5tYXAoKGluZGV4KSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwcml0ZXNbaW5kZXhdO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGltYWdlcyA9IGltYWdlcy5tYXAoZnVuY3Rpb24gKGkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGkuY2xvbmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbl9BbmltYXRpb24oZW5naW5lLCBpbWFnZXMsIHNwZWVkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGFuaW1hdGlvbiBmcm9tIHRoZSB0aGlzIFNwcml0ZVNoZWV0IGJ5IHNwZWNpZnlpbmcgdGhlIHJhbmdlIG9mXHJcbiAgICAgKiBpbWFnZXMgd2l0aCB0aGUgYmVnaW5uaW5nIChpbmNsdXNpdmUpIGFuZCBlbmRpbmcgKGV4Y2x1c2l2ZSkgaW5kZXhcclxuICAgICAqIEZvciBleGFtcGxlIGBnZXRBbmltYXRpb25CZXR3ZWVuKGVuZ2luZSwgMCwgNSwgMjAwKWAgcmV0dXJucyBhbiBhbmltYXRpb24gd2l0aCA1IGZyYW1lcy5cclxuICAgICAqIEBwYXJhbSBlbmdpbmUgICAgICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBFbmdpbmVcclxuICAgICAqIEBwYXJhbSBiZWdpbkluZGV4ICBUaGUgaW5kZXggdG8gc3RhcnQgdGFraW5nIGZyYW1lcyAoaW5jbHVzaXZlKVxyXG4gICAgICogQHBhcmFtIGVuZEluZGV4ICAgIFRoZSBpbmRleCB0byBzdG9wIHRha2luZyBmcmFtZXMgKGV4Y2x1c2l2ZSlcclxuICAgICAqIEBwYXJhbSBzcGVlZCAgICAgICBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICovXHJcbiAgICBnZXRBbmltYXRpb25CZXR3ZWVuKGVuZ2luZSwgYmVnaW5JbmRleCwgZW5kSW5kZXgsIHNwZWVkKSB7XHJcbiAgICAgICAgbGV0IGltYWdlcyA9IHRoaXMuc3ByaXRlcy5zbGljZShiZWdpbkluZGV4LCBlbmRJbmRleCk7XHJcbiAgICAgICAgaW1hZ2VzID0gaW1hZ2VzLm1hcChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uX0FuaW1hdGlvbihlbmdpbmUsIGltYWdlcywgc3BlZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmVhdCB0aGUgZW50aXJlIFNwcml0ZVNoZWV0IGFzIG9uZSBhbmltYXRpb24sIG9yZ2FuaXppbmcgdGhlIGZyYW1lcyBpblxyXG4gICAgICogcm93IG1ham9yIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIGVuZ2luZSAgUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IGdhbWUgW1tFbmdpbmVdXVxyXG4gICAgICogQHBhcmFtIHNwZWVkICAgVGhlIG51bWJlciBpbiBtaWxsaXNlY29uZHMgdG8gZGlzcGxheSBlYWNoIGZyYW1lIHRoZSBhbmltYXRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0QW5pbWF0aW9uRm9yQWxsKGVuZ2luZSwgc3BlZWQpIHtcclxuICAgICAgICBjb25zdCBzcHJpdGVzID0gdGhpcy5zcHJpdGVzLm1hcChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uX0FuaW1hdGlvbihlbmdpbmUsIHNwcml0ZXMsIHNwZWVkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmUgYSBzcGVjaWZpYyBzcHJpdGUgZnJvbSB0aGUgU3ByaXRlU2hlZXQgYnkgaXRzIGluZGV4LiBTcHJpdGVzIGFyZSBvcmdhbml6ZWRcclxuICAgICAqIGluIHJvdyBtYWpvciBvcmRlciBpbiB0aGUgU3ByaXRlU2hlZXQuXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggIFRoZSBpbmRleCBvZiB0aGUgc3ByaXRlXHJcbiAgICAgKi9cclxuICAgIGdldFNwcml0ZShpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgdGhpcy5zcHJpdGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcHJpdGVzW2luZGV4XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmRleDogJyArIGluZGV4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbiBhbmltYXRpb24gd2l0aCBiZXNwb2tlIHNwcml0ZSBjb29yZGluYXRlcy4gVGhpcyBpcyB1c2VmdWwgaWYgdGhlIFNwcml0ZVNoZWV0IGlzXHJcbiAgICAgKiBwYWNrZWQgYW5kIG5vdCBhIHVuaWZvcm0gd2lkdGggb3IgaGVpZ2h0LiBUaGUgcmVzdWx0aW5nIFtbQW5pbWF0aW9uXV0gd2lsbCBoYXZlIHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRoZVxyXG4gICAgICogbGFyZ2VzdCBkaW1lbnNpb24gKHdpZHRoLCBoZWlnaHQpIGZyb20gYW1vbmcgdGhlIHNwcml0ZSBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIGVuZ2luZVxyXG4gICAgICogQHBhcmFtIHNwcml0ZUNvb3JkaW5hdGVzXHJcbiAgICAgKiBAcGFyYW0gc3BlZWRcclxuICAgICAqL1xyXG4gICAgZ2V0QW5pbWF0aW9uQnlDb29yZHMoZW5naW5lLCBzcHJpdGVDb29yZGluYXRlcywgc3BlZWQpIHtcclxuICAgICAgICBsZXQgbWF4V2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBtYXhIZWlnaHQgPSAwO1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZXMgPSBuZXcgQXJyYXkoc3ByaXRlQ29vcmRpbmF0ZXMubGVuZ3RoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwcml0ZUNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkID0gc3ByaXRlQ29vcmRpbmF0ZXNbaV07XHJcbiAgICAgICAgICAgIC8vIG5vIG5lZWQgdG8gcGFzcyBpbWFnZSBhZ2FpbiBpZiB1c2luZyBhIHNwcml0ZXNoZWV0XHJcbiAgICAgICAgICAgIGNvb3JkLmltYWdlID0gY29vcmQuaW1hZ2UgfHwgdGhpcy5pbWFnZTtcclxuICAgICAgICAgICAgbWF4V2lkdGggPSBNYXRoLm1heChtYXhXaWR0aCwgY29vcmQuZHJhd1dpZHRoKTtcclxuICAgICAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgobWF4SGVpZ2h0LCBjb29yZC5kcmF3SGVpZ2h0KTtcclxuICAgICAgICAgICAgc3ByaXRlc1tpXSA9IG5ldyBTcHJpdGVfU3ByaXRlKGNvb3JkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYW5pbSA9IG5ldyBBbmltYXRpb25fQW5pbWF0aW9uKGVuZ2luZSwgc3ByaXRlcywgc3BlZWQpO1xyXG4gICAgICAgIGFuaW0uZHJhd1dpZHRoID0gbWF4V2lkdGg7XHJcbiAgICAgICAgYW5pbS5kcmF3SGVpZ2h0ID0gbWF4SGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiBhbmltO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBTcHJpdGUgZm9udHMgYXJlIGEgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgW1tMYWJlbF1dIHRvIHNwZWNpZnlcclxuICogYSBwYXJ0aWN1bGFyIGJpdG1hcCBhcyBhIGZvbnQuIE5vdGUgdGhhdCBzb21lIGZvbnQgZmVhdHVyZXMgYXJlIG5vdFxyXG4gKiBzdXBwb3J0ZWQgYnkgU3ByaXRlIGZvbnRzLlxyXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW50byB2MC4yNi4wXHJcbiAqL1xyXG5sZXQgU3ByaXRlRm9udCA9IGNsYXNzIFNwcml0ZUZvbnQgZXh0ZW5kcyBTcHJpdGVTaGVldF9TcHJpdGVTaGVldCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBpbWFnZU9yQ29uZmlnICAgVGhlIGJhY2tpbmcgaW1hZ2UgdGV4dHVyZSB0byBidWlsZCB0aGUgU3ByaXRlRm9udCBvciB0aGUgc3ByaXRlIGZvbnQgb3B0aW9uIGJhZ1xyXG4gICAgICogQHBhcmFtIGFscGhhYmV0ICAgICAgICBBIHN0cmluZyByZXByZXNlbnRpbmcgYWxsIHRoZSBjaGFyYWN0ZXJzIGluIHRoZSBpbWFnZSwgaW4gcm93IG1ham9yIG9yZGVyLlxyXG4gICAgICogQHBhcmFtIGNhc2VJbnNlbnNpdGl2ZSAgSW5kaWNhdGUgd2hldGhlciB0aGlzIGZvbnQgdGFrZXMgY2FzZSBpbnRvIGFjY291bnRcclxuICAgICAqIEBwYXJhbSBjb2x1bW5zICAgICAgICAgVGhlIG51bWJlciBvZiBjb2x1bW5zIG9mIGNoYXJhY3RlcnMgaW4gdGhlIGltYWdlXHJcbiAgICAgKiBAcGFyYW0gcm93cyAgICAgICAgICAgIFRoZSBudW1iZXIgb2Ygcm93cyBvZiBjaGFyYWN0ZXJzIGluIHRoZSBpbWFnZVxyXG4gICAgICogQHBhcmFtIHNwV2lkdGggICAgICAgICBUaGUgd2lkdGggb2YgZWFjaCBjaGFyYWN0ZXIgaW4gcGl4ZWxzXHJcbiAgICAgKiBAcGFyYW0gc3BIZWlnaHQgICAgICAgIFRoZSBoZWlnaHQgb2YgZWFjaCBjaGFyYWN0ZXIgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGltYWdlT3JDb25maWcsIGFscGhhYmV0LCBjYXNlSW5zZW5zaXRpdmUsIGNvbHVtbnMsIHJvd3MsIHNwV2lkdGgsIHNwSGVpZ2h0LCBzcGFjaW5nKSB7XHJcbiAgICAgICAgc3VwZXIoaW1hZ2VPckNvbmZpZyBpbnN0YW5jZW9mIFRleHR1cmVcclxuICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2VPckNvbmZpZyxcclxuICAgICAgICAgICAgICAgIHNwV2lkdGg6IHNwV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBzcEhlaWdodDogc3BIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICByb3dzOiByb3dzLFxyXG4gICAgICAgICAgICAgICAgY29sdW1uczogY29sdW1ucyxcclxuICAgICAgICAgICAgICAgIHNwYWNpbmc6IHNwYWNpbmcgfHwgMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIDogaW1hZ2VPckNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yID0gQ29sb3IuQmxhY2s7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE9wYWNpdHkgPSAxLjA7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlUmVjb3JkID0ge307XHJcbiAgICAgICAgLy8gdGV4dCBzaGFkb3dcclxuICAgICAgICB0aGlzLl90ZXh0U2hhZG93T24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90ZXh0U2hhZG93RGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3RleHRTaGFkb3dDb2xvciA9IENvbG9yLkJsYWNrO1xyXG4gICAgICAgIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzID0ge307XHJcbiAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WCA9IDU7XHJcbiAgICAgICAgdGhpcy5fc2hhZG93T2Zmc2V0WSA9IDU7XHJcbiAgICAgICAgaWYgKGltYWdlT3JDb25maWcgJiYgIShpbWFnZU9yQ29uZmlnIGluc3RhbmNlb2YgVGV4dHVyZSkpIHtcclxuICAgICAgICAgICAgYWxwaGFiZXQgPSBpbWFnZU9yQ29uZmlnLmFscGhhYmV0O1xyXG4gICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmUgPSBpbWFnZU9yQ29uZmlnLmNhc2VJbnNlbnNpdGl2ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hbHBoYWJldCA9IGFscGhhYmV0O1xyXG4gICAgICAgIHRoaXMuY2FzZUluc2Vuc2l0aXZlID0gY2FzZUluc2Vuc2l0aXZlO1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZVJlY29yZCA9IHRoaXMuZ2V0VGV4dFNwcml0ZXMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGRpY3Rpb25hcnkgdGhhdCBtYXBzIGVhY2ggY2hhcmFjdGVyIGluIHRoZSBhbHBoYWJldCB0byB0aGUgYXBwcm9wcmlhdGUgW1tTcHJpdGVdXS5cclxuICAgICAqL1xyXG4gICAgZ2V0VGV4dFNwcml0ZXMoKSB7XHJcbiAgICAgICAgY29uc3QgbG9va3VwID0ge307XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFscGhhYmV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGxldCBjaGFyID0gdGhpcy5hbHBoYWJldFtpXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FzZUluc2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFyID0gY2hhci50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxvb2t1cFtjaGFyXSA9IHRoaXMuc3ByaXRlc1tpXS5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG9va3VwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB0ZXh0IHNoYWRvdyBmb3Igc3ByaXRlIGZvbnRzXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0WCAgICAgIFRoZSB4IG9mZnNldCBpbiBwaXhlbHMgdG8gcGxhY2UgdGhlIHNoYWRvd1xyXG4gICAgICogQHBhcmFtIG9mZnNldFkgICAgICBUaGUgeSBvZmZzZXQgaW4gcGl4ZWxzIHRvIHBsYWNlIHRoZSBzaGFkb3dcclxuICAgICAqIEBwYXJhbSBzaGFkb3dDb2xvciAgVGhlIGNvbG9yIG9mIHRoZSB0ZXh0IHNoYWRvd1xyXG4gICAgICovXHJcbiAgICBzZXRUZXh0U2hhZG93KG9mZnNldFgsIG9mZnNldFksIHNoYWRvd0NvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5fdGV4dFNoYWRvd09uID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRYID0gb2Zmc2V0WDtcclxuICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRZID0gb2Zmc2V0WTtcclxuICAgICAgICB0aGlzLl90ZXh0U2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvci5jbG9uZSgpO1xyXG4gICAgICAgIHRoaXMuX3RleHRTaGFkb3dEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGFyYWN0ZXIgaW4gdGhpcy5fc3ByaXRlUmVjb3JkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzW2NoYXJhY3Rlcl0gPSB0aGlzLl9zcHJpdGVSZWNvcmRbY2hhcmFjdGVyXS5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG9nZ2xlcyB0ZXh0IHNoYWRvd3Mgb24gb3Igb2ZmXHJcbiAgICAgKi9cclxuICAgIHVzZVRleHRTaGFkb3cob24pIHtcclxuICAgICAgICB0aGlzLl90ZXh0U2hhZG93T24gPSBvbjtcclxuICAgICAgICBpZiAob24pIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRUZXh0U2hhZG93KDUsIDUsIHRoaXMuX3RleHRTaGFkb3dDb2xvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgY3VycmVudCBzcHJpdGUgZm9udFxyXG4gICAgICovXHJcbiAgICBkcmF3KGN0eCwgdGV4dCwgeCwgeSwgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSB0aGlzLl9wYXJzZU9wdGlvbnMob3B0aW9ucyk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRDb2xvci50b1N0cmluZygpICE9PSBvcHRpb25zLmNvbG9yLnRvU3RyaW5nKCkgfHwgdGhpcy5fY3VycmVudE9wYWNpdHkgIT09IG9wdGlvbnMub3BhY2l0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50T3BhY2l0eSA9IG9wdGlvbnMub3BhY2l0eTtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudENvbG9yID0gb3B0aW9ucy5jb2xvcjtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjaGFyIGluIHRoaXMuX3Nwcml0ZVJlY29yZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlUmVjb3JkW2NoYXJdLmNsZWFyRWZmZWN0cygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlUmVjb3JkW2NoYXJdLmZpbGwob3B0aW9ucy5jb2xvcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGVSZWNvcmRbY2hhcl0ub3BhY2l0eShvcHRpb25zLm9wYWNpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl90ZXh0U2hhZG93T24gJiYgdGhpcy5fdGV4dFNoYWRvd0RpcnR5ICYmIHRoaXMuX3RleHRTaGFkb3dDb2xvcikge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoYXJhY3RlclNoYWRvdyBpbiB0aGlzLl90ZXh0U2hhZG93U3ByaXRlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyU2hhZG93XS5jbGVhckVmZmVjdHMoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzW2NoYXJhY3RlclNoYWRvd10uYWRkRWZmZWN0KG5ldyBGaWxsKHRoaXMuX3RleHRTaGFkb3dDb2xvci5jbG9uZSgpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd0RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnQgbGVuZ3RoIG9mIHRleHQgaW4gcGl4ZWxzXHJcbiAgICAgICAgY29uc3Qgc3ByaXRlID0gdGhpcy5zcHJpdGVzWzBdO1xyXG4gICAgICAgIC8vIGZpbmQgdGhlIGN1cnJlbnQgaGVpZ2h0IGZvIHRoZSB0ZXh0IGluIHBpeGVsc1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHNwcml0ZS5oZWlnaHQ7XHJcbiAgICAgICAgLy8gY2FsY3VsYXRlIGFwcHJvcHJpYXRlIHNjYWxlIGZvciBmb250IHNpemVcclxuICAgICAgICBjb25zdCBzY2FsZSA9IG9wdGlvbnMuZm9udFNpemUgLyBoZWlnaHQ7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGV4dC5sZW5ndGggKiBzcHJpdGUud2lkdGggKiBzY2FsZSArIHRleHQubGVuZ3RoICogb3B0aW9ucy5sZXR0ZXJTcGFjaW5nO1xyXG4gICAgICAgIGxldCBjdXJyWCA9IHg7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMudGV4dEFsaWduID09PSBUZXh0QWxpZ24uTGVmdCB8fCBvcHRpb25zLnRleHRBbGlnbiA9PT0gVGV4dEFsaWduLlN0YXJ0KSB7XHJcbiAgICAgICAgICAgIGN1cnJYID0geDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy50ZXh0QWxpZ24gPT09IFRleHRBbGlnbi5SaWdodCB8fCBvcHRpb25zLnRleHRBbGlnbiA9PT0gVGV4dEFsaWduLkVuZCkge1xyXG4gICAgICAgICAgICBjdXJyWCA9IHggLSBsZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMudGV4dEFsaWduID09PSBUZXh0QWxpZ24uQ2VudGVyKSB7XHJcbiAgICAgICAgICAgIGN1cnJYID0geCAtIGxlbmd0aCAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjdXJyWSA9IHkgLSBoZWlnaHQgKiBzY2FsZTtcclxuICAgICAgICBpZiAob3B0aW9ucy5iYXNlQWxpZ24gPT09IEJhc2VBbGlnbi5Ub3AgfHwgb3B0aW9ucy5iYXNlQWxpZ24gPT09IEJhc2VBbGlnbi5IYW5naW5nKSB7XHJcbiAgICAgICAgICAgIGN1cnJZID0geTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5iYXNlQWxpZ24gPT09IEJhc2VBbGlnbi5JZGVvZ3JhcGhpYyB8fFxyXG4gICAgICAgICAgICBvcHRpb25zLmJhc2VBbGlnbiA9PT0gQmFzZUFsaWduLkJvdHRvbSB8fFxyXG4gICAgICAgICAgICBvcHRpb25zLmJhc2VBbGlnbiA9PT0gQmFzZUFsaWduLkFscGhhYmV0aWMpIHtcclxuICAgICAgICAgICAgY3VyclkgPSB5IC0gaGVpZ2h0ICogc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuYmFzZUFsaWduID09PSBCYXNlQWxpZ24uTWlkZGxlKSB7XHJcbiAgICAgICAgICAgIGN1cnJZID0geSAtIChoZWlnaHQgKiBzY2FsZSkgLyAyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNoYXJhY3RlciA9IHRleHRbaV07XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNhc2VJbnNlbnNpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgY2hhcmFjdGVyID0gY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHRleHQgc2hhZG93XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGV4dFNoYWRvd09uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXS5kcmF3QXJvdW5kQW5jaG9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXS5zY2FsZSA9IHZlYyhzY2FsZSwgc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzW2NoYXJhY3Rlcl0uZHJhdyhjdHgsIGN1cnJYICsgdGhpcy5fc2hhZG93T2Zmc2V0WCwgY3VyclkgKyB0aGlzLl9zaGFkb3dPZmZzZXRZKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJTcHJpdGUgPSB0aGlzLl9zcHJpdGVSZWNvcmRbY2hhcmFjdGVyXTtcclxuICAgICAgICAgICAgICAgIGNoYXJTcHJpdGUuZHJhd0Fyb3VuZEFuY2hvciA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY2hhclNwcml0ZS5zY2FsZSA9IHZlYyhzY2FsZSwgc2NhbGUpO1xyXG4gICAgICAgICAgICAgICAgY2hhclNwcml0ZS5kcmF3KGN0eCwgY3VyclgsIGN1cnJZKTtcclxuICAgICAgICAgICAgICAgIGN1cnJYICs9IGNoYXJTcHJpdGUuZHJhd1dpZHRoICsgb3B0aW9ucy5sZXR0ZXJTcGFjaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihgU3ByaXRlRm9udCBFcnJvciBkcmF3aW5nIGNoYXIgJHtjaGFyYWN0ZXJ9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcGFyc2VPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBmb250U2l6ZTogb3B0aW9ucy5mb250U2l6ZSB8fCAxMCxcclxuICAgICAgICAgICAgbGV0dGVyU3BhY2luZzogb3B0aW9ucy5sZXR0ZXJTcGFjaW5nIHx8IDAsXHJcbiAgICAgICAgICAgIGNvbG9yOiBvcHRpb25zLmNvbG9yIHx8IENvbG9yLkJsYWNrLFxyXG4gICAgICAgICAgICB0ZXh0QWxpZ246IHR5cGVvZiBvcHRpb25zLnRleHRBbGlnbiA9PT0gdW5kZWZpbmVkID8gVGV4dEFsaWduLkxlZnQgOiBvcHRpb25zLnRleHRBbGlnbixcclxuICAgICAgICAgICAgYmFzZUFsaWduOiB0eXBlb2Ygb3B0aW9ucy5iYXNlQWxpZ24gPT09IHVuZGVmaW5lZCA/IEJhc2VBbGlnbi5Cb3R0b20gOiBvcHRpb25zLmJhc2VBbGlnbixcclxuICAgICAgICAgICAgbWF4V2lkdGg6IG9wdGlvbnMubWF4V2lkdGggfHwgLTEsXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IG9wdGlvbnMub3BhY2l0eSB8fCAwXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufTtcclxuU3ByaXRlRm9udCA9IFNwcml0ZVNoZWV0X2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnU3ByaXRlU2hlZXQgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBHcmFwaGljcy5TcHJpdGVTaGVldCdcclxuICAgIH0pXHJcbl0sIFNwcml0ZUZvbnQpO1xyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9TcHJpdGVTaGVldC50c1xuXHJcblxyXG5cclxuLyoqXHJcbiAqIFJlcHJlc2VudHMgYSBjb2xsZWN0aW9uIG9mIHNwcml0ZXMgZnJvbSBhIHNvdXJjZSBpbWFnZSB3aXRoIHNvbWUgb3JnYW5pemF0aW9uIGluIGEgZ3JpZFxyXG4gKi9cclxuY2xhc3MgU3ByaXRlU2hlZXQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCBhIG5ldyBzcHJpdGUgc2hlZXQgZnJvbSBhIGxpc3Qgb2Ygc3ByaXRlc1xyXG4gICAgICpcclxuICAgICAqIFVzZSBbW1Nwcml0ZVNoZWV0LmZyb21JbWFnZVNvdXJjZV1dIHRvIGNyZWF0ZSBhIFNwcml0ZVNoZWV0IGZyb20gYW4gW1tJbWFnZVNvdXJjZV1dIG9yZ2FuaXplZCBpbiBhIGdyaWRcclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLnNwcml0ZXMgPSBbXTtcclxuICAgICAgICBjb25zdCB7IHNwcml0ZXMsIHJvd3MsIGNvbHVtbnMgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVzID0gc3ByaXRlcztcclxuICAgICAgICB0aGlzLnJvd3MgPSByb3dzICE9PSBudWxsICYmIHJvd3MgIT09IHZvaWQgMCA/IHJvd3MgOiAxO1xyXG4gICAgICAgIHRoaXMuY29sdW1ucyA9IGNvbHVtbnMgIT09IG51bGwgJiYgY29sdW1ucyAhPT0gdm9pZCAwID8gY29sdW1ucyA6IHRoaXMuc3ByaXRlcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgYSBzcHJpdGUgYnkgdGhlaXIgeC95IHBvc2l0aW9uIGluIHRoZSBTcHJpdGVTaGVldCwgZm9yIGV4YW1wbGUgYGdldFNwcml0ZSgwLCAwKWAgaXMgdGhlIFtbU3ByaXRlXV0gaW4gdGhlIHRvcC1sZWZ0XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgZ2V0U3ByaXRlKHgsIHkpIHtcclxuICAgICAgICBpZiAoeCA+PSB0aGlzLmNvbHVtbnMgfHwgeCA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYE5vIHNwcml0ZSBleGlzdHMgaW4gdGhlIFNwcml0ZVNoZWV0IGF0ICgke3h9LCAke3l9KSwgeDogJHt4fSBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMuY29sdW1ucyAtIDF9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoeSA+PSB0aGlzLnJvd3MgfHwgeSA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYE5vIHNwcml0ZSBleGlzdHMgaW4gdGhlIFNwcml0ZVNoZWV0IGF0ICgke3h9LCAke3l9KSwgeTogJHt5fSBzaG91bGQgYmUgYmV0d2VlbiAwIGFuZCAke3RoaXMucm93cyAtIDF9YCk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzcHJpdGVJbmRleCA9IHggKyB5ICogdGhpcy5jb2x1bW5zO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNwcml0ZXNbc3ByaXRlSW5kZXhdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUbyBhIGdyYXBoaWNzIHNwcml0ZSBzaGVldCBmcm9tIGEgbGVnYWN5IHNwcml0ZSBzaGVldFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUxlZ2FjeVNwcml0ZVNoZWV0KGxlZ2FjeVNwcml0ZVNoZWV0KSB7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlcyA9IGxlZ2FjeVNwcml0ZVNoZWV0LnNwcml0ZXMubWFwKG9sZFNwcml0ZSA9PiBTcHJpdGUuZnJvbUxlZ2FjeVNwcml0ZShvbGRTcHJpdGUpKTtcclxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZVNoZWV0KHtcclxuICAgICAgICAgICAgc3ByaXRlc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHBhcmFtIHNwcml0ZVNoZWV0XHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdG9MZWdhY3lTcHJpdGVTaGVldChzcHJpdGVTaGVldCkge1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZXMgPSBzcHJpdGVTaGVldC5zcHJpdGVzLm1hcChzcHJpdGUgPT4gU3ByaXRlLnRvTGVnYWN5U3ByaXRlKHNwcml0ZSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlU2hlZXRfU3ByaXRlU2hlZXQoc3ByaXRlcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIFNwcml0ZVNoZWV0IGZyb20gYW4gW1tJbWFnZVNvdXJjZV1dIG9yZ2FuaXplZCBpbiBhIGdyaWRcclxuICAgICAqXHJcbiAgICAgKiBFeGFtcGxlOlxyXG4gICAgICogYGBgXHJcbiAgICAgKiBjb25zdCBzcHJpdGVTaGVldCA9IFNwcml0ZVNoZWV0LmZyb21JbWFnZVNvdXJjZSh7XHJcbiAgICAgKiAgIGltYWdlOiBpbWFnZVNvdXJjZSxcclxuICAgICAqICAgZ3JpZDoge1xyXG4gICAgICogICAgIHJvd3M6IDUsXHJcbiAgICAgKiAgICAgY29sdW1uczogMixcclxuICAgICAqICAgICBzcHJpdGVXaWR0aDogMzIsIC8vIHBpeGVsc1xyXG4gICAgICogICAgIHNwcml0ZUhlaWdodDogMzIgLy8gcGl4ZWxzXHJcbiAgICAgKiAgIH0sXHJcbiAgICAgKiAgIC8vIE9wdGlvbmFsbHkgc3BlY2lmeSBzcGFjaW5nXHJcbiAgICAgKiAgIHNwYWNpbmc6IHtcclxuICAgICAqICAgICAvLyBwaXhlbHMgZnJvbSB0aGUgdG9wIGxlZnQgdG8gc3RhcnQgdGhlIHNwcml0ZSBwYXJzaW5nXHJcbiAgICAgKiAgICAgb3JpZ2luT2Zmc2V0OiB7XHJcbiAgICAgKiAgICAgICB4OiA1LFxyXG4gICAgICogICAgICAgeTogNVxyXG4gICAgICogICAgIH0sXHJcbiAgICAgKiAgICAgLy8gcGl4ZWxzIGJldHdlZW4gZWFjaCBzcHJpdGUgd2hpbGUgcGFyc2luZ1xyXG4gICAgICogICAgIG1hcmdpbjoge1xyXG4gICAgICogICAgICAgeDogMSxcclxuICAgICAqICAgICAgIHk6IDFcclxuICAgICAqICAgICB9XHJcbiAgICAgKiAgIH1cclxuICAgICAqIH0pXHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUltYWdlU291cmNlKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlcyA9IFtdO1xyXG4gICAgICAgIG9wdGlvbnMuc3BhY2luZyA9IChfYSA9IG9wdGlvbnMuc3BhY2luZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XHJcbiAgICAgICAgY29uc3QgeyBpbWFnZSwgZ3JpZDogeyByb3dzLCBjb2x1bW5zOiBjb2xzLCBzcHJpdGVXaWR0aCwgc3ByaXRlSGVpZ2h0IH0sIHNwYWNpbmc6IHsgb3JpZ2luT2Zmc2V0LCBtYXJnaW4gfSB9ID0gb3B0aW9ucztcclxuICAgICAgICBjb25zdCBvZmZzZXREZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oeyB4OiAwLCB5OiAwIH0sIG9yaWdpbk9mZnNldCk7XHJcbiAgICAgICAgY29uc3QgbWFyZ2luRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKHsgeDogMCwgeTogMCB9LCBtYXJnaW4pO1xyXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgY29sczsgeCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgcm93czsgeSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGVzW3ggKyB5ICogY29sc10gPSBuZXcgU3ByaXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBpbWFnZTogaW1hZ2UsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlVmlldzoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB4ICogc3ByaXRlV2lkdGggKyBtYXJnaW5EZWZhdWx0cy54ICogeCArIG9mZnNldERlZmF1bHRzLngsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IHkgKiBzcHJpdGVIZWlnaHQgKyBtYXJnaW5EZWZhdWx0cy55ICogeSArIG9mZnNldERlZmF1bHRzLnksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzcHJpdGVXaWR0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzcHJpdGVIZWlnaHRcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGRlc3RTaXplOiB7IGhlaWdodDogc3ByaXRlSGVpZ2h0LCB3aWR0aDogc3ByaXRlV2lkdGggfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGVTaGVldCh7XHJcbiAgICAgICAgICAgIHNwcml0ZXM6IHNwcml0ZXMsXHJcbiAgICAgICAgICAgIHJvd3M6IHJvd3MsXHJcbiAgICAgICAgICAgIGNvbHVtbnM6IGNvbHNcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL1Nwcml0ZUZvbnQudHNcblxyXG5cclxuXHJcblxyXG5jbGFzcyBTcHJpdGVGb250X1Nwcml0ZUZvbnQgZXh0ZW5kcyBHcmFwaGljIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl90ZXh0ID0gJyc7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuYWxwaGFiZXQgPSAnJztcclxuICAgICAgICB0aGlzLnNoYWRvdyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jYXNlSW5zZW5zaXRpdmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnNwYWNpbmcgPSAwO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZXMgPSBbXTtcclxuICAgICAgICBjb25zdCB7IGFscGhhYmV0LCBzcHJpdGVTaGVldCwgY2FzZUluc2Vuc2l0aXZlLCBzcGFjaW5nLCBzaGFkb3cgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5hbHBoYWJldCA9IGFscGhhYmV0O1xyXG4gICAgICAgIHRoaXMuc3ByaXRlU2hlZXQgPSBzcHJpdGVTaGVldDtcclxuICAgICAgICB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IGNhc2VJbnNlbnNpdGl2ZSAhPT0gbnVsbCAmJiBjYXNlSW5zZW5zaXRpdmUgIT09IHZvaWQgMCA/IGNhc2VJbnNlbnNpdGl2ZSA6IHRoaXMuY2FzZUluc2Vuc2l0aXZlO1xyXG4gICAgICAgIHRoaXMuc3BhY2luZyA9IHNwYWNpbmcgIT09IG51bGwgJiYgc3BhY2luZyAhPT0gdm9pZCAwID8gc3BhY2luZyA6IHRoaXMuc3BhY2luZztcclxuICAgICAgICB0aGlzLnNoYWRvdyA9IHNoYWRvdyAhPT0gbnVsbCAmJiBzaGFkb3cgIT09IHZvaWQgMCA/IHNoYWRvdyA6IHRoaXMuc2hhZG93O1xyXG4gICAgICAgIHRoaXMuc3ByaXRlU2hlZXQuc3ByaXRlc1swXS5pbWFnZS5yZWFkeS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21MZWdhY3lTcHJpdGVGb250KHNwcml0ZUZvbnQpIHtcclxuICAgICAgICBjb25zdCBzcHJpdGVzID0gc3ByaXRlRm9udC5zcHJpdGVzLm1hcChTcHJpdGUuZnJvbUxlZ2FjeVNwcml0ZSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGVGb250X1Nwcml0ZUZvbnQoe1xyXG4gICAgICAgICAgICBhbHBoYWJldDogc3ByaXRlRm9udC5hbHBoYWJldCxcclxuICAgICAgICAgICAgc3BhY2luZzogMCxcclxuICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlOiBzcHJpdGVGb250LmNhc2VJbnNlbnNpdGl2ZSxcclxuICAgICAgICAgICAgc3ByaXRlU2hlZXQ6IG5ldyBTcHJpdGVTaGVldCh7XHJcbiAgICAgICAgICAgICAgICBzcHJpdGVzXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0Q2hhcmFjdGVyU3ByaXRlcyh0ZXh0KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3ByaXRlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIC8vIGhhbmRsZSBjYXNlIGluc2Vuc3RpdmVcclxuICAgICAgICBjb25zdCB0ZXh0VG9SZW5kZXIgPSB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA/IHRleHQudG9Mb2NhbGVMb3dlckNhc2UoKSA6IHRleHQ7XHJcbiAgICAgICAgY29uc3QgYWxwaGFiZXQgPSB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA/IHRoaXMuYWxwaGFiZXQudG9Mb2NhbGVMb3dlckNhc2UoKSA6IHRoaXMuYWxwaGFiZXQ7XHJcbiAgICAgICAgLy8gZm9yIGVhY2ggbGV0dGVyIGluIHRleHRcclxuICAgICAgICBmb3IgKGxldCBsZXR0ZXJJbmRleCA9IDA7IGxldHRlckluZGV4IDwgdGV4dFRvUmVuZGVyLmxlbmd0aDsgbGV0dGVySW5kZXgrKykge1xyXG4gICAgICAgICAgICAvLyBmaW5kIHRoZSBzcHJpdGUgaW5kZXggaW4gYWxwaGFiZXQgLCBpZiB0aGVyZSBpcyBhbiBlcnJvciBwaWNrIHRoZSBmaXJzdFxyXG4gICAgICAgICAgICBjb25zdCBsZXR0ZXIgPSB0ZXh0VG9SZW5kZXJbbGV0dGVySW5kZXhdO1xyXG4gICAgICAgICAgICBsZXQgc3ByaXRlSW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XHJcbiAgICAgICAgICAgIGlmIChzcHJpdGVJbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHNwcml0ZUluZGV4ID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBTcHJpdGVGb250IC0gQ2Fubm90IGZpbmQgbGV0dGVyICcke2xldHRlcn0nIGluIGNvbmZpZ3VyZWQgYWxwaGFiZXQgJyR7YWxwaGFiZXR9J2ApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGxldHRlclNwcml0ZSA9IHRoaXMuc3ByaXRlU2hlZXQuc3ByaXRlc1tzcHJpdGVJbmRleF07XHJcbiAgICAgICAgICAgIGlmIChsZXR0ZXJTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChsZXR0ZXJTcHJpdGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYFNwcml0ZUZvbnQgLSBDYW5ub3QgZmluZCBzcHJpdGUgZm9yICcke2xldHRlcn0nIGF0IGluZGV4ICcke3Nwcml0ZUluZGV4fScgaW4gY29uZmlndXJlZCBTcHJpdGVTaGVldGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9zcHJpdGVzID0gcmVzdWx0cyk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRGltZW5zaW9ucygpIHtcclxuICAgICAgICBjb25zdCBzcHJpdGVzID0gdGhpcy5fZ2V0Q2hhcmFjdGVyU3ByaXRlcyh0aGlzLl90ZXh0KTtcclxuICAgICAgICBsZXQgd2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBoZWlnaHQgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3ByaXRlIG9mIHNwcml0ZXMpIHtcclxuICAgICAgICAgICAgd2lkdGggKz0gc3ByaXRlLndpZHRoICsgdGhpcy5zcGFjaW5nO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIHNwcml0ZS5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVUZXh0KHRleHQpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGV4dCAhPT0gdGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHQgPSB0ZXh0O1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3ByZURyYXcoZXgsIHgsIHkpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgc3VwZXIuX3ByZURyYXcoZXgsIHgsIHkpO1xyXG4gICAgfVxyXG4gICAgX2RyYXdJbWFnZShleCwgeCwgeSkge1xyXG4gICAgICAgIGxldCBjdXJzb3IgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3ByaXRlIG9mIHRoaXMuX2dldENoYXJhY3RlclNwcml0ZXModGhpcy5fdGV4dCkpIHtcclxuICAgICAgICAgICAgLy8gZHJhdyBpdCBpbiB0aGUgcmlnaHQgc3BvdCBhbmQgaW5jcmVhc2UgdGhlIGN1cnNvciBieSBzcHJpdGUgd2lkdGhcclxuICAgICAgICAgICAgc3ByaXRlLmRyYXcoZXgsIHggKyBjdXJzb3IsIHkpO1xyXG4gICAgICAgICAgICBjdXJzb3IgKz0gc3ByaXRlLndpZHRoICsgdGhpcy5zcGFjaW5nO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbmRlcihleCwgdGV4dCwgeCwgeSkge1xyXG4gICAgICAgIGlmICh0aGlzLl90ZXh0ICE9PSB0ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dCA9IHRleHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNoYWRvdykge1xyXG4gICAgICAgICAgICBleC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGV4LnRyYW5zbGF0ZSh0aGlzLnNoYWRvdy5vZmZzZXQueCwgdGhpcy5zaGFkb3cub2Zmc2V0LnkpO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXcoZXgsIHgsIHkpO1xyXG4gICAgICAgICAgICBleC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZHJhdyhleCwgeCwgeSk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZUZvbnRfU3ByaXRlRm9udCh7XHJcbiAgICAgICAgICAgIGFscGhhYmV0OiB0aGlzLmFscGhhYmV0LFxyXG4gICAgICAgICAgICBzcHJpdGVTaGVldDogdGhpcy5zcHJpdGVTaGVldCxcclxuICAgICAgICAgICAgc3BhY2luZzogdGhpcy5zcGFjaW5nXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2RlYnVnLWZvbnQucG5nXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGRlYnVnX2ZvbnQgPSAoXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQVFBQUFBQXdDQVlBQUFEK2Y2Ui9BQUFBQVhOU1IwSUFyczRjNlFBQUJjSkpSRUZVZUp6dG5lbXU3Q2dNaEdFMDcvL0ttVDlOaHJBRlZ6a1FuZFFudFhSUDMvYkNaa3dDU1FoQ0NDR0VFRUlJSVlRUVFvZy9UUno5NTNFY3gvbkRHSWUvdmROaGxjOXRJejYwNUZrL1ptV2ZzTzFobjlHeHV2MUtIYnZiM2lML1ZOK2QxV09SYnlyN3lSLzViOU00dmpOZXFrbzZqUEpIcTV3R0hVMTUxbzlKMlVkc2U5aG5kQ3h1djBySDdyWTN5RC9XZHlmMTNNcm5RZURma1pJVVNHS000ZmYzY1dOODJwRVp1VHlRR1gySXhleVI2M3ZhLy84Vk5DWUNxKzF5RWtMdFd5YWdYdjFQMXIxSCsxMTBnUDNQelQ0Z1Q4dVcvbWRROG1VRzhFOURxT3o0TVM5SUNLR2JYcFMyQnBuSXJSelllUzk2Y2xsMDhJTmxDTWwyL2dsemRjZmF6dXVQcVFPMDNsbXFyQkhzZjI3MlE2Tk9EWGo2enpaSUpkL0xBSFlUZzNNYXlzNWdCaTdaUjI3Zk9nczB5ajhybTM2RExNRmlQZ2tBZFhIS093VVFlTUNRL2FkU2gvcUJRclQvdFB4YkF3QTkrRE9aRUlMUEFBVFN1SE1nVHY3K0F1ay9kZjJsSFBDWkx2TVNMSmUzNExrRVE5UHdYRjFTUlRsbE1ZZ3ZJYWZscXlWQWpMR2JzaUNEY09LNzZqZmx4WitzSU5QeVJPYzUwNzF5S1dLNUNKVFYzZE1wNit0Qmx5Q3RObGhBcS8rWGJXb0JEY1JOWFlCTXpENFZ2UXlnU3VQWUMyakdHYVNTT3hYZnkzZFRVRXNhbkl2TmVlcG0zOE4vaHNzU0FMVFBabkFYZndJWVJKbjJiN1VCY3cwRktYK25EZEFNcG0yajlXVm54clVhN1RYYVZBY2EvQitUZ2FBVmg2Ui9ySDBQLzVtMDFkdC9STFlWaUpuK3cvYmhWWDJQN2YvZHVxb201cWIwMnBSTENMR0lNZ0JVMXdDRUVOOUJBVUNJRDZNQUlNU0hVUUFRNHNNb0FBanhZUlFBaFBnd2QxdUIwZnVaN0gzY25uMlArOW1yL1BlNEI4L2VCL2Z3UDRlUnRjaS8wZjZPZlRDUHQvOW9Id0M2RzZ5MTlSSFpEdW14bXd6UjRlRS9zLzJUdGUvcS8rWExkYzlEZUoxOWRpZXNRYy9qN1o4ZkNlNHRBUzRDeFo3c3A3ZWlKaTdIaVptam1PVEdKcys5M0NiUzNuUDBYSVBIM3ZXOC9xejZRUG5YMlFkc1YvMXV3L2laWXZnOEFDZUhkMjhycFB6Zk5maEwrN3Zrdy80T3U5cytPbmhidjkxZWxwS1o0OERsNmJ6cHd3aWJIaWdSQXJmK1B0azkrTDNZMVE1T0I0TGdDZVNCdzFpdUIzR2VKaDEvSHJYL3pGMEE5TWsrdTQ1ek1rYzNyNHJXUG9tbWE1K3AvNTE0TEIrWm85M01FckoxSkh4WFB6QnlHYS9saWNSWVZLYnBlUUNvUTZROHl4dUN3SkY5SVBzb0RrSEFvLzNUeDI2Y3ZBNEV0Si9uMDR3OFFPcS9tclI3ZGRmTEFDNUJZRk5sVkkvMENuT1ZVZmxPcHZKVVFNeDlBSU1JVy9uV0RNNjcvcXcwKzk1djlnb0JxRDlqKzcydS9LRDlVODlJYm5RYk1JUjJaYm5laDV6VVk3SGRrN1hJUDNVZmZWYityK3dEWUFaTHErMW4xK0M3eTMvbnkycjdwNXllQnlERWg5SHpBSVFRSndvQVFud1lCUUFoUG93Q2dCQmpvTnUzaE54U0ZBQ0U2SU51S3ZQYWpQWjRFRkVBRUtJTmN5YkdZek9kMjQ3V0VkM1RnQTJqbG1qRXlyZCtqOWh2ZlZiRDJQV1EzWm1HbHUySHlPOG9nOGVCdU5Vdk5ZV29EZ01WcHdIVEpvTFdkejFZK1pZT3k1dUY3dDZQUHJ1WnhBTnJ1ZDFsUVhrUDBqc0d6L1l6K3ZHR011eWdGeWhTUGNKbmMxcE1uUVpFbGMrY1Jub0FseGRUdm9EdUs3cHVxRjd1Q1F5KzNmeUZNaUEwMi92SlFIaDdEUURvZ01QVFNHRk5BNTZIVHpiWjl5QWZCT2IxWnlvM3FHTTNNZk1aM2Y3Nmh1WGY2eGxtQUhrbk1sTE5Yc0JCQnZibGpJejlVeXo1WTVUeklCTFIvcXkvck55clo4K0wvMEJaMG0rdGdYRDBPSzVYWnhDLzlQN0kvZzRoVkZ2elhmMS82aTVBNyszQWxpak1QQkxNWmZDdnVBcDdBOXJZNTZBcEhpdG1MUWM3YzhiT3Y2ZnRBeGxNOVhwMzVua0VLN25KZXRCc2FNaHRBQUF1T0xRR1h3aGgyZFhRbm4xclovYTQyQkkzZEw3TCtqa0ZBYlFkZHdkQTlBaDM1eU1LaGdFZ1ZUNDZFRmg1RDRqeitPZ2F2Tkt4ZUJDZDF3RFNKLzk3b1I4ZW9Ka0xpOXQ5L0JEZ0RIVEo1TkU3RG56ZWNoaDkxNE9WdjlNMUs5UENxc2ZxYjg4WFZnOXFOOWxtNm5HMTc2VVB1K3puMTdHT3h1TzB2T1dFRUMvaitMRktUZ2dobHZFZllKYUxTK1NBMk8wQUFBQUFTVVZPUks1Q1lJST1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2RlYnVnLXRleHQudHNcblxyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGRlYnVndGV4dCBoZWxwZXJcclxuICovXHJcbmNsYXNzIERlYnVnVGV4dCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBiYXNlNjQgZm9udFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZm9udFNoZWV0ID0gZGVidWdfZm9udDtcclxuICAgICAgICB0aGlzLnNpemUgPSAxNjtcclxuICAgICAgICB0aGlzLmxvYWQoKTtcclxuICAgIH1cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgdGhpcy5faW1hZ2VTb3VyY2UgPSBuZXcgSW1hZ2VTb3VyY2UodGhpcy5mb250U2hlZXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbWFnZVNvdXJjZS5sb2FkKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXQuZnJvbUltYWdlU291cmNlKHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiB0aGlzLl9pbWFnZVNvdXJjZSxcclxuICAgICAgICAgICAgICAgIGdyaWQ6IHtcclxuICAgICAgICAgICAgICAgICAgICByb3dzOiAzLFxyXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbnM6IDE2LFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZVdpZHRoOiAxNixcclxuICAgICAgICAgICAgICAgICAgICBzcHJpdGVIZWlnaHQ6IDE2XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVGb250ID0gbmV3IFNwcml0ZUZvbnRfU3ByaXRlRm9udCh7XHJcbiAgICAgICAgICAgICAgICBhbHBoYWJldDogJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiwhXFwnJi5cIj8tKCkrICcsXHJcbiAgICAgICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzcHJpdGVTaGVldDogdGhpcy5fc3ByaXRlU2hlZXQsXHJcbiAgICAgICAgICAgICAgICBzcGFjaW5nOiAtNlxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGRlYnVnIHRleHQgdXNpbmcgdGhlIGJ1aWx0IGluIHNwcmludCBmb250XHJcbiAgICAgKiBAcGFyYW0gY3R4XHJcbiAgICAgKiBAcGFyYW0gdGV4dFxyXG4gICAgICogQHBhcmFtIHBvc1xyXG4gICAgICovXHJcbiAgICB3cml0ZShjdHgsIHRleHQsIHBvcykge1xyXG4gICAgICAgIGlmICh0aGlzLl9pbWFnZVNvdXJjZS5pc0xvYWRlZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUZvbnQucmVuZGVyKGN0eCwgdGV4dCwgcG9zLngsIHBvcy55KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dFdlYkdMLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHRXZWJHTERlYnVnIHtcclxuICAgIGNvbnN0cnVjdG9yKF93ZWJnbEN0eCkge1xyXG4gICAgICAgIHRoaXMuX3dlYmdsQ3R4ID0gX3dlYmdsQ3R4O1xyXG4gICAgICAgIHRoaXMuX2RlYnVnVGV4dCA9IG5ldyBEZWJ1Z1RleHQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGRlYnVnZ2luZyByZWN0YW5nbGUgdG8gdGhlIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICogQHBhcmFtIHdpZHRoXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIGRyYXdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHJlY3RPcHRpb25zID0geyBjb2xvcjogQ29sb3IuQmxhY2sgfSkge1xyXG4gICAgICAgIHRoaXMuZHJhd0xpbmUodmVjKHgsIHkpLCB2ZWMoeCArIHdpZHRoLCB5KSwgT2JqZWN0LmFzc2lnbih7fSwgcmVjdE9wdGlvbnMpKTtcclxuICAgICAgICB0aGlzLmRyYXdMaW5lKHZlYyh4ICsgd2lkdGgsIHkpLCB2ZWMoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KSwgT2JqZWN0LmFzc2lnbih7fSwgcmVjdE9wdGlvbnMpKTtcclxuICAgICAgICB0aGlzLmRyYXdMaW5lKHZlYyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpLCB2ZWMoeCwgeSArIGhlaWdodCksIE9iamVjdC5hc3NpZ24oe30sIHJlY3RPcHRpb25zKSk7XHJcbiAgICAgICAgdGhpcy5kcmF3TGluZSh2ZWMoeCwgeSArIGhlaWdodCksIHZlYyh4LCB5KSwgT2JqZWN0LmFzc2lnbih7fSwgcmVjdE9wdGlvbnMpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGRlYnVnZ2luZyBsaW5lIHRvIHRoZSBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gc3RhcnRcclxuICAgICAqIEBwYXJhbSBlbmRcclxuICAgICAqIEBwYXJhbSBsaW5lT3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBkcmF3TGluZShzdGFydCwgZW5kLCBsaW5lT3B0aW9ucyA9IHsgY29sb3I6IENvbG9yLkJsYWNrIH0pIHtcclxuICAgICAgICB0aGlzLl93ZWJnbEN0eC5fX2xpbmVSZW5kZXJlci5hZGRMaW5lKHN0YXJ0LCBlbmQsIGxpbmVPcHRpb25zLmNvbG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGRlYnVnZ2luZyBwb2ludCB0byB0aGUgY29udGV4dFxyXG4gICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnRPcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGRyYXdQb2ludChwb2ludCwgcG9pbnRPcHRpb25zID0geyBjb2xvcjogQ29sb3IuQmxhY2ssIHNpemU6IDUgfSkge1xyXG4gICAgICAgIHRoaXMuX3dlYmdsQ3R4Ll9fcG9pbnRSZW5kZXJlci5hZGRQb2ludChwb2ludCwgcG9pbnRPcHRpb25zLmNvbG9yLCBwb2ludE9wdGlvbnMuc2l6ZSk7XHJcbiAgICB9XHJcbiAgICBkcmF3VGV4dCh0ZXh0LCBwb3MpIHtcclxuICAgICAgICB0aGlzLl9kZWJ1Z1RleHQud3JpdGUodGhpcy5fd2ViZ2xDdHgsIHRleHQsIHBvcyk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0wge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1TdGFjaygpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gbmV3IFN0YXRlU3RhY2soKTtcclxuICAgICAgICB0aGlzLnNuYXBUb1BpeGVsID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnNtb290aGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuRXhjYWxpYnVyQmx1ZTtcclxuICAgICAgICB0aGlzLmRlYnVnID0gbmV3IEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dFdlYkdMRGVidWcodGhpcyk7XHJcbiAgICAgICAgY29uc3QgeyBjYW52YXNFbGVtZW50LCBlbmFibGVUcmFuc3BhcmVuY3ksIHNtb290aGluZywgc25hcFRvUGl4ZWwsIGJhY2tncm91bmRDb2xvciB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLl9fZ2wgPSBjYW52YXNFbGVtZW50LmdldENvbnRleHQoJ3dlYmdsJywge1xyXG4gICAgICAgICAgICBhbnRpYWxpYXM6IHNtb290aGluZyAhPT0gbnVsbCAmJiBzbW9vdGhpbmcgIT09IHZvaWQgMCA/IHNtb290aGluZyA6IHRoaXMuc21vb3RoaW5nLFxyXG4gICAgICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxyXG4gICAgICAgICAgICBhbHBoYTogZW5hYmxlVHJhbnNwYXJlbmN5ICE9PSBudWxsICYmIGVuYWJsZVRyYW5zcGFyZW5jeSAhPT0gdm9pZCAwID8gZW5hYmxlVHJhbnNwYXJlbmN5IDogdHJ1ZSxcclxuICAgICAgICAgICAgZGVwdGg6IHRydWUsXHJcbiAgICAgICAgICAgIHBvd2VyUHJlZmVyZW5jZTogJ2hpZ2gtcGVyZm9ybWFuY2UnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zbmFwVG9QaXhlbCA9IHNuYXBUb1BpeGVsICE9PSBudWxsICYmIHNuYXBUb1BpeGVsICE9PSB2b2lkIDAgPyBzbmFwVG9QaXhlbCA6IHRoaXMuc25hcFRvUGl4ZWw7XHJcbiAgICAgICAgdGhpcy5zbW9vdGhpbmcgPSBzbW9vdGhpbmcgIT09IG51bGwgJiYgc21vb3RoaW5nICE9PSB2b2lkIDAgPyBzbW9vdGhpbmcgOiB0aGlzLnNtb290aGluZztcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvciAhPT0gbnVsbCAmJiBiYWNrZ3JvdW5kQ29sb3IgIT09IHZvaWQgMCA/IGJhY2tncm91bmRDb2xvciA6IHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIHRoaXMuX2luaXQoKTtcclxuICAgIH1cclxuICAgIGdldCBvcGFjaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5jdXJyZW50Lm9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICBzZXQgb3BhY2l0eSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlLmN1cnJlbnQub3BhY2l0eSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fZ2wuY2FudmFzLndpZHRoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2dsLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB0aGUgdW5kZXJseWluZyB3ZWJnbCBpbXBsZW1lbnRhdGlvbiBpZiB0aGUgcmVxdWVzdGVkIGludGVybmFsIHJlc29sdXRpb24gaXMgc3VwcG9ydGVkXHJcbiAgICAgKiBAcGFyYW0gZGltXHJcbiAgICAgKi9cclxuICAgIGNoZWNrSWZSZXNvbHV0aW9uU3VwcG9ydGVkKGRpbSkge1xyXG4gICAgICAgIC8vIFNsaWdodCBoYWNrIGJhc2VkIG9uIHRoaXMgdGhyZWFkIGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZy93ZWJnbC1kZXYtbGlzdC9jL0FIT052ejNvUVRvXHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9fZ2w7XHJcbiAgICAgICAgLy8gSWYgYW55IGRpbWVuc2lvbiBpcyBncmVhdGVyIHRoYW4gbWF4IHRleHR1cmUgc2l6ZSAoZGl2aWRlIGJ5IDQgYnl0ZXMgcGVyIHBpeGVsKVxyXG4gICAgICAgIGNvbnN0IG1heERpbSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKSAvIDQ7XHJcbiAgICAgICAgbGV0IHN1cHBvcnRlZCA9IHRydWU7XHJcbiAgICAgICAgaWYgKGRpbS53aWR0aCA+IG1heERpbSB8fCBkaW0uaGVpZ2h0ID4gbWF4RGltKSB7XHJcbiAgICAgICAgICAgIHN1cHBvcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc3VwcG9ydGVkO1xyXG4gICAgfVxyXG4gICAgX2luaXQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9fZ2w7XHJcbiAgICAgICAgLy8gU2V0dXAgdmlld3BvcnQgYW5kIHZpZXcgbWF0cml4XHJcbiAgICAgICAgdGhpcy5fb3J0aG8gPSBNYXRyaXgub3J0aG8oMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0LCAwLCA0MDAsIC00MDApO1xyXG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgLy8gQ2xlYXIgYmFja2dyb3VuZFxyXG4gICAgICAgIGdsLmNsZWFyQ29sb3IodGhpcy5iYWNrZ3JvdW5kQ29sb3IuciAvIDI1NSwgdGhpcy5iYWNrZ3JvdW5kQ29sb3IuZyAvIDI1NSwgdGhpcy5iYWNrZ3JvdW5kQ29sb3IuYiAvIDI1NSwgdGhpcy5iYWNrZ3JvdW5kQ29sb3IuYSk7XHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgLy8gRW5hYmxlIGFscGhhIGJsZW5kaW5nXHJcbiAgICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcclxuICAgICAgICBnbC5ibGVuZEZ1bmMoZ2wuU1JDX0FMUEhBLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcclxuICAgICAgICB0aGlzLl9fcG9pbnRSZW5kZXJlciA9IG5ldyBQb2ludFJlbmRlcmVyKGdsLCB7IG1hdHJpeDogdGhpcy5fb3J0aG8sIHRyYW5zZm9ybTogdGhpcy5fdHJhbnNmb3JtLCBzdGF0ZTogdGhpcy5fc3RhdGUgfSk7XHJcbiAgICAgICAgdGhpcy5fX2xpbmVSZW5kZXJlciA9IG5ldyBMaW5lUmVuZGVyZXIoZ2wsIHsgbWF0cml4OiB0aGlzLl9vcnRobywgdHJhbnNmb3JtOiB0aGlzLl90cmFuc2Zvcm0sIHN0YXRlOiB0aGlzLl9zdGF0ZSB9KTtcclxuICAgICAgICB0aGlzLl9faW1hZ2VSZW5kZXJlciA9IG5ldyBJbWFnZVJlbmRlcmVyKGdsLCB7IG1hdHJpeDogdGhpcy5fb3J0aG8sIHRyYW5zZm9ybTogdGhpcy5fdHJhbnNmb3JtLCBzdGF0ZTogdGhpcy5fc3RhdGUgfSk7XHJcbiAgICAgICAgLy8gMkQgY3R4IHNoaW1cclxuICAgICAgICB0aGlzLl9jYW52YXMgPSBuZXcgQ2FudmFzKHtcclxuICAgICAgICAgICAgd2lkdGg6IGdsLmNhbnZhcy53aWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBnbC5jYW52YXMuaGVpZ2h0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX2N0eCA9IHRoaXMuX2NhbnZhcy5jdHg7XHJcbiAgICB9XHJcbiAgICByZXNldFRyYW5zZm9ybSgpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0uY3VycmVudCA9IE1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlVmlld3BvcnQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9fZ2w7XHJcbiAgICAgICAgdGhpcy5fb3J0aG8gPSB0aGlzLl9vcnRobyA9IE1hdHJpeC5vcnRobygwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQsIDAsIDQwMCwgLTQwMCk7XHJcbiAgICAgICAgdGhpcy5fX3BvaW50UmVuZGVyZXIuc2hhZGVyLmFkZFVuaWZvcm1NYXRyaXgoJ3VfbWF0cml4JywgdGhpcy5fb3J0aG8uZGF0YSk7XHJcbiAgICAgICAgdGhpcy5fX2xpbmVSZW5kZXJlci5zaGFkZXIuYWRkVW5pZm9ybU1hdHJpeCgndV9tYXRyaXgnLCB0aGlzLl9vcnRoby5kYXRhKTtcclxuICAgICAgICB0aGlzLl9faW1hZ2VSZW5kZXJlci5zaGFkZXIuYWRkVW5pZm9ybU1hdHJpeCgndV9tYXRyaXgnLCB0aGlzLl9vcnRoby5kYXRhKTtcclxuICAgICAgICAvLyAyRCBjdHggc2hpbVxyXG4gICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IGdsLmNhbnZhcy53aWR0aDtcclxuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gZ2wuY2FudmFzLmhlaWdodDtcclxuICAgIH1cclxuICAgIGRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQsIGR4LCBkeSwgZHdpZHRoLCBkaGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHN3aWR0aCA9PT0gMCB8fCBzaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gemVybyBkaW1lbnNpb24gZGVzdCBleGl0IGVhcmx5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGR3aWR0aCA9PT0gMCB8fCBkaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gemVybyBkaW1lbnNpb24gZGVzdCBleGl0IGVhcmx5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGltYWdlLndpZHRoID09PSAwIHx8IGltYWdlLmhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIHplcm8gZGltZW5zaW9uIHNvdXJjZSBleGl0IGVhcmx5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaW1hZ2UpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignQ2Fubm90IGRyYXcgYSBudWxsIG9yIHVuZGVmaW5lZCBpbWFnZScpO1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tY29uc29sZVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fX2ltYWdlUmVuZGVyZXIuYWRkSW1hZ2UoaW1hZ2UsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0LCBkeCwgZHksIGR3aWR0aCwgZGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBkcmF3TGluZShzdGFydCwgZW5kLCBjb2xvciwgdGhpY2tuZXNzID0gMSkge1xyXG4gICAgICAgIHRoaXMuX19pbWFnZVJlbmRlcmVyLmFkZExpbmUoY29sb3IsIHN0YXJ0LCBlbmQsIHRoaWNrbmVzcyk7XHJcbiAgICB9XHJcbiAgICBkcmF3UmVjdGFuZ2xlKHBvcywgd2lkdGgsIGhlaWdodCwgY29sb3IpIHtcclxuICAgICAgICB0aGlzLl9faW1hZ2VSZW5kZXJlci5hZGRSZWN0YW5nbGUoY29sb3IsIHBvcywgd2lkdGgsIGhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBkcmF3Q2lyY2xlKHBvcywgcmFkaXVzLCBjb2xvcikge1xyXG4gICAgICAgIHRoaXMuX19pbWFnZVJlbmRlcmVyLmFkZENpcmNsZShwb3MsIHJhZGl1cywgY29sb3IpO1xyXG4gICAgfVxyXG4gICAgc2F2ZSgpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0uc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlLnNhdmUoKTtcclxuICAgIH1cclxuICAgIHJlc3RvcmUoKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnJlc3RvcmUoKTtcclxuICAgICAgICB0aGlzLl9zdGF0ZS5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgICB0cmFuc2xhdGUoeCwgeSkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS50cmFuc2xhdGUodGhpcy5zbmFwVG9QaXhlbCA/IH5+eCA6IHgsIHRoaXMuc25hcFRvUGl4ZWwgPyB+fnkgOiB5KTtcclxuICAgIH1cclxuICAgIHJvdGF0ZShhbmdsZSkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5yb3RhdGUoYW5nbGUpO1xyXG4gICAgfVxyXG4gICAgc2NhbGUoeCwgeSkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5zY2FsZSh4LCB5KTtcclxuICAgIH1cclxuICAgIHRyYW5zZm9ybShtYXRyaXgpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0uY3VycmVudCA9IG1hdHJpeDtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fX2dsO1xyXG4gICAgICAgIGdsLmNsZWFyQ29sb3IodGhpcy5iYWNrZ3JvdW5kQ29sb3IuciAvIDI1NSwgdGhpcy5iYWNrZ3JvdW5kQ29sb3IuZyAvIDI1NSwgdGhpcy5iYWNrZ3JvdW5kQ29sb3IuYiAvIDI1NSwgdGhpcy5iYWNrZ3JvdW5kQ29sb3IuYSk7XHJcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGNvbnRleHQgd2l0aCB0aGUgbmV3bHkgc2V0IGNvbG9yLiBUaGlzIGlzXHJcbiAgICAgICAgLy8gdGhlIGZ1bmN0aW9uIGNhbGwgdGhhdCBhY3R1YWxseSBkb2VzIHRoZSBkcmF3aW5nLlxyXG4gICAgICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpO1xyXG4gICAgICAgIEdyYXBoaWNzRGlhZ25vc3RpY3MuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmx1c2hlcyBhbGwgYmF0Y2hlZCByZW5kZXJpbmcgdG8gdGhlIHNjcmVlblxyXG4gICAgICovXHJcbiAgICBmbHVzaCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX19nbDtcclxuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX19pbWFnZVJlbmRlcmVyLnJlbmRlcigpO1xyXG4gICAgICAgIHRoaXMuX19saW5lUmVuZGVyZXIucmVuZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fX3BvaW50UmVuZGVyZXIucmVuZGVyKCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9TY3JlZW4udHNcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgZGlzcGxheSBtb2RlcyBhdmFpbGFibGUgdG8gRXhjYWxpYnVyLlxyXG4gKi9cclxudmFyIERpc3BsYXlNb2RlO1xyXG4oZnVuY3Rpb24gKERpc3BsYXlNb2RlKSB7XHJcbiAgICAvKipcclxuICAgICAqIERlZmF1bHQsIHVzZSBhIHNwZWNpZmllZCByZXNvbHV0aW9uIGZvciB0aGUgZ2FtZS4gTGlrZSA4MDB4NjAwIHBpeGVscyBmb3IgZXhhbXBsZS5cclxuICAgICAqL1xyXG4gICAgRGlzcGxheU1vZGVbXCJGaXhlZFwiXSA9IFwiRml4ZWRcIjtcclxuICAgIC8qKlxyXG4gICAgICogRml0IHRvIHNjcmVlbiB1c2luZyBhcyBtdWNoIHNwYWNlIGFzIHBvc3NpYmxlIHdoaWxlIG1haW50YWluaW5nIGFzcGVjdCByYXRpbyBhbmQgcmVzb2x1dGlvbi5cclxuICAgICAqIFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIFtbU2NyZWVuLmdvRnVsbFNjcmVlbl1dIGJ1dCBiZWhhdmVzIGluIGEgc2ltaWxhciB3YXkgbWFpbnRhaW5pbmcgYXNwZWN0IHJhdGlvLlxyXG4gICAgICpcclxuICAgICAqIFlvdSBtYXkgd2FudCB0byBjZW50ZXIgeW91ciBnYW1lIGhlcmUgaXMgYW4gZXhhbXBsZVxyXG4gICAgICogYGBgaHRtbFxyXG4gICAgICogPCEtLSBodG1sIC0tPlxyXG4gICAgICogPGJvZHk+XHJcbiAgICAgKiA8bWFpbj5cclxuICAgICAqICAgPGNhbnZhcyBpZD1cImdhbWVcIj48L2NhbnZhcz5cclxuICAgICAqIDwvbWFpbj5cclxuICAgICAqIDwvYm9keT5cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIGBgYGNzc1xyXG4gICAgICogLy8gY3NzXHJcbiAgICAgKiBtYWluIHtcclxuICAgICAqICAgZGlzcGxheTogZmxleDtcclxuICAgICAqICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcclxuICAgICAqICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XHJcbiAgICAgKiAgIGhlaWdodDogMTAwJTtcclxuICAgICAqICAgd2lkdGg6IDEwMCU7XHJcbiAgICAgKiB9XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIERpc3BsYXlNb2RlW1wiRml0U2NyZWVuXCJdID0gXCJGaXRTY3JlZW5cIjtcclxuICAgIC8qKlxyXG4gICAgICogRmlsbCB0aGUgZW50aXJlIHNjcmVlbidzIGNzcyB3aWR0aC9oZWlnaHQgZm9yIHRoZSBnYW1lIHJlc29sdXRpb24gZHluYW1pY2FsbHkuIFRoaXMgbWVhbnMgdGhlIHJlc29sdXRpb24gb2YgdGhlIGdhbWUgd2lsbFxyXG4gICAgICogY2hhbmdlIGR5bmFtaWNhbGx5IGFzIHRoZSB3aW5kb3cgaXMgcmVzaXplZC4gVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgW1tTY3JlZW4uZ29GdWxsU2NyZWVuXV1cclxuICAgICAqL1xyXG4gICAgRGlzcGxheU1vZGVbXCJGaWxsU2NyZWVuXCJdID0gXCJGaWxsU2NyZWVuXCI7XHJcbiAgICAvKipcclxuICAgICAqIEZpdCB0byBwYXJlbnQgZWxlbWVudCB3aWR0aC9oZWlnaHQgdXNpbmcgYXMgbXVjaCBzcGFjZSBhcyBwb3NzaWJsZSB3aGlsZSBtYWludGFpbmluZyBhc3BlY3QgcmF0aW8gYW5kIHJlc29sdXRpb24uXHJcbiAgICAgKi9cclxuICAgIERpc3BsYXlNb2RlW1wiRml0Q29udGFpbmVyXCJdID0gXCJGaXRDb250YWluZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogVXNlIHRoZSBwYXJlbnQgRE9NIGNvbnRhaW5lcidzIGNzcyB3aWR0aC9oZWlnaHQgZm9yIHRoZSBnYW1lIHJlc29sdXRpb24gZHluYW1pY2FsbHlcclxuICAgICAqL1xyXG4gICAgRGlzcGxheU1vZGVbXCJGaWxsQ29udGFpbmVyXCJdID0gXCJGaWxsQ29udGFpbmVyXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFsbG93IHRoZSBnYW1lIHRvIGJlIHBvc2l0aW9uZWQgd2l0aCB0aGUgW1tFbmdpbmVPcHRpb25zLnBvc2l0aW9uXV0gb3B0aW9uXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgQ1NTIHRvIHBvc2l0aW9uIHRoZSBnYW1lIGNhbnZhcywgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICAgICAqL1xyXG4gICAgRGlzcGxheU1vZGVbXCJQb3NpdGlvblwiXSA9IFwiUG9zaXRpb25cIjtcclxufSkoRGlzcGxheU1vZGUgfHwgKERpc3BsYXlNb2RlID0ge30pKTtcclxuLyoqXHJcbiAqIENvbnZlbmllbmNlIGNsYXNzIGZvciBxdWljayByZXNvbHV0aW9uc1xyXG4gKiBNb3N0bHkgc291cmNlZCBmcm9tIGh0dHBzOi8vZW11bGF0aW9uLmdhbWV0ZWNod2lraS5jb20vaW5kZXgucGhwL1Jlc29sdXRpb25cclxuICovXHJcbmNsYXNzIFJlc29sdXRpb24ge1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHN0YXRpYyBnZXQgU1ZHQSgpIHtcclxuICAgICAgICByZXR1cm4geyB3aWR0aDogODAwLCBoZWlnaHQ6IDYwMCB9O1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHN0YXRpYyBnZXQgU3RhbmRhcmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IDE5MjAsIGhlaWdodDogMTA4MCB9O1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHN0YXRpYyBnZXQgQXRhcmkyNjAwKCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiAxNjAsIGhlaWdodDogMTkyIH07XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgc3RhdGljIGdldCBHYW1lQm95KCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiAxNjAsIGhlaWdodDogMTQ0IH07XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgc3RhdGljIGdldCBHYW1lQm95QWR2YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4geyB3aWR0aDogMjQwLCBoZWlnaHQ6IDE2MCB9O1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHN0YXRpYyBnZXQgTmludGVuZG9EUygpIHtcclxuICAgICAgICByZXR1cm4geyB3aWR0aDogMjU2LCBoZWlnaHQ6IDE5MiB9O1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHN0YXRpYyBnZXQgTkVTKCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiAyNTYsIGhlaWdodDogMjI0IH07XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgc3RhdGljIGdldCBTTkVTKCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiAyNTYsIGhlaWdodDogMjQ0IH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBTY3JlZW4gaGFuZGxlcyBhbGwgYXNwZWN0cyBvZiBpbnRlcmFjdGluZyB3aXRoIHRoZSBzY3JlZW4gZm9yIEV4Y2FsaWJ1ci5cclxuICovXHJcbmNsYXNzIFNjcmVlbiB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgdGhpcy5fYW50aWFsaWFzaW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9yZXNvbHV0aW9uU3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLl92aWV3cG9ydFN0YWNrID0gW107XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxSYXRpb092ZXJyaWRlID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9pc0Z1bGxTY3JlZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5fZnVsbHNjcmVlbkNoYW5nZUhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzRnVsbFNjcmVlbiA9ICF0aGlzLl9pc0Z1bGxTY3JlZW47XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnRnVsbHNjcmVlbiBDaGFuZ2UnLCB0aGlzLl9pc0Z1bGxTY3JlZW4pO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxSYXRpb0NoYW5nZUhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnUGl4ZWwgUmF0aW8gQ2hhbmdlJywgd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xyXG4gICAgICAgICAgICB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvID0gdGhpcy5fY2FsY3VsYXRlRGV2aWNlUGl4ZWxSYXRpbygpO1xyXG4gICAgICAgICAgICB0aGlzLmFwcGx5UmVzb2x1dGlvbkFuZFZpZXdwb3J0KCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9yZXNpemVIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdWaWV3IHBvcnQgcmVzaXplZCcpO1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRSZXNvbHV0aW9uQW5kVmlld3BvcnRCeURpc3BsYXlNb2RlKHBhcmVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlSZXNvbHV0aW9uQW5kVmlld3BvcnQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIEFza2luZyB0aGUgd2luZG93LmRldmljZVBpeGVsUmF0aW8gaXMgZXhwZW5zaXZlIHdlIGRvIGl0IG9uY2VcclxuICAgICAgICB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvID0gdGhpcy5fY2FsY3VsYXRlRGV2aWNlUGl4ZWxSYXRpbygpO1xyXG4gICAgICAgIHRoaXMuX2FscmVhZHlXYXJuZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gb3B0aW9ucy52aWV3cG9ydDtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSAoX2EgPSBvcHRpb25zLnJlc29sdXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudmlld3BvcnQpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3BsYXlNb2RlID0gKF9iID0gb3B0aW9ucy5kaXNwbGF5TW9kZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogRGlzcGxheU1vZGUuRml4ZWQ7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzID0gb3B0aW9ucy5jYW52YXM7XHJcbiAgICAgICAgdGhpcy5fY3R4ID0gb3B0aW9ucy5jb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX2FudGlhbGlhc2luZyA9IChfYyA9IG9wdGlvbnMuYW50aWFsaWFzaW5nKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLl9hbnRpYWxpYXNpbmc7XHJcbiAgICAgICAgdGhpcy5fYnJvd3NlciA9IG9wdGlvbnMuYnJvd3NlcjtcclxuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxSYXRpb092ZXJyaWRlID0gb3B0aW9ucy5waXhlbFJhdGlvO1xyXG4gICAgICAgIHRoaXMuX2FwcGx5RGlzcGxheU1vZGUoKTtcclxuICAgICAgICB0aGlzLl9tZWRpYVF1ZXJ5TGlzdCA9IHRoaXMuX2Jyb3dzZXIud2luZG93Lm5hdGl2ZUNvbXBvbmVudC5tYXRjaE1lZGlhKGAocmVzb2x1dGlvbjogJHt3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb31kcHB4KWApO1xyXG4gICAgICAgIHRoaXMuX21lZGlhUXVlcnlMaXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX3BpeGVsUmF0aW9DaGFuZ2VIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIHRoaXMuX2Z1bGxzY3JlZW5DaGFuZ2VIYW5kbGVyKTtcclxuICAgICAgICB0aGlzLmFwcGx5UmVzb2x1dGlvbkFuZFZpZXdwb3J0KCk7XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faXNEaXNwb3NlZCkge1xyXG4gICAgICAgICAgICAvLyBDbGVhbiB1cCBoYW5kbGVyc1xyXG4gICAgICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fYnJvd3Nlci53aW5kb3cub2ZmKCdyZXNpemUnLCB0aGlzLl9yZXNpemVIYW5kbGVyKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZU9ic2VydmVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fcmVzaXplSGFuZGxlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX21lZGlhUXVlcnlMaXN0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuX3BpeGVsUmF0aW9DaGFuZ2VIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Z1bGxzY3JlZW5jaGFuZ2UnLCB0aGlzLl9mdWxsc2NyZWVuQ2hhbmdlSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NhbGN1bGF0ZURldmljZVBpeGVsUmF0aW8oKSB7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIDwgMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XHJcbiAgICAgICAgcmV0dXJuIGRldmljZVBpeGVsUmF0aW87XHJcbiAgICB9XHJcbiAgICBnZXQgcGl4ZWxSYXRpbygpIHtcclxuICAgICAgICBpZiAodGhpcy5fcGl4ZWxSYXRpb092ZXJyaWRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9waXhlbFJhdGlvT3ZlcnJpZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9kZXZpY2VQaXhlbFJhdGlvO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzSGlEcGkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGl4ZWxSYXRpbyAhPT0gMTtcclxuICAgIH1cclxuICAgIGdldCBkaXNwbGF5TW9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGlzcGxheU1vZGU7XHJcbiAgICB9XHJcbiAgICBnZXQgY2FudmFzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFyZW50KCkge1xyXG4gICAgICAgIHJldHVybiAoKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkZpbGxDb250YWluZXIgfHwgdGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuRml0Q29udGFpbmVyXHJcbiAgICAgICAgICAgID8gdGhpcy5jYW52YXMucGFyZW50RWxlbWVudCB8fCBkb2N1bWVudC5ib2R5XHJcbiAgICAgICAgICAgIDogd2luZG93KSk7XHJcbiAgICB9XHJcbiAgICBnZXQgcmVzb2x1dGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIHNldCByZXNvbHV0aW9uKHJlc29sdXRpb24pIHtcclxuICAgICAgICB0aGlzLl9yZXNvbHV0aW9uID0gcmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIGdldCB2aWV3cG9ydCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdmlld3BvcnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbjtcclxuICAgIH1cclxuICAgIHNldCB2aWV3cG9ydCh2aWV3cG9ydCkge1xyXG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gdmlld3BvcnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgYXNwZWN0UmF0aW8oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdXRpb24ud2lkdGggLyB0aGlzLl9yZXNvbHV0aW9uLmhlaWdodDtcclxuICAgIH1cclxuICAgIGdldCBzY2FsZWRXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbi53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbztcclxuICAgIH1cclxuICAgIGdldCBzY2FsZWRIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdXRpb24uaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgfVxyXG4gICAgc2V0Q3VycmVudENhbWVyYShjYW1lcmEpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBjYW1lcmE7XHJcbiAgICB9XHJcbiAgICBwdXNoUmVzb2x1dGlvbkFuZFZpZXdwb3J0KCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25TdGFjay5wdXNoKHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgdGhpcy5fdmlld3BvcnRTdGFjay5wdXNoKHRoaXMudmlld3BvcnQpO1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMucmVzb2x1dGlvbik7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMudmlld3BvcnQpO1xyXG4gICAgfVxyXG4gICAgcGVla1ZpZXdwb3J0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydFN0YWNrW3RoaXMuX3ZpZXdwb3J0U3RhY2subGVuZ3RoIC0gMV07XHJcbiAgICB9XHJcbiAgICBwZWVrUmVzb2x1dGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvblN0YWNrW3RoaXMuX3Jlc29sdXRpb25TdGFjay5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIHBvcFJlc29sdXRpb25BbmRWaWV3cG9ydCgpIHtcclxuICAgICAgICB0aGlzLnJlc29sdXRpb24gPSB0aGlzLl9yZXNvbHV0aW9uU3RhY2sucG9wKCk7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMuX3ZpZXdwb3J0U3RhY2sucG9wKCk7XHJcbiAgICB9XHJcbiAgICBhcHBseVJlc29sdXRpb25BbmRWaWV3cG9ydCgpIHtcclxuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSB0aGlzLnNjYWxlZFdpZHRoO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSB0aGlzLnNjYWxlZEhlaWdodDtcclxuICAgICAgICBpZiAodGhpcy5fY3R4IGluc3RhbmNlb2YgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0wpIHtcclxuICAgICAgICAgICAgY29uc3Qgc3VwcG9ydGVkID0gdGhpcy5fY3R4LmNoZWNrSWZSZXNvbHV0aW9uU3VwcG9ydGVkKHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLnNjYWxlZFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB0aGlzLnNjYWxlZEhlaWdodFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKCFzdXBwb3J0ZWQgJiYgIXRoaXMuX2FscmVhZHlXYXJuZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FscmVhZHlXYXJuZWQgPSB0cnVlOyAvLyB3YXJuIG9uY2VcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKGBUaGUgY3VycmVudGx5IGNvbmZpZ3VyZWQgcmVzb2x1dGlvbiAoJHt0aGlzLnJlc29sdXRpb24ud2lkdGh9eCR7dGhpcy5yZXNvbHV0aW9uLmhlaWdodH0pYCArXHJcbiAgICAgICAgICAgICAgICAgICAgJyBpcyB0b28gbGFyZ2UgZm9yIHRoZSBwbGF0Zm9ybSBXZWJHTCBpbXBsZW1lbnRhdGlvbiwgdGhpcyBtYXkgd29yayBidXQgY2F1c2UgV2ViR0wgcmVuZGVyaW5nIHRvIGJlaGF2ZSBvZGRseS4nICtcclxuICAgICAgICAgICAgICAgICAgICAnIFRyeSByZWR1Y2luZyB0aGUgcmVzb2x1dGlvbiBvciBkaXNhYmxpbmcgSGkgRFBJIHNjYWxpbmcgdG8gYXZvaWQgdGhpcycgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgKHJlYWQgbW9yZSBoZXJlIGh0dHBzOi8vZXhjYWxpYnVyanMuY29tL2RvY3Mvc2NyZWVucyN1bmRlcnN0YW5kaW5nLXZpZXdwb3J0LS1yZXNvbHV0aW9uKS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fYW50aWFsaWFzaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5pbWFnZVJlbmRlcmluZyA9ICdhdXRvJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5pbWFnZVJlbmRlcmluZyA9ICdwaXhlbGF0ZWQnO1xyXG4gICAgICAgICAgICAvLyBGYWxsIGJhY2sgdG8gJ2NyaXNwLWVkZ2VzJyBpZiAncGl4ZWxhdGVkJyBpcyBub3Qgc3VwcG9ydGVkXHJcbiAgICAgICAgICAgIC8vIEN1cnJlbnRseSBmb3IgZmlyZWZveCBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvaW1hZ2UtcmVuZGVyaW5nXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW52YXMuc3R5bGUuaW1hZ2VSZW5kZXJpbmcgPT09ICcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuaW1hZ2VSZW5kZXJpbmcgPSAnY3Jpc3AtZWRnZXMnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS53aWR0aCA9IHRoaXMudmlld3BvcnQud2lkdGggKyAncHgnO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5oZWlnaHQgPSB0aGlzLnZpZXdwb3J0LmhlaWdodCArICdweCc7XHJcbiAgICAgICAgLy8gQWZ0ZXIgbWVzc2luZyB3aXRoIHRoZSBjYW52YXMgd2lkdGgvaGVpZ2h0IHRoZSBncmFwaGljcyBjb250ZXh0IGlzIGludmFsaWRhdGVkIGFuZCBuZWVkcyB0byBoYXZlIHNvbWUgcHJvcGVydGllcyByZXNldFxyXG4gICAgICAgIHRoaXMuX2N0eC51cGRhdGVWaWV3cG9ydCgpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5yZXNldFRyYW5zZm9ybSgpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5zY2FsZSh0aGlzLnBpeGVsUmF0aW8sIHRoaXMucGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnNtb290aGluZyA9IHRoaXMuX2FudGlhbGlhc2luZztcclxuICAgIH1cclxuICAgIGdldCBhbnRpYWxpYXNpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FudGlhbGlhc2luZztcclxuICAgIH1cclxuICAgIHNldCBhbnRpYWxpYXNpbmcoaXNTbW9vdGgpIHtcclxuICAgICAgICB0aGlzLl9hbnRpYWxpYXNpbmcgPSBpc1Ntb290aDtcclxuICAgICAgICB0aGlzLl9jdHguc21vb3RoaW5nID0gdGhpcy5fYW50aWFsaWFzaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgZXhjYWxpYnVyIGlzIGZ1bGxzY3JlZW5lZCB1c2luZyB0aGUgYnJvd3NlciBmdWxsc2NyZWVuIGFwaVxyXG4gICAgICovXHJcbiAgICBnZXQgaXNGdWxsU2NyZWVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Z1bGxTY3JlZW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3RzIHRvIGdvIGZ1bGxzY3JlZW4gdXNpbmcgdGhlIGJyb3dzZXIgZnVsbHNjcmVlbiBhcGksIHJlcXVpcmVzIHVzZXIgaW50ZXJhY3Rpb24gdG8gYmUgc3VjY2Vzc2Z1bC5cclxuICAgICAqIEZvciBleGFtcGxlLCB3aXJlIHRoaXMgdG8gYSB1c2VyIGNsaWNrIGhhbmRsZXIuXHJcbiAgICAgKi9cclxuICAgIGdvRnVsbFNjcmVlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FudmFzLnJlcXVlc3RGdWxsc2NyZWVuKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcXVlc3RzIHRvIGV4aXQgZnVsbHNjcmVlbiB1c2luZyB0aGUgYnJvd3NlciBmdWxsc2NyZWVuIGFwaVxyXG4gICAgICovXHJcbiAgICBleGl0RnVsbFNjcmVlbigpIHtcclxuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW4oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSBjb29yZGluYXRlIGluIG5vcm1hbCBodG1sIHBhZ2Ugc3BhY2UsIGZvciBleGFtcGxlIGZyb20gYSBwb2ludGVyIG1vdmUgZXZlbnQsIGFuZCB0cmFuc2xhdGVzIGl0IHRvXHJcbiAgICAgKiBFeGNhbGlidXIgc2NyZWVuIHNwYWNlLlxyXG4gICAgICpcclxuICAgICAqIEV4Y2FsaWJ1ciBzY3JlZW4gc3BhY2Ugc3RhcnRzIGF0IHRoZSB0b3AgbGVmdCAoMCwgMCkgY29ybmVyIG9mIHRoZSB2aWV3cG9ydCwgYW5kIGV4dGVuZHMgdG8gdGhlXHJcbiAgICAgKiBib3R0b20gcmlnaHQgY29ybmVyIChyZXNvbHV0aW9uWCwgcmVzb2x1dGlvblkpXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgcGFnZVRvU2NyZWVuQ29vcmRpbmF0ZXMocG9pbnQpIHtcclxuICAgICAgICBsZXQgbmV3WCA9IHBvaW50Lng7XHJcbiAgICAgICAgbGV0IG5ld1kgPSBwb2ludC55O1xyXG4gICAgICAgIGlmICghdGhpcy5faXNGdWxsU2NyZWVuKSB7XHJcbiAgICAgICAgICAgIG5ld1ggLT0gZ2V0UG9zaXRpb24odGhpcy5fY2FudmFzKS54O1xyXG4gICAgICAgICAgICBuZXdZIC09IGdldFBvc2l0aW9uKHRoaXMuX2NhbnZhcykueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgZnVsbHNjcmVlbiBhcGkgb24gaXQgY2VudGVycyB3aXRoIGJsYWNrIGJhcnNcclxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGFkanVzdCB0aGUgc2NyZWVuIHRvIHdvcmxkIGNvb3JkaW5hdGVzIGluIHRoaXMgY2FzZVxyXG4gICAgICAgIGlmICh0aGlzLl9pc0Z1bGxTY3JlZW4pIHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIC8gdGhpcy5hc3BlY3RSYXRpbyA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuSGVpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuTWFyZ2luWSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBzY3JlZW5IZWlnaHQpIC8gMjtcclxuICAgICAgICAgICAgICAgIG5ld1kgPSAoKG5ld1kgLSBzY3JlZW5NYXJnaW5ZKSAvIHNjcmVlbkhlaWdodCkgKiB0aGlzLnZpZXdwb3J0LmhlaWdodDtcclxuICAgICAgICAgICAgICAgIG5ld1ggPSAobmV3WCAvIHdpbmRvdy5pbm5lcldpZHRoKSAqIHRoaXMudmlld3BvcnQud2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5XaWR0aCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIHRoaXMuYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5NYXJnaW5YID0gKHdpbmRvdy5pbm5lcldpZHRoIC0gc2NyZWVuV2lkdGgpIC8gMjtcclxuICAgICAgICAgICAgICAgIG5ld1ggPSAoKG5ld1ggLSBzY3JlZW5NYXJnaW5YKSAvIHNjcmVlbldpZHRoKSAqIHRoaXMudmlld3BvcnQud2lkdGg7XHJcbiAgICAgICAgICAgICAgICBuZXdZID0gKG5ld1kgLyB3aW5kb3cuaW5uZXJIZWlnaHQpICogdGhpcy52aWV3cG9ydC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbmV3WCA9IChuZXdYIC8gdGhpcy52aWV3cG9ydC53aWR0aCkgKiB0aGlzLnJlc29sdXRpb24ud2lkdGg7XHJcbiAgICAgICAgbmV3WSA9IChuZXdZIC8gdGhpcy52aWV3cG9ydC5oZWlnaHQpICogdGhpcy5yZXNvbHV0aW9uLmhlaWdodDtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihuZXdYLCBuZXdZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSBjb29yZGluYXRlIGluIEV4Y2FsaWJ1ciBzY3JlZW4gc3BhY2UsIGFuZCB0cmFuc2xhdGVzIGl0IHRvIG5vcm1hbCBodG1sIHBhZ2Ugc3BhY2UuIEZvciBleGFtcGxlLFxyXG4gICAgICogdGhpcyBpcyB3aGVyZSBodG1sIGVsZW1lbnRzIG1pZ2h0IGxpdmUgaWYgeW91IHdhbnQgdG8gcG9zaXRpb24gdGhlbSByZWxhdGl2ZSB0byBFeGNhbGlidXIuXHJcbiAgICAgKlxyXG4gICAgICogRXhjYWxpYnVyIHNjcmVlbiBzcGFjZSBzdGFydHMgYXQgdGhlIHRvcCBsZWZ0ICgwLCAwKSBjb3JuZXIgb2YgdGhlIHZpZXdwb3J0LCBhbmQgZXh0ZW5kcyB0byB0aGVcclxuICAgICAqIGJvdHRvbSByaWdodCBjb3JuZXIgKHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSlcclxuICAgICAqIEBwYXJhbSBwb2ludFxyXG4gICAgICovXHJcbiAgICBzY3JlZW5Ub1BhZ2VDb29yZGluYXRlcyhwb2ludCkge1xyXG4gICAgICAgIGxldCBuZXdYID0gcG9pbnQueDtcclxuICAgICAgICBsZXQgbmV3WSA9IHBvaW50Lnk7XHJcbiAgICAgICAgbmV3WCA9IChuZXdYIC8gdGhpcy5yZXNvbHV0aW9uLndpZHRoKSAqIHRoaXMudmlld3BvcnQud2lkdGg7XHJcbiAgICAgICAgbmV3WSA9IChuZXdZIC8gdGhpcy5yZXNvbHV0aW9uLmhlaWdodCkgKiB0aGlzLnZpZXdwb3J0LmhlaWdodDtcclxuICAgICAgICBpZiAodGhpcy5faXNGdWxsU2NyZWVuKSB7XHJcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCAvIHRoaXMuYXNwZWN0UmF0aW8gPCB3aW5kb3cuaW5uZXJIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbkhlaWdodCA9IHdpbmRvdy5pbm5lcldpZHRoIC8gdGhpcy5hc3BlY3RSYXRpbztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbk1hcmdpblkgPSAod2luZG93LmlubmVySGVpZ2h0IC0gc2NyZWVuSGVpZ2h0KSAvIDI7XHJcbiAgICAgICAgICAgICAgICBuZXdZID0gKG5ld1kgLyB0aGlzLnZpZXdwb3J0LmhlaWdodCkgKiBzY3JlZW5IZWlnaHQgKyBzY3JlZW5NYXJnaW5ZO1xyXG4gICAgICAgICAgICAgICAgbmV3WCA9IChuZXdYIC8gdGhpcy52aWV3cG9ydC53aWR0aCkgKiB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbldpZHRoID0gd2luZG93LmlubmVySGVpZ2h0ICogdGhpcy5hc3BlY3RSYXRpbztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbk1hcmdpblggPSAod2luZG93LmlubmVyV2lkdGggLSBzY3JlZW5XaWR0aCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgbmV3WCA9IChuZXdYIC8gdGhpcy52aWV3cG9ydC53aWR0aCkgKiBzY3JlZW5XaWR0aCArIHNjcmVlbk1hcmdpblg7XHJcbiAgICAgICAgICAgICAgICBuZXdZID0gKG5ld1kgLyB0aGlzLnZpZXdwb3J0LmhlaWdodCkgKiB3aW5kb3cuaW5uZXJIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0Z1bGxTY3JlZW4pIHtcclxuICAgICAgICAgICAgbmV3WCArPSBnZXRQb3NpdGlvbih0aGlzLl9jYW52YXMpLng7XHJcbiAgICAgICAgICAgIG5ld1kgKz0gZ2V0UG9zaXRpb24odGhpcy5fY2FudmFzKS55O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihuZXdYLCBuZXdZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSBjb29yZGluYXRlIGluIEV4Y2FsaWJ1ciBzY3JlZW4gc3BhY2UsIGFuZCB0cmFuc2xhdGVzIGl0IHRvIEV4Y2FsaWJ1ciB3b3JsZCBzcGFjZS5cclxuICAgICAqXHJcbiAgICAgKiBXb3JsZCBzcGFjZSBpcyB3aGVyZSBbW0VudGl0eXxlbnRpdGllc11dIGluIEV4Y2FsaWJ1ciBsaXZlIGJ5IGRlZmF1bHQgW1tDb29yZFBsYW5lLldvcmxkXV1cclxuICAgICAqIGFuZCBleHRlbmRzIGluZmluaXRlbHkgb3V0IHJlbGF0aXZlIGZyb20gdGhlIFtbQ2FtZXJhXV0uXHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgIFNjcmVlbiBjb29yZGluYXRlIHRvIGNvbnZlcnRcclxuICAgICAqL1xyXG4gICAgc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKHBvaW50KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIGxldCBuZXdYID0gcG9pbnQueDtcclxuICAgICAgICBsZXQgbmV3WSA9IHBvaW50Lnk7XHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIGJhY2sgdG8gd29ybGQgc3BhY2VcclxuICAgICAgICBuZXdYID0gKG5ld1ggLyB0aGlzLnJlc29sdXRpb24ud2lkdGgpICogdGhpcy5kcmF3V2lkdGg7XHJcbiAgICAgICAgbmV3WSA9IChuZXdZIC8gdGhpcy5yZXNvbHV0aW9uLmhlaWdodCkgKiB0aGlzLmRyYXdIZWlnaHQ7XHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIGJhc2VkIG9uIHpvb21cclxuICAgICAgICBuZXdYID0gbmV3WCAtIHRoaXMuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICBuZXdZID0gbmV3WSAtIHRoaXMuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgLy8gc2hpZnQgYnkgY2FtZXJhIGZvY3VzXHJcbiAgICAgICAgbmV3WCArPSAoX2IgPSAoX2EgPSB0aGlzLl9jYW1lcmEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS54KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xyXG4gICAgICAgIG5ld1kgKz0gKF9kID0gKF9jID0gdGhpcy5fY2FtZXJhKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MueSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMDtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihuZXdYLCBuZXdZKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGFrZXMgYSBjb29yZGluYXRlIGluIEV4Y2FsaWJ1ciB3b3JsZCBzcGFjZSwgYW5kIHRyYW5zbGF0ZXMgaXQgdG8gRXhjYWxpYnVyIHNjcmVlbiBzcGFjZS5cclxuICAgICAqXHJcbiAgICAgKiBTY3JlZW4gc3BhY2UgaXMgd2hlcmUgW1tTY3JlZW5FbGVtZW50fHNjcmVlbiBlbGVtZW50c11dIGFuZCBbW0VudGl0eXxlbnRpdGllc11dIHdpdGggW1tDb29yZFBsYW5lLlNjcmVlbl1dIGxpdmUuXHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgIFdvcmxkIGNvb3JkaW5hdGUgdG8gY29udmVydFxyXG4gICAgICovXHJcbiAgICB3b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMocG9pbnQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgbGV0IHNjcmVlblggPSBwb2ludC54O1xyXG4gICAgICAgIGxldCBzY3JlZW5ZID0gcG9pbnQueTtcclxuICAgICAgICAvLyBzaGlmdCBieSBjYW1lcmEgZm9jdXNcclxuICAgICAgICBzY3JlZW5YIC09IChfYiA9IChfYSA9IHRoaXMuX2NhbWVyYSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLngpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgICAgICAgc2NyZWVuWSAtPSAoX2QgPSAoX2MgPSB0aGlzLl9jYW1lcmEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy55KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwO1xyXG4gICAgICAgIC8vIHRyYW5zZm9ybSBiYWNrIG9uIHpvb21cclxuICAgICAgICBzY3JlZW5YID0gc2NyZWVuWCArIHRoaXMuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICBzY3JlZW5ZID0gc2NyZWVuWSArIHRoaXMuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIGJhY2sgdG8gc2NyZWVuIHNwYWNlXHJcbiAgICAgICAgc2NyZWVuWCA9IChzY3JlZW5YIC8gdGhpcy5kcmF3V2lkdGgpICogdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xyXG4gICAgICAgIHNjcmVlblkgPSAoc2NyZWVuWSAvIHRoaXMuZHJhd0hlaWdodCkgKiB0aGlzLnJlc29sdXRpb24uaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHNjcmVlblgsIHNjcmVlblkpO1xyXG4gICAgfVxyXG4gICAgcGFnZVRvV29ybGRDb29yZGluYXRlcyhwb2ludCkge1xyXG4gICAgICAgIGNvbnN0IHNjcmVlbiA9IHRoaXMucGFnZVRvU2NyZWVuQ29vcmRpbmF0ZXMocG9pbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhzY3JlZW4pO1xyXG4gICAgfVxyXG4gICAgd29ybGRUb1BhZ2VDb29yZGluYXRlcyhwb2ludCkge1xyXG4gICAgICAgIGNvbnN0IHNjcmVlbiA9IHRoaXMud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKHBvaW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW5Ub1BhZ2VDb29yZGluYXRlcyhzY3JlZW4pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgQm91bmRpbmdCb3ggb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgc2NyZWVuXHJcbiAgICAgKiBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHNjcmVlbi5cclxuICAgICAqXHJcbiAgICAgKiBXb3JsZCBib3VuZHMgYXJlIGluIHdvcmxkIGNvb3JkaW5hdGVzLCB1c2VmdWwgZm9yIGN1bGxpbmcgb2JqZWN0cyBvZmZzY3JlZW5cclxuICAgICAqL1xyXG4gICAgZ2V0V29ybGRCb3VuZHMoKSB7XHJcbiAgICAgICAgY29uc3QgbGVmdCA9IHRoaXMuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKFZlY3Rvci5aZXJvKS54O1xyXG4gICAgICAgIGNvbnN0IHRvcCA9IHRoaXMuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKFZlY3Rvci5aZXJvKS55O1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gbGVmdCArIHRoaXMuZHJhd1dpZHRoO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IHRvcCArIHRoaXMuZHJhd0hlaWdodDtcclxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgZ2FtZSBjYW52YXMgaW4gcGl4ZWxzIChwaHlzaWNhbCB3aWR0aCBjb21wb25lbnQgb2YgdGhlXHJcbiAgICAgKiByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgZWxlbWVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbnZhc1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy53aWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBoYWxmIHdpZHRoIG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKGhhbGYgcGh5c2ljYWwgd2lkdGggY29tcG9uZW50KVxyXG4gICAgICovXHJcbiAgICBnZXQgaGFsZkNhbnZhc1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy53aWR0aCAvIDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscywgKHBoeXNpY2FsIGhlaWdodCBjb21wb25lbnQgb2ZcclxuICAgICAqIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgZWxlbWVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbnZhc0hlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhhbGYgaGVpZ2h0IG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKGhhbGYgcGh5c2ljYWwgaGVpZ2h0IGNvbXBvbmVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGhhbGZDYW52YXNIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLmhlaWdodCAvIDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyYXdXaWR0aCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY2FtZXJhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlc29sdXRpb24ud2lkdGggLyB0aGlzLl9jYW1lcmEuem9vbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi53aWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBoYWxmIHRoZSB3aWR0aCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgKi9cclxuICAgIGdldCBoYWxmRHJhd1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdXaWR0aCAvIDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgKi9cclxuICAgIGdldCBkcmF3SGVpZ2h0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYW1lcmEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQgLyB0aGlzLl9jYW1lcmEuem9vbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaGFsZiB0aGUgaGVpZ2h0IG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhhbGZEcmF3SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdIZWlnaHQgLyAyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHNjcmVlbiBjZW50ZXIgY29vcmRpbmF0ZXMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGNlbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gdmVjKHRoaXMuaGFsZkRyYXdXaWR0aCwgdGhpcy5oYWxmRHJhd0hlaWdodCk7XHJcbiAgICB9XHJcbiAgICBfY29tcHV0ZUZpdCgpIHtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm1hcmdpbiA9ICcwcHgnO1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgICBjb25zdCBhc3BlY3QgPSB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICAgIGxldCBhZGp1c3RlZFdpZHRoID0gMDtcclxuICAgICAgICBsZXQgYWRqdXN0ZWRIZWlnaHQgPSAwO1xyXG4gICAgICAgIGlmICh3aW5kb3cuaW5uZXJXaWR0aCAvIGFzcGVjdCA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICAgICAgICBhZGp1c3RlZFdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XHJcbiAgICAgICAgICAgIGFkanVzdGVkSGVpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhZGp1c3RlZFdpZHRoID0gd2luZG93LmlubmVySGVpZ2h0ICogYXNwZWN0O1xyXG4gICAgICAgICAgICBhZGp1c3RlZEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IGFkanVzdGVkV2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogYWRqdXN0ZWRIZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2NvbXB1dGVGaXRDb250YWluZXIoKSB7XHJcbiAgICAgICAgY29uc3QgYXNwZWN0ID0gdGhpcy5hc3BlY3RSYXRpbztcclxuICAgICAgICBsZXQgYWRqdXN0ZWRXaWR0aCA9IDA7XHJcbiAgICAgICAgbGV0IGFkanVzdGVkSGVpZ2h0ID0gMDtcclxuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmNhbnZhcy5wYXJlbnRFbGVtZW50O1xyXG4gICAgICAgIGlmIChwYXJlbnQuY2xpZW50V2lkdGggLyBhc3BlY3QgPCBwYXJlbnQuY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGFkanVzdGVkV2lkdGggPSBwYXJlbnQuY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgIGFkanVzdGVkSGVpZ2h0ID0gcGFyZW50LmNsaWVudFdpZHRoIC8gYXNwZWN0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgYWRqdXN0ZWRXaWR0aCA9IHBhcmVudC5jbGllbnRIZWlnaHQgKiBhc3BlY3Q7XHJcbiAgICAgICAgICAgIGFkanVzdGVkSGVpZ2h0ID0gcGFyZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydCA9IHtcclxuICAgICAgICAgICAgd2lkdGg6IGFkanVzdGVkV2lkdGgsXHJcbiAgICAgICAgICAgIGhlaWdodDogYWRqdXN0ZWRIZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2FwcGx5RGlzcGxheU1vZGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLlBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVEaXNwbGF5TW9kZVBvc2l0aW9uKHRoaXMuX3Bvc2l0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFJlc29sdXRpb25BbmRWaWV3cG9ydEJ5RGlzcGxheU1vZGUodGhpcy5wYXJlbnQpO1xyXG4gICAgICAgICAgICAvLyB3YXRjaCByZXNpemluZ1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQgaW5zdGFuY2VvZiBXaW5kb3cpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Jyb3dzZXIud2luZG93Lm9uKCdyZXNpemUnLCB0aGlzLl9yZXNpemVIYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZXNpemVIYW5kbGVyKCk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy5wYXJlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcmVzb3VsdGlvbiBhbmQgdmlld3BvcnQgYmFzZWQgb24gdGhlIHNlbGVjdGVkIGRpc3BsYXkgbW9kZS5cclxuICAgICAqL1xyXG4gICAgX3NldFJlc29sdXRpb25BbmRWaWV3cG9ydEJ5RGlzcGxheU1vZGUocGFyZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkZpbGxDb250YWluZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHBhcmVudC5jbGllbnRXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyZW50LmNsaWVudEhlaWdodFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdGhpcy5yZXNvbHV0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuRmlsbFNjcmVlbikge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm1hcmdpbiA9ICcwcHgnO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHtcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBwYXJlbnQuaW5uZXJXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogcGFyZW50LmlubmVySGVpZ2h0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5GaXRTY3JlZW4pIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUZpdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuRml0Q29udGFpbmVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXB1dGVGaXRDb250YWluZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZURpc3BsYXlNb2RlUG9zaXRpb24ocG9zaXRpb24pIHtcclxuICAgICAgICBpZiAoIXBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRGlzcGxheU1vZGUgb2YgUG9zaXRpb24gd2FzIHNlbGVjdGVkIGJ1dCBubyBwb3NpdGlvbiBvcHRpb24gd2FzIGdpdmVuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHBvc2l0aW9uID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BlY2lmaWVkUG9zaXRpb24gPSBwb3NpdGlvbi5zcGxpdCgnICcpO1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzcGVjaWZpZWRQb3NpdGlvblswXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9ICcwcHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdib3R0b20nOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5ib3R0b20gPSAnMHB4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbWlkZGxlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gJzUwJSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSAtdGhpcy5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubWFyZ2luVG9wID0gb2Zmc2V0WS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUG9zaXRpb24gR2l2ZW4nKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzcGVjaWZpZWRQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc3BlY2lmaWVkUG9zaXRpb25bMV0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVmdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gJzBweCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUucmlnaHQgPSAnMHB4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjZW50ZXInOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUubGVmdCA9ICc1MCUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IC10aGlzLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5tYXJnaW5MZWZ0ID0gb2Zmc2V0WC50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgUG9zaXRpb24gR2l2ZW4nKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24udG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBvc2l0aW9uLnRvcCA9PT0gJ251bWJlcidcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyAodGhpcy5jYW52YXMuc3R5bGUudG9wID0gcG9zaXRpb24udG9wLnRvU3RyaW5nKCkgKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICh0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSBwb3NpdGlvbi50b3ApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBvc2l0aW9uLnJpZ2h0ID09PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICh0aGlzLmNhbnZhcy5zdHlsZS5yaWdodCA9IHBvc2l0aW9uLnJpZ2h0LnRvU3RyaW5nKCkgKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICh0aGlzLmNhbnZhcy5zdHlsZS5yaWdodCA9IHBvc2l0aW9uLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbi5ib3R0b20pIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcG9zaXRpb24uYm90dG9tID09PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICh0aGlzLmNhbnZhcy5zdHlsZS5ib3R0b20gPSBwb3NpdGlvbi5ib3R0b20udG9TdHJpbmcoKSArICdweCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHRoaXMuY2FudmFzLnN0eWxlLmJvdHRvbSA9IHBvc2l0aW9uLmJvdHRvbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24ubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwb3NpdGlvbi5sZWZ0ID09PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICh0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gcG9zaXRpb24ubGVmdC50b1N0cmluZygpICsgJ3B4JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAodGhpcy5jYW52YXMuc3R5bGUubGVmdCA9IHBvc2l0aW9uLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUmVzb3VyY2VzL1NvdW5kL0F1ZGlvQ29udGV4dC50c1xuLyoqXHJcbiAqIEludGVybmFsIGNsYXNzIHVzZWQgdG8gYnVpbGQgaW5zdGFuY2VzIG9mIEF1ZGlvQ29udGV4dFxyXG4gKi9cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuY2xhc3MgQXVkaW9Db250ZXh0RmFjdG9yeSB7XHJcbiAgICBzdGF0aWMgY3JlYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fSU5TVEFOQ0UpIHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fSU5TVEFOQ0UgPSBuZXcgQXVkaW9Db250ZXh0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX0lOU1RBTkNFO1xyXG4gICAgfVxyXG59XHJcbkF1ZGlvQ29udGV4dEZhY3RvcnkuX0lOU1RBTkNFID0gbnVsbDtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL1dlYkF1ZGlvLnRzXG5cclxuXHJcbi8qKlxyXG4gKiBQYXRjaCBmb3IgZGV0ZWN0aW5nIGxlZ2FjeSB3ZWIgYXVkaW8gaW4gYnJvd3NlcnNcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSBzb3VyY2VcclxuICovXHJcbmZ1bmN0aW9uIGlzTGVnYWN5V2ViQXVkaW9Tb3VyY2Uoc291cmNlKSB7XHJcbiAgICByZXR1cm4gISFzb3VyY2UucGxheWJhY2tTdGF0ZTtcclxufVxyXG5jbGFzcyBXZWJBdWRpbyB7XHJcbiAgICAvKipcclxuICAgICAqIFBsYXkgYW4gZW1wdHkgc291bmQgdG8gdW5sb2NrIFNhZmFyaSBXZWJBdWRpbyBjb250ZXh0LiBDYWxsIHRoaXMgZnVuY3Rpb25cclxuICAgICAqIHJpZ2h0IGFmdGVyIGEgdXNlciBpbnRlcmFjdGlvbiBldmVudC5cclxuICAgICAqIEBzb3VyY2UgaHR0cHM6Ly9wYXVsYmFrYXVzLmNvbS90dXRvcmlhbHMvaHRtbDUvd2ViLWF1ZGlvLW9uLWlvcy9cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVubG9jaygpIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoV2ViQXVkaW8uX1VOTE9DS0VEIHx8ICFBdWRpb0NvbnRleHRGYWN0b3J5LmNyZWF0ZSgpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCB1bmxvY2tUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0V4Y2FsaWJ1ciB3YXMgdW5hYmxlIHRvIHVubG9jayB0aGUgYXVkaW8gY29udGV4dCwgYXVkaW8gcHJvYmFibHkgd2lsbCBub3QgcGxheSBpbiB0aGlzIGJyb3dzZXIuJyk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKGZhbHNlKTtcclxuICAgICAgICAgICAgfSwgMjAwKTtcclxuICAgICAgICAgICAgY29uc3QgYXVkaW9Db250ZXh0ID0gQXVkaW9Db250ZXh0RmFjdG9yeS5jcmVhdGUoKTtcclxuICAgICAgICAgICAgYXVkaW9Db250ZXh0LnJlc3VtZSgpLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGVtcHR5IGJ1ZmZlciBhbmQgcGxheSBpdFxyXG4gICAgICAgICAgICAgICAgY29uc3QgYnVmZmVyID0gYXVkaW9Db250ZXh0LmNyZWF0ZUJ1ZmZlcigxLCAxLCAyMjA1MCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZW5kZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5idWZmZXIgPSBidWZmZXI7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2UuY29ubmVjdChhdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgc291cmNlLm9uZW5kZWQgPSAoKSA9PiAoZW5kZWQgPSB0cnVlKTtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5zdGFydCgwKTtcclxuICAgICAgICAgICAgICAgIC8vIGJ5IGNoZWNraW5nIHRoZSBwbGF5IHN0YXRlIGFmdGVyIHNvbWUgdGltZSwgd2Uga25vdyBpZiB3ZSdyZSByZWFsbHkgdW5sb2NrZWRcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0xlZ2FjeVdlYkF1ZGlvU291cmNlKHNvdXJjZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5wbGF5YmFja1N0YXRlID09PSBzb3VyY2UuUExBWUlOR19TVEFURSB8fCBzb3VyY2UucGxheWJhY2tTdGF0ZSA9PT0gc291cmNlLkZJTklTSEVEX1NUQVRFKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBXZWJBdWRpby5fVU5MT0NLRUQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lID4gMCB8fCBlbmRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgV2ViQXVkaW8uX1VOTE9DS0VEID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sIDApO1xyXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHVubG9ja1RpbWVvdXRUaW1lcik7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3QoKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgaXNVbmxvY2tlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fVU5MT0NLRUQ7XHJcbiAgICB9XHJcbn1cclxuV2ViQXVkaW8uX1VOTE9DS0VEID0gZmFsc2U7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ2xhc3MudHNcblxyXG4vKipcclxuICogRXhjYWxpYnVyIGJhc2UgY2xhc3MgdGhhdCBwcm92aWRlcyBiYXNpYyBmdW5jdGlvbmFsaXR5IHN1Y2ggYXMgW1tFdmVudERpc3BhdGNoZXJdXVxyXG4gKiBhbmQgZXh0ZW5kaW5nIGFiaWxpdGllcyBmb3IgdmFuaWxsYSBKYXZhc2NyaXB0IHByb2plY3RzXHJcbiAqL1xyXG5jbGFzcyBDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG5ldyBFdmVudERpc3BhdGNoZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsaWFzIGZvciBgYWRkRXZlbnRMaXN0ZW5lcmAuIFlvdSBjYW4gbGlzdGVuIGZvciBhIHZhcmlldHkgb2ZcclxuICAgICAqIGV2ZW50cyBvZmYgb2YgdGhlIGVuZ2luZTsgc2VlIHRoZSBldmVudHMgc2VjdGlvbiBiZWxvdyBmb3IgYSBjb21wbGV0ZSBsaXN0LlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAgTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxyXG4gICAgICogQHBhcmFtIGhhbmRsZXIgICAgRXZlbnQgaGFuZGxlciBmb3IgdGhlIHRocm93biBldmVudFxyXG4gICAgICovXHJcbiAgICBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBbGlhcyBmb3IgYHJlbW92ZUV2ZW50TGlzdGVuZXJgLiBJZiBvbmx5IHRoZSBldmVudE5hbWUgaXMgc3BlY2lmaWVkXHJcbiAgICAgKiBpdCB3aWxsIHJlbW92ZSBhbGwgaGFuZGxlcnMgcmVnaXN0ZXJlZCBmb3IgdGhhdCBzcGVjaWZpYyBldmVudC4gSWYgdGhlIGV2ZW50TmFtZVxyXG4gICAgICogYW5kIHRoZSBoYW5kbGVyIGluc3RhbmNlIGFyZSBzcGVjaWZpZWQgb25seSB0aGF0IGhhbmRsZXIgd2lsbCBiZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiBmb3JcclxuICAgICAqIEBwYXJhbSBoYW5kbGVyICAgIEV2ZW50IGhhbmRsZXIgZm9yIHRoZSB0aHJvd24gZXZlbnRcclxuICAgICAqL1xyXG4gICAgb2ZmKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbWl0cyBhIG5ldyBldmVudFxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAgIE5hbWUgb2YgdGhlIGV2ZW50IHRvIGVtaXRcclxuICAgICAqIEBwYXJhbSBldmVudE9iamVjdCBEYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGV2ZW50XHJcbiAgICAgKi9cclxuICAgIGVtaXQoZXZlbnROYW1lLCBldmVudE9iamVjdCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoZXZlbnROYW1lLCBldmVudE9iamVjdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE9uY2UgbGlzdGVucyB0byBhbiBldmVudCBvbmUgdGltZSwgdGhlbiB1bnN1YnNjcmliZXMgZnJvbSB0aGF0IGV2ZW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvIG9uY2VcclxuICAgICAqIEBwYXJhbSBoYW5kbGVyICAgVGhlIGhhbmRsZXIgb2YgdGhlIGV2ZW50IHRoYXQgd2lsbCBiZSBhdXRvIHVuc3Vic2NyaWJlZFxyXG4gICAgICovXHJcbiAgICBvbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLm9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvRHJhd1V0aWwudHNcblxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4vKipcclxuICogRHJhdyBhIGxpbmUgb24gY2FudmFzIGNvbnRleHRcclxuICpcclxuICogQHBhcmFtIGN0eCBUaGUgY2FudmFzIGNvbnRleHRcclxuICogQHBhcmFtIGNvbG9yIFRoZSBjb2xvciBvZiB0aGUgbGluZVxyXG4gKiBAcGFyYW0geDEgVGhlIHN0YXJ0IHggY29vcmRpbmF0ZVxyXG4gKiBAcGFyYW0geTEgVGhlIHN0YXJ0IHkgY29vcmRpbmF0ZVxyXG4gKiBAcGFyYW0geDIgVGhlIGVuZGluZyB4IGNvb3JkaW5hdGVcclxuICogQHBhcmFtIHkyIFRoZSBlbmRpbmcgeSBjb29yZGluYXRlXHJcbiAqIEBwYXJhbSB0aGlja25lc3MgVGhlIGxpbmUgdGhpY2tuZXNzXHJcbiAqIEBwYXJhbSBjYXAgVGhlIFtbTGluZUNhcFN0eWxlXV0gKGJ1dHQsIHJvdW5kLCBvciBzcXVhcmUpXHJcbiAqL1xyXG5mdW5jdGlvbiBsaW5lKGN0eCwgY29sb3IgPSBDb2xvci5SZWQsIHgxLCB5MSwgeDIsIHkyLCB0aGlja25lc3MgPSAxLCBjYXAgPSAnYnV0dCcpIHtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGN0eC5saW5lV2lkdGggPSB0aGlja25lc3M7XHJcbiAgICBjdHgubGluZUNhcCA9IGNhcDtcclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICBjdHgubW92ZVRvKHgxLCB5MSk7XHJcbiAgICBjdHgubGluZVRvKHgyLCB5Mik7XHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBjdHguc3Ryb2tlKCk7XHJcbn1cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuLyoqXHJcbiAqIERyYXcgdGhlIHZlY3RvciBhcyBhIHBvaW50IG9udG8gdGhlIGNhbnZhcy5cclxuICovXHJcbmZ1bmN0aW9uIHBvaW50KGN0eCwgY29sb3IgPSBDb2xvci5SZWQsIHBvaW50KSB7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBjdHguc3Ryb2tlKCk7XHJcbn1cclxuLyoqXHJcbiAqIERyYXcgdGhlIHZlY3RvciBhcyBhIGxpbmUgb250byB0aGUgY2FudmFzIHN0YXJ0aW5nIGEgb3JpZ2luIHBvaW50LlxyXG4gKi9cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiB2ZWN0b3IoY3R4LCBjb2xvciwgb3JpZ2luLCB2ZWN0b3IsIHNjYWxlID0gMS4wKSB7XHJcbiAgICBjb25zdCBjID0gY29sb3IgPyBjb2xvci50b1N0cmluZygpIDogJ2JsdWUnO1xyXG4gICAgY29uc3QgdiA9IHZlY3Rvci5zY2FsZShzY2FsZSk7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSBjO1xyXG4gICAgY3R4Lm1vdmVUbyhvcmlnaW4ueCwgb3JpZ2luLnkpO1xyXG4gICAgY3R4LmxpbmVUbyhvcmlnaW4ueCArIHYueCwgb3JpZ2luLnkgKyB2LnkpO1xyXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgY3R4LnN0cm9rZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBEcmF3IGEgcm91bmQgcmVjdGFuZ2xlIG9uIGEgY2FudmFzIGNvbnRleHRcclxuICpcclxuICogQHBhcmFtIGN0eCBUaGUgY2FudmFzIGNvbnRleHRcclxuICogQHBhcmFtIHggVGhlIHRvcC1sZWZ0IHggY29vcmRpbmF0ZVxyXG4gKiBAcGFyYW0geSBUaGUgdG9wLWxlZnQgeSBjb29yZGluYXRlXHJcbiAqIEBwYXJhbSB3aWR0aCBUaGUgd2lkdGggb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcGFyYW0gaGVpZ2h0IFRoZSBoZWlnaHQgb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcGFyYW0gcmFkaXVzIFRoZSBib3JkZXIgcmFkaXVzIG9mIHRoZSByZWN0YW5nbGVcclxuICogQHBhcmFtIHN0cm9rZSBUaGUgW1tDb2xvcl1dIHRvIHN0cm9rZSByZWN0YW5nbGUgd2l0aFxyXG4gKiBAcGFyYW0gZmlsbCBUaGUgW1tDb2xvcl1dIHRvIGZpbGwgcmVjdGFuZ2xlIHdpdGhcclxuICovXHJcbmZ1bmN0aW9uIHJvdW5kUmVjdChjdHgsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cyA9IDUsIHN0cm9rZSA9IENvbG9yLldoaXRlLCBmaWxsID0gbnVsbCkge1xyXG4gICAgbGV0IGJyO1xyXG4gICAgaWYgKHR5cGVvZiByYWRpdXMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgYnIgPSB7IHRsOiByYWRpdXMsIHRyOiByYWRpdXMsIGJyOiByYWRpdXMsIGJsOiByYWRpdXMgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGRlZmF1bHRSYWRpdXMgPSB7IHRsOiAwLCB0cjogMCwgYnI6IDAsIGJsOiAwIH07XHJcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIGluIGRlZmF1bHRSYWRpdXMpIHtcclxuICAgICAgICAgICAgaWYgKGRlZmF1bHRSYWRpdXMuaGFzT3duUHJvcGVydHkocHJvcCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZGUgPSBwcm9wO1xyXG4gICAgICAgICAgICAgICAgYnJbc2lkZV0gPSByYWRpdXNbc2lkZV0gfHwgZGVmYXVsdFJhZGl1c1tzaWRlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGN0eC5tb3ZlVG8oeCArIGJyLnRsLCB5KTtcclxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gYnIudHIsIHkpO1xyXG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5LCB4ICsgd2lkdGgsIHkgKyBici50cik7XHJcbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIGJyLmJyKTtcclxuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gYnIuYnIsIHkgKyBoZWlnaHQpO1xyXG4gICAgY3R4LmxpbmVUbyh4ICsgYnIuYmwsIHkgKyBoZWlnaHQpO1xyXG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSArIGhlaWdodCwgeCwgeSArIGhlaWdodCAtIGJyLmJsKTtcclxuICAgIGN0eC5saW5lVG8oeCwgeSArIGJyLnRsKTtcclxuICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKHgsIHksIHggKyBici50bCwgeSk7XHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBpZiAoZmlsbCkge1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgIH1cclxuICAgIGlmIChzdHJva2UpIHtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2UudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjaXJjbGUoY3R4LCB4LCB5LCByYWRpdXMsIHN0cm9rZSA9IENvbG9yLldoaXRlLCBmaWxsID0gbnVsbCkge1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LmFyYyh4LCB5LCByYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0cm9rZSkge1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZS50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0xvYWRlci5sb2dvLnBuZ1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBMb2FkZXJfbG9nbyA9IChcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBZFFBQUFCMkNBWUFBQUJ4aEdJOUFBQUFDWEJJV1hNQUFBc1NBQUFMRWdIUzNYNzhBQUFLblVsRVFWUjQydTNkUDJ3alN4MEg4TjhoSklvbklSbUpqc3EwU0JSK0JRMWRjcUtoZTBsRDc3U3ZTd3BLa0pLR1B1bHBrdGZSSU1VZEVxS0lxVjU3cnBBb2tNNGRiU2l5cTdPTlBUUDd4MzlpZno3U0ZibkVucDN4ZXI0N083dXpIMTVmWHdNQTZPWUhtZ0FBQkNvQUNGUUFFS2dBZ0VBRkFJRUtBQUlWQUFRcUFDQlFBVUNnQW9CQUJRQ0JDZ0FJVkFBUXFBQWdVQUZBb0FJQUFoVUFCQ29BQ0ZRQUVLZ0FnRUNGTGJtT2lOZUZmMlBiQXl6NjhQcjZxaFVnYlJ3UjkydisvendpSnJZSE1FS0ZNbWNOLy8vVXRnY1FxRkJrMVBELzk3VTlReDhWQ0ZTZ3U0RW1BSUVLQUFJVkFBUXFBQ0JRNFoyNWpvalA4ZVgrMFd0TkFnSVZhT1krSW01aitlS2gyNGg0MWpRZ1VJRXlaN0Y1TmFQVTd3Q0JDaXdZZC93OWNPQitxQWxnSjNLTExvdzBFVjE5ODgwM1JXdkpmdmZkZHgrMGxoRXFIS3U1SmdBalZDQnZsaG1GempRUlhVZWtIejkrVFA3OXk4dUxSak5DaFhmdm9lUHZBWUVLeE50ajFlNDIvTzVKb0lKQUJjcmRSTVJWTE0rWDNrVEVwYWFCOTg4Y0t1eldnOUVvYlRXZE14ME9seTh1TjRkcWhBb0FScWduYU4zYXJIZnF1N095SDhJdEtMVkIvUCtDRWZNVEh5R1BZM25weDFtOHpXR0RFZW9CZlVrL3hkdGk1N2RyL3IxV3YyKzZFUG93M3RaNXJSZFM3MnMxbmV1Rjk3eHZXZCtYVEgwL1YrVU10dERXcWJJL3IybnJ4ZnAranYydVNqU083UytPWHkvQS8zbE4rOXhYNVQ1SHhFVVBaWjB0ZkI3MSt3NTdlSi9IRnUreitqa3YxdTkyWVg5ZmJJL0hoWDNKQTlycDVNUHI2NnRXYUc5VWZVR2JySEl6aTdjTFV5WUZmL3RwVGFkeTAzRUVlTDhtVUo2aTdNS1lOdldOcXI0UGUyanJhZFhPNjBMcnZQQXoyUFE1UlBYNjg0YWg4ZHhEKzJ6YW50bkNnVmlwU1ZWK20vdGdCOVcyRERxMlN4L3ZNOTV3Y0hoWmhXVkptOHlydjU4Y1NnZlRkYzcwKysrL1gvcjUyMisvdFVLU0VlcEJxbytvbTRaTFBlck1qVXd1Tm5RQ3R4MUdXSnRlZTFGd2RENXVXZDg2eExzOFVhVnQyYU5FTzEvc2FaL1o1cllNVzR6cTZ2MzRyR1Y5QmczcTJlWjlTa2VObTlxd3lVaDMwT1BJSFlGS3g1RkcwM0M3em5TT3FZQnErcVcvenBRM2FuSDAzN1ROSGx1RzZmMFdQc1BoSHZhYjRRRnR5N29nT2V1eERZY055Mi96dTIyMTRXTllXeG1CdXJOTzhiR245N3BOQk9POHh5Lzl1Q29yWlo0STJyNEM3YUpnTzdaVjlpRTQ5RG02TnZPV3grcFdFOUNVcTN6YmRUcDlkb3ozOFRiWHR6cUg5UlQ1Q3lXZTQyMk9hWm9aR2VaQ2FicmhQUVk5SGp3c2pwVHZDZzRZdGxFMitUYS9qMmJ6bjhmcXJEcWdtKzZ5VUhPbUF2V1VqQXRHaGJOWXZzQmtuRG5xSDFRaGM3Vm14SGdlYi9OYnVkQTVqL1VYbFl3aWYycDZsdWhBYzl0ZXUxbnBpSEtuRHM4aWY2dENtN0pMWDNOS3BndHRYZTlydWM5bUhNZDdhODNpd2R4RjV2dDh0dXRBUmFDZWtsUm5OSzlDOFduTkY3Z2VKUTRUNFhHM0poU25WZGlsUXJHK3lPbnJsVkhmc0VHWXpoTkJuN0x1NnRTNytISmFmSlE0RU1pTmxOcVdYWjlXUHZWZ25WWUhHNU0xQnlEWGtUNmxlWDJFZ1RxSnR5dDQ1eXY3UzJxTzNzRVpqWmhETFhlUitZS2RKMFpkazhRb2N2SDlONzMyS3JOdHErRlovenpJSEFCY0pyWXBkK1h2MTRsT2Q1YXA3NlNncmR1Vy9WVFExcWNRcHFuYmd1NGlmWnZVTU5wZDlYdW9abXZDdFBhUTJZL0JDSFZMZ2JySlRlUlBEZFZmNnBmTUtEVTJmT2tIbVZGRmZYcjNNc291THNuTnZWNWtSb2U1K3M0MzFQZXVvS1BxV25hdXJZL1pQQkVlcXdjZU40bDk2aXdPNkg3TWpxNHk3VkdQVk5lMTBWYVpNelZDUFZXcEkvWjZGWmJjdjVmTXFHQ1UrZExmRkd6ajU4alA4K2JDZEpDbzd5ektUd2RPRjBidTlVZzdWNGMreXo3RkpmWWVHb3lzVXNzMEhzc0lkVlp3WUxEdWpNcWxFU29DZFR0R3NadGJIbkpCZU5kRFNKU3MwalRLZE1KTjFITlg1NFd2N2J2c1U5TmtWSlZhMTNkWCsvd3VBclYwWC9sNVJIeW8vbG5mRjRHNnA2RHJTMGtIZHRYaHkzNVRHRXJEUFlaVW4yV2ZXcURPby9sVnFkTUQyTy9oS0poRDdTL29kdWt5bXE5czAyUU40RUVQUi96YmFPdW1aYytyMTV6SzFacXpubDlqc2ZpZW1UTTFRbVYzSFV1VGtlZGxnOUhJUXpSYlVEOTNkZkMrMnRwajJmSUhFSDIrUnFDQ1FIMTNnWnE3aFdYVE5wVnUxOU9CMWZjOW5RMEFLT0tVYjVsVTBQMWtEeU9uZW9XazBsT1o5Y0lQMHg3cXU4KzJCaENvUjJ3WXUxK2U3RG1hWHpCU3N1NXZhWDFuZTJ6cnBtVVBUbXhmN1BNMURtNHkvdkM3bnk3TmlmNyt6LzlabXRNMFozcGFuUEx0UG1yYTlmMTZiY0swRHBibndrNDNWZC9SSHR1NnpmTlFUeTFRQnkzYXFHMmc5blZteG1sK0JPb0p5VDNOcFdtbjl4aGZGbnU0YnZEYSs0NEJYaHFxZmRmM3VVRjkreXo3N0FUMzFZdWUybWplY1lRNjJOTGZna0E5Z2hIcUxORWhOZW00SDFjNnZkeUR4aGYvYnB6NW00Y29XL2MzOXdpNlZIMmJQdEhsY2FWOWN2WHRzK3p4Q2U2clRlcWMybmRMN3VHZDkzUXdNOWJGY0F6TW9aWjdTZ1RCYld4K2FzdWk2MWgvaXExK1JtanFkYm5RWFEzVDFETlE2M1YvVTl1Y3FtL3BNelBiMXJlUHNrLzFpVE9qZ3ZhdFI0VzNMYzhVTEI3OHBFTHlybkFmZVRjajFOVTUwOS84Nm1mSjMzLzgrTWYwMGEwNVV5UFVFdzdVVkNlV0cvV05FaUV4eUhSTXQ1bHRXMzBpelVQazE4eXR0N2xOZmM4aS8vRHZ0dlh0byt5U0E1QmpsanNMVUY4bFBrcU1QRXRXMUpvbURzaUdCWjlCeWI0TkF2VUlUU045R3V3c0lqNnQ2VVRPcWs3akpSRWttenFsaTh4SXM5NnVkU08yMHNYMEgxdlc5MklMOWUxYTlyZ3FWeWY5MWdiUHNUeTlVRDluOWxPa1Q4aytSZmtGUjVQTU5xeE9jZFNmMzJQQnZnM3ZpbE8remR4RStva3g5V20wcGgzNlhZc1JaQ3BNRjk5M0dPazVxdnFCM0RjdDZqdnNzYjY3S3Z1VU5KM2ZydzkyYmhyOC9TVFNGMEpkUlBNTHBVQ2duc2dvOVM3NlBaMjQ2WkZrMXdXdks1bTN2Vm9ZdlcxU3o3bk45MWpmWGJRMVpRYzdUVzZIZWFvT2FseXBHLzgvcC9yUDFhTkFjNlpIelNuZmRxUFVQaGR5MlBRdzZOejlnU1ZodWhpcXVlVUhSM3V1N3k3SzNyZERYNHU0NlpyUGJVYTBJRkJaMHNlS1EzWFFUUnQydm0zVy9hMkRiTkt5cysrcnZtM2VwNit5MXgyVWRQM2JXVTlsenJhNDdVMUdtbGN0WC9zUTIzdCthT2xCeUxUaC80TkFQYUNSeHRjZE81SExTSi82dk50Q3dHeDY3VlBtUGJ2V2QxcTlmcktIdHA0a0FxUkoySFI5ajc2MkpmWDNiWi8vZWxQdGoxM1BQRHgxK0Q1dHFrL1hpNk5POFNIejdNbUgxOWRYcmRCTmZWRlA2VDJQVDFVSE5pdDg3L3Q0bTUrYVJIK25RQmR2cXloWkRLSkxmWnM4aDdYUHNxZFYyWk9WK3RhbktCOGFsbjBkeXhkQVhiVjRqNGd2dDRvTU9yYlA2dmJVNzNOVzdUTWxiZFRuUHJXcGZxWGZoOUhLWjl2a2U3S3VUZVpSTnRYUlNlNisxRlYvL2NlL2xuNWVYZnNYZ2NxWHpyNis5MjYxTTNtb09vYTdFNm52VFpUZnk3aU5zbWZiN2tqZmdYR3N2eGUwdmloc0V0czlIVHF1UHB0MXExdnRhaHUyVHFBaVVBRUVLajB6aHdvQVJxZ0F1L09uWC80NDJXSCs5eGMvV3ZyNThyZS9UcjdmNDEvK1pzUnFoQW9BQ0ZRQUVLZ0FjSGpNb1FKc2tKc3ovZXFycjVaK3Z2cjd2NWZtUUZldkFsNWx6dFFJRlFBUXFBQWdVQUhnSUpsREJkaGdkUTQxTjJlS0VTb0FJRkFCUUtBQ3dGRXdod29BUnFnQUlGQUJRS0FDQUFJVkFBUXFBQWhVQUJDb0FJQkFCUUNCQ2dBQ0ZRQUVLZ0FnVUFGQW9BS0FRQVVBZ1FvQUNGUUFFS2dBSUZBQlFLQUNBQUlWQUFRcUFBaFVBQkNvQUlCQUJRQ0JDZ0FDRlFBUXFBQWdVQUZBb0FLQVFBVUFsdndQY0ZEbnMxRHNINHNBQUFBQVNVVk9SSzVDWUlJPVwiKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9Mb2FkZXIuY3NzXG52YXIgTG9hZGVyXzAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzODgpO1xuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTG9hZGVyLnRzXG52YXIgTG9hZGVyX2F3YWl0ZXIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFByZS1sb2FkaW5nIGFzc2V0c1xyXG4gKlxyXG4gKiBUaGUgbG9hZGVyIHByb3ZpZGVzIGEgbWVjaGFuaXNtIHRvIHByZWxvYWQgbXVsdGlwbGUgcmVzb3VyY2VzIGF0XHJcbiAqIG9uZSB0aW1lLiBUaGUgbG9hZGVyIG11c3QgYmUgcGFzc2VkIHRvIHRoZSBlbmdpbmUgaW4gb3JkZXIgdG9cclxuICogdHJpZ2dlciB0aGUgbG9hZGluZyBwcm9ncmVzcyBiYXIuXHJcbiAqXHJcbiAqIFRoZSBbW0xvYWRlcl1dIGl0c2VsZiBpbXBsZW1lbnRzIFtbTG9hZGFibGVdXSBzbyB5b3UgY2FuIGxvYWQgbG9hZGVycy5cclxuICpcclxuICogIyMgRXhhbXBsZTogUHJlLWxvYWRpbmcgcmVzb3VyY2VzIGZvciBhIGdhbWVcclxuICpcclxuICogYGBganNcclxuICogLy8gY3JlYXRlIGEgbG9hZGVyXHJcbiAqIHZhciBsb2FkZXIgPSBuZXcgZXguTG9hZGVyKCk7XHJcbiAqXHJcbiAqIC8vIGNyZWF0ZSBhIHJlc291cmNlIGRpY3Rpb25hcnkgKGJlc3QgcHJhY3RpY2UgaXMgdG8ga2VlcCBhIHNlcGFyYXRlIGZpbGUpXHJcbiAqIHZhciByZXNvdXJjZXMgPSB7XHJcbiAqICAgVGV4dHVyZUdyb3VuZDogbmV3IGV4LlRleHR1cmUoXCIvaW1hZ2VzL3RleHR1cmVzL2dyb3VuZC5wbmdcIiksXHJcbiAqICAgU291bmREZWF0aDogbmV3IGV4LlNvdW5kKFwiL3NvdW5kL2RlYXRoLndhdlwiLCBcIi9zb3VuZC9kZWF0aC5tcDNcIilcclxuICogfTtcclxuICpcclxuICogLy8gbG9vcCB0aHJvdWdoIGRpY3Rpb25hcnkgYW5kIGFkZCB0byBsb2FkZXJcclxuICogZm9yICh2YXIgbG9hZGFibGUgaW4gcmVzb3VyY2VzKSB7XHJcbiAqICAgaWYgKHJlc291cmNlcy5oYXNPd25Qcm9wZXJ0eShsb2FkYWJsZSkpIHtcclxuICogICAgIGxvYWRlci5hZGRSZXNvdXJjZShyZXNvdXJjZXNbbG9hZGFibGVdKTtcclxuICogICB9XHJcbiAqIH1cclxuICpcclxuICogLy8gc3RhcnQgZ2FtZVxyXG4gKiBnYW1lLnN0YXJ0KGxvYWRlcikudGhlbihmdW5jdGlvbiAoKSB7XHJcbiAqICAgY29uc29sZS5sb2coXCJHYW1lIHN0YXJ0ZWQhXCIpO1xyXG4gKiB9KTtcclxuICogYGBgXHJcbiAqXHJcbiAqICMjIEN1c3RvbWl6ZSB0aGUgTG9hZGVyXHJcbiAqXHJcbiAqIFRoZSBsb2FkZXIgY2FuIGJlIGN1c3RvbWl6ZWQgdG8gc2hvdyBkaWZmZXJlbnQsIHRleHQsIGxvZ28sIGJhY2tncm91bmQgY29sb3IsIGFuZCBidXR0b24uXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgbG9hZGVyID0gbmV3IGV4LkxvYWRlcihbcGxheWVyVGV4dHVyZV0pO1xyXG4gKlxyXG4gKiAvLyBUaGUgbG9hZGVycyBidXR0b24gdGV4dCBjYW4gc2ltcGx5IG1vZGlmaWVkIHVzaW5nIHRoaXNcclxuICogbG9hZGVyLnBsYXlCdXR0b25UZXh0ID0gJ1N0YXJ0IHRoZSBiZXN0IGdhbWUgZXZlcic7XHJcbiAqXHJcbiAqIC8vIFRoZSBsb2dvIGNhbiBiZSBjaGFuZ2VkIGJ5IGluc2VydGluZyBhIGJhc2U2NCBpbWFnZSBzdHJpbmcgaGVyZVxyXG4gKlxyXG4gKiBsb2FkZXIubG9nbyA9ICdkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3Li4uJztcclxuICogbG9hZGVyLmxvZ29XaWR0aCA9IDE1O1xyXG4gKiBsb2FkZXIubG9nb0hlaWdodCA9IDE0O1xyXG4gKlxyXG4gKiAvLyBUaGUgYmFja2dyb3VuZCBjb2xvciBjYW4gYmUgY2hhbmdlZCBsaWtlIHNvIGJ5IHN1cHBseWluZyBhIHZhbGlkIENTUyBjb2xvciBzdHJpbmdcclxuICpcclxuICogbG9hZGVyLmJhY2tncm91bmRDb2xvciA9ICdyZWQnXHJcbiAqIGxvYWRlci5iYWNrZ3JvdW5kQ29sb3IgPSAnIzE3NkJBQSdcclxuICpcclxuICogLy8gVG8gYnVpbGQgYSBjb21wbGV0ZWx5IG5ldyBidXR0b25cclxuICogbG9hZGVyLnN0YXJ0QnV0dG9uRmFjdG9yeSA9ICgpID0+IHtcclxuICogICAgIGxldCBteUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG4gKiAgICAgbXlCdXR0b24udGV4dENvbnRlbnQgPSAnVGhlIGJlc3QgYnV0dG9uJztcclxuICogICAgIHJldHVybiBteUJ1dHRvbjtcclxuICogfTtcclxuICpcclxuICogZW5naW5lLnN0YXJ0KGxvYWRlcikudGhlbigoKSA9PiB7fSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuY2xhc3MgTG9hZGVyIGV4dGVuZHMgQ2xhc3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gbG9hZGFibGVzICBPcHRpb25hbGx5IHByb3ZpZGUgdGhlIGxpc3Qgb2YgcmVzb3VyY2VzIHlvdSB3YW50IHRvIGxvYWQgYXQgY29uc3RydWN0b3IgdGltZVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihsb2FkYWJsZXMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzID0gbmV3IENhbnZhcyh7XHJcbiAgICAgICAgICAgIHNtb290aGluZzogdHJ1ZSxcclxuICAgICAgICAgICAgZHJhdzogdGhpcy5kcmF3LmJpbmQodGhpcylcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9yZXNvdXJjZUxpc3QgPSBbXTtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IDA7XHJcbiAgICAgICAgdGhpcy5fcGxheUJ1dHRvblNob3duID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VDb3VudCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbnVtTG9hZGVkID0gMDtcclxuICAgICAgICB0aGlzLl9wcm9ncmVzc0NvdW50cyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3RvdGFsQ291bnRzID0ge307XHJcbiAgICAgICAgLy8gbG9nbyBkcmF3aW5nIHN0dWZmXHJcbiAgICAgICAgLy8gYmFzZTY0IHN0cmluZyBlbmNvZGluZyBvZiB0aGUgZXhjYWxpYnVyIGxvZ28gKGxvZ28td2hpdGUucG5nKVxyXG4gICAgICAgIHRoaXMubG9nbyA9IExvYWRlcl9sb2dvO1xyXG4gICAgICAgIHRoaXMubG9nb1dpZHRoID0gNDY4O1xyXG4gICAgICAgIHRoaXMubG9nb0hlaWdodCA9IDExODtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGNvbG9yIG9mIHRoZSBsb2FkaW5nIGJhciwgZGVmYXVsdCBpcyBbW0NvbG9yLldoaXRlXV1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvYWRpbmdCYXJDb2xvciA9IENvbG9yLldoaXRlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgbG9hZGVyIGFzIGEgaGV4IHN0cmluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gJyMxNzZCQUEnO1xyXG4gICAgICAgIHRoaXMuc3VwcHJlc3NQbGF5QnV0dG9uID0gZmFsc2U7XHJcbiAgICAgICAgLyoqIExvYWRzIHRoZSBjc3MgZnJvbSBMb2FkZXIuY3NzICovXHJcbiAgICAgICAgdGhpcy5fcGxheUJ1dHRvblN0eWxlcyA9IExvYWRlcl8wLyogZGVmYXVsdC50b1N0cmluZyAqLy5aLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0L3NldCBwbGF5IGJ1dHRvbiB0ZXh0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wbGF5QnV0dG9uVGV4dCA9ICdQbGF5IGdhbWUnO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybiBhIGh0bWwgYnV0dG9uIGVsZW1lbnQgZm9yIGV4Y2FsaWJ1ciB0byB1c2UgYXMgYSBwbGF5IGJ1dHRvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhcnRCdXR0b25GYWN0b3J5ID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBsZXQgYnV0dG9uRWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdleGNhbGlidXItcGxheScpO1xyXG4gICAgICAgICAgICBpZiAoIWJ1dHRvbkVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGJ1dHRvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBidXR0b25FbGVtZW50LmlkID0gJ2V4Y2FsaWJ1ci1wbGF5JztcclxuICAgICAgICAgICAgYnV0dG9uRWxlbWVudC50ZXh0Q29udGVudCA9IHRoaXMucGxheUJ1dHRvblRleHQ7XHJcbiAgICAgICAgICAgIGJ1dHRvbkVsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkVsZW1lbnQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAobG9hZGFibGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUmVzb3VyY2VzKGxvYWRhYmxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IF9pbWFnZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2ltYWdlRWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgdGhpcy5faW1hZ2VFbGVtZW50LnNyYyA9IHRoaXMubG9nbztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlRWxlbWVudDtcclxuICAgIH1cclxuICAgIGdldCBwbGF5QnV0dG9uUm9vdEVsZW1lbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudDtcclxuICAgIH1cclxuICAgIGdldCBwbGF5QnV0dG9uRWxlbWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGxheUJ1dHRvbkVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICBnZXQgX3BsYXlCdXR0b24oKSB7XHJcbiAgICAgICAgY29uc3QgZXhpc3RpbmdSb290ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4Y2FsaWJ1ci1wbGF5LXJvb3QnKTtcclxuICAgICAgICBpZiAoZXhpc3RpbmdSb290KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudCA9IGV4aXN0aW5nUm9vdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudC5pZCA9ICdleGNhbGlidXItcGxheS1yb290JztcclxuICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX3N0eWxlQmxvY2spIHtcclxuICAgICAgICAgICAgdGhpcy5fc3R5bGVCbG9jayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0eWxlQmxvY2sudGV4dENvbnRlbnQgPSB0aGlzLl9wbGF5QnV0dG9uU3R5bGVzO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuX3N0eWxlQmxvY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX3BsYXlCdXR0b25FbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25FbGVtZW50ID0gdGhpcy5zdGFydEJ1dHRvbkZhY3RvcnkoKTtcclxuICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuX3BsYXlCdXR0b25FbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlCdXR0b25FbGVtZW50O1xyXG4gICAgfVxyXG4gICAgd2lyZUVuZ2luZShlbmdpbmUpIHtcclxuICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLl9lbmdpbmUuY2FudmFzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHRoaXMuX2VuZ2luZS5jYW52YXMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSByZXNvdXJjZSB0byB0aGUgbG9hZGVyIHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBsb2FkYWJsZSAgUmVzb3VyY2UgdG8gYWRkXHJcbiAgICAgKi9cclxuICAgIGFkZFJlc291cmNlKGxvYWRhYmxlKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5faW5kZXgrKztcclxuICAgICAgICB0aGlzLl9yZXNvdXJjZUxpc3QucHVzaChsb2FkYWJsZSk7XHJcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NDb3VudHNba2V5XSA9IDA7XHJcbiAgICAgICAgdGhpcy5fdG90YWxDb3VudHNba2V5XSA9IDE7XHJcbiAgICAgICAgdGhpcy5fcmVzb3VyY2VDb3VudCsrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYSBsaXN0IG9mIHJlc291cmNlcyB0byB0aGUgbG9hZGVyIHRvIGxvYWRcclxuICAgICAqIEBwYXJhbSBsb2FkYWJsZXMgIFRoZSBsaXN0IG9mIHJlc291cmNlcyB0byBsb2FkXHJcbiAgICAgKi9cclxuICAgIGFkZFJlc291cmNlcyhsb2FkYWJsZXMpIHtcclxuICAgICAgICBsZXQgaSA9IDA7XHJcbiAgICAgICAgY29uc3QgbGVuID0gbG9hZGFibGVzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGk7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFJlc291cmNlKGxvYWRhYmxlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGxvYWRlciBoYXMgY29tcGxldGVseSBsb2FkZWQgYWxsIHJlc291cmNlc1xyXG4gICAgICovXHJcbiAgICBpc0xvYWRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbnVtTG9hZGVkID09PSB0aGlzLl9yZXNvdXJjZUNvdW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTaG93cyB0aGUgcGxheSBidXR0b24gYW5kIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBjbGlja2VkXHJcbiAgICAgKi9cclxuICAgIHNob3dQbGF5QnV0dG9uKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAodGhpcy5zdXBwcmVzc1BsYXlCdXR0b24pIHtcclxuICAgICAgICAgICAgdGhpcy5oaWRlUGxheUJ1dHRvbigpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCByZXNpemVIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9zaXRpb25QbGF5QnV0dG9uKCk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLl9lbmdpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5icm93c2VyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUuYnJvd3Nlci53aW5kb3cub24oJ3Jlc2l6ZScsIHJlc2l6ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25TaG93biA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZ0LmtleSA9PT0gJ0VudGVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b24uY2xpY2soKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRCdXR0b25IYW5kbGVyID0gKGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugd2FudCB0byBzdG9wIHByb3BvZ2F0aW9uIHRvIGtlZXAgYnViYmxpbmcgdG8gdGhlIGVuZ2luZSBwb2ludGVyIGhhbmRsZXJzXHJcbiAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBIaWRlIEJ1dHRvbiBhZnRlciBjbGlja1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBsYXlCdXR0b24oKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5fZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYnJvd3Nlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmdpbmUuYnJvd3Nlci53aW5kb3cub2ZmKCdyZXNpemUnLCByZXNpemVIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdGFydEJ1dHRvbkhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHN0YXJ0QnV0dG9uSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHN0YXJ0QnV0dG9uSGFuZGxlcik7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBoaWRlUGxheUJ1dHRvbigpIHtcclxuICAgICAgICB0aGlzLl9wbGF5QnV0dG9uU2hvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wbGF5QnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFuIHVwIGdlbmVyYXRlZCBlbGVtZW50cyBmb3IgdGhlIGxvYWRlclxyXG4gICAgICovXHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQucGFyZW50RWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5fcGxheUJ1dHRvbkVsZW1lbnQpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudCk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQodGhpcy5fc3R5bGVCbG9jayk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25FbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fc3R5bGVCbG9jayA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIG92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJlZ2luIGxvYWRpbmcgYWxsIG9mIHRoZSBzdXBwbGllZCByZXNvdXJjZXMsIHJldHVybmluZyBhIHByb21pc2VcclxuICAgICAqIHRoYXQgcmVzb2x2ZXMgd2hlbiBsb2FkaW5nIG9mIGFsbCBpcyBjb21wbGV0ZVxyXG4gICAgICovXHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIHJldHVybiBMb2FkZXJfYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwodGhpcy5fcmVzb3VyY2VMaXN0Lm1hcCgocikgPT4gci5sb2FkKCkuZmluYWxseSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIHByb2dyZXNzXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9udW1Mb2FkZWQrKztcclxuICAgICAgICAgICAgfSkpKTtcclxuICAgICAgICAgICAgLy8gc2hvcnQgZGVsYXkgaW4gc2hvd2luZyB0aGUgYnV0dG9uIGZvciBhZXN0aGV0aWNzXHJcbiAgICAgICAgICAgIHlpZWxkIGRlbGF5KDIwMCk7XHJcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuc2hvd1BsYXlCdXR0b24oKTtcclxuICAgICAgICAgICAgLy8gVW5sb2NrIGJyb3dzZXIgQXVkaW9Db250ZXh0IGluIGFmdGVyIHVzZXIgZ2VzdHVyZVxyXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvaXNzdWVzLzI2MlxyXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvaXNzdWVzLzEwMzFcclxuICAgICAgICAgICAgeWllbGQgV2ViQXVkaW8udW5sb2NrKCk7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5kYXRhID0gdGhpcy5fcmVzb3VyY2VMaXN0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG1hcmtSZXNvdXJjZUNvbXBsZXRlKCkge1xyXG4gICAgICAgIHRoaXMuX251bUxvYWRlZCsrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwcm9nZXNzIG9mIHRoZSBsb2FkZXIgYXMgYSBudW1iZXIgYmV0d2VlbiBbMCwgMV0gaW5jbHVzaXZlLlxyXG4gICAgICovXHJcbiAgICBnZXQgcHJvZ3Jlc3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc291cmNlQ291bnQgPiAwID8gY2xhbXAodGhpcy5fbnVtTG9hZGVkLCAwLCB0aGlzLl9yZXNvdXJjZUNvdW50KSAvIHRoaXMuX3Jlc291cmNlQ291bnQgOiAxO1xyXG4gICAgfVxyXG4gICAgX3Bvc2l0aW9uUGxheUJ1dHRvbigpIHtcclxuICAgICAgICBjb25zdCBzY3JlZW5IZWlnaHQgPSB0aGlzLl9lbmdpbmUuc2NyZWVuLnZpZXdwb3J0LmhlaWdodDtcclxuICAgICAgICBjb25zdCBzY3JlZW5XaWR0aCA9IHRoaXMuX2VuZ2luZS5zY3JlZW4udmlld3BvcnQud2lkdGg7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5fZW5naW5lLmNhbnZhcy5vZmZzZXRMZWZ0O1xyXG4gICAgICAgICAgICBjb25zdCB0b3AgPSB0aGlzLl9lbmdpbmUuY2FudmFzLm9mZnNldFRvcDtcclxuICAgICAgICAgICAgY29uc3QgYnV0dG9uV2lkdGggPSB0aGlzLl9wbGF5QnV0dG9uLmNsaWVudFdpZHRoO1xyXG4gICAgICAgICAgICBjb25zdCBidXR0b25IZWlnaHQgPSB0aGlzLl9wbGF5QnV0dG9uLmNsaWVudEhlaWdodDtcclxuICAgICAgICAgICAgaWYgKHRoaXMucGxheUJ1dHRvblBvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQuc3R5bGUubGVmdCA9IGAke3RoaXMucGxheUJ1dHRvblBvc2l0aW9uLnh9cHhgO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50LnN0eWxlLnRvcCA9IGAke3RoaXMucGxheUJ1dHRvblBvc2l0aW9uLnl9cHhgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50LnN0eWxlLmxlZnQgPSBgJHtsZWZ0ICsgc2NyZWVuV2lkdGggLyAyIC0gYnV0dG9uV2lkdGggLyAyfXB4YDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudC5zdHlsZS50b3AgPSBgJHt0b3AgKyBzY3JlZW5IZWlnaHQgLyAyIC0gYnV0dG9uSGVpZ2h0IC8gMiArIDEwMH1weGA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvYWRlciBkcmF3IGZ1bmN0aW9uLiBEcmF3cyB0aGUgZGVmYXVsdCBFeGNhbGlidXIgbG9hZGluZyBzY3JlZW4uXHJcbiAgICAgKiBPdmVycmlkZSBgbG9nb2AsIGBsb2dvV2lkdGhgLCBgbG9nb0hlaWdodGAgYW5kIGBiYWNrZ3JvdW5kQ29sb3JgIHByb3BlcnRpZXNcclxuICAgICAqIHRvIGN1c3RvbWl6ZSB0aGUgZHJhd2luZywgb3IganVzdCBvdmVycmlkZSBlbnRpcmUgbWV0aG9kLlxyXG4gICAgICovXHJcbiAgICBkcmF3KGN0eCkge1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc0hlaWdodCA9IHRoaXMuX2VuZ2luZS5jYW52YXNIZWlnaHQgLyB0aGlzLl9lbmdpbmUucGl4ZWxSYXRpbztcclxuICAgICAgICBjb25zdCBjYW52YXNXaWR0aCA9IHRoaXMuX2VuZ2luZS5jYW52YXNXaWR0aCAvIHRoaXMuX2VuZ2luZS5waXhlbFJhdGlvO1xyXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uUGxheUJ1dHRvbigpO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XHJcbiAgICAgICAgbGV0IGxvZ29ZID0gY2FudmFzSGVpZ2h0IC8gMjtcclxuICAgICAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKHRoaXMubG9nb1dpZHRoLCBjYW52YXNXaWR0aCAqIDAuNzUpO1xyXG4gICAgICAgIGxldCBsb2dvWCA9IGNhbnZhc1dpZHRoIC8gMiAtIHdpZHRoIC8gMjtcclxuICAgICAgICBpZiAodGhpcy5sb2dvUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgbG9nb1ggPSB0aGlzLmxvZ29Qb3NpdGlvbi54O1xyXG4gICAgICAgICAgICBsb2dvWSA9IHRoaXMubG9nb1Bvc2l0aW9uLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGltYWdlSGVpZ2h0ID0gTWF0aC5mbG9vcih3aWR0aCAqICh0aGlzLmxvZ29IZWlnaHQgLyB0aGlzLmxvZ29XaWR0aCkpOyAvLyBPRyBoZWlnaHQvd2lkdGggZmFjdG9yXHJcbiAgICAgICAgY29uc3Qgb2xkQW50aWFsaWFzID0gdGhpcy5fZW5naW5lLmdldEFudGlhbGlhc2luZygpO1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZS5zZXRBbnRpYWxpYXNpbmcodHJ1ZSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxvZ29Qb3NpdGlvbikge1xyXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlLCAwLCAwLCB0aGlzLmxvZ29XaWR0aCwgdGhpcy5sb2dvSGVpZ2h0LCBsb2dvWCwgbG9nb1kgLSBpbWFnZUhlaWdodCAtIDIwLCB3aWR0aCwgaW1hZ2VIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLl9pbWFnZSwgMCwgMCwgdGhpcy5sb2dvV2lkdGgsIHRoaXMubG9nb0hlaWdodCwgbG9nb1gsIGxvZ29ZLCB3aWR0aCwgaW1hZ2VIZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBsb2FkaW5nIGJveFxyXG4gICAgICAgIGlmICghdGhpcy5zdXBwcmVzc1BsYXlCdXR0b24gJiYgdGhpcy5fcGxheUJ1dHRvblNob3duKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5zZXRBbnRpYWxpYXNpbmcob2xkQW50aWFsaWFzKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbG9hZGluZ1ggPSBsb2dvWDtcclxuICAgICAgICBsZXQgbG9hZGluZ1kgPSBsb2dvWTtcclxuICAgICAgICBpZiAodGhpcy5sb2FkaW5nQmFyUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgbG9hZGluZ1ggPSB0aGlzLmxvYWRpbmdCYXJQb3NpdGlvbi54O1xyXG4gICAgICAgICAgICBsb2FkaW5nWSA9IHRoaXMubG9hZGluZ0JhclBvc2l0aW9uLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xyXG4gICAgICAgIHJvdW5kUmVjdChjdHgsIGxvYWRpbmdYLCBsb2FkaW5nWSwgd2lkdGgsIDIwLCAxMCwgdGhpcy5sb2FkaW5nQmFyQ29sb3IpO1xyXG4gICAgICAgIGNvbnN0IHByb2dyZXNzID0gd2lkdGggKiB0aGlzLnByb2dyZXNzO1xyXG4gICAgICAgIGNvbnN0IG1hcmdpbiA9IDU7XHJcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NXaWR0aCA9IHByb2dyZXNzIC0gbWFyZ2luICogMjtcclxuICAgICAgICBjb25zdCBoZWlnaHQgPSAyMCAtIG1hcmdpbiAqIDI7XHJcbiAgICAgICAgcm91bmRSZWN0KGN0eCwgbG9hZGluZ1ggKyBtYXJnaW4sIGxvYWRpbmdZICsgbWFyZ2luLCBwcm9ncmVzc1dpZHRoID4gMTAgPyBwcm9ncmVzc1dpZHRoIDogMTAsIGhlaWdodCwgNSwgbnVsbCwgdGhpcy5sb2FkaW5nQmFyQ29sb3IpO1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZS5zZXRBbnRpYWxpYXNpbmcob2xkQW50aWFsaWFzKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvRGV0ZWN0b3IudHNcblxyXG4vKipcclxuICogVGhpcyBpcyB0aGUgbGlzdCBvZiBmZWF0dXJlcyB0aGF0IHdpbGwgYmUgdXNlZCB0byBsb2cgdGhlIHN1cHBvcnRlZFxyXG4gKiBmZWF0dXJlcyB0byB0aGUgY29uc29sZSB3aGVuIERldGVjdG9yLmxvZ0Jyb3dzZXJGZWF0dXJlcygpIGlzIGNhbGxlZC5cclxuICovXHJcbmNvbnN0IFJFUE9SVEVEX0ZFQVRVUkVTID0ge1xyXG4gICAgd2ViZ2w6ICdXZWJHTCcsXHJcbiAgICB3ZWJhdWRpbzogJ1dlYkF1ZGlvJyxcclxuICAgIGdhbWVwYWRhcGk6ICdHYW1lcGFkIEFQSSdcclxufTtcclxuLyoqXHJcbiAqIEV4Y2FsaWJ1ciBpbnRlcm5hbCBmZWF0dXJlIGRldGVjdGlvbiBoZWxwZXIgY2xhc3NcclxuICovXHJcbmNsYXNzIERldGVjdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZhaWxlZFRlc3RzID0gW107XHJcbiAgICAgICAgLy8gY3JpdGljYWwgYnJvd3NlciBmZWF0dXJlcyByZXF1aXJlZCBmb3IgZXggdG8gcnVuXHJcbiAgICAgICAgdGhpcy5fY3JpdGljYWxUZXN0cyA9IHtcclxuICAgICAgICAgICAgLy8gVGVzdCBjYW52YXMvMmQgY29udGV4dCBzdXBwb3J0XHJcbiAgICAgICAgICAgIGNhbnZhc1N1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIShlbGVtLmdldENvbnRleHQgJiYgZWxlbS5nZXRDb250ZXh0KCcyZCcpKTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gVGVzdCBhcnJheSBidWZmZXIgc3VwcG9ydCBleCB1c2VzIGZvciBkb3dubG9hZGluZyBiaW5hcnkgZGF0YVxyXG4gICAgICAgICAgICBhcnJheUJ1ZmZlclN1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xyXG4gICAgICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsICcvJyk7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJztcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gVGVzdCBkYXRhIHVybHMgZXggdXNlcyBmb3Igc3ByaXRlc1xyXG4gICAgICAgICAgICBkYXRhVXJsU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykuaW5kZXhPZignZGF0YTppbWFnZS9wbmcnKSA9PT0gMDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgLy8gVGVzdCBvYmplY3QgdXJsIHN1cHBvcnQgZm9yIGxvYWRpbmdcclxuICAgICAgICAgICAgb2JqZWN0VXJsU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICdVUkwnIGluIHdpbmRvdyAmJiAncmV2b2tlT2JqZWN0VVJMJyBpbiBVUkwgJiYgJ2NyZWF0ZU9iamVjdFVSTCcgaW4gVVJMO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBSR0JBIHN1cHBvcnQgZm9yIGNvbG9yc1xyXG4gICAgICAgICAgICByZ2JhU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJykuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICBzdHlsZS5jc3NUZXh0ID0gJ2JhY2tncm91bmQtY29sb3I6cmdiYSgxNTAsMjU1LDE1MCwuNSknO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICgnJyArIHN0eWxlLmJhY2tncm91bmRDb2xvcikuaW5kZXhPZigncmdiYScpID4gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHdhcm5pbmdzIGV4Y2FsaWJ1ciBwZXJmb3JtYW5jZSB3aWxsIGJlIGRlZ3JhZGVkXHJcbiAgICAgICAgdGhpcy5fd2FybmluZ1Rlc3QgPSB7XHJcbiAgICAgICAgICAgIHdlYkF1ZGlvU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHdpbmRvdy5BdWRpb0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1vekF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5tc0F1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5vQXVkaW9Db250ZXh0KTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgd2ViZ2xTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISEoZWxlbS5nZXRDb250ZXh0ICYmIGVsZW0uZ2V0Q29udGV4dCgnd2ViZ2wnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gdGhpcy5fbG9hZEJyb3dzZXJGZWF0dXJlcygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbWFwIG9mIGN1cnJlbnRseSBzdXBwb3J0ZWQgYnJvd3NlciBmZWF0dXJlcy4gVGhpcyBtZXRob2RcclxuICAgICAqIHRyZWF0cyB0aGUgZmVhdHVyZXMgYXMgYSBzaW5nbGV0b24gYW5kIHdpbGwgb25seSBjYWxjdWxhdGUgZmVhdHVyZVxyXG4gICAgICogc3VwcG9ydCBpZiBpdCBoYXMgbm90IHByZXZpb3VzbHkgYmVlbiBkb25lLlxyXG4gICAgICovXHJcbiAgICBnZXRCcm93c2VyRmVhdHVyZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ZlYXR1cmVzID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZlYXR1cmVzID0gdGhpcy5fbG9hZEJyb3dzZXJGZWF0dXJlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZmVhdHVyZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlcG9ydCBvbiBub24tY3JpdGljYWwgYnJvd3NlciBzdXBwb3J0IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXHJcbiAgICAgKiBVc2UgbmF0aXZlIGJyb3dzZXIgY29uc29sZSBjb2xvcnMgZm9yIHZpc2liaWxpdHkuXHJcbiAgICAgKi9cclxuICAgIGxvZ0Jyb3dzZXJGZWF0dXJlcygpIHtcclxuICAgICAgICBsZXQgbXNnID0gJyVjU1VQUE9SVEVEIEJST1dTRVIgRkVBVFVSRVNcXG49PT09PT09PT09PT09PT09PT09PT09PT09PSVjXFxuJztcclxuICAgICAgICBjb25zdCBhcmdzID0gWydmb250LXdlaWdodDogYm9sZDsgY29sb3I6IG5hdnknLCAnZm9udC13ZWlnaHQ6IG5vcm1hbDsgY29sb3I6IGluaGVyaXQnXTtcclxuICAgICAgICBjb25zdCBzdXBwb3J0ZWQgPSB0aGlzLmdldEJyb3dzZXJGZWF0dXJlcygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgZmVhdHVyZSBvZiBPYmplY3Qua2V5cyhSRVBPUlRFRF9GRUFUVVJFUykpIHtcclxuICAgICAgICAgICAgaWYgKHN1cHBvcnRlZFtmZWF0dXJlXSkge1xyXG4gICAgICAgICAgICAgICAgbXNnICs9ICcoJWNcXHUyNzEzJWMpJzsgLy8gKOKckylcclxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiBncmVlbicpO1xyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKCdmb250LXdlaWdodDogbm9ybWFsOyBjb2xvcjogaW5oZXJpdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbXNnICs9ICcoJWNcXHUyNzE3JWMpJzsgLy8gKOKclylcclxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnZm9udC13ZWlnaHQ6IGJvbGQ7IGNvbG9yOiByZWQnKTtcclxuICAgICAgICAgICAgICAgIGFyZ3MucHVzaCgnZm9udC13ZWlnaHQ6IG5vcm1hbDsgY29sb3I6IGluaGVyaXQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBtc2cgKz0gJyAnICsgUkVQT1JURURfRkVBVFVSRVNbZmVhdHVyZV0gKyAnXFxuJztcclxuICAgICAgICB9XHJcbiAgICAgICAgYXJncy51bnNoaWZ0KG1zZyk7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXhlY3V0ZXMgc2V2ZXJhbCBJSUZFJ3MgdG8gZ2V0IGEgY29uc3RhbnQgcmVmZXJlbmNlIHRvIHN1cHBvcnRlZFxyXG4gICAgICogZmVhdHVyZXMgd2l0aGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBjb250ZXh0LlxyXG4gICAgICovXHJcbiAgICBfbG9hZEJyb3dzZXJGZWF0dXJlcygpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIGNhbnZhcyBzdXBwb3J0XHJcbiAgICAgICAgICAgIGNhbnZhczogKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcml0aWNhbFRlc3RzLmNhbnZhc1N1cHBvcnQoKTtcclxuICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayBhcnJheWJ1ZmZlciBzdXBwb3J0XHJcbiAgICAgICAgICAgIGFycmF5YnVmZmVyOiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyaXRpY2FsVGVzdHMuYXJyYXlCdWZmZXJTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgZGF0YXVybCBzdXBwb3J0XHJcbiAgICAgICAgICAgIGRhdGF1cmw6ICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JpdGljYWxUZXN0cy5kYXRhVXJsU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIG9iamVjdHVybCBzdXBwb3J0XHJcbiAgICAgICAgICAgIG9iamVjdHVybDogKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcml0aWNhbFRlc3RzLm9iamVjdFVybFN1cHBvcnQoKTtcclxuICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayByZ2JhIHN1cHBvcnRcclxuICAgICAgICAgICAgcmdiYTogKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcml0aWNhbFRlc3RzLnJnYmFTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgd2ViYXVkaW8gc3VwcG9ydFxyXG4gICAgICAgICAgICB3ZWJhdWRpbzogKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93YXJuaW5nVGVzdC53ZWJBdWRpb1N1cHBvcnQoKTtcclxuICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayB3ZWJnbCBzdXBwb3J0XHJcbiAgICAgICAgICAgIHdlYmdsOiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dhcm5pbmdUZXN0LndlYmdsU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIGdhbWVwYWRhcGkgc3VwcG9ydFxyXG4gICAgICAgICAgICBnYW1lcGFkYXBpOiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbmF2aWdhdG9yLmdldEdhbWVwYWRzO1xyXG4gICAgICAgICAgICB9KSgpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHRlc3QoKSB7XHJcbiAgICAgICAgLy8gQ3JpdGljYWwgdGVzdCB3aWxsIGZvciBleCBub3QgdG8gcnVuXHJcbiAgICAgICAgbGV0IGZhaWxlZENyaXRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgZm9yIChjb25zdCB0ZXN0IGluIHRoaXMuX2NyaXRpY2FsVGVzdHMpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9jcml0aWNhbFRlc3RzW3Rlc3RdLmNhbGwodGhpcykpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZmFpbGVkVGVzdHMucHVzaCh0ZXN0KTtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDcml0aWNhbCBicm93c2VyIGZlYXR1cmUgbWlzc2luZywgRXhjYWxpYnVyIHJlcXVpcmVzOicsIHRlc3QpO1xyXG4gICAgICAgICAgICAgICAgZmFpbGVkQ3JpdGljYWwgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmYWlsZWRDcml0aWNhbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdhcm5pbmcgdGVzdHMgZG8gbm90IGZvciBleCB0byByZXR1cm4gZmFsc2UgdG8gY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIGZvciAoY29uc3Qgd2FybmluZyBpbiB0aGlzLl93YXJuaW5nVGVzdCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3dhcm5pbmdUZXN0W3dhcm5pbmddKCkpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ1dhcm5pbmcgYnJvd3NlciBmZWF0dXJlIG1pc3NpbmcsIEV4Y2FsaWJ1ciB3aWxsIGhhdmUgcmVkdWNlZCBwZXJmb3JtYW5jZTonLCB3YXJuaW5nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaXNpb25UeXBlLnRzXG4vKipcclxuICogQW4gZW51bSB0aGF0IGRlc2NyaWJlcyB0aGUgdHlwZXMgb2YgY29sbGlzaW9ucyBib2RpZXMgY2FuIHBhcnRpY2lwYXRlIGluXHJcbiAqL1xyXG52YXIgQ29sbGlzaW9uVHlwZTtcclxuKGZ1bmN0aW9uIChDb2xsaXNpb25UeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEJvZGllcyB3aXRoIHRoZSBgUHJldmVudENvbGxpc2lvbmAgc2V0dGluZyBkbyBub3QgcGFydGljaXBhdGUgaW4gYW55XHJcbiAgICAgKiBjb2xsaXNpb25zIGFuZCBkbyBub3QgcmFpc2UgY29sbGlzaW9uIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgQ29sbGlzaW9uVHlwZVtcIlByZXZlbnRDb2xsaXNpb25cIl0gPSBcIlByZXZlbnRDb2xsaXNpb25cIjtcclxuICAgIC8qKlxyXG4gICAgICogQm9kaWVzIHdpdGggdGhlIGBQYXNzaXZlYCBzZXR0aW5nIG9ubHkgcmFpc2UgY29sbGlzaW9uIGV2ZW50cywgYnV0IGFyZSBub3RcclxuICAgICAqIGluZmx1ZW5jZWQgb3IgbW92ZWQgYnkgb3RoZXIgYm9kaWVzIGFuZCBkbyBub3QgaW5mbHVlbmNlIG9yIG1vdmUgb3RoZXIgYm9kaWVzLlxyXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIHVzZSBpbiB0cmlnZ2VyIHR5cGUgYmVoYXZpb3IuXHJcbiAgICAgKi9cclxuICAgIENvbGxpc2lvblR5cGVbXCJQYXNzaXZlXCJdID0gXCJQYXNzaXZlXCI7XHJcbiAgICAvKipcclxuICAgICAqIEJvZGllcyB3aXRoIHRoZSBgQWN0aXZlYCBzZXR0aW5nIHJhaXNlIGNvbGxpc2lvbiBldmVudHMgYW5kIHBhcnRpY2lwYXRlXHJcbiAgICAgKiBpbiBjb2xsaXNpb25zIHdpdGggb3RoZXIgYm9kaWVzIGFuZCB3aWxsIGJlIHB1c2ggb3IgbW92ZWQgYnkgYm9kaWVzIHNoYXJpbmdcclxuICAgICAqIHRoZSBgQWN0aXZlYCBvciBgRml4ZWRgIHNldHRpbmcuXHJcbiAgICAgKi9cclxuICAgIENvbGxpc2lvblR5cGVbXCJBY3RpdmVcIl0gPSBcIkFjdGl2ZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCb2RpZXMgd2l0aCB0aGUgYEZpeGVkYCBzZXR0aW5nIHJhaXNlIGNvbGxpc2lvbiBldmVudHMgYW5kIHBhcnRpY2lwYXRlIGluXHJcbiAgICAgKiBjb2xsaXNpb25zIHdpdGggb3RoZXIgYm9kaWVzLiBBY3RvcnMgd2l0aCB0aGUgYEZpeGVkYCBzZXR0aW5nIHdpbGwgbm90IGJlXHJcbiAgICAgKiBwdXNoZWQgb3IgbW92ZWQgYnkgb3RoZXIgYm9kaWVzIHNoYXJpbmcgdGhlIGBGaXhlZGAuIFRoaW5rIG9mIEZpeGVkXHJcbiAgICAgKiBib2RpZXMgYXMgXCJpbW1vdmFibGUvdW5zdG9wcGFibGVcIiBvYmplY3RzLiBJZiB0d28gYEZpeGVkYCBib2RpZXMgbWVldCB0aGV5IHdpbGxcclxuICAgICAqIG5vdCBiZSBwdXNoZWQgb3IgbW92ZWQgYnkgZWFjaCBvdGhlciwgdGhleSB3aWxsIG5vdCBpbnRlcmFjdCBleGNlcHQgdG8gdGhyb3dcclxuICAgICAqIGNvbGxpc2lvbiBldmVudHMuXHJcbiAgICAgKi9cclxuICAgIENvbGxpc2lvblR5cGVbXCJGaXhlZFwiXSA9IFwiRml4ZWRcIjtcclxufSkoQ29sbGlzaW9uVHlwZSB8fCAoQ29sbGlzaW9uVHlwZSA9IHt9KSk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL1BoeXNpY3MudHNcbnZhciBQaHlzaWNzX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBQb3NzaWJsZSBjb2xsaXNpb24gcmVzb2x1dGlvbiBzdHJhdGVnaWVzXHJcbiAqXHJcbiAqIFRoZSBkZWZhdWx0IGlzIFtbQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkFyY2FkZV1dIHdoaWNoIHBlcmZvcm1zIHNpbXBsZSBheGlzIGFsaWduZWQgYXJjYWRlIHN0eWxlIHBoeXNpY3MuIFRoaXMgaXMgdXNlZnVsIGZvciB0aGluZ3NcclxuICogbGlrZSBwbGF0Zm9ybWVycyBvciB0b3AgZG93biBnYW1lcy5cclxuICpcclxuICogTW9yZSBhZHZhbmNlZCByaWdpZCBib2R5IHBoeXNpY3MgYXJlIGVuYWJsZWQgYnkgc2V0dGluZyBbW0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SZWFsaXN0aWNdXSB3aGljaCBhbGxvd3MgZm9yIGNvbXBsaWNhdGVkXHJcbiAqIHNpbXVsYXRlZCBwaHlzaWNhbCBpbnRlcmFjdGlvbnMuXHJcbiAqL1xyXG52YXIgQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5O1xyXG4oZnVuY3Rpb24gKENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSkge1xyXG4gICAgQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5W1wiQXJjYWRlXCJdID0gXCJhcmNhZGVcIjtcclxuICAgIENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneVtcIlJlYWxpc3RpY1wiXSA9IFwicmVhbGlzdGljXCI7XHJcbn0pKENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSB8fCAoQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5ID0ge30pKTtcclxuLyoqXHJcbiAqIFBvc3NpYmxlIGJyb2FkcGhhc2UgY29sbGlzaW9uIHBhaXIgaWRlbnRpZmljYXRpb24gc3RyYXRlZ2llc1xyXG4gKlxyXG4gKiBUaGUgZGVmYXVsdCBzdHJhdGVneSBpcyBbW0Jyb2FkcGhhc2VTdHJhdGVneS5EeW5hbWljQUFCQlRyZWVdXSB3aGljaCB1c2VzIGEgYmluYXJ5IHRyZWUgb2YgYXhpcy1hbGlnbmVkIGJvdW5kaW5nIGJveGVzIHRvIGlkZW50aWZ5XHJcbiAqIHBvdGVudGlhbCBjb2xsaXNpb24gcGFpcnMgd2hpY2ggaXMgTyhubG9nKG4pKSBmYXN0ZXIuXHJcbiAqL1xyXG52YXIgQnJvYWRwaGFzZVN0cmF0ZWd5O1xyXG4oZnVuY3Rpb24gKEJyb2FkcGhhc2VTdHJhdGVneSkge1xyXG4gICAgQnJvYWRwaGFzZVN0cmF0ZWd5W0Jyb2FkcGhhc2VTdHJhdGVneVtcIkR5bmFtaWNBQUJCVHJlZVwiXSA9IDBdID0gXCJEeW5hbWljQUFCQlRyZWVcIjtcclxufSkoQnJvYWRwaGFzZVN0cmF0ZWd5IHx8IChCcm9hZHBoYXNlU3RyYXRlZ3kgPSB7fSkpO1xyXG4vKipcclxuICogUG9zc2libGUgbnVtZXJpY2FsIGludGVncmF0b3JzIGZvciBwb3NpdGlvbiBhbmQgdmVsb2NpdHlcclxuICovXHJcbnZhciBJbnRlZ3JhdG9yO1xyXG4oZnVuY3Rpb24gKEludGVncmF0b3IpIHtcclxuICAgIEludGVncmF0b3JbSW50ZWdyYXRvcltcIkV1bGVyXCJdID0gMF0gPSBcIkV1bGVyXCI7XHJcbn0pKEludGVncmF0b3IgfHwgKEludGVncmF0b3IgPSB7fSkpO1xyXG4vKipcclxuICogVGhlIFtbUGh5c2ljc11dIG9iamVjdCBpcyB0aGUgZ2xvYmFsIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBhbGwgRXhjYWxpYnVyIHBoeXNpY3MuXHJcbiAqL1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5jbGFzcyBQaHlzaWNzIHtcclxuICAgIHN0YXRpYyBnZXQgZ3Jhdml0eSgpIHtcclxuICAgICAgICByZXR1cm4gUGh5c2ljcy5hY2M7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgc2V0IGdyYXZpdHkodikge1xyXG4gICAgICAgIFBoeXNpY3MuYWNjID0gdjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29uZmlndXJlcyBFeGNhbGlidXIgdG8gdXNlIFwiYXJjYWRlXCIgcGh5c2ljcy4gQXJjYWRlIHBoeXNpY3Mgd2hpY2ggcGVyZm9ybXMgc2ltcGxlIGF4aXMgYWxpZ25lZCBhcmNhZGUgc3R5bGUgcGh5c2ljcy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVzZUFyY2FkZVBoeXNpY3MoKSB7XHJcbiAgICAgICAgUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQXJjYWRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25maWd1cmVzIEV4Y2FsaWJ1ciB0byB1c2UgcmlnaWQgYm9keSBwaHlzaWNzLiBSaWdpZCBib2R5IHBoeXNpY3MgYWxsb3dzIGZvciBjb21wbGljYXRlZFxyXG4gICAgICogc2ltdWxhdGVkIHBoeXNpY2FsIGludGVyYWN0aW9ucy5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVzZVJlYWxpc3RpY1BoeXNpY3MoKSB7XHJcbiAgICAgICAgUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuUmVhbGlzdGljO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBkeW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbHllcigpIHtcclxuICAgICAgICByZXR1cm4gUGh5c2ljcy5keW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbGllcjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBzZXQgZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGx5ZXIodmFsdWUpIHtcclxuICAgICAgICBQaHlzaWNzLmR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBsaWVyID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdsb2JhbCBhY2NlbGVyYXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIGFsbCB2YW5pbGxhIGFjdG9ycyB0aGF0IGhhdmUgYSBbW0NvbGxpc2lvblR5cGUuQWN0aXZlfGFjdGl2ZV1dIGNvbGxpc2lvbiB0eXBlLlxyXG4gKiBHbG9iYWwgYWNjZWxlcmF0aW9uIHdvbid0IGVmZmVjdCBbW0xhYmVsfGxhYmVsc11dLCBbW1NjcmVlbkVsZW1lbnR8dWkgYWN0b3JzXV0sIG9yIFtbVHJpZ2dlcnx0cmlnZ2Vyc11dIGluIEV4Y2FsaWJ1ci5cclxuICpcclxuICogVGhpcyBpcyBhIGdyZWF0IHdheSB0byBnbG9iYWxseSBzaW11bGF0ZSBlZmZlY3RzIGxpa2UgZ3Jhdml0eS5cclxuICovXHJcblBoeXNpY3MuYWNjID0gbmV3IFZlY3RvcigwLCAwKTtcclxuLyoqXHJcbiAqIEdsb2JhbGx5IHN3aXRjaGVzIGFsbCBFeGNhbGlidXIgcGh5c2ljcyBiZWhhdmlvciBvbiBvciBvZmYuXHJcbiAqL1xyXG5QaHlzaWNzLmVuYWJsZWQgPSB0cnVlO1xyXG4vKipcclxuICogR2V0cyBvciBzZXRzIHRoZSBicm9hZHBoYXNlIHBhaXIgaWRlbnRpZmljYXRpb24gc3RyYXRlZ3kuXHJcbiAqXHJcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IGlzIFtbQnJvYWRwaGFzZVN0cmF0ZWd5LkR5bmFtaWNBQUJCVHJlZV1dIHdoaWNoIHVzZXMgYSBiaW5hcnkgdHJlZSBvZiBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94ZXMgdG8gaWRlbnRpZnlcclxuICogcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlycyB3aGljaCBpcyBPKG5sb2cobikpIGZhc3Rlci5cclxuICovXHJcblBoeXNpY3MuYnJvYWRwaGFzZVN0cmF0ZWd5ID0gQnJvYWRwaGFzZVN0cmF0ZWd5LkR5bmFtaWNBQUJCVHJlZTtcclxuLyoqXHJcbiAqIEdldHMgb3Igc2V0cyB0aGUgZ2xvYmFsIGNvbGxpc2lvbiByZXNvbHV0aW9uIHN0cmF0ZWd5IChuYXJyb3dwaGFzZSkuXHJcbiAqXHJcbiAqIFRoZSBkZWZhdWx0IGlzIFtbQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LkFyY2FkZV1dIHdoaWNoIHBlcmZvcm1zIHNpbXBsZSBheGlzIGFsaWduZWQgYXJjYWRlIHN0eWxlIHBoeXNpY3MuXHJcbiAqXHJcbiAqIE1vcmUgYWR2YW5jZWQgcmlnaWQgYm9keSBwaHlzaWNzIGFyZSBlbmFibGVkIGJ5IHNldHRpbmcgW1tDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuUmVhbGlzdGljXV0gd2hpY2ggYWxsb3dzIGZvciBjb21wbGljYXRlZFxyXG4gKiBzaW11bGF0ZWQgcGh5c2ljYWwgaW50ZXJhY3Rpb25zLlxyXG4gKi9cclxuUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQXJjYWRlO1xyXG4vKipcclxuICogVGhlIGRlZmF1bHQgbWFzcyB0byB1c2UgaWYgbm9uZSBpcyBzcGVjaWZpZWRcclxuICovXHJcblBoeXNpY3MuZGVmYXVsdE1hc3MgPSAxMDtcclxuLyoqXHJcbiAqIEdldHMgb3Igc2V0cyB0aGUgcG9zaXRpb24gYW5kIHZlbG9jaXR5IHBvc2l0aW9uYWwgaW50ZWdyYXRvciwgY3VycmVudGx5IG9ubHkgRXVsZXIgaXMgc3VwcG9ydGVkLlxyXG4gKi9cclxuUGh5c2ljcy5pbnRlZ3JhdG9yID0gSW50ZWdyYXRvci5FdWxlcjtcclxuLyoqXHJcbiAqIEZhY3RvciB0byBhZGQgdG8gdGhlIFJpZ2lkQm9keSBCb3VuZGluZ0JveCwgYm91bmRpbmcgYm94IChkaW1lbnNpb25zICs9IHZlbCAqIGR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBsaWVyKTtcclxuICovXHJcblBoeXNpY3MuZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGxpZXIgPSAyO1xyXG4vKipcclxuICogUGFkIFJpZ2lkQm9keSBCb3VuZGluZ0JveCBieSBhIGNvbnN0YW50IGFtb3VudFxyXG4gKi9cclxuUGh5c2ljcy5ib3VuZHNQYWRkaW5nID0gNTtcclxuLyoqXHJcbiAqIE51bWJlciBvZiBwb3NpdGlvbiBpdGVyYXRpb25zIChvdmVybGFwKSB0byBydW4gaW4gdGhlIHNvbHZlclxyXG4gKi9cclxuUGh5c2ljcy5wb3NpdGlvbkl0ZXJhdGlvbnMgPSAzO1xyXG4vKipcclxuICogTnVtYmVyIG9mIHZlbG9jaXR5IGl0ZXJhdGlvbiAocmVzcG9uc2UpIHRvIHJ1biBpbiB0aGUgc29sdmVyXHJcbiAqL1xyXG5QaHlzaWNzLnZlbG9jaXR5SXRlcmF0aW9ucyA9IDg7XHJcbi8qKlxyXG4gKiBBbW91bnQgb2Ygb3ZlcmxhcCB0byB0b2xlcmF0ZSBpbiBwaXhlbHNcclxuICovXHJcblBoeXNpY3Muc2xvcCA9IDE7XHJcbi8qKlxyXG4gKiBBbW91bnQgb2YgcG9zaXRpb25hbCBvdmVybGFwIGNvcnJlY3Rpb24gdG8gYXBwbHkgZWFjaCBwb3NpdGlvbiBpdGVyYXRpb24gb2YgdGhlIHNvbHZlclxyXG4gKiBPIC0gbWVhbmluZyBubyBjb3JyZWN0aW9uLCAxIC0gbWVhbmluZyBjb3JyZWN0IGFsbCBvdmVybGFwXHJcbiAqL1xyXG5QaHlzaWNzLnN0ZWVyaW5nRmFjdG9yID0gMC4yO1xyXG4vKipcclxuICogV2FybSBzdGFydCBzZXQgdG8gdHJ1ZSByZS11c2VzIGltcHVsc2VzIGZyb20gcHJldmlvdXMgZnJhbWVzIGJhY2sgaW4gdGhlIHNvbHZlclxyXG4gKi9cclxuUGh5c2ljcy53YXJtU3RhcnQgPSB0cnVlO1xyXG4vKipcclxuICogQnkgZGVmYXVsdCBib2RpZXMgZG8gbm90IHNsZWVwXHJcbiAqL1xyXG5QaHlzaWNzLmJvZGllc0NhblNsZWVwQnlEZWZhdWx0ID0gZmFsc2U7XHJcbi8qKlxyXG4gKiBTdXJmYWNlIGVwc2lsb24gaXMgdXNlZCB0byBoZWxwIGRlYWwgd2l0aCBzdXJmYWNlIHBlbmV0cmF0aW9uXHJcbiAqL1xyXG5QaHlzaWNzLnN1cmZhY2VFcHNpbG9uID0gMC4xO1xyXG5QaHlzaWNzLnNsZWVwRXBzaWxvbiA9IDAuMDc7XHJcblBoeXNpY3Mud2FrZVRocmVzaG9sZCA9IFBoeXNpY3Muc2xlZXBFcHNpbG9uICogMztcclxuUGh5c2ljcy5zbGVlcEJpYXMgPSAwLjk7XHJcbi8qKlxyXG4gKiBFbmFibGUgZmFzdCBtb3ZpbmcgYm9keSBjaGVja2luZywgdGhpcyBlbmFibGVzIGNoZWNraW5nIGZvciBjb2xsaXNpb24gcGFpcnMgdmlhIHJheWNhc3QgZm9yIGZhc3QgbW92aW5nIG9iamVjdHMgdG8gcHJldmVudFxyXG4gKiBib2RpZXMgZnJvbSB0dW5uZWxpbmcgdGhyb3VnaCBvbmUgYW5vdGhlci5cclxuICovXHJcblBoeXNpY3MuY2hlY2tGb3JGYXN0Qm9kaWVzID0gdHJ1ZTtcclxuLyoqXHJcbiAqIERpc2FibGUgbWluaW11bSBmYXN0IG1vdmluZyBib2R5IHJheWNhc3QsIGJ5IGRlZmF1bHQgaWYgZXguUGh5c2ljcy5jaGVja0ZvckZhc3RCb2RpZXMgPSB0cnVlIEV4Y2FsaWJ1ciB3aWxsIG9ubHkgY2hlY2sgaWYgdGhlXHJcbiAqIGJvZHkgaXMgbW92aW5nIGF0IGxlYXN0IGhhbGYgb2YgaXRzIG1pbmltdW0gZGltZW5zaW9uIGluIGFuIHVwZGF0ZS4gSWYgZXguUGh5c2ljcy5kaXNhYmxlTWluaW11bVNwZWVkRm9yRmFzdEJvZHkgaXMgc2V0IHRvIHRydWUsXHJcbiAqIEV4Y2FsaWJ1ciB3aWxsIGFsd2F5cyBwZXJmb3JtIHRoZSBmYXN0IGJvZHkgcmF5Y2FzdCByZWdhcmRsZXNzIG9mIHNwZWVkLlxyXG4gKi9cclxuUGh5c2ljcy5kaXNhYmxlTWluaW11bVNwZWVkRm9yRmFzdEJvZHkgPSBmYWxzZTtcclxuUGh5c2ljc19kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0FsaWFzIGZvciBpbmNvcnJlY3Qgc3BlbGxpbmcgdXNlZCBpbiBvbGRlciB2ZXJzaW9ucywgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI1LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ2R5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBsaWVyJ1xyXG4gICAgfSlcclxuXSwgUGh5c2ljcywgXCJkeW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbHllclwiLCBudWxsKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL3ZlY3Rvci12aWV3LnRzXG5cclxuY2xhc3MgVmVjdG9yVmlldyBleHRlbmRzIFZlY3RvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fZ2V0WCA9IG9wdGlvbnMuZ2V0WDtcclxuICAgICAgICB0aGlzLl9nZXRZID0gb3B0aW9ucy5nZXRZO1xyXG4gICAgICAgIHRoaXMuX3NldFggPSBvcHRpb25zLnNldFg7XHJcbiAgICAgICAgdGhpcy5fc2V0WSA9IG9wdGlvbnMuc2V0WTtcclxuICAgIH1cclxuICAgIGdldCB4KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5feCA9IHRoaXMuX2dldFgoKSk7XHJcbiAgICB9XHJcbiAgICBzZXQgeCh2YWwpIHtcclxuICAgICAgICB0aGlzLl9zZXRYKHZhbCk7XHJcbiAgICAgICAgdGhpcy5feCA9IHZhbDtcclxuICAgIH1cclxuICAgIGdldCB5KCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5feSA9IHRoaXMuX2dldFkoKSk7XHJcbiAgICB9XHJcbiAgICBzZXQgeSh2YWwpIHtcclxuICAgICAgICB0aGlzLl9zZXRZKHZhbCk7XHJcbiAgICAgICAgdGhpcy5feSA9IHZhbDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9Db21wb25lbnQudHNcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGlmIGEgY29tcG9uZW50IGltcGxlbWVudHMgY2xvbmVcclxuICogQHBhcmFtIHhcclxuICovXHJcbmZ1bmN0aW9uIGhhc0Nsb25lKHgpIHtcclxuICAgIHJldHVybiAhISh4ID09PSBudWxsIHx8IHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHguY2xvbmUpO1xyXG59XHJcbi8qKlxyXG4gKiBDb21wb25lbnRzIGFyZSBjb250YWluZXJzIGZvciBzdGF0ZSBpbiBFeGNhbGlidXIsIHRoZSBhcmUgbWVhbnQgdG8gY29udmV5IGNhcGFiaWxpdGllcyB0aGF0IGFuIEVudGl0eSBwb3Nlc3Nlc1xyXG4gKlxyXG4gKiBJbXBsZW1lbnRhdGlvbnMgb2YgQ29tcG9uZW50IG11c3QgaGF2ZSBhIHplcm8tYXJnIGNvbnN0cnVjdG9yIHRvIHN1cHBvcnQgZGVwZW5kZWNpZXNcclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjbGFzcyBNeUNvbXBvbmVudCBleHRlbmRzIGV4LkNvbXBvbmVudDwnbXknPiB7XHJcbiAqICAgcHVibGljIHJlYWRvbmx5IHR5cGUgPSAnbXknO1xyXG4gKiAgIC8vIHplcm8gYXJnIHN1cHBvcnQgcmVxdWlyZWQgaWYgeW91IHdhbnQgdG8gdXNlIGNvbXBvbmVudCBkZXBlbmRlbmNpZXNcclxuICogICBjb25zdHJ1Y3RvcihwdWJsaWMgb3B0aW9uYWxQb3M/OiBleC5WZWN0b3IpIHt9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5jbGFzcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBvd25pbmcgW1tFbnRpdHldXSwgaWYgYW55LCBvZiB0aGlzIGNvbXBvbmVudC4gTnVsbCBpZiBub3QgYWRkZWQgdG8gYW55IFtbRW50aXR5XV1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm93bmVyID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xvbmVzIGFueSBwcm9wZXJ0aWVzIG9uIHRoaXMgY29tcG9uZW50LCBpZiB0aGF0IHByb3BlcnR5IHZhbHVlIGhhcyBhIGBjbG9uZSgpYCBtZXRob2QgaXQgd2lsbCBiZSBjYWxsZWRcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgbmV3Q29tcG9uZW50ID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gdGhpcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gdGhpc1twcm9wXTtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNDbG9uZSh2YWwpICYmIHByb3AgIT09ICdvd25lcicgJiYgcHJvcCAhPT0gJ2Nsb25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgIG5ld0NvbXBvbmVudFtwcm9wXSA9IHZhbC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29tcG9uZW50W3Byb3BdID0gdmFsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdDb21wb25lbnQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRhZyBjb21wb25lbnRzIGFyZSBhIHdheSBvZiB0YWdnaW5nIGEgY29tcG9uZW50IHdpdGggbGFiZWwgYW5kIGEgc2ltcGxlIHZhbHVlXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlOlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IGlzT2Zmc2NyZWVuID0gbmV3IFRhZ0NvbXBvbmVudCgnb2Zmc2NyZWVuJyk7XHJcbiAqIGVudGl0eS5hZGRDb21wb25lbnQoaXNPZmZzY3JlZW4pO1xyXG4gKiBlbnRpdHkudGFncy5pbmNsdWRlc1xyXG4gKiBgYGBcclxuICovXHJcbmNsYXNzIFRhZ0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCB2YWx1ZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FbnRpdHlDb21wb25lbnRTeXN0ZW0vQ29tcG9uZW50cy9UcmFuc2Zvcm1Db21wb25lbnQudHNcblxyXG5cclxuXHJcblxyXG5jb25zdCBjcmVhdGVQb3NWaWV3ID0gKG1hdHJpeCkgPT4ge1xyXG4gICAgY29uc3Qgc291cmNlID0gbWF0cml4O1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3JWaWV3KHtcclxuICAgICAgICBzZXRYOiAoeCkgPT4ge1xyXG4gICAgICAgICAgICBzb3VyY2UuZGF0YVtNYXRyaXhMb2NhdGlvbnMuWF0gPSB4O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0WTogKHkpID0+IHtcclxuICAgICAgICAgICAgc291cmNlLmRhdGFbTWF0cml4TG9jYXRpb25zLlldID0geTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFg6ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5kYXRhW01hdHJpeExvY2F0aW9ucy5YXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFk6ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5kYXRhW01hdHJpeExvY2F0aW9ucy5ZXTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuY29uc3QgY3JlYXRlU2NhbGVWaWV3ID0gKG1hdHJpeCkgPT4ge1xyXG4gICAgY29uc3Qgc291cmNlID0gbWF0cml4O1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3JWaWV3KHtcclxuICAgICAgICBzZXRYOiAoeCkgPT4ge1xyXG4gICAgICAgICAgICBzb3VyY2Uuc2V0U2NhbGVYKHgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0WTogKHkpID0+IHtcclxuICAgICAgICAgICAgc291cmNlLnNldFNjYWxlWSh5KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFg6ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5nZXRTY2FsZVgoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGdldFk6ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5nZXRTY2FsZVkoKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufTtcclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBjb29yZGluYXRlIHBsYW5lIGZvciB0aGUgcG9zaXRpb24gMkQgdmVjdG9yIGluIHRoZSBbW1RyYW5zZm9ybUNvbXBvbmVudF1dXHJcbiAqL1xyXG52YXIgQ29vcmRQbGFuZTtcclxuKGZ1bmN0aW9uIChDb29yZFBsYW5lKSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3b3JsZCBjb29yZGluYXRlIHBsYW5lIChkZWZhdWx0KSByZXByZXNlbnRzIHdvcmxkIHNwYWNlLCBhbnkgZW50aXRpZXMgZHJhd24gd2l0aCB3b3JsZFxyXG4gICAgICogc3BhY2UgbW92ZSB3aGVuIHRoZSBjYW1lcmEgbW92ZXMuXHJcbiAgICAgKi9cclxuICAgIENvb3JkUGxhbmVbXCJXb3JsZFwiXSA9IFwid29ybGRcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNjcmVlbiBjb29yZGluYXRlIHBsYW5lIHJlcHJlc2VudHMgc2NyZWVuIHNwYWNlLCBlbnRpdGllcyBkcmF3biBpbiBzY3JlZW4gc3BhY2UgYXJlIHBpbm5lZFxyXG4gICAgICogdG8gc2NyZWVuIGNvb3JkaW5hdGVzIGlnbm9yaW5nIHRoZSBjYW1lcmEuXHJcbiAgICAgKi9cclxuICAgIENvb3JkUGxhbmVbXCJTY3JlZW5cIl0gPSBcInNjcmVlblwiO1xyXG59KShDb29yZFBsYW5lIHx8IChDb29yZFBsYW5lID0ge30pKTtcclxuY2xhc3MgVHJhbnNmb3JtQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4LnRyYW5zZm9ybSc7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm1hdHJpeCA9IE1hdHJpeC5pZGVudGl0eSgpLnRyYW5zbGF0ZSgwLCAwKS5yb3RhdGUoMCkuc2NhbGUoMSwgMSk7XHJcbiAgICAgICAgdGhpcy5fcG9zaXRpb24gPSBjcmVhdGVQb3NWaWV3KHRoaXMubWF0cml4KTtcclxuICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fc2NhbGUgPSBjcmVhdGVTY2FsZVZpZXcodGhpcy5tYXRyaXgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBbW0Nvb3JkUGxhbmV8Y29vcmRpbmF0ZSBwbGFuZXxdXSBmb3IgdGhpcyB0cmFuc2Zvcm0gZm9yIHRoZSBlbnRpdHkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb29yZFBsYW5lID0gQ29vcmRQbGFuZS5Xb3JsZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgei1pbmRleCBvcmRlcmluZyBvZiB0aGUgZW50aXR5LCBhIGhpZ2hlciB2YWx1ZXMgYXJlIGRyYXduIG9uIHRvcCBvZiBsb3dlciB2YWx1ZXMuXHJcbiAgICAgICAgICogRm9yIGV4YW1wbGUgej05OSB3b3VsZCBiZSBkcmF3biBvbiB0b3Agb2Ygej0wLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMueiA9IDA7XHJcbiAgICB9XHJcbiAgICBfcmVjYWxjdWxhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5fcm90YXRpb24gPSB0aGlzLm1hdHJpeC5nZXRSb3RhdGlvbigpO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXRHbG9iYWxNYXRyaXgoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0R2xvYmFsTWF0cml4KCkubXVsdG0odGhpcy5tYXRyaXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEdsb2JhbFRyYW5zZm9ybSgpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBwb3M6IHRoaXMuZ2xvYmFsUG9zLFxyXG4gICAgICAgICAgICBzY2FsZTogdGhpcy5nbG9iYWxTY2FsZSxcclxuICAgICAgICAgICAgcm90YXRpb246IHRoaXMuZ2xvYmFsUm90YXRpb24sXHJcbiAgICAgICAgICAgIHo6IHRoaXMueixcclxuICAgICAgICAgICAgY29vcmRQbGFuZTogdGhpcy5jb29yZFBsYW5lXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcyA9PT0gbnVsbCB8fCB0aGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGlzLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGFyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoZSBlbnRpdHkgaW4gd29ybGQgc3BhY2Ugb3IgaW4gc2NyZWVuIHNwYWNlIGRlcGVuZGluZyBvbiB0aGUgdGhlIFtbQ29vcmRQbGFuZXxjb29yZGluYXRlIHBsYW5lXV0uXHJcbiAgICAgKlxyXG4gICAgICogSWYgYSBwYXJlbnQgZW50aXR5IGV4aXN0cyBjb29yZGluYXRlcyBhcmUgbG9jYWwgdG8gdGhlIHBhcmVudC5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBvcygpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVjYWxjdWxhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Bvc2l0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IHBvcyh2YWwpIHtcclxuICAgICAgICB0aGlzLm1hdHJpeC5zZXRQb3NpdGlvbih2YWwueCwgdmFsLnkpO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8vIERpcnR5IGZsYWcgY2hlY2sgdXAgdGhlIGNoYWluXHJcbiAgICBnZXQgZGlydHkoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzID09PSBudWxsIHx8IHRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnQpIHtcclxuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuZGlydHkgfHwgdGhpcy5fZGlydHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXJ0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgd29ybGQgcG9zaXRpb24gY2FsY3VsYXRlZFxyXG4gICAgICovXHJcbiAgICBnZXQgZ2xvYmFsUG9zKCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0R2xvYmFsTWF0cml4KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3JWaWV3KHtcclxuICAgICAgICAgICAgZ2V0WDogKCkgPT4gc291cmNlLmRhdGFbTWF0cml4TG9jYXRpb25zLlhdLFxyXG4gICAgICAgICAgICBnZXRZOiAoKSA9PiBzb3VyY2UuZGF0YVtNYXRyaXhMb2NhdGlvbnMuWV0sXHJcbiAgICAgICAgICAgIHNldFg6ICh4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbbmV3WF0gPSAoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEdsb2JhbE1hdHJpeCgpLmdldEFmZmluZUludmVyc2UoKS5tdWx0dihbeCwgc291cmNlLmRhdGFbTWF0cml4TG9jYXRpb25zLlldXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRyaXguZGF0YVtNYXRyaXhMb2NhdGlvbnMuWF0gPSBuZXdYO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRyaXguZGF0YVtNYXRyaXhMb2NhdGlvbnMuWF0gPSB4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzZXRZOiAoeSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgWywgbmV3WV0gPSAoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldEdsb2JhbE1hdHJpeCgpLmdldEFmZmluZUludmVyc2UoKS5tdWx0dihbc291cmNlLmRhdGFbTWF0cml4TG9jYXRpb25zLlhdLCB5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRyaXguZGF0YVtNYXRyaXhMb2NhdGlvbnMuWV0gPSBuZXdZO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRyaXguZGF0YVtNYXRyaXhMb2NhdGlvbnMuWV0gPSB5O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZXQgZ2xvYmFsUG9zKHZhbCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFRyYW5zZm9ybSA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmICghcGFyZW50VHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSBwYXJlbnRUcmFuc2Zvcm0uZ2V0R2xvYmFsTWF0cml4KCkuZ2V0QWZmaW5lSW52ZXJzZSgpLm11bHR2KHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIGVudGl0eSBpbiByYWRpYW5zLiBGb3IgZXhhbXBsZSBgTWF0aC5QSWAgcmFkaWFucyBpcyB0aGUgc2FtZSBhcyAxODAgZGVncmVlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcm90YXRpb247XHJcbiAgICB9XHJcbiAgICBzZXQgcm90YXRpb24odmFsKSB7XHJcbiAgICAgICAgdGhpcy5tYXRyaXguc2V0Um90YXRpb24odmFsKTtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXQgZ2xvYmFsUm90YXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KCkuZ2V0Um90YXRpb24oKTtcclxuICAgIH1cclxuICAgIHNldCBnbG9iYWxSb3RhdGlvbih2YWwpIHtcclxuICAgICAgICBjb25zdCBwYXJlbnRUcmFuc2Zvcm0gPSB0aGlzLnBhcmVudDtcclxuICAgICAgICBpZiAoIXBhcmVudFRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHZhbCAtIHBhcmVudFRyYW5zZm9ybS5nbG9iYWxSb3RhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzY2FsZSBvZiB0aGUgZW50aXR5LlxyXG4gICAgICovXHJcbiAgICBnZXQgc2NhbGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9zY2FsZTtcclxuICAgIH1cclxuICAgIHNldCBzY2FsZSh2YWwpIHtcclxuICAgICAgICB0aGlzLm1hdHJpeC5zZXRTY2FsZSh2YWwpO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldCBnbG9iYWxTY2FsZSgpIHtcclxuICAgICAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmdldEdsb2JhbE1hdHJpeCgpO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yVmlldyh7XHJcbiAgICAgICAgICAgIGdldFg6ICgpID0+IHNvdXJjZS5nZXRTY2FsZVgoKSxcclxuICAgICAgICAgICAgZ2V0WTogKCkgPT4gc291cmNlLmdldFNjYWxlWSgpLFxyXG4gICAgICAgICAgICBzZXRYOiAoeCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsU2NhbGVYID0gdGhpcy5wYXJlbnQuZ2xvYmFsU2NhbGUueDtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeC5zZXRTY2FsZVgoeCAvIGdsb2JhbFNjYWxlWCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeC5zZXRTY2FsZVgoeCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldFk6ICh5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBnbG9iYWxTY2FsZVkgPSB0aGlzLnBhcmVudC5nbG9iYWxTY2FsZS55O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0cml4LnNldFNjYWxlWSh5IC8gZ2xvYmFsU2NhbGVZKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0cml4LnNldFNjYWxlWSh5KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc2V0IGdsb2JhbFNjYWxlKHZhbCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFRyYW5zZm9ybSA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmICghcGFyZW50VHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNjYWxlID0gdmVjKHZhbC54IC8gcGFyZW50VHJhbnNmb3JtLmdsb2JhbFNjYWxlLngsIHZhbC55IC8gcGFyZW50VHJhbnNmb3JtLmdsb2JhbFNjYWxlLnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgdGhlIHRyYW5zZm9ybSB0byBhIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgYXBwbHkocG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXRyaXgubXVsdHYocG9pbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0aGUgaW52ZXJzZSB0cmFuc2Zvcm0gdG8gYSBwb2ludFxyXG4gICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgKi9cclxuICAgIGFwcGx5SW52ZXJzZShwb2ludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hdHJpeC5nZXRBZmZpbmVJbnZlcnNlKCkubXVsdHYocG9pbnQpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRW50aXR5Q29tcG9uZW50U3lzdGVtL0NvbXBvbmVudHMvTW90aW9uQ29tcG9uZW50LnRzXG5cclxuXHJcbmNsYXNzIE1vdGlvbkNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC5tb3Rpb24nO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB2ZWxvY2l0eSBvZiBhbiBlbnRpdHkgaW4gcGl4ZWxzIHBlciBzZWNvbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZlbCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhY2NlbGVyYXRpb24gb2YgZW50aXR5IGluIHBpeGVscyBwZXIgc2Vjb25kXjJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjYyA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzY2FsZSByYXRlIG9mIGNoYW5nZSBpbiBzY2FsZSB1bml0cyBwZXIgc2Vjb25kXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zY2FsZUZhY3RvciA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbmd1bGFyIHZlbG9jaXR5IHdoaWNoIGlzIGhvdyBxdWlja2x5IHRoZSBlbnRpdHkgaXMgcm90YXRpbmcgaW4gcmFkaWFucyBwZXIgc2Vjb25kXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgdG9ycXVlIGFwcGxpZWQgdG8gdGhlIGVudGl0eSwgYW5ndWxhciBhY2NlbGVyYXRpb24gaXMgdG9ycXVlICogaW5lcnRpYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudG9ycXVlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmVyaXRhIGNhbiBiZSB0aG91Z2h0IG9mIGFzIHRoZSByZXNpc3RhbmNlIHRvIG1vdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaW5lcnRpYSA9IDE7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vR3JvdXAvQ29sbGlzaW9uR3JvdXAudHNcbi8qKlxyXG4gKiBDb2xsaXNpb25Hcm91cHMgaW5kaWNhdGUgbGlrZSBtZW1iZXJzIHRoYXQgZG8gbm90IGNvbGxpZGUgd2l0aCBlYWNoIG90aGVyLiBVc2UgW1tDb2xsaXNpb25Hcm91cE1hbmFnZXJdXSB0byBjcmVhdGUgW1tDb2xsaXNpb25Hcm91cF1dc1xyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogUGxheWVycyBoYXZlIGNvbGxpc2lvbiBncm91cCBcInBsYXllclwiXHJcbiAqXHJcbiAqICFbUGxheWVyIENvbGxpc2lvbiBHcm91cF0oL2Fzc2V0cy9pbWFnZXMvZG9jcy9Db2xsaXNpb25Hcm91cHNQbGF5ZXIucG5nKVxyXG4gKlxyXG4gKiBFbmVtaWVzIGhhdmUgY29sbGlzaW9uIGdyb3VwIFwiZW5lbXlcIlxyXG4gKlxyXG4gKiAhW0VuZW15IENvbGxpc2lvbiBHcm91cF0oL2Fzc2V0cy9pbWFnZXMvZG9jcy9Db2xsaXNpb25Hcm91cHNFbmVteS5wbmcpXHJcbiAqXHJcbiAqIEJsb2NrcyBoYXZlIGNvbGxpc2lvbiBncm91cCBcImdyb3VuZFwiXHJcbiAqXHJcbiAqICFbR3JvdW5kIGNvbGxpc2lvbiBncm91cF0oL2Fzc2V0cy9pbWFnZXMvZG9jcy9Db2xsaXNpb25Hcm91cHNHcm91bmQucG5nKVxyXG4gKlxyXG4gKiBQbGF5ZXJzIGRvbid0IGNvbGxpZGUgd2l0aCBlYWNoIG90aGVyLCBidXQgZW5lbWllcyBhbmQgYmxvY2tzLiBMaWtld2lzZSwgZW5lbWllcyBkb24ndCBjb2xsaWRlIHdpdGggZWFjaCBvdGhlciBidXQgY29sbGlkZVxyXG4gKiB3aXRoIHBsYXllcnMgYW5kIGJsb2Nrcy5cclxuICpcclxuICogVGhpcyBpcyBkb25lIHdpdGggYml0bWFza2luZywgc2VlIHRoZSBmb2xsb3dpbmcgcHNldWRvLWNvZGVcclxuICpcclxuICogUGxheWVyR3JvdXAgPSBgMGIwMDFgXHJcbiAqIFBsYXllckdyb3VwTWFzayA9IGAwYjExMGBcclxuICpcclxuICogRW5lbXlHcm91cCA9IGAwYjAxMGBcclxuICogRW5lbXlHcm91cE1hc2sgPSBgMGIxMDFgXHJcbiAqXHJcbiAqIEJsb2NrR3JvdXAgPSBgMGIxMDBgXHJcbiAqIEJsb2NrR3JvdXBNYXNrID0gYDBiMDExYFxyXG4gKlxyXG4gKiBTaG91bGQgUGxheWVycyBjb2xsaWRlPyBObyBiZWNhdXNlIHRoZSBiaXR3aXNlIG1hc2sgZXZhbHVhdGVzIHRvIDBcclxuICogYChwbGF5ZXIxLmdyb3VwICYgcGxheWVyMi5tYXNrKSA9PT0gMGBcclxuICogYCgwYjAwMSAmIDBiMTEwKSA9PT0gMGBcclxuICpcclxuICogU2hvdWxkIFBsYXllcnMgYW5kIEVuZW1pZXMgY29sbGlkZT8gWWVzIGJlY2F1c2UgdGhlIGJpdHdpc2UgbWFzayBpcyBub24temVyb1xyXG4gKiBgKHBsYXllcjEuZ3JvdXAgJiBlbmVteTEubWFzaykgPT09IDFgXHJcbiAqIGAoMGIwMDEgJiAwYjEwMSkgPT09IDFgXHJcbiAqXHJcbiAqIFNob3VsZCBQbGF5ZXJzIGFuZCBCbG9ja3MgY29sbGlkZT8gWWVzIGJlY2F1c2UgdGhlIGJpdHdpc2UgbWFzayBpcyBub24temVyb1xyXG4gKiBgKHBsYXllcjEuZ3JvdXAgJiBibG9ja3MxLm1hc2spID09PSAxYFxyXG4gKiBgKDBiMDAxICYgMGIwMTEpID09PSAxYFxyXG4gKi9cclxuY2xhc3MgQ29sbGlzaW9uR3JvdXAge1xyXG4gICAgLyoqXHJcbiAgICAgKiBTVE9QISEqKiBJdCBpcyBwcmVmZXJyZWQgdGhhdCBbW0NvbGxpc2lvbkdyb3VwTWFuYWdlci5jcmVhdGVdXSBpcyB1c2VkIHRvIGNyZWF0ZSBjb2xsaXNpb24gZ3JvdXBzXHJcbiAgICAgKiAgdW5sZXNzIHlvdSBrbm93IGhvdyB0byBjb25zdHJ1Y3QgdGhlIHByb3BlciBiaXRtYXNrcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvaXNzdWVzLzEwOTEgZm9yIG1vcmUgaW5mby5cclxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIGNvbGxpc2lvbiBncm91cFxyXG4gICAgICogQHBhcmFtIGNhdGVnb3J5IDMyIGJpdCBjYXRlZ29yeSBmb3IgdGhlIGdyb3VwLCBzaG91bGQgYmUgYSB1bmlxdWUgcG93ZXIgb2YgMi4gRm9yIGV4YW1wbGUgYDBiMDAxYCBvciBgMGIwMTBgXHJcbiAgICAgKiBAcGFyYW0gbWFzayAzMiBiaXQgbWFzayBvZiBjYXRlZ29yeSwgb3IgYH5jYXRlZ29yeWAgZ2VuZXJhbGx5LiBGb3IgYSBjYXRlZ29yeSBvZiBgMGIwMDFgLCB0aGUgbWFzayB3b3VsZCBiZSBgMGIxMTBgXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNhdGVnb3J5LCBtYXNrKSB7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICAgICAgdGhpcy5fY2F0ZWdvcnkgPSBjYXRlZ29yeTtcclxuICAgICAgICB0aGlzLl9tYXNrID0gbWFzaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBuYW1lIG9mIHRoZSBjb2xsaXNpb24gZ3JvdXBcclxuICAgICAqL1xyXG4gICAgZ2V0IG5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2F0ZWdvcnkgb2YgdGhlIGNvbGxpc2lvbiBncm91cCwgYSAzMiBiaXQgbnVtYmVyIHdoaWNoIHNob3VsZCBiZSBhIHVuaXF1ZSBwb3dlciBvZiAyXHJcbiAgICAgKi9cclxuICAgIGdldCBjYXRlZ29yeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2F0ZWdvcnk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbWFzayBmb3IgdGhpcyBjb2xsaXNpb24gZ3JvdXBcclxuICAgICAqL1xyXG4gICAgZ2V0IG1hc2soKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hc2s7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEV2YWx1YXRlcyB3aGV0aGVyIDIgY29sbGlzaW9uIGdyb3VwcyBjYW4gY29sbGlkZVxyXG4gICAgICogQHBhcmFtIG90aGVyICBDb2xsaXNpb25Hcm91cFxyXG4gICAgICovXHJcbiAgICBjYW5Db2xsaWRlKG90aGVyKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmNhdGVnb3J5ICYgb3RoZXIubWFzaykgIT09IDAgJiYgKG90aGVyLmNhdGVnb3J5ICYgdGhpcy5tYXNrKSAhPT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW52ZXJ0cyB0aGUgY29sbGlzaW9uIGdyb3VwLiBGb3IgZXhhbXBsZSwgaWYgYmVmb3JlIHRoZSBncm91cCBzcGVjaWZpZWQgXCJwbGF5ZXJzXCIsXHJcbiAgICAgKiBpbnZlcnRpbmcgd291bGQgc3BlY2lmeSBhbGwgZ3JvdXBzIGV4Y2VwdCBwbGF5ZXJzXHJcbiAgICAgKiBAcmV0dXJucyBDb2xsaXNpb25Hcm91cFxyXG4gICAgICovXHJcbiAgICBpbnZlcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Hcm91cCgnfignICsgdGhpcy5uYW1lICsgJyknLCB+dGhpcy5jYXRlZ29yeSwgfnRoaXMubWFzayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbWJpbmUgY29sbGlzaW9uIGdyb3VwcyB3aXRoIGVhY2ggb3RoZXIuIFRoZSBuZXcgZ3JvdXAgaW5jbHVkZXMgYWxsIG9mIHRoZSBwcmV2aW91cyBncm91cHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbGxpc2lvbkdyb3Vwc1xyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNvbWJpbmUoY29sbGlzaW9uR3JvdXBzKSB7XHJcbiAgICAgICAgY29uc3QgY29tYmluZWROYW1lID0gY29sbGlzaW9uR3JvdXBzLm1hcCgoYykgPT4gYy5uYW1lKS5qb2luKCcrJyk7XHJcbiAgICAgICAgY29uc3QgY29tYmluZWRDYXRlZ29yeSA9IGNvbGxpc2lvbkdyb3Vwcy5yZWR1Y2UoKGN1cnJlbnQsIGcpID0+IGcuY2F0ZWdvcnkgfCBjdXJyZW50LCAwYjApO1xyXG4gICAgICAgIGNvbnN0IGNvbWJpbmVkTWFzayA9IH5jb21iaW5lZENhdGVnb3J5O1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29sbGlzaW9uR3JvdXAoY29tYmluZWROYW1lLCBjb21iaW5lZENhdGVnb3J5LCBjb21iaW5lZE1hc2spO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgY29sbGlzaW9uIGdyb3VwIHRoYXQgY29sbGlkZXMgd2l0aCB0aGUgbGlzdGVkIGdyb3Vwc1xyXG4gICAgICogQHBhcmFtIGNvbGxpc2lvbkdyb3Vwc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29sbGlkZXNXaXRoKGNvbGxpc2lvbkdyb3Vwcykge1xyXG4gICAgICAgIHJldHVybiBDb2xsaXNpb25Hcm91cC5jb21iaW5lKGNvbGxpc2lvbkdyb3VwcykuaW52ZXJ0KCk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBgQWxsYCBbW0NvbGxpc2lvbkdyb3VwXV0gaXMgYSBzcGVjaWFsIGdyb3VwIHRoYXQgY29sbGlkZXMgd2l0aCBhbGwgb3RoZXIgZ3JvdXBzIGluY2x1ZGluZyBpdHNlbGYsXHJcbiAqIGl0IGlzIHRoZSBkZWZhdWx0IGNvbGxpc2lvbiBncm91cCBvbiBjb2xsaWRlcnMuXHJcbiAqL1xyXG5Db2xsaXNpb25Hcm91cC5BbGwgPSBuZXcgQ29sbGlzaW9uR3JvdXAoJ0NvbGxpZGUgd2l0aCBhbGwgZ3JvdXBzJywgLTEsIC0xKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL09ic2VydmFibGUudHNcbi8qKlxyXG4gKiBTaW1wbGUgT2JzZXJ2YWJsZSBpbXBsZW1lbmF0aW9uXHJcbiAqIEB0ZW1wbGF0ZSBUIGlzIHRoZSB0eXBlc2NyaXB0IFR5cGUgdGhhdCBkZWZpbmVzIHRoZSBkYXRhIGJlaW5nIG9ic2VydmVkXHJcbiAqL1xyXG5jbGFzcyBPYnNlcnZhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGFuIG9ic2VydmVyIHRvIGxpc3RlbiB0byB0aGlzIG9ic2VydmFibGVcclxuICAgICAqIEBwYXJhbSBvYnNlcnZlclxyXG4gICAgICovXHJcbiAgICByZWdpc3RlcihvYnNlcnZlcikge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGxpc3RlbiB0byB0aGlzIG9ic2VydmFibGVcclxuICAgICAqIEBwYXJhbSBmdW5jXHJcbiAgICAgKi9cclxuICAgIHN1YnNjcmliZShmdW5jKSB7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goZnVuYyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBvYnNlcnZlciBmcm9tIHRoZSBvYnNlcnZhYmxlXHJcbiAgICAgKiBAcGFyYW0gb2JzZXJ2ZXJcclxuICAgICAqL1xyXG4gICAgdW5yZWdpc3RlcihvYnNlcnZlcikge1xyXG4gICAgICAgIGNvbnN0IGkgPSB0aGlzLm9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5vYnNlcnZlcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGEgY2FsbGJhY2sgdGhhdCBpcyBsaXN0ZW5pbmcgdG8gdGhpcyBvYnNlcnZhYmxlXHJcbiAgICAgKiBAcGFyYW0gZnVuY1xyXG4gICAgICovXHJcbiAgICB1bnN1YnNjcmliZShmdW5jKSB7XHJcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuc3Vic2NyaXB0aW9ucy5pbmRleE9mKGZ1bmMpO1xyXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQnJvYWRjYXN0cyBhIG1lc3NhZ2UgdG8gYWxsIG9ic2VydmVycyBhbmQgY2FsbGJhY2tzXHJcbiAgICAgKiBAcGFyYW0gbWVzc2FnZVxyXG4gICAgICovXHJcbiAgICBub3RpZnlBbGwobWVzc2FnZSkge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmZvckVhY2goKG8pID0+IG8ubm90aWZ5KG1lc3NhZ2UpKTtcclxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMuZm9yRWFjaChjYiA9PiBjYihtZXNzYWdlKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIG9ic2VydmVycyBhbmQgY2FsbGJhY2tzXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vRGV0ZWN0aW9uL1BhaXIudHNcblxyXG5cclxuLyoqXHJcbiAqIE1vZGVscyBhIHBvdGVudGlhbCBjb2xsaXNpb24gYmV0d2VlbiAyIGNvbGxpZGVyc1xyXG4gKi9cclxuY2xhc3MgUGFpciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xsaWRlckEsIGNvbGxpZGVyQikge1xyXG4gICAgICAgIHRoaXMuY29sbGlkZXJBID0gY29sbGlkZXJBO1xyXG4gICAgICAgIHRoaXMuY29sbGlkZXJCID0gY29sbGlkZXJCO1xyXG4gICAgICAgIHRoaXMuaWQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaWQgPSBQYWlyLmNhbGN1bGF0ZVBhaXJIYXNoKGNvbGxpZGVyQS5pZCwgY29sbGlkZXJCLmlkKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBjYW5Db2xsaWRlKGNvbGxpZGVyQSwgY29sbGlkZXJCKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBib2R5QSA9IChfYSA9IGNvbGxpZGVyQSA9PT0gbnVsbCB8fCBjb2xsaWRlckEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbGxpZGVyQS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICBjb25zdCBib2R5QiA9IChfYiA9IGNvbGxpZGVyQiA9PT0gbnVsbCB8fCBjb2xsaWRlckIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbGxpZGVyQi5vd25lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAvLyBCb2R5J3MgbmVlZGVkIGZvciBjb2xsaXNpb24gaW4gdGhlIGN1cnJlbnQgc3RhdGVcclxuICAgICAgICAvLyBUT0RPIGNhbiB3ZSBjb2xsaWRlIHdpdGhvdXQgYSBib2R5P1xyXG4gICAgICAgIGlmICghYm9keUEgfHwgIWJvZHlCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgYm90aCBhcmUgaW4gdGhlIHNhbWUgY29sbGlzaW9uIGdyb3VwIHNob3J0IGNpcmN1aXRcclxuICAgICAgICBpZiAoIWJvZHlBLmdyb3VwLmNhbkNvbGxpZGUoYm9keUIuZ3JvdXApKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgYm90aCBhcmUgZml4ZWQgc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgIGlmIChib2R5QS5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLkZpeGVkICYmIGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuRml4ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiB0aGUgZWl0aGVyIGlzIHByZXZlbnQgY29sbGlzaW9uIHNob3J0IGNpcmN1aXRcclxuICAgICAgICBpZiAoYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uIHx8IGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIGVpdGhlciBpcyBkZWFkIHNob3J0IGNpcmN1aXRcclxuICAgICAgICBpZiAoIWJvZHlBLmFjdGl2ZSB8fCAhYm9keUIuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBvciBub3QgaXQgaXMgcG9zc2libGUgZm9yIHRoZSBwYWlycyB0byBjb2xsaWRlXHJcbiAgICAgKi9cclxuICAgIGdldCBjYW5Db2xsaWRlKCkge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVyQSA9IHRoaXMuY29sbGlkZXJBO1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVyQiA9IHRoaXMuY29sbGlkZXJCO1xyXG4gICAgICAgIHJldHVybiBQYWlyLmNhbkNvbGxpZGUoY29sbGlkZXJBLCBjb2xsaWRlckIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIHRoZSBjb2xsaXNpb24gaW50ZXJzZWN0aW9uIGxvZ2ljIG9uIHRoZSBtZW1iZXJzIG9mIHRoaXMgcGFpclxyXG4gICAgICovXHJcbiAgICBjb2xsaWRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbGxpZGVyQS5jb2xsaWRlKHRoaXMuY29sbGlkZXJCKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgdGhlIGNvbGxpZGVyIGlzIHBhcnQgb2YgdGhlIHBhaXJcclxuICAgICAqIEBwYXJhbSBjb2xsaWRlclxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgaGFzQ29sbGlkZXIoY29sbGlkZXIpIHtcclxuICAgICAgICByZXR1cm4gY29sbGlkZXIgPT09IHRoaXMuY29sbGlkZXJBIHx8IGNvbGxpZGVyID09PSB0aGlzLmNvbGxpZGVyQjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdW5pcXVlIHBhaXIgaGFzaCBpZCBmb3IgdGhpcyBjb2xsaXNpb24gcGFpciAob3duaW5nIGlkKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY2FsY3VsYXRlUGFpckhhc2goaWRBLCBpZEIpIHtcclxuICAgICAgICBpZiAoaWRBLnZhbHVlIDwgaWRCLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgIyR7aWRBLnZhbHVlfSske2lkQi52YWx1ZX1gO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAjJHtpZEIudmFsdWV9KyR7aWRBLnZhbHVlfWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTWF0aC9wcm9qZWN0aW9uLnRzXG4vKipcclxuICogQSAxIGRpbWVuc2lvbmFsIHByb2plY3Rpb24gb24gYW4gYXhpcywgdXNlZCB0byB0ZXN0IG92ZXJsYXBzXHJcbiAqL1xyXG5jbGFzcyBQcm9qZWN0aW9uIHtcclxuICAgIGNvbnN0cnVjdG9yKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgdGhpcy5taW4gPSBtaW47XHJcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XHJcbiAgICB9XHJcbiAgICBvdmVybGFwcyhwcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF4ID4gcHJvamVjdGlvbi5taW4gJiYgcHJvamVjdGlvbi5tYXggPiB0aGlzLm1pbjtcclxuICAgIH1cclxuICAgIGdldE92ZXJsYXAocHJvamVjdGlvbikge1xyXG4gICAgICAgIGlmICh0aGlzLm92ZXJsYXBzKHByb2plY3Rpb24pKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm1heCA+IHByb2plY3Rpb24ubWF4KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvamVjdGlvbi5tYXggLSB0aGlzLm1pbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1heCAtIHByb2plY3Rpb24ubWluO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0RldGVjdGlvbi9EeW5hbWljVHJlZS50c1xuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogRHluYW1pYyBUcmVlIE5vZGUgdXNlZCBmb3IgdHJhY2tpbmcgYm91bmRzIHdpdGhpbiB0aGUgdHJlZVxyXG4gKi9cclxuY2xhc3MgVHJlZU5vZGUge1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XHJcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgfHwgbnVsbDtcclxuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuYm91bmRzID0gbmV3IEJvdW5kaW5nQm94KCk7XHJcbiAgICAgICAgdGhpcy5sZWZ0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLnJpZ2h0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICB9XHJcbiAgICBpc0xlYWYoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmxlZnQgJiYgIXRoaXMucmlnaHQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBEeW5hbWljVHJlZXMgcHJvdmlkZXMgYSBzcGF0aWFsIHBhcnRpdGlvbmluZyBkYXRhIHN0cnVjdHVyZSBmb3IgcXVpY2tseSBxdWVyeWluZyBmb3Igb3ZlcmxhcHBpbmcgYm91bmRpbmcgYm94ZXMgZm9yXHJcbiAqIGFsbCB0cmFja2VkIGJvZGllcy4gVGhlIHdvcnN0IGNhc2UgcGVyZm9ybWFuY2Ugb2YgdGhpcyBpcyBPKG4qbG9nKG4pKSB3aGVyZSBuIGlzIHRoZSBudW1iZXIgb2YgYm9kaWVzIGluIHRoZSB0cmVlLlxyXG4gKlxyXG4gKiBJbnRlcm5hbGx5IHRoZSBib3VuZGluZyBib3hlcyBhcmUgb3JnYW5pemVkIGFzIGEgYmFsYW5jZWQgYmluYXJ5IHRyZWUgb2YgYm91bmRpbmcgYm94ZXMsIHdoZXJlIHRoZSBsZWFmIG5vZGVzIGFyZSB0cmFja2VkIGJvZGllcy5cclxuICogRXZlcnkgbm9uLWxlYWYgbm9kZSBpcyBhIGJvdW5kaW5nIGJveCB0aGF0IGNvbnRhaW5zIGNoaWxkIGJvdW5kaW5nIGJveGVzLlxyXG4gKi9cclxuY2xhc3MgRHluYW1pY1RyZWUge1xyXG4gICAgY29uc3RydWN0b3Iod29ybGRCb3VuZHMgPSBuZXcgQm91bmRpbmdCb3goLU51bWJlci5NQVhfVkFMVUUsIC1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFKSkge1xyXG4gICAgICAgIHRoaXMud29ybGRCb3VuZHMgPSB3b3JsZEJvdW5kcztcclxuICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubm9kZXMgPSB7fTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5zZXJ0cyBhIG5vZGUgaW50byB0aGUgZHluYW1pYyB0cmVlXHJcbiAgICAgKi9cclxuICAgIF9pbnNlcnQobGVhZikge1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBub2RlcyBpbiB0aGUgdHJlZSwgbWFrZSB0aGlzIHRoZSByb290IGxlYWZcclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IGxlYWY7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdC5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFNlYXJjaCB0aGUgdHJlZSBmb3IgYSBub2RlIHRoYXQgaXMgbm90IGEgbGVhZiBhbmQgZmluZCB0aGUgYmVzdCBwbGFjZSB0byBpbnNlcnRcclxuICAgICAgICBjb25zdCBsZWFmQUFCQiA9IGxlYWYuYm91bmRzO1xyXG4gICAgICAgIGxldCBjdXJyZW50Um9vdCA9IHRoaXMucm9vdDtcclxuICAgICAgICB3aGlsZSAoIWN1cnJlbnRSb290LmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBjdXJyZW50Um9vdC5sZWZ0O1xyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGN1cnJlbnRSb290LnJpZ2h0O1xyXG4gICAgICAgICAgICBjb25zdCBhcmVhID0gY3VycmVudFJvb3QuYm91bmRzLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZEFBQkIgPSBjdXJyZW50Um9vdC5ib3VuZHMuY29tYmluZShsZWFmQUFCQik7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkQXJlYSA9IGNvbWJpbmVkQUFCQi5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGNvc3QgaGV1cmlzdGljIGZvciBjcmVhdGluZyBhIG5ldyBwYXJlbnQgYW5kIGxlYWZcclxuICAgICAgICAgICAgY29uc3QgY29zdCA9IDIgKiBjb21iaW5lZEFyZWE7XHJcbiAgICAgICAgICAgIC8vIE1pbmltdW0gY29zdCBvZiBwdXNoaW5nIHRoZSBsZWFmIGRvd24gdGhlIHRyZWVcclxuICAgICAgICAgICAgY29uc3QgaW5oZXJpdGFuY2VDb3N0ID0gMiAqIChjb21iaW5lZEFyZWEgLSBhcmVhKTtcclxuICAgICAgICAgICAgLy8gQ29zdCBvZiBkZXNjZW5kaW5nXHJcbiAgICAgICAgICAgIGxldCBsZWZ0Q29zdCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnRDb21iaW5lZCA9IGxlYWZBQUJCLmNvbWJpbmUobGVmdC5ib3VuZHMpO1xyXG4gICAgICAgICAgICBsZXQgbmV3QXJlYTtcclxuICAgICAgICAgICAgbGV0IG9sZEFyZWE7XHJcbiAgICAgICAgICAgIGlmIChsZWZ0LmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q29zdCA9IGxlZnRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9sZEFyZWEgPSBsZWZ0LmJvdW5kcy5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgIG5ld0FyZWEgPSBsZWZ0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgICAgICBsZWZ0Q29zdCA9IG5ld0FyZWEgLSBvbGRBcmVhICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCByaWdodENvc3QgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCByaWdodENvbWJpbmVkID0gbGVhZkFBQkIuY29tYmluZShyaWdodC5ib3VuZHMpO1xyXG4gICAgICAgICAgICBpZiAocmlnaHQuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgIHJpZ2h0Q29zdCA9IHJpZ2h0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCkgKyBpbmhlcml0YW5jZUNvc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvbGRBcmVhID0gcmlnaHQuYm91bmRzLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgbmV3QXJlYSA9IHJpZ2h0Q29tYmluZWQuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgICAgICByaWdodENvc3QgPSBuZXdBcmVhIC0gb2xkQXJlYSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBjb3N0IGlzIGFjY2VwdGFibGVcclxuICAgICAgICAgICAgaWYgKGNvc3QgPCBsZWZ0Q29zdCAmJiBjb3N0IDwgcmlnaHRDb3N0KSB7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBEZXNjZW5kIHRvIHRoZSBkZXB0aHNcclxuICAgICAgICAgICAgaWYgKGxlZnRDb3N0IDwgcmlnaHRDb3N0KSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Um9vdCA9IGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Um9vdCA9IHJpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IHBhcmVudCBub2RlIGFuZCBpbnNlcnQgaW50byB0aGUgdHJlZVxyXG4gICAgICAgIGNvbnN0IG9sZFBhcmVudCA9IGN1cnJlbnRSb290LnBhcmVudDtcclxuICAgICAgICBjb25zdCBuZXdQYXJlbnQgPSBuZXcgVHJlZU5vZGUob2xkUGFyZW50KTtcclxuICAgICAgICBuZXdQYXJlbnQuYm91bmRzID0gbGVhZkFBQkIuY29tYmluZShjdXJyZW50Um9vdC5ib3VuZHMpO1xyXG4gICAgICAgIG5ld1BhcmVudC5oZWlnaHQgPSBjdXJyZW50Um9vdC5oZWlnaHQgKyAxO1xyXG4gICAgICAgIGlmIChvbGRQYXJlbnQgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgLy8gVGhlIHNpYmxpbmcgbm9kZSB3YXMgbm90IHRoZSByb290XHJcbiAgICAgICAgICAgIGlmIChvbGRQYXJlbnQubGVmdCA9PT0gY3VycmVudFJvb3QpIHtcclxuICAgICAgICAgICAgICAgIG9sZFBhcmVudC5sZWZ0ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb2xkUGFyZW50LnJpZ2h0ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG5ld1BhcmVudC5sZWZ0ID0gY3VycmVudFJvb3Q7XHJcbiAgICAgICAgICAgIG5ld1BhcmVudC5yaWdodCA9IGxlYWY7XHJcbiAgICAgICAgICAgIGN1cnJlbnRSb290LnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBUaGUgc2libGluZyBub2RlIHdhcyB0aGUgcm9vdFxyXG4gICAgICAgICAgICBuZXdQYXJlbnQubGVmdCA9IGN1cnJlbnRSb290O1xyXG4gICAgICAgICAgICBuZXdQYXJlbnQucmlnaHQgPSBsZWFmO1xyXG4gICAgICAgICAgICBjdXJyZW50Um9vdC5wYXJlbnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgIGxlYWYucGFyZW50ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdhbGsgdXAgdGhlIHRyZWUgZml4aW5nIGhlaWdodHMgYW5kIEFBQkJzXHJcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gbGVhZi5wYXJlbnQ7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy5fYmFsYW5jZShjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudE5vZGUubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJlbnQgb2YgY3VycmVudCBsZWFmIGNhbm5vdCBoYXZlIGEgbnVsbCBsZWZ0IGNoaWxkJyArIGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnROb2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBvZiBjdXJyZW50IGxlYWYgY2Fubm90IGhhdmUgYSBudWxsIHJpZ2h0IGNoaWxkJyArIGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjdXJyZW50Tm9kZS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoY3VycmVudE5vZGUubGVmdC5oZWlnaHQsIGN1cnJlbnROb2RlLnJpZ2h0LmhlaWdodCk7XHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcyA9IGN1cnJlbnROb2RlLmxlZnQuYm91bmRzLmNvbWJpbmUoY3VycmVudE5vZGUucmlnaHQuYm91bmRzKTtcclxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgbm9kZSBmcm9tIHRoZSBkeW5hbWljIHRyZWVcclxuICAgICAqL1xyXG4gICAgX3JlbW92ZShsZWFmKSB7XHJcbiAgICAgICAgaWYgKGxlYWYgPT09IHRoaXMucm9vdCkge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBudWxsO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGxlYWYucGFyZW50O1xyXG4gICAgICAgIGNvbnN0IGdyYW5kUGFyZW50ID0gcGFyZW50LnBhcmVudDtcclxuICAgICAgICBsZXQgc2libGluZztcclxuICAgICAgICBpZiAocGFyZW50LmxlZnQgPT09IGxlYWYpIHtcclxuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5yaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNpYmxpbmcgPSBwYXJlbnQubGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGdyYW5kUGFyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChncmFuZFBhcmVudC5sZWZ0ID09PSBwYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGdyYW5kUGFyZW50LmxlZnQgPSBzaWJsaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ3JhbmRQYXJlbnQucmlnaHQgPSBzaWJsaW5nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHNpYmxpbmcucGFyZW50ID0gZ3JhbmRQYXJlbnQ7XHJcbiAgICAgICAgICAgIGxldCBjdXJyZW50Tm9kZSA9IGdyYW5kUGFyZW50O1xyXG4gICAgICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gdGhpcy5fYmFsYW5jZShjdXJyZW50Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5ib3VuZHMgPSBjdXJyZW50Tm9kZS5sZWZ0LmJvdW5kcy5jb21iaW5lKGN1cnJlbnROb2RlLnJpZ2h0LmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoY3VycmVudE5vZGUubGVmdC5oZWlnaHQsIGN1cnJlbnROb2RlLnJpZ2h0LmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gc2libGluZztcclxuICAgICAgICAgICAgc2libGluZy5wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhY2tzIGEgYm9keSBpbiB0aGUgZHluYW1pYyB0cmVlXHJcbiAgICAgKi9cclxuICAgIHRyYWNrQ29sbGlkZXIoY29sbGlkZXIpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gbmV3IFRyZWVOb2RlKCk7XHJcbiAgICAgICAgbm9kZS5kYXRhID0gY29sbGlkZXI7XHJcbiAgICAgICAgbm9kZS5ib3VuZHMgPSBjb2xsaWRlci5ib3VuZHM7XHJcbiAgICAgICAgbm9kZS5ib3VuZHMubGVmdCAtPSAyO1xyXG4gICAgICAgIG5vZGUuYm91bmRzLnRvcCAtPSAyO1xyXG4gICAgICAgIG5vZGUuYm91bmRzLnJpZ2h0ICs9IDI7XHJcbiAgICAgICAgbm9kZS5ib3VuZHMuYm90dG9tICs9IDI7XHJcbiAgICAgICAgdGhpcy5ub2Rlc1tjb2xsaWRlci5pZC52YWx1ZV0gPSBub2RlO1xyXG4gICAgICAgIHRoaXMuX2luc2VydChub2RlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgZHluYW1pYyB0cmVlIGdpdmVuIHRoZSBjdXJyZW50IGJvdW5kcyBvZiBlYWNoIGJvZHkgYmVpbmcgdHJhY2tlZFxyXG4gICAgICovXHJcbiAgICB1cGRhdGVDb2xsaWRlcihjb2xsaWRlcikge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2Rlc1tjb2xsaWRlci5pZC52YWx1ZV07XHJcbiAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYiA9IGNvbGxpZGVyLmJvdW5kcztcclxuICAgICAgICAvLyBpZiB0aGUgYm9keSBpcyBvdXRzaWRlIHRoZSB3b3JsZCBubyBsb25nZXIgdXBkYXRlIGl0XHJcbiAgICAgICAgaWYgKCF0aGlzLndvcmxkQm91bmRzLmNvbnRhaW5zKGIpKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0NvbGxpZGVyIHdpdGggaWQgJyArIGNvbGxpZGVyLmlkLnZhbHVlICsgJyBpcyBvdXRzaWRlIHRoZSB3b3JsZCBib3VuZHMgYW5kIHdpbGwgbm8gbG9uZ2VyIGJlIHRyYWNrZWQgZm9yIHBoeXNpY3MnKTtcclxuICAgICAgICAgICAgdGhpcy51bnRyYWNrQ29sbGlkZXIoY29sbGlkZXIpO1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub2RlLmJvdW5kcy5jb250YWlucyhiKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3JlbW92ZShub2RlKTtcclxuICAgICAgICBiLmxlZnQgLT0gUGh5c2ljcy5ib3VuZHNQYWRkaW5nO1xyXG4gICAgICAgIGIudG9wIC09IFBoeXNpY3MuYm91bmRzUGFkZGluZztcclxuICAgICAgICBiLnJpZ2h0ICs9IFBoeXNpY3MuYm91bmRzUGFkZGluZztcclxuICAgICAgICBiLmJvdHRvbSArPSBQaHlzaWNzLmJvdW5kc1BhZGRpbmc7XHJcbiAgICAgICAgLy8gVEhJUyBJUyBDQVVTSU5HIFVORUNFU1NBUlkgQ0hFQ0tTXHJcbiAgICAgICAgaWYgKGNvbGxpZGVyLm93bmVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSAoX2EgPSBjb2xsaWRlci5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKGJvZHkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG11bHRkeCA9ICgoYm9keS52ZWwueCAqIDMyKSAvIDEwMDApICogUGh5c2ljcy5keW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG11bHRkeSA9ICgoYm9keS52ZWwueSAqIDMyKSAvIDEwMDApICogUGh5c2ljcy5keW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbGllcjtcclxuICAgICAgICAgICAgICAgIGlmIChtdWx0ZHggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5sZWZ0ICs9IG11bHRkeDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGIucmlnaHQgKz0gbXVsdGR4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG11bHRkeSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBiLnRvcCArPSBtdWx0ZHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBiLmJvdHRvbSArPSBtdWx0ZHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgbm9kZS5ib3VuZHMgPSBiO1xyXG4gICAgICAgIHRoaXMuX2luc2VydChub2RlKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW50cmFja3MgYSBib2R5IGZyb20gdGhlIGR5bmFtaWMgdHJlZVxyXG4gICAgICovXHJcbiAgICB1bnRyYWNrQ29sbGlkZXIoY29sbGlkZXIpIHtcclxuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5ub2Rlc1tjb2xsaWRlci5pZC52YWx1ZV07XHJcbiAgICAgICAgaWYgKCFub2RlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgIHRoaXMubm9kZXNbY29sbGlkZXIuaWQudmFsdWVdID0gbnVsbDtcclxuICAgICAgICBkZWxldGUgdGhpcy5ub2Rlc1tjb2xsaWRlci5pZC52YWx1ZV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJhbGFuY2VzIHRoZSB0cmVlIGFib3V0IGEgbm9kZVxyXG4gICAgICovXHJcbiAgICBfYmFsYW5jZShub2RlKSB7XHJcbiAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYmFsYW5jZSBhdCBudWxsIG5vZGUnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuaXNMZWFmKCkgfHwgbm9kZS5oZWlnaHQgPCAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZWZ0ID0gbm9kZS5sZWZ0O1xyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gbm9kZS5yaWdodDtcclxuICAgICAgICBjb25zdCBhID0gbm9kZTtcclxuICAgICAgICBjb25zdCBiID0gbGVmdDtcclxuICAgICAgICBjb25zdCBjID0gcmlnaHQ7XHJcbiAgICAgICAgY29uc3QgZCA9IGxlZnQubGVmdDtcclxuICAgICAgICBjb25zdCBlID0gbGVmdC5yaWdodDtcclxuICAgICAgICBjb25zdCBmID0gcmlnaHQubGVmdDtcclxuICAgICAgICBjb25zdCBnID0gcmlnaHQucmlnaHQ7XHJcbiAgICAgICAgY29uc3QgYmFsYW5jZSA9IGMuaGVpZ2h0IC0gYi5oZWlnaHQ7XHJcbiAgICAgICAgLy8gUm90YXRlIGMgbm9kZSB1cFxyXG4gICAgICAgIGlmIChiYWxhbmNlID4gMSkge1xyXG4gICAgICAgICAgICAvLyBTd2FwIHRoZSByaWdodCBub2RlIHdpdGggaXQncyBwYXJlbnRcclxuICAgICAgICAgICAgYy5sZWZ0ID0gYTtcclxuICAgICAgICAgICAgYy5wYXJlbnQgPSBhLnBhcmVudDtcclxuICAgICAgICAgICAgYS5wYXJlbnQgPSBjO1xyXG4gICAgICAgICAgICAvLyBUaGUgb3JpZ2luYWwgbm9kZSdzIG9sZCBwYXJlbnQgc2hvdWxkIHBvaW50IHRvIHRoZSByaWdodCBub2RlXHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbWVnYSBjb25mdXNpbmdcclxuICAgICAgICAgICAgaWYgKGMucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYy5wYXJlbnQubGVmdCA9PT0gYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGMucGFyZW50LmxlZnQgPSBjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQucmlnaHQgPSBjO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gYztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSb3RhdGVcclxuICAgICAgICAgICAgaWYgKGYuaGVpZ2h0ID4gZy5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGMucmlnaHQgPSBmO1xyXG4gICAgICAgICAgICAgICAgYS5yaWdodCA9IGc7XHJcbiAgICAgICAgICAgICAgICBnLnBhcmVudCA9IGE7XHJcbiAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGIuYm91bmRzLmNvbWJpbmUoZy5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgYy5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGYuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGIuaGVpZ2h0LCBnLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBjLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZi5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYy5yaWdodCA9IGc7XHJcbiAgICAgICAgICAgICAgICBhLnJpZ2h0ID0gZjtcclxuICAgICAgICAgICAgICAgIGYucGFyZW50ID0gYTtcclxuICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYi5ib3VuZHMuY29tYmluZShmLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBjLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZy5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYi5oZWlnaHQsIGYuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBnLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJvdGF0ZSBsZWZ0IG5vZGUgdXBcclxuICAgICAgICBpZiAoYmFsYW5jZSA8IC0xKSB7XHJcbiAgICAgICAgICAgIC8vIHN3YXBcclxuICAgICAgICAgICAgYi5sZWZ0ID0gYTtcclxuICAgICAgICAgICAgYi5wYXJlbnQgPSBhLnBhcmVudDtcclxuICAgICAgICAgICAgYS5wYXJlbnQgPSBiO1xyXG4gICAgICAgICAgICAvLyBub2RlJ3Mgb2xkIHBhcmVudCBzaG91bGQgcG9pbnQgdG8gYlxyXG4gICAgICAgICAgICBpZiAoYi5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudC5sZWZ0ID09PSBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5wYXJlbnQubGVmdCA9IGI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYi5wYXJlbnQucmlnaHQgIT09IGEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgJ0Vycm9yIHJvdGF0aW5nIER5bmFtaWMgVHJlZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGIucGFyZW50LnJpZ2h0ID0gYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucm9vdCA9IGI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcm90YXRlXHJcbiAgICAgICAgICAgIGlmIChkLmhlaWdodCA+IGUuaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBiLnJpZ2h0ID0gZDtcclxuICAgICAgICAgICAgICAgIGEubGVmdCA9IGU7XHJcbiAgICAgICAgICAgICAgICBlLnBhcmVudCA9IGE7XHJcbiAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGMuYm91bmRzLmNvbWJpbmUoZS5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgYi5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGQuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGMuaGVpZ2h0LCBlLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBiLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZC5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgYi5yaWdodCA9IGU7XHJcbiAgICAgICAgICAgICAgICBhLmxlZnQgPSBkO1xyXG4gICAgICAgICAgICAgICAgZC5wYXJlbnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBjLmJvdW5kcy5jb21iaW5lKGQuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGIuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShlLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChjLmhlaWdodCwgZC5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgYi5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGludGVybmFsIGhlaWdodCBvZiB0aGUgdHJlZSwgc2hvcnRlciB0cmVlcyBhcmUgYmV0dGVyLiBQZXJmb3JtYW5jZSBkcm9wcyBhcyB0aGUgdHJlZSBncm93c1xyXG4gICAgICovXHJcbiAgICBnZXRIZWlnaHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFF1ZXJpZXMgdGhlIER5bmFtaWMgQXhpcyBBbGlnbmVkIFRyZWUgZm9yIGJvZGllcyB0aGF0IGNvdWxkIGJlIGNvbGxpZGluZyB3aXRoIHRoZSBwcm92aWRlZCBib2R5LlxyXG4gICAgICpcclxuICAgICAqIEluIHRoZSBxdWVyeSBjYWxsYmFjaywgaXQgd2lsbCBiZSBwYXNzZWQgYSBwb3RlbnRpYWwgY29sbGlkZXIuIFJldHVybmluZyB0cnVlIGZyb20gdGhpcyBjYWxsYmFjayBpbmRpY2F0ZXNcclxuICAgICAqIHRoYXQgeW91IGFyZSBjb21wbGV0ZSB3aXRoIHlvdXIgcXVlcnkgYW5kIHlvdSBkbyBub3Qgd2FudCB0byBjb250aW51ZS4gUmV0dXJuaW5nIGZhbHNlIHdpbGwgY29udGludWUgc2VhcmNoaW5nXHJcbiAgICAgKiB0aGUgdHJlZSB1bnRpbCBhbGwgcG9zc2libGUgY29sbGlkZXJzIGhhdmUgYmVlbiByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgcXVlcnkoY29sbGlkZXIsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgYm91bmRzID0gY29sbGlkZXIuYm91bmRzO1xyXG4gICAgICAgIGNvbnN0IGhlbHBlciA9IChjdXJyZW50Tm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUuYm91bmRzLmludGVyc2VjdChib3VuZHMpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkgJiYgY3VycmVudE5vZGUuZGF0YSAhPT0gY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChjb2xsaWRlciwgY3VycmVudE5vZGUuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KSB8fCBoZWxwZXIoY3VycmVudE5vZGUucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGhlbHBlcih0aGlzLnJvb3QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBRdWVyaWVzIHRoZSBEeW5hbWljIEF4aXMgQWxpZ25lZCBUcmVlIGZvciBib2RpZXMgdGhhdCBjb3VsZCBiZSBpbnRlcnNlY3RpbmcuIEJ5IGRlZmF1bHQgdGhlIHJheWNhc3QgcXVlcnkgdXNlcyBhbiBpbmZpbml0ZWx5XHJcbiAgICAgKiBsb25nIHJheSB0byB0ZXN0IHRoZSB0cmVlIHNwZWNpZmllZCBieSBgbWF4YC5cclxuICAgICAqXHJcbiAgICAgKiBJbiB0aGUgcXVlcnkgY2FsbGJhY2ssIGl0IHdpbGwgYmUgcGFzc2VkIGEgcG90ZW50aWFsIGJvZHkgdGhhdCBpbnRlcnNlY3RzIHdpdGggdGhlIHJheWNhc3QuIFJldHVybmluZyB0cnVlIGZyb20gdGhpc1xyXG4gICAgICogY2FsbGJhY2sgaW5kaWNhdGVzIHRoYXQgeW91ciBhcmUgY29tcGxldGUgd2l0aCB5b3VyIHF1ZXJ5IGFuZCBkbyBub3Qgd2FudCB0byBjb250aW51ZS4gUmV0dXJuIGZhbHNlIHdpbGwgY29udGludWUgc2VhcmNoaW5nXHJcbiAgICAgKiB0aGUgdHJlZSB1bnRpbCBhbGwgcG9zc2libGUgYm9kaWVzIHRoYXQgd291bGQgaW50ZXJzZWN0IHdpdGggdGhlIHJheSBoYXZlIGJlZW4gcmV0dXJuZWQuXHJcbiAgICAgKi9cclxuICAgIHJheUNhc3RRdWVyeShyYXksIG1heCA9IEluZmluaXR5LCBjYWxsYmFjaykge1xyXG4gICAgICAgIGNvbnN0IGhlbHBlciA9IChjdXJyZW50Tm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUgJiYgY3VycmVudE5vZGUuYm91bmRzLnJheUNhc3QocmF5LCBtYXgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2suY2FsbChyYXksIGN1cnJlbnROb2RlLmRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJheSBoaXQgYSBsZWFmISByZXR1cm4gdGhlIGJvZHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmF5IGhpdCBidXQgbm90IGF0IGEgbGVhZiwgcmVjdXJzZSBkZWVwZXJcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpIHx8IGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyByYXkgbWlzc2VkXHJcbiAgICAgICAgfTtcclxuICAgICAgICBoZWxwZXIodGhpcy5yb290KTtcclxuICAgIH1cclxuICAgIGdldE5vZGVzKCkge1xyXG4gICAgICAgIGNvbnN0IGhlbHBlciA9IChjdXJyZW50Tm9kZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbY3VycmVudE5vZGVdLmNvbmNhdChoZWxwZXIoY3VycmVudE5vZGUubGVmdCksIGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gaGVscGVyKHRoaXMucm9vdCk7XHJcbiAgICB9XHJcbiAgICBkZWJ1ZyhleCkge1xyXG4gICAgICAgIC8vIGRyYXcgYWxsIHRoZSBub2RlcyBpbiB0aGUgRHluYW1pYyBUcmVlXHJcbiAgICAgICAgY29uc3QgaGVscGVyID0gKGN1cnJlbnROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLmlzTGVhZigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzLmRyYXcoZXgsIENvbG9yLkdyZWVuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcy5kcmF3KGV4LCBDb2xvci5XaGl0ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUubGVmdCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5yaWdodCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIGhlbHBlcih0aGlzLnJvb3QpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTWF0aC9yYXkudHNcbi8qKlxyXG4gKiBBIDJEIHJheSB0aGF0IGNhbiBiZSBjYXN0IGludG8gdGhlIHNjZW5lIHRvIGRvIGNvbGxpc2lvbiBkZXRlY3Rpb25cclxuICovXHJcbmNsYXNzIFJheSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwb3MgVGhlIHN0YXJ0aW5nIHBvc2l0aW9uIGZvciB0aGUgcmF5XHJcbiAgICAgKiBAcGFyYW0gZGlyIFRoZSB2ZWN0b3IgaW5kaWNhdGluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSByYXlcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocG9zLCBkaXIpIHtcclxuICAgICAgICB0aGlzLnBvcyA9IHBvcztcclxuICAgICAgICB0aGlzLmRpciA9IGRpci5ub3JtYWxpemUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgYSB3aGV0aGVyIHRoaXMgcmF5IGludGVyc2VjdHMgd2l0aCBhIGxpbmUgc2VnbWVudC4gUmV0dXJucyBhIG51bWJlciBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gMCBvbiBzdWNjZXNzLlxyXG4gICAgICogVGhpcyBudW1iZXIgaW5kaWNhdGVzIHRoZSBtYXRoZW1hdGljYWwgaW50ZXJzZWN0aW9uIHRpbWUuXHJcbiAgICAgKiBAcGFyYW0gbGluZSAgVGhlIGxpbmUgdG8gdGVzdFxyXG4gICAgICovXHJcbiAgICBpbnRlcnNlY3QobGluZSkge1xyXG4gICAgICAgIGNvbnN0IG51bWVyYXRvciA9IGxpbmUuYmVnaW4uc3ViKHRoaXMucG9zKTtcclxuICAgICAgICAvLyBUZXN0IGlzIGxpbmUgYW5kIHJheSBhcmUgcGFyYWxsZWwgYW5kIG5vbiBpbnRlcnNlY3RpbmdcclxuICAgICAgICBpZiAodGhpcy5kaXIuY3Jvc3MobGluZS5nZXRTbG9wZSgpKSA9PT0gMCAmJiBudW1lcmF0b3IuY3Jvc3ModGhpcy5kaXIpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAtMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTGluZXMgYXJlIHBhcmFsbGVsXHJcbiAgICAgICAgY29uc3QgZGl2aXNvciA9IHRoaXMuZGlyLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSk7XHJcbiAgICAgICAgaWYgKGRpdmlzb3IgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0ID0gbnVtZXJhdG9yLmNyb3NzKGxpbmUuZ2V0U2xvcGUoKSkgLyBkaXZpc29yO1xyXG4gICAgICAgIGlmICh0ID49IDApIHtcclxuICAgICAgICAgICAgY29uc3QgdSA9IG51bWVyYXRvci5jcm9zcyh0aGlzLmRpcikgLyBkaXZpc29yIC8gbGluZS5nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgaWYgKHUgPj0gMCAmJiB1IDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGludGVyc2VjdFBvaW50KGxpbmUpIHtcclxuICAgICAgICBjb25zdCB0aW1lID0gdGhpcy5pbnRlcnNlY3QobGluZSk7XHJcbiAgICAgICAgaWYgKHRpbWUgPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRQb2ludCh0aW1lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcG9pbnQgb2YgaW50ZXJzZWN0aW9uIGdpdmVuIHRoZSBpbnRlcnNlY3Rpb24gdGltZVxyXG4gICAgICovXHJcbiAgICBnZXRQb2ludCh0aW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zLmFkZCh0aGlzLmRpci5zY2FsZSh0aW1lKSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vRGV0ZWN0aW9uL0R5bmFtaWNUcmVlQ29sbGlzaW9uUHJvY2Vzc29yLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVzcG9uc2libGUgZm9yIHBlcmZvcm1pbmcgdGhlIGNvbGxpc2lvbiBicm9hZHBoYXNlIChsb2NhdGluZyBwb3RlbnRpYWwgY29sbGxpc2lvbnMpIGFuZFxyXG4gKiB0aGUgbmFycm93cGhhc2UgKGFjdHVhbCBjb2xsaXNpb24gY29udGFjdHMpXHJcbiAqL1xyXG5jbGFzcyBEeW5hbWljVHJlZUNvbGxpc2lvblByb2Nlc3NvciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZSA9IG5ldyBEeW5hbWljVHJlZSgpO1xyXG4gICAgICAgIHRoaXMuX2NvbGxpc2lvbnMgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlID0gW107XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXJzID0gW107XHJcbiAgICB9XHJcbiAgICBnZXRDb2xsaWRlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxpZGVycztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhY2tzIGEgcGh5c2ljcyBib2R5IGZvciBjb2xsaXNpb25zXHJcbiAgICAgKi9cclxuICAgIHRyYWNrKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0Nhbm5vdCB0cmFjayBudWxsIGNvbGxpZGVyJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIENvbXBvc2l0ZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRhcmdldC5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICAgICAgYy5vd25lciA9IHRhcmdldC5vd25lcjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVycy5wdXNoKGMpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudHJhY2tDb2xsaWRlcihjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlkZXJzLnB1c2godGFyZ2V0KTtcclxuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudHJhY2tDb2xsaWRlcih0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW50cmFja3MgYSBwaHlzaWNzIGJvZHlcclxuICAgICAqL1xyXG4gICAgdW50cmFjayh0YXJnZXQpIHtcclxuICAgICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdDYW5ub3QgdW50cmFjayBhIG51bGwgY29sbGlkZXInKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQ29tcG9zaXRlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGFyZ2V0LmdldENvbGxpZGVycygpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NvbGxpZGVycy5pbmRleE9mKGMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudW50cmFja0NvbGxpZGVyKGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NvbGxpZGVycy5pbmRleE9mKHRhcmdldCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVycy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnVudHJhY2tDb2xsaWRlcih0YXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zaG91bGRHZW5lcmF0ZUNvbGxpc2lvblBhaXIoY29sbGlkZXJBLCBjb2xsaWRlckIpIHtcclxuICAgICAgICAvLyBpZiB0aGUgY29sbGlzaW9uIHBhaXIgbXVzdCBiZSAyIHNlcGFyYXRlIGNvbGxpZGVyc1xyXG4gICAgICAgIC8vIEFsc28gc2VwYXJhdGUgb3duZXJzIGZvciBjb21wb3NpdGUgY29sbGlkZXJzXHJcbiAgICAgICAgaWYgKChjb2xsaWRlckEuaWQgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgY29sbGlkZXJCLmlkICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgIGNvbGxpZGVyQS5pZCA9PT0gY29sbGlkZXJCLmlkKSB8fFxyXG4gICAgICAgICAgICAoY29sbGlkZXJBLm93bmVyICE9PSBudWxsICYmXHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlckIub3duZXIgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQS5vd25lciA9PT0gY29sbGlkZXJCLm93bmVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSBjb2xsaXNpb24gcGFpciBoYXMgYmVlbiBjYWxjdWxhdGVkIGFscmVhZHkgc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgIGNvbnN0IGhhc2ggPSBQYWlyLmNhbGN1bGF0ZVBhaXJIYXNoKGNvbGxpZGVyQS5pZCwgY29sbGlkZXJCLmlkKTtcclxuICAgICAgICBpZiAodGhpcy5fY29sbGlzaW9ucy5oYXMoaGFzaCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBwYWlyIGV4aXN0cyBlYXN5IGV4aXQgcmV0dXJuIGZhbHNlXHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSBwYWlyIGhhcyBhIG1lbWJlciB3aXRoIHplcm8gZGltZW5zaW9uXHJcbiAgICAgICAgaWYgKGNvbGxpZGVyQS5sb2NhbEJvdW5kcy5oYXNaZXJvRGltZW5zaW9ucygpIHx8IGNvbGxpZGVyQi5sb2NhbEJvdW5kcy5oYXNaZXJvRGltZW5zaW9ucygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFBhaXIuY2FuQ29sbGlkZShjb2xsaWRlckEsIGNvbGxpZGVyQik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERldGVjdHMgcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlycyBpbiBhIGJyb2FkcGhhc2UgYXBwcm9hY2ggd2l0aCB0aGUgZHluYW1pYyBhYWJiIHRyZWUgc3RyYXRlZ3lcclxuICAgICAqL1xyXG4gICAgYnJvYWRwaGFzZSh0YXJnZXRzLCBkZWx0YSwgc3RhdHMpIHtcclxuICAgICAgICBjb25zdCBzZWNvbmRzID0gZGVsdGEgLyAxMDAwO1xyXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBsaXN0IG9mIHBvdGVudGlhbCBjb2xsaWRlcnMsIGV4Y2x1ZGUga2lsbGVkLCBwcmV2ZW50ZWQsIGFuZCBzZWxmXHJcbiAgICAgICAgY29uc3QgcG90ZW50aWFsQ29sbGlkZXJzID0gdGFyZ2V0cy5maWx0ZXIoKG90aGVyKSA9PiB7XHJcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvZHkgPSAoX2EgPSBvdGhlci5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuICgoX2IgPSBvdGhlci5vd25lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFjdGl2ZSkgJiYgYm9keS5jb2xsaXNpb25UeXBlICE9PSBDb2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gY2xlYXIgb2xkIGxpc3Qgb2YgY29sbGlzaW9uIHBhaXJzXHJcbiAgICAgICAgdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlID0gW107XHJcbiAgICAgICAgdGhpcy5fY29sbGlzaW9ucy5jbGVhcigpO1xyXG4gICAgICAgIC8vIGNoZWNrIGZvciBub3JtYWwgY29sbGlzaW9uIHBhaXJzXHJcbiAgICAgICAgbGV0IGNvbGxpZGVyO1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwLCBsID0gcG90ZW50aWFsQ29sbGlkZXJzLmxlbmd0aDsgaiA8IGw7IGorKykge1xyXG4gICAgICAgICAgICBjb2xsaWRlciA9IHBvdGVudGlhbENvbGxpZGVyc1tqXTtcclxuICAgICAgICAgICAgLy8gUXVlcnkgdGhlIGNvbGxpc2lvbiB0cmVlIGZvciBwb3RlbnRpYWwgY29sbGlkZXJzXHJcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnF1ZXJ5KGNvbGxpZGVyLCAob3RoZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG91bGRHZW5lcmF0ZUNvbGxpc2lvblBhaXIoY29sbGlkZXIsIG90aGVyKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihjb2xsaWRlciwgb3RoZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvbnMuYWRkKHBhaXIuaWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblBhaXJDYWNoZS5wdXNoKHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIHJldHVybiBmYWxzZSwgdG8gcXVlcnkgd2hvbGUgdHJlZS4gUmV0dXJuaW5nIHRydWUgaW4gdGhlIHF1ZXJ5IG1ldGhvZCBzdG9wcyBzZWFyY2hpbmdcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0cykge1xyXG4gICAgICAgICAgICBzdGF0cy5waHlzaWNzLnBhaXJzID0gdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2hlY2sgZHluYW1pYyB0cmVlIGZvciBmYXN0IG1vdmluZyBvYmplY3RzXHJcbiAgICAgICAgLy8gRmFzdCBtb3Zpbmcgb2JqZWN0cyBhcmUgdGhvc2UgbW92aW5nIGF0IGxlYXN0IHRoZXJlIHNtYWxsZXN0IGJvdW5kIHBlciBmcmFtZVxyXG4gICAgICAgIGlmIChQaHlzaWNzLmNoZWNrRm9yRmFzdEJvZGllcykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIHBvdGVudGlhbENvbGxpZGVycykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IGNvbGxpZGVyLm93bmVyLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIC8vIFNraXAgbm9uLWFjdGl2ZSBvYmplY3RzLiBEb2VzIG5vdCBtYWtlIHNlbnNlIG9uIG90aGVyIGNvbGxpc2lvbiB0eXBlc1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHkuY29sbGlzaW9uVHlwZSAhPT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIE1heGltdW0gdHJhdmVsIGRpc3RhbmNlIG5leHQgZnJhbWVcclxuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZURpc3RhbmNlID0gYm9keS52ZWwuc2l6ZSAqIHNlY29uZHMgKyAvLyB2ZWxvY2l0eSB0ZXJtXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keS5hY2Muc2l6ZSAqIDAuNSAqIHNlY29uZHMgKiBzZWNvbmRzOyAvLyBhY2MgdGVybVxyXG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgbWluaW11bSBkaW1lbnNpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IG1pbkRpbWVuc2lvbiA9IE1hdGgubWluKGNvbGxpZGVyLmJvdW5kcy5oZWlnaHQsIGNvbGxpZGVyLmJvdW5kcy53aWR0aCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoUGh5c2ljcy5kaXNhYmxlTWluaW11bVNwZWVkRm9yRmFzdEJvZHkgfHwgdXBkYXRlRGlzdGFuY2UgPiBtaW5EaW1lbnNpb24gLyAyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnBoeXNpY3MuZmFzdEJvZGllcysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBzdGFydCB3aXRoIHRoZSBvbGRQb3MgYmVjYXVzZSB0aGUgaW50ZWdyYXRpb24gZm9yIGFjdG9ycyBoYXMgYWxyZWFkeSBoYXBwZW5lZFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgcmVzdGluZyBvbiBhIHN1cmZhY2UgbWF5IGJlIHNsaWdodGx5IHBlbmV0cmF0aW5nIGluIHRoZSBjdXJyZW50IHBvc2l0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlVmVjID0gYm9keS5wb3Muc3ViKGJvZHkub2xkUG9zKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJQb2ludCA9IGNvbGxpZGVyLmNlbnRlcjtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmdXJ0aGVzdFBvaW50ID0gY29sbGlkZXIuZ2V0RnVydGhlc3RQb2ludChib2R5LnZlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gZnVydGhlc3RQb2ludC5zdWIodXBkYXRlVmVjKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXkgPSBuZXcgUmF5KG9yaWdpbiwgYm9keS52ZWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGJhY2sgdGhlIHJheSB1cCBieSAtMnggc3VyZmFjZUVwc2lsb24gdG8gYWNjb3VudCBmb3IgZmFzdCBtb3Zpbmcgb2JqZWN0cyBzdGFydGluZyBvbiB0aGUgc3VyZmFjZVxyXG4gICAgICAgICAgICAgICAgICAgIHJheS5wb3MgPSByYXkucG9zLmFkZChyYXkuZGlyLnNjYWxlKC0yICogUGh5c2ljcy5zdXJmYWNlRXBzaWxvbikpO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW5Db2xsaWRlcjtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgbWluVHJhbnNsYXRlID0gbmV3IFZlY3RvcihJbmZpbml0eSwgSW5maW5pdHkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnJheUNhc3RRdWVyeShyYXksIHVwZGF0ZURpc3RhbmNlICsgUGh5c2ljcy5zdXJmYWNlRXBzaWxvbiAqIDIsIChvdGhlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlkZXIgIT09IG90aGVyICYmIFBhaXIuY2FuQ29sbGlkZShjb2xsaWRlciwgb3RoZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoaXRQb2ludCA9IG90aGVyLnJheUNhc3QocmF5LCB1cGRhdGVEaXN0YW5jZSArIFBoeXNpY3Muc3VyZmFjZUVwc2lsb24gKiAxMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGl0UG9pbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGUgPSBoaXRQb2ludC5zdWIob3JpZ2luKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRlLnNpemUgPCBtaW5UcmFuc2xhdGUuc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5UcmFuc2xhdGUgPSB0cmFuc2xhdGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvbGxpZGVyID0gb3RoZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWluQ29sbGlkZXIgJiYgVmVjdG9yLmlzVmFsaWQobWluVHJhbnNsYXRlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYWlyID0gbmV3IFBhaXIoY29sbGlkZXIsIG1pbkNvbGxpZGVyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jb2xsaXNpb25zLmhhcyhwYWlyLmlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9ucy5hZGQocGFpci5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUucHVzaChwYWlyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3ZlIHRoZSBmYXN0IG1vdmluZyBvYmplY3QgdG8gdGhlIG90aGVyIGJvZHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBwdXNoIGludG8gdGhlIHN1cmZhY2UgYnkgZXguUGh5c2ljcy5zdXJmYWNlRXBzaWxvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaGlmdCA9IGNlbnRlclBvaW50LnN1YihmdXJ0aGVzdFBvaW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keS5wb3MgPSBvcmlnaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGQoc2hpZnQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYWRkKG1pblRyYW5zbGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGQocmF5LmRpci5zY2FsZSgxMCAqIFBoeXNpY3Muc3VyZmFjZUVwc2lsb24pKTsgLy8gbmVlZGVkIHRvIHB1c2ggdGhlIHNoYXBlIHNsaWdodGx5IGludG8gY29udGFjdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaWRlci51cGRhdGUoYm9keS50cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRzLnBoeXNpY3MuZmFzdEJvZHlDb2xsaXNpb25zKys7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmV0dXJuIGNhY2hlXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxpc2lvblBhaXJDYWNoZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyBuYXJyb3cgcGhhc2Ugb24gY29sbGlzaW9uIHBhaXJzIHRvIGZpbmQgYWN0dWFsIGFyZWEgaW50ZXJzZWN0aW9uc1xyXG4gICAgICogQWRkcyBhY3R1YWwgY29sbGlkaW5nIHBhaXJzIHRvIHN0YXRzJyBGcmFtZSBkYXRhXHJcbiAgICAgKi9cclxuICAgIG5hcnJvd3BoYXNlKHBhaXJzLCBzdGF0cykge1xyXG4gICAgICAgIGxldCBjb250YWN0cyA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgbmV3Q29udGFjdHMgPSBwYWlyc1tpXS5jb2xsaWRlKCk7XHJcbiAgICAgICAgICAgIGNvbnRhY3RzID0gY29udGFjdHMuY29uY2F0KG5ld0NvbnRhY3RzKTtcclxuICAgICAgICAgICAgaWYgKHN0YXRzICYmIG5ld0NvbnRhY3RzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBuZXdDb250YWN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0YXRzLnBoeXNpY3MuY29udGFjdHMuc2V0KGMuaWQsIGMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzdGF0cykge1xyXG4gICAgICAgICAgICBzdGF0cy5waHlzaWNzLmNvbGxpc2lvbnMgKz0gY29udGFjdHMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udGFjdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgZHluYW1pYyB0cmVlIHBvc2l0aW9uc1xyXG4gICAgICovXHJcbiAgICB1cGRhdGUodGFyZ2V0cykge1xyXG4gICAgICAgIGxldCB1cGRhdGVkID0gMDtcclxuICAgICAgICBjb25zdCBsZW4gPSB0YXJnZXRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS51cGRhdGVDb2xsaWRlcih0YXJnZXRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgdXBkYXRlZCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB1cGRhdGVkO1xyXG4gICAgfVxyXG4gICAgZGVidWcoZXgpIHtcclxuICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS5kZWJ1ZyhleCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQ29sbGlkZXJzL0NvbGxpZGVyLnRzXG5cclxuXHJcbi8qKlxyXG4gKiBBIGNvbGxpc2lvbiBjb2xsaWRlciBzcGVjaWZpZXMgdGhlIGdlb21ldHJ5IHRoYXQgY2FuIGRldGVjdCB3aGVuIG90aGVyIGNvbGxpc2lvbiBjb2xsaWRlcnMgaW50ZXJzZWN0XHJcbiAqIGZvciB0aGUgcHVycG9zZXMgb2YgY29sbGlkaW5nIDIgb2JqZWN0cyBpbiBleGNhbGlidXIuXHJcbiAqL1xyXG5jbGFzcyBDb2xsaWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmlkID0gY3JlYXRlSWQoJ2NvbGxpZGVyJywgQ29sbGlkZXIuX0lEKyspO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcih0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoaXMgYm9keSBjb2xsaWRlZCB3aXRoXHJcbiAgICAgKiBvciB3YXMgaW4gc3RhdGlvbmFyeSBjb250YWN0IHdpdGhcclxuICAgICAqIHRoZSBib2R5IG9mIHRoZSBvdGhlciBbW0NvbGxpZGVyXV1cclxuICAgICAqL1xyXG4gICAgdG91Y2hpbmcob3RoZXIpIHtcclxuICAgICAgICBjb25zdCBjb250YWN0ID0gdGhpcy5jb2xsaWRlKG90aGVyKTtcclxuICAgICAgICBpZiAoY29udGFjdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG59XHJcbkNvbGxpZGVyLl9JRCA9IDA7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpZGVycy9Db21wb3NpdGVDb2xsaWRlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBDb21wb3NpdGVDb2xsaWRlciBleHRlbmRzIENvbGxpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbGxpZGVycykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fY29sbGlzaW9uUHJvY2Vzc29yID0gbmV3IER5bmFtaWNUcmVlQ29sbGlzaW9uUHJvY2Vzc29yKCk7XHJcbiAgICAgICAgdGhpcy5fZHluYW1pY0FBQkJUcmVlID0gbmV3IER5bmFtaWNUcmVlKCk7XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENvbGxpZGVyKGMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFyQ29sbGlkZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbGxpZGVycyA9IFtdO1xyXG4gICAgfVxyXG4gICAgYWRkQ29sbGlkZXIoY29sbGlkZXIpIHtcclxuICAgICAgICB0aGlzLmV2ZW50cy53aXJlKGNvbGxpZGVyLmV2ZW50cyk7XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXJzLnB1c2goY29sbGlkZXIpO1xyXG4gICAgICAgIHRoaXMuX2NvbGxpc2lvblByb2Nlc3Nvci50cmFjayhjb2xsaWRlcik7XHJcbiAgICAgICAgdGhpcy5fZHluYW1pY0FBQkJUcmVlLnRyYWNrQ29sbGlkZXIoY29sbGlkZXIpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ29sbGlkZXIoY29sbGlkZXIpIHtcclxuICAgICAgICB0aGlzLmV2ZW50cy51bndpcmUoY29sbGlkZXIuZXZlbnRzKTtcclxuICAgICAgICByZW1vdmVJdGVtRnJvbUFycmF5KGNvbGxpZGVyLCB0aGlzLl9jb2xsaWRlcnMpO1xyXG4gICAgICAgIHRoaXMuX2NvbGxpc2lvblByb2Nlc3Nvci51bnRyYWNrKGNvbGxpZGVyKTtcclxuICAgICAgICB0aGlzLl9keW5hbWljQUFCQlRyZWUudW50cmFja0NvbGxpZGVyKGNvbGxpZGVyKTtcclxuICAgIH1cclxuICAgIGdldENvbGxpZGVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlkZXJzO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdvcmxkUG9zKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgLy8gVE9ETyB0cmFuc2Zvcm0gY29tcG9uZW50IHdvcmxkIHBvc1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFZlY3Rvci5aZXJvO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNlbnRlcigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFZlY3Rvci5aZXJvO1xyXG4gICAgfVxyXG4gICAgZ2V0IGJvdW5kcygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIC8vIFRPRE8gY2FjaGUgdGhpc1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGNvbGxpZGVycy5yZWR1Y2UoKGFjYywgY29sbGlkZXIpID0+IGFjYy5jb21iaW5lKGNvbGxpZGVyLmJvdW5kcyksIChfYiA9IChfYSA9IGNvbGxpZGVyc1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJvdW5kcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEJvdW5kaW5nQm94KCkudHJhbnNsYXRlKHRoaXMud29ybGRQb3MpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIC8vIFRPRE8gY2FjaGUgdGhpc1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IGNvbGxpZGVycy5yZWR1Y2UoKGFjYywgY29sbGlkZXIpID0+IGFjYy5jb21iaW5lKGNvbGxpZGVyLmxvY2FsQm91bmRzKSwgKF9iID0gKF9hID0gY29sbGlkZXJzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxCb3VuZHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBCb3VuZGluZ0JveCgpKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuICAgIGdldCBheGVzKCkge1xyXG4gICAgICAgIC8vIFRPRE8gY2FjaGUgdGhpc1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgbGV0IGF4ZXMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBheGVzID0gYXhlcy5jb25jYXQoY29sbGlkZXIuYXhlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBheGVzO1xyXG4gICAgfVxyXG4gICAgZ2V0RnVydGhlc3RQb2ludChkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBjb2xsaWRlcnMgPSB0aGlzLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgIGNvbnN0IGZ1cnRoZXN0UG9pbnRzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBjb2xsaWRlciBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgZnVydGhlc3RQb2ludHMucHVzaChjb2xsaWRlci5nZXRGdXJ0aGVzdFBvaW50KGRpcmVjdGlvbikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQaWNrIGJlc3QgcG9pbnQgZnJvbSBhbGwgY29sbGlkZXJzXHJcbiAgICAgICAgbGV0IGJlc3RQb2ludCA9IGZ1cnRoZXN0UG9pbnRzWzBdO1xyXG4gICAgICAgIGxldCBtYXhEaXN0YW5jZSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgZnVydGhlc3RQb2ludHMpIHtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBwb2ludC5kb3QoZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbWF4RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RQb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmVzdFBvaW50O1xyXG4gICAgfVxyXG4gICAgZ2V0SW5lcnRpYShtYXNzKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBsZXQgdG90YWxJbmVydGlhID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICB0b3RhbEluZXJ0aWEgKz0gY29sbGlkZXIuZ2V0SW5lcnRpYShtYXNzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRvdGFsSW5lcnRpYTtcclxuICAgIH1cclxuICAgIGNvbGxpZGUob3RoZXIpIHtcclxuICAgICAgICBsZXQgb3RoZXJDb2xsaWRlcnMgPSBbb3RoZXJdO1xyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIG90aGVyQ29sbGlkZXJzID0gb3RoZXIuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIG90aGVyQ29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2R5bmFtaWNBQUJCVHJlZS5xdWVyeShjLCAocG90ZW50aWFsQ29sbGlkZXIpID0+IHtcclxuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2gobmV3IFBhaXIoYywgcG90ZW50aWFsQ29sbGlkZXIpKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBjb250YWN0cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgcCBvZiBwYWlycykge1xyXG4gICAgICAgICAgICBjb250YWN0cyA9IGNvbnRhY3RzLmNvbmNhdChwLmNvbGxpZGUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250YWN0cztcclxuICAgIH1cclxuICAgIGdldENsb3Nlc3RMaW5lQmV0d2VlbihvdGhlcikge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgbGluZXMgPSBbXTtcclxuICAgICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBvdGhlckNvbGxpZGVycyA9IG90aGVyLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyQSBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29sbGlkZXJCIG9mIG90aGVyQ29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF5YmVMaW5lID0gY29sbGlkZXJBLmdldENsb3Nlc3RMaW5lQmV0d2Vlbihjb2xsaWRlckIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXliZUxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChtYXliZUxpbmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjb2xsaWRlciBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1heWJlTGluZSA9IG90aGVyLmdldENsb3Nlc3RMaW5lQmV0d2Vlbihjb2xsaWRlcik7XHJcbiAgICAgICAgICAgICAgICBpZiAobWF5YmVMaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGluZXMucHVzaChtYXliZUxpbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgbGV0IG1pbkxlbmd0aCA9IGxpbmVzWzBdLmdldExlbmd0aCgpO1xyXG4gICAgICAgICAgICBsZXQgbWluTGluZSA9IGxpbmVzWzBdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IGxpbmUuZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoIDwgbWluTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluTGVuZ3RoID0gbGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkxpbmUgPSBsaW5lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBtaW5MaW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIGNvbnRhaW5zKHBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBpZiAoY29sbGlkZXIuY29udGFpbnMocG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByYXlDYXN0KHJheSwgbWF4KSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBjb25zdCB2ZWMgPSBjb2xsaWRlci5yYXlDYXN0KHJheSwgbWF4KTtcclxuICAgICAgICAgICAgaWYgKHZlYykge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRzLnB1c2godmVjKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgbWluUG9pbnQgPSBwb2ludHNbMF07XHJcbiAgICAgICAgICAgIGxldCBtaW5EaXN0YW5jZSA9IG1pblBvaW50LmRvdChyYXkuZGlyKTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBwb2ludHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gcmF5LmRpci5kb3QocG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5Qb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkRpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1pblBvaW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHByb2plY3QoYXhpcykge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgcHJvanMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9qID0gY29sbGlkZXIucHJvamVjdChheGlzKTtcclxuICAgICAgICAgICAgaWYgKHByb2opIHtcclxuICAgICAgICAgICAgICAgIHByb2pzLnB1c2gocHJvaik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWVyZ2UgYWxsIHByb2oncyBvbiB0aGUgc2FtZSBheGlzXHJcbiAgICAgICAgaWYgKHByb2pzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdQcm9qZWN0aW9uID0gbmV3IFByb2plY3Rpb24ocHJvanNbMF0ubWluLCBwcm9qc1swXS5tYXgpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb2ogb2YgcHJvanMpIHtcclxuICAgICAgICAgICAgICAgIG5ld1Byb2plY3Rpb24ubWluID0gTWF0aC5taW4ocHJvai5taW4sIG5ld1Byb2plY3Rpb24ubWluKTtcclxuICAgICAgICAgICAgICAgIG5ld1Byb2plY3Rpb24ubWF4ID0gTWF0aC5tYXgocHJvai5tYXgsIG5ld1Byb2plY3Rpb24ubWF4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3UHJvamVjdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlcnMgPSB0aGlzLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXIub3duZXIgPSB0aGlzLm93bmVyO1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXIudXBkYXRlKHRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkcmF3KGN0eCwgY29sb3IsIHBvcykge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb2xsaWRlciBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgY29sbGlkZXIuZHJhdyhjdHgsIGNvbG9yLCBwb3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlYnVnKGV4LCBjb2xvcikge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb2xsaWRlciBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgY29sbGlkZXIuZGVidWcoZXgsIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWJ1Z0RyYXcoY3R4LCBjb2xvcikge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb2xsaWRlciBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgY29sbGlkZXIuZHJhdyhjdHgsIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbXBvc2l0ZUNvbGxpZGVyKHRoaXMuX2NvbGxpZGVycy5tYXAoKGMpID0+IGMuY2xvbmUoKSkpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTWF0aC9saW5lLnRzXG5cclxuLyoqXHJcbiAqIEEgMkQgbGluZSBzZWdtZW50XHJcbiAqL1xyXG5jbGFzcyBMaW5lIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGJlZ2luICBUaGUgc3RhcnRpbmcgcG9pbnQgb2YgdGhlIGxpbmUgc2VnbWVudFxyXG4gICAgICogQHBhcmFtIGVuZCAgVGhlIGVuZGluZyBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICB0aGlzLmJlZ2luID0gYmVnaW47XHJcbiAgICAgICAgdGhpcy5lbmQgPSBlbmQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHJhdyBzbG9wZSAobSkgb2YgdGhlIGxpbmUuIFdpbGwgcmV0dXJuICgrLy0pSW5maW5pdHkgZm9yIHZlcnRpY2FsIGxpbmVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgc2xvcGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLmVuZC55IC0gdGhpcy5iZWdpbi55KSAvICh0aGlzLmVuZC54IC0gdGhpcy5iZWdpbi54KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgWS1pbnRlcmNlcHQgKGIpIG9mIHRoZSBsaW5lLiBXaWxsIHJldHVybiAoKy8tKUluZmluaXR5IGlmIHRoZXJlIGlzIG5vIGludGVyY2VwdC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGludGVyY2VwdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iZWdpbi55IC0gdGhpcy5zbG9wZSAqIHRoaXMuYmVnaW4ueDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbm9ybWFsIG9mIHRoZSBsaW5lXHJcbiAgICAgKi9cclxuICAgIG5vcm1hbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmQuc3ViKHRoaXMuYmVnaW4pLm5vcm1hbCgpO1xyXG4gICAgfVxyXG4gICAgZGlyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZC5zdWIodGhpcy5iZWdpbik7XHJcbiAgICB9XHJcbiAgICBnZXRQb2ludHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFt0aGlzLmJlZ2luLCB0aGlzLmVuZF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNsb3BlIG9mIHRoZSBsaW5lIGluIHRoZSBmb3JtIG9mIGEgdmVjdG9yIG9mIGxlbmd0aCAxXHJcbiAgICAgKi9cclxuICAgIGdldFNsb3BlKCkge1xyXG4gICAgICAgIGNvbnN0IGJlZ2luID0gdGhpcy5iZWdpbjtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmVuZDtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XHJcbiAgICAgICAgcmV0dXJuIGVuZC5zdWIoYmVnaW4pLnNjYWxlKDEgLyBkaXN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGVkZ2Ugb2YgdGhlIGxpbmUgYXMgdmVjdG9yLCB0aGUgbGVuZ3RoIG9mIHRoZSB2ZWN0b3IgaXMgdGhlIGxlbmd0aCBvZiB0aGUgZWRnZVxyXG4gICAgICovXHJcbiAgICBnZXRFZGdlKCkge1xyXG4gICAgICAgIGNvbnN0IGJlZ2luID0gdGhpcy5iZWdpbjtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmVuZDtcclxuICAgICAgICByZXR1cm4gZW5kLnN1YihiZWdpbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgbGluZSBzZWdtZW50IGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBnZXRMZW5ndGgoKSB7XHJcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuZW5kO1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1pZHBvaW50IG9mIHRoZSBlZGdlXHJcbiAgICAgKi9cclxuICAgIGdldCBtaWRwb2ludCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5iZWdpbi5hZGQodGhpcy5lbmQpLnNjYWxlKDAuNSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZsaXBzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxpbmUgc2VnbWVudFxyXG4gICAgICovXHJcbiAgICBmbGlwKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZSh0aGlzLmVuZCwgdGhpcy5iZWdpbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgZ2l2ZW4gcG9pbnQgaXMgYmVsb3cgdGhlIGxpbmUsIHBvaW50cyBpbiB0aGUgbm9ybWFsIGRpcmVjdGlvbiBhYm92ZSB0aGUgbGluZSBhcmUgY29uc2lkZXJlZCBhYm92ZS5cclxuICAgICAqIEBwYXJhbSBwb2ludFxyXG4gICAgICovXHJcbiAgICBiZWxvdyhwb2ludCkge1xyXG4gICAgICAgIGNvbnN0IGFib3ZlMiA9ICh0aGlzLmVuZC54IC0gdGhpcy5iZWdpbi54KSAqIChwb2ludC55IC0gdGhpcy5iZWdpbi55KSAtICh0aGlzLmVuZC55IC0gdGhpcy5iZWdpbi55KSAqIChwb2ludC54IC0gdGhpcy5iZWdpbi54KTtcclxuICAgICAgICByZXR1cm4gYWJvdmUyID49IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNsaXAgcG9pbnRcclxuICAgICAqIEBwYXJhbSBzaWRlVmVjdG9yIFZlY3RvciB0aGF0IHRyYWNlcyB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtIGxlbmd0aCBMZW5ndGggdG8gY2xpcCBhbG9uZyBzaWRlXHJcbiAgICAgKi9cclxuICAgIGNsaXAoc2lkZVZlY3RvciwgbGVuZ3RoKSB7XHJcbiAgICAgICAgbGV0IGRpciA9IHNpZGVWZWN0b3I7XHJcbiAgICAgICAgZGlyID0gZGlyLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGNvbnN0IG5lYXIgPSBkaXIuZG90KHRoaXMuYmVnaW4pIC0gbGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IGZhciA9IGRpci5kb3QodGhpcy5lbmQpIC0gbGVuZ3RoO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICBpZiAobmVhciA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmJlZ2luKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZhciA8PSAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmVuZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZWFyICogZmFyIDwgMCkge1xyXG4gICAgICAgICAgICBjb25zdCBjbGlwVGltZSA9IG5lYXIgLyAobmVhciAtIGZhcik7XHJcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh0aGlzLmJlZ2luLmFkZCh0aGlzLmVuZC5zdWIodGhpcy5iZWdpbikuc2NhbGUoY2xpcFRpbWUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXN1bHRzLmxlbmd0aCAhPT0gMikge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lKHJlc3VsdHNbMF0sIHJlc3VsdHNbMV0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBwZXJwZW5kaWN1bGFyIGRpc3RhbmNlIGZyb20gdGhlIGxpbmUgdG8gYSBwb2ludFxyXG4gICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZVxyXG4gICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgKi9cclxuICAgIGRpc3RhbmNlVG9Qb2ludChwb2ludCwgc2lnbmVkID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCB4MCA9IHBvaW50Lng7XHJcbiAgICAgICAgY29uc3QgeTAgPSBwb2ludC55O1xyXG4gICAgICAgIGNvbnN0IGwgPSB0aGlzLmdldExlbmd0aCgpO1xyXG4gICAgICAgIGNvbnN0IGR5ID0gdGhpcy5lbmQueSAtIHRoaXMuYmVnaW4ueTtcclxuICAgICAgICBjb25zdCBkeCA9IHRoaXMuZW5kLnggLSB0aGlzLmJlZ2luLng7XHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSAoZHkgKiB4MCAtIGR4ICogeTAgKyB0aGlzLmVuZC54ICogdGhpcy5iZWdpbi55IC0gdGhpcy5lbmQueSAqIHRoaXMuYmVnaW4ueCkgLyBsO1xyXG4gICAgICAgIHJldHVybiBzaWduZWQgPyBkaXN0YW5jZSA6IE1hdGguYWJzKGRpc3RhbmNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgcGVycGVuZGljdWxhciBsaW5lIGZyb20gdGhlIGxpbmUgdG8gYSBwb2ludFxyXG4gICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGlzdGFuY2VfZnJvbV9hX3BvaW50X3RvX2FfbGluZVxyXG4gICAgICogKGEgLSBwKSAtICgoYSAtIHApICogbiluXHJcbiAgICAgKiBhIGlzIGEgcG9pbnQgb24gdGhlIGxpbmVcclxuICAgICAqIHAgaXMgdGhlIGFyYml0cmFyeSBwb2ludCBhYm92ZSB0aGUgbGluZVxyXG4gICAgICogbiBpcyBhIHVuaXQgdmVjdG9yIGluIGRpcmVjdGlvbiBvZiB0aGUgbGluZVxyXG4gICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgKi9cclxuICAgIGZpbmRWZWN0b3JUb1BvaW50KHBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgYU1pbnVzUCA9IHRoaXMuYmVnaW4uc3ViKHBvaW50KTtcclxuICAgICAgICBjb25zdCBuID0gdGhpcy5nZXRTbG9wZSgpO1xyXG4gICAgICAgIHJldHVybiBhTWludXNQLnN1YihuLnNjYWxlKGFNaW51c1AuZG90KG4pKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIGEgcG9pbnQgb24gdGhlIGxpbmUgZ2l2ZW4gb25seSBhbiBYIG9yIGEgWSB2YWx1ZS4gR2l2ZW4gYW4gWCB2YWx1ZSwgdGhlIGZ1bmN0aW9uIHJldHVybnNcclxuICAgICAqIGEgbmV3IHBvaW50IHdpdGggdGhlIGNhbGN1bGF0ZWQgWSB2YWx1ZSBhbmQgdmljZS12ZXJzYS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0geCBUaGUga25vd24gWCB2YWx1ZSBvZiB0aGUgdGFyZ2V0IHBvaW50XHJcbiAgICAgKiBAcGFyYW0geSBUaGUga25vd24gWSB2YWx1ZSBvZiB0aGUgdGFyZ2V0IHBvaW50XHJcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBwb2ludCB3aXRoIHRoZSBvdGhlciBjYWxjdWxhdGVkIGF4aXMgdmFsdWVcclxuICAgICAqL1xyXG4gICAgZmluZFBvaW50KHggPSBudWxsLCB5ID0gbnVsbCkge1xyXG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLnNsb3BlO1xyXG4gICAgICAgIGNvbnN0IGIgPSB0aGlzLmludGVyY2VwdDtcclxuICAgICAgICBpZiAoeCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih4LCBtICogeCArIGIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKCh5IC0gYikgLyBtLCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IG11c3QgcHJvdmlkZSBhbiBYIG9yIGEgWSB2YWx1ZScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xMTkwODE1OC8xMDk0NThcclxuICAgICAqL1xyXG4gICAgaGFzUG9pbnQoKSB7XHJcbiAgICAgICAgbGV0IGN1cnJQb2ludDtcclxuICAgICAgICBsZXQgdGhyZXNob2xkID0gMDtcclxuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgY3VyclBvaW50ID0gbmV3IFZlY3Rvcihhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IGFyZ3VtZW50c1syXSB8fCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgY3VyclBvaW50ID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgICAgICB0aHJlc2hvbGQgPSBhcmd1bWVudHNbMV0gfHwgMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93ICdDb3VsZCBub3QgZGV0ZXJtaW5lIHRoZSBhcmd1bWVudHMgZm9yIFZlY3Rvci5oYXNQb2ludCc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGR4YyA9IGN1cnJQb2ludC54IC0gdGhpcy5iZWdpbi54O1xyXG4gICAgICAgIGNvbnN0IGR5YyA9IGN1cnJQb2ludC55IC0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgIGNvbnN0IGR4MSA9IHRoaXMuZW5kLnggLSB0aGlzLmJlZ2luLng7XHJcbiAgICAgICAgY29uc3QgZHkxID0gdGhpcy5lbmQueSAtIHRoaXMuYmVnaW4ueTtcclxuICAgICAgICBjb25zdCBjcm9zcyA9IGR4YyAqIGR5MSAtIGR5YyAqIGR4MTtcclxuICAgICAgICAvLyBjaGVjayB3aGV0aGVyIHBvaW50IGxpbmVzIG9uIHRoZSBsaW5lXHJcbiAgICAgICAgaWYgKE1hdGguYWJzKGNyb3NzKSA+IHRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgcG9pbnQgbGllcyBpbi1iZXR3ZWVuIHN0YXJ0IGFuZCBlbmRcclxuICAgICAgICBpZiAoTWF0aC5hYnMoZHgxKSA+PSBNYXRoLmFicyhkeTEpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkeDEgPiAwID8gdGhpcy5iZWdpbi54IDw9IGN1cnJQb2ludC54ICYmIGN1cnJQb2ludC54IDw9IHRoaXMuZW5kLnggOiB0aGlzLmVuZC54IDw9IGN1cnJQb2ludC54ICYmIGN1cnJQb2ludC54IDw9IHRoaXMuYmVnaW4ueDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBkeTEgPiAwID8gdGhpcy5iZWdpbi55IDw9IGN1cnJQb2ludC55ICYmIGN1cnJQb2ludC55IDw9IHRoaXMuZW5kLnkgOiB0aGlzLmVuZC55IDw9IGN1cnJQb2ludC55ICYmIGN1cnJQb2ludC55IDw9IHRoaXMuYmVnaW4ueTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQ29sbGlkZXJzL0Nsb3Nlc3RMaW5lSnVtcFRhYmxlLnRzXG5cclxuXHJcblxyXG4vKipcclxuICogRmluZHMgdGhlIGNsb3NlcyBsaW5lIGJldHdlZW4gMiBsaW5lIHNlZ21lbnRzLCB3ZXJlIHRoZSBtYWduaXR1ZGUgb2YgdSwgdiBhcmUgdGhlIGxlbmd0aHMgb2YgZWFjaCBzZWdtZW50XHJcbiAqIEwxID0gUChzKSA9IHAwICsgcyAqIHUsIHdoZXJlIHMgaXMgdGltZSBhbmQgcDAgaXMgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAqIEwyID0gUSh0KSA9IHEwICsgdCAqIHYsIHdoZXJlIHQgaXMgdGltZSBhbmQgcTAgaXMgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAqIEBwYXJhbSBwMCBQb2ludCB3aGVyZSBMMSBiZWdpbnNcclxuICogQHBhcmFtIHUgRGlyZWN0aW9uIGFuZCBsZW5ndGggb2YgTDFcclxuICogQHBhcmFtIHEwIFBvaW50IHdlcmUgTDIgYmVnaW5zXHJcbiAqIEBwYXJhbSB2IERpcmVjdGlvbiBhbmQgbGVuZ3RoIG9mIEwyXHJcbiAqL1xyXG5mdW5jdGlvbiBDbG9zZXN0TGluZShwMCwgdSwgcTAsIHYpIHtcclxuICAgIC8vIERpc3RhbmNlIGJldHdlZW4gMiBsaW5lcyBodHRwOi8vZ2VvbWFsZ29yaXRobXMuY29tL2EwNy1fZGlzdGFuY2UuaHRtbFxyXG4gICAgLy8gdyhzLCB0KSA9IFAocykgLSBRKHQpXHJcbiAgICAvLyBUaGUgdyhzLCB0KSB0aGF0IGhhcyB0aGUgbWluaW11bSBkaXN0YW5jZSB3ZSB3aWxsIHNheSBpcyB3KHNDbG9zZXN0LCB0Q2xvc2VzdCkgPSB3Q2xvc2VzdFxyXG4gICAgLy9cclxuICAgIC8vIHdDbG9zZXN0IGlzIHRoZSB2ZWN0b3IgdGhhdCBpcyB1bmlxdWVseSBwZXJwZW5kaWN1bGFyIHRvIHRoZSAyIGxpbmUgZGlyZWN0aW9ucyB1ICYgdi5cclxuICAgIC8vIHdDbG9zZXN0ID0gdzAgKyBzQ2xvc2VzdCAqIHUgLSB0Q2xvc2VzdCAqIHYsIHdoZXJlIHcwIGlzIHAwIC0gcTBcclxuICAgIC8vXHJcbiAgICAvLyBUaGUgY2xvc2VzdCBwb2ludCBiZXR3ZWVuIDIgbGluZXMgdGhlbiBzYXRpc2ZpZXMgdGhpcyBwYWlyIG9mIGVxdWF0aW9uc1xyXG4gICAgLy8gMTogdSAqIHdDbG9zZXN0ID0gMFxyXG4gICAgLy8gMjogdiAqIHdDbG9zZXN0ID0gMFxyXG4gICAgLy9cclxuICAgIC8vIFN1YnN0aXR1dGluZyB3Q2xvc2VzdCBpbnRvIHRoZSBlcXVhdGlvbnMgd2UgZ2V0XHJcbiAgICAvL1xyXG4gICAgLy8gMTogKHUgKiB1KSAqIHNDbG9zZXN0IC0gKHUgKiB2KSB0Q2xvc2VzdCA9IC11ICogdzBcclxuICAgIC8vIDI6ICh2ICogdSkgKiBzQ2xvc2VzdCAtICh2ICogdikgdENsb3Nlc3QgPSAtdiAqIHcwXHJcbiAgICAvLyBzaW1wbGlmeSB3MFxyXG4gICAgY29uc3QgdzAgPSBwMC5zdWIocTApO1xyXG4gICAgLy8gc2ltcGxpZnkgKHUgKiB1KTtcclxuICAgIGNvbnN0IGEgPSB1LmRvdCh1KTtcclxuICAgIC8vIHNpbXBsaWZ5ICh1ICogdik7XHJcbiAgICBjb25zdCBiID0gdS5kb3Qodik7XHJcbiAgICAvLyBzaW1wbGlmeSAodiAqIHYpXHJcbiAgICBjb25zdCBjID0gdi5kb3Qodik7XHJcbiAgICAvLyBzaW1wbGlmeSAodSAqIHcwKVxyXG4gICAgY29uc3QgZCA9IHUuZG90KHcwKTtcclxuICAgIC8vIHNpbXBsaWZ5ICh2ICogdzApXHJcbiAgICBjb25zdCBlID0gdi5kb3QodzApO1xyXG4gICAgLy8gZGVub21pbmF0b3IgYWMgLSBiXjJcclxuICAgIGNvbnN0IGRlbm9tID0gYSAqIGMgLSBiICogYjtcclxuICAgIGxldCBzRGVub20gPSBkZW5vbTtcclxuICAgIGxldCB0RGVub20gPSBkZW5vbTtcclxuICAgIC8vIGlmIGRlbm9tIGlzIDAgdGhleSBhcmUgcGFyYWxsZWwsIHVzZSBhbnkgcG9pbnQgZnJvbSBlaXRoZXIgYXMgdGhlIHN0YXJ0IGluIHRoaXMgY2FzZSBwMFxyXG4gICAgaWYgKGRlbm9tID09PSAwIHx8IGRlbm9tIDw9IDAuMDEpIHtcclxuICAgICAgICBjb25zdCB0Q2xvc2VzdFBhcmFsbGVsID0gZCAvIGI7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lKHAwLCBxMC5hZGQodi5zY2FsZSh0Q2xvc2VzdFBhcmFsbGVsKSkpO1xyXG4gICAgfVxyXG4gICAgLy8gU29sdmUgZm9yIHNDbG9zZXN0IGZvciBpbmZpbml0ZSBsaW5lXHJcbiAgICBsZXQgc0Nsb3Nlc3QgPSBiICogZSAtIGMgKiBkOyAvLyAvIGRlbm9tO1xyXG4gICAgLy8gU29sdmUgZm9yIHRDbG9zZXN0IGZvciBpbmZpbml0ZSBsaW5lXHJcbiAgICBsZXQgdENsb3Nlc3QgPSBhICogZSAtIGIgKiBkOyAvLyAvIGRlbm9tO1xyXG4gICAgLy8gU29sdmUgZm9yIHNlZ21lbnRzIGNhbmRpZGF0ZSBlZGdlcywgaWYgc0Nsb3Nlc3QgYW5kIHRDbG9zZXN0IGFyZSBvdXRzaWRlIHRoZWlyIHNlZ21lbnRzXHJcbiAgICBpZiAoc0Nsb3Nlc3QgPCAwKSB7XHJcbiAgICAgICAgc0Nsb3Nlc3QgPSAwO1xyXG4gICAgICAgIHRDbG9zZXN0ID0gZTtcclxuICAgICAgICB0RGVub20gPSBjO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc0Nsb3Nlc3QgPiBzRGVub20pIHtcclxuICAgICAgICBzQ2xvc2VzdCA9IHNEZW5vbTtcclxuICAgICAgICB0Q2xvc2VzdCA9IGUgKyBiO1xyXG4gICAgICAgIHREZW5vbSA9IGM7XHJcbiAgICB9XHJcbiAgICBpZiAodENsb3Nlc3QgPCAwKSB7XHJcbiAgICAgICAgdENsb3Nlc3QgPSAwO1xyXG4gICAgICAgIGlmICgtZCA8IDApIHtcclxuICAgICAgICAgICAgc0Nsb3Nlc3QgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgtZCA+IGEpIHtcclxuICAgICAgICAgICAgc0Nsb3Nlc3QgPSBzRGVub207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzQ2xvc2VzdCA9IC1kO1xyXG4gICAgICAgICAgICBzRGVub20gPSBhO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHRDbG9zZXN0ID4gdERlbm9tKSB7XHJcbiAgICAgICAgdENsb3Nlc3QgPSB0RGVub207XHJcbiAgICAgICAgaWYgKC1kICsgYiA8IDApIHtcclxuICAgICAgICAgICAgc0Nsb3Nlc3QgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgtZCArIGIgPiBhKSB7XHJcbiAgICAgICAgICAgIHNDbG9zZXN0ID0gc0Rlbm9tO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc0Nsb3Nlc3QgPSAtZCArIGI7XHJcbiAgICAgICAgICAgIHNEZW5vbSA9IGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc0Nsb3Nlc3QgPSBNYXRoLmFicyhzQ2xvc2VzdCkgPCAwLjAwMSA/IDAgOiBzQ2xvc2VzdCAvIHNEZW5vbTtcclxuICAgIHRDbG9zZXN0ID0gTWF0aC5hYnModENsb3Nlc3QpIDwgMC4wMDEgPyAwIDogdENsb3Nlc3QgLyB0RGVub207XHJcbiAgICByZXR1cm4gbmV3IExpbmUocDAuYWRkKHUuc2NhbGUoc0Nsb3Nlc3QpKSwgcTAuYWRkKHYuc2NhbGUodENsb3Nlc3QpKSk7XHJcbn1cclxuY29uc3QgQ2xvc2VzdExpbmVKdW1wVGFibGUgPSB7XHJcbiAgICBQb2x5Z29uUG9seWdvbkNsb3Nlc3RMaW5lKHBvbHlnb25BLCBwb2x5Z29uQikge1xyXG4gICAgICAgIC8vIEZpbmQgdGhlIDIgY2xvc2VzdCBmYWNlcyBvbiBlYWNoIHBvbHlnb25cclxuICAgICAgICBjb25zdCBvdGhlcldvcmxkUG9zID0gcG9seWdvbkIud29ybGRQb3M7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJEaXJlY3Rpb24gPSBvdGhlcldvcmxkUG9zLnN1Yihwb2x5Z29uQS53b3JsZFBvcyk7XHJcbiAgICAgICAgY29uc3QgdGhpc0RpcmVjdGlvbiA9IG90aGVyRGlyZWN0aW9uLm5lZ2F0ZSgpO1xyXG4gICAgICAgIGNvbnN0IHJheVRvd2FyZHNPdGhlciA9IG5ldyBSYXkocG9seWdvbkEud29ybGRQb3MsIG90aGVyRGlyZWN0aW9uKTtcclxuICAgICAgICBjb25zdCByYXlUb3dhcmRzVGhpcyA9IG5ldyBSYXkob3RoZXJXb3JsZFBvcywgdGhpc0RpcmVjdGlvbik7XHJcbiAgICAgICAgY29uc3QgdGhpc1BvaW50ID0gcG9seWdvbkEucmF5Q2FzdChyYXlUb3dhcmRzT3RoZXIpLmFkZChyYXlUb3dhcmRzT3RoZXIuZGlyLnNjYWxlKDAuMSkpO1xyXG4gICAgICAgIGNvbnN0IG90aGVyUG9pbnQgPSBwb2x5Z29uQi5yYXlDYXN0KHJheVRvd2FyZHNUaGlzKS5hZGQocmF5VG93YXJkc1RoaXMuZGlyLnNjYWxlKDAuMSkpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNGYWNlID0gcG9seWdvbkEuZ2V0Q2xvc2VzdEZhY2UodGhpc1BvaW50KTtcclxuICAgICAgICBjb25zdCBvdGhlckZhY2UgPSBwb2x5Z29uQi5nZXRDbG9zZXN0RmFjZShvdGhlclBvaW50KTtcclxuICAgICAgICAvLyBMMSA9IFAocykgPSBwMCArIHMgKiB1LCB3aGVyZSBzIGlzIHRpbWUgYW5kIHAwIGlzIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICAgIGNvbnN0IHAwID0gdGhpc0ZhY2UuZmFjZS5iZWdpbjtcclxuICAgICAgICBjb25zdCB1ID0gdGhpc0ZhY2UuZmFjZS5nZXRFZGdlKCk7XHJcbiAgICAgICAgLy8gTDIgPSBRKHQpID0gcTAgKyB0ICogdiwgd2hlcmUgdCBpcyB0aW1lIGFuZCBxMCBpcyB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICAgICAgICBjb25zdCBxMCA9IG90aGVyRmFjZS5mYWNlLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IHYgPSBvdGhlckZhY2UuZmFjZS5nZXRFZGdlKCk7XHJcbiAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lKHAwLCB1LCBxMCwgdik7XHJcbiAgICB9LFxyXG4gICAgUG9seWdvbkVkZ2VDbG9zZXN0TGluZShwb2x5Z29uLCBlZGdlKSB7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgMiBjbG9zZXN0IGZhY2VzIG9uIGVhY2ggcG9seWdvblxyXG4gICAgICAgIGNvbnN0IG90aGVyV29ybGRQb3MgPSBlZGdlLndvcmxkUG9zO1xyXG4gICAgICAgIGNvbnN0IG90aGVyRGlyZWN0aW9uID0gb3RoZXJXb3JsZFBvcy5zdWIocG9seWdvbi53b3JsZFBvcyk7XHJcbiAgICAgICAgY29uc3QgcmF5VG93YXJkc090aGVyID0gbmV3IFJheShwb2x5Z29uLndvcmxkUG9zLCBvdGhlckRpcmVjdGlvbik7XHJcbiAgICAgICAgY29uc3QgdGhpc1BvaW50ID0gcG9seWdvbi5yYXlDYXN0KHJheVRvd2FyZHNPdGhlcikuYWRkKHJheVRvd2FyZHNPdGhlci5kaXIuc2NhbGUoMC4xKSk7XHJcbiAgICAgICAgY29uc3QgdGhpc0ZhY2UgPSBwb2x5Z29uLmdldENsb3Nlc3RGYWNlKHRoaXNQb2ludCk7XHJcbiAgICAgICAgLy8gTDEgPSBQKHMpID0gcDAgKyBzICogdSwgd2hlcmUgcyBpcyB0aW1lIGFuZCBwMCBpcyB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICAgICAgICBjb25zdCBwMCA9IHRoaXNGYWNlLmZhY2UuYmVnaW47XHJcbiAgICAgICAgY29uc3QgdSA9IHRoaXNGYWNlLmZhY2UuZ2V0RWRnZSgpO1xyXG4gICAgICAgIC8vIEwyID0gUSh0KSA9IHEwICsgdCAqIHYsIHdoZXJlIHQgaXMgdGltZSBhbmQgcTAgaXMgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgICAgY29uc3QgZWRnZUxpbmUgPSBlZGdlLmFzTGluZSgpO1xyXG4gICAgICAgIGNvbnN0IGVkZ2VTdGFydCA9IGVkZ2VMaW5lLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IGVkZ2VWZWN0b3IgPSBlZGdlTGluZS5nZXRFZGdlKCk7XHJcbiAgICAgICAgY29uc3QgcTAgPSBlZGdlU3RhcnQ7XHJcbiAgICAgICAgY29uc3QgdiA9IGVkZ2VWZWN0b3I7XHJcbiAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lKHAwLCB1LCBxMCwgdik7XHJcbiAgICB9LFxyXG4gICAgUG9seWdvbkNpcmNsZUNsb3Nlc3RMaW5lKHBvbHlnb24sIGNpcmNsZSkge1xyXG4gICAgICAgIC8vIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTkxOTE3Ny9ob3ctdG8tZmluZC1wb2ludC1vbi1saW5lLWNsb3Nlc3QtdG8tc3BoZXJlXHJcbiAgICAgICAgLy8gRmluZCB0aGUgMiBjbG9zZXN0IGZhY2VzIG9uIGVhY2ggcG9seWdvblxyXG4gICAgICAgIGNvbnN0IG90aGVyV29ybGRQb3MgPSBjaXJjbGUud29ybGRQb3M7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJEaXJlY3Rpb24gPSBvdGhlcldvcmxkUG9zLnN1Yihwb2x5Z29uLndvcmxkUG9zKTtcclxuICAgICAgICBjb25zdCByYXlUb3dhcmRzT3RoZXIgPSBuZXcgUmF5KHBvbHlnb24ud29ybGRQb3MsIG90aGVyRGlyZWN0aW9uLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICBjb25zdCB0aGlzUG9pbnQgPSBwb2x5Z29uLnJheUNhc3QocmF5VG93YXJkc090aGVyKS5hZGQocmF5VG93YXJkc090aGVyLmRpci5zY2FsZSgwLjEpKTtcclxuICAgICAgICBjb25zdCB0aGlzRmFjZSA9IHBvbHlnb24uZ2V0Q2xvc2VzdEZhY2UodGhpc1BvaW50KTtcclxuICAgICAgICAvLyBMMSA9IFAocykgPSBwMCArIHMgKiB1LCB3aGVyZSBzIGlzIHRpbWUgYW5kIHAwIGlzIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICAgIGNvbnN0IHAwID0gdGhpc0ZhY2UuZmFjZS5iZWdpbjtcclxuICAgICAgICBjb25zdCB1ID0gdGhpc0ZhY2UuZmFjZS5nZXRFZGdlKCk7XHJcbiAgICAgICAgLy8gVGltZSBvZiBtaW5pbXVtIGRpc3RhbmNlXHJcbiAgICAgICAgbGV0IHQgPSAodS54ICogKG90aGVyV29ybGRQb3MueCAtIHAwLngpICsgdS55ICogKG90aGVyV29ybGRQb3MueSAtIHAwLnkpKSAvICh1LnggKiB1LnggKyB1LnkgKiB1LnkpO1xyXG4gICAgICAgIC8vIElmIHRpbWUgb2YgbWluaW11bSBpcyBwYXN0IHRoZSBlZGdlIGNsYW1wXHJcbiAgICAgICAgaWYgKHQgPiAxKSB7XHJcbiAgICAgICAgICAgIHQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0IDwgMCkge1xyXG4gICAgICAgICAgICB0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWluaW11bSBkaXN0YW5jZVxyXG4gICAgICAgIGNvbnN0IGQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocDAueCArIHUueCAqIHQgLSBvdGhlcldvcmxkUG9zLngsIDIpICsgTWF0aC5wb3cocDAueSArIHUueSAqIHQgLSBvdGhlcldvcmxkUG9zLnksIDIpKSAtIGNpcmNsZS5yYWRpdXM7XHJcbiAgICAgICAgY29uc3QgY2lyY2xleCA9ICgocDAueCArIHUueCAqIHQgLSBvdGhlcldvcmxkUG9zLngpICogY2lyY2xlLnJhZGl1cykgLyAoY2lyY2xlLnJhZGl1cyArIGQpO1xyXG4gICAgICAgIGNvbnN0IGNpcmNsZXkgPSAoKHAwLnkgKyB1LnkgKiB0IC0gb3RoZXJXb3JsZFBvcy55KSAqIGNpcmNsZS5yYWRpdXMpIC8gKGNpcmNsZS5yYWRpdXMgKyBkKTtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmUodS5zY2FsZSh0KS5hZGQocDApLCBuZXcgVmVjdG9yKG90aGVyV29ybGRQb3MueCArIGNpcmNsZXgsIG90aGVyV29ybGRQb3MueSArIGNpcmNsZXkpKTtcclxuICAgIH0sXHJcbiAgICBDaXJjbGVDaXJjbGVDbG9zZXN0TGluZShjaXJjbGVBLCBjaXJjbGVCKSB7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgMiBjbG9zZXN0IGZhY2VzIG9uIGVhY2ggcG9seWdvblxyXG4gICAgICAgIGNvbnN0IG90aGVyV29ybGRQb3MgPSBjaXJjbGVCLndvcmxkUG9zO1xyXG4gICAgICAgIGNvbnN0IG90aGVyRGlyZWN0aW9uID0gb3RoZXJXb3JsZFBvcy5zdWIoY2lyY2xlQS53b3JsZFBvcyk7XHJcbiAgICAgICAgY29uc3QgdGhpc1dvcmxkUG9zID0gY2lyY2xlQS53b3JsZFBvcztcclxuICAgICAgICBjb25zdCB0aGlzRGlyZWN0aW9uID0gdGhpc1dvcmxkUG9zLnN1YihjaXJjbGVCLndvcmxkUG9zKTtcclxuICAgICAgICBjb25zdCByYXlUb3dhcmRzT3RoZXIgPSBuZXcgUmF5KGNpcmNsZUEud29ybGRQb3MsIG90aGVyRGlyZWN0aW9uKTtcclxuICAgICAgICBjb25zdCByYXlUb3dhcmRzVGhpcyA9IG5ldyBSYXkoY2lyY2xlQi53b3JsZFBvcywgdGhpc0RpcmVjdGlvbik7XHJcbiAgICAgICAgY29uc3QgdGhpc1BvaW50ID0gY2lyY2xlQS5yYXlDYXN0KHJheVRvd2FyZHNPdGhlcik7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJQb2ludCA9IGNpcmNsZUIucmF5Q2FzdChyYXlUb3dhcmRzVGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lKHRoaXNQb2ludCwgb3RoZXJQb2ludCk7XHJcbiAgICB9LFxyXG4gICAgQ2lyY2xlRWRnZUNsb3Nlc3RMaW5lKGNpcmNsZSwgZWRnZSkge1xyXG4gICAgICAgIC8vIGh0dHBzOi8vbWF0aC5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTkxOTE3Ny9ob3ctdG8tZmluZC1wb2ludC1vbi1saW5lLWNsb3Nlc3QtdG8tc3BoZXJlXHJcbiAgICAgICAgY29uc3QgY2lyY2xlV29ybFBvcyA9IGNpcmNsZS53b3JsZFBvcztcclxuICAgICAgICAvLyBMMSA9IFAocykgPSBwMCArIHMgKiB1LCB3aGVyZSBzIGlzIHRpbWUgYW5kIHAwIGlzIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICAgIGNvbnN0IGVkZ2VMaW5lID0gZWRnZS5hc0xpbmUoKTtcclxuICAgICAgICBjb25zdCBlZGdlU3RhcnQgPSBlZGdlTGluZS5iZWdpbjtcclxuICAgICAgICBjb25zdCBlZGdlVmVjdG9yID0gZWRnZUxpbmUuZ2V0RWRnZSgpO1xyXG4gICAgICAgIGNvbnN0IHAwID0gZWRnZVN0YXJ0O1xyXG4gICAgICAgIGNvbnN0IHUgPSBlZGdlVmVjdG9yO1xyXG4gICAgICAgIC8vIFRpbWUgb2YgbWluaW11bSBkaXN0YW5jZVxyXG4gICAgICAgIGxldCB0ID0gKHUueCAqIChjaXJjbGVXb3JsUG9zLnggLSBwMC54KSArIHUueSAqIChjaXJjbGVXb3JsUG9zLnkgLSBwMC55KSkgLyAodS54ICogdS54ICsgdS55ICogdS55KTtcclxuICAgICAgICAvLyBJZiB0aW1lIG9mIG1pbmltdW0gaXMgcGFzdCB0aGUgZWRnZSBjbGFtcCB0byBlZGdlXHJcbiAgICAgICAgaWYgKHQgPiAxKSB7XHJcbiAgICAgICAgICAgIHQgPSAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0IDwgMCkge1xyXG4gICAgICAgICAgICB0ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTWluaW11bSBkaXN0YW5jZVxyXG4gICAgICAgIGNvbnN0IGQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocDAueCArIHUueCAqIHQgLSBjaXJjbGVXb3JsUG9zLngsIDIpICsgTWF0aC5wb3cocDAueSArIHUueSAqIHQgLSBjaXJjbGVXb3JsUG9zLnksIDIpKSAtIGNpcmNsZS5yYWRpdXM7XHJcbiAgICAgICAgY29uc3QgY2lyY2xleCA9ICgocDAueCArIHUueCAqIHQgLSBjaXJjbGVXb3JsUG9zLngpICogY2lyY2xlLnJhZGl1cykgLyAoY2lyY2xlLnJhZGl1cyArIGQpO1xyXG4gICAgICAgIGNvbnN0IGNpcmNsZXkgPSAoKHAwLnkgKyB1LnkgKiB0IC0gY2lyY2xlV29ybFBvcy55KSAqIGNpcmNsZS5yYWRpdXMpIC8gKGNpcmNsZS5yYWRpdXMgKyBkKTtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmUodS5zY2FsZSh0KS5hZGQocDApLCBuZXcgVmVjdG9yKGNpcmNsZVdvcmxQb3MueCArIGNpcmNsZXgsIGNpcmNsZVdvcmxQb3MueSArIGNpcmNsZXkpKTtcclxuICAgIH0sXHJcbiAgICBFZGdlRWRnZUNsb3Nlc3RMaW5lKGVkZ2VBLCBlZGdlQikge1xyXG4gICAgICAgIC8vIEwxID0gUChzKSA9IHAwICsgcyAqIHUsIHdoZXJlIHMgaXMgdGltZSBhbmQgcDAgaXMgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgICAgY29uc3QgZWRnZUxpbmVBID0gZWRnZUEuYXNMaW5lKCk7XHJcbiAgICAgICAgY29uc3QgZWRnZVN0YXJ0QSA9IGVkZ2VMaW5lQS5iZWdpbjtcclxuICAgICAgICBjb25zdCBlZGdlVmVjdG9yQSA9IGVkZ2VMaW5lQS5nZXRFZGdlKCk7XHJcbiAgICAgICAgY29uc3QgcDAgPSBlZGdlU3RhcnRBO1xyXG4gICAgICAgIGNvbnN0IHUgPSBlZGdlVmVjdG9yQTtcclxuICAgICAgICAvLyBMMiA9IFEodCkgPSBxMCArIHQgKiB2LCB3aGVyZSB0IGlzIHRpbWUgYW5kIHEwIGlzIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICAgIGNvbnN0IGVkZ2VMaW5lQiA9IGVkZ2VCLmFzTGluZSgpO1xyXG4gICAgICAgIGNvbnN0IGVkZ2VTdGFydEIgPSBlZGdlTGluZUIuYmVnaW47XHJcbiAgICAgICAgY29uc3QgZWRnZVZlY3RvckIgPSBlZGdlTGluZUIuZ2V0RWRnZSgpO1xyXG4gICAgICAgIGNvbnN0IHEwID0gZWRnZVN0YXJ0QjtcclxuICAgICAgICBjb25zdCB2ID0gZWRnZVZlY3RvckI7XHJcbiAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lKHAwLCB1LCBxMCwgdik7XHJcbiAgICB9XHJcbn07XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpZGVycy9DaXJjbGVDb2xsaWRlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoaXMgaXMgYSBjaXJjbGUgY29sbGlkZXIgZm9yIHRoZSBleGNhbGlidXIgcmlnaWQgYm9keSBwaHlzaWNzIHNpbXVsYXRpb25cclxuICovXHJcbmNsYXNzIENpcmNsZUNvbGxpZGVyIGV4dGVuZHMgQ29sbGlkZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUG9zaXRpb24gb2YgdGhlIGNpcmNsZSByZWxhdGl2ZSB0byB0aGUgY29sbGlkZXIsIGJ5IGRlZmF1bHQgKDAsIDApLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDA7XHJcbiAgICB9XHJcbiAgICBnZXQgd29ybGRQb3MoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gdGhpcy5vZmZzZXQuYWRkKChfYiA9IChfYSA9IHRoaXMuX3RyYW5zZm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogVmVjdG9yLlplcm8pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBzaGFwZSwgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgY29sbGlkZXJcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVDb2xsaWRlcih7XHJcbiAgICAgICAgICAgIG9mZnNldDogdGhpcy5vZmZzZXQuY2xvbmUoKSxcclxuICAgICAgICAgICAgcmFkaXVzOiB0aGlzLnJhZGl1c1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgY29sbGlkZXIgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgZ2V0IGNlbnRlcigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldC5hZGQoKF9iID0gKF9hID0gdGhpcy5fdHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBWZWN0b3IuWmVybyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgY29udGFpbmVkIGluIHRoaXMgY29sbGlkZXJcclxuICAgICAqL1xyXG4gICAgY29udGFpbnMocG9pbnQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IChfYiA9IChfYSA9IHRoaXMuX3RyYW5zZm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBwb3MuZGlzdGFuY2UocG9pbnQpO1xyXG4gICAgICAgIGlmIChkaXN0YW5jZSA8PSB0aGlzLnJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYXN0cyBhIHJheSBhdCB0aGUgQ2lyY2xlIGNvbGxpZGVyIGFuZCByZXR1cm5zIHRoZSBuZWFyZXN0IHBvaW50IG9mIGNvbGxpc2lvblxyXG4gICAgICogQHBhcmFtIHJheVxyXG4gICAgICovXHJcbiAgICByYXlDYXN0KHJheSwgbWF4ID0gSW5maW5pdHkpIHtcclxuICAgICAgICAvL2h0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmUlRTIlODAlOTNzcGhlcmVfaW50ZXJzZWN0aW9uXHJcbiAgICAgICAgY29uc3QgYyA9IHRoaXMuY2VudGVyO1xyXG4gICAgICAgIGNvbnN0IGRpciA9IHJheS5kaXI7XHJcbiAgICAgICAgY29uc3Qgb3JpZyA9IHJheS5wb3M7XHJcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYW50ID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpci5kb3Qob3JpZy5zdWIoYykpLCAyKSAtIE1hdGgucG93KG9yaWcuc3ViKGMpLmRpc3RhbmNlKCksIDIpICsgTWF0aC5wb3codGhpcy5yYWRpdXMsIDIpKTtcclxuICAgICAgICBpZiAoZGlzY3JpbWluYW50IDwgMCkge1xyXG4gICAgICAgICAgICAvLyBubyBpbnRlcnNlY3Rpb25cclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgdG9pID0gMDtcclxuICAgICAgICAgICAgaWYgKGRpc2NyaW1pbmFudCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgdG9pID0gLWRpci5kb3Qob3JpZy5zdWIoYykpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRvaSA+IDAgJiYgdG9pIDwgbWF4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludCh0b2kpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b2kxID0gLWRpci5kb3Qob3JpZy5zdWIoYykpICsgZGlzY3JpbWluYW50O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdG9pMiA9IC1kaXIuZG90KG9yaWcuc3ViKGMpKSAtIGRpc2NyaW1pbmFudDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aXZlVG9pID0gW107XHJcbiAgICAgICAgICAgICAgICBpZiAodG9pMSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpdmVUb2kucHVzaCh0b2kxKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0b2kyID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGl2ZVRvaS5wdXNoKHRvaTIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWludG9pID0gTWF0aC5taW4oLi4ucG9zaXRpdmVUb2kpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1pbnRvaSA8PSBtYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmF5LmdldFBvaW50KG1pbnRvaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldENsb3Nlc3RMaW5lQmV0d2VlbihzaGFwZSkge1xyXG4gICAgICAgIGlmIChzaGFwZSBpbnN0YW5jZW9mIENpcmNsZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbG9zZXN0TGluZUp1bXBUYWJsZS5DaXJjbGVDaXJjbGVDbG9zZXN0TGluZSh0aGlzLCBzaGFwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNoYXBlIGluc3RhbmNlb2YgUG9seWdvbkNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbG9zZXN0TGluZUp1bXBUYWJsZS5Qb2x5Z29uQ2lyY2xlQ2xvc2VzdExpbmUoc2hhcGUsIHRoaXMpLmZsaXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hhcGUgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLkNpcmNsZUVkZ2VDbG9zZXN0TGluZSh0aGlzLCBzaGFwZSkuZmxpcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2x5Z29uIGNvdWxkIG5vdCBjb2xsaWRlIHdpdGggdW5rbm93biBDb2xsaXNpb25TaGFwZSAke3R5cGVvZiBzaGFwZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbmhlcml0ZG9jXHJcbiAgICAgKi9cclxuICAgIGNvbGxpZGUoY29sbGlkZXIpIHtcclxuICAgICAgICBpZiAoY29sbGlkZXIgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVDaXJjbGUodGhpcywgY29sbGlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2xsaWRlciBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVQb2x5Z29uKHRoaXMsIGNvbGxpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29sbGlkZXIgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlRWRnZSh0aGlzLCBjb2xsaWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENpcmNsZSBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gQ29sbGlzaW9uU2hhcGUgJHt0eXBlb2YgY29sbGlkZXJ9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBwb2ludCBvbiB0aGUgY29sbGlkZXIgZnVydGhlc3QgaW4gdGhlIGRpcmVjdGlvbiBzcGVjaWZpZWRcclxuICAgICAqL1xyXG4gICAgZ2V0RnVydGhlc3RQb2ludChkaXJlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXIuYWRkKGRpcmVjdGlvbi5ub3JtYWxpemUoKS5zY2FsZSh0aGlzLnJhZGl1cykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBsb2NhbCBwb2ludCBvbiB0aGUgc2hhcGUgaW4gdGhlIGRpcmVjdGlvbiBzcGVjaWZpZWRcclxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgZ2V0RnVydGhlc3RMb2NhbFBvaW50KGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGRpciA9IGRpcmVjdGlvbi5ub3JtYWxpemUoKTtcclxuICAgICAgICByZXR1cm4gZGlyLnNjYWxlKHRoaXMucmFkaXVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciB0aGUgY2lyY2xlIGNvbGxpZGVyIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGdldCBib3VuZHMoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy5fdHJhbnNmb3JtO1xyXG4gICAgICAgIGNvbnN0IGJvZHlQb3MgPSAoX2EgPSB0eCA9PT0gbnVsbCB8fCB0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHguZ2xvYmFsUG9zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWZWN0b3IuWmVybztcclxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHRoaXMub2Zmc2V0LnggKyBib2R5UG9zLnggLSB0aGlzLnJhZGl1cywgdGhpcy5vZmZzZXQueSArIGJvZHlQb3MueSAtIHRoaXMucmFkaXVzLCB0aGlzLm9mZnNldC54ICsgYm9keVBvcy54ICsgdGhpcy5yYWRpdXMsIHRoaXMub2Zmc2V0LnkgKyBib2R5UG9zLnkgKyB0aGlzLnJhZGl1cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIGNpcmNsZSBjb2xsaWRlciBpbiBsb2NhbCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0aGlzLm9mZnNldC54IC0gdGhpcy5yYWRpdXMsIHRoaXMub2Zmc2V0LnkgLSB0aGlzLnJhZGl1cywgdGhpcy5vZmZzZXQueCArIHRoaXMucmFkaXVzLCB0aGlzLm9mZnNldC55ICsgdGhpcy5yYWRpdXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYXhpcyBub3QgaW1wbGVtZW50ZWQgb24gY2lyY2xlcywgc2luY2UgdGhlcmUgYXJlIGluZmluaXRlIGF4aXMgaW4gYSBjaXJjbGVcclxuICAgICAqL1xyXG4gICAgZ2V0IGF4ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBtb21lbnQgb2YgaW5lcnRpYSBvZiBhIGNpcmNsZSBnaXZlbiBpdCdzIG1hc3NcclxuICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhXHJcbiAgICAgKi9cclxuICAgIGdldEluZXJ0aWEobWFzcykge1xyXG4gICAgICAgIHJldHVybiAobWFzcyAqIHRoaXMucmFkaXVzICogdGhpcy5yYWRpdXMpIC8gMjtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICB1cGRhdGUodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9qZWN0IHRoZSBjaXJjbGUgYWxvbmcgYSBzcGVjaWZpZWQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwcm9qZWN0KGF4aXMpIHtcclxuICAgICAgICBjb25zdCBzY2FsYXJzID0gW107XHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSB0aGlzLmNlbnRlcjtcclxuICAgICAgICBjb25zdCBkb3RQcm9kdWN0ID0gcG9pbnQuZG90KGF4aXMpO1xyXG4gICAgICAgIHNjYWxhcnMucHVzaChkb3RQcm9kdWN0KTtcclxuICAgICAgICBzY2FsYXJzLnB1c2goZG90UHJvZHVjdCArIHRoaXMucmFkaXVzKTtcclxuICAgICAgICBzY2FsYXJzLnB1c2goZG90UHJvZHVjdCAtIHRoaXMucmFkaXVzKTtcclxuICAgICAgICByZXR1cm4gbmV3IFByb2plY3Rpb24oTWF0aC5taW4uYXBwbHkoTWF0aCwgc2NhbGFycyksIE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjYWxhcnMpKTtcclxuICAgIH1cclxuICAgIGRyYXcoY3R4LCBjb2xvciA9IENvbG9yLkdyZWVuLCBwb3MgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIGNvbnN0IG5ld1BvcyA9IHBvcy5hZGQodGhpcy5vZmZzZXQpO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguYXJjKG5ld1Bvcy54LCBuZXdQb3MueSwgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgIH1cclxuICAgIGRlYnVnKGV4LCBjb2xvcikge1xyXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy5fdHJhbnNmb3JtO1xyXG4gICAgICAgIGNvbnN0IHBvcyA9ICh0eCA9PT0gbnVsbCB8fCB0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHguZ2xvYmFsUG9zKSA/IHR4ID09PSBudWxsIHx8IHR4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eC5nbG9iYWxQb3MuYWRkKHRoaXMub2Zmc2V0KSA6IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIGV4LmRyYXdDaXJjbGUocG9zLCB0aGlzLnJhZGl1cywgY29sb3IpO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGRlYnVnRHJhdyhjdHgsIGNvbG9yID0gQ29sb3IuR3JlZW4pIHtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLl90cmFuc2Zvcm07XHJcbiAgICAgICAgY29uc3QgcG9zID0gdHJhbnNmb3JtID8gdHJhbnNmb3JtLnBvcy5hZGQodGhpcy5vZmZzZXQpIDogdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0ucm90YXRpb24gOiAwO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5hcmMocG9zLngsIHBvcy55LCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8ocG9zLngsIHBvcy55KTtcclxuICAgICAgICBjdHgubGluZVRvKE1hdGguY29zKHJvdGF0aW9uKSAqIHRoaXMucmFkaXVzICsgcG9zLngsIE1hdGguc2luKHJvdGF0aW9uKSAqIHRoaXMucmFkaXVzICsgcG9zLnkpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vRGV0ZWN0aW9uL0NvbGxpc2lvbkNvbnRhY3QudHNcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29sbGlzaW9uIGNvbnRhY3RzIGFyZSB1c2VkIGludGVybmFsbHkgYnkgRXhjYWxpYnVyIHRvIHJlc29sdmUgY29sbGlzaW9uIGJldHdlZW4gY29sbGlkZXJzLiBUaGlzXHJcbiAqIFBhaXIgcHJldmVudHMgY29sbGlzaW9ucyBmcm9tIGJlaW5nIGV2YWx1YXRlZCBtb3JlIHRoYW4gb25lIHRpbWVcclxuICovXHJcbmNsYXNzIENvbGxpc2lvbkNvbnRhY3Qge1xyXG4gICAgY29uc3RydWN0b3IoY29sbGlkZXJBLCBjb2xsaWRlckIsIG10diwgbm9ybWFsLCB0YW5nZW50LCBwb2ludHMsIGxvY2FsUG9pbnRzLCBpbmZvKSB7XHJcbiAgICAgICAgdGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmNvbGxpZGVyQSA9IGNvbGxpZGVyQTtcclxuICAgICAgICB0aGlzLmNvbGxpZGVyQiA9IGNvbGxpZGVyQjtcclxuICAgICAgICB0aGlzLm10diA9IG10djtcclxuICAgICAgICB0aGlzLm5vcm1hbCA9IG5vcm1hbDtcclxuICAgICAgICB0aGlzLnRhbmdlbnQgPSB0YW5nZW50O1xyXG4gICAgICAgIHRoaXMucG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgIHRoaXMubG9jYWxQb2ludHMgPSBsb2NhbFBvaW50cztcclxuICAgICAgICB0aGlzLmluZm8gPSBpbmZvO1xyXG4gICAgICAgIHRoaXMuaWQgPSBQYWlyLmNhbGN1bGF0ZVBhaXJIYXNoKGNvbGxpZGVyQS5pZCwgY29sbGlkZXJCLmlkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWF0Y2ggY29udGFjdCBhd2FrZSBzdGF0ZSwgZXhjZXB0IGlmIGJvZHkncyBhcmUgRml4ZWRcclxuICAgICAqL1xyXG4gICAgbWF0Y2hBd2FrZSgpIHtcclxuICAgICAgICBjb25zdCBib2R5QSA9IHRoaXMuY29sbGlkZXJBLm93bmVyLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICBjb25zdCBib2R5QiA9IHRoaXMuY29sbGlkZXJCLm93bmVyLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgaWYgKGJvZHlBLnNsZWVwaW5nICE9PSBib2R5Qi5zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBLnNsZWVwaW5nICYmIGJvZHlBLmNvbGxpc2lvblR5cGUgIT09IENvbGxpc2lvblR5cGUuRml4ZWQgJiYgYm9keUIuc2xlZXBNb3Rpb24gPj0gUGh5c2ljcy53YWtlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEuc2V0U2xlZXBpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCLnNsZWVwaW5nICYmIGJvZHlCLmNvbGxpc2lvblR5cGUgIT09IENvbGxpc2lvblR5cGUuRml4ZWQgJiYgYm9keUEuc2xlZXBNb3Rpb24gPj0gUGh5c2ljcy53YWtlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIuc2V0U2xlZXBpbmcoZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDYW5jZWxlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY2FuY2VsZWQ7XHJcbiAgICB9XHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgdGhpcy5fY2FuY2VsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpZGVycy9TZXBhcmF0aW5nQXhpcy50c1xuY2xhc3MgU2VwYXJhdGluZ0F4aXMge1xyXG4gICAgc3RhdGljIGZpbmRQb2x5Z29uUG9seWdvblNlcGFyYXRpb24ocG9seUEsIHBvbHlCKSB7XHJcbiAgICAgICAgbGV0IGJlc3RTZXBhcmF0aW9uID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IGJlc3RTaWRlID0gbnVsbDtcclxuICAgICAgICBsZXQgYmVzdEF4aXMgPSBudWxsO1xyXG4gICAgICAgIGxldCBiZXN0U2lkZUluZGV4ID0gLTE7XHJcbiAgICAgICAgbGV0IGJlc3RPdGhlclBvaW50ID0gbnVsbDtcclxuICAgICAgICBjb25zdCBzaWRlcyA9IHBvbHlBLmdldFNpZGVzKCk7XHJcbiAgICAgICAgY29uc3QgbG9jYWxTaWRlcyA9IHBvbHlBLmdldExvY2FsU2lkZXMoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZGUgPSBzaWRlc1tpXTtcclxuICAgICAgICAgICAgY29uc3QgYXhpcyA9IHNpZGUubm9ybWFsKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlcnRCID0gcG9seUIuZ2V0RnVydGhlc3RQb2ludChheGlzLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgLy8gU2VwYXJhdGlvbiBvbiBzaWRlIGkncyBheGlzXHJcbiAgICAgICAgICAgIC8vIFdlIGFyZSBsb29raW5nIGZvciB0aGUgbGFyZ2VzdCBzZXBhcmF0aW9uIGJldHdlZW4gcG9seSBBJ3Mgc2lkZXNcclxuICAgICAgICAgICAgY29uc3QgdmVydFNlcGFyYXRpb24gPSBzaWRlLmRpc3RhbmNlVG9Qb2ludCh2ZXJ0QiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIGlmICh2ZXJ0U2VwYXJhdGlvbiA+IGJlc3RTZXBhcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2VwYXJhdGlvbiA9IHZlcnRTZXBhcmF0aW9uO1xyXG4gICAgICAgICAgICAgICAgYmVzdFNpZGUgPSBzaWRlO1xyXG4gICAgICAgICAgICAgICAgYmVzdEF4aXMgPSBheGlzO1xyXG4gICAgICAgICAgICAgICAgYmVzdFNpZGVJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICBiZXN0T3RoZXJQb2ludCA9IHZlcnRCO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyOiBwb2x5QSxcclxuICAgICAgICAgICAgc2VwYXJhdGlvbjogYmVzdEF4aXMgPyBiZXN0U2VwYXJhdGlvbiA6IDk5LFxyXG4gICAgICAgICAgICBheGlzOiBiZXN0QXhpcyxcclxuICAgICAgICAgICAgc2lkZTogYmVzdFNpZGUsXHJcbiAgICAgICAgICAgIGxvY2FsU2lkZTogbG9jYWxTaWRlc1tiZXN0U2lkZUluZGV4XSxcclxuICAgICAgICAgICAgc2lkZUlkOiBiZXN0U2lkZUluZGV4LFxyXG4gICAgICAgICAgICBwb2ludDogYmVzdE90aGVyUG9pbnQsXHJcbiAgICAgICAgICAgIGxvY2FsUG9pbnQ6IGJlc3RBeGlzID8gcG9seUIuZ2V0RnVydGhlc3RMb2NhbFBvaW50KGJlc3RBeGlzLm5lZ2F0ZSgpKSA6IG51bGxcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZpbmRDaXJjbGVQb2x5Z29uU2VwYXJhdGlvbihjaXJjbGUsIHBvbHlnb24pIHtcclxuICAgICAgICBjb25zdCBheGVzID0gcG9seWdvbi5heGVzO1xyXG4gICAgICAgIGNvbnN0IHBjID0gcG9seWdvbi5jZW50ZXI7XHJcbiAgICAgICAgLy8gU3BlY2lhbCBTQVQgd2l0aCBjaXJjbGVzXHJcbiAgICAgICAgY29uc3QgcG9seURpciA9IHBjLnN1YihjaXJjbGUud29ybGRQb3MpO1xyXG4gICAgICAgIGNvbnN0IGNsb3Nlc3RQb2ludE9uUG9seSA9IHBvbHlnb24uZ2V0RnVydGhlc3RQb2ludChwb2x5RGlyLm5lZ2F0ZSgpKTtcclxuICAgICAgICBheGVzLnB1c2goY2xvc2VzdFBvaW50T25Qb2x5LnN1YihjaXJjbGUud29ybGRQb3MpLm5vcm1hbGl6ZSgpKTtcclxuICAgICAgICBsZXQgbWluT3ZlcmxhcCA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IG1pbkF4aXMgPSBudWxsO1xyXG4gICAgICAgIGxldCBtaW5JbmRleCA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwcm9qMSA9IHBvbHlnb24ucHJvamVjdChheGVzW2ldKTtcclxuICAgICAgICAgICAgY29uc3QgcHJvajIgPSBjaXJjbGUucHJvamVjdChheGVzW2ldKTtcclxuICAgICAgICAgICAgY29uc3Qgb3ZlcmxhcCA9IHByb2oxLmdldE92ZXJsYXAocHJvajIpO1xyXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkF4aXMgPSBheGVzW2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIG1pbkluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWluSW5kZXggPCAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWluQXhpcy5ub3JtYWxpemUoKS5zY2FsZShtaW5PdmVybGFwKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaWRlcnMvQ29sbGlzaW9uSnVtcFRhYmxlLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNvbnN0IENvbGxpc2lvbkp1bXBUYWJsZSA9IHtcclxuICAgIENvbGxpZGVDaXJjbGVDaXJjbGUoY2lyY2xlQSwgY2lyY2xlQikge1xyXG4gICAgICAgIGNvbnN0IGNpcmNsZUFQb3MgPSBjaXJjbGVBLndvcmxkUG9zO1xyXG4gICAgICAgIGNvbnN0IGNpcmNsZUJQb3MgPSBjaXJjbGVCLndvcmxkUG9zO1xyXG4gICAgICAgIGNvbnN0IGNvbWJpbmVkUmFkaXVzID0gY2lyY2xlQS5yYWRpdXMgKyBjaXJjbGVCLnJhZGl1cztcclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGNpcmNsZUFQb3MuZGlzdGFuY2UoY2lyY2xlQlBvcyk7XHJcbiAgICAgICAgaWYgKGRpc3RhbmNlID4gY29tYmluZWRSYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBuZWdhdGl2ZSBtZWFucyBvdmVybGFwXHJcbiAgICAgICAgY29uc3Qgc2VwYXJhdGlvbiA9IGNvbWJpbmVkUmFkaXVzIC0gZGlzdGFuY2U7XHJcbiAgICAgICAgLy8gTm9ybWFsIHBvaW50cyBmcm9tIEEgLT4gQlxyXG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IGNpcmNsZUJQb3Muc3ViKGNpcmNsZUFQb3MpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGNvbnN0IHRhbmdlbnQgPSBub3JtYWwucGVycGVuZGljdWxhcigpO1xyXG4gICAgICAgIGNvbnN0IG12dCA9IG5vcm1hbC5zY2FsZShzZXBhcmF0aW9uKTtcclxuICAgICAgICBjb25zdCBwb2ludCA9IGNpcmNsZUEuZ2V0RnVydGhlc3RQb2ludChub3JtYWwpO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsID0gY2lyY2xlQS5nZXRGdXJ0aGVzdExvY2FsUG9pbnQobm9ybWFsKTtcclxuICAgICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgICAgICBjb2xsaWRlcjogY2lyY2xlQSxcclxuICAgICAgICAgICAgc2VwYXJhdGlvbixcclxuICAgICAgICAgICAgYXhpczogbm9ybWFsLFxyXG4gICAgICAgICAgICBwb2ludDogcG9pbnRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBbbmV3IENvbGxpc2lvbkNvbnRhY3QoY2lyY2xlQSwgY2lyY2xlQiwgbXZ0LCBub3JtYWwsIHRhbmdlbnQsIFtwb2ludF0sIFtsb2NhbF0sIGluZm8pXTtcclxuICAgIH0sXHJcbiAgICBDb2xsaWRlQ2lyY2xlUG9seWdvbihjaXJjbGUsIHBvbHlnb24pIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGxldCBtaW5BeGlzID0gU2VwYXJhdGluZ0F4aXMuZmluZENpcmNsZVBvbHlnb25TZXBhcmF0aW9uKGNpcmNsZSwgcG9seWdvbik7XHJcbiAgICAgICAgaWYgKCFtaW5BeGlzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgdGhlIG1pbkF4aXMgaXMgcG9pbnRpbmcgYXdheSBmcm9tIGNpcmNsZVxyXG4gICAgICAgIGNvbnN0IHNhbWVkaXIgPSBtaW5BeGlzLmRvdChwb2x5Z29uLmNlbnRlci5zdWIoY2lyY2xlLmNlbnRlcikpO1xyXG4gICAgICAgIG1pbkF4aXMgPSBzYW1lZGlyIDwgMCA/IG1pbkF4aXMubmVnYXRlKCkgOiBtaW5BeGlzO1xyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gY2lyY2xlLmdldEZ1cnRoZXN0UG9pbnQobWluQXhpcyk7XHJcbiAgICAgICAgY29uc3QgeGYgPSAoX2IgPSAoX2EgPSBjaXJjbGUub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsID0geGYuYXBwbHlJbnZlcnNlKHBvaW50KTtcclxuICAgICAgICBjb25zdCBub3JtYWwgPSBtaW5BeGlzLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyOiBjaXJjbGUsXHJcbiAgICAgICAgICAgIHNlcGFyYXRpb246IC1taW5BeGlzLnNpemUsXHJcbiAgICAgICAgICAgIGF4aXM6IG5vcm1hbCxcclxuICAgICAgICAgICAgcG9pbnQ6IHBvaW50LFxyXG4gICAgICAgICAgICBsb2NhbFBvaW50OiBsb2NhbCxcclxuICAgICAgICAgICAgc2lkZTogcG9seWdvbi5maW5kU2lkZShub3JtYWwubmVnYXRlKCkpLFxyXG4gICAgICAgICAgICBsb2NhbFNpZGU6IHBvbHlnb24uZmluZExvY2FsU2lkZShub3JtYWwubmVnYXRlKCkpXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gW25ldyBDb2xsaXNpb25Db250YWN0KGNpcmNsZSwgcG9seWdvbiwgbWluQXhpcywgbm9ybWFsLCBub3JtYWwucGVycGVuZGljdWxhcigpLCBbcG9pbnRdLCBbbG9jYWxdLCBpbmZvKV07XHJcbiAgICB9LFxyXG4gICAgQ29sbGlkZUNpcmNsZUVkZ2UoY2lyY2xlLCBlZGdlKSB7XHJcbiAgICAgICAgLy8gVE9ETyBub3Qgc3VyZSB0aGlzIGFjdHVhbGx5IGFiaWRlcyBieSBsb2NhbC93b3JsZCBjb2xsaXNpb25zXHJcbiAgICAgICAgLy8gQXJlIGVkZ2UuYmVnaW4gYW5kIGVkZ2UuZW5kIGxvY2FsIHNwYWNlIG9yIHdvcmxkIHNwYWNlPyBJIHRoaW5rIHRoZXkgc2hvdWxkIGJlIGxvY2FsXHJcbiAgICAgICAgLy8gY2VudGVyIG9mIHRoZSBjaXJjbGUgaW4gd29ybGQgcG9zXHJcbiAgICAgICAgY29uc3QgY2MgPSBjaXJjbGUuY2VudGVyO1xyXG4gICAgICAgIC8vIHZlY3RvciBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlZGdlXHJcbiAgICAgICAgY29uc3QgZWRnZVdvcmxkID0gZWRnZS5hc0xpbmUoKTtcclxuICAgICAgICBjb25zdCBlID0gZWRnZVdvcmxkLmVuZC5zdWIoZWRnZVdvcmxkLmJlZ2luKTtcclxuICAgICAgICAvLyBhbW91bnQgb2Ygb3ZlcmxhcCB3aXRoIHRoZSBjaXJjbGUncyBjZW50ZXIgYWxvbmcgdGhlIGVkZ2UgZGlyZWN0aW9uXHJcbiAgICAgICAgY29uc3QgdSA9IGUuZG90KGVkZ2VXb3JsZC5lbmQuc3ViKGNjKSk7XHJcbiAgICAgICAgY29uc3QgdiA9IGUuZG90KGNjLnN1YihlZGdlV29ybGQuYmVnaW4pKTtcclxuICAgICAgICBjb25zdCBzaWRlID0gZWRnZS5hc0xpbmUoKTtcclxuICAgICAgICBjb25zdCBsb2NhbFNpZGUgPSBlZGdlLmFzTG9jYWxMaW5lKCk7XHJcbiAgICAgICAgLy8gUG90ZW50aWFsIHJlZ2lvbiBBIGNvbGxpc2lvbiAoY2lyY2xlIGlzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGVkZ2UsIGJlZm9yZSB0aGUgYmVnaW5uaW5nKVxyXG4gICAgICAgIGlmICh2IDw9IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZGEgPSBlZGdlV29ybGQuYmVnaW4uc3ViKGNjKTtcclxuICAgICAgICAgICAgY29uc3QgZGRhID0gZGEuZG90KGRhKTsgLy8gcXVpY2sgYW5kIGRpcnR5IHdheSBvZiBjYWxjJ24gZGlzdGFuY2UgaW4gcl4yIHRlcm1zIHNhdmVzIHNvbWUgc3FydHNcclxuICAgICAgICAgICAgLy8gc2F2ZSBzb21lIHNxcnRzXHJcbiAgICAgICAgICAgIGlmIChkZGEgPiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBubyBjb2xsaXNpb25cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3JtYWwgPSBkYS5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdGlvbiA9IGNpcmNsZS5yYWRpdXMgLSBNYXRoLnNxcnQoZGRhKTtcclxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyOiBjaXJjbGUsXHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0aW9uOiBzZXBhcmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgYXhpczogbm9ybWFsLFxyXG4gICAgICAgICAgICAgICAgcG9pbnQ6IHNpZGUuYmVnaW4sXHJcbiAgICAgICAgICAgICAgICBzaWRlOiBzaWRlLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxTaWRlOiBsb2NhbFNpZGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIG5ldyBDb2xsaXNpb25Db250YWN0KGNpcmNsZSwgZWRnZSwgbm9ybWFsLnNjYWxlKHNlcGFyYXRpb24pLCBub3JtYWwsIG5vcm1hbC5wZXJwZW5kaWN1bGFyKCksIFtzaWRlLmJlZ2luXSwgW2xvY2FsU2lkZS5iZWdpbl0sIGluZm8pXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBvdGVudGlhbCByZWdpb24gQiBjb2xsaXNpb24gKGNpcmNsZSBpcyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgZWRnZSwgYWZ0ZXIgdGhlIGVuZClcclxuICAgICAgICBpZiAodSA8PSAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRiID0gZWRnZVdvcmxkLmVuZC5zdWIoY2MpO1xyXG4gICAgICAgICAgICBjb25zdCBkZGIgPSBkYi5kb3QoZGIpO1xyXG4gICAgICAgICAgICBpZiAoZGRiID4gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBub3JtYWwgPSBkYi5ub3JtYWxpemUoKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdGlvbiA9IGNpcmNsZS5yYWRpdXMgLSBNYXRoLnNxcnQoZGRiKTtcclxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyOiBjaXJjbGUsXHJcbiAgICAgICAgICAgICAgICBzZXBhcmF0aW9uOiBzZXBhcmF0aW9uLFxyXG4gICAgICAgICAgICAgICAgYXhpczogbm9ybWFsLFxyXG4gICAgICAgICAgICAgICAgcG9pbnQ6IHNpZGUuZW5kLFxyXG4gICAgICAgICAgICAgICAgc2lkZTogc2lkZSxcclxuICAgICAgICAgICAgICAgIGxvY2FsU2lkZTogbG9jYWxTaWRlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgICAgICBuZXcgQ29sbGlzaW9uQ29udGFjdChjaXJjbGUsIGVkZ2UsIG5vcm1hbC5zY2FsZShzZXBhcmF0aW9uKSwgbm9ybWFsLCBub3JtYWwucGVycGVuZGljdWxhcigpLCBbc2lkZS5lbmRdLCBbbG9jYWxTaWRlLmVuZF0sIGluZm8pXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE90aGVyd2lzZSBwb3RlbnRpYWwgcmVnaW9uIEFCIGNvbGxpc2lvbiAoY2lyY2xlIGlzIGluIHRoZSBtaWRkbGUgb2YgdGhlIGVkZ2UgYmV0d2VlbiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQpXHJcbiAgICAgICAgY29uc3QgZGVuID0gZS5kb3QoZSk7XHJcbiAgICAgICAgY29uc3QgcG9pbnRPbkVkZ2UgPSBlZGdlV29ybGQuYmVnaW5cclxuICAgICAgICAgICAgLnNjYWxlKHUpXHJcbiAgICAgICAgICAgIC5hZGQoZWRnZVdvcmxkLmVuZC5zY2FsZSh2KSlcclxuICAgICAgICAgICAgLnNjYWxlKDEgLyBkZW4pO1xyXG4gICAgICAgIGNvbnN0IGQgPSBjYy5zdWIocG9pbnRPbkVkZ2UpO1xyXG4gICAgICAgIGNvbnN0IGRkID0gZC5kb3QoZCk7XHJcbiAgICAgICAgaWYgKGRkID4gY2lyY2xlLnJhZGl1cyAqIGNpcmNsZS5yYWRpdXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdOyAvLyBubyBjb2xsaXNpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5vcm1hbCA9IGUucGVycGVuZGljdWxhcigpO1xyXG4gICAgICAgIC8vIGZsaXAgY29ycmVjdCBkaXJlY3Rpb25cclxuICAgICAgICBpZiAobm9ybWFsLmRvdChjYy5zdWIoZWRnZVdvcmxkLmJlZ2luKSkgPCAwKSB7XHJcbiAgICAgICAgICAgIG5vcm1hbC54ID0gLW5vcm1hbC54O1xyXG4gICAgICAgICAgICBub3JtYWwueSA9IC1ub3JtYWwueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbm9ybWFsID0gbm9ybWFsLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGNvbnN0IHNlcGFyYXRpb24gPSBjaXJjbGUucmFkaXVzIC0gTWF0aC5zcXJ0KGRkKTtcclxuICAgICAgICBjb25zdCBtdnQgPSBub3JtYWwuc2NhbGUoc2VwYXJhdGlvbik7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgY29sbGlkZXI6IGNpcmNsZSxcclxuICAgICAgICAgICAgc2VwYXJhdGlvbjogc2VwYXJhdGlvbixcclxuICAgICAgICAgICAgYXhpczogbm9ybWFsLFxyXG4gICAgICAgICAgICBwb2ludDogcG9pbnRPbkVkZ2UsXHJcbiAgICAgICAgICAgIHNpZGU6IHNpZGUsXHJcbiAgICAgICAgICAgIGxvY2FsU2lkZTogbG9jYWxTaWRlXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICBuZXcgQ29sbGlzaW9uQ29udGFjdChjaXJjbGUsIGVkZ2UsIG12dCwgbm9ybWFsLm5lZ2F0ZSgpLCBub3JtYWwubmVnYXRlKCkucGVycGVuZGljdWxhcigpLCBbcG9pbnRPbkVkZ2VdLCBbcG9pbnRPbkVkZ2Uuc3ViKGVkZ2Uud29ybGRQb3MpXSwgaW5mbylcclxuICAgICAgICBdO1xyXG4gICAgfSxcclxuICAgIENvbGxpZGVFZGdlRWRnZSgpIHtcclxuICAgICAgICAvLyBFZGdlLWVkZ2UgY29sbGlzaW9uIGRvZXNuJ3QgbWFrZSBzZW5zZVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH0sXHJcbiAgICBDb2xsaWRlUG9seWdvbkVkZ2UocG9seWdvbiwgZWRnZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBwYyA9IHBvbHlnb24uY2VudGVyO1xyXG4gICAgICAgIGNvbnN0IGVjID0gZWRnZS5jZW50ZXI7XHJcbiAgICAgICAgY29uc3QgZGlyID0gZWMuc3ViKHBjKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAvLyBidWlsZCBhIHRlbXBvcmFyeSBwb2x5Z29uIGZyb20gdGhlIGVkZ2UgdG8gdXNlIFNBVFxyXG4gICAgICAgIGNvbnN0IGxpbmVQb2x5ID0gbmV3IFBvbHlnb25Db2xsaWRlcih7XHJcbiAgICAgICAgICAgIHBvaW50czogW2VkZ2UuYmVnaW4sIGVkZ2UuZW5kLCBlZGdlLmVuZC5hZGQoZGlyLnNjYWxlKDEwMCkpLCBlZGdlLmJlZ2luLmFkZChkaXIuc2NhbGUoMTAwKSldLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IGVkZ2Uub2Zmc2V0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgbGluZVBvbHkub3duZXIgPSBlZGdlLm93bmVyO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gKF9hID0gZWRnZS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIGlmICh0eCkge1xyXG4gICAgICAgICAgICBsaW5lUG9seS51cGRhdGUoZWRnZS5vd25lci5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEdyb3NzIGhhY2sgYnV0IHBvbHktcG9seSB3b3JrcyB3ZWxsXHJcbiAgICAgICAgY29uc3QgY29udGFjdCA9IHRoaXMuQ29sbGlkZVBvbHlnb25Qb2x5Z29uKHBvbHlnb24sIGxpbmVQb2x5KTtcclxuICAgICAgICBpZiAoY29udGFjdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gRnVkZ2UgdGhlIGNvbnRhY3QgYmFjayB0byBlZGdlXHJcbiAgICAgICAgICAgIGNvbnRhY3RbMF0uY29sbGlkZXJCID0gZWRnZTtcclxuICAgICAgICAgICAgY29udGFjdFswXS5pZCA9IFBhaXIuY2FsY3VsYXRlUGFpckhhc2gocG9seWdvbi5pZCwgZWRnZS5pZCk7XHJcbiAgICAgICAgICAgIC8vIGNvbnRhY3RbMF0uaW5mby5jb2xsaWRlclxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29udGFjdDtcclxuICAgIH0sXHJcbiAgICBDb2xsaWRlUG9seWdvblBvbHlnb24ocG9seUEsIHBvbHlCKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIC8vIE11bHRpIGNvbnRhY3QgZnJvbSBTQVRcclxuICAgICAgICAvLyBodHRwczovL2dhbWVkZXYuc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzExMTM5MC9tdWx0aXBsZS1jb250YWN0cy1mb3Itc2F0LWNvbGxpc2lvbi1kZXRlY3Rpb25cclxuICAgICAgICAvLyBkbyBhIFNBVCB0ZXN0IHRvIGZpbmQgYSBtaW4gYXhpcyBpZiBpdCBleGlzdHNcclxuICAgICAgICBjb25zdCBzZXBhcmF0aW9uQSA9IFNlcGFyYXRpbmdBeGlzLmZpbmRQb2x5Z29uUG9seWdvblNlcGFyYXRpb24ocG9seUEsIHBvbHlCKTtcclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBvdmVybGFwIGZyb20gYm94QSdzIHBlcnNwZWN0aXZlIHdlIGNhbiBlbmQgZWFybHlcclxuICAgICAgICBpZiAoc2VwYXJhdGlvbkEuc2VwYXJhdGlvbiA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzZXBhcmF0aW9uQiA9IFNlcGFyYXRpbmdBeGlzLmZpbmRQb2x5Z29uUG9seWdvblNlcGFyYXRpb24ocG9seUIsIHBvbHlBKTtcclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBvdmVybGFwIGZyb20gYm94QidzIHBlcnNwZWN0aXZlIGV4aXQgbm93XHJcbiAgICAgICAgaWYgKHNlcGFyYXRpb25CLnNlcGFyYXRpb24gPiAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2VwYXJhdGlvbnMgYXJlIGJvdGggbmVnYXRpdmUsIHdlIHdhbnQgdG8gcGljayB0aGUgbGVhc3QgbmVnYXRpdmUgKG1pbmltYWwgbW92ZW1lbnQpXHJcbiAgICAgICAgY29uc3Qgc2VwYXJhdGlvbiA9IHNlcGFyYXRpb25BLnNlcGFyYXRpb24gPiBzZXBhcmF0aW9uQi5zZXBhcmF0aW9uID8gc2VwYXJhdGlvbkEgOiBzZXBhcmF0aW9uQjtcclxuICAgICAgICAvLyBUaGUgaW5jaWRlbnQgc2lkZSBpcyB0aGUgbW9zdCBvcHBvc2l0ZSBmcm9tIHRoZSBheGVzIG9mIGNvbGxpc2lvbiBvbiB0aGUgb3RoZXIgY29sbGlkZXJcclxuICAgICAgICBjb25zdCBvdGhlciA9IHNlcGFyYXRpb24uY29sbGlkZXIgPT09IHBvbHlBID8gcG9seUIgOiBwb2x5QTtcclxuICAgICAgICBjb25zdCBpbmNpZGVudCA9IG90aGVyLmZpbmRTaWRlKHNlcGFyYXRpb24uYXhpcy5uZWdhdGUoKSk7XHJcbiAgICAgICAgLy8gQ2xpcCBpbmNpZGVudCBzaWRlIGJ5IHRoZSBwZXJwZW5kaWN1bGFyIGxpbmVzIGF0IGVhY2ggZW5kIG9mIHRoZSByZWZlcmVuY2Ugc2lkZVxyXG4gICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1N1dGhlcmxhbmQlRTIlODAlOTNIb2RnbWFuX2FsZ29yaXRobVxyXG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IHNlcGFyYXRpb24uc2lkZTtcclxuICAgICAgICBjb25zdCByZWZEaXIgPSByZWZlcmVuY2UuZGlyKCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgLy8gRmluZCBvdXIgY29udGFjdCBwb2ludHMgYnkgY2xpcHBpbmcgdGhlIGluY2lkZW50IGJ5IHRoZSBjb2xsaXNpb24gc2lkZVxyXG4gICAgICAgIGNvbnN0IGNsaXBSaWdodCA9IGluY2lkZW50LmNsaXAocmVmRGlyLm5lZ2F0ZSgpLCAtcmVmRGlyLmRvdChyZWZlcmVuY2UuYmVnaW4pKTtcclxuICAgICAgICBsZXQgY2xpcExlZnQgPSBudWxsO1xyXG4gICAgICAgIGlmIChjbGlwUmlnaHQpIHtcclxuICAgICAgICAgICAgY2xpcExlZnQgPSBjbGlwUmlnaHQuY2xpcChyZWZEaXIsIHJlZkRpci5kb3QocmVmZXJlbmNlLmVuZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBsZWZ0IHRoZXJlIGlzIG5vIGNvbGxpc2lvblxyXG4gICAgICAgIGlmIChjbGlwTGVmdCkge1xyXG4gICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgY2xpcCBwb2ludHMgYmVsb3cgdGhlIHJlZmVyZW5jZSBlZGdlLCBkaXNjYXJkIHRoZSBvdGhlcnNcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gY2xpcExlZnQuZ2V0UG9pbnRzKCkuZmlsdGVyKChwKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmZXJlbmNlLmJlbG93KHApO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGV0IG5vcm1hbCA9IHNlcGFyYXRpb24uYXhpcztcclxuICAgICAgICAgICAgbGV0IHRhbmdlbnQgPSBub3JtYWwucGVycGVuZGljdWxhcigpO1xyXG4gICAgICAgICAgICAvLyBQb2ludCBDb250YWN0IEEgLT4gQlxyXG4gICAgICAgICAgICBpZiAocG9seUIud29ybGRQb3Muc3ViKHBvbHlBLndvcmxkUG9zKS5kb3Qobm9ybWFsKSA8IDApIHtcclxuICAgICAgICAgICAgICAgIG5vcm1hbCA9IG5vcm1hbC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgIHRhbmdlbnQgPSBub3JtYWwucGVycGVuZGljdWxhcigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFBvaW50cyBhcmUgY2xpcHBlZCBmcm9tIGluY2lkZW50IHdoaWNoIGlzIHRoZSBvdGhlciBjb2xsaWRlclxyXG4gICAgICAgICAgICAvLyBTdG9yZSB0aG9zZSBhcyBsb2NhbHNcclxuICAgICAgICAgICAgbGV0IGxvY2FsUG9pbnRzID0gW107XHJcbiAgICAgICAgICAgIGlmIChzZXBhcmF0aW9uLmNvbGxpZGVyID09PSBwb2x5QSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeGYgPSAoX2IgPSAoX2EgPSBwb2x5Qi5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChUcmFuc2Zvcm1Db21wb25lbnQpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVHJhbnNmb3JtQ29tcG9uZW50KCk7XHJcbiAgICAgICAgICAgICAgICBsb2NhbFBvaW50cyA9IHBvaW50cy5tYXAoKHApID0+IHhmLmFwcGx5SW52ZXJzZShwKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4ZiA9IChfZCA9IChfYyA9IHBvbHlBLm93bmVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG5ldyBUcmFuc2Zvcm1Db21wb25lbnQoKTtcclxuICAgICAgICAgICAgICAgIGxvY2FsUG9pbnRzID0gcG9pbnRzLm1hcCgocCkgPT4geGYuYXBwbHlJbnZlcnNlKHApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW25ldyBDb2xsaXNpb25Db250YWN0KHBvbHlBLCBwb2x5Qiwgbm9ybWFsLnNjYWxlKC1zZXBhcmF0aW9uLnNlcGFyYXRpb24pLCBub3JtYWwsIHRhbmdlbnQsIHBvaW50cywgbG9jYWxQb2ludHMsIHNlcGFyYXRpb24pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfSxcclxuICAgIEZpbmRDb250YWN0U2VwYXJhdGlvbihjb250YWN0LCBsb2NhbFBvaW50KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG4gICAgICAgIGNvbnN0IHNoYXBlQSA9IGNvbnRhY3QuY29sbGlkZXJBO1xyXG4gICAgICAgIGNvbnN0IHR4QSA9IChfYiA9IChfYSA9IGNvbnRhY3QuY29sbGlkZXJBLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBUcmFuc2Zvcm1Db21wb25lbnQoKTtcclxuICAgICAgICBjb25zdCBzaGFwZUIgPSBjb250YWN0LmNvbGxpZGVyQjtcclxuICAgICAgICBjb25zdCB0eEIgPSAoX2QgPSAoX2MgPSBjb250YWN0LmNvbGxpZGVyQi5vd25lcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldChUcmFuc2Zvcm1Db21wb25lbnQpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBuZXcgVHJhbnNmb3JtQ29tcG9uZW50KCk7XHJcbiAgICAgICAgLy8gYm90aCBhcmUgY2lyY2xlc1xyXG4gICAgICAgIGlmIChzaGFwZUEgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlciAmJiBzaGFwZUIgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBjb21iaW5lZFJhZGl1cyA9IHNoYXBlQS5yYWRpdXMgKyBzaGFwZUIucmFkaXVzO1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHR4QS5wb3MuZGlzdGFuY2UodHhCLnBvcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRpb24gPSBjb21iaW5lZFJhZGl1cyAtIGRpc3RhbmNlO1xyXG4gICAgICAgICAgICByZXR1cm4gLXNlcGFyYXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGJvdGggYXJlIHBvbHlnb25zXHJcbiAgICAgICAgaWYgKHNoYXBlQSBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlciAmJiBzaGFwZUIgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgaWYgKGNvbnRhY3QuaW5mby5sb2NhbFNpZGUpIHtcclxuICAgICAgICAgICAgICAgIGxldCBzaWRlO1xyXG4gICAgICAgICAgICAgICAgbGV0IHdvcmxkUG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29udGFjdC5pbmZvLmNvbGxpZGVyID09PSBzaGFwZUEpIHtcclxuICAgICAgICAgICAgICAgICAgICBzaWRlID0gbmV3IExpbmUodHhBLmFwcGx5KGNvbnRhY3QuaW5mby5sb2NhbFNpZGUuYmVnaW4pLCB0eEEuYXBwbHkoY29udGFjdC5pbmZvLmxvY2FsU2lkZS5lbmQpKTtcclxuICAgICAgICAgICAgICAgICAgICB3b3JsZFBvaW50ID0gdHhCLmFwcGx5KGxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2lkZSA9IG5ldyBMaW5lKHR4Qi5hcHBseShjb250YWN0LmluZm8ubG9jYWxTaWRlLmJlZ2luKSwgdHhCLmFwcGx5KGNvbnRhY3QuaW5mby5sb2NhbFNpZGUuZW5kKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgd29ybGRQb2ludCA9IHR4QS5hcHBseShsb2NhbFBvaW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBzaWRlLmRpc3RhbmNlVG9Qb2ludCh3b3JsZFBvaW50LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwb2x5Z29uIHYgY2lyY2xlXHJcbiAgICAgICAgaWYgKChzaGFwZUEgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIgJiYgc2hhcGVCIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpIHx8XHJcbiAgICAgICAgICAgIChzaGFwZUIgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIgJiYgc2hhcGVBIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmxkUG9pbnQgPSB0eEEuYXBwbHkobG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChjb250YWN0LmluZm8uc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhY3QuaW5mby5zaWRlLmRpc3RhbmNlVG9Qb2ludCh3b3JsZFBvaW50LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBwb2x5Z29uIHYgZWRnZVxyXG4gICAgICAgIGlmICgoc2hhcGVBIGluc3RhbmNlb2YgRWRnZUNvbGxpZGVyICYmIHNoYXBlQiBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlcikgfHxcclxuICAgICAgICAgICAgKHNoYXBlQiBpbnN0YW5jZW9mIEVkZ2VDb2xsaWRlciAmJiBzaGFwZUEgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIpKSB7XHJcbiAgICAgICAgICAgIGxldCB3b3JsZFBvaW50O1xyXG4gICAgICAgICAgICBpZiAoY29udGFjdC5pbmZvLmNvbGxpZGVyID09PSBzaGFwZUEpIHtcclxuICAgICAgICAgICAgICAgIHdvcmxkUG9pbnQgPSB0eEIuYXBwbHkobG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB3b3JsZFBvaW50ID0gdHhBLmFwcGx5KGxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjb250YWN0LmluZm8uc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhY3QuaW5mby5zaWRlLmRpc3RhbmNlVG9Qb2ludCh3b3JsZFBvaW50LCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjaXJjbGUgdiBlZGdlXHJcbiAgICAgICAgaWYgKChzaGFwZUEgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlciAmJiBzaGFwZUIgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIpIHx8XHJcbiAgICAgICAgICAgIChzaGFwZUIgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlciAmJiBzaGFwZUEgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIpKSB7XHJcbiAgICAgICAgICAgIC8vIExvY2FsIHBvaW50IGlzIGFsd2F5cyBvbiB0aGUgZWRnZSB3aGljaCBpcyBhbHdheXMgc2hhcGVCXHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmxkUG9pbnQgPSB0eEIuYXBwbHkobG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgIGxldCBjaXJjbGVQb2ludDtcclxuICAgICAgICAgICAgaWYgKHNoYXBlQSBpbnN0YW5jZW9mIENpcmNsZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjaXJjbGVQb2ludCA9IHNoYXBlQS5nZXRGdXJ0aGVzdFBvaW50KGNvbnRhY3Qubm9ybWFsKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gd29ybGRQb2ludC5kaXN0YW5jZShjaXJjbGVQb2ludCk7XHJcbiAgICAgICAgICAgIGlmIChjb250YWN0LmluZm8uc2lkZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpc3QgPiAwID8gLWRpc3QgOiAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG59O1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaWRlcnMvRWRnZUNvbGxpZGVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEVkZ2UgaXMgYSBzaW5nbGUgbGluZSBjb2xsaWRlciB0byBjcmVhdGUgY29sbGlzaW9ucyB3aXRoIGEgc2luZ2xlIGxpbmUuXHJcbiAqL1xyXG5jbGFzcyBFZGdlQ29sbGlkZXIgZXh0ZW5kcyBDb2xsaWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5iZWdpbiA9IG9wdGlvbnMuYmVnaW4gfHwgVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5lbmQgPSBvcHRpb25zLmVuZCB8fCBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLm9mZnNldCA9IChfYSA9IG9wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWZWN0b3IuWmVybztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgRWRnZSwgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgY29sbGlkZXJcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBFZGdlQ29sbGlkZXIoe1xyXG4gICAgICAgICAgICBiZWdpbjogdGhpcy5iZWdpbi5jbG9uZSgpLFxyXG4gICAgICAgICAgICBlbmQ6IHRoaXMuZW5kLmNsb25lKClcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGdldCB3b3JsZFBvcygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgdHggPSB0aGlzLl90cmFuc2Zvcm07XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHR4ID09PSBudWxsIHx8IHR4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eC5nbG9iYWxQb3MuYWRkKHRoaXMub2Zmc2V0KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5vZmZzZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2VudGVyIG9mIHRoZSBjb2xsaXNpb24gYXJlYSBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuYmVnaW4uYXZlcmFnZSh0aGlzLmVuZCkuYWRkKHRoaXMuX2dldEJvZHlQb3MoKSk7XHJcbiAgICAgICAgcmV0dXJuIHBvcztcclxuICAgIH1cclxuICAgIF9nZXRCb2R5UG9zKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB0eCA9IHRoaXMuX3RyYW5zZm9ybTtcclxuICAgICAgICBjb25zdCBib2R5UG9zID0gKF9hID0gdHggPT09IG51bGwgfHwgdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR4Lmdsb2JhbFBvcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVmVjdG9yLlplcm87XHJcbiAgICAgICAgcmV0dXJuIGJvZHlQb3M7XHJcbiAgICB9XHJcbiAgICBfZ2V0VHJhbnNmb3JtZWRCZWdpbigpIHtcclxuICAgICAgICBjb25zdCB0eCA9IHRoaXMuX3RyYW5zZm9ybTtcclxuICAgICAgICBjb25zdCBhbmdsZSA9IHR4ID8gdHguZ2xvYmFsUm90YXRpb24gOiAwO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJlZ2luLnJvdGF0ZShhbmdsZSkuYWRkKHRoaXMuX2dldEJvZHlQb3MoKSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0VHJhbnNmb3JtZWRFbmQoKSB7XHJcbiAgICAgICAgY29uc3QgdHggPSB0aGlzLl90cmFuc2Zvcm07XHJcbiAgICAgICAgY29uc3QgYW5nbGUgPSB0eCA/IHR4Lmdsb2JhbFJvdGF0aW9uIDogMDtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmQucm90YXRlKGFuZ2xlKS5hZGQodGhpcy5fZ2V0Qm9keVBvcygpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2xvcGUgb2YgdGhlIGxpbmUgaW4gdGhlIGZvcm0gb2YgYSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgZ2V0U2xvcGUoKSB7XHJcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XHJcbiAgICAgICAgcmV0dXJuIGVuZC5zdWIoYmVnaW4pLnNjYWxlKDEgLyBkaXN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGxlbmd0aCBvZiB0aGUgbGluZSBzZWdtZW50IGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBnZXRMZW5ndGgoKSB7XHJcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGJlZ2luLmRpc3RhbmNlKGVuZCk7XHJcbiAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiBhIHBvaW50IGlzIGNvbnRhaW5lZCBpbiB0aGlzIGNvbGxpc2lvbiBhcmVhXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGluaGVyaXRkb2NcclxuICAgICAqL1xyXG4gICAgcmF5Q2FzdChyYXksIG1heCA9IEluZmluaXR5KSB7XHJcbiAgICAgICAgY29uc3QgbnVtZXJhdG9yID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpLnN1YihyYXkucG9zKTtcclxuICAgICAgICAvLyBUZXN0IGlzIGxpbmUgYW5kIHJheSBhcmUgcGFyYWxsZWwgYW5kIG5vbiBpbnRlcnNlY3RpbmdcclxuICAgICAgICBpZiAocmF5LmRpci5jcm9zcyh0aGlzLmdldFNsb3BlKCkpID09PSAwICYmIG51bWVyYXRvci5jcm9zcyhyYXkuZGlyKSAhPT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTGluZXMgYXJlIHBhcmFsbGVsXHJcbiAgICAgICAgY29uc3QgZGl2aXNvciA9IHJheS5kaXIuY3Jvc3ModGhpcy5nZXRTbG9wZSgpKTtcclxuICAgICAgICBpZiAoZGl2aXNvciA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdCA9IG51bWVyYXRvci5jcm9zcyh0aGlzLmdldFNsb3BlKCkpIC8gZGl2aXNvcjtcclxuICAgICAgICBpZiAodCA+PSAwICYmIHQgPD0gbWF4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHUgPSBudW1lcmF0b3IuY3Jvc3MocmF5LmRpcikgLyBkaXZpc29yIC8gdGhpcy5nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgaWYgKHUgPj0gMCAmJiB1IDw9IDEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByYXkuZ2V0UG9pbnQodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNsb3NlcyBsaW5lIGJldHdlZW4gdGhpcyBhbmQgYW5vdGhlciBjb2xsaWRlciwgZnJvbSB0aGlzIC0+IGNvbGxpZGVyXHJcbiAgICAgKiBAcGFyYW0gc2hhcGVcclxuICAgICAqL1xyXG4gICAgZ2V0Q2xvc2VzdExpbmVCZXR3ZWVuKHNoYXBlKSB7XHJcbiAgICAgICAgaWYgKHNoYXBlIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLkNpcmNsZUVkZ2VDbG9zZXN0TGluZShzaGFwZSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNoYXBlIGluc3RhbmNlb2YgUG9seWdvbkNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbG9zZXN0TGluZUp1bXBUYWJsZS5Qb2x5Z29uRWRnZUNsb3Nlc3RMaW5lKHNoYXBlLCB0aGlzKS5mbGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNoYXBlIGluc3RhbmNlb2YgRWRnZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbG9zZXN0TGluZUp1bXBUYWJsZS5FZGdlRWRnZUNsb3Nlc3RMaW5lKHRoaXMsIHNoYXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seWdvbiBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gQ29sbGlzaW9uU2hhcGUgJHt0eXBlb2Ygc2hhcGV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICovXHJcbiAgICBjb2xsaWRlKHNoYXBlKSB7XHJcbiAgICAgICAgaWYgKHNoYXBlIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlQ2lyY2xlRWRnZShzaGFwZSwgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHNoYXBlIGluc3RhbmNlb2YgUG9seWdvbkNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZVBvbHlnb25FZGdlKHNoYXBlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hhcGUgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlRWRnZUVkZ2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRWRnZSBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gQ29sbGlzaW9uU2hhcGUgJHt0eXBlb2Ygc2hhcGV9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBwb2ludCBvbiB0aGUgY29sbGlkZXIgZnVydGhlc3QgaW4gdGhlIGRpcmVjdGlvbiBzcGVjaWZpZWRcclxuICAgICAqL1xyXG4gICAgZ2V0RnVydGhlc3RQb2ludChkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEJlZ2luID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpO1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkRW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uLmRvdCh0cmFuc2Zvcm1lZEJlZ2luKSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkQmVnaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRFbmQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2JvdW5kc0Zyb21CZWdpbkVuZChiZWdpbiwgZW5kLCBwYWRkaW5nID0gMTApIHtcclxuICAgICAgICAvLyBBIHBlcmZlY3RseSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIGVkZ2Ugd291bGQgaGF2ZSBhIGJvdW5kcyAwIHdpZHRoIG9yIGhlaWdodFxyXG4gICAgICAgIC8vIHRoaXMgY2F1c2VzIHByb2JsZW1zIGZvciB0aGUgY29sbGlzaW9uIHN5c3RlbSBzbyB3ZSBnaXZlIHRoZW0gc29tZSBwYWRkaW5nXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChNYXRoLm1pbihiZWdpbi54LCBlbmQueCkgLSBwYWRkaW5nLCBNYXRoLm1pbihiZWdpbi55LCBlbmQueSkgLSBwYWRkaW5nLCBNYXRoLm1heChiZWdpbi54LCBlbmQueCkgKyBwYWRkaW5nLCBNYXRoLm1heChiZWdpbi55LCBlbmQueSkgKyBwYWRkaW5nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciB0aGUgZWRnZSBjb2xsaWRlciBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBnZXQgYm91bmRzKCkge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRFbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHNGcm9tQmVnaW5FbmQodHJhbnNmb3JtZWRCZWdpbiwgdHJhbnNmb3JtZWRFbmQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIHRoZSBlZGdlIGNvbGxpZGVyIGluIGxvY2FsIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzRnJvbUJlZ2luRW5kKHRoaXMuYmVnaW4sIHRoaXMuZW5kKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGlzIGVkZ2UgcmVwcmVzZW50ZWQgYXMgYSBsaW5lIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGFzTGluZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmUodGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpLCB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoaXMgZWRnZSBhcyBhIGxpbmUgaW4gbG9jYWwgbGluZSBjb29yZGluYXRlcyAocmVsYXRpdmUgdG8gdGhlIHBvc2l0aW9uKVxyXG4gICAgICovXHJcbiAgICBhc0xvY2FsTGluZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmUodGhpcy5iZWdpbiwgdGhpcy5lbmQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGF4aXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBlZGdlXHJcbiAgICAgKi9cclxuICAgIGdldCBheGVzKCkge1xyXG4gICAgICAgIGNvbnN0IGUgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpLnN1Yih0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCkpO1xyXG4gICAgICAgIGNvbnN0IGVkZ2VOb3JtYWwgPSBlLm5vcm1hbCgpO1xyXG4gICAgICAgIGNvbnN0IGF4ZXMgPSBbXTtcclxuICAgICAgICBheGVzLnB1c2goZWRnZU5vcm1hbCk7XHJcbiAgICAgICAgYXhlcy5wdXNoKGVkZ2VOb3JtYWwubmVnYXRlKCkpO1xyXG4gICAgICAgIGF4ZXMucHVzaChlZGdlTm9ybWFsLm5vcm1hbCgpKTtcclxuICAgICAgICBheGVzLnB1c2goZWRnZU5vcm1hbC5ub3JtYWwoKS5uZWdhdGUoKSk7XHJcbiAgICAgICAgcmV0dXJuIGF4ZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbW9tZW50IG9mIGluZXJ0aWEgZm9yIGFuIGVkZ2VcclxuICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhXHJcbiAgICAgKi9cclxuICAgIGdldEluZXJ0aWEobWFzcykge1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuZW5kLnN1Yih0aGlzLmJlZ2luKS5kaXN0YW5jZSgpIC8gMjtcclxuICAgICAgICByZXR1cm4gbWFzcyAqIGxlbmd0aCAqIGxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGluaGVyaXRkb2NcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKHRyYW5zZm9ybSkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvamVjdCB0aGUgZWRnZSBhbG9uZyBhIHNwZWNpZmllZCBheGlzXHJcbiAgICAgKi9cclxuICAgIHByb2plY3QoYXhpcykge1xyXG4gICAgICAgIGNvbnN0IHNjYWxhcnMgPSBbXTtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSBbdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpLCB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpXTtcclxuICAgICAgICBjb25zdCBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgc2NhbGFycy5wdXNoKHBvaW50c1tpXS5kb3QoYXhpcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFByb2plY3Rpb24oTWF0aC5taW4uYXBwbHkoTWF0aCwgc2NhbGFycyksIE1hdGgubWF4LmFwcGx5KE1hdGgsIHNjYWxhcnMpKTtcclxuICAgIH1cclxuICAgIGRyYXcoY3R4LCBjb2xvciA9IENvbG9yLkdyZWVuLCBwb3MgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIGNvbnN0IGJlZ2luID0gdGhpcy5iZWdpbi5hZGQocG9zKTtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLmVuZC5hZGQocG9zKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubW92ZVRvKGJlZ2luLngsIGJlZ2luLnkpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oZW5kLngsIGVuZC55KTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG4gICAgZGVidWcoZXgsIGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRFbmQoKTtcclxuICAgICAgICBleC5kcmF3TGluZShiZWdpbiwgZW5kLCBjb2xvciwgMik7XHJcbiAgICAgICAgZXguZHJhd0NpcmNsZShiZWdpbiwgMiwgY29sb3IpO1xyXG4gICAgICAgIGV4LmRyYXdDaXJjbGUoZW5kLCAyLCBjb2xvcik7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgZGVidWdEcmF3KGN0eCwgY29sb3IgPSBDb2xvci5SZWQpIHtcclxuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8oYmVnaW4ueCwgYmVnaW4ueSk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyhlbmQueCwgZW5kLnkpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQ29sbGlkZXJzL1BvbHlnb25Db2xsaWRlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogUG9seWdvbiBjb2xsaWRlciBmb3IgZGV0ZWN0aW5nIGNvbGxpc2lvbnNcclxuICovXHJcbmNsYXNzIFBvbHlnb25Db2xsaWRlciBleHRlbmRzIENvbGxpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFBvaW50cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2F4ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9zaWRlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xvY2FsU2lkZXMgPSBbXTtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IChfYSA9IG9wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWZWN0b3IuWmVybztcclxuICAgICAgICBjb25zdCB3aW5kaW5nID0gISFvcHRpb25zLmNsb2Nrd2lzZVdpbmRpbmc7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSAod2luZGluZyA/IG9wdGlvbnMucG9pbnRzLnJldmVyc2UoKSA6IG9wdGlvbnMucG9pbnRzKSB8fCBbXTtcclxuICAgICAgICAvLyBjYWxjdWxhdGUgaW5pdGlhbCB0cmFuc2Zvcm1hdGlvblxyXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVRyYW5zZm9ybWF0aW9uKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIENvbnZleFBvbHlnb24sIG5vdCBhc3NvY2lhdGVkIHdpdGggYW55IGNvbGxpZGVyXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbkNvbGxpZGVyKHtcclxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldC5jbG9uZSgpLFxyXG4gICAgICAgICAgICBwb2ludHM6IHRoaXMucG9pbnRzLm1hcCgocCkgPT4gcC5jbG9uZSgpKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB3b3JsZCBwb3NpdGlvbiBvZiB0aGUgY29sbGlkZXIsIHdoaWNoIGlzIHRoZSBjdXJyZW50IGJvZHkgdHJhbnNmb3JtIHBsdXMgYW55IGRlZmluZWQgb2Zmc2V0XHJcbiAgICAgKi9cclxuICAgIGdldCB3b3JsZFBvcygpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0ucG9zLmFkZCh0aGlzLm9mZnNldCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjZW50ZXIgb2YgdGhlIGNvbGxpZGVyIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGdldCBjZW50ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm91bmRzLmNlbnRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgdW5kZXJseWluZyB0cmFuc2Zvcm1hdGlvbiBmcm9tIHRoZSBib2R5IHJlbGF0aXZlIHNwYWNlIHRvIHdvcmxkIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIF9jYWxjdWxhdGVUcmFuc2Zvcm1hdGlvbigpIHtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLl90cmFuc2Zvcm07XHJcbiAgICAgICAgY29uc3QgcG9zID0gdHJhbnNmb3JtID8gdHJhbnNmb3JtLmdsb2JhbFBvcy5hZGQodGhpcy5vZmZzZXQpIDogdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgY29uc3QgYW5nbGUgPSB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0uZ2xvYmFsUm90YXRpb24gOiAwO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gdHJhbnNmb3JtID8gdHJhbnNmb3JtLmdsb2JhbFNjYWxlIDogVmVjdG9yLk9uZTtcclxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLnBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHMubGVuZ3RoID0gMDsgLy8gY2xlYXIgb3V0IG9sZCB0cmFuc2Zvcm1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzW2ldID0gdGhpcy5wb2ludHNbaV0uc2NhbGUoc2NhbGUpLnJvdGF0ZShhbmdsZSkuYWRkKHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb2ludHMgdGhhdCBtYWtlIHVwIHRoZSBwb2x5Z29uIGluIHdvcmxkIHNwYWNlLCBmcm9tIGFjdG9yIHJlbGF0aXZlIHNwYWNlIChpZiBzcGVjaWZpZWQpXHJcbiAgICAgKi9cclxuICAgIGdldFRyYW5zZm9ybWVkUG9pbnRzKCkge1xyXG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZVRyYW5zZm9ybWF0aW9uKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBzaWRlcyBvZiB0aGUgcG9seWdvbiBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBnZXRTaWRlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2lkZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zaWRlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGluZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgd2luZGluZyBpcyBpbXBvcnRhbnRcclxuICAgICAgICAgICAgbGluZXMucHVzaChuZXcgTGluZShwb2ludHNbaV0sIHBvaW50c1soaSArIDEpICUgbGVuXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zaWRlcyA9IGxpbmVzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zaWRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbG9jYWwgY29vcmRpbmF0ZSBzcGFjZSBzaWRlc1xyXG4gICAgICovXHJcbiAgICBnZXRMb2NhbFNpZGVzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sb2NhbFNpZGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxTaWRlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgbGluZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcclxuICAgICAgICBjb25zdCBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gVGhpcyB3aW5kaW5nIGlzIGltcG9ydGFudFxyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKHBvaW50c1tpXSwgcG9pbnRzWyhpICsgMSkgJSBsZW5dKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvY2FsU2lkZXMgPSBsaW5lcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9jYWxTaWRlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBkaXJlY3Rpb24gdmVjdG9yIGZpbmQgdGhlIHdvcmxkIHNwYWNlIHNpZGUgdGhhdCBpcyBtb3N0IGluIHRoYXQgZGlyZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGZpbmRTaWRlKGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHNpZGVzID0gdGhpcy5nZXRTaWRlcygpO1xyXG4gICAgICAgIGxldCBiZXN0U2lkZSA9IHNpZGVzWzBdO1xyXG4gICAgICAgIGxldCBtYXhEaXN0YW5jZSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGZvciAobGV0IHNpZGUgPSAwOyBzaWRlIDwgc2lkZXMubGVuZ3RoOyBzaWRlKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudFNpZGUgPSBzaWRlc1tzaWRlXTtcclxuICAgICAgICAgICAgY29uc3Qgc2lkZU5vcm1hbCA9IGN1cnJlbnRTaWRlLm5vcm1hbCgpO1xyXG4gICAgICAgICAgICBjb25zdCBtb3N0RGlyZWN0aW9uID0gc2lkZU5vcm1hbC5kb3QoZGlyZWN0aW9uKTtcclxuICAgICAgICAgICAgaWYgKG1vc3REaXJlY3Rpb24gPiBtYXhEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdFNpZGUgPSBjdXJyZW50U2lkZTtcclxuICAgICAgICAgICAgICAgIG1heERpc3RhbmNlID0gbW9zdERpcmVjdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmVzdFNpZGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdpdmVuIGEgZGlyZWN0aW9uIHZlY3RvciBmaW5kIHRoZSBsb2NhbCBzcGFjZSBzaWRlIHRoYXQgaXMgbW9zdCBpbiB0aGF0IGRpcmVjdGlvblxyXG4gICAgICogQHBhcmFtIGRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBmaW5kTG9jYWxTaWRlKGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHNpZGVzID0gdGhpcy5nZXRMb2NhbFNpZGVzKCk7XHJcbiAgICAgICAgbGV0IGJlc3RTaWRlID0gc2lkZXNbMF07XHJcbiAgICAgICAgbGV0IG1heERpc3RhbmNlID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgZm9yIChsZXQgc2lkZSA9IDA7IHNpZGUgPCBzaWRlcy5sZW5ndGg7IHNpZGUrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2lkZSA9IHNpZGVzW3NpZGVdO1xyXG4gICAgICAgICAgICBjb25zdCBzaWRlTm9ybWFsID0gY3VycmVudFNpZGUubm9ybWFsKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vc3REaXJlY3Rpb24gPSBzaWRlTm9ybWFsLmRvdChkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAobW9zdERpcmVjdGlvbiA+IG1heERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IGN1cnJlbnRTaWRlO1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBtb3N0RGlyZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiZXN0U2lkZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBheGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29udmV4IHBvbHlnb25cclxuICAgICAqL1xyXG4gICAgZ2V0IGF4ZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2F4ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9heGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBheGVzID0gdGhpcy5nZXRTaWRlcygpLm1hcCgocykgPT4gcy5ub3JtYWwoKSk7XHJcbiAgICAgICAgdGhpcy5fYXhlcyA9IGF4ZXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2F4ZXM7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgICAgIHRoaXMuX3NpZGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fbG9jYWxTaWRlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX2F4ZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKTtcclxuICAgICAgICB0aGlzLmdldFNpZGVzKCk7XHJcbiAgICAgICAgdGhpcy5nZXRMb2NhbFNpZGVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgY29udGFpbmVkIGluIHRoaXMgY29sbGlkZXIgaW4gd29ybGQgc3BhY2VcclxuICAgICAqL1xyXG4gICAgY29udGFpbnMocG9pbnQpIHtcclxuICAgICAgICAvLyBBbHdheXMgY2FzdCB0byB0aGUgcmlnaHQsIGFzIGxvbmcgYXMgd2UgY2FzdCBpbiBhIGNvbnNpc3RlbnQgZml4ZWQgZGlyZWN0aW9uIHdlXHJcbiAgICAgICAgLy8gd2lsbCBiZSBmaW5lXHJcbiAgICAgICAgY29uc3QgdGVzdFJheSA9IG5ldyBSYXkocG9pbnQsIG5ldyBWZWN0b3IoMSwgMCkpO1xyXG4gICAgICAgIGNvbnN0IGludGVyc2VjdENvdW50ID0gdGhpcy5nZXRTaWRlcygpLnJlZHVjZShmdW5jdGlvbiAoYWNjdW0sIHNpZGUpIHtcclxuICAgICAgICAgICAgaWYgKHRlc3RSYXkuaW50ZXJzZWN0KHNpZGUpID49IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSArIDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIGlmIChpbnRlcnNlY3RDb3VudCAlIDIgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldENsb3Nlc3RMaW5lQmV0d2Vlbihjb2xsaWRlcikge1xyXG4gICAgICAgIGlmIChjb2xsaWRlciBpbnN0YW5jZW9mIENpcmNsZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbG9zZXN0TGluZUp1bXBUYWJsZS5Qb2x5Z29uQ2lyY2xlQ2xvc2VzdExpbmUodGhpcywgY29sbGlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2xsaWRlciBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2xvc2VzdExpbmVKdW1wVGFibGUuUG9seWdvblBvbHlnb25DbG9zZXN0TGluZSh0aGlzLCBjb2xsaWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgRWRnZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbG9zZXN0TGluZUp1bXBUYWJsZS5Qb2x5Z29uRWRnZUNsb3Nlc3RMaW5lKHRoaXMsIGNvbGxpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seWdvbiBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gQ29sbGlzaW9uU2hhcGUgJHt0eXBlb2YgY29sbGlkZXJ9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY29sbGlzaW9uIGNvbnRhY3QgaWYgdGhlIDIgY29sbGlkZXJzIGNvbGxpZGUsIG90aGVyd2lzZSBjb2xsaWRlIHdpbGxcclxuICAgICAqIHJldHVybiBudWxsLlxyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyXHJcbiAgICAgKi9cclxuICAgIGNvbGxpZGUoY29sbGlkZXIpIHtcclxuICAgICAgICBpZiAoY29sbGlkZXIgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVQb2x5Z29uKGNvbGxpZGVyLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29sbGlkZXIgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlUG9seWdvblBvbHlnb24odGhpcywgY29sbGlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2xsaWRlciBpbnN0YW5jZW9mIEVkZ2VDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVQb2x5Z29uRWRnZSh0aGlzLCBjb2xsaWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvbHlnb24gY291bGQgbm90IGNvbGxpZGUgd2l0aCB1bmtub3duIENvbGxpc2lvblNoYXBlICR7dHlwZW9mIGNvbGxpZGVyfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCB0aGUgcG9pbnQgb24gdGhlIGNvbGxpZGVyIGZ1cnRoZXN0IGluIHRoZSBkaXJlY3Rpb24gc3BlY2lmaWVkXHJcbiAgICAgKi9cclxuICAgIGdldEZ1cnRoZXN0UG9pbnQoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgcHRzID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgIGxldCBmdXJ0aGVzdFBvaW50ID0gbnVsbDtcclxuICAgICAgICBsZXQgbWF4RGlzdGFuY2UgPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHB0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGRpcmVjdGlvbi5kb3QocHRzW2ldKTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gbWF4RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIG1heERpc3RhbmNlID0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICBmdXJ0aGVzdFBvaW50ID0gcHRzW2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmdXJ0aGVzdFBvaW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBsb2NhbCBwb2ludCBvbiB0aGUgY29sbGlkZXIgZnVydGhlc3QgaW4gdGhlIGRpcmVjdGlvbiBzcGVjaWZpZWRcclxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgZ2V0RnVydGhlc3RMb2NhbFBvaW50KGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHB0cyA9IHRoaXMucG9pbnRzO1xyXG4gICAgICAgIGxldCBmdXJ0aGVzdFBvaW50ID0gcHRzWzBdO1xyXG4gICAgICAgIGxldCBtYXhEaXN0YW5jZSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gZGlyZWN0aW9uLmRvdChwdHNbaV0pO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGZ1cnRoZXN0UG9pbnQgPSBwdHNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1cnRoZXN0UG9pbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmRzIHRoZSBjbG9zZXMgZmFjZSB0byB0aGUgcG9pbnQgdXNpbmcgcGVycGVuZGljdWxhciBkaXN0YW5jZVxyXG4gICAgICogQHBhcmFtIHBvaW50IHBvaW50IHRvIHRlc3QgYWdhaW5zdCBwb2x5Z29uXHJcbiAgICAgKi9cclxuICAgIGdldENsb3Nlc3RGYWNlKHBvaW50KSB7XHJcbiAgICAgICAgY29uc3Qgc2lkZXMgPSB0aGlzLmdldFNpZGVzKCk7XHJcbiAgICAgICAgbGV0IG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgICAgICBsZXQgZmFjZUluZGV4ID0gLTE7XHJcbiAgICAgICAgbGV0IGRpc3RhbmNlID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaWRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gc2lkZXNbaV0uZGlzdGFuY2VUb1BvaW50KHBvaW50KTtcclxuICAgICAgICAgICAgaWYgKGRpc3QgPCBtaW4pIHtcclxuICAgICAgICAgICAgICAgIG1pbiA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICBmYWNlSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBkaXN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmYWNlSW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZTogc2lkZXNbZmFjZUluZGV4XS5ub3JtYWwoKS5zY2FsZShkaXN0YW5jZSksXHJcbiAgICAgICAgICAgICAgICBmYWNlOiBzaWRlc1tmYWNlSW5kZXhdXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIHRoZSBwb2x5Z29uIGNvbGxpZGVyIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGdldCBib3VuZHMoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgY29uc3QgdHggPSB0aGlzLl90cmFuc2Zvcm07XHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSAoX2EgPSB0eCA9PT0gbnVsbCB8fCB0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHguZ2xvYmFsU2NhbGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFZlY3Rvci5PbmU7XHJcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSAoX2IgPSB0eCA9PT0gbnVsbCB8fCB0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHguZ2xvYmFsUm90YXRpb24pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgICAgICAgY29uc3QgcG9zID0gKChfYyA9IHR4ID09PSBudWxsIHx8IHR4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eC5nbG9iYWxQb3MpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFZlY3Rvci5aZXJvKS5hZGQodGhpcy5vZmZzZXQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsQm91bmRzLnNjYWxlKHNjYWxlKS5yb3RhdGUocm90YXRpb24pLnRyYW5zbGF0ZShwb3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIHRoZSBwb2x5Z29uIGNvbGxpZGVyIGluIGxvY2FsIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICByZXR1cm4gQm91bmRpbmdCb3guZnJvbVBvaW50cyh0aGlzLnBvaW50cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbW9tZW50IG9mIGluZXJ0aWEgZm9yIGFuIGFyYml0cmFyeSBwb2x5Z29uXHJcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaXN0X29mX21vbWVudHNfb2ZfaW5lcnRpYVxyXG4gICAgICovXHJcbiAgICBnZXRJbmVydGlhKG1hc3MpIHtcclxuICAgICAgICBsZXQgbnVtZXJhdG9yID0gMDtcclxuICAgICAgICBsZXQgZGVub21pbmF0b3IgPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgaXBsdXNvbmUgPSAoaSArIDEpICUgdGhpcy5wb2ludHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBjb25zdCBjcm9zc1Rlcm0gPSB0aGlzLnBvaW50c1tpcGx1c29uZV0uY3Jvc3ModGhpcy5wb2ludHNbaV0pO1xyXG4gICAgICAgICAgICBudW1lcmF0b3IgKz1cclxuICAgICAgICAgICAgICAgIGNyb3NzVGVybSAqXHJcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMucG9pbnRzW2ldLmRvdCh0aGlzLnBvaW50c1tpXSkgKyB0aGlzLnBvaW50c1tpXS5kb3QodGhpcy5wb2ludHNbaXBsdXNvbmVdKSArIHRoaXMucG9pbnRzW2lwbHVzb25lXS5kb3QodGhpcy5wb2ludHNbaXBsdXNvbmVdKSk7XHJcbiAgICAgICAgICAgIGRlbm9taW5hdG9yICs9IGNyb3NzVGVybTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIChtYXNzIC8gNikgKiAobnVtZXJhdG9yIC8gZGVub21pbmF0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYXN0cyBhIHJheSBpbnRvIHRoZSBwb2x5Z29uIGFuZCByZXR1cm5zIGEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgcG9pbnQgb2YgY29udGFjdCAoaW4gd29ybGQgc3BhY2UpIG9yIG51bGwgaWYgbm8gY29sbGlzaW9uLlxyXG4gICAgICovXHJcbiAgICByYXlDYXN0KHJheSwgbWF4ID0gSW5maW5pdHkpIHtcclxuICAgICAgICAvLyBmaW5kIHRoZSBtaW5pbXVtIGNvbnRhY3QgdGltZSBncmVhdGVyIHRoYW4gMFxyXG4gICAgICAgIC8vIGNvbnRhY3QgdGltZXMgbGVzcyB0aGFuIDAgYXJlIGJlaGluZCB0aGUgcmF5IGFuZCB3ZSBkb24ndCB3YW50IHRob3NlXHJcbiAgICAgICAgY29uc3Qgc2lkZXMgPSB0aGlzLmdldFNpZGVzKCk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gc2lkZXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCBtaW5Db250YWN0VGltZSA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IGNvbnRhY3RJbmRleCA9IC0xO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY29udGFjdFRpbWUgPSByYXkuaW50ZXJzZWN0KHNpZGVzW2ldKTtcclxuICAgICAgICAgICAgaWYgKGNvbnRhY3RUaW1lID49IDAgJiYgY29udGFjdFRpbWUgPCBtaW5Db250YWN0VGltZSAmJiBjb250YWN0VGltZSA8PSBtYXgpIHtcclxuICAgICAgICAgICAgICAgIG1pbkNvbnRhY3RUaW1lID0gY29udGFjdFRpbWU7XHJcbiAgICAgICAgICAgICAgICBjb250YWN0SW5kZXggPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNvbnRhY3Qgd2FzIGZvdW5kXHJcbiAgICAgICAgaWYgKGNvbnRhY3RJbmRleCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiByYXkuZ2V0UG9pbnQobWluQ29udGFjdFRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBubyBjb250YWN0IGZvdW5kXHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb2plY3QgdGhlIGVkZ2VzIG9mIHRoZSBwb2x5Z29uIGFsb25nIGEgc3BlY2lmaWVkIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHJvamVjdChheGlzKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IG1pbiA9IE51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IG1heCA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgc2NhbGFyID0gcG9pbnRzW2ldLmRvdChheGlzKTtcclxuICAgICAgICAgICAgbWluID0gTWF0aC5taW4obWluLCBzY2FsYXIpO1xyXG4gICAgICAgICAgICBtYXggPSBNYXRoLm1heChtYXgsIHNjYWxhcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvamVjdGlvbihtaW4sIG1heCk7XHJcbiAgICB9XHJcbiAgICBkcmF3KGN0eCwgY29sb3IgPSBDb2xvci5HcmVlbiwgcG9zID0gVmVjdG9yLlplcm8pIHtcclxuICAgICAgICBjb25zdCBlZmZlY3RpdmVPZmZzZXQgPSBwb3MuYWRkKHRoaXMub2Zmc2V0KTtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQb2ludCA9IHRoaXMucG9pbnRzWzBdLmFkZChlZmZlY3RpdmVPZmZzZXQpO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xyXG4gICAgICAgIC8vIFBvaW50cyBhcmUgcmVsYXRpdmVcclxuICAgICAgICB0aGlzLnBvaW50c1xyXG4gICAgICAgICAgICAubWFwKChwKSA9PiBwLmFkZChlZmZlY3RpdmVPZmZzZXQpKVxyXG4gICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgIH1cclxuICAgIGRlYnVnKGV4LCBjb2xvcikge1xyXG4gICAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKClbMF07XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gW2ZpcnN0UG9pbnQsIC4uLnRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKSwgZmlyc3RQb2ludF07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XHJcbiAgICAgICAgICAgIGV4LmRyYXdMaW5lKHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgY29sb3IsIDIpO1xyXG4gICAgICAgICAgICBleC5kcmF3Q2lyY2xlKHBvaW50c1tpXSwgMiwgY29sb3IpO1xyXG4gICAgICAgICAgICBleC5kcmF3Q2lyY2xlKHBvaW50c1tpICsgMV0sIDIsIGNvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgZGVidWdEcmF3KGN0eCwgY29sb3IgPSBDb2xvci5SZWQpIHtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIHN1cHBsaWVkIHBvaW50cyBhbmQgY29uc3RydWN0IGEgJ3BvbHlnb24nXHJcbiAgICAgICAgY29uc3QgZmlyc3RQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKVswXTtcclxuICAgICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCkuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54LCBwb2ludC55KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpZGVycy9TaGFwZS50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBFeGNhbGlidXIgaGVscGVyIGZvciBkZWZpbmluZyBjb2xsaWRlcnMgcXVpY2tseVxyXG4gKi9cclxuY2xhc3MgU2hhcGUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYm94IGNvbGxpZGVyLCB1bmRlciB0aGUgaG9vZCBkZWZpbmVzIGEgW1tQb2x5Z29uQ29sbGlkZXJdXSBjb2xsaWRlclxyXG4gICAgICogQHBhcmFtIHdpZHRoIFdpZHRoIG9mIHRoZSBib3hcclxuICAgICAqIEBwYXJhbSBoZWlnaHQgSGVpZ2h0IG9mIHRoZSBib3hcclxuICAgICAqIEBwYXJhbSBhbmNob3IgQW5jaG9yIG9mIHRoZSBib3ggKGRlZmF1bHQgKC41LCAuNSkpIHdoaWNoIHBvc2l0aW9ucyB0aGUgYm94IHJlbGF0aXZlIHRvIHRoZSBjZW50ZXIgb2YgdGhlIGNvbGxpZGVyJ3MgcG9zaXRpb25cclxuICAgICAqIEBwYXJhbSBvZmZzZXQgT3B0aW9uYWwgb2Zmc2V0IHJlbGF0aXZlIHRvIHRoZSBjb2xsaWRlciBpbiBsb2NhbCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgQm94KHdpZHRoLCBoZWlnaHQsIGFuY2hvciA9IFZlY3Rvci5IYWxmLCBvZmZzZXQgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbkNvbGxpZGVyKHtcclxuICAgICAgICAgICAgcG9pbnRzOiBuZXcgQm91bmRpbmdCb3goLXdpZHRoICogYW5jaG9yLngsIC1oZWlnaHQgKiBhbmNob3IueSwgd2lkdGggLSB3aWR0aCAqIGFuY2hvci54LCBoZWlnaHQgLSBoZWlnaHQgKiBhbmNob3IueSkuZ2V0UG9pbnRzKCksXHJcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgW1tQb2x5Z29uQ29sbGlkZXJ8YXJiaXRyYXJ5IHBvbHlnb25dXSBjb2xsaWRlclxyXG4gICAgICpcclxuICAgICAqIFBvbHlnb25Db2xsaWRlcnMgYXJlIHVzZWZ1bCBmb3IgY3JlYXRpbmcgY29udmV4IHBvbHlnb24gc2hhcGVzXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRzIFBvaW50cyBzcGVjaWZpZWQgaW4gY291bnRlciBjbG9ja3dpc2VcclxuICAgICAqIEBwYXJhbSBjbG9ja3dpc2VXaW5kaW5nIE9wdGlvbmFsbHkgY2hhbmdlZCB0aGUgd2luZGluZyBvZiBwb2ludHMsIGJ5IGRlZmF1bHQgZmFsc2UgbWVhbmluZyBjb3VudGVyLWNsb2Nrd2lzZSB3aW5kaW5nLlxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPcHRpb25hbCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGNvbGxpZGVyIGluIGxvY2FsIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBQb2x5Z29uKHBvaW50cywgY2xvY2t3aXNlV2luZGluZyA9IGZhbHNlLCBvZmZzZXQgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbkNvbGxpZGVyKHtcclxuICAgICAgICAgICAgcG9pbnRzOiBwb2ludHMsXHJcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxyXG4gICAgICAgICAgICBjbG9ja3dpc2VXaW5kaW5nOiBjbG9ja3dpc2VXaW5kaW5nXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgW1tDaXJjbGVDb2xsaWRlcnxjaXJjbGVdXSBjb2xsaWRlclxyXG4gICAgICpcclxuICAgICAqIENpcmNsZSBjb2xsaWRlcnMgYXJlIHVzZWZ1bCBmb3IgYmFsbHMsIG9yIHRvIG1ha2UgY29sbGlzaW9ucyBtb3JlIGZvcmdpdmluZyBvbiBzaGFycCBlZGdlc1xyXG4gICAgICogQHBhcmFtIHJhZGl1cyBSYWRpdXMgb2YgdGhlIGNpcmNsZSBjb2xsaWRlclxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPcHRpb25hbCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGNvbGxpZGVyIGluIGxvY2FsIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBDaXJjbGUocmFkaXVzLCBvZmZzZXQgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlQ29sbGlkZXIoe1xyXG4gICAgICAgICAgICByYWRpdXM6IHJhZGl1cyxcclxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBbW0VkZ2VDb2xsaWRlcnxlZGdlXV0gY29sbGlkZXJcclxuICAgICAqXHJcbiAgICAgKiBFZGdlIGNvbGxpZGVycyBhcmUgdXNlZnVsIGZvciAgZmxvb3JzLCB3YWxscywgYW5kIG90aGVyIGJhcnJpZXJzXHJcbiAgICAgKiBAcGFyYW0gYmVnaW4gQmVnaW5uaW5nIG9mIHRoZSBlZGdlIGluIGxvY2FsIGNvb3JkaW5hdGVzIHRvIHRoZSBjb2xsaWRlclxyXG4gICAgICogQHBhcmFtIGVuZCBFbmRpbmcgb2YgdGhlIGVkZ2UgaW4gbG9jYWwgY29vcmRpbmF0ZXMgdG8gdGhlIGNvbGxpZGVyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBFZGdlKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEVkZ2VDb2xsaWRlcih7XHJcbiAgICAgICAgICAgIGJlZ2luOiBiZWdpbixcclxuICAgICAgICAgICAgZW5kOiBlbmRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjYXBzdWxlIHNoYXBlZCBbW0NvbXBvc2l0ZUNvbGxpZGVyXV0gdXNpbmcgMiBjaXJjbGVzIGFuZCBhIGJveFxyXG4gICAgICpcclxuICAgICAqIENhcHN1bGUgY29sbGlkZXJzIGFyZSB1c2VmdWwgZm9yIHBsYXRmb3JtZXJzIHdpdGggaW5jbGluZSBvciBqYWdnZWQgZmxvb3JzIHRvIGhhdmUgYSBzbW9vdGhcclxuICAgICAqIHBsYXllciBleHBlcmllbmNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB3aWR0aFxyXG4gICAgICogQHBhcmFtIGhlaWdodFxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPcHRpb25hbCBvZmZzZXRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIENhcHN1bGUod2lkdGgsIGhlaWdodCwgb2Zmc2V0ID0gVmVjdG9yLlplcm8pIHtcclxuICAgICAgICBjb25zdCBsb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICBpZiAod2lkdGggPT09IGhlaWdodCkge1xyXG4gICAgICAgICAgICBsb2dnZXIud2FybignQSBjYXBzdWxlIGNvbGxpZGVyIHdpdGggZXF1YWwgd2lkdGggYW5kIGhlaWdodCBpcyBhIGNpcmNsZSwgY29uc2lkZXIgdXNpbmcgYSBleC5TaGFwZS5DaXJjbGUgb3IgZXguQ2lyY2xlQ29sbGlkZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdmVydGljYWwgPSBoZWlnaHQgPj0gd2lkdGg7XHJcbiAgICAgICAgaWYgKHZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIC8vIGhlaWdodCA+IHdpZHRoLCBpZiBlcXVhbCBtYXliZSB1c2UgYSBjaXJjbGVcclxuICAgICAgICAgICAgY29uc3QgY2Fwc3VsZSA9IG5ldyBDb21wb3NpdGVDb2xsaWRlcihbXHJcbiAgICAgICAgICAgICAgICBTaGFwZS5DaXJjbGUod2lkdGggLyAyLCB2ZWMoMCwgLWhlaWdodCAvIDIgKyB3aWR0aCAvIDIpLmFkZChvZmZzZXQpKSxcclxuICAgICAgICAgICAgICAgIFNoYXBlLkJveCh3aWR0aCwgaGVpZ2h0IC0gd2lkdGgsIFZlY3Rvci5IYWxmLCBvZmZzZXQpLFxyXG4gICAgICAgICAgICAgICAgU2hhcGUuQ2lyY2xlKHdpZHRoIC8gMiwgdmVjKDAsIGhlaWdodCAvIDIgLSB3aWR0aCAvIDIpLmFkZChvZmZzZXQpKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhcHN1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB3aWR0aCA+IGhlaWdodCwgaWYgZXF1YWwgbWF5YmUgdXNlIGEgY2lyY2xlXHJcbiAgICAgICAgICAgIGNvbnN0IGNhcHN1bGUgPSBuZXcgQ29tcG9zaXRlQ29sbGlkZXIoW1xyXG4gICAgICAgICAgICAgICAgU2hhcGUuQ2lyY2xlKGhlaWdodCAvIDIsIHZlYygtd2lkdGggLyAyICsgaGVpZ2h0IC8gMiwgMCkuYWRkKG9mZnNldCkpLFxyXG4gICAgICAgICAgICAgICAgU2hhcGUuQm94KHdpZHRoIC0gaGVpZ2h0LCBoZWlnaHQsIFZlY3Rvci5IYWxmLCBvZmZzZXQpLFxyXG4gICAgICAgICAgICAgICAgU2hhcGUuQ2lyY2xlKGhlaWdodCAvIDIsIHZlYyh3aWR0aCAvIDIgLSBoZWlnaHQgLyAyLCAwKS5hZGQob2Zmc2V0KSlcclxuICAgICAgICAgICAgXSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjYXBzdWxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaWRlckNvbXBvbmVudC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQ29sbGlkZXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoY29sbGlkZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC5jb2xsaWRlcic7XHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKHRoaXMpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9ic2VydmFibGUgdGhhdCBub3RpZmllcyB3aGVuIGEgY29sbGlkZXIgaXMgYWRkZWQgdG8gdGhlIGJvZHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLiRjb2xsaWRlckFkZGVkID0gbmV3IE9ic2VydmFibGUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPYnNlcnZhYmxlIHRoYXQgbm90aWZpZXMgd2hlbiBhIGNvbGxpZGVyIGlzIHJlbW92ZWQgZnJvbSB0aGUgYm9keVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuJGNvbGxpZGVyUmVtb3ZlZCA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5zZXQoY29sbGlkZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgY29sbGlkZXIgZ2VvbWV0cnlcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGdldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlkZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY29sbGlkZXIgZ2VvbWV0cnlcclxuICAgICAqIEBwYXJhbSBjb2xsaWRlclxyXG4gICAgICogQHJldHVybnMgdGhlIGNvbGxpZGVyIHlvdSBzZXRcclxuICAgICAqL1xyXG4gICAgc2V0KGNvbGxpZGVyKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhcigpO1xyXG4gICAgICAgIGlmIChjb2xsaWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaWRlciA9IGNvbGxpZGVyO1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaWRlci5vd25lciA9IHRoaXMub3duZXI7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLndpcmUoY29sbGlkZXIuZXZlbnRzKTtcclxuICAgICAgICAgICAgdGhpcy4kY29sbGlkZXJBZGRlZC5ub3RpZnlBbGwoY29sbGlkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29sbGlkZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBjb2xsaWRlciBnZW9tZXRyeSBmcm9tIGNvbGxpZGVyIGNvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICBpZiAodGhpcy5fY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMudW53aXJlKHRoaXMuX2NvbGxpZGVyLmV2ZW50cyk7XHJcbiAgICAgICAgICAgIHRoaXMuJGNvbGxpZGVyUmVtb3ZlZC5ub3RpZnlBbGwodGhpcy5fY29sbGlkZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaWRlci5vd25lciA9IG51bGw7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB3b3JsZCBzcGFjZSBib3VuZHNcclxuICAgICAqL1xyXG4gICAgZ2V0IGJvdW5kcygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9jb2xsaWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJvdW5kcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEJvdW5kaW5nQm94KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBsb2NhbCBzcGFjZSBib3VuZHNcclxuICAgICAqL1xyXG4gICAgZ2V0IGxvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX2NvbGxpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxCb3VuZHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBCb3VuZGluZ0JveCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGNvbGxpZGVyJ3MgdHJhbnNmb3JtZWQgZ2VvbWV0cnlcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB0eCA9IChfYSA9IHRoaXMub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICBpZiAodGhpcy5fY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlkZXIub3duZXIgPSB0aGlzLm93bmVyO1xyXG4gICAgICAgICAgICBpZiAodHgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyLnVwZGF0ZSh0eCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbGxpZGUgY29tcG9uZW50IHdpdGggYW5vdGhlclxyXG4gICAgICogQHBhcmFtIG90aGVyXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBjb2xsaWRlKG90aGVyKSB7XHJcbiAgICAgICAgbGV0IGNvbGxpZGVyQSA9IHRoaXMuX2NvbGxpZGVyO1xyXG4gICAgICAgIGxldCBjb2xsaWRlckIgPSBvdGhlci5fY29sbGlkZXI7XHJcbiAgICAgICAgaWYgKCFjb2xsaWRlckEgfHwgIWNvbGxpZGVyQikge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBjb21wb3NpdGUgbGVmdGhhbmQgc2lkZSA6KFxyXG4gICAgICAgIC8vIE1pZ2h0IGJpdGUgdXMsIGJ1dCB0byBhdm9pZCB1cGRhdGluZyBhbGwgdGhlIGhhbmRsZXJzIG1ha2UgY29tcG9zaXRlIGFsd2F5cyBsZWZ0IHNpZGVcclxuICAgICAgICBsZXQgZmxpcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIGlmIChjb2xsaWRlckIgaW5zdGFuY2VvZiBDb21wb3NpdGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICBjb2xsaWRlckEgPSBjb2xsaWRlckI7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyQiA9IHRoaXMuX2NvbGxpZGVyO1xyXG4gICAgICAgICAgICBmbGlwcGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRhY3RzID0gY29sbGlkZXJBLmNvbGxpZGUoY29sbGlkZXJCKTtcclxuICAgICAgICAgICAgaWYgKGNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmxpcHBlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RzLmZvckVhY2goKGNvbnRhY3QpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdC5tdHYgPSBjb250YWN0Lm10di5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdC5ub3JtYWwgPSBjb250YWN0Lm5vcm1hbC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdC50YW5nZW50ID0gY29udGFjdC5ub3JtYWwucGVycGVuZGljdWxhcigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQSA9IHRoaXMuX2NvbGxpZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQiA9IG90aGVyLl9jb2xsaWRlcjtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBjb250YWN0cztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBbXTtcclxuICAgIH1cclxuICAgIG9uQWRkKGVudGl0eSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb2xsaWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXaXJlIHVwIHRoZSBjb2xsaWRlciBldmVudHMgdG8gdGhlIG93bmluZyBlbnRpdHlcclxuICAgICAgICB0aGlzLmV2ZW50cy5vbigncHJlY29sbGlzaW9uJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwcmVjb2xsaXNpb24gPSBldnQ7XHJcbiAgICAgICAgICAgIGVudGl0eS5ldmVudHMuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IFByZUNvbGxpc2lvbkV2ZW50KHByZWNvbGxpc2lvbi50YXJnZXQub3duZXIsIHByZWNvbGxpc2lvbi5vdGhlci5vd25lciwgcHJlY29sbGlzaW9uLnNpZGUsIHByZWNvbGxpc2lvbi5pbnRlcnNlY3Rpb24pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmV2ZW50cy5vbigncG9zdGNvbGxpc2lvbicsIChldnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9zdGNvbGxpc2lvbiA9IGV2dDtcclxuICAgICAgICAgICAgZW50aXR5LmV2ZW50cy5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IFBvc3RDb2xsaXNpb25FdmVudChwb3N0Y29sbGlzaW9uLnRhcmdldC5vd25lciwgcG9zdGNvbGxpc2lvbi5vdGhlci5vd25lciwgcG9zdGNvbGxpc2lvbi5zaWRlLCBwb3N0Y29sbGlzaW9uLmludGVyc2VjdGlvbikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdjb2xsaXNpb25zdGFydCcsIChldnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBldnQ7XHJcbiAgICAgICAgICAgIGVudGl0eS5ldmVudHMuZW1pdCgnY29sbGlzaW9uc3RhcnQnLCBuZXcgQ29sbGlzaW9uU3RhcnRFdmVudChzdGFydC50YXJnZXQub3duZXIsIHN0YXJ0Lm90aGVyLm93bmVyLCBzdGFydC5jb250YWN0KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NvbGxpc2lvbmVuZCcsIChldnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZW5kID0gZXZ0O1xyXG4gICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ2NvbGxpc2lvbmVuZCcsIG5ldyBDb2xsaXNpb25FbmRFdmVudChlbmQudGFyZ2V0Lm93bmVyLCBlbmQub3RoZXIub3duZXIpKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIG9uUmVtb3ZlKCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy4kY29sbGlkZXJSZW1vdmVkLm5vdGlmeUFsbCh0aGlzLl9jb2xsaWRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgYSBib3ggZ2VvbWV0cnkgYmFzZWQgb24gdGhlIGN1cnJlbnQgYm91bmRzIG9mIHRoZSBhc3NvY2lhdGVkIGFjdG9yIG9mIHRoaXMgcGh5c2ljcyBib2R5LlxyXG4gICAgICpcclxuICAgICAqIElmIG5vIHdpZHRoL2hlaWdodCBhcmUgc3BlY2lmaWVkIHRoZSBib2R5IHdpbGwgYXR0ZW1wdCB0byB1c2UgdGhlIGFzc29jaWF0ZWQgYWN0b3IncyB3aWR0aC9oZWlnaHQuXHJcbiAgICAgKlxyXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIGJveCBpcyBjZW50ZXIgaXMgYXQgKDAsIDApIHdoaWNoIG1lYW5zIGl0IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYWN0b3JzIGFuY2hvci5cclxuICAgICAqL1xyXG4gICAgdXNlQm94Q29sbGlkZXIod2lkdGgsIGhlaWdodCwgYW5jaG9yID0gVmVjdG9yLkhhbGYsIGNlbnRlciA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXIgPSBTaGFwZS5Cb3god2lkdGgsIGhlaWdodCwgYW5jaG9yLCBjZW50ZXIpO1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zZXQoY29sbGlkZXIpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB1cCBhIFtbUG9seWdvbkNvbGxpZGVyfHBvbHlnb25dXSBjb2xsaXNpb24gZ2VvbWV0cnkgYmFzZWQgb24gYSBsaXN0IG9mIG9mIHBvaW50cyByZWxhdGl2ZVxyXG4gICAgICogIHRvIHRoZSBhbmNob3Igb2YgdGhlIGFzc29jaWF0ZWQgYWN0b3JcclxuICAgICAqIG9mIHRoaXMgcGh5c2ljcyBib2R5LlxyXG4gICAgICpcclxuICAgICAqIE9ubHkgW2NvbnZleCBwb2x5Z29uXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db252ZXhfcG9seWdvbikgZGVmaW5pdGlvbnMgYXJlIHN1cHBvcnRlZC5cclxuICAgICAqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYm94IGlzIGNlbnRlciBpcyBhdCAoMCwgMCkgd2hpY2ggbWVhbnMgaXQgaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBhY3RvcnMgYW5jaG9yLlxyXG4gICAgICovXHJcbiAgICB1c2VQb2x5Z29uQ29sbGlkZXIocG9pbnRzLCBjZW50ZXIgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIGNvbnN0IHBvbHkgPSBTaGFwZS5Qb2x5Z29uKHBvaW50cywgZmFsc2UsIGNlbnRlcik7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNldChwb2x5KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgYSBbW0NpcmNsZXxjaXJjbGUgY29sbGlzaW9uIGdlb21ldHJ5XV0gYXMgdGhlIG9ubHkgY29sbGlkZXIgd2l0aCBhIHNwZWNpZmllZCByYWRpdXMgaW4gcGl4ZWxzLlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBib3ggaXMgY2VudGVyIGlzIGF0ICgwLCAwKSB3aGljaCBtZWFucyBpdCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFjdG9ycyBhbmNob3IuXHJcbiAgICAgKi9cclxuICAgIHVzZUNpcmNsZUNvbGxpZGVyKHJhZGl1cywgY2VudGVyID0gVmVjdG9yLlplcm8pIHtcclxuICAgICAgICBjb25zdCBjb2xsaWRlciA9IFNoYXBlLkNpcmNsZShyYWRpdXMsIGNlbnRlcik7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNldChjb2xsaWRlcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHVwIGFuIFtbRWRnZXxlZGdlIGNvbGxpc2lvbiBnZW9tZXRyeV1dIHdpdGggYSBzdGFydCBwb2ludCBhbmQgYW4gZW5kIHBvaW50IHJlbGF0aXZlIHRvIHRoZSBhbmNob3Igb2YgdGhlIGFzc29jaWF0ZWQgYWN0b3JcclxuICAgICAqIG9mIHRoaXMgcGh5c2ljcyBib2R5LlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBib3ggaXMgY2VudGVyIGlzIGF0ICgwLCAwKSB3aGljaCBtZWFucyBpdCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFjdG9ycyBhbmNob3IuXHJcbiAgICAgKi9cclxuICAgIHVzZUVkZ2VDb2xsaWRlcihiZWdpbiwgZW5kKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXIgPSBTaGFwZS5FZGdlKGJlZ2luLCBlbmQpO1xyXG4gICAgICAgIHJldHVybiAodGhpcy5zZXQoY29sbGlkZXIpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0dXBzIHVwIGEgW1tDb21wb3NpdGVDb2xsaWRlcl1dIHdoaWNoIGNhbiBkZWZpbmUgYW55IGFyYml0cmFyeSBzZXQgb2YgZXhjYWxpYnVyIGNvbGxpZGVyc1xyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyc1xyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgdXNlQ29tcG9zaXRlQ29sbGlkZXIoY29sbGlkZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNldChuZXcgQ29tcG9zaXRlQ29sbGlkZXIoY29sbGlkZXJzKSkpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0JvZHlDb21wb25lbnQudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIERlZ3JlZU9mRnJlZWRvbTtcclxuKGZ1bmN0aW9uIChEZWdyZWVPZkZyZWVkb20pIHtcclxuICAgIERlZ3JlZU9mRnJlZWRvbVtcIlJvdGF0aW9uXCJdID0gXCJyb3RhdGlvblwiO1xyXG4gICAgRGVncmVlT2ZGcmVlZG9tW1wiWFwiXSA9IFwieFwiO1xyXG4gICAgRGVncmVlT2ZGcmVlZG9tW1wiWVwiXSA9IFwieVwiO1xyXG59KShEZWdyZWVPZkZyZWVkb20gfHwgKERlZ3JlZU9mRnJlZWRvbSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBCb2R5IGRlc2NyaWJlcyBhbGwgdGhlIHBoeXNpY2FsIHByb3BlcnRpZXMgcG9zLCB2ZWwsIGFjYywgcm90YXRpb24sIGFuZ3VsYXIgdmVsb2NpdHkgZm9yIHRoZSBwdXJwb3NlIG9mXHJcbiAqIG9mIHBoeXNpY3Mgc2ltdWxhdGlvbi5cclxuICovXHJcbmNsYXNzIEJvZHlDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4LmJvZHknO1xyXG4gICAgICAgIHRoaXMuZGVwZW5kZW5jaWVzID0gW1RyYW5zZm9ybUNvbXBvbmVudCwgTW90aW9uQ29tcG9uZW50XTtcclxuICAgICAgICB0aGlzLmlkID0gY3JlYXRlSWQoJ2JvZHknLCBCb2R5Q29tcG9uZW50Ll9JRCsrKTtcclxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIodGhpcyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGlzaW9uIHR5cGUgZm9yIHRoZSByaWdpZGJvZHkgcGh5c2ljcyBzaW11bGF0aW9uLCBieSBkZWZhdWx0IFtbQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uXV1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbGxpc2lvblR5cGUgPSBDb2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGNvbGxpc2lvbiBncm91cCBmb3IgdGhlIGJvZHkncyBjb2xsaWRlcnMsIGJ5IGRlZmF1bHQgYm9keSBjb2xsaWRlcnMgY29sbGlkZSB3aXRoIGV2ZXJ5dGhpbmdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdyb3VwID0gQ29sbGlzaW9uR3JvdXAuQWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbW91bnQgb2YgbWFzcyB0aGUgYm9keSBoYXNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1hc3MgPSBQaHlzaWNzLmRlZmF1bHRNYXNzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFtb3VudCBvZiBcIm1vdGlvblwiIHRoZSBib2R5IGhhcyBiZWZvcmUgc2xlZXBpbmcuIElmIGJlbG93IFtbUGh5c2ljcy5zbGVlcEVwc2lsb25dXSBpdCBnb2VzIHRvIFwic2xlZXBcIlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2xlZXBNb3Rpb24gPSBQaHlzaWNzLnNsZWVwRXBzaWxvbiAqIDU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FuIHRoaXMgYm9keSBzbGVlcCwgYnkgZGVmYXVsdCBib2RpZXMgZG8gbm90IHNsZWVwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYW5TbGVlcCA9IFBoeXNpY3MuYm9kaWVzQ2FuU2xlZXBCeURlZmF1bHQ7XHJcbiAgICAgICAgdGhpcy5fc2xlZXBpbmcgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgYWxzbyBrbm93biBhcyBjb2VmZmljaWVudCBvZiByZXN0aXR1dGlvbiBvZiB0aGlzIGFjdG9yLCByZXByZXNlbnRzIHRoZSBhbW91bnQgb2YgZW5lcmd5IHByZXNlcnZlZCBhZnRlciBjb2xsaXNpb24gb3IgdGhlXHJcbiAgICAgICAgICogYm91bmNpbmVzcy4gSWYgMSwgaXQgaXMgMTAwJSBib3VuY3ksIDAgaXQgY29tcGxldGVseSBhYnNvcmJzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYm91bmNpbmVzcyA9IDAuMjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29lZmZpY2llbnQgb2YgZnJpY3Rpb24gb24gdGhpcyBhY3RvclxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZnJpY3Rpb24gPSAwLjk5O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNob3VsZCB1c2UgZ2xvYmFsIGdyYXZpdHkgW1tQaHlzaWNzLmdyYXZpdHldXSBpbiBpdCdzIHBoeXNpY3Mgc2ltdWxhdGlvbiwgZGVmYXVsdCBpcyB0cnVlXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy51c2VHcmF2aXR5ID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEZWdyZWVzIG9mIGZyZWVkb20gdG8gbGltaXRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxpbWl0RGVncmVlT2ZGcmVlZG9tID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHBvc2l0aW9uIG9mIHRoZSBhY3RvciBsYXN0IGZyYW1lICh4LCB5KSBpbiBwaXhlbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9sZFBvcyA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBsYXN0IGZyYW1lICh2eCwgdnkpIGluIHBpeGVscy9zZWNvbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9sZFZlbCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cy9zZXRzIHRoZSBhY2NlbGVyYXRpb24gb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWUuIFRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgZ2xvYmFsIGFjYyBbW1BoeXNpY3MuYWNjXV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vbGRBY2MgPSBWZWN0b3IuWmVybztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzL3NldHMgdGhlIHJvdGF0aW9uIG9mIHRoZSBib2R5IGZyb20gdGhlIGxhc3QgZnJhbWUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vbGRSb3RhdGlvbiA9IDA7IC8vIHJhZGlhbnNcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2NhbGUgb2YgdGhlIGFjdG9yIGxhc3QgZnJhbWVcclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBleC5Cb2R5LnNjYWxlIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNS4wXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vbGRTY2FsZSA9IFZlY3Rvci5PbmU7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xsaXNpb25UeXBlID0gKF9hID0gb3B0aW9ucy50eXBlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmNvbGxpc2lvblR5cGU7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JvdXAgPSAoX2IgPSBvcHRpb25zLmdyb3VwKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmdyb3VwO1xyXG4gICAgICAgICAgICB0aGlzLnVzZUdyYXZpdHkgPSAoX2MgPSBvcHRpb25zLnVzZUdyYXZpdHkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMudXNlR3Jhdml0eTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbnZlcnNlIG1hc3MgKDEvbWFzcykgb2YgdGhlIGJvZHkuIElmIFtbQ29sbGlzaW9uVHlwZS5GaXhlZF1dIHRoaXMgaXMgMCwgbWVhbmluZyBcImluZmluaXRlXCIgbWFzc1xyXG4gICAgICovXHJcbiAgICBnZXQgaW52ZXJzZU1hc3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5GaXhlZCA/IDAgOiAxIC8gdGhpcy5tYXNzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoaXMgYm9keSBpcyBzbGVlcGluZyBvciBub3RcclxuICAgICAqL1xyXG4gICAgZ2V0IHNsZWVwaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zbGVlcGluZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBzbGVlcCBzdGF0ZSBvZiB0aGUgYm9keVxyXG4gICAgICogQHBhcmFtIHNsZWVwaW5nXHJcbiAgICAgKi9cclxuICAgIHNldFNsZWVwaW5nKHNsZWVwaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fc2xlZXBpbmcgPSBzbGVlcGluZztcclxuICAgICAgICBpZiAoIXNsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgIC8vIEdpdmUgaXQgYSBraWNrIHRvIGtlZXAgaXQgZnJvbSBmYWxsaW5nIGFzbGVlcCBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICB0aGlzLnNsZWVwTW90aW9uID0gUGh5c2ljcy5zbGVlcEVwc2lsb24gKiA1O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52ZWwgPSBWZWN0b3IuWmVybztcclxuICAgICAgICAgICAgdGhpcy5hY2MgPSBWZWN0b3IuWmVybztcclxuICAgICAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLnNsZWVwTW90aW9uID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBib2R5J3MgW1tCb2R5Q29tcG9uZW50LnNsZWVwTW90aW9uXV0gZm9yIHRoZSBwdXJwb3NlIG9mIHNsZWVwaW5nXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZU1vdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fc2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTbGVlcGluZyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY3VycmVudE1vdGlvbiA9IHRoaXMudmVsLnNpemUgKiB0aGlzLnZlbC5zaXplICsgTWF0aC5hYnModGhpcy5hbmd1bGFyVmVsb2NpdHkgKiB0aGlzLmFuZ3VsYXJWZWxvY2l0eSk7XHJcbiAgICAgICAgY29uc3QgYmlhcyA9IFBoeXNpY3Muc2xlZXBCaWFzO1xyXG4gICAgICAgIHRoaXMuc2xlZXBNb3Rpb24gPSBiaWFzICogdGhpcy5zbGVlcE1vdGlvbiArICgxIC0gYmlhcykgKiBjdXJyZW50TW90aW9uO1xyXG4gICAgICAgIHRoaXMuc2xlZXBNb3Rpb24gPSBjbGFtcCh0aGlzLnNsZWVwTW90aW9uLCAwLCAxMCAqIFBoeXNpY3Muc2xlZXBFcHNpbG9uKTtcclxuICAgICAgICBpZiAodGhpcy5jYW5TbGVlcCAmJiB0aGlzLnNsZWVwTW90aW9uIDwgUGh5c2ljcy5zbGVlcEVwc2lsb24pIHtcclxuICAgICAgICAgICAgdGhpcy5zZXRTbGVlcGluZyh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbW9tZW50IG9mIGluZXJ0aWEgZnJvbSB0aGUgW1tDb2xsaWRlckNvbXBvbmVudF1dXHJcbiAgICAgKi9cclxuICAgIGdldCBpbmVydGlhKCkge1xyXG4gICAgICAgIC8vIEluZXJ0aWEgaXMgYSBwcm9wZXJ0eSBvZiB0aGUgZ2VvbWV0cnksIHNvIHRoaXMgaXMgYSBsaXR0bGUgZ29vZnkgYnV0IHNlZW1zIHRvIGJlIG9rYXk/XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXIgPSB0aGlzLm93bmVyLmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKGNvbGxpZGVyID09PSBudWxsIHx8IGNvbGxpZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb2xsaWRlci5nZXQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29sbGlkZXIuZ2V0KCkuZ2V0SW5lcnRpYSh0aGlzLm1hc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBpbnZlcnNlIG1vbWVudCBvZiBpbmVydGlhbCBmcm9tIHRoZSBbW0NvbGxpZGVyQ29tcG9uZW50XV0uIElmIFtbQ29sbGlzaW9uVHlwZS5GaXhlZF1dIHRoaXMgaXMgMCwgbWVhbmluZyBcImluZmluaXRlXCIgbWFzc1xyXG4gICAgICovXHJcbiAgICBnZXQgaW52ZXJzZUluZXJ0aWEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5GaXhlZCA/IDAgOiAxIC8gdGhpcy5pbmVydGlhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSBvd25lciBpcyBhY3RpdmVcclxuICAgICAqL1xyXG4gICAgZ2V0IGFjdGl2ZSgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuICEhKChfYSA9IHRoaXMub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmUpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNlbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3M7XHJcbiAgICB9XHJcbiAgICBnZXQgdHJhbnNmb3JtKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1vdGlvbigpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlICh4LCB5KSBwb3NpdGlvbiBvZiB0aGUgYWN0b3IgdGhpcyB3aWxsIGJlIGluIHRoZSBtaWRkbGUgb2YgdGhlIGFjdG9yIGlmIHRoZVxyXG4gICAgICogW1tBY3Rvci5hbmNob3JdXSBpcyBzZXQgdG8gKDAuNSwgMC41KSB3aGljaCBpcyBkZWZhdWx0LlxyXG4gICAgICogSWYgeW91IHdhbnQgdGhlICh4LCB5KSBwb3NpdGlvbiB0byBiZSB0aGUgdG9wIGxlZnQgb2YgdGhlIGFjdG9yIHNwZWNpZnkgYW4gYW5jaG9yIG9mICgwLCAwKS5cclxuICAgICAqL1xyXG4gICAgZ2V0IHBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0uZ2xvYmFsUG9zO1xyXG4gICAgfVxyXG4gICAgc2V0IHBvcyh2YWwpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5nbG9iYWxQb3MgPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IHZlbG9jaXR5IHZlY3RvciAodngsIHZ5KSBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY29uZFxyXG4gICAgICovXHJcbiAgICBnZXQgdmVsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vdGlvbi52ZWw7XHJcbiAgICB9XHJcbiAgICBzZXQgdmVsKHZhbCkge1xyXG4gICAgICAgIHRoaXMubW90aW9uLnZlbCA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgYWNjZWxlcmF0aW9uIHZlY3RvciAoYXgsIGF5KSBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY29uZC9zZWNvbmQuIEFuIGFjY2VsZXJhdGlvbiBwb2ludGluZyBkb3duIHN1Y2ggYXMgKDAsIDEwMCkgbWF5XHJcbiAgICAgKiBiZSB1c2VmdWwgdG8gc2ltdWxhdGUgYSBncmF2aXRhdGlvbmFsIGVmZmVjdC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGFjYygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb3Rpb24uYWNjO1xyXG4gICAgfVxyXG4gICAgc2V0IGFjYyh2YWwpIHtcclxuICAgICAgICB0aGlzLm1vdGlvbi5hY2MgPSB2YWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjdXJyZW50IHRvcnF1ZSBhcHBsaWVkIHRvIHRoZSBhY3RvclxyXG4gICAgICovXHJcbiAgICBnZXQgdG9ycXVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vdGlvbi50b3JxdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgdG9ycXVlKHZhbCkge1xyXG4gICAgICAgIHRoaXMubW90aW9uLnRvcnF1ZSA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJvdGF0aW9uIG9mIHRoZSBib2R5IGluIHJhZGlhbnNcclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5nbG9iYWxSb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHNldCByb3RhdGlvbih2YWwpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5nbG9iYWxSb3RhdGlvbiA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNjYWxlIHZlY3RvciBvZiB0aGUgYWN0b3JcclxuICAgICAqIEBkZXByZWNhdGVkIGV4LkJvZHkuc2NhbGUgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI1LjAsIFVzZSBleC5UcmFuc2Zvcm0uc2NhbGVcclxuICAgICAqL1xyXG4gICAgZ2V0IHNjYWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5nbG9iYWxTY2FsZTtcclxuICAgIH1cclxuICAgIHNldCBzY2FsZSh2YWwpIHtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5nbG9iYWxTY2FsZSA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHggc2NhbGFyIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiBzY2FsZS9zZWNvbmRcclxuICAgICAqIEBkZXByZWNhdGVkIGV4LkJvZHkuc2NhbGUgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI1LjBcclxuICAgICAqL1xyXG4gICAgZ2V0IHN4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vdGlvbi5zY2FsZUZhY3Rvci54O1xyXG4gICAgfVxyXG4gICAgc2V0IHN4KHhGYWN0b3IpIHtcclxuICAgICAgICB0aGlzLm1vdGlvbi5zY2FsZUZhY3Rvci54ID0geEZhY3RvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHkgc2NhbGFyIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiBzY2FsZS9zZWNvbmRcclxuICAgICAqIEBkZXByZWNhdGVkIGV4LkJvZHkuc2NhbGUgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI1LjBcclxuICAgICAqL1xyXG4gICAgZ2V0IHN5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vdGlvbi5zY2FsZUZhY3Rvci55O1xyXG4gICAgfVxyXG4gICAgc2V0IHN5KHlGYWN0b3IpIHtcclxuICAgICAgICB0aGlzLm1vdGlvbi5zY2FsZUZhY3Rvci55ID0geUZhY3RvcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMvc2Vjb25kXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICBnZXQgcngoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLmFuZ3VsYXJWZWxvY2l0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMvc2Vjb25kXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICBzZXQgcngodmFsdWUpIHtcclxuICAgICAgICB0aGlzLm1vdGlvbi5hbmd1bGFyVmVsb2NpdHkgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBhbmd1bGFyIHZlbG9jaXR5IGluIHJhZGlhbnMvc2Vjb25kXHJcbiAgICAgKi9cclxuICAgIGdldCBhbmd1bGFyVmVsb2NpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLmFuZ3VsYXJWZWxvY2l0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBhbmd1bGFyIHZlbG9jaXR5IGluIHJhZGlhbnMvc2Vjb25kXHJcbiAgICAgKi9cclxuICAgIHNldCBhbmd1bGFyVmVsb2NpdHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLm1vdGlvbi5hbmd1bGFyVmVsb2NpdHkgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgYSBzcGVjaWZpYyBpbXB1bHNlIHRvIHRoZSBib2R5XHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqIEBwYXJhbSBpbXB1bHNlXHJcbiAgICAgKi9cclxuICAgIGFwcGx5SW1wdWxzZShwb2ludCwgaW1wdWxzZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbGxpc2lvblR5cGUgIT09IENvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gb25seSBhY3RpdmUgb2JqZWN0cyBwYXJ0aWNpcGF0ZSBpbiB0aGUgc2ltdWxhdGlvblxyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmaW5hbEltcHVsc2UgPSBpbXB1bHNlLnNjYWxlKHRoaXMuaW52ZXJzZU1hc3MpO1xyXG4gICAgICAgIGlmICh0aGlzLmxpbWl0RGVncmVlT2ZGcmVlZG9tLmluY2x1ZGVzKERlZ3JlZU9mRnJlZWRvbS5YKSkge1xyXG4gICAgICAgICAgICBmaW5hbEltcHVsc2UueCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmxpbWl0RGVncmVlT2ZGcmVlZG9tLmluY2x1ZGVzKERlZ3JlZU9mRnJlZWRvbS5ZKSkge1xyXG4gICAgICAgICAgICBmaW5hbEltcHVsc2UueSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudmVsLmFkZEVxdWFsKGZpbmFsSW1wdWxzZSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxpbWl0RGVncmVlT2ZGcmVlZG9tLmluY2x1ZGVzKERlZ3JlZU9mRnJlZWRvbS5Sb3RhdGlvbikpIHtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VGcm9tQ2VudGVyID0gcG9pbnQuc3ViKHRoaXMucG9zKTtcclxuICAgICAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKz0gdGhpcy5pbnZlcnNlSW5lcnRpYSAqIGRpc3RhbmNlRnJvbUNlbnRlci5jcm9zcyhpbXB1bHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IG9ubHkgbGluZWFyIGltcHVsc2UgdG8gdGhlIGJvZHlcclxuICAgICAqIEBwYXJhbSBpbXB1bHNlXHJcbiAgICAgKi9cclxuICAgIGFwcGx5TGluZWFySW1wdWxzZShpbXB1bHNlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29sbGlzaW9uVHlwZSAhPT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBvbmx5IGFjdGl2ZSBvYmplY3RzIHBhcnRpY2lwYXRlIGluIHRoZSBzaW11bGF0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpbmFsSW1wdWxzZSA9IGltcHVsc2Uuc2NhbGUodGhpcy5pbnZlcnNlTWFzcyk7XHJcbiAgICAgICAgaWYgKHRoaXMubGltaXREZWdyZWVPZkZyZWVkb20uaW5jbHVkZXMoRGVncmVlT2ZGcmVlZG9tLlgpKSB7XHJcbiAgICAgICAgICAgIGZpbmFsSW1wdWxzZS54ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubGltaXREZWdyZWVPZkZyZWVkb20uaW5jbHVkZXMoRGVncmVlT2ZGcmVlZG9tLlkpKSB7XHJcbiAgICAgICAgICAgIGZpbmFsSW1wdWxzZS55ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52ZWwgPSB0aGlzLnZlbC5hZGQoZmluYWxJbXB1bHNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgb25seSBhbmd1bGFyIGltcHVzZSB0byB0aGUgYm9keVxyXG4gICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gaW1wdWxzZVxyXG4gICAgICovXHJcbiAgICBhcHBseUFuZ3VsYXJJbXB1bHNlKHBvaW50LCBpbXB1bHNlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29sbGlzaW9uVHlwZSAhPT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBvbmx5IGFjdGl2ZSBvYmplY3RzIHBhcnRpY2lwYXRlIGluIHRoZSBzaW11bGF0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5saW1pdERlZ3JlZU9mRnJlZWRvbS5pbmNsdWRlcyhEZWdyZWVPZkZyZWVkb20uUm90YXRpb24pKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbUNlbnRlciA9IHBvaW50LnN1Yih0aGlzLnBvcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ICs9IHRoaXMuaW52ZXJzZUluZXJ0aWEgKiBkaXN0YW5jZUZyb21DZW50ZXIuY3Jvc3MoaW1wdWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBvbGQgdmVyc2lvbnMgb2YgcG9zLCB2ZWwsIGFjYywgYW5kIHNjYWxlLlxyXG4gICAgICovXHJcbiAgICBjYXB0dXJlT2xkVHJhbnNmb3JtKCkge1xyXG4gICAgICAgIC8vIENhcHR1cmUgb2xkIHZhbHVlcyBiZWZvcmUgaW50ZWdyYXRpb24gc3RlcCB1cGRhdGVzIHRoZW1cclxuICAgICAgICB0aGlzLm9sZFZlbC5zZXRUbyh0aGlzLnZlbC54LCB0aGlzLnZlbC55KTtcclxuICAgICAgICB0aGlzLm9sZFBvcy5zZXRUbyh0aGlzLnBvcy54LCB0aGlzLnBvcy55KTtcclxuICAgICAgICB0aGlzLm9sZEFjYy5zZXRUbyh0aGlzLmFjYy54LCB0aGlzLmFjYy55KTtcclxuICAgICAgICB0aGlzLm9sZFNjYWxlLnNldFRvKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcclxuICAgICAgICB0aGlzLm9sZFJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbjtcclxuICAgIH1cclxuICAgIGRlYnVnRHJhdyhfY3R4KSB7XHJcbiAgICAgICAgLy8gcGFzc1xyXG4gICAgfVxyXG59XHJcbkJvZHlDb21wb25lbnQuX0lEID0gMDtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL0N1bGxpbmdCb3gudHNcblxyXG5cclxuLyoqXHJcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjI2LjBcclxuICovXHJcbmNsYXNzIEN1bGxpbmdCb3gge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fdG9wTGVmdCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fdG9wUmlnaHQgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2JvdHRvbUxlZnQgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2JvdHRvbVJpZ2h0ID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgIH1cclxuICAgIGlzU3ByaXRlT2ZmU2NyZWVuKGFjdG9yLCBlbmdpbmUpIHtcclxuICAgICAgICBjb25zdCBkcmF3aW5nV2lkdGggPSBhY3Rvci5jdXJyZW50RHJhd2luZy5kcmF3V2lkdGg7XHJcbiAgICAgICAgY29uc3QgZHJhd2luZ0hlaWdodCA9IGFjdG9yLmN1cnJlbnREcmF3aW5nLmRyYXdIZWlnaHQ7XHJcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBhY3Rvci5yb3RhdGlvbjtcclxuICAgICAgICBjb25zdCBhbmNob3IgPSBhY3Rvci5jZW50ZXI7XHJcbiAgICAgICAgY29uc3Qgd29ybGRQb3MgPSBhY3Rvci5nZXRHbG9iYWxQb3MoKTtcclxuICAgICAgICB0aGlzLl90b3BMZWZ0ID0gdmVjKHdvcmxkUG9zLnggLSBkcmF3aW5nV2lkdGggLyAyLCB3b3JsZFBvcy55IC0gZHJhd2luZ0hlaWdodCAvIDIpO1xyXG4gICAgICAgIHRoaXMuX3RvcExlZnQgPSB0aGlzLl90b3BMZWZ0LnJvdGF0ZShyb3RhdGlvbiwgYW5jaG9yKTtcclxuICAgICAgICB0aGlzLl90b3BSaWdodCA9IHZlYyh3b3JsZFBvcy54ICsgZHJhd2luZ1dpZHRoIC8gMiwgd29ybGRQb3MueSAtIGRyYXdpbmdIZWlnaHQgLyAyKTtcclxuICAgICAgICB0aGlzLl90b3BSaWdodCA9IHRoaXMuX3RvcFJpZ2h0LnJvdGF0ZShyb3RhdGlvbiwgYW5jaG9yKTtcclxuICAgICAgICB0aGlzLl9ib3R0b21MZWZ0ID0gdmVjKHdvcmxkUG9zLnggLSBkcmF3aW5nV2lkdGggLyAyLCB3b3JsZFBvcy55ICsgZHJhd2luZ0hlaWdodCAvIDIpO1xyXG4gICAgICAgIHRoaXMuX2JvdHRvbUxlZnQgPSB0aGlzLl9ib3R0b21MZWZ0LnJvdGF0ZShyb3RhdGlvbiwgYW5jaG9yKTtcclxuICAgICAgICB0aGlzLl9ib3R0b21SaWdodCA9IHZlYyh3b3JsZFBvcy54ICsgZHJhd2luZ1dpZHRoIC8gMiwgd29ybGRQb3MueSArIGRyYXdpbmdIZWlnaHQgLyAyKTtcclxuICAgICAgICB0aGlzLl9ib3R0b21SaWdodCA9IHRoaXMuX2JvdHRvbVJpZ2h0LnJvdGF0ZShyb3RhdGlvbiwgYW5jaG9yKTtcclxuICAgICAgICBjb25zdCB0b3BMZWZ0U2NyZWVuID0gZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyh0aGlzLl90b3BMZWZ0KTtcclxuICAgICAgICBjb25zdCB0b3BSaWdodFNjcmVlbiA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXModGhpcy5fdG9wUmlnaHQpO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbUxlZnRTY3JlZW4gPSBlbmdpbmUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKHRoaXMuX2JvdHRvbUxlZnQpO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0U2NyZWVuID0gZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyh0aGlzLl9ib3R0b21SaWdodCk7XHJcbiAgICAgICAgdGhpcy5feENvb3JkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3lDb29yZHMgPSBbXTtcclxuICAgICAgICB0aGlzLl94Q29vcmRzLnB1c2godG9wTGVmdFNjcmVlbi54LCB0b3BSaWdodFNjcmVlbi54LCBib3R0b21MZWZ0U2NyZWVuLngsIGJvdHRvbVJpZ2h0U2NyZWVuLngpO1xyXG4gICAgICAgIHRoaXMuX3lDb29yZHMucHVzaCh0b3BMZWZ0U2NyZWVuLnksIHRvcFJpZ2h0U2NyZWVuLnksIGJvdHRvbUxlZnRTY3JlZW4ueSwgYm90dG9tUmlnaHRTY3JlZW4ueSk7XHJcbiAgICAgICAgdGhpcy5feE1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIHRoaXMuX3hDb29yZHMpO1xyXG4gICAgICAgIHRoaXMuX3lNaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCB0aGlzLl95Q29vcmRzKTtcclxuICAgICAgICB0aGlzLl94TWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy5feENvb3Jkcyk7XHJcbiAgICAgICAgdGhpcy5feU1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRoaXMuX3lDb29yZHMpO1xyXG4gICAgICAgIGNvbnN0IG1pbldvcmxkID0gZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgVmVjdG9yKHRoaXMuX3hNaW4sIHRoaXMuX3lNaW4pKTtcclxuICAgICAgICBjb25zdCBtYXhXb3JsZCA9IGVuZ2luZS5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMobmV3IFZlY3Rvcih0aGlzLl94TWF4LCB0aGlzLl95TWF4KSk7XHJcbiAgICAgICAgdGhpcy5feE1pbldvcmxkID0gbWluV29ybGQueDtcclxuICAgICAgICB0aGlzLl95TWluV29ybGQgPSBtaW5Xb3JsZC55O1xyXG4gICAgICAgIHRoaXMuX3hNYXhXb3JsZCA9IG1heFdvcmxkLng7XHJcbiAgICAgICAgdGhpcy5feU1heFdvcmxkID0gbWF4V29ybGQueTtcclxuICAgICAgICBjb25zdCBib3VuZGluZ1BvaW50cyA9IFtcclxuICAgICAgICAgICAgbmV3IFZlY3Rvcih0aGlzLl94TWluLCB0aGlzLl95TWluKSxcclxuICAgICAgICAgICAgbmV3IFZlY3Rvcih0aGlzLl94TWF4LCB0aGlzLl95TWluKSxcclxuICAgICAgICAgICAgbmV3IFZlY3Rvcih0aGlzLl94TWluLCB0aGlzLl95TWF4KSxcclxuICAgICAgICAgICAgbmV3IFZlY3Rvcih0aGlzLl94TWF4LCB0aGlzLl95TWF4KSAvLyBib3R0b20gcmlnaHRcclxuICAgICAgICBdO1xyXG4gICAgICAgIC8vIHNwcml0ZSBjYW4gYmUgd2lkZXIgdGhhbiBjYW52YXMgc2NyZWVuIChhbmQgc3RpbGwgdmlzaWJsZSB3aXRoaW4gY2FudmFzKVxyXG4gICAgICAgIC8vIHRvcCBvciBib3R0b20gb2Ygc3ByaXRlIG11c3QgYmUgd2l0aGluIGNhbnZhc1xyXG4gICAgICAgIGlmIChib3VuZGluZ1BvaW50c1swXS54IDwgMCAmJlxyXG4gICAgICAgICAgICBib3VuZGluZ1BvaW50c1sxXS54ID4gZW5naW5lLmNhbnZhcy5jbGllbnRXaWR0aCAmJlxyXG4gICAgICAgICAgICAoYm91bmRpbmdQb2ludHNbMF0ueSA+IDAgfHwgYm91bmRpbmdQb2ludHNbMl0ueSA8IGVuZ2luZS5jYW52YXMuY2xpZW50SGVpZ2h0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHNwcml0ZSBjYW4gYmUgdGFsbGVyIHRoYW4gY2FudmFzIHNjcmVlbiAoYW5kIHN0aWxsIHZpc2libGUgd2l0aGluIGNhbnZhcylcclxuICAgICAgICAvLyBsZWZ0IG9yIHJpZ2h0IG9mIHNwcml0ZSBtdXN0IGJlIHdpdGhpbiBjYW52YXNcclxuICAgICAgICBpZiAoYm91bmRpbmdQb2ludHNbMF0ueSA8IDAgJiZcclxuICAgICAgICAgICAgYm91bmRpbmdQb2ludHNbMl0ueSA+IGVuZ2luZS5jYW52YXMuY2xpZW50SGVpZ2h0ICYmXHJcbiAgICAgICAgICAgIChib3VuZGluZ1BvaW50c1sxXS54ID4gMCB8fCBib3VuZGluZ1BvaW50c1swXS54IDwgZW5naW5lLmNhbnZhcy5jbGllbnRXaWR0aCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBvdGhlcndpc2UgaWYgYW55IGNvcm5lciBpcyB2aXNpYmxlLCB3ZSdyZSBub3Qgb2Zmc2NyZWVuXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3VuZGluZ1BvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoYm91bmRpbmdQb2ludHNbaV0ueCA+IDAgJiZcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nUG9pbnRzW2ldLnkgPiAwICYmXHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1BvaW50c1tpXS54IDwgZW5naW5lLmNhbnZhcy5jbGllbnRXaWR0aCAmJlxyXG4gICAgICAgICAgICAgICAgYm91bmRpbmdQb2ludHNbaV0ueSA8IGVuZ2luZS5jYW52YXMuY2xpZW50SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBkZWJ1Z0RyYXcoY3R4KSB7XHJcbiAgICAgICAgLy8gYm91bmRpbmcgcmVjdGFuZ2xlXHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9yLldoaXRlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LnJlY3QodGhpcy5feE1pbldvcmxkLCB0aGlzLl95TWluV29ybGQsIHRoaXMuX3hNYXhXb3JsZCAtIHRoaXMuX3hNaW5Xb3JsZCwgdGhpcy5feU1heFdvcmxkIC0gdGhpcy5feU1pbldvcmxkKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yLlJlZC50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguYXJjKHRoaXMuX3RvcExlZnQueCwgdGhpcy5fdG9wTGVmdC55LCA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yLkdyZWVuLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5hcmModGhpcy5fdG9wUmlnaHQueCwgdGhpcy5fdG9wUmlnaHQueSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvci5CbHVlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5hcmModGhpcy5fYm90dG9tTGVmdC54LCB0aGlzLl9ib3R0b21MZWZ0LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3IuTWFnZW50YS50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguYXJjKHRoaXMuX2JvdHRvbVJpZ2h0LngsIHRoaXMuX2JvdHRvbVJpZ2h0LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1RyYWl0cy9PZmZzY3JlZW5DdWxsaW5nLnRzXG5cclxuXHJcblxyXG4vKipcclxuICogQGRlcHJlY2F0ZWQgd2lsbCBiZSByZW1vdmVkIGluIDAuMjYuMFxyXG4gKi9cclxuY2xhc3MgT2Zmc2NyZWVuQ3VsbGluZyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmN1bGxpbmdCb3ggPSBuZXcgQ3VsbGluZ0JveCgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGFjdG9yLCBlbmdpbmUpIHtcclxuICAgICAgICBjb25zdCBldmVudHMgPSBhY3Rvci5ldmVudERpc3BhdGNoZXI7XHJcbiAgICAgICAgbGV0IGlzU3ByaXRlT2ZmU2NyZWVuID0gdHJ1ZTtcclxuICAgICAgICBpZiAoYWN0b3IuY3VycmVudERyYXdpbmcgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICBpc1Nwcml0ZU9mZlNjcmVlbiA9IHRoaXMuY3VsbGluZ0JveC5pc1Nwcml0ZU9mZlNjcmVlbihhY3RvciwgZW5naW5lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGFjdG9yQm91bmRzT2Zmc2NyZWVuID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGVuZ2luZSAmJiBlbmdpbmUuY3VycmVudFNjZW5lICYmIGVuZ2luZS5jdXJyZW50U2NlbmUuY2FtZXJhICYmIGVuZ2luZS5jdXJyZW50U2NlbmUuY2FtZXJhLnZpZXdwb3J0ICYmICFhY3Rvci5wYXJlbnQpIHtcclxuICAgICAgICAgICAgYWN0b3JCb3VuZHNPZmZzY3JlZW4gPSAhZW5naW5lLmN1cnJlbnRTY2VuZS5jYW1lcmEudmlld3BvcnQuaW50ZXJzZWN0KGFjdG9yLmNvbGxpZGVyLmJvdW5kcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYWN0b3IuaXNPZmZTY3JlZW4pIHtcclxuICAgICAgICAgICAgaWYgKGFjdG9yQm91bmRzT2Zmc2NyZWVuICYmIGlzU3ByaXRlT2ZmU2NyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHMuZW1pdCgnZXhpdHZpZXdwb3J0JywgbmV3IEV4aXRWaWV3UG9ydEV2ZW50KGFjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICBhY3Rvci5hZGRDb21wb25lbnQobmV3IFRhZ0NvbXBvbmVudCgnb2Zmc2NyZWVuJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoIWFjdG9yQm91bmRzT2Zmc2NyZWVuIHx8ICFpc1Nwcml0ZU9mZlNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgZXZlbnRzLmVtaXQoJ2VudGVydmlld3BvcnQnLCBuZXcgRW50ZXJWaWV3UG9ydEV2ZW50KGFjdG9yKSk7XHJcbiAgICAgICAgICAgICAgICBhY3Rvci5yZW1vdmVDb21wb25lbnQoJ29mZnNjcmVlbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVHJhaXRzL0NhcHR1cmVQb2ludGVyLnRzXG4vKipcclxuICogUmV2aXNlcyBwb2ludGVyIGV2ZW50cyBwYXRoIGFjY29yZGluZ2x5IHRvIHRoZSBhY3RvclxyXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gMC4yNi4wXHJcbiAqL1xyXG5jbGFzcyBDYXB0dXJlUG9pbnRlciB7XHJcbiAgICB1cGRhdGUoYWN0b3IsIGVuZ2luZSkge1xyXG4gICAgICAgIGlmICghYWN0b3IuZW5hYmxlQ2FwdHVyZVBvaW50ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoYWN0b3IuaXNLaWxsZWQoKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVuZ2luZS5pbnB1dC5wb2ludGVycy5jaGVja0FuZFVwZGF0ZUFjdG9yVW5kZXJQb2ludGVyKGFjdG9yKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9FbnRpdHkudHNcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEFkZGVkQ29tcG9uZW50IG1lc3NhZ2VcclxuICovXHJcbmNsYXNzIEFkZGVkQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdDb21wb25lbnQgQWRkZWQnO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIHRvIGtub3cgaWYgbWVzc2FnZSBpcyBmIGFuIEFkZGVkIENvbXBvbmVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNBZGRlZENvbXBvbmVudCh4KSB7XHJcbiAgICByZXR1cm4gISF4ICYmIHgudHlwZSA9PT0gJ0NvbXBvbmVudCBBZGRlZCc7XHJcbn1cclxuLyoqXHJcbiAqIFJlbW92ZWRDb21wb25lbnQgbWVzc2FnZVxyXG4gKi9cclxuY2xhc3MgUmVtb3ZlZENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnQ29tcG9uZW50IFJlbW92ZWQnO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIHRvIGtub3cgaWYgbWVzc2FnZSBpcyBmb3IgYSBSZW1vdmVkIENvbXBvbmVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZW1vdmVkQ29tcG9uZW50KHgpIHtcclxuICAgIHJldHVybiAhIXggJiYgeC50eXBlID09PSAnQ29tcG9uZW50IFJlbW92ZWQnO1xyXG59XHJcbi8qKlxyXG4gKiBBbiBFbnRpdHkgaXMgdGhlIGJhc2UgdHlwZSBvZiBhbnl0aGluZyB0aGF0IGNhbiBoYXZlIGJlaGF2aW9yIGluIEV4Y2FsaWJ1ciwgdGhleSBhcmUgcGFydCBvZiB0aGUgYnVpbHQgaW4gZW50aXR5IGNvbXBvbmVudCBzeXN0ZW1cclxuICpcclxuICogRW50aXRpZXMgY2FuIGJlIHN0cm9uZ2x5IHR5cGVkIHdpdGggdGhlIGNvbXBvbmVudHMgdGhleSBjb250YWluXHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgZW50aXR5ID0gbmV3IEVudGl0eTxDb21wb25lbnRBIHwgQ29tcG9uZW50Qj4oKTtcclxuICogZW50aXR5LmNvbXBvbmVudHMuYTsgLy8gVHlwZSBDb21wb25lbnRBXHJcbiAqIGVudGl0eS5jb21wb25lbnRzLmI7IC8vIFR5cGUgQ29tcG9uZW50QlxyXG4gKiBgYGBcclxuICovXHJcbmNsYXNzIEVudGl0eSBleHRlbmRzIENsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudHMsIG5hbWUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGVudGl0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaWQgPSBFbnRpdHkuX0lEKys7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9ICdhbm9ueW1vdXMnO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgdGhpcyBlbnRpdHkgaXMgYWN0aXZlLCBpZiBzZXQgdG8gZmFsc2UgaXQgd2lsbCBiZSByZWNsYWltZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnVja2V0IHRvIGhvbGQgb24gdG8gZGVmZXJyZWQgcmVtb3ZhbHNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9jb21wb25lbnRzVG9SZW1vdmUgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb21wb25lbnRUeXBlVG9JbnN0YW5jZSA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9jb21wb25lbnRTdHJpbmdUb0luc3RhbmNlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3RhZ3NNZW1vID0gW107XHJcbiAgICAgICAgdGhpcy5fdHlwZXNNZW1vID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2JzZXJ2YWJsZSB0aGF0IGtlZXBzIHRyYWNrIG9mIGNvbXBvbmVudCBhZGQgb3IgcmVtb3ZlIGNoYW5nZXMgb24gdGhlIGVudGl0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50QWRkZWQkID0gbmV3IE9ic2VydmFibGUoKTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudFJlbW92ZWQkID0gbmV3IE9ic2VydmFibGUoKTtcclxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5BZGRlZCQgPSBuZXcgT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW5SZW1vdmVkJCA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5fY2hpbGRyZW4gPSBbXTtcclxuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc2V0TmFtZShuYW1lKTtcclxuICAgICAgICBpZiAoY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudCBvZiBjb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3NldE5hbWUobmFtZSkge1xyXG4gICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSBuYW1lO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0IGV2ZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ldmVudERpc3BhdGNoZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEtpbGwgdGhlIGVudGl0eSwgbWVhbnMgaXQgd2lsbCBubyBsb25nZXIgYmUgdXBkYXRlZC4gS2lsbHMgYXJlIGRlZmVycmVkIHRvIHRoZSBlbmQgb2YgdGhlIHVwZGF0ZS5cclxuICAgICAqL1xyXG4gICAga2lsbCgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaXNLaWxsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmFjdGl2ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3BlY2lmaWNhbGx5IGdldCB0aGUgdGFncyBvbiB0aGUgZW50aXR5IGZyb20gW1tUYWdDb21wb25lbnRdXVxyXG4gICAgICovXHJcbiAgICBnZXQgdGFncygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGFnc01lbW87XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrIGlmIGEgdGFnIGV4aXN0cyBvbiB0aGUgZW50aXR5XHJcbiAgICAgKiBAcGFyYW0gdGFnIG5hbWUgdG8gY2hlY2sgZm9yXHJcbiAgICAgKi9cclxuICAgIGhhc1RhZyh0YWcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50YWdzLmluY2x1ZGVzKHRhZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSB0YWcgdG8gYW4gZW50aXR5XHJcbiAgICAgKiBAcGFyYW0gdGFnXHJcbiAgICAgKiBAcmV0dXJucyBFbnRpdHlcclxuICAgICAqL1xyXG4gICAgYWRkVGFnKHRhZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFkZENvbXBvbmVudChuZXcgVGFnQ29tcG9uZW50KHRhZykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgdGFnIG9uIHRoZSBlbnRpdHlcclxuICAgICAqXHJcbiAgICAgKiBSZW1vdmFscyBhcmUgZGVmZXJyZWQgdW50aWwgdGhlIGVuZCBvZiB1cGRhdGVcclxuICAgICAqIEBwYXJhbSB0YWdcclxuICAgICAqIEBwYXJhbSBmb3JjZSBSZW1vdmUgY29tcG9uZW50IGltbWVkaWF0ZWx5LCBubyBkZWZlcnJlZFxyXG4gICAgICovXHJcbiAgICByZW1vdmVUYWcodGFnLCBmb3JjZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQ29tcG9uZW50KHRhZywgZm9yY2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHlwZXMgb2YgdGhlIGNvbXBvbmVudHMgb24gdGhlIEVudGl0eVxyXG4gICAgICovXHJcbiAgICBnZXQgdHlwZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3R5cGVzTWVtbztcclxuICAgIH1cclxuICAgIF9yZWJ1aWxkTWVtb3MoKSB7XHJcbiAgICAgICAgdGhpcy5fdGFnc01lbW8gPSBBcnJheS5mcm9tKHRoaXMuX2NvbXBvbmVudFN0cmluZ1RvSW5zdGFuY2UudmFsdWVzKCkpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGMpID0+IGMgaW5zdGFuY2VvZiBUYWdDb21wb25lbnQpXHJcbiAgICAgICAgICAgIC5tYXAoKGMpID0+IGMudHlwZSk7XHJcbiAgICAgICAgdGhpcy5fdHlwZXNNZW1vID0gQXJyYXkuZnJvbSh0aGlzLl9jb21wb25lbnRTdHJpbmdUb0luc3RhbmNlLmtleXMoKSk7XHJcbiAgICB9XHJcbiAgICBnZXRDb21wb25lbnRzKCkge1xyXG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX2NvbXBvbmVudFN0cmluZ1RvSW5zdGFuY2UudmFsdWVzKCkpO1xyXG4gICAgfVxyXG4gICAgX25vdGlmeUFkZENvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLl9yZWJ1aWxkTWVtb3MoKTtcclxuICAgICAgICBjb25zdCBhZGRlZCA9IG5ldyBBZGRlZENvbXBvbmVudCh7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudCxcclxuICAgICAgICAgICAgZW50aXR5OiB0aGlzXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRBZGRlZCQubm90aWZ5QWxsKGFkZGVkKTtcclxuICAgIH1cclxuICAgIF9ub3RpZnlSZW1vdmVDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgY29uc3QgcmVtb3ZlZCA9IG5ldyBSZW1vdmVkQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgY29tcG9uZW50LFxyXG4gICAgICAgICAgICBlbnRpdHk6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudFJlbW92ZWQkLm5vdGlmeUFsbChyZW1vdmVkKTtcclxuICAgICAgICB0aGlzLl9yZWJ1aWxkTWVtb3MoKTtcclxuICAgIH1cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkaXJlY3QgY2hpbGRyZW4gb2YgdGhpcyBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW5wYXJlbnRzIHRoaXMgZW50aXR5LCBpZiB0aGVyZSBpcyBhIHBhcmVudC4gT3RoZXJ3aXNlIGl0IGRvZXMgbm90aGluZy5cclxuICAgICAqL1xyXG4gICAgdW5wYXJlbnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQucmVtb3ZlQ2hpbGQodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGVudGl0eSB0byBiZSBhIGNoaWxkIG9mIHRoaXMgZW50aXR5XHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIGFkZENoaWxkKGVudGl0eSkge1xyXG4gICAgICAgIGlmIChlbnRpdHkucGFyZW50ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEFuY2VzdG9ycygpLmluY2x1ZGVzKGVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ3ljbGUgZGV0ZWN0ZWQsIGNhbm5vdCBhZGQgZW50aXR5Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fY2hpbGRyZW4ucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICBlbnRpdHkuX3BhcmVudCA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5BZGRlZCQubm90aWZ5QWxsKGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudGl0eSBhbHJlYWR5IGhhcyBhIHBhcmVudCwgY2Fubm90IGFkZCB3aXRob3V0IHVucGFyZW50aW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gZW50aXR5IGZyb20gY2hpbGRyZW4gaWYgaXQgZXhpc3RzXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUNoaWxkKGVudGl0eSkge1xyXG4gICAgICAgIGlmIChlbnRpdHkucGFyZW50ID09PSB0aGlzKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUl0ZW1Gcm9tQXJyYXkoZW50aXR5LCB0aGlzLl9jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIGVudGl0eS5fcGFyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlblJlbW92ZWQkLm5vdGlmeUFsbChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgY2hpbGRyZW4gZnJvbSB0aGlzIGVudGl0eVxyXG4gICAgICovXHJcbiAgICByZW1vdmVBbGxDaGlsZHJlbigpIHtcclxuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKGMpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVDaGlsZChjKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgcGFyZW50IGVudGl0aWVzIHN0YXJ0aW5nIHdpdGggdGhlIHRvcG1vc3QgcGFyZW50LiBJbmNsdWRlcyB0aGUgY3VycmVudCBlbnRpdHkuXHJcbiAgICAgKi9cclxuICAgIGdldEFuY2VzdG9ycygpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbdGhpc107XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudCkge1xyXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHRoZSBlbnRpdGllcyB0aGF0IGRlc2NlbmQgZnJvbSB0aGlzIGVudGl0eS4gSW5jbHVkZXMgdGhlIGN1cnJlbnQgZW50aXR5LlxyXG4gICAgICovXHJcbiAgICBnZXREZXNjZW5kYW50cygpIHtcclxuICAgICAgICBsZXQgcmVzdWx0ID0gW3RoaXNdO1xyXG4gICAgICAgIGxldCBxdWV1ZSA9IFt0aGlzXTtcclxuICAgICAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyID0gcXVldWUucG9wKCk7XHJcbiAgICAgICAgICAgIHF1ZXVlID0gcXVldWUuY29uY2F0KGN1cnIuY2hpbGRyZW4pO1xyXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGN1cnIuY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSBlbnRpdHkgYW5kIGEgY29weSBvZiBhbGwgaXRzIGNvbXBvbmVudHNcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgbmV3RW50aXR5ID0gbmV3IEVudGl0eSgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnR5cGVzKSB7XHJcbiAgICAgICAgICAgIG5ld0VudGl0eS5hZGRDb21wb25lbnQodGhpcy5nZXQoYykuY2xvbmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBuZXdFbnRpdHkuYWRkQ2hpbGQoY2hpbGQuY2xvbmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXdFbnRpdHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBjb3B5IG9mIGFsbCB0aGUgY29tcG9uZW50cyBmcm9tIGFub3RoZXIgdGVtcGxhdGUgZW50aXR5IGFzIGEgXCJwcmVmYWJcIlxyXG4gICAgICogQHBhcmFtIHRlbXBsYXRlRW50aXR5IEVudGl0eSB0byB1c2UgYXMgYSB0ZW1wbGF0ZVxyXG4gICAgICogQHBhcmFtIGZvcmNlIEZvcmNlIGNvbXBvbmVudCByZXBsYWNlbWVudCBpZiBpdCBhbGVhZHkgZXhpc3RzIG9uIHRoZSB0YXJnZXQgZW50aXR5XHJcbiAgICAgKi9cclxuICAgIGFkZFRlbXBsYXRlKHRlbXBsYXRlRW50aXR5LCBmb3JjZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRlbXBsYXRlRW50aXR5LmdldENvbXBvbmVudHMoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChjLmNsb25lKCksIGZvcmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0ZW1wbGF0ZUVudGl0eS5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENoaWxkKGNoaWxkLmNsb25lKCkuYWRkVGVtcGxhdGUoY2hpbGQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBjb21wb25lbnQgdG8gdGhlIGVudGl0eVxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBDb21wb25lbnQgb3IgRW50aXR5IHRvIGFkZCBjb3B5IG9mIGNvbXBvbmVudHMgZnJvbVxyXG4gICAgICogQHBhcmFtIGZvcmNlIE9wdGlvbmFsbHkgb3ZlcndyaXRlIGFueSBleGlzdGluZyBjb21wb25lbnRzIG9mIHRoZSBzYW1lIHR5cGVcclxuICAgICAqL1xyXG4gICAgYWRkQ29tcG9uZW50KGNvbXBvbmVudCwgZm9yY2UgPSBmYWxzZSkge1xyXG4gICAgICAgIC8vIGlmIGNvbXBvbmVudCBhbHJlYWR5IGV4aXN0cywgc2tpcCBpZiBub3QgZm9yY2VkXHJcbiAgICAgICAgaWYgKHRoaXMuaGFzKGNvbXBvbmVudC50eXBlKSkge1xyXG4gICAgICAgICAgICBpZiAoZm9yY2UpIHtcclxuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBleGlzdGluZyBjb21wb25lbnQgdHlwZSBpZiBleGlzdHMgd2hlbiBmb3JjZWRcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyBlYXJseSBleGl0IGNvbXBvbmVudCBleGlzc1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBjaXJjdWxhciBkZXBlbmRlbmNpZXMgd2lsbCBiZSBhIHByb2JsZW1cclxuICAgICAgICBpZiAoY29tcG9uZW50LmRlcGVuZGVuY2llcyAmJiBjb21wb25lbnQuZGVwZW5kZW5jaWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGN0b3Igb2YgY29tcG9uZW50LmRlcGVuZGVuY2llcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IGN0b3IoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29tcG9uZW50Lm93bmVyID0gdGhpcztcclxuICAgICAgICBjb25zdCBjb25zdHVjdG9yVHlwZSA9IGNvbXBvbmVudC5jb25zdHJ1Y3RvcjtcclxuICAgICAgICB0aGlzLl9jb21wb25lbnRUeXBlVG9JbnN0YW5jZS5zZXQoY29uc3R1Y3RvclR5cGUsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fY29tcG9uZW50U3RyaW5nVG9JbnN0YW5jZS5zZXQoY29tcG9uZW50LnR5cGUsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKGNvbXBvbmVudC5vbkFkZCkge1xyXG4gICAgICAgICAgICBjb21wb25lbnQub25BZGQodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX25vdGlmeUFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY29tcG9uZW50IGZyb20gdGhlIGVudGl0eSwgYnkgZGVmYXVsdCByZW1vdmFscyBhcmUgZGVmZXJyZWQgdG8gdGhlIGVuZCBvZiBlbnRpdHkgdXBkYXRlIHRvIGF2b2lkIGNvbnNpc3RlbmN5IGlzc3Vlc1xyXG4gICAgICpcclxuICAgICAqIENvbXBvbmVudHMgY2FuIGJlIGZvcmNlIHJlbW92ZWQgd2l0aCB0aGUgYGZvcmNlYCBmbGFnLCB0aGUgcmVtb3ZhbCBpcyBub3QgZGVmZXJyZWQgYW5kIGhhcHBlbnMgaW1tZWRpYXRlbHlcclxuICAgICAqIEBwYXJhbSBjb21wb25lbnRPclR5cGVcclxuICAgICAqIEBwYXJhbSBmb3JjZVxyXG4gICAgICovXHJcbiAgICByZW1vdmVDb21wb25lbnQoY29tcG9uZW50T3JUeXBlLCBmb3JjZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgaWYgKGZvcmNlKSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50T3JUeXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ29tcG9uZW50QnlUeXBlKGNvbXBvbmVudE9yVHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50T3JUeXBlIGluc3RhbmNlb2YgQ29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDb21wb25lbnRCeVR5cGUoY29tcG9uZW50T3JUeXBlLnR5cGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRzVG9SZW1vdmUucHVzaChjb21wb25lbnRPclR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIF9yZW1vdmVDb21wb25lbnRCeVR5cGUodHlwZSkge1xyXG4gICAgICAgIGlmICh0aGlzLmhhcyh0eXBlKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSB0aGlzLmdldCh0eXBlKTtcclxuICAgICAgICAgICAgY29tcG9uZW50Lm93bmVyID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC5vblJlbW92ZSkge1xyXG4gICAgICAgICAgICAgICAgY29tcG9uZW50Lm9uUmVtb3ZlKHRoaXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGN0b3IgPSBjb21wb25lbnQuY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudFR5cGVUb0luc3RhbmNlLmRlbGV0ZShjdG9yKTtcclxuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50U3RyaW5nVG9JbnN0YW5jZS5kZWxldGUoY29tcG9uZW50LnR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9ub3RpZnlSZW1vdmVDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBoaWRkZW5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBwcm9jZXNzQ29tcG9uZW50UmVtb3ZhbCgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbXBvbmVudE9yVHlwZSBvZiB0aGlzLl9jb21wb25lbnRzVG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgY29uc3QgdHlwZSA9IHR5cGVvZiBjb21wb25lbnRPclR5cGUgPT09ICdzdHJpbmcnID8gY29tcG9uZW50T3JUeXBlIDogY29tcG9uZW50T3JUeXBlLnR5cGU7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNvbXBvbmVudEJ5VHlwZSh0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29tcG9uZW50c1RvUmVtb3ZlLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBoYXModHlwZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudFN0cmluZ1RvSW5zdGFuY2UuaGFzKHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudFR5cGVUb0luc3RhbmNlLmhhcyh0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQodHlwZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudFN0cmluZ1RvSW5zdGFuY2UuZ2V0KHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBvbmVudFR5cGVUb0luc3RhbmNlLmdldCh0eXBlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgYWN0b3IgaXMgSW5pdGlhbGl6ZWRcclxuICAgICAqL1xyXG4gICAgZ2V0IGlzSW5pdGlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5pdGlhbGl6ZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHRoaXMgZW50aXR5LCBtZWFudCB0byBiZSBjYWxsZWQgYnkgdGhlIFNjZW5lIGJlZm9yZSBmaXJzdCB1cGRhdGUgbm90IGJ5IHVzZXJzIG9mIEV4Y2FsaWJ1ci5cclxuICAgICAqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9pbml0aWFsaXplKGVuZ2luZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Jbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoJ2luaXRpYWxpemUnLCBuZXcgSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSwgdGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJldXBkYXRlIGhhbmRsZXIgZm9yIFtbb25QcmVVcGRhdGVdXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcHJldXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBQcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblByZVVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wcmV1cGRhdGUgaGFuZGxlciBmb3IgW1tvblBvc3RVcGRhdGVdXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcG9zdHVwZGF0ZShlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0dXBkYXRlJywgbmV3IFBvc3RVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblBvc3RVcGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGBvbkluaXRpYWxpemVgIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBvZiB0aGUgZW50aXR5LiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZVxyXG4gICAgICogb3ZlcnJpZGRlbi5cclxuICAgICAqXHJcbiAgICAgKiBTeW5vbnltb3VzIHdpdGggdGhlIGV2ZW50IGhhbmRsZXIgYC5vbignaW5pdGlhbGl6ZScsIChldnQpID0+IHsuLi59KWBcclxuICAgICAqL1xyXG4gICAgb25Jbml0aWFsaXplKF9lbmdpbmUpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUHJlVXBkYXRlIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncHJldXBkYXRlJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUHJlVXBkYXRlYCBpcyBjYWxsZWQgZGlyZWN0bHkgYmVmb3JlIGFuIGVudGl0eSBpcyB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBvblByZVVwZGF0ZShfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUG9zdFVwZGF0ZSBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3Bvc3R1cGRhdGUnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25Qb3N0VXBkYXRlYCBpcyBjYWxsZWQgZGlyZWN0bHkgYWZ0ZXIgYW4gZW50aXR5IGlzIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIG9uUG9zdFVwZGF0ZShfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogRW50aXR5IHVwZGF0ZSBsaWZlY3ljbGUsIGNhbGxlZCBpbnRlcm5hbGx5XHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAcGFyYW0gZW5naW5lXHJcbiAgICAgKiBAcGFyYW0gZGVsdGFcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICAgICAgdGhpcy5fcHJldXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjaGlsZC51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Bvc3R1cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICB9XHJcbn1cclxuRW50aXR5Ll9JRCA9IDA7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRHJhd2luZy9DYW52YXNEcmF3Q29tcG9uZW50LnRzXG5cclxuLyoqXHJcbiAqIFNoaW0gdG8gZHJhdyB0byB0aGUgY2FudmFzIHdoZW4gaW4gTGVnYWN5RHJhd2luZyBtb2RlXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqL1xyXG5jbGFzcyBDYW52YXNEcmF3Q29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGRyYXcpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmRyYXcgPSBkcmF3O1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC5jYW52YXMnO1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cclxuICAgICAgICB0aGlzLmRyYXcgPSAoX2EgPSB0aGlzLmRyYXcpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICgoKSA9PiB7IH0pO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvR3JhcGhpY3NDb21wb25lbnQudHNcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgZ3VhcmQgZm9yIGNoZWNraW5nIGlmIGEgR3JhcGhpYyBIYXNUaWNrICh1c2VkIGZvciBncmFwaGljcyB0aGF0IGNoYW5nZSBvdmVyIHRpbWUgbGlrZSBhbmltYXRpb25zKVxyXG4gKiBAcGFyYW0gZ3JhcGhpY1xyXG4gKi9cclxuZnVuY3Rpb24gaGFzR3JhcGhpY3NUaWNrKGdyYXBoaWMpIHtcclxuICAgIHJldHVybiAhIWdyYXBoaWMudGljaztcclxufVxyXG5jbGFzcyBHcmFwaGljc0xheWVyIHtcclxuICAgIGNvbnN0cnVjdG9yKF9vcHRpb25zLCBfZ3JhcGhpY3MpIHtcclxuICAgICAgICB0aGlzLl9vcHRpb25zID0gX29wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3MgPSBfZ3JhcGhpY3M7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljcyA9IFtdO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMubmFtZTtcclxuICAgIH1cclxuICAgIGhpZGUobmFtZU9yR3JhcGhpYykge1xyXG4gICAgICAgIGlmICghbmFtZU9yR3JhcGhpYykge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgZ2Z4ID0gbnVsbDtcclxuICAgICAgICAgICAgaWYgKG5hbWVPckdyYXBoaWMgaW5zdGFuY2VvZiBHcmFwaGljKSB7XHJcbiAgICAgICAgICAgICAgICBnZnggPSBuYW1lT3JHcmFwaGljO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZ2Z4ID0gdGhpcy5fZ3JhcGhpY3MuZ2V0R3JhcGhpYyhuYW1lT3JHcmFwaGljKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzID0gdGhpcy5ncmFwaGljcy5maWx0ZXIoKGcpID0+IGcuZ3JhcGhpYyAhPT0gZ2Z4KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgYSBncmFwaGljIGJ5IG5hbWUgb3IgaW5zdGFuY2UgYXQgYW4gb2Zmc2V0LCBncmFwaGljcyBhcmUgc2hvd24gaW4gdGhlIG9yZGVyIGluIHdoaWNoIGBzaG93KClgIGlzIGNhbGxlZC5cclxuICAgICAqXHJcbiAgICAgKiBJZiBgc2hvdygpYCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZm9yIHRoZSBzYW1lIGdyYXBoaWMgaXQgd2lsbCBiZSBzaG93biBtdWx0aXBsZSB0aW1lcy5cclxuICAgICAqIEBwYXJhbSBuYW1lT3JHcmFwaGljXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBzaG93KG5hbWVPckdyYXBoaWMsIG9wdGlvbnMpIHtcclxuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XHJcbiAgICAgICAgbGV0IGdmeDtcclxuICAgICAgICBpZiAobmFtZU9yR3JhcGhpYyBpbnN0YW5jZW9mIEdyYXBoaWMpIHtcclxuICAgICAgICAgICAgZ2Z4ID0gdGhpcy5fZ3JhcGhpY3MuY29weUdyYXBoaWNzID8gbmFtZU9yR3JhcGhpYy5jbG9uZSgpIDogbmFtZU9yR3JhcGhpYztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGdmeCA9IHRoaXMuX2dyYXBoaWNzLmdldEdyYXBoaWMobmFtZU9yR3JhcGhpYyk7XHJcbiAgICAgICAgICAgIGlmICghZ2Z4KSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihgTm8gc3VjaCBncmFwaGljIGFkZGVkIHRvIGNvbXBvbmVudCBuYW1lZCAke25hbWVPckdyYXBoaWN9LiBUaGVzZSBuYW1lZCBncmFwaGljcyBhcmUgYXZhaWxhYmxlOiBgLCB0aGlzLl9ncmFwaGljcy5nZXROYW1lcygpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ2Z4KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MucHVzaCh7IGdyYXBoaWM6IGdmeCwgb3B0aW9ucyB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIGdmeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlIGEgc3BlY2lmaWMgZ3JhcGhpYywgc3dhcCBvdXQgYW55IGN1cnJlbnQgZ3JhcGhpY3MgYmVpbmcgc2hvd25cclxuICAgICAqIEBwYXJhbSBuYW1lT3JHcmFwaGljXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICB1c2UobmFtZU9yR3JhcGhpYywgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaG93KG5hbWVPckdyYXBoaWMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDdXJyZW50IG9yZGVyIG9mIHRoZSBsYXllciwgaGlnaGVyIG51bWJlcnMgYXJlIG9uIHRvcCwgbG93ZXIgbnVtYmVycyBhcmUgb24gdGhlIGJvdHRvbS5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgZXhhbXBsZSBhIGxheWVyIHdpdGggYG9yZGVyID0gLTFgIHdvdWxkIGJlIHVuZGVyIGEgbGF5ZXIgb2YgYG9yZGVyID0gMWBcclxuICAgICAqL1xyXG4gICAgZ2V0IG9yZGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vcHRpb25zLm9yZGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIG9yZGVyIG9mIHRoZSBsYXllciwgaGlnaGVyIG51bWJlcnMgYXJlIG9uIHRvcCwgbG93ZXIgbnVtYmVycyBhcmUgb24gdGhlIGJvdHRvbS5cclxuICAgICAqXHJcbiAgICAgKiBGb3IgZXhhbXBsZSBhIGxheWVyIHdpdGggYG9yZGVyID0gLTFgIHdvdWxkIGJlIHVuZGVyIGEgbGF5ZXIgb2YgYG9yZGVyID0gMWBcclxuICAgICAqL1xyXG4gICAgc2V0IG9yZGVyKG9yZGVyKSB7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vcmRlciA9IG9yZGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBwaXhlbCBvZmZzZXQgZnJvbSB0aGUgbGF5ZXIgYW5jaG9yIGZvciBhbGwgZ3JhcGhpY3MgaW4gdGhlIGxheWVyXHJcbiAgICAgKi9cclxuICAgIGdldCBvZmZzZXQoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9vcHRpb25zLm9mZnNldCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVmVjdG9yLlplcm87XHJcbiAgICB9XHJcbiAgICBzZXQgb2Zmc2V0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5vZmZzZXQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBjdXJyZW50S2V5cygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2Fub255bW91cyc7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgR3JhcGhpY3NMYXllcnMge1xyXG4gICAgY29uc3RydWN0b3IoX2NvbXBvbmVudCkge1xyXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudCA9IF9jb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJNYXAgPSB7fTtcclxuICAgICAgICB0aGlzLmRlZmF1bHQgPSBuZXcgR3JhcGhpY3NMYXllcih7IG5hbWU6ICdkZWZhdWx0Jywgb3JkZXI6IDAgfSwgX2NvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbWF5YmVBZGRMYXllcih0aGlzLmRlZmF1bHQpO1xyXG4gICAgfVxyXG4gICAgY3JlYXRlKG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBsYXllciA9IG5ldyBHcmFwaGljc0xheWVyKG9wdGlvbnMsIHRoaXMuX2NvbXBvbmVudCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heWJlQWRkTGF5ZXIobGF5ZXIpO1xyXG4gICAgfVxyXG4gICAgZ2V0KG5hbWUpIHtcclxuICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0TGF5ZXIobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcnM7XHJcbiAgICB9XHJcbiAgICBjdXJyZW50S2V5cygpIHtcclxuICAgICAgICBjb25zdCBncmFwaGljc0xheWVyS2V5cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5fbGF5ZXJzKSB7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzTGF5ZXJLZXlzLnB1c2gobGF5ZXIuY3VycmVudEtleXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZ3JhcGhpY3NMYXllcktleXM7XHJcbiAgICB9XHJcbiAgICBoYXMobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuYW1lIGluIHRoaXMuX2xheWVyTWFwO1xyXG4gICAgfVxyXG4gICAgX21heWJlQWRkTGF5ZXIobGF5ZXIpIHtcclxuICAgICAgICBpZiAodGhpcy5fbGF5ZXJNYXBbbGF5ZXIubmFtZV0pIHtcclxuICAgICAgICAgICAgLy8gdG9kbyBsb2cgd2FybmluZ1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJNYXBbbGF5ZXIubmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xheWVyTWFwW2xheWVyLm5hbWVdID0gbGF5ZXI7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJzLnB1c2gobGF5ZXIpO1xyXG4gICAgICAgIHRoaXMuX2xheWVycy5zb3J0KChhLCBiKSA9PiBhLm9yZGVyIC0gYi5vcmRlcik7XHJcbiAgICAgICAgcmV0dXJuIGxheWVyO1xyXG4gICAgfVxyXG4gICAgX2dldExheWVyKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENvbXBvbmVudCB0byBtYW5hZ2UgZHJhd2luZ3MsIHVzaW5nIHdpdGggdGhlIHBvc2l0aW9uIGNvbXBvbmVudFxyXG4gKi9cclxuY2xhc3MgR3JhcGhpY3NDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4LmdyYXBoaWNzJztcclxuICAgICAgICB0aGlzLl9ncmFwaGljcyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB3ZXRoZXIgYW55IGRyYXdpbmcgc2hvdWxkIGJlIHZpc2libGUgaW4gdGhpcyBjb21wb25lbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgb3IgZ2V0cyB3aXRoZXIgYWxsIGRyYXdpbmdzIHNob3VsZCBoYXZlIGFuIG9wYWNpdHkgYXBwbGllZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2Zmc2V0IHRvIGFwcGx5IHRvIGdyYXBoaWNzIGJ5IGRlZmF1bHRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9mZnNldCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFuY2hvciB0byBhcHBseSB0byBncmFwaGljcyBieSBkZWZhdWx0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hbmNob3IgPSBWZWN0b3IuSGFsZjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJZiBzZXQgdG8gdHJ1ZSBncmFwaGljcyBhZGRlZCB0byB0aGUgY29tcG9uZW50IHdpbGwgYmUgY29waWVkLiBUaGlzIGNhbiBhZmZlY3QgcGVyZm9ybWFuY2VcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvcHlHcmFwaGljcyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IG51bGw7XHJcbiAgICAgICAgLy8gRGVmYXVsdHNcclxuICAgICAgICBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHZpc2libGU6IHRoaXMudmlzaWJsZSB9LCBvcHRpb25zKTtcclxuICAgICAgICBjb25zdCB7IGN1cnJlbnQsIGFuY2hvciwgb3BhY2l0eSwgdmlzaWJsZSwgZ3JhcGhpY3MsIG9mZnNldCwgY29weUdyYXBoaWNzLCBvblByZURyYXcsIG9uUG9zdERyYXcgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3MgPSBncmFwaGljcyB8fCB7fTtcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldCAhPT0gbnVsbCAmJiBvZmZzZXQgIT09IHZvaWQgMCA/IG9mZnNldCA6IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHkgIT09IG51bGwgJiYgb3BhY2l0eSAhPT0gdm9pZCAwID8gb3BhY2l0eSA6IHRoaXMub3BhY2l0eTtcclxuICAgICAgICB0aGlzLmFuY2hvciA9IGFuY2hvciAhPT0gbnVsbCAmJiBhbmNob3IgIT09IHZvaWQgMCA/IGFuY2hvciA6IHRoaXMuYW5jaG9yO1xyXG4gICAgICAgIHRoaXMuY29weUdyYXBoaWNzID0gY29weUdyYXBoaWNzICE9PSBudWxsICYmIGNvcHlHcmFwaGljcyAhPT0gdm9pZCAwID8gY29weUdyYXBoaWNzIDogdGhpcy5jb3B5R3JhcGhpY3M7XHJcbiAgICAgICAgdGhpcy5vblByZURyYXcgPSBvblByZURyYXcgIT09IG51bGwgJiYgb25QcmVEcmF3ICE9PSB2b2lkIDAgPyBvblByZURyYXcgOiB0aGlzLm9uUHJlRHJhdztcclxuICAgICAgICB0aGlzLm9uUG9zdERyYXcgPSBvblBvc3REcmF3ICE9PSBudWxsICYmIG9uUG9zdERyYXcgIT09IHZvaWQgMCA/IG9uUG9zdERyYXcgOiB0aGlzLm9uUG9zdERyYXc7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gISF2aXNpYmxlO1xyXG4gICAgICAgIHRoaXMubGF5ZXJzID0gbmV3IEdyYXBoaWNzTGF5ZXJzKHRoaXMpO1xyXG4gICAgICAgIGlmIChjdXJyZW50ICYmIHRoaXMuX2dyYXBoaWNzW2N1cnJlbnRdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hvdyh0aGlzLl9ncmFwaGljc1tjdXJyZW50XSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0R3JhcGhpYyhuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyYXBoaWNzW25hbWVdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgcmVnaXN0ZXJlZCBncmFwaGljcyBuYW1lc1xyXG4gICAgICovXHJcbiAgICBnZXROYW1lcygpIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZ3JhcGhpY3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIGdyYXBoaWNzIGFuZCB0aGVpciBvZmZzZXRzLCBlbXB0eSBhcnJheSBpZiBoaWRkZW5cclxuICAgICAqL1xyXG4gICAgZ2V0IGN1cnJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzLmRlZmF1bHQuZ3JhcGhpY3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIGdyYXBoaWNzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGNvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICBnZXQgZ3JhcGhpY3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyYXBoaWNzO1xyXG4gICAgfVxyXG4gICAgYWRkKG5hbWVPckdyYXBoaWMsIGdyYXBoaWMpIHtcclxuICAgICAgICBsZXQgbmFtZSA9ICdkZWZhdWx0JztcclxuICAgICAgICBsZXQgZ3JhcGhpY1RvU2V0ID0gbnVsbDtcclxuICAgICAgICBpZiAodHlwZW9mIG5hbWVPckdyYXBoaWMgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lT3JHcmFwaGljO1xyXG4gICAgICAgICAgICBncmFwaGljVG9TZXQgPSBncmFwaGljO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ3JhcGhpY1RvU2V0ID0gbmFtZU9yR3JhcGhpYztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NbbmFtZV0gPSB0aGlzLmNvcHlHcmFwaGljcyA/IGdyYXBoaWNUb1NldC5jbG9uZSgpIDogZ3JhcGhpY1RvU2V0O1xyXG4gICAgICAgIGlmIChuYW1lID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93KCdkZWZhdWx0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBncmFwaGljVG9TZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3cgYSBncmFwaGljIGJ5IG5hbWUgb24gdGhlICoqZGVmYXVsdCoqIGxheWVyLCByZXR1cm5zIHRoZSBuZXcgW1tHcmFwaGljXV1cclxuICAgICAqL1xyXG4gICAgc2hvdyhuYW1lT3JHcmFwaGljLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzLmRlZmF1bHQuc2hvdyhuYW1lT3JHcmFwaGljLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlIGEgZ3JhcGhpYyBvbmx5LCBzd2FwIG91dCBhbnkgZ3JhcGhpY3Mgb24gdGhlICoqZGVmYXVsdCoqIGxheWVyLCByZXR1cm5zIHRoZSBuZXcgW1tHcmFwaGljXV1cclxuICAgICAqIEBwYXJhbSBuYW1lT3JHcmFwaGljXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICB1c2UobmFtZU9yR3JhcGhpYywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmxheWVycy5kZWZhdWx0LnVzZShuYW1lT3JHcmFwaGljLCBvcHRpb25zKTtcclxuICAgIH1cclxuICAgIGhpZGUobmFtZU9yR3JhcGhpYykge1xyXG4gICAgICAgIHRoaXMubGF5ZXJzLmRlZmF1bHQuaGlkZShuYW1lT3JHcmFwaGljKTtcclxuICAgIH1cclxuICAgIHNldCBsb2NhbEJvdW5kcyhib3VuZHMpIHtcclxuICAgICAgICB0aGlzLl9ib3VuZHMgPSBib3VuZHM7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JvdW5kcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYm91bmRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYmIgPSBuZXcgQm91bmRpbmdCb3goKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzLmdldCgpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBncmFwaGljLCBvcHRpb25zIH0gb2YgbGF5ZXIuZ3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgIGxldCBhbmNob3IgPSB0aGlzLmFuY2hvcjtcclxuICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSB0aGlzLm9mZnNldDtcclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYW5jaG9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gb3B0aW9ucy5hbmNob3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9mZnNldCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRzID0gZ3JhcGhpYy5sb2NhbEJvdW5kcztcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFggPSAtYm91bmRzLndpZHRoICogZ3JhcGhpYy5zY2FsZS54ICogYW5jaG9yLnggKyBvZmZzZXQueDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSAtYm91bmRzLmhlaWdodCAqIGdyYXBoaWMuc2NhbGUueSAqIGFuY2hvci55ICsgb2Zmc2V0Lnk7XHJcbiAgICAgICAgICAgICAgICBiYiA9IGdyYXBoaWMgPT09IG51bGwgfHwgZ3JhcGhpYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JhcGhpYy5sb2NhbEJvdW5kcy50cmFuc2xhdGUodmVjKG9mZnNldFggKyBsYXllci5vZmZzZXQueCwgb2Zmc2V0WSArIGxheWVyLm9mZnNldC55KSkuY29tYmluZShiYik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdW5kZXJseWluZyBncmFwaGljcyBpZiBuZWNlc2FyeSwgY2FsbGVkIGludGVybmFsbHlcclxuICAgICAqIEBwYXJhbSBlbGFwc2VkXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKGVsYXBzZWQsIGlkZW1wb3RlbmN5VG9rZW4gPSAwKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycy5nZXQoKSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHsgZ3JhcGhpYyB9IG9mIGxheWVyLmdyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaGFzR3JhcGhpY3NUaWNrKGdyYXBoaWMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYyA9PT0gbnVsbCB8fCBncmFwaGljID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncmFwaGljLnRpY2soZWxhcHNlZCwgaWRlbXBvdGVuY3lUb2tlbik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9SZWN0YW5nbGUudHNcblxyXG4vKipcclxuICogQSBSZWN0YW5nbGUgW1tHcmFwaGljXV0gZm9yIGRyYXdpbmcgcmVjdGFuZ2xlcyB0byB0aGUgW1tFeGNhbGlidXJHcmFwaGljc0NvbnRleHRdXVxyXG4gKi9cclxuY2xhc3MgUmVjdGFuZ2xlIGV4dGVuZHMgUmFzdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLndpZHRoID0gb3B0aW9ucy53aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IG9wdGlvbnMuaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMucmFzdGVyaXplKCk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyB3aWR0aDogdGhpcy53aWR0aCwgaGVpZ2h0OiB0aGlzLmhlaWdodCB9LCB0aGlzLmNsb25lR3JhcGhpY09wdGlvbnMoKSksIHRoaXMuY2xvbmVSYXN0ZXJPcHRpb25zKCkpKTtcclxuICAgIH1cclxuICAgIGV4ZWN1dGUoY3R4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc3Ryb2tlQ29sb3IpIHtcclxuICAgICAgICAgICAgY3R4LnN0cm9rZVJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NpcmNsZS50c1xuXHJcbi8qKlxyXG4gKiBBIGNpcmNsZSBbW0dyYXBoaWNdXSBmb3IgZHJhd2luZyBjaXJjbGVzIHRvIHRoZSBbW0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dF1dXHJcbiAqL1xyXG5jbGFzcyBDaXJjbGUgZXh0ZW5kcyBSYXN0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLl9yYWRpdXMgPSAwO1xyXG4gICAgICAgIHRoaXMucGFkZGluZyA9IChfYSA9IG9wdGlvbnMucGFkZGluZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMjsgLy8gZGVmYXVsdCAyIHBhZGRpbmcgZm9yIGNpcmNsZXMgbG9va3MgbmljZVxyXG4gICAgICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXM7XHJcbiAgICAgICAgdGhpcy5yYXN0ZXJpemUoKTtcclxuICAgIH1cclxuICAgIGdldCByYWRpdXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JhZGl1cztcclxuICAgIH1cclxuICAgIHNldCByYWRpdXModmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9yYWRpdXMgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5fcmFkaXVzICogMjtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX3JhZGl1cyAqIDI7XHJcbiAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2lyY2xlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHJhZGl1czogdGhpcy5yYWRpdXMgfSwgdGhpcy5jbG9uZUdyYXBoaWNPcHRpb25zKCkpLCB0aGlzLmNsb25lUmFzdGVyT3B0aW9ucygpKSk7XHJcbiAgICB9XHJcbiAgICBleGVjdXRlKGN0eCkge1xyXG4gICAgICAgIGlmICh0aGlzLnJhZGl1cyA+IDApIHtcclxuICAgICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgICAgICBjdHguYXJjKHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cywgdGhpcy5yYWRpdXMsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc3Ryb2tlQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvRWFzaW5nRnVuY3Rpb25zLnRzXG52YXIgRWFzaW5nRnVuY3Rpb25zX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBTdGFuZGFyZCBlYXNpbmcgZnVuY3Rpb25zIGZvciBtb3Rpb24gaW4gRXhjYWxpYnVyLCBkZWZpbmVkIG9uIGEgZG9tYWluIG9mIFswLCBkdXJhdGlvbl0gYW5kIGEgcmFuZ2UgZnJvbSBbK3N0YXJ0VmFsdWUsK2VuZFZhbHVlXVxyXG4gKiBHaXZlbiBhIHRpbWUsIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIHZhbHVlIGZyb20gcG9zaXRpdmUgc3RhcnRWYWx1ZSB0byBwb3NpdGl2ZSBlbmRWYWx1ZS5cclxuICpcclxuICogYGBganNcclxuICogZnVuY3Rpb24gTGluZWFyICh0KSB7XHJcbiAqICAgIHJldHVybiB0ICogdDtcclxuICogfVxyXG4gKlxyXG4gKiAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XHJcbiAqIGZ1bmN0aW9uIEVhc2VJblF1YWQgKHQpIHtcclxuICogICAgcmV0dXJuIHQgKiB0O1xyXG4gKiB9XHJcbiAqXHJcbiAqIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XHJcbiAqIGZ1bmN0aW9uIEVhc2VPdXRRdWFkICh0KSB7XHJcbiAqICAgIHJldHVybiB0ICogKDIgLSB0KTtcclxuICogfVxyXG4gKlxyXG4gKiAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cclxuICogZnVuY3Rpb24gRWFzZUluT3V0UXVhZCAodCkge1xyXG4gKiAgICByZXR1cm4gdCA8IC41ID8gMiAqIHQgKiB0IDogLTEgKyAoNCAtIDIgKiB0KSAqIHQ7XHJcbiAqIH1cclxuICpcclxuICogLy8gYWNjZWxlcmF0aW5nIGZyb20gemVybyB2ZWxvY2l0eVxyXG4gKiBmdW5jdGlvbiBFYXNlSW5DdWJpYyAodCkge1xyXG4gKiAgICByZXR1cm4gdCAqIHQgKiB0O1xyXG4gKiB9XHJcbiAqXHJcbiAqIC8vIGRlY2VsZXJhdGluZyB0byB6ZXJvIHZlbG9jaXR5XHJcbiAqIGZ1bmN0aW9uIEVhc2VPdXRDdWJpYyAodCkge1xyXG4gKiAgICByZXR1cm4gKC0tdCkgKiB0ICogdCArIDE7XHJcbiAqIH1cclxuICpcclxuICogLy8gYWNjZWxlcmF0aW9uIHVudGlsIGhhbGZ3YXksIHRoZW4gZGVjZWxlcmF0aW9uXHJcbiAqIGZ1bmN0aW9uIEVhc2VJbk91dEN1YmljICh0KSB7XHJcbiAqICAgIHJldHVybiB0IDwgLjUgPyA0ICogdCAqIHQgKiB0IDogKHQgLSAxKSAqICgyICogdCAtIDIpICogKDIgKiB0IC0gMikgKyAxO1xyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuY2xhc3MgRWFzaW5nRnVuY3Rpb25zIHtcclxuICAgIHN0YXRpYyBDcmVhdGVSZXZlcnNpYmxlRWFzaW5nRnVuY3Rpb24oZWFzaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aW1lLCBzdGFydCwgZW5kLCBkdXJhdGlvbikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZW5kIDwgc3RhcnQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBzdGFydCAtIChlYXNpbmcodGltZSwgZW5kLCBzdGFydCwgZHVyYXRpb24pIC0gZW5kKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlYXNpbmcodGltZSwgc3RhcnQsIGVuZCwgZHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBDcmVhdGVSZXZlcnNhYmxlRWFzaW5nRnVuY3Rpb24oZWFzaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuIEVhc2luZ0Z1bmN0aW9ucy5DcmVhdGVSZXZlcnNpYmxlRWFzaW5nRnVuY3Rpb24oZWFzaW5nKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBDcmVhdGVWZWN0b3JFYXNpbmdGdW5jdGlvbihlYXNpbmcpIHtcclxuICAgICAgICByZXR1cm4gKHRpbWUsIHN0YXJ0LCBlbmQsIGR1cmF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKGVhc2luZyh0aW1lLCBzdGFydC54LCBlbmQueCwgZHVyYXRpb24pLCBlYXNpbmcodGltZSwgc3RhcnQueSwgZW5kLnksIGR1cmF0aW9uKSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG5FYXNpbmdGdW5jdGlvbnMuTGluZWFyID0gRWFzaW5nRnVuY3Rpb25zLkNyZWF0ZVJldmVyc2libGVFYXNpbmdGdW5jdGlvbigoY3VycmVudFRpbWUsIHN0YXJ0VmFsdWUsIGVuZFZhbHVlLCBkdXJhdGlvbikgPT4ge1xyXG4gICAgZW5kVmFsdWUgPSBlbmRWYWx1ZSAtIHN0YXJ0VmFsdWU7XHJcbiAgICByZXR1cm4gKGVuZFZhbHVlICogY3VycmVudFRpbWUpIC8gZHVyYXRpb24gKyBzdGFydFZhbHVlO1xyXG59KTtcclxuRWFzaW5nRnVuY3Rpb25zLkVhc2VJblF1YWQgPSBFYXNpbmdGdW5jdGlvbnMuQ3JlYXRlUmV2ZXJzaWJsZUVhc2luZ0Z1bmN0aW9uKChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSA9PiB7XHJcbiAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZTtcclxuICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xyXG4gICAgcmV0dXJuIGVuZFZhbHVlICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XHJcbn0pO1xyXG5FYXNpbmdGdW5jdGlvbnMuRWFzZU91dFF1YWQgPSBFYXNpbmdGdW5jdGlvbnMuQ3JlYXRlUmV2ZXJzaWJsZUVhc2luZ0Z1bmN0aW9uKChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSA9PiB7XHJcbiAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZTtcclxuICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xyXG4gICAgcmV0dXJuIC1lbmRWYWx1ZSAqIGN1cnJlbnRUaW1lICogKGN1cnJlbnRUaW1lIC0gMikgKyBzdGFydFZhbHVlO1xyXG59KTtcclxuRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dFF1YWQgPSBFYXNpbmdGdW5jdGlvbnMuQ3JlYXRlUmV2ZXJzaWJsZUVhc2luZ0Z1bmN0aW9uKChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSA9PiB7XHJcbiAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZTtcclxuICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uIC8gMjtcclxuICAgIGlmIChjdXJyZW50VGltZSA8IDEpIHtcclxuICAgICAgICByZXR1cm4gKGVuZFZhbHVlIC8gMikgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcclxuICAgIH1cclxuICAgIGN1cnJlbnRUaW1lLS07XHJcbiAgICByZXR1cm4gKC1lbmRWYWx1ZSAvIDIpICogKGN1cnJlbnRUaW1lICogKGN1cnJlbnRUaW1lIC0gMikgLSAxKSArIHN0YXJ0VmFsdWU7XHJcbn0pO1xyXG5FYXNpbmdGdW5jdGlvbnMuRWFzZUluQ3ViaWMgPSBFYXNpbmdGdW5jdGlvbnMuQ3JlYXRlUmV2ZXJzaWJsZUVhc2luZ0Z1bmN0aW9uKChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSA9PiB7XHJcbiAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZTtcclxuICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xyXG4gICAgcmV0dXJuIGVuZFZhbHVlICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcclxufSk7XHJcbkVhc2luZ0Z1bmN0aW9ucy5FYXNlT3V0Q3ViaWMgPSBFYXNpbmdGdW5jdGlvbnMuQ3JlYXRlUmV2ZXJzaWJsZUVhc2luZ0Z1bmN0aW9uKChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSA9PiB7XHJcbiAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZTtcclxuICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uO1xyXG4gICAgY3VycmVudFRpbWUtLTtcclxuICAgIHJldHVybiBlbmRWYWx1ZSAqIChjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyAxKSArIHN0YXJ0VmFsdWU7XHJcbn0pO1xyXG5FYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWMgPSBFYXNpbmdGdW5jdGlvbnMuQ3JlYXRlUmV2ZXJzaWJsZUVhc2luZ0Z1bmN0aW9uKChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSA9PiB7XHJcbiAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZTtcclxuICAgIGN1cnJlbnRUaW1lIC89IGR1cmF0aW9uIC8gMjtcclxuICAgIGlmIChjdXJyZW50VGltZSA8IDEpIHtcclxuICAgICAgICByZXR1cm4gKGVuZFZhbHVlIC8gMikgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xyXG4gICAgfVxyXG4gICAgY3VycmVudFRpbWUgLT0gMjtcclxuICAgIHJldHVybiAoZW5kVmFsdWUgLyAyKSAqIChjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyAyKSArIHN0YXJ0VmFsdWU7XHJcbn0pO1xyXG5FYXNpbmdGdW5jdGlvbnNfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdBbGlhcyBmb3IgaW5jb3JyZWN0IHNwZWxsaW5nIHVzZWQgaW4gb2xkZXIgdmVyc2lvbnMsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNS4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdDcmVhdGVSZXZlcnNpYmxlRWFzaW5nRnVuY3Rpb24nXHJcbiAgICB9KVxyXG5dLCBFYXNpbmdGdW5jdGlvbnMsIFwiQ3JlYXRlUmV2ZXJzYWJsZUVhc2luZ0Z1bmN0aW9uXCIsIG51bGwpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uUXVldWUudHNcbi8qKlxyXG4gKiBBY3Rpb24gUXVldWVzIHJlcHJlc2VudCBhbiBvcmRlcmVkIHNlcXVlbmNlIG9mIGFjdGlvbnNcclxuICpcclxuICogQWN0aW9uIHF1ZXVlcyBhcmUgcGFydCBvZiB0aGUgW1tBY3Rpb25Db250ZXh0fEFjdGlvbiBBUEldXSBhbmRcclxuICogc3RvcmUgdGhlIGxpc3Qgb2YgYWN0aW9ucyB0byBiZSBleGVjdXRlZCBmb3IgYW4gW1tBY3Rvcl1dLlxyXG4gKlxyXG4gKiBBY3RvcnMgaW1wbGVtZW50IFtbQWN0b3IuYWN0aW9uc11dIHdoaWNoIGNhbiBiZSBtYW5pcHVsYXRlZCBieVxyXG4gKiBhZHZhbmNlZCB1c2VycyB0byBhZGp1c3QgdGhlIGFjdGlvbnMgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkIGluIHRoZVxyXG4gKiBxdWV1ZS5cclxuICovXHJcbmNsYXNzIEFjdGlvblF1ZXVlIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSkge1xyXG4gICAgICAgIHRoaXMuX2FjdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zID0gW107XHJcbiAgICAgICAgdGhpcy5fZW50aXR5ID0gZW50aXR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gYWN0aW9uIHRvIHRoZSBzZXF1ZW5jZVxyXG4gICAgICogQHBhcmFtIGFjdGlvblxyXG4gICAgICovXHJcbiAgICBhZGQoYWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9ucy5wdXNoKGFjdGlvbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBhY3Rpb24gYnkgcmVmZXJlbmNlIGZyb20gdGhlIHNlcXVlbmNlXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZShhY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2FjdGlvbnMuaW5kZXhPZihhY3Rpb24pO1xyXG4gICAgICAgIHRoaXMuX2FjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgYWN0aW9ucyBmcm9tIHRoaXMgc2VxdWVuY2VcclxuICAgICAqL1xyXG4gICAgY2xlYXJBY3Rpb25zKCkge1xyXG4gICAgICAgIHRoaXMuX2FjdGlvbnMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9jb21wbGV0ZWRBY3Rpb25zLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRBY3Rpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbi5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgVGhlIHRvdGFsIGxpc3Qgb2YgYWN0aW9ucyBpbiB0aGlzIHNlcXVlbmNlIGNvbXBsZXRlIG9yIG5vdFxyXG4gICAgICovXHJcbiAgICBnZXRBY3Rpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmNvbmNhdCh0aGlzLl9jb21wbGV0ZWRBY3Rpb25zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGVyZSBhcmUgbW9yZSBhY3Rpb25zIHRvIHByb2Nlc3MgaW4gdGhlIHNlcXVlbmNlXHJcbiAgICAgKi9cclxuICAgIGhhc05leHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMubGVuZ3RoID4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZSBjdXJyZW50IHNlcXVlbmNlIG9mIGFjdGlvbnMgaXMgZG9uZVxyXG4gICAgICovXHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb25zLmxlbmd0aCA9PT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBzZXF1ZW5jZSBvZiBhY3Rpb25zLCB0aGlzIGlzIHVzZWQgdG8gcmVzdGFydCBhIHNlcXVlbmNlIGZyb20gdGhlIGJlZ2lubmluZ1xyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9hY3Rpb25zID0gdGhpcy5nZXRBY3Rpb25zKCk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYWN0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25zW2ldLnJlc2V0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBxdWV1ZSB3aGljaCB1cGRhdGVzIGFjdGlvbnMgYW5kIGhhbmRsZXMgY29tcGxldGluZyBhY3Rpb25zXHJcbiAgICAgKiBAcGFyYW0gZWxhcHNlZE1zXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShlbGFwc2VkTXMpIHtcclxuICAgICAgICBpZiAodGhpcy5fYWN0aW9ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24gPSB0aGlzLl9hY3Rpb25zWzBdO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uLnVwZGF0ZShlbGFwc2VkTXMpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudEFjdGlvbi5pc0NvbXBsZXRlKHRoaXMuX2VudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMucHVzaCh0aGlzLl9hY3Rpb25zLnNoaWZ0KCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vUmVwZWF0LnRzXG5cclxuY2xhc3MgUmVwZWF0IHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgcmVwZWF0QnVpbGRlciwgcmVwZWF0KSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdEJ1aWxkZXIgPSByZXBlYXRCdWlsZGVyO1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdENvbnRleHQgPSBuZXcgQWN0aW9uQ29udGV4dChlbnRpdHkpO1xyXG4gICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlID0gdGhpcy5fcmVwZWF0Q29udGV4dC5nZXRRdWV1ZSgpO1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdCA9IHJlcGVhdDtcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbFJlcGVhdCA9IHJlcGVhdDtcclxuICAgICAgICB0aGlzLl9yZXBlYXRCdWlsZGVyKHRoaXMuX3JlcGVhdENvbnRleHQpO1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdC0tOyAvLyBjdXJyZW50IGV4ZWN1dGlvbiBpcyB0aGUgZmlyc3QgcmVwZWF0XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZGVsdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uUXVldWUuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLmNsZWFyQWN0aW9ucygpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBlYXRCdWlsZGVyKHRoaXMuX3JlcGVhdENvbnRleHQpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBlYXQtLTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgKHRoaXMuX3JlcGVhdCA8PSAwICYmIHRoaXMuX2FjdGlvblF1ZXVlLmlzQ29tcGxldGUoKSk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gdGhpcy5fb3JpZ2luYWxSZXBlYXQ7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9SZXBlYXRGb3JldmVyLnRzXG5cclxuLyoqXHJcbiAqIFJlcGVhdEZvcmV2ZXIgQWN0aW9uIGltcGxlbWVudGF0aW9uLCBpdCBpcyByZWNvbW1lbmRlZCB5b3UgdXNlIHRoZSBmbHVlbnQgYWN0aW9uXHJcbiAqIGNvbnRleHQgQVBJLlxyXG4gKlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgUmVwZWF0Rm9yZXZlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIHJlcGVhdEJ1aWxkZXIpIHtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0QnVpbGRlciA9IHJlcGVhdEJ1aWxkZXI7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0Q29udGV4dCA9IG5ldyBBY3Rpb25Db250ZXh0KGVudGl0eSk7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUgPSB0aGlzLl9yZXBlYXRDb250ZXh0LmdldFF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0QnVpbGRlcih0aGlzLl9yZXBlYXRDb250ZXh0KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zdG9wcGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2FjdGlvblF1ZXVlLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS5jbGVhckFjdGlvbnMoKTtcclxuICAgICAgICAgICAgdGhpcy5fcmVwZWF0QnVpbGRlcih0aGlzLl9yZXBlYXRDb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUudXBkYXRlKGRlbHRhKTtcclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQ7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLmNsZWFyQWN0aW9ucygpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vTW92ZUJ5LnRzXG5cclxuXHJcblxyXG5cclxuY2xhc3MgTW92ZUJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgb2Zmc2V0WCwgb2Zmc2V0WSwgc3BlZWQpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eSA9IGVudGl0eTtcclxuICAgICAgICB0aGlzLl90eCA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24gPSBlbnRpdHkuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcclxuICAgICAgICB0aGlzLl9vZmZzZXQgPSBuZXcgVmVjdG9yKG9mZnNldFgsIG9mZnNldFkpO1xyXG4gICAgICAgIGlmIChzcGVlZCA8PSAwKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdBdHRlbXB0ZWQgdG8gbW92ZUJ5IHdpdGggc3BlZWQgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHplcm8gOiAnICsgc3BlZWQpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NwZWVkIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAgcGl4ZWxzIHBlciBzZWNvbmQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydCA9IG5ldyBWZWN0b3IodGhpcy5fdHgucG9zLngsIHRoaXMuX3R4LnBvcy55KTtcclxuICAgICAgICAgICAgdGhpcy5fZW5kID0gdGhpcy5fc3RhcnQuYWRkKHRoaXMuX29mZnNldCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fb2Zmc2V0LnNpemU7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fc3RhcnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuX2VudGl0eSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHgucG9zID0gdmVjKHRoaXMuX2VuZC54LCB0aGlzLl9lbmQueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdGhpcy5fZGlyLnNjYWxlKHRoaXMuX3NwZWVkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKGVudGl0eSkge1xyXG4gICAgICAgIGNvbnN0IHR4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IHR4LnBvcy5kaXN0YW5jZSh0aGlzLl9zdGFydCkgPj0gdGhpcy5fZGlzdGFuY2U7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9Nb3ZlVG8udHNcblxyXG5cclxuXHJcbmNsYXNzIE1vdmVUbyB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIGRlc3R4LCBkZXN0eSwgc3BlZWQpIHtcclxuICAgICAgICB0aGlzLmVudGl0eSA9IGVudGl0eTtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3R4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IGVudGl0eS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9lbmQgPSBuZXcgVmVjdG9yKGRlc3R4LCBkZXN0eSk7XHJcbiAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gbmV3IFZlY3Rvcih0aGlzLl90eC5wb3MueCwgdGhpcy5fdHgucG9zLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3N0YXJ0LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fc3RhcnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fZGlyLnNjYWxlKHRoaXMuX3NwZWVkKTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKG0ueCwgbS55KTtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKHRoaXMuZW50aXR5KSkge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5wb3MgPSB2ZWModGhpcy5fZW5kLngsIHRoaXMuX2VuZC55KTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKGVudGl0eSkge1xyXG4gICAgICAgIGNvbnN0IHR4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IG5ldyBWZWN0b3IodHgucG9zLngsIHR4LnBvcy55KS5kaXN0YW5jZSh0aGlzLl9zdGFydCkgPj0gdGhpcy5fZGlzdGFuY2U7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL1JvdGF0aW9uVHlwZS50c1xuLyoqXHJcbiAqIEFuIGVudW0gdGhhdCBkZXNjcmliZXMgdGhlIHN0cmF0ZWdpZXMgdGhhdCByb3RhdGlvbiBhY3Rpb25zIGNhbiB1c2VcclxuICovXHJcbnZhciBSb3RhdGlvblR5cGU7XHJcbihmdW5jdGlvbiAoUm90YXRpb25UeXBlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0aW9uIHZpYSBgU2hvcnRlc3RQYXRoYCB3aWxsIHVzZSB0aGUgc21hbGxlc3QgYW5nbGVcclxuICAgICAqIGJldHdlZW4gdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzLiBUaGlzIHN0cmF0ZWd5IGlzIHRoZSBkZWZhdWx0IGJlaGF2aW9yLlxyXG4gICAgICovXHJcbiAgICBSb3RhdGlvblR5cGVbUm90YXRpb25UeXBlW1wiU2hvcnRlc3RQYXRoXCJdID0gMF0gPSBcIlNob3J0ZXN0UGF0aFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGlvbiB2aWEgYExvbmdlc3RQYXRoYCB3aWxsIHVzZSB0aGUgbGFyZ2VzdCBhbmdsZVxyXG4gICAgICogYmV0d2VlbiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIFJvdGF0aW9uVHlwZVtSb3RhdGlvblR5cGVbXCJMb25nZXN0UGF0aFwiXSA9IDFdID0gXCJMb25nZXN0UGF0aFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGlvbiB2aWEgYENsb2Nrd2lzZWAgd2lsbCB0cmF2ZWwgaW4gYSBjbG9ja3dpc2UgZGlyZWN0aW9uLFxyXG4gICAgICogcmVnYXJkbGVzcyBvZiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIFJvdGF0aW9uVHlwZVtSb3RhdGlvblR5cGVbXCJDbG9ja3dpc2VcIl0gPSAyXSA9IFwiQ2xvY2t3aXNlXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0aW9uIHZpYSBgQ291bnRlckNsb2Nrd2lzZWAgd2lsbCB0cmF2ZWwgaW4gYSBjb3VudGVyY2xvY2t3aXNlIGRpcmVjdGlvbixcclxuICAgICAqIHJlZ2FyZGxlc3Mgb2YgdGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgcG9pbnRzLlxyXG4gICAgICovXHJcbiAgICBSb3RhdGlvblR5cGVbUm90YXRpb25UeXBlW1wiQ291bnRlckNsb2Nrd2lzZVwiXSA9IDNdID0gXCJDb3VudGVyQ2xvY2t3aXNlXCI7XHJcbn0pKFJvdGF0aW9uVHlwZSB8fCAoUm90YXRpb25UeXBlID0ge30pKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9Sb3RhdGVUby50c1xuXHJcblxyXG5cclxuXHJcbmNsYXNzIFJvdGF0ZVRvIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgYW5nbGVSYWRpYW5zLCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90eCA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24gPSBlbnRpdHkuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fZW5kID0gYW5nbGVSYWRpYW5zO1xyXG4gICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5fcm90YXRpb25UeXBlID0gcm90YXRpb25UeXBlIHx8IFJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX3R4LnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Tm9uQ2Fubm9uQW5nbGUgPSB0aGlzLl90eC5yb3RhdGlvbjtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UxID0gTWF0aC5hYnModGhpcy5fZW5kIC0gdGhpcy5fc3RhcnQpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZTIgPSBUd29QSSAtIGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlMSA+IGRpc3RhbmNlMikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnREaXN0YW5jZSA9IGRpc3RhbmNlMjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdEaXN0YW5jZSA9IGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0RGlzdGFuY2UgPSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGlzdGFuY2UgPSBkaXN0YW5jZTI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSA9ICh0aGlzLl9zdGFydCAtIHRoaXMuX2VuZCArIFR3b1BJKSAlIFR3b1BJID49IE1hdGguUEk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZS5Mb25nZXN0UGF0aDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGUuQ2xvY2t3aXNlOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGUuQ291bnRlckNsb2Nrd2lzZTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX21vdGlvbi5hbmd1bGFyVmVsb2NpdHkgPSB0aGlzLl9kaXJlY3Rpb24gKiB0aGlzLl9zcGVlZDtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Tm9uQ2Fubm9uQW5nbGUgKz0gdGhpcy5fZGlyZWN0aW9uICogdGhpcy5fc3BlZWQgKiAoX2RlbHRhIC8gMTAwMCk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R4LnJvdGF0aW9uID0gdGhpcy5fZW5kO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24uYW5ndWxhclZlbG9jaXR5ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZVRyYXZlbGxlZCA9IE1hdGguYWJzKHRoaXMuX2N1cnJlbnROb25DYW5ub25BbmdsZSAtIHRoaXMuX3N0YXJ0KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCBkaXN0YW5jZVRyYXZlbGxlZCA+PSBNYXRoLmFicyh0aGlzLl9kaXN0YW5jZSk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi5hbmd1bGFyVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vUm90YXRlQnkudHNcblxyXG5cclxuXHJcblxyXG5jbGFzcyBSb3RhdGVCeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIGFuZ2xlUmFkaWFuc09mZnNldCwgc3BlZWQsIHJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdHggPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uID0gZW50aXR5LmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gYW5nbGVSYWRpYW5zT2Zmc2V0O1xyXG4gICAgICAgIHRoaXMuX3JvdGF0aW9uVHlwZSA9IHJvdGF0aW9uVHlwZSB8fCBSb3RhdGlvblR5cGUuU2hvcnRlc3RQYXRoO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9kZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSB0aGlzLl90eC5yb3RhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudE5vbkNhbm5vbkFuZ2xlID0gdGhpcy5fdHgucm90YXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZCA9IHRoaXMuX3N0YXJ0ICsgdGhpcy5fb2Zmc2V0O1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZTEgPSBNYXRoLmFicyh0aGlzLl9lbmQgLSB0aGlzLl9zdGFydCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlMiA9IFR3b1BJIC0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UxID4gZGlzdGFuY2UyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydERpc3RhbmNlID0gZGlzdGFuY2UyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ0Rpc3RhbmNlID0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnREaXN0YW5jZSA9IGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdEaXN0YW5jZSA9IGRpc3RhbmNlMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlID0gKHRoaXMuX3N0YXJ0IC0gdGhpcy5fZW5kICsgVHdvUEkpICUgVHdvUEkgPj0gTWF0aC5QSTtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9yb3RhdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlLlNob3J0ZXN0UGF0aDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlLkxvbmdlc3RQYXRoOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZS5DbG9ja3dpc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnREaXN0YW5jZSA+PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlLkNvdW50ZXJDbG9ja3dpc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0RGlzdGFuY2UgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLmFuZ3VsYXJWZWxvY2l0eSA9IHRoaXMuX2RpcmVjdGlvbiAqIHRoaXMuX3NwZWVkO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnROb25DYW5ub25BbmdsZSArPSB0aGlzLl9kaXJlY3Rpb24gKiB0aGlzLl9zcGVlZCAqIChfZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHgucm90YXRpb24gPSB0aGlzLl9lbmQ7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi5hbmd1bGFyVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVHJhdmVsbGVkID0gTWF0aC5hYnModGhpcy5fY3VycmVudE5vbkNhbm5vbkFuZ2xlIC0gdGhpcy5fc3RhcnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IGRpc3RhbmNlVHJhdmVsbGVkID49IE1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9TY2FsZVRvLnRzXG5cclxuXHJcblxyXG5jbGFzcyBTY2FsZVRvIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgc2NhbGVYLCBzY2FsZVksIHNwZWVkWCwgc3BlZWRZKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90eCA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24gPSBlbnRpdHkuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fZW5kWCA9IHNjYWxlWDtcclxuICAgICAgICB0aGlzLl9lbmRZID0gc2NhbGVZO1xyXG4gICAgICAgIHRoaXMuX3NwZWVkWCA9IHNwZWVkWDtcclxuICAgICAgICB0aGlzLl9zcGVlZFkgPSBzcGVlZFk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydFggPSB0aGlzLl90eC5zY2FsZS54O1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydFkgPSB0aGlzLl90eC5zY2FsZS55O1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZVggPSBNYXRoLmFicyh0aGlzLl9lbmRYIC0gdGhpcy5fc3RhcnRYKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VZID0gTWF0aC5hYnModGhpcy5fZW5kWSAtIHRoaXMuX3N0YXJ0WSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKE1hdGguYWJzKHRoaXMuX3R4LnNjYWxlLnggLSB0aGlzLl9zdGFydFgpID49IHRoaXMuX2Rpc3RhbmNlWCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uWCA9IHRoaXMuX2VuZFkgPCB0aGlzLl9zdGFydFkgPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci54ID0gdGhpcy5fc3BlZWRYICogZGlyZWN0aW9uWDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci54ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoTWF0aC5hYnModGhpcy5fdHguc2NhbGUueSAtIHRoaXMuX3N0YXJ0WSkgPj0gdGhpcy5fZGlzdGFuY2VZKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25ZID0gdGhpcy5fZW5kWSA8IHRoaXMuX3N0YXJ0WSA/IC0xIDogMTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnkgPSB0aGlzLl9zcGVlZFkgKiBkaXJlY3Rpb25ZO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHguc2NhbGUgPSB2ZWModGhpcy5fZW5kWCwgdGhpcy5fZW5kWSk7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci54ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9zdG9wcGVkIHx8XHJcbiAgICAgICAgICAgIChNYXRoLmFicyh0aGlzLl90eC5zY2FsZS55IC0gdGhpcy5fc3RhcnRYKSA+PSB0aGlzLl9kaXN0YW5jZVggJiYgTWF0aC5hYnModGhpcy5fdHguc2NhbGUueSAtIHRoaXMuX3N0YXJ0WSkgPj0gdGhpcy5fZGlzdGFuY2VZKSk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci54ID0gMDtcclxuICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueSA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9TY2FsZUJ5LnRzXG5cclxuXHJcblxyXG5jbGFzcyBTY2FsZUJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgc2NhbGVPZmZzZXRYLCBzY2FsZU9mZnNldFksIHNwZWVkKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90eCA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24gPSBlbnRpdHkuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gbmV3IFZlY3RvcihzY2FsZU9mZnNldFgsIHNjYWxlT2Zmc2V0WSk7XHJcbiAgICAgICAgdGhpcy5fc3BlZWRYID0gdGhpcy5fc3BlZWRZID0gc3BlZWQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydFNjYWxlID0gdGhpcy5fdHguc2NhbGUuY2xvbmUoKTtcclxuICAgICAgICAgICAgdGhpcy5fZW5kU2NhbGUgPSB0aGlzLl9zdGFydFNjYWxlLmFkZCh0aGlzLl9vZmZzZXQpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZVggPSBNYXRoLmFicyh0aGlzLl9lbmRTY2FsZS54IC0gdGhpcy5fc3RhcnRTY2FsZS54KTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2VZID0gTWF0aC5hYnModGhpcy5fZW5kU2NhbGUueSAtIHRoaXMuX3N0YXJ0U2NhbGUueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvblggPSB0aGlzLl9lbmRTY2FsZS54IDwgdGhpcy5fc3RhcnRTY2FsZS54ID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb25ZID0gdGhpcy5fZW5kU2NhbGUueSA8IHRoaXMuX3N0YXJ0U2NhbGUueSA/IC0xIDogMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnggPSB0aGlzLl9zcGVlZFggKiB0aGlzLl9kaXJlY3Rpb25YO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci55ID0gdGhpcy5fc3BlZWRZICogdGhpcy5fZGlyZWN0aW9uWTtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHguc2NhbGUgPSB0aGlzLl9lbmRTY2FsZTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX3N0b3BwZWQgfHxcclxuICAgICAgICAgICAgKE1hdGguYWJzKHRoaXMuX3R4LnNjYWxlLnggLSB0aGlzLl9zdGFydFNjYWxlLngpID49IHRoaXMuX2Rpc3RhbmNlWCAmJlxyXG4gICAgICAgICAgICAgICAgTWF0aC5hYnModGhpcy5fdHguc2NhbGUueSAtIHRoaXMuX3N0YXJ0U2NhbGUueSkgPj0gdGhpcy5fZGlzdGFuY2VZKSk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci54ID0gMDtcclxuICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueSA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9DYWxsTWV0aG9kLnRzXG5jbGFzcyBDYWxsTWV0aG9kIHtcclxuICAgIGNvbnN0cnVjdG9yKG1ldGhvZCkge1xyXG4gICAgICAgIHRoaXMuX21ldGhvZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX21ldGhvZCA9IG1ldGhvZDtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZGVsdGEpIHtcclxuICAgICAgICB0aGlzLl9tZXRob2QoKTtcclxuICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhc0JlZW5DYWxsZWQ7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vRWFzZVRvLnRzXG5cclxuXHJcblxyXG5jbGFzcyBFYXNlVG8ge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCB4LCB5LCBkdXJhdGlvbiwgZWFzaW5nRmNuKSB7XHJcbiAgICAgICAgdGhpcy5lYXNpbmdGY24gPSBlYXNpbmdGY247XHJcbiAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSAxICogMTAwMDsgLy8gMSBzZWNvbmRcclxuICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2xlcnBFbmQgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gMDtcclxuICAgICAgICB0aGlzLl90eCA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24gPSBlbnRpdHkuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5fbGVycEVuZCA9IG5ldyBWZWN0b3IoeCwgeSk7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZSgpIHtcclxuICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSBuZXcgVmVjdG9yKHRoaXMuX3R4LnBvcy54LCB0aGlzLl90eC5wb3MueSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xlcnBTdGFydC5kaXN0YW5jZSh0aGlzLl9sZXJwRW5kKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5lZWQgdG8gdXBkYXRlIGxlcnAgdGltZSBmaXJzdCwgb3RoZXJ3aXNlIHRoZSBmaXJzdCB1cGRhdGUgd2lsbCBhbHdheXMgYmUgemVyb1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSArPSBkZWx0YTtcclxuICAgICAgICBsZXQgbmV3WCA9IHRoaXMuX3R4LnBvcy54O1xyXG4gICAgICAgIGxldCBuZXdZID0gdGhpcy5fdHgucG9zLnk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRMZXJwVGltZSA8IHRoaXMuX2xlcnBEdXJhdGlvbikge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fbGVycEVuZC54IDwgdGhpcy5fbGVycFN0YXJ0LngpIHtcclxuICAgICAgICAgICAgICAgIG5ld1ggPVxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydC54IC1cclxuICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycER1cmF0aW9uKSAtIHRoaXMuX2xlcnBFbmQueCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBuZXdYID0gdGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQueCwgdGhpcy5fbGVycEVuZC54LCB0aGlzLl9sZXJwRHVyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnkgPCB0aGlzLl9sZXJwU3RhcnQueSkge1xyXG4gICAgICAgICAgICAgICAgbmV3WSA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0LnkgLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwRW5kLnksIHRoaXMuX2xlcnBTdGFydC55LCB0aGlzLl9sZXJwRHVyYXRpb24pIC0gdGhpcy5fbGVycEVuZC55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld1kgPSB0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydC55LCB0aGlzLl9sZXJwRW5kLnksIHRoaXMuX2xlcnBEdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gR2l2ZW4gdGhlIGxlcnAgcG9zaXRpb24gZmlndXJlIG91dCB0aGUgdmVsb2NpdHkgaW4gcGl4ZWxzIHBlciBzZWNvbmRcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygobmV3WCAtIHRoaXMuX3R4LnBvcy54KSAvIChkZWx0YSAvIDEwMDApLCAobmV3WSAtIHRoaXMuX3R4LnBvcy55KSAvIChkZWx0YSAvIDEwMDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R4LnBvcyA9IHZlYyh0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBFbmQueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSBWZWN0b3IuWmVybztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKGFjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgbmV3IFZlY3RvcihhY3Rvci5wb3MueCwgYWN0b3IucG9zLnkpLmRpc3RhbmNlKHRoaXMuX2xlcnBTdGFydCkgPj0gdGhpcy5fZGlzdGFuY2U7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKDAsIDApO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vQmxpbmsudHNcblxyXG5jbGFzcyBCbGluayB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzID0gMSkge1xyXG4gICAgICAgIHRoaXMuX3RpbWVWaXNpYmxlID0gMDtcclxuICAgICAgICB0aGlzLl90aW1lTm90VmlzaWJsZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX3RvdGFsVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9ncmFwaGljcyA9IGVudGl0eS5nZXQoR3JhcGhpY3NDb21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX3RpbWVWaXNpYmxlID0gdGltZVZpc2libGU7XHJcbiAgICAgICAgdGhpcy5fdGltZU5vdFZpc2libGUgPSB0aW1lTm90VmlzaWJsZTtcclxuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9ICh0aW1lVmlzaWJsZSArIHRpbWVOb3RWaXNpYmxlKSAqIG51bUJsaW5rcztcclxuICAgIH1cclxuICAgIHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ncmFwaGljcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgIHRoaXMuX3RvdGFsVGltZSArPSBkZWx0YTtcclxuICAgICAgICBpZiAodGhpcy5fZ3JhcGhpY3MudmlzaWJsZSAmJiB0aGlzLl9lbGFwc2VkVGltZSA+PSB0aGlzLl90aW1lVmlzaWJsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljcy52aXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9ncmFwaGljcy52aXNpYmxlICYmIHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuX3RpbWVOb3RWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IHRoaXMuX3RvdGFsVGltZSA+PSB0aGlzLl9kdXJhdGlvbjtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2dyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fdG90YWxUaW1lID0gMDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL0ZhZGUudHNcblxyXG5cclxuY2xhc3MgRmFkZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIGVuZE9wYWNpdHksIHNwZWVkKSB7XHJcbiAgICAgICAgdGhpcy5fbXVsdGlwbGllciA9IDE7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9ncmFwaGljcyA9IGVudGl0eS5nZXQoR3JhcGhpY3NDb21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2VuZE9wYWNpdHkgPSBlbmRPcGFjaXR5O1xyXG4gICAgICAgIHRoaXMuX3NwZWVkID0gc3BlZWQ7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2dyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgZGlyZWN0aW9uIHdoZW4gd2Ugc3RhcnRcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuZE9wYWNpdHkgPCB0aGlzLl9ncmFwaGljcy5vcGFjaXR5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tdWx0aXBsaWVyID0gLTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tdWx0aXBsaWVyID0gMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fc3BlZWQgPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzLm9wYWNpdHkgKz0gKHRoaXMuX211bHRpcGxpZXIgKlxyXG4gICAgICAgICAgICAgICAgKE1hdGguYWJzKHRoaXMuX2dyYXBoaWNzLm9wYWNpdHkgLSB0aGlzLl9lbmRPcGFjaXR5KSAqIGRlbHRhKSkgLyB0aGlzLl9zcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc3BlZWQgLT0gZGVsdGE7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzLm9wYWNpdHkgPSB0aGlzLl9lbmRPcGFjaXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnW0FjdGlvbiBmYWRlXSBBY3RvciBvcGFjaXR5OicsIHRoaXMuX2dyYXBoaWNzLm9wYWNpdHkpO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCBNYXRoLmFicyh0aGlzLl9ncmFwaGljcy5vcGFjaXR5IC0gdGhpcy5fZW5kT3BhY2l0eSkgPCAwLjA1O1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL0RlbGF5LnRzXG5jbGFzcyBEZWxheSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkZWxheSkge1xyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RlbGF5ID0gZGVsYXk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lICs9IGRlbHRhO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCB0aGlzLl9lbGFwc2VkVGltZSA+PSB0aGlzLl9kZWxheTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vRGllLnRzXG5cclxuY2xhc3MgRGllIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSkge1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9lbnRpdHkgPSBlbnRpdHk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5fZW50aXR5LmdldChBY3Rpb25zQ29tcG9uZW50KS5jbGVhckFjdGlvbnMoKTtcclxuICAgICAgICB0aGlzLl9lbnRpdHkua2lsbCgpO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vRm9sbG93LnRzXG5cclxuXHJcblxyXG5jbGFzcyBGb2xsb3cge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCBlbnRpdHlUb0ZvbGxvdywgZm9sbG93RGlzdGFuY2UpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3R4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IGVudGl0eS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9mb2xsb3dUeCA9IGVudGl0eVRvRm9sbG93LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2ZvbGxvd01vdGlvbiA9IGVudGl0eVRvRm9sbG93LmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSBuZXcgVmVjdG9yKHRoaXMuX3R4LnBvcy54LCB0aGlzLl90eC5wb3MueSk7XHJcbiAgICAgICAgdGhpcy5fZW5kID0gbmV3IFZlY3Rvcih0aGlzLl9mb2xsb3dUeC5wb3MueCwgdGhpcy5fZm9sbG93VHgucG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX21heGltdW1EaXN0YW5jZSA9IGZvbGxvd0Rpc3RhbmNlICE9PSB1bmRlZmluZWQgPyBmb2xsb3dEaXN0YW5jZSA6IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICB0aGlzLl9zcGVlZCA9IDA7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZUJldHdlZW4gPSB0aGlzLl9jdXJyZW50LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fY3VycmVudCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjdG9yVG9Gb2xsb3dTcGVlZCA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLl9mb2xsb3dNb3Rpb24udmVsLngsIDIpICsgTWF0aC5wb3codGhpcy5fZm9sbG93TW90aW9uLnZlbC55LCAyKSk7XHJcbiAgICAgICAgaWYgKGFjdG9yVG9Gb2xsb3dTcGVlZCAhPT0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zcGVlZCA9IGFjdG9yVG9Gb2xsb3dTcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHZlYyh0aGlzLl90eC5wb3MueCwgdGhpcy5fdHgucG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX2VuZCA9IHZlYyh0aGlzLl9mb2xsb3dUeC5wb3MueCwgdGhpcy5fZm9sbG93VHgucG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA9IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICB0aGlzLl9kaXIgPSB0aGlzLl9lbmQuc3ViKHRoaXMuX2N1cnJlbnQpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXN0YW5jZUJldHdlZW4gPj0gdGhpcy5fbWF4aW11bURpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLl9kaXIuc2NhbGUodGhpcy5fc3BlZWQpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKG0ueCwgbS55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5wb3MgPSB2ZWModGhpcy5fZW5kLngsIHRoaXMuX2VuZC55KTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIC8vIHRoZSBhY3RvciBmb2xsb3dpbmcgc2hvdWxkIG5ldmVyIHN0b3AgdW5sZXNzIHNwZWNpZmllZCB0byBkbyBzb1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vTWVldC50c1xuXHJcblxyXG5cclxuY2xhc3MgTWVldCB7XHJcbiAgICBjb25zdHJ1Y3RvcihhY3RvciwgYWN0b3JUb01lZXQsIHNwZWVkKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zcGVlZFdhc1NwZWNpZmllZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3R4ID0gYWN0b3IuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uID0gYWN0b3IuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbWVldFR4ID0gYWN0b3JUb01lZXQuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbWVldE1vdGlvbiA9IGFjdG9yVG9NZWV0LmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnQgPSBuZXcgVmVjdG9yKHRoaXMuX3R4LnBvcy54LCB0aGlzLl90eC5wb3MueSk7XHJcbiAgICAgICAgdGhpcy5fZW5kID0gbmV3IFZlY3Rvcih0aGlzLl9tZWV0VHgucG9zLngsIHRoaXMuX21lZXRUeC5wb3MueSk7XHJcbiAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZCB8fCAwO1xyXG4gICAgICAgIGlmIChzcGVlZCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkV2FzU3BlY2lmaWVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZUJldHdlZW4gPSB0aGlzLl9jdXJyZW50LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fY3VycmVudCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGFjdG9yVG9NZWV0U3BlZWQgPSBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy5fbWVldE1vdGlvbi52ZWwueCwgMikgKyBNYXRoLnBvdyh0aGlzLl9tZWV0TW90aW9uLnZlbC55LCAyKSk7XHJcbiAgICAgICAgaWYgKGFjdG9yVG9NZWV0U3BlZWQgIT09IDAgJiYgIXRoaXMuX3NwZWVkV2FzU3BlY2lmaWVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gYWN0b3JUb01lZXRTcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IHZlYyh0aGlzLl90eC5wb3MueCwgdGhpcy5fdHgucG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX2VuZCA9IHZlYyh0aGlzLl9tZWV0VHgucG9zLngsIHRoaXMuX21lZXRUeC5wb3MueSk7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fY3VycmVudCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuX2Rpci5zY2FsZSh0aGlzLl9zcGVlZCk7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYyhtLngsIG0ueSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R4LnBvcyA9IHZlYyh0aGlzLl9lbmQueCwgdGhpcy5fZW5kLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgdGhpcy5fZGlzdGFuY2VCZXR3ZWVuIDw9IDE7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbkNvbnRleHQudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIGZsdWVudCBBY3Rpb24gQVBJIGFsbG93cyB5b3UgdG8gcGVyZm9ybSBcImFjdGlvbnNcIiBvblxyXG4gKiBbW0FjdG9yfEFjdG9yc11dIHN1Y2ggYXMgZm9sbG93aW5nLCBtb3ZpbmcsIHJvdGF0aW5nLCBhbmRcclxuICogbW9yZS4gWW91IGNhbiBpbXBsZW1lbnQgeW91ciBvd24gYWN0aW9ucyBieSBpbXBsZW1lbnRpbmdcclxuICogdGhlIFtbQWN0aW9uXV0gaW50ZXJmYWNlLlxyXG4gKi9cclxuY2xhc3MgQWN0aW9uQ29udGV4dCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHkpIHtcclxuICAgICAgICB0aGlzLl9lbnRpdHkgPSBlbnRpdHk7XHJcbiAgICAgICAgdGhpcy5fcXVldWUgPSBuZXcgQWN0aW9uUXVldWUoZW50aXR5KTtcclxuICAgIH1cclxuICAgIGdldFF1ZXVlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9xdWV1ZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShlbGFwc2VkTXMpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS51cGRhdGUoZWxhcHNlZE1zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGFsbCBxdWV1ZWQgYWN0aW9ucyBmcm9tIHRoZSBBY3RvclxyXG4gICAgICovXHJcbiAgICBjbGVhckFjdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUuY2xlYXJBY3Rpb25zKCk7XHJcbiAgICB9XHJcbiAgICBlYXNlVG8oLi4uYXJncykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgIGxldCB5ID0gMDtcclxuICAgICAgICBsZXQgZHVyYXRpb24gPSAwO1xyXG4gICAgICAgIGxldCBlYXNpbmdGY24gPSBFYXNpbmdGdW5jdGlvbnMuTGluZWFyO1xyXG4gICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHggPSBhcmdzWzBdLng7XHJcbiAgICAgICAgICAgIHkgPSBhcmdzWzBdLnk7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gYXJnc1sxXTtcclxuICAgICAgICAgICAgZWFzaW5nRmNuID0gKF9hID0gYXJnc1syXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZWFzaW5nRmNuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgeCA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgIHkgPSBhcmdzWzFdO1xyXG4gICAgICAgICAgICBkdXJhdGlvbiA9IGFyZ3NbMl07XHJcbiAgICAgICAgICAgIGVhc2luZ0ZjbiA9IChfYiA9IGFyZ3NbM10pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGVhc2luZ0ZjbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBFYXNlVG8odGhpcy5fZW50aXR5LCB4LCB5LCBkdXJhdGlvbiwgZWFzaW5nRmNuKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBtb3ZlVG8oeE9yUG9zLCB5T3JTcGVlZCwgc3BlZWRPclVuZGVmaW5lZCkge1xyXG4gICAgICAgIGxldCB4ID0gMDtcclxuICAgICAgICBsZXQgeSA9IDA7XHJcbiAgICAgICAgbGV0IHNwZWVkID0gMDtcclxuICAgICAgICBpZiAoeE9yUG9zIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHggPSB4T3JQb3MueDtcclxuICAgICAgICAgICAgeSA9IHhPclBvcy55O1xyXG4gICAgICAgICAgICBzcGVlZCA9IHlPclNwZWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgeCA9IHhPclBvcztcclxuICAgICAgICAgICAgeSA9IHlPclNwZWVkO1xyXG4gICAgICAgICAgICBzcGVlZCA9IHNwZWVkT3JVbmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgTW92ZVRvKHRoaXMuX2VudGl0eSwgeCwgeSwgc3BlZWQpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIG1vdmVCeSh4T2Zmc2V0T3JWZWN0b3IsIHlPZmZzZXRPclNwZWVkLCBzcGVlZE9yVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbGV0IHhPZmZzZXQgPSAwO1xyXG4gICAgICAgIGxldCB5T2Zmc2V0ID0gMDtcclxuICAgICAgICBsZXQgc3BlZWQgPSAwO1xyXG4gICAgICAgIGlmICh4T2Zmc2V0T3JWZWN0b3IgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgeE9mZnNldCA9IHhPZmZzZXRPclZlY3Rvci54O1xyXG4gICAgICAgICAgICB5T2Zmc2V0ID0geE9mZnNldE9yVmVjdG9yLnk7XHJcbiAgICAgICAgICAgIHNwZWVkID0geU9mZnNldE9yU3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB4T2Zmc2V0ID0geE9mZnNldE9yVmVjdG9yO1xyXG4gICAgICAgICAgICB5T2Zmc2V0ID0geU9mZnNldE9yU3BlZWQ7XHJcbiAgICAgICAgICAgIHNwZWVkID0gc3BlZWRPclVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBNb3ZlQnkodGhpcy5fZW50aXR5LCB4T2Zmc2V0LCB5T2Zmc2V0LCBzcGVlZCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGF0IHRoZSBzcGVlZFxyXG4gICAgICogc3BlY2lmaWVkIChpbiByYWRpYW5zIHBlciBzZWNvbmQpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXNcclxuICAgICAqIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSBhbmdsZVJhZGlhbnMgIFRoZSBhbmdsZSB0byByb3RhdGUgdG8gaW4gcmFkaWFuc1xyXG4gICAgICogQHBhcmFtIHNwZWVkICAgICAgICAgVGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIHJvdGF0aW9uIHNwZWNpZmllZCBpbiByYWRpYW5zIHBlciBzZWNvbmRcclxuICAgICAqIEBwYXJhbSByb3RhdGlvblR5cGUgIFRoZSBbW1JvdGF0aW9uVHlwZV1dIHRvIHVzZSBmb3IgdGhpcyByb3RhdGlvblxyXG4gICAgICovXHJcbiAgICByb3RhdGVUbyhhbmdsZVJhZGlhbnMsIHNwZWVkLCByb3RhdGlvblR5cGUpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IFJvdGF0ZVRvKHRoaXMuX2VudGl0eSwgYW5nbGVSYWRpYW5zLCBzcGVlZCwgcm90YXRpb25UeXBlKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcm90YXRlIGFuIGFjdG9yIGJ5IHRoZSBzcGVjaWZpZWQgYW5nbGUgb2Zmc2V0LCBmcm9tIGl0J3MgY3VycmVudCByb3RhdGlvbiBnaXZlbiBhIGNlcnRhaW4gc3BlZWRcclxuICAgICAqIGluIHJhZGlhbnMvc2VjIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIHBhcnRcclxuICAgICAqIG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSBhbmdsZVJhZGlhbnNPZmZzZXQgIFRoZSBhbmdsZSB0byByb3RhdGUgdG8gaW4gcmFkaWFucyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCByb3RhdGlvblxyXG4gICAgICogQHBhcmFtIHNwZWVkICAgICAgICAgIFRoZSBzcGVlZCBpbiByYWRpYW5zL3NlYyB0aGUgYWN0b3Igc2hvdWxkIHJvdGF0ZSBhdFxyXG4gICAgICogQHBhcmFtIHJvdGF0aW9uVHlwZSAgVGhlIFtbUm90YXRpb25UeXBlXV0gdG8gdXNlIGZvciB0aGlzIHJvdGF0aW9uLCBkZWZhdWx0IGlzIHNob3J0ZXN0IHBhdGhcclxuICAgICAqL1xyXG4gICAgcm90YXRlQnkoYW5nbGVSYWRpYW5zT2Zmc2V0LCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBSb3RhdGVCeSh0aGlzLl9lbnRpdHksIGFuZ2xlUmFkaWFuc09mZnNldCwgc3BlZWQsIHJvdGF0aW9uVHlwZSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgc2NhbGVUbyhzaXplWE9yVmVjdG9yLCBzaXplWU9yU3BlZWQsIHNwZWVkWE9yVW5kZWZpbmVkLCBzcGVlZFlPclVuZGVmaW5lZCkge1xyXG4gICAgICAgIGxldCBzaXplWCA9IDE7XHJcbiAgICAgICAgbGV0IHNpemVZID0gMTtcclxuICAgICAgICBsZXQgc3BlZWRYID0gMDtcclxuICAgICAgICBsZXQgc3BlZWRZID0gMDtcclxuICAgICAgICBpZiAoc2l6ZVhPclZlY3RvciBpbnN0YW5jZW9mIFZlY3RvciAmJiBzaXplWU9yU3BlZWQgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgc2l6ZVggPSBzaXplWE9yVmVjdG9yLng7XHJcbiAgICAgICAgICAgIHNpemVZID0gc2l6ZVhPclZlY3Rvci55O1xyXG4gICAgICAgICAgICBzcGVlZFggPSBzaXplWU9yU3BlZWQueDtcclxuICAgICAgICAgICAgc3BlZWRZID0gc2l6ZVlPclNwZWVkLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZVhPclZlY3RvciA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHNpemVZT3JTcGVlZCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgc2l6ZVggPSBzaXplWE9yVmVjdG9yO1xyXG4gICAgICAgICAgICBzaXplWSA9IHNpemVZT3JTcGVlZDtcclxuICAgICAgICAgICAgc3BlZWRYID0gc3BlZWRYT3JVbmRlZmluZWQ7XHJcbiAgICAgICAgICAgIHNwZWVkWSA9IHNwZWVkWU9yVW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IFNjYWxlVG8odGhpcy5fZW50aXR5LCBzaXplWCwgc2l6ZVksIHNwZWVkWCwgc3BlZWRZKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzY2FsZUJ5KHNpemVPZmZzZXRYT3JWZWN0b3IsIHNpemVPZmZzZXRZT3JTcGVlZCwgc3BlZWQpIHtcclxuICAgICAgICBsZXQgc2l6ZU9mZnNldFggPSAxO1xyXG4gICAgICAgIGxldCBzaXplT2Zmc2V0WSA9IDE7XHJcbiAgICAgICAgaWYgKHNpemVPZmZzZXRYT3JWZWN0b3IgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgc2l6ZU9mZnNldFggPSBzaXplT2Zmc2V0WE9yVmVjdG9yLng7XHJcbiAgICAgICAgICAgIHNpemVPZmZzZXRZID0gc2l6ZU9mZnNldFhPclZlY3Rvci55O1xyXG4gICAgICAgICAgICBzcGVlZCA9IHNpemVPZmZzZXRZT3JTcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzaXplT2Zmc2V0WE9yVmVjdG9yID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2l6ZU9mZnNldFlPclNwZWVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBzaXplT2Zmc2V0WCA9IHNpemVPZmZzZXRYT3JWZWN0b3I7XHJcbiAgICAgICAgICAgIHNpemVPZmZzZXRZID0gc2l6ZU9mZnNldFlPclNwZWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IFNjYWxlQnkodGhpcy5fZW50aXR5LCBzaXplT2Zmc2V0WCwgc2l6ZU9mZnNldFksIHNwZWVkKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgYW4gYWN0b3IgdG8gYmxpbmsgKGJlY29tZSB2aXNpYmxlIGFuZCBub3RcclxuICAgICAqIHZpc2libGUpLiBPcHRpb25hbGx5LCB5b3UgbWF5IHNwZWNpZnkgdGhlIG51bWJlciBvZiBibGlua3MuIFNwZWNpZnkgdGhlIGFtb3VudCBvZiB0aW1lXHJcbiAgICAgKiB0aGUgYWN0b3Igc2hvdWxkIGJlIHZpc2libGUgcGVyIGJsaW5rLCBhbmQgdGhlIGFtb3VudCBvZiB0aW1lIG5vdCB2aXNpYmxlLlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gdGltZVZpc2libGUgICAgIFRoZSBhbW91bnQgb2YgdGltZSB0byBzdGF5IHZpc2libGUgcGVyIGJsaW5rIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHBhcmFtIHRpbWVOb3RWaXNpYmxlICBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc3RheSBub3QgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKiBAcGFyYW0gbnVtQmxpbmtzICAgICAgIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gYmxpbmtcclxuICAgICAqL1xyXG4gICAgYmxpbmsodGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MgPSAxKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBCbGluayh0aGlzLl9lbnRpdHksIHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgYW4gYWN0b3IncyBvcGFjaXR5IHRvIGNoYW5nZSBmcm9tIGl0cyBjdXJyZW50IHZhbHVlXHJcbiAgICAgKiB0byB0aGUgcHJvdmlkZWQgdmFsdWUgYnkgYSBzcGVjaWZpZWQgdGltZSAoaW4gbWlsbGlzZWNvbmRzKS4gVGhpcyBtZXRob2QgaXNcclxuICAgICAqIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICogQHBhcmFtIG9wYWNpdHkgIFRoZSBlbmRpbmcgb3BhY2l0eVxyXG4gICAgICogQHBhcmFtIHRpbWUgICAgIFRoZSB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIGZhZGUgdGhlIGFjdG9yIChpbiBtaWxsaXNlY29uZHMpXHJcbiAgICAgKi9cclxuICAgIGZhZGUob3BhY2l0eSwgdGltZSkge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgRmFkZSh0aGlzLl9lbnRpdHksIG9wYWNpdHksIHRpbWUpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBkZWxheSB0aGUgbmV4dCBhY3Rpb24gZnJvbSBleGVjdXRpbmcgZm9yIGEgY2VydGFpblxyXG4gICAgICogYW1vdW50IG9mIHRpbWUgKGluIG1pbGxpc2Vjb25kcykuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yXHJcbiAgICAgKiAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSB0aW1lICBUaGUgYW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgdGhlIG5leHQgYWN0aW9uIGluIHRoZSBxdWV1ZSBmcm9tIGV4ZWN1dGluZyBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgZGVsYXkodGltZSkge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgRGVsYXkodGltZSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBhbiBhY3Rpb24gdG8gdGhlIHF1ZXVlIHRoYXQgd2lsbCByZW1vdmUgdGhlIGFjdG9yIGZyb20gdGhlXHJcbiAgICAgKiBzY2VuZSBvbmNlIGl0IGhhcyBjb21wbGV0ZWQgaXRzIHByZXZpb3VzICBBbnkgYWN0aW9ucyBvbiB0aGVcclxuICAgICAqIGFjdGlvbiBxdWV1ZSBhZnRlciB0aGlzIGFjdGlvbiB3aWxsIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAqL1xyXG4gICAgZGllKCkge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgRGllKHRoaXMuX2VudGl0eSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgeW91IHRvIGNhbGwgYW4gYXJiaXRyYXJ5IG1ldGhvZCBhcyB0aGUgbmV4dCBhY3Rpb24gaW4gdGhlXHJcbiAgICAgKiBhY3Rpb24gcXVldWUuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGV4ZWN1dGUgY29kZSBpbiBhZnRlciBhIHNwZWNpZmljXHJcbiAgICAgKiBhY3Rpb24sIGkuZSBBbiBhY3RvciBhcnJpdmVzIGF0IGEgZGVzdGluYXRpb24gYWZ0ZXIgdHJhdmVyc2luZyBhIHBhdGhcclxuICAgICAqL1xyXG4gICAgY2FsbE1ldGhvZChtZXRob2QpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IENhbGxNZXRob2QobWV0aG9kKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIHJlcGVhdCBhbGwgb2YgdGhlIGFjdGlvbnMgYnVpbHQgaW5cclxuICAgICAqIHRoZSBgcmVwZWF0QnVpbGRlcmAgY2FsbGJhY2suIElmIHRoZSBudW1iZXIgb2YgcmVwZWF0c1xyXG4gICAgICogaXMgbm90IHNwZWNpZmllZCBpdCB3aWxsIHJlcGVhdCBmb3JldmVyLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mXHJcbiAgICAgKiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmdcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiAvLyBNb3ZlIHVwIGluIGEgemlnLXphZyBieSByZXBlYXRlZCBtb3ZlQnknc1xyXG4gICAgICogYWN0b3IuYWN0aW9ucy5yZXBlYXQocmVwZWF0Q3R4ID0+IHtcclxuICAgICAqICByZXBlYXRDdHgubW92ZUJ5KDEwLCAwLCAxMCk7XHJcbiAgICAgKiAgcmVwZWF0Q3R4Lm1vdmVCeSgwLCAxMCwgMTApO1xyXG4gICAgICogfSwgNSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVwZWF0QnVpbGRlciBUaGUgYnVpbGRlciB0byBzcGVjaWZ5IHRoZSByZXBlYXRhYmxlIGxpc3Qgb2YgYWN0aW9uc1xyXG4gICAgICogQHBhcmFtIHRpbWVzICBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCBhbGwgdGhlIHByZXZpb3VzIGFjdGlvbnMgaW4gdGhlIGFjdGlvbiBxdWV1ZS4gSWYgbm90aGluZyBpcyBzcGVjaWZpZWQgdGhlIGFjdGlvbnNcclxuICAgICAqIHdpbGwgcmVwZWF0IGZvcmV2ZXJcclxuICAgICAqL1xyXG4gICAgcmVwZWF0KHJlcGVhdEJ1aWxkZXIsIHRpbWVzKSB7XHJcbiAgICAgICAgaWYgKCF0aW1lcykge1xyXG4gICAgICAgICAgICB0aGlzLnJlcGVhdEZvcmV2ZXIocmVwZWF0QnVpbGRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IFJlcGVhdCh0aGlzLl9lbnRpdHksIHJlcGVhdEJ1aWxkZXIsIHRpbWVzKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIHJlcGVhdCBhbGwgb2YgdGhlIGFjdGlvbnMgYnVpbHQgaW5cclxuICAgICAqIHRoZSBgcmVwZWF0QnVpbGRlcmAgY2FsbGJhY2suIElmIHRoZSBudW1iZXIgb2YgcmVwZWF0c1xyXG4gICAgICogaXMgbm90IHNwZWNpZmllZCBpdCB3aWxsIHJlcGVhdCBmb3JldmVyLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mXHJcbiAgICAgKiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmdcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiAvLyBNb3ZlIHVwIGluIGEgemlnLXphZyBieSByZXBlYXRlZCBtb3ZlQnknc1xyXG4gICAgICogYWN0b3IuYWN0aW9ucy5yZXBlYXQocmVwZWF0Q3R4ID0+IHtcclxuICAgICAqICByZXBlYXRDdHgubW92ZUJ5KDEwLCAwLCAxMCk7XHJcbiAgICAgKiAgcmVwZWF0Q3R4Lm1vdmVCeSgwLCAxMCwgMTApO1xyXG4gICAgICogfSwgNSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVwZWF0QnVpbGRlciBUaGUgYnVpbGRlciB0byBzcGVjaWZ5IHRoZSByZXBlYXRhYmxlIGxpc3Qgb2YgYWN0aW9uc1xyXG4gICAgICovXHJcbiAgICByZXBlYXRGb3JldmVyKHJlcGVhdEJ1aWxkZXIpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IFJlcGVhdEZvcmV2ZXIodGhpcy5fZW50aXR5LCByZXBlYXRCdWlsZGVyKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGVudGl0eSB0byBmb2xsb3cgYW5vdGhlciBhdCBhIHNwZWNpZmllZCBkaXN0YW5jZVxyXG4gICAgICogQHBhcmFtIGVudGl0eSAgICAgICAgICAgVGhlIGVudGl0eSB0byBmb2xsb3dcclxuICAgICAqIEBwYXJhbSBmb2xsb3dEaXN0YW5jZSAgVGhlIGRpc3RhbmNlIHRvIG1haW50YWluIHdoZW4gZm9sbG93aW5nLCBpZiBub3Qgc3BlY2lmaWVkIHRoZSBhY3RvciB3aWxsIGZvbGxvdyBhdCB0aGUgY3VycmVudCBkaXN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZm9sbG93KGVudGl0eSwgZm9sbG93RGlzdGFuY2UpIHtcclxuICAgICAgICBpZiAoZm9sbG93RGlzdGFuY2UgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IEZvbGxvdyh0aGlzLl9lbnRpdHksIGVudGl0eSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBGb2xsb3codGhpcy5fZW50aXR5LCBlbnRpdHksIGZvbGxvd0Rpc3RhbmNlKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBlbnRpdHkgdG8gbW92ZSB0b3dhcmRzIGFub3RoZXIgdW50aWwgdGhleVxyXG4gICAgICogY29sbGlkZSBcIm1lZXRcIiBhdCBhIHNwZWNpZmllZCBzcGVlZC5cclxuICAgICAqIEBwYXJhbSBlbnRpdHkgIFRoZSBlbnRpdHkgdG8gbWVldFxyXG4gICAgICogQHBhcmFtIHNwZWVkICBUaGUgc3BlZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmQgdG8gbW92ZSwgaWYgbm90IHNwZWNpZmllZCBpdCB3aWxsIG1hdGNoIHRoZSBzcGVlZCBvZiB0aGUgb3RoZXIgYWN0b3JcclxuICAgICAqL1xyXG4gICAgbWVldChlbnRpdHksIHNwZWVkKSB7XHJcbiAgICAgICAgaWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBNZWV0KHRoaXMuX2VudGl0eSwgZW50aXR5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IE1lZXQodGhpcy5fZW50aXR5LCBlbnRpdHksIHNwZWVkKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGN1cnJlbnQgYWN0aW9uIHF1ZXVlIHVwIHRvIG5vd1xyXG4gICAgICogaXMgZmluaXNoZWQuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYHRvUHJvbWlzZSgpYCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gICAgICovXHJcbiAgICBhc1Byb21pc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Qcm9taXNlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY3VycmVudCBhY3Rpb24gcXVldWUgdXAgdG8gbm93XHJcbiAgICAgKiBpcyBmaW5pc2hlZC5cclxuICAgICAqL1xyXG4gICAgdG9Qcm9taXNlKCkge1xyXG4gICAgICAgIGNvbnN0IHRlbXAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IENhbGxNZXRob2QoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRlbXA7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbnNDb21wb25lbnQudHNcblxyXG5cclxuXHJcblxyXG47XHJcbmNsYXNzIEFjdGlvbnNDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZXguYWN0aW9ucyc7XHJcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbVHJhbnNmb3JtQ29tcG9uZW50LCBNb3Rpb25Db21wb25lbnRdO1xyXG4gICAgfVxyXG4gICAgb25BZGQoZW50aXR5KSB7XHJcbiAgICAgICAgdGhpcy5fY3R4ID0gbmV3IEFjdGlvbkNvbnRleHQoZW50aXR5KTtcclxuICAgIH1cclxuICAgIG9uUmVtb3ZlKCkge1xyXG4gICAgICAgIHRoaXMuX2N0eCA9IG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGludGVybmFsIGFjdGlvbiBxdWV1ZVxyXG4gICAgICogQHJldHVybnMgYWN0aW9uIHF1ZXVcclxuICAgICAqL1xyXG4gICAgZ2V0UXVldWUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9jdHgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRRdWV1ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBhY3Rpb24gY29udGV4dCwgcGVyZm9ybWluZyBhY3Rpb24gYW5kIG1vdmluZyB0aHJvdWdoIHRoZSBpbnRlcm5hbCBxdWV1ZVxyXG4gICAgICogQHBhcmFtIGVsYXBzZWRNc1xyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZWxhcHNlZE1zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9jdHgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGUoZWxhcHNlZE1zKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGFsbCBxdWV1ZWQgYWN0aW9ucyBmcm9tIHRoZSBBY3RvclxyXG4gICAgICovXHJcbiAgICBjbGVhckFjdGlvbnMoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMuX2N0eCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsZWFyQWN0aW9ucygpO1xyXG4gICAgfVxyXG4gICAgZWFzZVRvKC4uLmFyZ3MpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LmVhc2VUby5hcHBseSh0aGlzLl9jdHgsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgbW92ZVRvKHhPclBvcywgeU9yU3BlZWQsIHNwZWVkT3JVbmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4Lm1vdmVUby5hcHBseSh0aGlzLl9jdHgsIFt4T3JQb3MsIHlPclNwZWVkLCBzcGVlZE9yVW5kZWZpbmVkXSk7XHJcbiAgICB9XHJcbiAgICBtb3ZlQnkoeE9mZnNldE9yVmVjdG9yLCB5T2Zmc2V0T3JTcGVlZCwgc3BlZWRPclVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgubW92ZUJ5LmFwcGx5KHRoaXMuX2N0eCwgW3hPZmZzZXRPclZlY3RvciwgeU9mZnNldE9yU3BlZWQsIHNwZWVkT3JVbmRlZmluZWRdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCByb3RhdGUgYW4gYWN0b3IgdG8gdGhlIHNwZWNpZmllZCBhbmdsZSBhdCB0aGUgc3BlZWRcclxuICAgICAqIHNwZWNpZmllZCAoaW4gcmFkaWFucyBwZXIgc2Vjb25kKSBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzXHJcbiAgICAgKiBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zICBUaGUgYW5nbGUgdG8gcm90YXRlIHRvIGluIHJhZGlhbnNcclxuICAgICAqIEBwYXJhbSBzcGVlZCAgICAgICAgIFRoZSBhbmd1bGFyIHZlbG9jaXR5IG9mIHRoZSByb3RhdGlvbiBzcGVjaWZpZWQgaW4gcmFkaWFucyBwZXIgc2Vjb25kXHJcbiAgICAgKiBAcGFyYW0gcm90YXRpb25UeXBlICBUaGUgW1tSb3RhdGlvblR5cGVdXSB0byB1c2UgZm9yIHRoaXMgcm90YXRpb25cclxuICAgICAqL1xyXG4gICAgcm90YXRlVG8oYW5nbGVSYWRpYW5zLCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC5yb3RhdGVUbyhhbmdsZVJhZGlhbnMsIHNwZWVkLCByb3RhdGlvblR5cGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciBieSB0aGUgc3BlY2lmaWVkIGFuZ2xlIG9mZnNldCwgZnJvbSBpdCdzIGN1cnJlbnQgcm90YXRpb24gZ2l2ZW4gYSBjZXJ0YWluIHNwZWVkXHJcbiAgICAgKiBpbiByYWRpYW5zL3NlYyBhbmQgcmV0dXJuIGJhY2sgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBwYXJ0XHJcbiAgICAgKiBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zT2Zmc2V0ICBUaGUgYW5nbGUgdG8gcm90YXRlIHRvIGluIHJhZGlhbnMgcmVsYXRpdmUgdG8gdGhlIGN1cnJlbnQgcm90YXRpb25cclxuICAgICAqIEBwYXJhbSBzcGVlZCAgICAgICAgICBUaGUgc3BlZWQgaW4gcmFkaWFucy9zZWMgdGhlIGFjdG9yIHNob3VsZCByb3RhdGUgYXRcclxuICAgICAqIEBwYXJhbSByb3RhdGlvblR5cGUgIFRoZSBbW1JvdGF0aW9uVHlwZV1dIHRvIHVzZSBmb3IgdGhpcyByb3RhdGlvbiwgZGVmYXVsdCBpcyBzaG9ydGVzdCBwYXRoXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZUJ5KGFuZ2xlUmFkaWFuc09mZnNldCwgc3BlZWQsIHJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgucm90YXRlQnkoYW5nbGVSYWRpYW5zT2Zmc2V0LCBzcGVlZCwgcm90YXRpb25UeXBlKTtcclxuICAgIH1cclxuICAgIHNjYWxlVG8oc2l6ZVhPclZlY3Rvciwgc2l6ZVlPclNwZWVkLCBzcGVlZFhPclVuZGVmaW5lZCwgc3BlZWRZT3JVbmRlZmluZWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LnNjYWxlVG8uYXBwbHkodGhpcy5fY3R4LCBbc2l6ZVhPclZlY3Rvciwgc2l6ZVlPclNwZWVkLCBzcGVlZFhPclVuZGVmaW5lZCwgc3BlZWRZT3JVbmRlZmluZWRdKTtcclxuICAgIH1cclxuICAgIHNjYWxlQnkoc2l6ZU9mZnNldFhPclZlY3Rvciwgc2l6ZU9mZnNldFlPclNwZWVkLCBzcGVlZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguc2NhbGVCeS5hcHBseSh0aGlzLl9jdHgsIFtzaXplT2Zmc2V0WE9yVmVjdG9yLCBzaXplT2Zmc2V0WU9yU3BlZWQsIHNwZWVkXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgYW4gYWN0b3IgdG8gYmxpbmsgKGJlY29tZSB2aXNpYmxlIGFuZCBub3RcclxuICAgICAqIHZpc2libGUpLiBPcHRpb25hbGx5LCB5b3UgbWF5IHNwZWNpZnkgdGhlIG51bWJlciBvZiBibGlua3MuIFNwZWNpZnkgdGhlIGFtb3VudCBvZiB0aW1lXHJcbiAgICAgKiB0aGUgYWN0b3Igc2hvdWxkIGJlIHZpc2libGUgcGVyIGJsaW5rLCBhbmQgdGhlIGFtb3VudCBvZiB0aW1lIG5vdCB2aXNpYmxlLlxyXG4gICAgICogVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gdGltZVZpc2libGUgICAgIFRoZSBhbW91bnQgb2YgdGltZSB0byBzdGF5IHZpc2libGUgcGVyIGJsaW5rIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICogQHBhcmFtIHRpbWVOb3RWaXNpYmxlICBUaGUgYW1vdW50IG9mIHRpbWUgdG8gc3RheSBub3QgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKiBAcGFyYW0gbnVtQmxpbmtzICAgICAgIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gYmxpbmtcclxuICAgICAqL1xyXG4gICAgYmxpbmsodGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LmJsaW5rKHRpbWVWaXNpYmxlLCB0aW1lTm90VmlzaWJsZSwgbnVtQmxpbmtzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSBhbiBhY3RvcidzIG9wYWNpdHkgdG8gY2hhbmdlIGZyb20gaXRzIGN1cnJlbnQgdmFsdWVcclxuICAgICAqIHRvIHRoZSBwcm92aWRlZCB2YWx1ZSBieSBhIHNwZWNpZmllZCB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpc1xyXG4gICAgICogcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gb3BhY2l0eSAgVGhlIGVuZGluZyBvcGFjaXR5XHJcbiAgICAgKiBAcGFyYW0gdGltZSAgICAgVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gZmFkZSB0aGUgYWN0b3IgKGluIG1pbGxpc2Vjb25kcylcclxuICAgICAqL1xyXG4gICAgZmFkZShvcGFjaXR5LCB0aW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC5mYWRlKG9wYWNpdHksIHRpbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGRlbGF5IHRoZSBuZXh0IGFjdGlvbiBmcm9tIGV4ZWN1dGluZyBmb3IgYSBjZXJ0YWluXHJcbiAgICAgKiBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKS4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3JcclxuICAgICAqICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICogQHBhcmFtIHRpbWUgIFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSB0aGUgbmV4dCBhY3Rpb24gaW4gdGhlIHF1ZXVlIGZyb20gZXhlY3V0aW5nIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICovXHJcbiAgICBkZWxheSh0aW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC5kZWxheSh0aW1lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBhZGQgYW4gYWN0aW9uIHRvIHRoZSBxdWV1ZSB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhY3RvciBmcm9tIHRoZVxyXG4gICAgICogc2NlbmUgb25jZSBpdCBoYXMgY29tcGxldGVkIGl0cyBwcmV2aW91cyAgQW55IGFjdGlvbnMgb24gdGhlXHJcbiAgICAgKiBhY3Rpb24gcXVldWUgYWZ0ZXIgdGhpcyBhY3Rpb24gd2lsbCBub3QgYmUgZXhlY3V0ZWQuXHJcbiAgICAgKi9cclxuICAgIGRpZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LmRpZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBhbGxvd3MgeW91IHRvIGNhbGwgYW4gYXJiaXRyYXJ5IG1ldGhvZCBhcyB0aGUgbmV4dCBhY3Rpb24gaW4gdGhlXHJcbiAgICAgKiBhY3Rpb24gcXVldWUuIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIGV4ZWN1dGUgY29kZSBpbiBhZnRlciBhIHNwZWNpZmljXHJcbiAgICAgKiBhY3Rpb24sIGkuZSBBbiBhY3RvciBhcnJpdmVzIGF0IGEgZGVzdGluYXRpb24gYWZ0ZXIgdHJhdmVyc2luZyBhIHBhdGhcclxuICAgICAqL1xyXG4gICAgY2FsbE1ldGhvZChtZXRob2QpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LmNhbGxNZXRob2QobWV0aG9kKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gcmVwZWF0IGFsbCBvZiB0aGUgYWN0aW9ucyBidWlsdCBpblxyXG4gICAgICogdGhlIGByZXBlYXRCdWlsZGVyYCBjYWxsYmFjay4gSWYgdGhlIG51bWJlciBvZiByZXBlYXRzXHJcbiAgICAgKiBpcyBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgcmVwZWF0IGZvcmV2ZXIuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2ZcclxuICAgICAqIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZ1xyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIC8vIE1vdmUgdXAgaW4gYSB6aWctemFnIGJ5IHJlcGVhdGVkIG1vdmVCeSdzXHJcbiAgICAgKiBhY3Rvci5hY3Rpb25zLnJlcGVhdChyZXBlYXRDdHggPT4ge1xyXG4gICAgICogIHJlcGVhdEN0eC5tb3ZlQnkoMTAsIDAsIDEwKTtcclxuICAgICAqICByZXBlYXRDdHgubW92ZUJ5KDAsIDEwLCAxMCk7XHJcbiAgICAgKiB9LCA1KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXBlYXRCdWlsZGVyIFRoZSBidWlsZGVyIHRvIHNwZWNpZnkgdGhlIHJlcGVhdGFibGUgbGlzdCBvZiBhY3Rpb25zXHJcbiAgICAgKiBAcGFyYW0gdGltZXMgIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGFsbCB0aGUgcHJldmlvdXMgYWN0aW9ucyBpbiB0aGUgYWN0aW9uIHF1ZXVlLiBJZiBub3RoaW5nIGlzIHNwZWNpZmllZCB0aGUgYWN0aW9uc1xyXG4gICAgICogd2lsbCByZXBlYXQgZm9yZXZlclxyXG4gICAgICovXHJcbiAgICByZXBlYXQocmVwZWF0QnVpbGRlciwgdGltZXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LnJlcGVhdChyZXBlYXRCdWlsZGVyLCB0aW1lcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGFjdG9yIHRvIHJlcGVhdCBhbGwgb2YgdGhlIGFjdGlvbnMgYnVpbHQgaW5cclxuICAgICAqIHRoZSBgcmVwZWF0QnVpbGRlcmAgY2FsbGJhY2suIElmIHRoZSBudW1iZXIgb2YgcmVwZWF0c1xyXG4gICAgICogaXMgbm90IHNwZWNpZmllZCBpdCB3aWxsIHJlcGVhdCBmb3JldmVyLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mXHJcbiAgICAgKiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmdcclxuICAgICAqXHJcbiAgICAgKiBgYGB0eXBlc2NyaXB0XHJcbiAgICAgKiAvLyBNb3ZlIHVwIGluIGEgemlnLXphZyBieSByZXBlYXRlZCBtb3ZlQnknc1xyXG4gICAgICogYWN0b3IuYWN0aW9ucy5yZXBlYXQocmVwZWF0Q3R4ID0+IHtcclxuICAgICAqICByZXBlYXRDdHgubW92ZUJ5KDEwLCAwLCAxMCk7XHJcbiAgICAgKiAgcmVwZWF0Q3R4Lm1vdmVCeSgwLCAxMCwgMTApO1xyXG4gICAgICogfSwgNSk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcmVwZWF0QnVpbGRlciBUaGUgYnVpbGRlciB0byBzcGVjaWZ5IHRoZSByZXBlYXRhYmxlIGxpc3Qgb2YgYWN0aW9uc1xyXG4gICAgICovXHJcbiAgICByZXBlYXRGb3JldmVyKHJlcGVhdEJ1aWxkZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LnJlcGVhdEZvcmV2ZXIocmVwZWF0QnVpbGRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGVudGl0eSB0byBmb2xsb3cgYW5vdGhlciBhdCBhIHNwZWNpZmllZCBkaXN0YW5jZVxyXG4gICAgICogQHBhcmFtIGVudGl0eSAgICAgICAgICAgVGhlIGVudGl0eSB0byBmb2xsb3dcclxuICAgICAqIEBwYXJhbSBmb2xsb3dEaXN0YW5jZSAgVGhlIGRpc3RhbmNlIHRvIG1haW50YWluIHdoZW4gZm9sbG93aW5nLCBpZiBub3Qgc3BlY2lmaWVkIHRoZSBhY3RvciB3aWxsIGZvbGxvdyBhdCB0aGUgY3VycmVudCBkaXN0YW5jZS5cclxuICAgICAqL1xyXG4gICAgZm9sbG93KGVudGl0eSwgZm9sbG93RGlzdGFuY2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LmZvbGxvdyhlbnRpdHksIGZvbGxvd0Rpc3RhbmNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgZW50aXR5IHRvIG1vdmUgdG93YXJkcyBhbm90aGVyIHVudGlsIHRoZXlcclxuICAgICAqIGNvbGxpZGUgXCJtZWV0XCIgYXQgYSBzcGVjaWZpZWQgc3BlZWQuXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5ICBUaGUgZW50aXR5IHRvIG1lZXRcclxuICAgICAqIEBwYXJhbSBzcGVlZCAgVGhlIHNwZWVkIGluIHBpeGVscyBwZXIgc2Vjb25kIHRvIG1vdmUsIGlmIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCBtYXRjaCB0aGUgc3BlZWQgb2YgdGhlIG90aGVyIGFjdG9yXHJcbiAgICAgKi9cclxuICAgIG1lZXQoZW50aXR5LCBzcGVlZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgubWVldChlbnRpdHksIHNwZWVkKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjdXJyZW50IGFjdGlvbiBxdWV1ZSB1cCB0byBub3dcclxuICAgICAqIGlzIGZpbmlzaGVkLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGB0b1Byb21pc2UoKWAgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICAgICAqL1xyXG4gICAgYXNQcm9taXNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvUHJvbWlzZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGN1cnJlbnQgYWN0aW9uIHF1ZXVlIHVwIHRvIG5vd1xyXG4gICAgICogaXMgZmluaXNoZWQuXHJcbiAgICAgKi9cclxuICAgIHRvUHJvbWlzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LnRvUHJvbWlzZSgpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0b3IudHNcbnZhciBBY3Rvcl9kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIGZvciBjaGVja2luZyBpZiBzb21ldGhpbmcgaXMgYW4gQWN0b3JcclxuICogQHBhcmFtIHhcclxuICovXHJcbmZ1bmN0aW9uIGlzQWN0b3IoeCkge1xyXG4gICAgcmV0dXJuIHggaW5zdGFuY2VvZiBBY3RvcjtcclxufVxyXG4vKipcclxuICogVGhlIG1vc3QgaW1wb3J0YW50IHByaW1pdGl2ZSBpbiBFeGNhbGlidXIgaXMgYW4gYEFjdG9yYC4gQW55dGhpbmcgdGhhdFxyXG4gKiBjYW4gbW92ZSBvbiB0aGUgc2NyZWVuLCBjb2xsaWRlIHdpdGggYW5vdGhlciBgQWN0b3JgLCByZXNwb25kIHRvIGV2ZW50cyxcclxuICogb3IgaW50ZXJhY3Qgd2l0aCB0aGUgY3VycmVudCBzY2VuZSwgbXVzdCBiZSBhbiBhY3Rvci4gQW4gYEFjdG9yYCAqKm11c3QqKlxyXG4gKiBiZSBwYXJ0IG9mIGEgW1tTY2VuZV1dIGZvciBpdCB0byBiZSBkcmF3biB0byB0aGUgc2NyZWVuLlxyXG4gKi9cclxuY2xhc3MgQWN0b3IgZXh0ZW5kcyBFbnRpdHkge1xyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZ1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbmNob3IgdG8gYXBwbHkgYWxsIGFjdG9yIHJlbGF0ZWQgdHJhbnNmb3JtYXRpb25zIGxpa2Ugcm90YXRpb24sXHJcbiAgICAgICAgICogdHJhbnNsYXRpb24sIGFuZCBzY2FsaW5nLiBCeSBkZWZhdWx0IHRoZSBhbmNob3IgaXMgaW4gdGhlIGNlbnRlciBvZlxyXG4gICAgICAgICAqIHRoZSBhY3Rvci4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdGhlIGNlbnRlciBvZiB0aGUgYWN0b3IgKC41LCAuNSlcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEFuIGFuY2hvciBvZiAoLjUsIC41KSB3aWxsIGVuc3VyZSB0aGF0IGRyYXdpbmdzIGFyZSBjZW50ZXJlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFVzZSBgYW5jaG9yLnNldFRvYCB0byBzZXQgdGhlIGFuY2hvciB0byBhIGRpZmZlcmVudCBwb2ludCB1c2luZ1xyXG4gICAgICAgICAqIHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDEuIEZvciBleGFtcGxlLCBhbmNob3JpbmcgdG8gdGhlIHRvcC1sZWZ0IHdvdWxkIGJlXHJcbiAgICAgICAgICogYEFjdG9yLmFuY2hvci5zZXRUbygwLCAwKWAgYW5kIHRvcC1yaWdodCB3b3VsZCBiZSBgQWN0b3IuYW5jaG9yLnNldFRvKDAsIDEpYC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9hbmNob3IgPSB3YXRjaChWZWN0b3IuSGFsZiwgKHYpID0+IHRoaXMuX2hhbmRsZUFuY2hvckNoYW5nZSh2KSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udmVuaWVuY2UgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgbG9nZ2VyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc2NlbmUgdGhhdCB0aGUgYWN0b3IgaXMgaW5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjZW5lID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFjY2VzcyB0byB0aGUgY3VycmVudCBkcmF3aW5nIGZvciB0aGUgYWN0b3IsIHRoaXMgY2FuIGJlXHJcbiAgICAgICAgICogYW4gW1tBbmltYXRpb25dXSwgW1tTcHJpdGVdXSwgb3IgW1tQb2x5Z29uXV0uXHJcbiAgICAgICAgICogU2V0IGRyYXdpbmdzIHdpdGggW1tzZXREcmF3aW5nXV0uXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmFnZ2FibGUgaGVscGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fZHJhZ2dhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wb2ludGVyRHJhZ1N0YXJ0SGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fZHJhZ2dpbmcgPSB0cnVlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlckRyYWdFbmRIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlckRyYWdNb3ZlSGFuZGxlciA9IChwZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gcGUucG9pbnRlci5sYXN0V29ybGRQb3M7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJEcmFnTGVhdmVIYW5kbGVyID0gKHBlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBwZS5wb2ludGVyLmxhc3RXb3JsZFBvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTW9kaWZ5IHRoZSBjdXJyZW50IGFjdG9yIHVwZGF0ZSBwaXBlbGluZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRyYWl0cyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIGVuYWJsZSB0aGUgW1tUcmFpdHMuQ2FwdHVyZVBvaW50ZXJdXSB0cmFpdCB0aGF0IHByb3BhZ2F0ZXNcclxuICAgICAgICAgKiBwb2ludGVyIGV2ZW50cyB0byB0aGlzIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmFibGVDYXB0dXJlUG9pbnRlciA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENvbmZpZ3VyYXRpb24gZm9yIFtbVHJhaXRzLkNhcHR1cmVQb2ludGVyXV0gdHJhaXRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhcHR1cmVQb2ludGVyID0ge1xyXG4gICAgICAgICAgICBjYXB0dXJlTW92ZUV2ZW50czogZmFsc2UsXHJcbiAgICAgICAgICAgIGNhcHR1cmVEcmFnRXZlbnRzOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gI3JlZ2lvbiBFdmVudHNcclxuICAgICAgICB0aGlzLl9jYXB0dXJlUG9pbnRlckV2ZW50cyA9IFtcclxuICAgICAgICAgICAgJ3BvaW50ZXJ1cCcsXHJcbiAgICAgICAgICAgICdwb2ludGVyZG93bicsXHJcbiAgICAgICAgICAgICdwb2ludGVybW92ZScsXHJcbiAgICAgICAgICAgICdwb2ludGVyZW50ZXInLFxyXG4gICAgICAgICAgICAncG9pbnRlcmxlYXZlJyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJkcmFnc3RhcnQnLFxyXG4gICAgICAgICAgICAncG9pbnRlcmRyYWdlbmQnLFxyXG4gICAgICAgICAgICAncG9pbnRlcmRyYWdtb3ZlJyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJkcmFnZW50ZXInLFxyXG4gICAgICAgICAgICAncG9pbnRlcmRyYWdsZWF2ZSdcclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuX2NhcHR1cmVNb3ZlRXZlbnRzID0gW1xyXG4gICAgICAgICAgICAncG9pbnRlcm1vdmUnLFxyXG4gICAgICAgICAgICAncG9pbnRlcmVudGVyJyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJsZWF2ZScsXHJcbiAgICAgICAgICAgICdwb2ludGVyZHJhZ21vdmUnLFxyXG4gICAgICAgICAgICAncG9pbnRlcmRyYWdlbnRlcicsXHJcbiAgICAgICAgICAgICdwb2ludGVyZHJhZ2xlYXZlJ1xyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fY2FwdHVyZURyYWdFdmVudHMgPSBbXHJcbiAgICAgICAgICAgICdwb2ludGVyZHJhZ3N0YXJ0JyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJkcmFnZW5kJyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJkcmFnbW92ZScsXHJcbiAgICAgICAgICAgICdwb2ludGVyZHJhZ2VudGVyJyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJkcmFnbGVhdmUnXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCB7IG5hbWUsIHgsIHksIHBvcywgc2NhbGUsIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgY29sbGlkZXIsIHZlbCwgYWNjLCByb3RhdGlvbiwgYW5ndWxhclZlbG9jaXR5LCB6LCBjb2xvciwgdmlzaWJsZSwgYW5jaG9yLCBjb2xsaXNpb25UeXBlLCBjb2xsaXNpb25Hcm91cCB9ID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcclxuICAgICAgICB0aGlzLl9zZXROYW1lKG5hbWUpO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yICE9PSBudWxsICYmIGFuY2hvciAhPT0gdm9pZCAwID8gYW5jaG9yIDogQWN0b3IuZGVmYXVsdHMuYW5jaG9yLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpKTtcclxuICAgICAgICB0aGlzLnBvcyA9IHBvcyAhPT0gbnVsbCAmJiBwb3MgIT09IHZvaWQgMCA/IHBvcyA6IHZlYyh4ICE9PSBudWxsICYmIHggIT09IHZvaWQgMCA/IHggOiAwLCB5ICE9PSBudWxsICYmIHkgIT09IHZvaWQgMCA/IHkgOiAwKTtcclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb24gIT09IG51bGwgJiYgcm90YXRpb24gIT09IHZvaWQgMCA/IHJvdGF0aW9uIDogMDtcclxuICAgICAgICB0aGlzLnNjYWxlID0gc2NhbGUgIT09IG51bGwgJiYgc2NhbGUgIT09IHZvaWQgMCA/IHNjYWxlIDogdmVjKDEsIDEpO1xyXG4gICAgICAgIHRoaXMueiA9IHogIT09IG51bGwgJiYgeiAhPT0gdm9pZCAwID8geiA6IDA7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IEdyYXBoaWNzQ29tcG9uZW50KCkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBDYW52YXNEcmF3Q29tcG9uZW50KChjdHgsIGRlbHRhKSA9PiB0aGlzLmRyYXcoY3R4LCBkZWx0YSkpKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgTW90aW9uQ29tcG9uZW50KCkpO1xyXG4gICAgICAgIHRoaXMudmVsID0gdmVsICE9PSBudWxsICYmIHZlbCAhPT0gdm9pZCAwID8gdmVsIDogVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5hY2MgPSBhY2MgIT09IG51bGwgJiYgYWNjICE9PSB2b2lkIDAgPyBhY2MgOiBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IGFuZ3VsYXJWZWxvY2l0eSAhPT0gbnVsbCAmJiBhbmd1bGFyVmVsb2NpdHkgIT09IHZvaWQgMCA/IGFuZ3VsYXJWZWxvY2l0eSA6IDA7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IEFjdGlvbnNDb21wb25lbnQoKSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IEJvZHlDb21wb25lbnQoKSk7XHJcbiAgICAgICAgdGhpcy5ib2R5LmNvbGxpc2lvblR5cGUgPSBjb2xsaXNpb25UeXBlICE9PSBudWxsICYmIGNvbGxpc2lvblR5cGUgIT09IHZvaWQgMCA/IGNvbGxpc2lvblR5cGUgOiBDb2xsaXNpb25UeXBlLlBhc3NpdmU7XHJcbiAgICAgICAgaWYgKGNvbGxpc2lvbkdyb3VwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYm9keS5ncm91cCA9IGNvbGxpc2lvbkdyb3VwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IENvbGxpZGVyQ29tcG9uZW50KGNvbGxpZGVyKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHJhZGl1cykge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgQ29sbGlkZXJDb21wb25lbnQoU2hhcGUuQ2lyY2xlKHJhZGl1cywgdGhpcy5hbmNob3IpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAod2lkdGggPiAwICYmIGhlaWdodCA+IDApIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBDb2xsaWRlckNvbXBvbmVudChTaGFwZS5Cb3god2lkdGgsIGhlaWdodCwgdGhpcy5hbmNob3IpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgQ29sbGlkZXJDb21wb25lbnQoKSk7IC8vIG5vIGNvbGxpZGVyXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ncmFwaGljcy52aXNpYmxlID0gdmlzaWJsZSAhPT0gbnVsbCAmJiB2aXNpYmxlICE9PSB2b2lkIDAgPyB2aXNpYmxlIDogdHJ1ZTtcclxuICAgICAgICBpZiAoY29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgICAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmFkZChuZXcgUmVjdGFuZ2xlKHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAocmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmFkZChuZXcgQ2lyY2xlKHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IsXHJcbiAgICAgICAgICAgICAgICAgICAgcmFkaXVzXHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQnVpbGQgZGVmYXVsdCBwaXBlbGluZVxyXG4gICAgICAgIGlmIChGbGFncy5pc0VuYWJsZWQoTGVnYWN5LkxlZ2FjeURyYXdpbmcpKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIG9mZnNjcmVlbiB0cmFpdCBhZnRlciBsZWdhY3kgZHJhd2luZyByZW1vdmVkXHJcbiAgICAgICAgICAgIHRoaXMudHJhaXRzLnB1c2gobmV3IE9mZnNjcmVlbkN1bGxpbmcoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudHJhaXRzLnB1c2gobmV3IENhcHR1cmVQb2ludGVyKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGh5c2ljcyBib2R5IHRoZSBpcyBhc3NvY2lhdGVkIHdpdGggdGhpcyBhY3Rvci4gVGhlIGJvZHkgaXMgdGhlIGNvbnRhaW5lciBmb3IgYWxsIHBoeXNpY2FsIHByb3BlcnRpZXMsIGxpa2UgcG9zaXRpb24sIHZlbG9jaXR5LFxyXG4gICAgICogYWNjZWxlcmF0aW9uLCBtYXNzLCBpbmVydGlhLCBldGMuXHJcbiAgICAgKi9cclxuICAgIGdldCBib2R5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWNjZXNzIHRoZSBBY3RvcidzIGJ1aWx0IGluIFtbVHJhbnNmb3JtQ29tcG9uZW50XV1cclxuICAgICAqL1xyXG4gICAgZ2V0IHRyYW5zZm9ybSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWNjZXNzIHRoZSBBY3RvcidzIGJ1aWx0IGluIFtbTW90aW9uQ29tcG9uZW50XV1cclxuICAgICAqL1xyXG4gICAgZ2V0IG1vdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWNjZXNzIHRvIHRoZSBBY3RvcidzIGJ1aWx0IGluIFtbR3JhcGhpY3NDb21wb25lbnRdXVxyXG4gICAgICovXHJcbiAgICBnZXQgZ3JhcGhpY3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KEdyYXBoaWNzQ29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWNjZXNzIHRvIHRoZSBBY3RvcidzIGJ1aWx0IGluIFtbQ29sbGlkZXJDb21wb25lbnRdXVxyXG4gICAgICovXHJcbiAgICBnZXQgY29sbGlkZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KENvbGxpZGVyQ29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlZnVsIGZvciBxdWlja2x5IHNjcmlwdGluZyBhY3RvciBiZWhhdmlvciwgbGlrZSBtb3ZpbmcgdG8gYSBwbGFjZSwgcGF0cm9saW5nIGJhY2sgYW5kIGZvcnRoLCBibGlua2luZywgZXRjLlxyXG4gICAgICpcclxuICAgICAqICBBY2Nlc3MgdG8gdGhlIEFjdG9yJ3MgYnVpbHQgaW4gW1tBY3Rpb25zQ29tcG9uZW50XV0gd2hpY2ggZm9yd2FyZHMgdG8gdGhlXHJcbiAgICAgKiBbW0FjdGlvbkNvbnRleHR8QWN0aW9uIGNvbnRleHRdXSBvZiB0aGUgYWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGdldCBhY3Rpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChBY3Rpb25zQ29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcG9zaXRpb24gdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHNcclxuICAgICAqL1xyXG4gICAgZ2V0IHBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucG9zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBzZXQgcG9zKHRoZVBvcykge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnBvcyA9IHRoZVBvcy5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb3NpdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWVcclxuICAgICAqL1xyXG4gICAgZ2V0IG9sZFBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib2R5Lm9sZFBvcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcG9zaXRpb24gdmVjdG9yIG9mIHRoZSBhY3RvciBpbiB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBzZXQgb2xkUG9zKHRoZVBvcykge1xyXG4gICAgICAgIHRoaXMuYm9keS5vbGRQb3Muc2V0VG8odGhlUG9zLngsIHRoZVBvcy55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdmVsb2NpdHkgdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2VjXHJcbiAgICAgKi9cclxuICAgIGdldCB2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLnZlbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdmVsb2NpdHkgdmVjdG9yIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2VjXHJcbiAgICAgKi9cclxuICAgIHNldCB2ZWwodGhlVmVsKSB7XHJcbiAgICAgICAgdGhpcy5tb3Rpb24udmVsID0gdGhlVmVsLmNsb25lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHZlbG9jaXR5IHZlY3RvciBvZiB0aGUgYWN0b3IgZnJvbSB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBnZXQgb2xkVmVsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvZHkub2xkVmVsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWVcclxuICAgICAqL1xyXG4gICAgc2V0IG9sZFZlbCh0aGVWZWwpIHtcclxuICAgICAgICB0aGlzLmJvZHkub2xkVmVsLnNldFRvKHRoZVZlbC54LCB0aGVWZWwueSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGFjY2VsZXJhdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNvbmQvc2Vjb25kLiBBbiBhY2NlbGVyYXRpb24gcG9pbnRpbmcgZG93biBzdWNoIGFzICgwLCAxMDApIG1heSBiZVxyXG4gICAgICogdXNlZnVsIHRvIHNpbXVsYXRlIGEgZ3Jhdml0YXRpb25hbCBlZmZlY3QuXHJcbiAgICAgKi9cclxuICAgIGdldCBhY2MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLmFjYztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYWNjZWxlcmF0aW9uIHZlY3RvciBvZiB0ZWggYWN0b3IgaW4gcGl4ZWxzL3NlY29uZC9zZWNvbmRcclxuICAgICAqL1xyXG4gICAgc2V0IGFjYyh0aGVBY2MpIHtcclxuICAgICAgICB0aGlzLm1vdGlvbi5hY2MgPSB0aGVBY2MuY2xvbmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgYWNjZWxlcmF0aW9uIG9mIHRoZSBhY3RvciBmcm9tIHRoZSBsYXN0IGZyYW1lLiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGdsb2JhbCBhY2MgW1tQaHlzaWNzLmFjY11dLlxyXG4gICAgICovXHJcbiAgICBzZXQgb2xkQWNjKHRoZUFjYykge1xyXG4gICAgICAgIHRoaXMuYm9keS5vbGRBY2Muc2V0VG8odGhlQWNjLngsIHRoZUFjYy55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYWNjZWxlcmF0aW9uIG9mIHRoZSBhY3RvciBmcm9tIHRoZSBsYXN0IGZyYW1lLiBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGdsb2JhbCBhY2MgW1tQaHlzaWNzLmFjY11dLlxyXG4gICAgICovXHJcbiAgICBnZXQgb2xkQWNjKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvZHkub2xkQWNjO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSByb3RhdGlvbiBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy4gMSByYWRpYW4gPSAxODAvUEkgRGVncmVlcy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcm90YXRpb24gb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMuIDEgcmFkaWFuID0gMTgwL1BJIERlZ3JlZXMuXHJcbiAgICAgKi9cclxuICAgIHNldCByb3RhdGlvbih0aGVBbmdsZSkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uID0gdGhlQW5nbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHJvdGF0aW9uYWwgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHJhZGlhbnMvc2Vjb25kXHJcbiAgICAgKi9cclxuICAgIGdldCBhbmd1bGFyVmVsb2NpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLmFuZ3VsYXJWZWxvY2l0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy9zZWNcclxuICAgICAqL1xyXG4gICAgc2V0IGFuZ3VsYXJWZWxvY2l0eShhbmd1bGFyVmVsb2NpdHkpIHtcclxuICAgICAgICB0aGlzLm1vdGlvbi5hbmd1bGFyVmVsb2NpdHkgPSBhbmd1bGFyVmVsb2NpdHk7XHJcbiAgICB9XHJcbiAgICBnZXQgc2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkuc2NhbGU7XHJcbiAgICB9XHJcbiAgICBzZXQgc2NhbGUoc2NhbGUpIHtcclxuICAgICAgICB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLnNjYWxlID0gc2NhbGU7XHJcbiAgICB9XHJcbiAgICBnZXQgYW5jaG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hbmNob3I7XHJcbiAgICB9XHJcbiAgICBzZXQgYW5jaG9yKHZlYykge1xyXG4gICAgICAgIHRoaXMuX2FuY2hvciA9IHdhdGNoKHZlYywgKHYpID0+IHRoaXMuX2hhbmRsZUFuY2hvckNoYW5nZSh2KSk7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlQW5jaG9yQ2hhbmdlKHZlYyk7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlQW5jaG9yQ2hhbmdlKHYpIHtcclxuICAgICAgICBpZiAodGhpcy5ncmFwaGljcykge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmFuY2hvciA9IHY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYWN0b3IgaXMgcGh5c2ljYWxseSBpbiB0aGUgdmlld3BvcnRcclxuICAgICAqL1xyXG4gICAgZ2V0IGlzT2ZmU2NyZWVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmhhc1RhZygnb2Zmc2NyZWVuJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB2aXNpYmlsaXR5IG9mIGFuIGFjdG9yXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tHcmFwaGljc0NvbXBvbmVudC52aXNpYmxlfEFjdG9yLmdyYXBoaWNzLnZpc2libGVdXSwgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICAgICAqL1xyXG4gICAgZ2V0IHZpc2libGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGhpY3MudmlzaWJsZTtcclxuICAgIH1cclxuICAgIHNldCB2aXNpYmxlKGlzVmlzaWJsZSkge1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MudmlzaWJsZSA9IGlzVmlzaWJsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9wYWNpdHkgb2YgYW4gYWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgQWN0b3Iub3BhY2l0eSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCwgdXNlIFtbR3JhcGhpY3NDb21wb25lbnQub3BhY2l0eXxBY3Rvci5ncmFwaGljcy5vcGFjaXR5XV0uXHJcbiAgICAgKi9cclxuICAgIGdldCBvcGFjaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdyYXBoaWNzLm9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICBzZXQgb3BhY2l0eShvcGFjaXR5KSB7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljcy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuICAgIH1cclxuICAgIGdldCBkcmFnZ2FibGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYWdnYWJsZTtcclxuICAgIH1cclxuICAgIHNldCBkcmFnZ2FibGUoaXNEcmFnZ2FibGUpIHtcclxuICAgICAgICBpZiAoaXNEcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgaWYgKGlzRHJhZ2dhYmxlICYmICF0aGlzLl9kcmFnZ2FibGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMub24oJ3BvaW50ZXJkcmFnc3RhcnQnLCB0aGlzLl9wb2ludGVyRHJhZ1N0YXJ0SGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdwb2ludGVyZHJhZ2VuZCcsIHRoaXMuX3BvaW50ZXJEcmFnRW5kSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uKCdwb2ludGVyZHJhZ21vdmUnLCB0aGlzLl9wb2ludGVyRHJhZ01vdmVIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub24oJ3BvaW50ZXJkcmFnbGVhdmUnLCB0aGlzLl9wb2ludGVyRHJhZ0xlYXZlSGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzRHJhZ2dhYmxlICYmIHRoaXMuX2RyYWdnYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ3BvaW50ZXJkcmFnc3RhcnQnLCB0aGlzLl9wb2ludGVyRHJhZ1N0YXJ0SGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZigncG9pbnRlcmRyYWdlbmQnLCB0aGlzLl9wb2ludGVyRHJhZ0VuZEhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ3BvaW50ZXJkcmFnbW92ZScsIHRoaXMuX3BvaW50ZXJEcmFnTW92ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ3BvaW50ZXJkcmFnbGVhdmUnLCB0aGlzLl9wb2ludGVyRHJhZ0xlYXZlSGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZHJhZ2dhYmxlID0gaXNEcmFnZ2FibGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjb2xvciBvZiB0aGUgYWN0b3IuIEEgcmVjdGFuZ2xlIG9mIHRoaXMgY29sb3Igd2lsbCBiZVxyXG4gICAgICogZHJhd24gaWYgbm8gW1tEcmF3YWJsZV1dIGlzIHNwZWNpZmllZCBhcyB0aGUgYWN0b3JzIGRyYXdpbmcuXHJcbiAgICAgKlxyXG4gICAgICogVGhlIGRlZmF1bHQgaXMgYG51bGxgIHdoaWNoIHByZXZlbnRzIGEgcmVjdGFuZ2xlIGZyb20gYmVpbmcgZHJhd24uXHJcbiAgICAgKi9cclxuICAgIGdldCBjb2xvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XHJcbiAgICB9XHJcbiAgICBzZXQgY29sb3Iodikge1xyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gdi5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBgb25Jbml0aWFsaXplYCBpcyBjYWxsZWQgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgb2YgdGhlIGFjdG9yLiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZVxyXG4gICAgICogb3ZlcnJpZGRlbi4gVGhpcyBpcyB3aGVyZSBpbml0aWFsaXphdGlvbiBvZiBjaGlsZCBhY3RvcnMgc2hvdWxkIHRha2UgcGxhY2UuXHJcbiAgICAgKlxyXG4gICAgICogU3lub255bW91cyB3aXRoIHRoZSBldmVudCBoYW5kbGVyIGAub24oJ2luaXRpYWxpemUnLCAoZXZ0KSA9PiB7Li4ufSlgXHJcbiAgICAgKi9cclxuICAgIG9uSW5pdGlhbGl6ZShfZW5naW5lKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhpcyBhY3RvciBhbmQgYWxsIGl0J3MgY2hpbGQgYWN0b3JzLCBtZWFudCB0byBiZSBjYWxsZWQgYnkgdGhlIFNjZW5lIGJlZm9yZSBmaXJzdCB1cGRhdGUgbm90IGJ5IHVzZXJzIG9mIEV4Y2FsaWJ1ci5cclxuICAgICAqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfaW5pdGlhbGl6ZShlbmdpbmUpIHtcclxuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5jaGlsZHJlbikge1xyXG4gICAgICAgICAgICBjaGlsZC5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jaGVja0ZvclBvaW50ZXJPcHRJbihldmVudE5hbWUpIHtcclxuICAgICAgICBpZiAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NhcHR1cmVQb2ludGVyRXZlbnRzLmluZGV4T2Yobm9ybWFsaXplZCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9jYXB0dXJlTW92ZUV2ZW50cy5pbmRleE9mKG5vcm1hbGl6ZWQpICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZU1vdmVFdmVudHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhcHR1cmVEcmFnRXZlbnRzLmluZGV4T2Yobm9ybWFsaXplZCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlUG9pbnRlci5jYXB0dXJlRHJhZ0V2ZW50cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9jaGVja0ZvclBvaW50ZXJPcHRJbihldmVudE5hbWUpO1xyXG4gICAgICAgIHN1cGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBvbmNlKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrRm9yUG9pbnRlck9wdEluKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgc3VwZXIub25jZShldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wcmVraWxsIGhhbmRsZXIgZm9yIFtbb25QcmVLaWxsXV0gbGlmZWN5Y2xlIGV2ZW50XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3ByZWtpbGwoX3NjZW5lKSB7XHJcbiAgICAgICAgc3VwZXIuZW1pdCgncHJla2lsbCcsIG5ldyBQcmVLaWxsRXZlbnQodGhpcykpO1xyXG4gICAgICAgIHRoaXMub25QcmVLaWxsKF9zY2VuZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25QcmVLaWxsIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncHJla2lsbCcsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblByZUtpbGxgIGlzIGNhbGxlZCBkaXJlY3RseSBiZWZvcmUgYW4gYWN0b3IgaXMga2lsbGVkIGFuZCByZW1vdmVkIGZyb20gaXRzIGN1cnJlbnQgW1tTY2VuZV1dLlxyXG4gICAgICovXHJcbiAgICBvblByZUtpbGwoX3NjZW5lKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJla2lsbCBoYW5kbGVyIGZvciBbW29uUG9zdEtpbGxdXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcG9zdGtpbGwoX3NjZW5lKSB7XHJcbiAgICAgICAgc3VwZXIuZW1pdCgncG9zdGtpbGwnLCBuZXcgUG9zdEtpbGxFdmVudCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblBvc3RLaWxsKF9zY2VuZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25Qb3N0S2lsbCBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3Bvc3RraWxsJywgKGV2dCkgPT4gey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblBvc3RLaWxsYCBpcyBjYWxsZWQgZGlyZWN0bHkgYWZ0ZXIgYW4gYWN0b3IgaXMga2lsbGVkIGFuZCByZW1vdmUgZnJvbSBpdHMgY3VycmVudCBbW1NjZW5lXV0uXHJcbiAgICAgKi9cclxuICAgIG9uUG9zdEtpbGwoX3NjZW5lKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSWYgdGhlIGN1cnJlbnQgYWN0b3IgaXMgYSBtZW1iZXIgb2YgdGhlIHNjZW5lLCB0aGlzIHdpbGwgcmVtb3ZlXHJcbiAgICAgKiBpdCBmcm9tIHRoZSBzY2VuZSBncmFwaC4gSXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAga2lsbCgpIHtcclxuICAgICAgICBpZiAodGhpcy5zY2VuZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVraWxsKHRoaXMuc2NlbmUpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2tpbGwnLCBuZXcgS2lsbEV2ZW50KHRoaXMpKTtcclxuICAgICAgICAgICAgc3VwZXIua2lsbCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9wb3N0a2lsbCh0aGlzLnNjZW5lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0Nhbm5vdCBraWxsIGFjdG9yLCBpdCB3YXMgbmV2ZXIgYWRkZWQgdG8gdGhlIFNjZW5lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgY3VycmVudCBhY3RvciBpcyBraWxsZWQsIGl0IHdpbGwgbm93IG5vdCBiZSBraWxsZWQuXHJcbiAgICAgKi9cclxuICAgIHVua2lsbCgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3ZXRoZXIgdGhlIGFjdG9yIGhhcyBiZWVuIGtpbGxlZC5cclxuICAgICAqL1xyXG4gICAgaXNLaWxsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmFjdGl2ZTtcclxuICAgIH1cclxuICAgIHNldERyYXdpbmcoa2V5KSB7XHJcbiAgICAgICAga2V5ID0ga2V5LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYXdpbmcgIT09IHRoaXMuZnJhbWVzW2tleV0pIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZnJhbWVzW2tleV0gIT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mcmFtZXNba2V5XS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZyA9IHRoaXMuZnJhbWVzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihgdGhlIHNwZWNpZmllZCBkcmF3aW5nIGtleSAke2tleX0gZG9lcyBub3QgZXhpc3RgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhd2luZyAmJiB0aGlzLmN1cnJlbnREcmF3aW5nIGluc3RhbmNlb2YgQW5pbWF0aW9uX0FuaW1hdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nLnRpY2soMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkRHJhd2luZygpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICB0aGlzLmZyYW1lc1thcmd1bWVudHNbMF1dID0gYXJndW1lbnRzWzFdO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuY3VycmVudERyYXdpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcgPSBhcmd1bWVudHNbMV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBTcHJpdGVfU3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZERyYXdpbmcoJ2RlZmF1bHQnLCBhcmd1bWVudHNbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiBUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZERyYXdpbmcoJ2RlZmF1bHQnLCBhcmd1bWVudHNbMF0uYXNTcHJpdGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHotaW5kZXggb2YgYW4gYWN0b3IuIFRoZSB6LWluZGV4IGRldGVybWluZXMgdGhlIHJlbGF0aXZlIG9yZGVyIGFuIGFjdG9yIGlzIGRyYXduIGluLlxyXG4gICAgICogQWN0b3JzIHdpdGggYSBoaWdoZXIgei1pbmRleCBhcmUgZHJhd24gb24gdG9wIG9mIGFjdG9ycyB3aXRoIGEgbG93ZXIgei1pbmRleFxyXG4gICAgICovXHJcbiAgICBnZXQgeigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS56O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tBY3Rvci56XV1cclxuICAgICAqL1xyXG4gICAgZ2V0WkluZGV4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLno7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHotaW5kZXggb2YgYW4gYWN0b3IgYW5kIHVwZGF0ZXMgaXQgaW4gdGhlIGRyYXdpbmcgbGlzdCBmb3IgdGhlIHNjZW5lLlxyXG4gICAgICogVGhlIHotaW5kZXggZGV0ZXJtaW5lcyB0aGUgcmVsYXRpdmUgb3JkZXIgYW4gYWN0b3IgaXMgZHJhd24gaW4uXHJcbiAgICAgKiBBY3RvcnMgd2l0aCBhIGhpZ2hlciB6LWluZGV4IGFyZSBkcmF3biBvbiB0b3Agb2YgYWN0b3JzIHdpdGggYSBsb3dlciB6LWluZGV4XHJcbiAgICAgKiBAcGFyYW0gbmV3WiBuZXcgei1pbmRleCB0byBhc3NpZ25cclxuICAgICAqL1xyXG4gICAgc2V0IHoobmV3Wikge1xyXG4gICAgICAgIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkueiA9IG5ld1o7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBuZXdJbmRleCBuZXcgei1pbmRleCB0byBhc3NpZ25cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW0FjdG9yLnpdXVxyXG4gICAgICovXHJcbiAgICBzZXRaSW5kZXgobmV3SW5kZXgpIHtcclxuICAgICAgICB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLnogPSBuZXdJbmRleDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjZW50ZXIgcG9pbnQgb2YgYW4gYWN0b3JcclxuICAgICAqL1xyXG4gICAgZ2V0IGNlbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLnBvcy54ICsgdGhpcy53aWR0aCAvIDIgLSB0aGlzLmFuY2hvci54ICogdGhpcy53aWR0aCwgdGhpcy5wb3MueSArIHRoaXMuaGVpZ2h0IC8gMiAtIHRoaXMuYW5jaG9yLnkgKiB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXIubG9jYWxCb3VuZHMud2lkdGggKiB0aGlzLmdldEdsb2JhbFNjYWxlKCkueDtcclxuICAgIH1cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXIubG9jYWxCb3VuZHMuaGVpZ2h0ICogdGhpcy5nZXRHbG9iYWxTY2FsZSgpLnk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhpcyBhY3RvcidzIHJvdGF0aW9uIHRha2luZyBpbnRvIGFjY291bnQgYW55IHBhcmVudCByZWxhdGlvbnNoaXBzXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUm90YXRpb24gYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICovXHJcbiAgICBnZXRHbG9iYWxSb3RhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS5nbG9iYWxSb3RhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbiBhY3RvcidzIHdvcmxkIHBvc2l0aW9uIHRha2luZyBpbnRvIGFjY291bnQgcGFyZW50IHJlbGF0aW9uc2hpcHMsIHNjYWxpbmcsIHJvdGF0aW9uLCBhbmQgdHJhbnNsYXRpb25cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQb3NpdGlvbiBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXRHbG9iYWxQb3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkuZ2xvYmFsUG9zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBnbG9iYWwgc2NhbGUgb2YgdGhlIEFjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldEdsb2JhbFNjYWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLmdsb2JhbFNjYWxlO1xyXG4gICAgfVxyXG4gICAgLy8gI3JlZ2lvbiBDb2xsaXNpb25cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgd2hldGhlciB0aGUgeC95IHNwZWNpZmllZCBhcmUgY29udGFpbmVkIGluIHRoZSBhY3RvclxyXG4gICAgICogQHBhcmFtIHggIFggY29vcmRpbmF0ZSB0byB0ZXN0IChpbiB3b3JsZCBjb29yZGluYXRlcylcclxuICAgICAqIEBwYXJhbSB5ICBZIGNvb3JkaW5hdGUgdG8gdGVzdCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXHJcbiAgICAgKiBAcGFyYW0gcmVjdXJzZSBjaGVja3Mgd2hldGhlciB0aGUgeC95IGFyZSBjb250YWluZWQgaW4gYW55IGNoaWxkIGFjdG9ycyAoaWYgdGhleSBleGlzdCkuXHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKHgsIHksIHJlY3Vyc2UgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gdmVjKHgsIHkpO1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gdGhpcy5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgICAgIGNvbGxpZGVyLnVwZGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IGdlb20gPSBjb2xsaWRlci5nZXQoKTtcclxuICAgICAgICBpZiAoIWdlb20pIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb250YWlubWVudCA9IGdlb20uY29udGFpbnMocG9pbnQpO1xyXG4gICAgICAgIGlmIChyZWN1cnNlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoY29udGFpbm1lbnQgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uc29tZSgoY2hpbGQpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuY29udGFpbnMoeCwgeSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250YWlubWVudDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gYWN0b3IuY29sbGlkZXIncyBzdXJmYWNlcyBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBkaXN0YW5jZSBzcGVjaWZpZWQgZnJvbSBlYWNoIG90aGVyXHJcbiAgICAgKiBAcGFyYW0gYWN0b3IgICAgIEFjdG9yIHRvIHRlc3RcclxuICAgICAqIEBwYXJhbSBkaXN0YW5jZSAgRGlzdGFuY2UgaW4gcGl4ZWxzIHRvIHRlc3RcclxuICAgICAqL1xyXG4gICAgd2l0aGluKGFjdG9yLCBkaXN0YW5jZSkge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gdGhpcy5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgICAgIGNvbnN0IG90aGVyQ29sbGlkZXIgPSBhY3Rvci5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgICAgIGNvbnN0IG1lID0gY29sbGlkZXIuZ2V0KCk7XHJcbiAgICAgICAgY29uc3Qgb3RoZXIgPSBvdGhlckNvbGxpZGVyLmdldCgpO1xyXG4gICAgICAgIGlmIChtZSAmJiBvdGhlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbWUuZ2V0Q2xvc2VzdExpbmVCZXR3ZWVuKG90aGVyKS5nZXRMZW5ndGgoKSA8PSBkaXN0YW5jZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLy8gI2VuZHJlZ2lvblxyXG4gICAgLy8gI3JlZ2lvbiBVcGRhdGVcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IHRoZSBFbmdpbmUsIHVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBhY3RvclxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKiBAcGFyYW0gZW5naW5lIFRoZSByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBlbmdpbmVcclxuICAgICAqIEBwYXJhbSBkZWx0YSAgVGhlIHRpbWUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgIHRoaXMuX3ByZXVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICAvLyBUaWNrIGFuaW1hdGlvbnNcclxuICAgICAgICBjb25zdCBkcmF3aW5nID0gdGhpcy5jdXJyZW50RHJhd2luZztcclxuICAgICAgICBpZiAoZHJhd2luZyAmJiBkcmF3aW5nIGluc3RhbmNlb2YgQW5pbWF0aW9uX0FuaW1hdGlvbikge1xyXG4gICAgICAgICAgICBkcmF3aW5nLnRpY2soZGVsdGEsIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgYWN0b3IgcGlwZWxpbmUgKG1vdmVtZW50LCBjb2xsaXNpb24gZGV0ZWN0aW9uLCBldmVudCBwcm9wYWdhdGlvbiwgb2Zmc2NyZWVuIGN1bGxpbmcpXHJcbiAgICAgICAgZm9yIChjb25zdCB0cmFpdCBvZiB0aGlzLnRyYWl0cykge1xyXG4gICAgICAgICAgICB0cmFpdC51cGRhdGUodGhpcywgZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Bvc3R1cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25QcmVVcGRhdGUgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwcmV1cGRhdGUnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25QcmVVcGRhdGVgIGlzIGNhbGxlZCBkaXJlY3RseSBiZWZvcmUgYW4gYWN0b3IgaXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgb25QcmVVcGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblBvc3RVcGRhdGUgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwb3N0dXBkYXRlJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUG9zdFVwZGF0ZWAgaXMgY2FsbGVkIGRpcmVjdGx5IGFmdGVyIGFuIGFjdG9yIGlzIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIG9uUG9zdFVwZGF0ZShfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wcmV1cGRhdGUgaGFuZGxlciBmb3IgW1tvblByZVVwZGF0ZV1dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wcmV1cGRhdGUoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncHJldXBkYXRlJywgbmV3IFByZVVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUHJlVXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wcmV1cGRhdGUgaGFuZGxlciBmb3IgW1tvblBvc3RVcGRhdGVdXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcG9zdHVwZGF0ZShlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0dXBkYXRlJywgbmV3IFByZVVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUG9zdFVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8vIGVuZHJlZ2lvblxyXG4gICAgLy8gI3JlZ2lvbiBEcmF3aW5nXHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBieSB0aGUgRW5naW5lLCBkcmF3cyB0aGUgYWN0b3IgdG8gdGhlIHNjcmVlblxyXG4gICAgICogQHBhcmFtIGN0eCAgIFRoZSByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICogQHBhcmFtIGRlbHRhIFRoZSB0aW1lIHNpbmNlIHRoZSBsYXN0IGRyYXcgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKlxyXG4gICAgICogKipXYXJuaW5nKiogb25seSB3b3JrcyB3aXRoIEZsYWdzLnVzZUxlZ2FjeURyYXdpbmcoKSBlbmFibGVkXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgQWN0b3IuZ3JhcGhpY3MsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAgICAgKi9cclxuICAgIGRyYXcoY3R4LCBkZWx0YSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAvLyB0cmFuc2xhdGUgY2FudmFzIGJ5IGFuY2hvciBvZmZzZXRcclxuICAgICAgICBjdHguc2F2ZSgpO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmF3aW5nKSB7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoLSh0aGlzLndpZHRoICogdGhpcy5hbmNob3IueCksIC0odGhpcy5oZWlnaHQgKiB0aGlzLmFuY2hvci55KSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZWRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRyYXdpbmcgPSB0aGlzLmN1cnJlbnREcmF3aW5nO1xyXG4gICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9wdWxsLzYxOSBmb3IgZGlzY3Vzc2lvbiBvbiB0aGlzIGZvcm11bGFcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WCA9ICh0aGlzLndpZHRoIC0gZHJhd2luZy53aWR0aCAqIGRyYXdpbmcuc2NhbGUueCkgKiB0aGlzLmFuY2hvci54O1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRZID0gKHRoaXMuaGVpZ2h0IC0gZHJhd2luZy5oZWlnaHQgKiBkcmF3aW5nLnNjYWxlLnkpICogdGhpcy5hbmNob3IueTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZy5kcmF3KHsgY3R4LCB4OiBvZmZzZXRYLCB5OiBvZmZzZXRZLCBvcGFjaXR5OiB0aGlzLmdyYXBoaWNzLm9wYWNpdHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9wcmVkcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvciAmJiB0aGlzLmNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgY29sbGlkZXIgZ2VvbWV0cnkgYmFzZWQgb24gdHJhbnNmb3JtXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsaWRlciA9IHRoaXMuZ2V0KENvbGxpZGVyQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbGxpZGVyICYmICFjb2xsaWRlci5ib3VuZHMuaGFzWmVyb0RpbWVuc2lvbnMoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIENvbGxpZGVycyBhcmUgYWxyZWFkeSBzaGlmdGVkIGJ5IGFuY2hvciwgdW5zaGlmdFxyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuZ3JhcGhpY3Mub3BhY2l0eTtcclxuICAgICAgICAgICAgICAgICAgICAoX2EgPSBjb2xsaWRlci5nZXQoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRyYXcoY3R4LCB0aGlzLmNvbG9yLCB2ZWMoMCwgMCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgdGhpcy5fcG9zdGRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25QcmVEcmF3IGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncHJlZHJhdycsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblByZURyYXdgIGlzIGNhbGxlZCBkaXJlY3RseSBiZWZvcmUgYW4gYWN0b3IgaXMgZHJhd24sIGJ1dCBhZnRlciBsb2NhbCB0cmFuc2Zvcm1zIGFyZSBtYWRlLlxyXG4gICAgICpcclxuICAgICAqICoqV2FybmluZyoqIG9ubHkgd29ya3Mgd2l0aCBGbGFncy51c2VMZWdhY3lEcmF3aW5nKCkgZW5hYmxlZFxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIEFjdG9yLmdyYXBoaWNzLm9uUG9zdERyYXcsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAgICAgKi9cclxuICAgIG9uUHJlRHJhdyhfY3R4LCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUG9zdERyYXcgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwb3N0ZHJhdycsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblBvc3REcmF3YCBpcyBjYWxsZWQgZGlyZWN0bHkgYWZ0ZXIgYW4gYWN0b3IgaXMgZHJhd24sIGFuZCBiZWZvcmUgbG9jYWwgdHJhbnNmb3JtcyBhcmUgcmVtb3ZlZC5cclxuICAgICAqXHJcbiAgICAgKiAqKldhcm5pbmcqKiBvbmx5IHdvcmtzIHdpdGggRmxhZ3MudXNlTGVnYWN5RHJhd2luZygpIGVuYWJsZWRcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBBY3Rvci5ncmFwaGljcy5vblBvc3REcmF3LCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gICAgICovXHJcbiAgICBvblBvc3REcmF3KF9jdHgsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3ByZWRyYXcgaGFuZGxlciBmb3IgW1tvblByZURyYXddXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqXHJcbiAgICAgKiAqKldhcm5pbmcqKiBvbmx5IHdvcmtzIHdpdGggRmxhZ3MudXNlTGVnYWN5RHJhd2luZygpIGVuYWJsZWRcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBBY3Rvci5ncmFwaGljcy5vblByZURyYXcsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3ByZWRyYXcoY3R4LCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncHJlZHJhdycsIG5ldyBQcmVEcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25QcmVEcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wb3N0ZHJhdyBoYW5kbGVyIGZvciBbW29uUG9zdERyYXddXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqXHJcbiAgICAgKiAqKldhcm5pbmcqKiBvbmx5IHdvcmtzIHdpdGggRmxhZ3MudXNlTGVnYWN5RHJhd2luZygpIGVuYWJsZWRcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBBY3Rvci5ncmFwaGljcy5vblBvc3REcmF3LCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wb3N0ZHJhdyhjdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZHJhdycsIG5ldyBQcmVEcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25Qb3N0RHJhdyhjdHgsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IHRoZSBFbmdpbmUsIGRyYXdzIHRoZSBhY3RvcnMgZGVidWdnaW5nIHRvIHRoZSBzY3JlZW5cclxuICAgICAqIEBwYXJhbSBjdHggVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqICoqV2FybmluZyoqIG9ubHkgd29ya3Mgd2l0aCBGbGFncy51c2VMZWdhY3lEcmF3aW5nKCkgZW5hYmxlZFxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIEFjdG9yLmdyYXBoaWNzLm9uUG9zdERyYXcsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGRlYnVnRHJhdyhfY3R4KSB7XHJcbiAgICAgICAgLy8gcGFzc1xyXG4gICAgfVxyXG59XHJcbi8vICNyZWdpb24gUHJvcGVydGllc1xyXG4vKipcclxuICogU2V0IGRlZmF1bHRzIGZvciBhbGwgQWN0b3JzXHJcbiAqL1xyXG5BY3Rvci5kZWZhdWx0cyA9IHtcclxuICAgIGFuY2hvcjogVmVjdG9yLkhhbGZcclxufTtcclxuQWN0b3JfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnQWN0b3IudmlzaWJsZSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBBY3Rvci5ncmFwaGljcy52aXNpYmxlJyB9KVxyXG5dLCBBY3Rvci5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCBudWxsKTtcclxuQWN0b3JfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdBY3Rvci5vcGFjaXR5IHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgQWN0b3IuZ3JhcGhpY3Mub3BhY2l0eSdcclxuICAgIH0pXHJcbl0sIEFjdG9yLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIG51bGwpO1xyXG5BY3Rvcl9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0FjdG9yLnNldERyYXdpbmcgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBBY3Rvci5ncmFwaGljcy5zaG93KCkgb3IgQWN0b3IuZ3JhcGhpY3MudXNlKCknXHJcbiAgICB9KVxyXG5dLCBBY3Rvci5wcm90b3R5cGUsIFwic2V0RHJhd2luZ1wiLCBudWxsKTtcclxuQWN0b3JfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdBY3Rvci5hZGREcmF3aW5nIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgQWN0b3IuZ3JhcGhpY3MuYWRkKCknXHJcbiAgICB9KVxyXG5dLCBBY3Rvci5wcm90b3R5cGUsIFwiYWRkRHJhd2luZ1wiLCBudWxsKTtcclxuQWN0b3JfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdBY3Rvci5nZXRaSW5kZXggd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBBY3Rvci50cmFuc2Zvcm0ueiBvciBBY3Rvci56J1xyXG4gICAgfSlcclxuXSwgQWN0b3IucHJvdG90eXBlLCBcImdldFpJbmRleFwiLCBudWxsKTtcclxuQWN0b3JfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdBY3Rvci5zZXRaSW5kZXggd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBBY3Rvci50cmFuc2Zvcm0ueiBvciBBY3Rvci56J1xyXG4gICAgfSlcclxuXSwgQWN0b3IucHJvdG90eXBlLCBcInNldFpJbmRleFwiLCBudWxsKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9TY3JlZW5FbGVtZW50LnRzXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBIZWxwZXIgW1tBY3Rvcl1dIHByaW1pdGl2ZSBmb3IgZHJhd2luZyBVSSdzLCBvcHRpbWl6ZWQgZm9yIFVJIGRyYXdpbmcuIERvZXNcclxuICogbm90IHBhcnRpY2lwYXRlIGluIGNvbGxpc2lvbnMuIERyYXduIG9uIHRvcCBvZiBhbGwgb3RoZXIgYWN0b3JzLlxyXG4gKi9cclxuY2xhc3MgU2NyZWVuRWxlbWVudF9TY3JlZW5FbGVtZW50IGV4dGVuZHMgQWN0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSk7XHJcbiAgICAgICAgdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS5jb29yZFBsYW5lID0gQ29vcmRQbGFuZS5TY3JlZW47XHJcbiAgICAgICAgdGhpcy50cmFpdHMgPSBbXTtcclxuICAgICAgICB0aGlzLnRyYWl0cy5wdXNoKG5ldyBDYXB0dXJlUG9pbnRlcigpKTtcclxuICAgICAgICB0aGlzLmFuY2hvciA9IHZlYygwLCAwKTtcclxuICAgICAgICB0aGlzLmJvZHkuY29sbGlzaW9uVHlwZSA9IENvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICB0aGlzLmNvbGxpZGVyLnVzZUJveENvbGxpZGVyKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLmFuY2hvcik7XHJcbiAgICAgICAgdGhpcy5lbmFibGVDYXB0dXJlUG9pbnRlciA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZShlbmdpbmUpIHtcclxuICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemUoZW5naW5lKTtcclxuICAgIH1cclxuICAgIGNvbnRhaW5zKHgsIHksIHVzZVdvcmxkID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmICh1c2VXb3JsZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gc3VwZXIuY29udGFpbnMoeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IHRoaXMuX2VuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMobmV3IFZlY3Rvcih4LCB5KSk7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmNvbnRhaW5zKGNvb3Jkcy54LCBjb29yZHMueSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9UaW1lci50c1xudmFyIFRpbWVyX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgRXhjYWxpYnVyIHRpbWVyIGhvb2tzIGludG8gdGhlIGludGVybmFsIHRpbWVyIGFuZCBmaXJlcyBjYWxsYmFja3MsXHJcbiAqIGFmdGVyIGEgY2VydGFpbiBpbnRlcnZhbCwgb3B0aW9uYWxseSByZXBlYXRpbmcuXHJcbiAqL1xyXG5jbGFzcyBUaW1lciB7XHJcbiAgICBjb25zdHJ1Y3RvcihmY24sIGludGVydmFsLCByZXBlYXRzLCBudW1iZXJPZlJlcGVhdHMpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLmlkID0gMDtcclxuICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fdG90YWxUaW1lQWxpdmUgPSAwO1xyXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZlRpY2tzID0gMDtcclxuICAgICAgICB0aGlzLmludGVydmFsID0gMTA7XHJcbiAgICAgICAgdGhpcy5yZXBlYXRzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5tYXhOdW1iZXJPZlJlcGVhdHMgPSAtMTtcclxuICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmNuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBmY247XHJcbiAgICAgICAgICAgIGZjbiA9IG9wdGlvbnMuZmNuO1xyXG4gICAgICAgICAgICBpbnRlcnZhbCA9IG9wdGlvbnMuaW50ZXJ2YWw7XHJcbiAgICAgICAgICAgIHJlcGVhdHMgPSBvcHRpb25zLnJlcGVhdHM7XHJcbiAgICAgICAgICAgIG51bWJlck9mUmVwZWF0cyA9IG9wdGlvbnMubnVtYmVyT2ZSZXBlYXRzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISFudW1iZXJPZlJlcGVhdHMgJiYgbnVtYmVyT2ZSZXBlYXRzID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5tYXhOdW1iZXJPZlJlcGVhdHMgPSBudW1iZXJPZlJlcGVhdHM7XHJcbiAgICAgICAgICAgIGlmICghcmVwZWF0cykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXBlYXRzIG11c3QgYmUgc2V0IHRvIHRydWUgaWYgbnVtYmVyT2ZSZXBlYXRzIGlzIHNldCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaWQgPSBUaW1lci5fTUFYX0lEKys7XHJcbiAgICAgICAgdGhpcy5pbnRlcnZhbCA9IGludGVydmFsIHx8IHRoaXMuaW50ZXJ2YWw7XHJcbiAgICAgICAgdGhpcy5yZXBlYXRzID0gcmVwZWF0cyB8fCB0aGlzLnJlcGVhdHM7XHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzID0gW107XHJcbiAgICAgICAgaWYgKGZjbikge1xyXG4gICAgICAgICAgICB0aGlzLm9uKGZjbik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGNvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wbGV0ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBjYWxsYmFjayB0byBiZSBmaXJlZCBhZnRlciB0aGUgaW50ZXJ2YWwgaXMgY29tcGxldGVcclxuICAgICAqIEBwYXJhbSBmY24gVGhlIGNhbGxiYWNrIHRvIGJlIGFkZGVkIHRvIHRoZSBjYWxsYmFjayBsaXN0LCB0byBiZSBmaXJlZCBhZnRlciB0aGUgaW50ZXJ2YWwgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIG9uKGZjbikge1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5wdXNoKGZjbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjYWxsYmFjayBmcm9tIHRoZSBjYWxsYmFjayBsaXN0IHRvIGJlIGZpcmVkIGFmdGVyIHRoZSBpbnRlcnZhbCBpcyBjb21wbGV0ZS5cclxuICAgICAqIEBwYXJhbSBmY24gVGhlIGNhbGxiYWNrIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgY2FsbGJhY2sgbGlzdCwgdG8gYmUgZmlyZWQgYWZ0ZXIgdGhlIGludGVydmFsIGlzIGNvbXBsZXRlLlxyXG4gICAgICovXHJcbiAgICBvZmYoZmNuKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9jYWxsYmFja3MuaW5kZXhPZihmY24pO1xyXG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSB0aW1lciBhZnRlciBhIGNlcnRhaW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQuIFRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBlbmdpbmUuXHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgIE51bWJlciBvZiBlbGFwc2VkIG1pbGxpc2Vjb25kcyBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9ydW5uaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsVGltZUFsaXZlICs9IGRlbHRhO1xyXG4gICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWF4TnVtYmVyT2ZSZXBlYXRzID4gLTEgJiYgdGhpcy5fbnVtYmVyT2ZUaWNrcyA+PSB0aGlzLm1heE51bWJlck9mUmVwZWF0cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jb21wbGV0ZSAmJiB0aGlzLl9lbGFwc2VkVGltZSA+PSB0aGlzLmludGVydmFsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MuZm9yRWFjaCgoYykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGMuY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbnVtYmVyT2ZUaWNrcysrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIHRpbWVyIHNvIHRoYXQgaXQgY2FuIGJlIHJldXNlZCwgYW5kIG9wdGlvbmFsbHkgcmVjb25maWd1cmUgdGhlIHRpbWVycyBpbnRlcnZhbC5cclxuICAgICAqXHJcbiAgICAgKiBXYXJuaW5nKiogeW91IG1heSBuZWVkIHRvIGNhbGwgYHRpbWVyLnN0YXJ0KClgIGFnYWluIGlmIHRoZSB0aW1lciBoYWQgY29tcGxldGVkXHJcbiAgICAgKiBAcGFyYW0gbmV3SW50ZXJ2YWwgSWYgc3BlY2lmaWVkLCBzZXRzIGEgbmV3IG5vbi1uZWdhdGl2ZSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHMgdG8gcmVmaXJlIHRoZSBjYWxsYmFja1xyXG4gICAgICogQHBhcmFtIG5ld051bWJlck9mUmVwZWF0cyBJZiBzcGVjaWZpZWQsIHNldHMgYSBuZXcgbm9uLW5lZ2F0aXZlIHVwcGVyIGxpbWl0IHRvIHRoZSBudW1iZXIgb2YgdGltZSB0aGlzIHRpbWVyIGV4ZWN1dGVzXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KG5ld0ludGVydmFsLCBuZXdOdW1iZXJPZlJlcGVhdHMpIHtcclxuICAgICAgICBpZiAoISFuZXdJbnRlcnZhbCAmJiBuZXdJbnRlcnZhbCA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwgPSBuZXdJbnRlcnZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEhdGhpcy5tYXhOdW1iZXJPZlJlcGVhdHMgJiYgdGhpcy5tYXhOdW1iZXJPZlJlcGVhdHMgPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heE51bWJlck9mUmVwZWF0cyA9IG5ld051bWJlck9mUmVwZWF0cztcclxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlcGVhdHMpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVwZWF0cyBtdXN0IGJlIHNldCB0byB0cnVlIGlmIG51bWJlck9mUmVwZWF0cyBpcyBzZXQnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZlRpY2tzID0gMDtcclxuICAgIH1cclxuICAgIGdldCB0aW1lc1JlcGVhdGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9udW1iZXJPZlRpY2tzO1xyXG4gICAgfVxyXG4gICAgZ2V0VGltZVJ1bm5pbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsVGltZUFsaXZlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBtaWxsaXNlY29uZHMgdW50aWwgdGhlIG5leHQgYWN0aW9uIGNhbGxiYWNrLCBpZiBjb21wbGV0ZSB3aWxsIHJldHVybiAwXHJcbiAgICAgKi9cclxuICAgIGdldCB0aW1lVG9OZXh0QWN0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlcnZhbCAtIHRoaXMuX2VsYXBzZWRUaW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBtaWxsaXNlY29uZHMgZWxhcHNlZCB0b3dhcmQgdGhlIG5leHQgYWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldCB0aW1lRWxhcHNlZFRvd2FyZE5leHRBY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VsYXBzZWRUaW1lO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzUnVubmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcnVubmluZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGF1c2VzIHRoZSB0aW1lciwgdGltZSB3aWxsIG5vIGxvbmdlciBpbmNyZW1lbnQgdG93YXJkcyB0aGUgbmV4dCBjYWxsXHJcbiAgICAgKi9cclxuICAgIHBhdXNlKCkge1xyXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW5wYXVzZXMgdGhlIHRpbWVyLiBUaW1lIHdpbGwgbm93IGluY3JlbWVudCB0b3dhcmRzIHRoZSBuZXh0IGNhbGxcclxuICAgICAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAgICAgKi9cclxuICAgIHVucGF1c2UoKSB7XHJcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc3VtZXMgdGhlIHRpbWVyLCB0aW1lIHdpbGwgbm93IGluY3JlbWVudCB0b3dhcmRzIHRoZSBuZXh0IGNhbGwuXHJcbiAgICAgKi9cclxuICAgIHJlc3VtZSgpIHtcclxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHRoZSB0aW1lciwgaWYgdGhlIHRpbWVyIHdhcyBjb21wbGV0ZSBpdCB3aWxsIHJlc3RhcnQgdGhlIHRpbWVyIGFuZCByZXNldCB0aGUgZWxhcHNlZCB0aW1lIGNvdW50ZXJcclxuICAgICAqL1xyXG4gICAgc3RhcnQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnNjZW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdDYW5ub3Qgc3RhcnQgYSB0aW1lciBub3QgcGFydCBvZiBhIHNjZW5lLCB0aW1lciB3b250IHN0YXJ0IHVudGlsIGFkZGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fbnVtYmVyT2ZUaWNrcyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyB0aGUgdGltZXIgYW5kIHJlc2V0cyB0aGUgZWxhcHNlZCB0aW1lIGNvdW50ZXIgdG93YXJkcyB0aGUgbmV4dCBhY3Rpb24gaW52b2NhdGlvblxyXG4gICAgICovXHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbnVtYmVyT2ZUaWNrcyA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbmNlbHMgdGhlIHRpbWVyLCBwcmV2ZW50aW5nIGFueSBmdXJ0aGVyIGV4ZWN1dGlvbnMuXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NlbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZS5jYW5jZWxUaW1lcih0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuVGltZXIuX01BWF9JRCA9IDA7XHJcblRpbWVyX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHsgbWVzc2FnZTogJ1dpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJywgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIFRpbWVyLnJlc3VtZSgpJyB9KVxyXG5dLCBUaW1lci5wcm90b3R5cGUsIFwidW5wYXVzZVwiLCBudWxsKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9UaWxlTWFwLnRzXG52YXIgVGlsZU1hcF9kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEBoaWRkZW5cclxuICovXHJcbmNsYXNzIFRpbGVNYXBJbXBsIGV4dGVuZHMgRW50aXR5IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHhPckNvbmZpZyAgICAgVGhlIHggY29vcmRpbmF0ZSB0byBhbmNob3IgdGhlIFRpbGVNYXAncyB1cHBlciBsZWZ0IGNvcm5lciAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KSBvciBUaWxlTWFwIG9wdGlvbiBiYWdcclxuICAgICAqIEBwYXJhbSB5ICAgICAgICAgICAgIFRoZSB5IGNvb3JkaW5hdGUgdG8gYW5jaG9yIHRoZSBUaWxlTWFwJ3MgdXBwZXIgbGVmdCBjb3JuZXIgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcclxuICAgICAqIEBwYXJhbSBjZWxsV2lkdGggICAgIFRoZSBpbmRpdmlkdWFsIHdpZHRoIG9mIGVhY2ggY2VsbCAoaW4gcGl4ZWxzKSAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxyXG4gICAgICogQHBhcmFtIGNlbGxIZWlnaHQgICAgVGhlIGluZGl2aWR1YWwgaGVpZ2h0IG9mIGVhY2ggY2VsbCAoaW4gcGl4ZWxzKSAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxyXG4gICAgICogQHBhcmFtIHJvd3MgICAgICAgICAgVGhlIG51bWJlciBvZiByb3dzIGluIHRoZSBUaWxlTWFwIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgKiBAcGFyYW0gY29scyAgICAgICAgICBUaGUgbnVtYmVyIG9mIGNvbHMgaW4gdGhlIFRpbGVNYXAgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoeE9yQ29uZmlnLCB5LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHJvd3MsIGNvbHMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3Rva2VuID0gMDtcclxuICAgICAgICB0aGlzLl9vblNjcmVlblhTdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5fb25TY3JlZW5YRW5kID0gOTk5OTtcclxuICAgICAgICB0aGlzLl9vblNjcmVlbllTdGFydCA9IDA7XHJcbiAgICAgICAgdGhpcy5fb25TY3JlZW5ZRW5kID0gOTk5OTtcclxuICAgICAgICB0aGlzLl9zcHJpdGVTaGVldHMgPSB7fTtcclxuICAgICAgICB0aGlzLl9sZWdhY3lTcHJpdGVNYXAgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBbXTtcclxuICAgICAgICB0aGlzLl9yb3dzID0gW107XHJcbiAgICAgICAgdGhpcy5fY29scyA9IFtdO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc09mZnNjcmVlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICBpZiAoeE9yQ29uZmlnICYmIHR5cGVvZiB4T3JDb25maWcgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHhPckNvbmZpZztcclxuICAgICAgICAgICAgeE9yQ29uZmlnID0gY29uZmlnLng7XHJcbiAgICAgICAgICAgIHkgPSBjb25maWcueTtcclxuICAgICAgICAgICAgY2VsbFdpZHRoID0gY29uZmlnLmNlbGxXaWR0aDtcclxuICAgICAgICAgICAgY2VsbEhlaWdodCA9IGNvbmZpZy5jZWxsSGVpZ2h0O1xyXG4gICAgICAgICAgICByb3dzID0gY29uZmlnLnJvd3M7XHJcbiAgICAgICAgICAgIGNvbHMgPSBjb25maWcuY29scztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgTW90aW9uQ29tcG9uZW50KCkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBCb2R5Q29tcG9uZW50KHtcclxuICAgICAgICAgICAgdHlwZTogQ29sbGlzaW9uVHlwZS5GaXhlZFxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgQ2FudmFzRHJhd0NvbXBvbmVudCgoY3R4LCBkZWx0YSkgPT4gdGhpcy5kcmF3KGN0eCwgZGVsdGEpKSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IEdyYXBoaWNzQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgb25Qb3N0RHJhdzogKGN0eCwgZGVsdGEpID0+IHRoaXMuZHJhdyhjdHgsIGRlbHRhKVxyXG4gICAgICAgIH0pKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgQ29sbGlkZXJDb21wb25lbnQoKSk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24gPSB0aGlzLmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2NvbGxpZGVyID0gdGhpcy5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZSA9IHRoaXMuX2NvbGxpZGVyLnVzZUNvbXBvc2l0ZUNvbGxpZGVyKFtdKTtcclxuICAgICAgICB0aGlzLnggPSB4T3JDb25maWc7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLmNlbGxXaWR0aCA9IGNlbGxXaWR0aDtcclxuICAgICAgICB0aGlzLmNlbGxIZWlnaHQgPSBjZWxsSGVpZ2h0O1xyXG4gICAgICAgIHRoaXMucm93cyA9IHJvd3M7XHJcbiAgICAgICAgdGhpcy5jb2xzID0gY29scztcclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQXJyYXkocm93cyAqIGNvbHMpO1xyXG4gICAgICAgIHRoaXMuX3Jvd3MgPSBuZXcgQXJyYXkocm93cyk7XHJcbiAgICAgICAgdGhpcy5fY29scyA9IG5ldyBBcnJheShjb2xzKTtcclxuICAgICAgICBsZXQgY3VycmVudENvbCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93czsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjZCA9IG5ldyBDZWxsKGkgKiBjZWxsV2lkdGggKyB4T3JDb25maWcsIGogKiBjZWxsSGVpZ2h0ICsgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBpICsgaiAqIGNvbHMpO1xyXG4gICAgICAgICAgICAgICAgY2QubWFwID0gdGhpcztcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtpICsgaiAqIGNvbHNdID0gY2Q7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29sLnB1c2goY2QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9yb3dzW2pdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcm93c1tqXSA9IFtdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm93c1tqXS5wdXNoKGNkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jb2xzW2ldID0gY3VycmVudENvbDtcclxuICAgICAgICAgICAgY3VycmVudENvbCA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdldChHcmFwaGljc0NvbXBvbmVudCkubG9jYWxCb3VuZHMgPSBuZXcgQm91bmRpbmdCb3goe1xyXG4gICAgICAgICAgICBsZWZ0OiAwLFxyXG4gICAgICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgICAgIHJpZ2h0OiB0aGlzLmNvbHMgKiB0aGlzLmNlbGxXaWR0aCxcclxuICAgICAgICAgICAgYm90dG9tOiB0aGlzLnJvd3MgKiB0aGlzLmNlbGxIZWlnaHRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZsYWdEaXJ0eSgpIHtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBnZXQgeCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX3RyYW5zZm9ybS5wb3MueCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgIH1cclxuICAgIHNldCB4KHZhbCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoKF9hID0gdGhpcy5fdHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkucG9zID0gdmVjKHZhbCwgdGhpcy55KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgeSgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3MueSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgIH1cclxuICAgIHNldCB5KHZhbCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoKF9hID0gdGhpcy5fdHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybS5wb3MgPSB2ZWModGhpcy54LCB2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCB6KCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fdHJhbnNmb3JtLnopICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XHJcbiAgICB9XHJcbiAgICBzZXQgeih2YWwpIHtcclxuICAgICAgICBpZiAodGhpcy5fdHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybS56ID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCByb3RhdGlvbigpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb3RhdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgIH1cclxuICAgIHNldCByb3RhdGlvbih2YWwpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuX3RyYW5zZm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybS5yb3RhdGlvbiA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgc2NhbGUoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fdHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2NhbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFZlY3Rvci5PbmU7XHJcbiAgICB9XHJcbiAgICBzZXQgc2NhbGUodmFsKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2FsZSkge1xyXG4gICAgICAgICAgICB0aGlzLl90cmFuc2Zvcm0uc2NhbGUgPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtLnBvcztcclxuICAgIH1cclxuICAgIHNldCBwb3ModmFsKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnBvcyA9IHZhbDtcclxuICAgIH1cclxuICAgIGdldCB2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX21vdGlvbi52ZWw7XHJcbiAgICB9XHJcbiAgICBzZXQgdmVsKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemUoZW5naW5lKSB7XHJcbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemUoZW5naW5lKTtcclxuICAgIH1cclxuICAgIHJlZ2lzdGVyU3ByaXRlU2hlZXQoa2V5LCBzcHJpdGVTaGVldCkge1xyXG4gICAgICAgIGlmIChzcHJpdGVTaGVldCBpbnN0YW5jZW9mIFNwcml0ZVNoZWV0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZVNoZWV0c1trZXldID0gc3ByaXRlU2hlZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVTaGVldHNba2V5XSA9IFNwcml0ZVNoZWV0LmZyb21MZWdhY3lTcHJpdGVTaGVldChzcHJpdGVTaGVldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaWxlcyBjb2xsaWRlcnMgYmFzZWQgb24gdGhlIHNvbGlkIHRpbGVzIGluIHRoZSB0aWxlbWFwLlxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlQ29sbGlkZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZS5jbGVhckNvbGxpZGVycygpO1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IFtdO1xyXG4gICAgICAgIGxldCBjdXJyZW50O1xyXG4gICAgICAgIC8vIEJhZCBzcXVhcmUgdGVzc2FsYXRpb24gYWxnb1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2xzOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gU2NhbiBjb2x1bW4gZm9yIGNvbGxpZGVyc1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMucm93czsgaisrKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBDb2x1bW5zIHN0YXJ0IHdpdGggYSBuZXcgY29sbGlkZXJcclxuICAgICAgICAgICAgICAgIGlmIChqID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0aWxlID0gdGhpcy5kYXRhW2kgKyBqICogdGhpcy5jb2xzXTtcclxuICAgICAgICAgICAgICAgIC8vIEN1cnJlbnQgdGlsZSBpbiBjb2x1bW4gaXMgc29saWQgYnVpbGQgdXAgY3VycmVudCBjb2xsaWRlclxyXG4gICAgICAgICAgICAgICAgaWYgKHRpbGUuc29saWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRpbGUuYm91bmRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuY29tYmluZSh0aWxlLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IHNvbGlkIHNraXAgYW5kIGN1dCBvZmYgdGhlIGN1cnJlbnQgY29sbGlkZXJcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsaWRlcnMucHVzaChjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQWZ0ZXIgYSBjb2x1bW4gaXMgY29tcGxldGUgY2hlY2sgdG8gc2VlIGlmIGl0IGNhbiBiZSBtZXJnZWQgaW50byB0aGUgbGFzdCBvbmVcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIC8vIGlmIHByZXZpb3VzIGlzIHRoZSBzYW1lIGNvbWJpbmUgaXRcclxuICAgICAgICAgICAgICAgIGNvbnN0IHByZXYgPSBjb2xsaWRlcnNbY29sbGlkZXJzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi50b3AgPT09IGN1cnJlbnQudG9wICYmIHByZXYuYm90dG9tID09PSBjdXJyZW50LmJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpZGVyc1tjb2xsaWRlcnMubGVuZ3RoIC0gMV0gPSBwcmV2LmNvbWJpbmUoY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlbHNlIG5ldyBjb2xsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpZGVycy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbXBvc2l0ZSA9IHRoaXMuX2NvbGxpZGVyLnVzZUNvbXBvc2l0ZUNvbGxpZGVyKFtdKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyID0gU2hhcGUuQm94KGMud2lkdGgsIGMuaGVpZ2h0LCBWZWN0b3IuWmVybywgdmVjKGMubGVmdCAtIHRoaXMucG9zLngsIGMudG9wIC0gdGhpcy5wb3MueSkpO1xyXG4gICAgICAgICAgICBjb2xsaWRlci5vd25lciA9IHRoaXM7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvc2l0ZS5hZGRDb2xsaWRlcihjb2xsaWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbGxpZGVyLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBbW0NlbGxdXSBieSBpbmRleCAocm93IG1ham9yIG9yZGVyKVxyXG4gICAgICovXHJcbiAgICBnZXRDZWxsQnlJbmRleChpbmRleCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBbW0NlbGxdXSBieSBpdHMgeCBhbmQgeSBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXRDZWxsKHgsIHkpIHtcclxuICAgICAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+PSB0aGlzLmNvbHMgfHwgeSA+PSB0aGlzLnJvd3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeCArIHkgKiB0aGlzLmNvbHNdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBbW0NlbGxdXSBieSB0ZXN0aW5nIGEgcG9pbnQgaW4gZ2xvYmFsIGNvb3JkaW5hdGVzLFxyXG4gICAgICogcmV0dXJucyBgbnVsbGAgaWYgbm8gY2VsbCB3YXMgZm91bmQuXHJcbiAgICAgKi9cclxuICAgIGdldENlbGxCeVBvaW50KHgsIHkpIHtcclxuICAgICAgICB4ID0gTWF0aC5mbG9vcigoeCAtIHRoaXMucG9zLngpIC8gdGhpcy5jZWxsV2lkdGgpO1xyXG4gICAgICAgIHkgPSBNYXRoLmZsb29yKCh5IC0gdGhpcy5wb3MueSkgLyB0aGlzLmNlbGxIZWlnaHQpO1xyXG4gICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdldENlbGwoeCwgeSk7XHJcbiAgICAgICAgaWYgKHggPj0gMCAmJiB5ID49IDAgJiYgeCA8IHRoaXMuY29scyAmJiB5IDwgdGhpcy5yb3dzICYmIGNlbGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNlbGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgZ2V0Um93cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcm93cztcclxuICAgIH1cclxuICAgIGdldENvbHVtbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHM7XHJcbiAgICB9XHJcbiAgICBvblByZVVwZGF0ZShfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgb25Qb3N0VXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMub25QcmVVcGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmV1cGRhdGUnLCBuZXcgUHJlVXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDb2xsaWRlcnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdG9rZW4rKztcclxuICAgICAgICBjb25zdCB3b3JsZEJvdW5kcyA9IGVuZ2luZS5nZXRXb3JsZEJvdW5kcygpO1xyXG4gICAgICAgIGNvbnN0IHdvcmxkQ29vcmRzVXBwZXJMZWZ0ID0gdmVjKHdvcmxkQm91bmRzLmxlZnQsIHdvcmxkQm91bmRzLnRvcCk7XHJcbiAgICAgICAgY29uc3Qgd29ybGRDb29yZHNMb3dlclJpZ2h0ID0gdmVjKHdvcmxkQm91bmRzLnJpZ2h0LCB3b3JsZEJvdW5kcy5ib3R0b20pO1xyXG4gICAgICAgIHRoaXMuX29uU2NyZWVuWFN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5mbG9vcigod29ybGRDb29yZHNVcHBlckxlZnQueCAtIHRoaXMueCkgLyB0aGlzLmNlbGxXaWR0aCkgLSAyLCAwKTtcclxuICAgICAgICB0aGlzLl9vblNjcmVlbllTdGFydCA9IE1hdGgubWF4KE1hdGguZmxvb3IoKHdvcmxkQ29vcmRzVXBwZXJMZWZ0LnkgLSB0aGlzLnkpIC8gdGhpcy5jZWxsSGVpZ2h0KSAtIDIsIDApO1xyXG4gICAgICAgIHRoaXMuX29uU2NyZWVuWEVuZCA9IE1hdGgubWF4KE1hdGguZmxvb3IoKHdvcmxkQ29vcmRzTG93ZXJSaWdodC54IC0gdGhpcy54KSAvIHRoaXMuY2VsbFdpZHRoKSArIDIsIDApO1xyXG4gICAgICAgIHRoaXMuX29uU2NyZWVuWUVuZCA9IE1hdGgubWF4KE1hdGguZmxvb3IoKHdvcmxkQ29vcmRzTG93ZXJSaWdodC55IC0gdGhpcy55KSAvIHRoaXMuY2VsbEhlaWdodCkgKyAyLCAwKTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0ucG9zID0gdmVjKHRoaXMueCwgdGhpcy55KTtcclxuICAgICAgICB0aGlzLm9uUG9zdFVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLmVtaXQoJ3Bvc3R1cGRhdGUnLCBuZXcgUG9zdFVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIHRpbGUgbWFwIHRvIHRoZSBzY3JlZW4uIENhbGxlZCBieSB0aGUgW1tTY2VuZV1dLlxyXG4gICAgICogQHBhcmFtIGN0eCBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgb3IgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IGRyYXdcclxuICAgICAqL1xyXG4gICAgZHJhdyhjdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVkcmF3JywgbmV3IFByZURyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7IC8vIFRPRE8gZml4IGV2ZW50XHJcbiAgICAgICAgbGV0IHggPSB0aGlzLl9vblNjcmVlblhTdGFydDtcclxuICAgICAgICBjb25zdCB4RW5kID0gTWF0aC5taW4odGhpcy5fb25TY3JlZW5YRW5kLCB0aGlzLmNvbHMpO1xyXG4gICAgICAgIGxldCB5ID0gdGhpcy5fb25TY3JlZW5ZU3RhcnQ7XHJcbiAgICAgICAgY29uc3QgeUVuZCA9IE1hdGgubWluKHRoaXMuX29uU2NyZWVuWUVuZCwgdGhpcy5yb3dzKTtcclxuICAgICAgICBsZXQgZ3JhcGhpY3MsIGdyYXBoaWNzSW5kZXgsIGdyYXBoaWNzTGVuO1xyXG4gICAgICAgIGZvciAoeDsgeCA8IHhFbmQ7IHgrKykge1xyXG4gICAgICAgICAgICBmb3IgKHk7IHkgPCB5RW5kOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIC8vIGdldCBub24tbmVnYXRpdmUgdGlsZSBzcHJpdGVzXHJcbiAgICAgICAgICAgICAgICBncmFwaGljcyA9IHRoaXMuZ2V0Q2VsbCh4LCB5KS5ncmFwaGljcztcclxuICAgICAgICAgICAgICAgIGZvciAoZ3JhcGhpY3NJbmRleCA9IDAsIGdyYXBoaWNzTGVuID0gZ3JhcGhpY3MubGVuZ3RoOyBncmFwaGljc0luZGV4IDwgZ3JhcGhpY3NMZW47IGdyYXBoaWNzSW5kZXgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGRyYXcgc3ByaXRlLCB3YXJuaW5nIGlmIHNwcml0ZSBkb2Vzbid0IGV4aXN0XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZ3JhcGhpYyA9IGdyYXBoaWNzW2dyYXBoaWNzSW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChncmFwaGljKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGN0eCBpbnN0YW5jZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNHcmFwaGljc1RpY2soZ3JhcGhpYykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljID09PSBudWxsIHx8IGdyYXBoaWMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyYXBoaWMudGljayhkZWx0YSwgdGhpcy5fdG9rZW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYy5kcmF3KGN0eCwgeCAqIHRoaXMuY2VsbFdpZHRoLCB5ICogdGhpcy5jZWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChncmFwaGljIGluc3RhbmNlb2YgU3ByaXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGxlZ2FjeSBkcmF3aW5nIG1vZGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fbGVnYWN5U3ByaXRlTWFwLmhhcyhncmFwaGljKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlZ2FjeVNwcml0ZU1hcC5zZXQoZ3JhcGhpYywgU3ByaXRlLnRvTGVnYWN5U3ByaXRlKGdyYXBoaWMpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlZ2FjeVNwcml0ZU1hcC5nZXQoZ3JhcGhpYykuZHJhdyhjdHgsIHggKiB0aGlzLmNlbGxXaWR0aCwgeSAqIHRoaXMuY2VsbEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgeSA9IHRoaXMuX29uU2NyZWVuWVN0YXJ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkcmF3JywgbmV3IFBvc3REcmF3RXZlbnQoY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgfVxyXG59XHJcblRpbGVNYXBfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnTm8gbG9uZ2VyIHVzZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyB9KVxyXG5dLCBUaWxlTWFwSW1wbC5wcm90b3R5cGUsIFwicmVnaXN0ZXJTcHJpdGVTaGVldFwiLCBudWxsKTtcclxuLyoqXHJcbiAqIFRoZSBbW1RpbGVNYXBdXSBjbGFzcyBwcm92aWRlcyBhIGxpZ2h0d2VpZ2h0IHdheSB0byBkbyBsYXJnZSBjb21wbGV4IHNjZW5lcyB3aXRoIGNvbGxpc2lvblxyXG4gKiB3aXRob3V0IHRoZSBvdmVyaGVhZCBvZiBhY3RvcnMuXHJcbiAqL1xyXG5jbGFzcyBUaWxlTWFwIGV4dGVuZHMgQ29uZmlndXJhYmxlKFRpbGVNYXBJbXBsKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4T3JDb25maWcsIHksIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgcm93cywgY29scykge1xyXG4gICAgICAgIHN1cGVyKHhPckNvbmZpZywgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCByb3dzLCBjb2xzKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQGhpZGRlblxyXG4gKi9cclxuY2xhc3MgQ2VsbEltcGwgZXh0ZW5kcyBFbnRpdHkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0geE9yQ29uZmlnIEdldHMgb3Igc2V0cyB4IGNvb3JkaW5hdGUgb2YgdGhlIGNlbGwgaW4gd29ybGQgY29vcmRpbmF0ZXMgb3IgY2VsbCBvcHRpb24gYmFnXHJcbiAgICAgKiBAcGFyYW0geSAgICAgICBHZXRzIG9yIHNldHMgeSBjb29yZGluYXRlIG9mIHRoZSBjZWxsIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggICBHZXRzIG9yIHNldHMgdGhlIHdpZHRoIG9mIHRoZSBjZWxsXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0ICBHZXRzIG9yIHNldHMgdGhlIGhlaWdodCBvZiB0aGUgY2VsbFxyXG4gICAgICogQHBhcmFtIGluZGV4ICAgVGhlIGluZGV4IG9mIHRoZSBjZWxsIGluIHJvdyBtYWpvciBvcmRlclxyXG4gICAgICogQHBhcmFtIHNvbGlkICAgR2V0cyBvciBzZXRzIHdoZXRoZXIgdGhpcyBjZWxsIGlzIHNvbGlkXHJcbiAgICAgKiBAcGFyYW0gZ3JhcGhpY3MgVGhlIGxpc3Qgb2YgdGlsZSBncmFwaGljcyB0byB1c2UgdG8gZHJhdyBpbiB0aGlzIGNlbGwgKGluIG9yZGVyKVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQsIGluZGV4LCBzb2xpZCA9IGZhbHNlLCBncmFwaGljcyA9IFtdKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9zb2xpZCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgbGlzdCBvZiBncmFwaGljcyBmb3IgdGhpcyBjZWxsXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ncmFwaGljcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEFiaXRyYXJ5IGRhdGEgc3RvcmFnZSBwZXIgY2VsbCwgdXNlZnVsIGZvciBhbnkgZ2FtZSBzcGVjaWZpYyBkYXRhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIGlmICh4T3JDb25maWcgJiYgdHlwZW9mIHhPckNvbmZpZyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0geE9yQ29uZmlnO1xyXG4gICAgICAgICAgICB4T3JDb25maWcgPSBjb25maWcueDtcclxuICAgICAgICAgICAgeSA9IGNvbmZpZy55O1xyXG4gICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy53aWR0aDtcclxuICAgICAgICAgICAgaGVpZ2h0ID0gY29uZmlnLmhlaWdodDtcclxuICAgICAgICAgICAgaW5kZXggPSBjb25maWcuaW5kZXg7XHJcbiAgICAgICAgICAgIHNvbGlkID0gY29uZmlnLnNvbGlkO1xyXG4gICAgICAgICAgICBncmFwaGljcyA9IGNvbmZpZy5zcHJpdGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnggPSB4T3JDb25maWc7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuc29saWQgPSBzb2xpZDtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzID0gZ3JhcGhpY3M7XHJcbiAgICAgICAgdGhpcy5fYm91bmRzID0gbmV3IEJvdW5kaW5nQm94KHRoaXMueCwgdGhpcy55LCB0aGlzLnggKyB0aGlzLndpZHRoLCB0aGlzLnkgKyB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdldGhlciB0aGlzIGNlbGwgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgc29saWQgYnkgdGhlIHRpbGVtYXBcclxuICAgICAqL1xyXG4gICAgZ2V0IHNvbGlkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zb2xpZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2V0aGVyIHRoaXMgY2VsbCBzaG91bGQgYmUgdHJlYXRlZCBhcyBzb2xpZCBieSB0aGUgdGlsZW1hcFxyXG4gICAgICovXHJcbiAgICBzZXQgc29saWQodmFsKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIChfYSA9IHRoaXMubWFwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmxhZ0RpcnR5KCk7XHJcbiAgICAgICAgdGhpcy5fc29saWQgPSB2YWw7XHJcbiAgICB9XHJcbiAgICBnZXQgYm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XHJcbiAgICB9XHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCArIHRoaXMud2lkdGggLyAyLCB0aGlzLnkgKyB0aGlzLmhlaWdodCAvIDIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW5vdGhlciBbW1Nwcml0ZV1dIHRvIHRoaXMgY2VsbFxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGFkZFNwcml0ZSwgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICAgICAqL1xyXG4gICAgcHVzaFNwcml0ZShzcHJpdGUpIHtcclxuICAgICAgICB0aGlzLmFkZEdyYXBoaWMoc3ByaXRlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFub3RoZXIgW1tHcmFwaGljXV0gdG8gdGhpcyBUaWxlTWFwIGNlbGxcclxuICAgICAqIEBwYXJhbSBncmFwaGljXHJcbiAgICAgKi9cclxuICAgIGFkZEdyYXBoaWMoZ3JhcGhpYykge1xyXG4gICAgICAgIGlmIChncmFwaGljIGluc3RhbmNlb2YgU3ByaXRlX1Nwcml0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLnB1c2goU3ByaXRlLmZyb21MZWdhY3lTcHJpdGUoZ3JhcGhpYykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5wdXNoKGdyYXBoaWMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFuIGluc3RhbmNlIG9mIGEgW1tHcmFwaGljXV0gZnJvbSB0aGlzIGNlbGxcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlR3JhcGhpYyhncmFwaGljKSB7XHJcbiAgICAgICAgcmVtb3ZlSXRlbUZyb21BcnJheShncmFwaGljLCB0aGlzLmdyYXBoaWNzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXIgYWxsIGdyYXBoaXMgZnJvbSB0aGlzIGNlbGxcclxuICAgICAqL1xyXG4gICAgY2xlYXJHcmFwaGljcygpIHtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbn1cclxuVGlsZU1hcF9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7IG1lc3NhZ2U6ICdXaWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsIGFsdGVybmF0ZU1ldGhvZDogJ2FkZFNwcml0ZScgfSlcclxuXSwgQ2VsbEltcGwucHJvdG90eXBlLCBcInB1c2hTcHJpdGVcIiwgbnVsbCk7XHJcbi8qKlxyXG4gKiBUaWxlTWFwIENlbGxcclxuICpcclxuICogQSBsaWdodC13ZWlnaHQgb2JqZWN0IHRoYXQgb2NjdXBpZXMgYSBzcGFjZSBpbiBhIGNvbGxpc2lvbiBtYXAuIEdlbmVyYWxseVxyXG4gKiBjcmVhdGVkIGJ5IGEgW1tUaWxlTWFwXV0uXHJcbiAqXHJcbiAqIENlbGxzIGNhbiBkcmF3IG11bHRpcGxlIHNwcml0ZXMuIE5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgZHJhd2luZyBpcyB0aGUgb3JkZXJcclxuICogb2YgdGhlIHNwcml0ZXMgaW4gdGhlIGFycmF5IHNvIHRoZSBsYXN0IG9uZSB3aWxsIGJlIGRyYXduIG9uIHRvcC4gWW91IGNhblxyXG4gKiB1c2UgdHJhbnNwYXJlbmN5IHRvIGNyZWF0ZSBsYXllcnMgdGhpcyB3YXkuXHJcbiAqL1xyXG5jbGFzcyBDZWxsIGV4dGVuZHMgQ29uZmlndXJhYmxlKENlbGxJbXBsKSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4T3JDb25maWcsIHksIHdpZHRoLCBoZWlnaHQsIGluZGV4LCBzb2xpZCwgc3ByaXRlcykge1xyXG4gICAgICAgIHN1cGVyKHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCwgaW5kZXgsIHNvbGlkLCBzcHJpdGVzKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NhbWVyYS50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogQ29udGFpbmVyIHRvIGhvdXNlIGNvbnZlbmllbmNlIHN0cmF0ZWd5IG1ldGhvZHNcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5jbGFzcyBTdHJhdGVneUNvbnRhaW5lciB7XHJcbiAgICBjb25zdHJ1Y3RvcihjYW1lcmEpIHtcclxuICAgICAgICB0aGlzLmNhbWVyYSA9IGNhbWVyYTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgYWRkcyB0aGUgW1tMb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5XV0gb24gdGhlIGN1cnJlbnQgY2FtZXJhLlxyXG4gICAgICogQHBhcmFtIGFjdG9yIFRoZSBhY3RvciB0byBsb2NrIHRoZSBjYW1lcmEgdG9cclxuICAgICAqL1xyXG4gICAgbG9ja1RvQWN0b3IoYWN0b3IpIHtcclxuICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneShhY3RvcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW0xvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5XV0gb24gdGhlIGN1cnJlbnQgY2FtZXJhXHJcbiAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIGxvY2sgdGhlIGNhbWVyYSB0b1xyXG4gICAgICogQHBhcmFtIGF4aXMgVGhlIGF4aXMgdG8gZm9sbG93IHRoZSBhY3RvciBvblxyXG4gICAgICovXHJcbiAgICBsb2NrVG9BY3RvckF4aXMoYWN0b3IsIGF4aXMpIHtcclxuICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3koYWN0b3IsIGF4aXMpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgYWRkcyB0aGUgW1tFbGFzdGljVG9BY3RvclN0cmF0ZWd5XV0gb24gdGhlIGN1cnJlbnQgY2FtZXJhXHJcbiAgICAgKiBJZiBjYW1lcmFFbGFzdGljaXR5IDwgY2FtZXJhRnJpY3Rpb24gPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGEgZGFtcGVuZWQgc3ByaW5nIHRoYXQgd2lsbCBzbG93bHkgZW5kIGF0IHRoZSB0YXJnZXQgd2l0aG91dCBib3VuY2luZ1xyXG4gICAgICogSWYgY2FtZXJhRnJpY3Rpb24gPCBjYW1lcmFFbGFzdGljaXR5IDwgMS4wLCB0aGUgYmVoYXZpb3Igd2lsbCBiZSBhbiBvc2NpbGxhdGluZyBzcHJpbmcgdGhhdCB3aWxsIG92ZXJcclxuICAgICAqIGNvcnJlY3QgYW5kIGJvdW5jZSBhcm91bmQgdGhlIHRhcmdldFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhY3RvciBUYXJnZXQgYWN0b3IgdG8gZWxhc3RpY2FsbHkgZm9sbG93XHJcbiAgICAgKiBAcGFyYW0gY2FtZXJhRWxhc3RpY2l0eSBbMCAtIDEuMF0gVGhlIGhpZ2hlciB0aGUgZWxhc3RpY2l0eSB0aGUgbW9yZSBmb3JjZSB0aGF0IHdpbGwgZHJpdmUgdGhlIGNhbWVyYSB0b3dhcmRzIHRoZSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSBjYW1lcmFGcmljdGlvbiBbMCAtIDEuMF0gVGhlIGhpZ2hlciB0aGUgZnJpY3Rpb24gdGhlIG1vcmUgdGhhdCB0aGUgY2FtZXJhIHdpbGwgcmVzaXN0IG1vdGlvbiB0b3dhcmRzIHRoZSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgZWxhc3RpY1RvQWN0b3IoYWN0b3IsIGNhbWVyYUVsYXN0aWNpdHksIGNhbWVyYUZyaWN0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5jYW1lcmEuYWRkU3RyYXRlZ3kobmV3IEVsYXN0aWNUb0FjdG9yU3RyYXRlZ3koYWN0b3IsIGNhbWVyYUVsYXN0aWNpdHksIGNhbWVyYUZyaWN0aW9uKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgdGhlIFtbUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneV1dIG9uIHRoZSBjdXJyZW50IGNhbWVyYVxyXG4gICAgICogQHBhcmFtIGFjdG9yIFRhcmdldCBhY3RvciB0byBmb2xsb3cgd2hlbiBpdCBpcyBcInJhZGl1c1wiIHBpeGVscyBhd2F5XHJcbiAgICAgKiBAcGFyYW0gcmFkaXVzIE51bWJlciBvZiBwaXhlbHMgYXdheSBiZWZvcmUgdGhlIGNhbWVyYSB3aWxsIGZvbGxvd1xyXG4gICAgICovXHJcbiAgICByYWRpdXNBcm91bmRBY3RvcihhY3RvciwgcmFkaXVzKSB7XHJcbiAgICAgICAgdGhpcy5jYW1lcmEuYWRkU3RyYXRlZ3kobmV3IFJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3koYWN0b3IsIHJhZGl1cykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW0xpbWl0Q2FtZXJhQm91bmRzU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmFcclxuICAgICAqIEBwYXJhbSBib3ggVGhlIGJvdW5kaW5nIGJveCB0byBsaW1pdCB0aGUgY2FtZXJhIHRvLlxyXG4gICAgICovXHJcbiAgICBsaW1pdENhbWVyYUJvdW5kcyhib3gpIHtcclxuICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgTGltaXRDYW1lcmFCb3VuZHNTdHJhdGVneShib3gpKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FtZXJhIGF4aXMgZW51bVxyXG4gKi9cclxudmFyIEF4aXM7XHJcbihmdW5jdGlvbiAoQXhpcykge1xyXG4gICAgQXhpc1tBeGlzW1wiWFwiXSA9IDBdID0gXCJYXCI7XHJcbiAgICBBeGlzW0F4aXNbXCJZXCJdID0gMV0gPSBcIllcIjtcclxufSkoQXhpcyB8fCAoQXhpcyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBMb2NrIGEgY2FtZXJhIHRvIHRoZSBleGFjdCB4L3kgcG9zaXRpb24gb2YgYW4gYWN0b3IuXHJcbiAqL1xyXG5jbGFzcyBMb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gKHRhcmdldCwgX2NhbSwgX2VuZywgX2RlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IHRhcmdldC5jZW50ZXI7XHJcbiAgICAgICAgICAgIHJldHVybiBjZW50ZXI7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogTG9jayBhIGNhbWVyYSB0byBhIHNwZWNpZmljIGF4aXMgYXJvdW5kIGFuIGFjdG9yLlxyXG4gKi9cclxuY2xhc3MgTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3kge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBheGlzKSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5heGlzID0gYXhpcztcclxuICAgICAgICB0aGlzLmFjdGlvbiA9ICh0YXJnZXQsIGNhbSwgX2VuZywgX2RlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlciA9IHRhcmdldC5jZW50ZXI7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGb2N1cyA9IGNhbS5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5heGlzID09PSBBeGlzLlgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKGNlbnRlci54LCBjdXJyZW50Rm9jdXMueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihjdXJyZW50Rm9jdXMueCwgY2VudGVyLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVXNpbmcgW0hvb2sncyBsYXddKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hvb2tlJ3NfbGF3KSwgZWxhc3RpY2FsbHkgbW92ZSB0aGUgY2FtZXJhIHRvd2FyZHMgdGhlIHRhcmdldCBhY3Rvci5cclxuICovXHJcbmNsYXNzIEVsYXN0aWNUb0FjdG9yU3RyYXRlZ3kge1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBjYW1lcmFFbGFzdGljaXR5IDwgY2FtZXJhRnJpY3Rpb24gPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGEgZGFtcGVuZWQgc3ByaW5nIHRoYXQgd2lsbCBzbG93bHkgZW5kIGF0IHRoZSB0YXJnZXQgd2l0aG91dCBib3VuY2luZ1xyXG4gICAgICogSWYgY2FtZXJhRnJpY3Rpb24gPCBjYW1lcmFFbGFzdGljaXR5IDwgMS4wLCB0aGUgYmVoYXZpb3Igd2lsbCBiZSBhbiBvc2NpbGxhdGluZyBzcHJpbmcgdGhhdCB3aWxsIG92ZXJcclxuICAgICAqIGNvcnJlY3QgYW5kIGJvdW5jZSBhcm91bmQgdGhlIHRhcmdldFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXJnZXQgVGFyZ2V0IGFjdG9yIHRvIGVsYXN0aWNhbGx5IGZvbGxvd1xyXG4gICAgICogQHBhcmFtIGNhbWVyYUVsYXN0aWNpdHkgWzAgLSAxLjBdIFRoZSBoaWdoZXIgdGhlIGVsYXN0aWNpdHkgdGhlIG1vcmUgZm9yY2UgdGhhdCB3aWxsIGRyaXZlIHRoZSBjYW1lcmEgdG93YXJkcyB0aGUgdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0gY2FtZXJhRnJpY3Rpb24gWzAgLSAxLjBdIFRoZSBoaWdoZXIgdGhlIGZyaWN0aW9uIHRoZSBtb3JlIHRoYXQgdGhlIGNhbWVyYSB3aWxsIHJlc2lzdCBtb3Rpb24gdG93YXJkcyB0aGUgdGFyZ2V0XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgY2FtZXJhRWxhc3RpY2l0eSwgY2FtZXJhRnJpY3Rpb24pIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLmNhbWVyYUVsYXN0aWNpdHkgPSBjYW1lcmFFbGFzdGljaXR5O1xyXG4gICAgICAgIHRoaXMuY2FtZXJhRnJpY3Rpb24gPSBjYW1lcmFGcmljdGlvbjtcclxuICAgICAgICB0aGlzLmFjdGlvbiA9ICh0YXJnZXQsIGNhbSwgX2VuZywgX2RlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGFyZ2V0LmNlbnRlcjtcclxuICAgICAgICAgICAgbGV0IGZvY3VzID0gY2FtLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgIGxldCBjYW1lcmFWZWwgPSBjYW0udmVsLmNsb25lKCk7XHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgc3RyZXRjaCB2ZWN0b3IsIHVzaW5nIHRoZSBzcHJpbmcgZXF1YXRpb25cclxuICAgICAgICAgICAgLy8gRiA9IGtYXHJcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hvb2tlJ3NfbGF3XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHRvIHRoZSBjdXJyZW50IGNhbWVyYSB2ZWxvY2l0eVxyXG4gICAgICAgICAgICBjb25zdCBzdHJldGNoID0gcG9zaXRpb24uc3ViKGZvY3VzKS5zY2FsZSh0aGlzLmNhbWVyYUVsYXN0aWNpdHkpOyAvLyBzdHJldGNoIGlzIFhcclxuICAgICAgICAgICAgY2FtZXJhVmVsID0gY2FtZXJhVmVsLmFkZChzdHJldGNoKTtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBmcmljdGlvbiAoLTEgdG8gYXBwbHkgYSBmb3JjZSBpbiB0aGUgb3Bwb3NpdGlvbiBvZiBtb3Rpb24pXHJcbiAgICAgICAgICAgIC8vIEFwcGx5IHRvIHRoZSBjdXJyZW50IGNhbWVyYSB2ZWxvY2l0eVxyXG4gICAgICAgICAgICBjb25zdCBmcmljdGlvbiA9IGNhbWVyYVZlbC5zY2FsZSgtMSkuc2NhbGUodGhpcy5jYW1lcmFGcmljdGlvbik7XHJcbiAgICAgICAgICAgIGNhbWVyYVZlbCA9IGNhbWVyYVZlbC5hZGQoZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgcG9zaXRpb24gYnkgdmVsb2NpdHkgZGVsdGFzXHJcbiAgICAgICAgICAgIGZvY3VzID0gZm9jdXMuYWRkKGNhbWVyYVZlbCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmb2N1cztcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3kge1xyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgYWN0b3IgdG8gZm9sbG93IHdoZW4gaXQgaXMgXCJyYWRpdXNcIiBwaXhlbHMgYXdheVxyXG4gICAgICogQHBhcmFtIHJhZGl1cyBOdW1iZXIgb2YgcGl4ZWxzIGF3YXkgYmVmb3JlIHRoZSBjYW1lcmEgd2lsbCBmb2xsb3dcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCByYWRpdXMpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cztcclxuICAgICAgICB0aGlzLmFjdGlvbiA9ICh0YXJnZXQsIGNhbSwgX2VuZywgX2RlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gdGFyZ2V0LmNlbnRlcjtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXMgPSBjYW0uZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcG9zaXRpb24uc3ViKGZvY3VzKTtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBkaXJlY3Rpb24uc2l6ZTtcclxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID49IHRoaXMucmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBkaXN0YW5jZSAtIHRoaXMucmFkaXVzO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzLmFkZChkaXJlY3Rpb24ubm9ybWFsaXplKCkuc2NhbGUob2Zmc2V0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZvY3VzO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByZXZlbnQgYSBjYW1lcmEgZnJvbSBnb2luZyBiZXlvbmQgdGhlIGdpdmVuIGNhbWVyYSBkaW1lbnNpb25zLlxyXG4gKi9cclxuY2xhc3MgTGltaXRDYW1lcmFCb3VuZHNTdHJhdGVneSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBVc2VmdWwgZm9yIGxpbWl0aW5nIHRoZSBjYW1lcmEgdG8gYSBbW1RpbGVNYXBdXSdzIGRpbWVuc2lvbnMsIG9yIGEgc3BlY2lmaWMgYXJlYSBpbnNpZGUgdGhlIG1hcC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGlzIHN0cmF0ZWd5IGRvZXMgbm90IHBlcmZvcm0gYW55IG1vdmVtZW50IGJ5IGl0c2VsZi5cclxuICAgICAgICAgKiBJdCBvbmx5IHNldHMgdGhlIGNhbWVyYSBwb3NpdGlvbiB0byB3aXRoaW4gdGhlIGdpdmVuIGJvdW5kcyB3aGVuIHRoZSBjYW1lcmEgaGFzIGdvbmUgYmV5b25kIHRoZW0uXHJcbiAgICAgICAgICogVGh1cywgaXQgaXMgYSBnb29kIGlkZWEgdG8gY29tYmluZSBpdCB3aXRoIG90aGVyIGNhbWVyYSBzdHJhdGVnaWVzIGFuZCBzZXQgdGhpcyBzdHJhdGVneSBhcyB0aGUgbGFzdCBvbmUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBNYWtlIHN1cmUgdGhhdCB0aGUgY2FtZXJhIGJvdW5kcyBhcmUgYXQgbGVhc3QgYXMgbGFyZ2UgYXMgdGhlIHZpZXdwb3J0IHNpemUuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBAcGFyYW0gdGFyZ2V0IFRoZSBib3VuZGluZyBib3ggdG8gbGltaXQgdGhlIGNhbWVyYSB0b1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYm91bmRTaXplQ2hlY2tlZCA9IGZhbHNlOyAvLyBDaGVjayBhbmQgd2FybiBvbmx5IG9uY2VcclxuICAgICAgICB0aGlzLmFjdGlvbiA9ICh0YXJnZXQsIGNhbSwgX2VuZywgX2RlbHRhKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZvY3VzID0gY2FtLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5ib3VuZFNpemVDaGVja2VkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmJvdHRvbSAtIHRhcmdldC50b3AgPCBfZW5nLmRyYXdIZWlnaHQgfHwgdGFyZ2V0LnJpZ2h0IC0gdGFyZ2V0LmxlZnQgPCBfZW5nLmRyYXdXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0NhbWVyYSBib3VuZHMgc2hvdWxkIG5vdCBiZSBzbWFsbGVyIHRoYW4gdGhlIGVuZ2luZSB2aWV3cG9ydCcpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5ib3VuZFNpemVDaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgZm9jdXNYID0gZm9jdXMueDtcclxuICAgICAgICAgICAgbGV0IGZvY3VzWSA9IGZvY3VzLnk7XHJcbiAgICAgICAgICAgIGlmIChmb2N1cy54IDwgdGFyZ2V0LmxlZnQgKyBfZW5nLmhhbGZEcmF3V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGZvY3VzWCA9IHRhcmdldC5sZWZ0ICsgX2VuZy5oYWxmRHJhd1dpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZvY3VzLnggPiB0YXJnZXQucmlnaHQgLSBfZW5nLmhhbGZEcmF3V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGZvY3VzWCA9IHRhcmdldC5yaWdodCAtIF9lbmcuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZm9jdXMueSA8IHRhcmdldC50b3AgKyBfZW5nLmhhbGZEcmF3SGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBmb2N1c1kgPSB0YXJnZXQudG9wICsgX2VuZy5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChmb2N1cy55ID4gdGFyZ2V0LmJvdHRvbSAtIF9lbmcuaGFsZkRyYXdIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGZvY3VzWSA9IHRhcmdldC5ib3R0b20gLSBfZW5nLmhhbGZEcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB2ZWMoZm9jdXNYLCBmb2N1c1kpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENhbWVyYXNcclxuICpcclxuICogW1tDYW1lcmFdXSBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIEV4Y2FsaWJ1ciBjYW1lcmFzLiBDYW1lcmFzIGFyZSB1c2VkXHJcbiAqIHRvIG1vdmUgYXJvdW5kIHlvdXIgZ2FtZSBhbmQgc2V0IGZvY3VzLiBUaGV5IGFyZSB1c2VkIHRvIGRldGVybWluZVxyXG4gKiB3aGF0IGlzIFwib2ZmIHNjcmVlblwiIGFuZCBjYW4gYmUgdXNlZCB0byBzY2FsZSB0aGUgZ2FtZS5cclxuICpcclxuICovXHJcbmNsYXNzIENhbWVyYSBleHRlbmRzIENsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhU3RyYXRlZ2llcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBuZXcgU3RyYXRlZ3lDb250YWluZXIodGhpcyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IG9yIHNldCBjdXJyZW50IHpvb20gb2YgdGhlIGNhbWVyYSwgZGVmYXVsdHMgdG8gMVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3ogPSAxO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBvciBzZXQgcmF0ZSBvZiBjaGFuZ2UgaW4gem9vbSwgZGVmYXVsdHMgdG8gMFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZHogPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBvciBzZXQgem9vbSBhY2NlbGVyYXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmF6ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IHJvdGF0aW9uIG9mIHRoZSBjYW1lcmFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IGFuZ3VsYXIgdmVsb2NpdHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJ4ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgb3Igc2V0IHRoZSBjYW1lcmEncyBwb3NpdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX3Bvc0NoYW5nZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wb3MgPSB3YXRjaEFueShWZWN0b3IuWmVybywgKCkgPT4gKHRoaXMuX3Bvc0NoYW5nZWQgPSB0cnVlKSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IG9yIHNldCB0aGUgY2FtZXJhJ3MgdmVsb2NpdHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnZlbCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdFdCBvciBzZXQgdGhlIGNhbWVyYSdzIGFjY2VsZXJhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWNjID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSAxMDAwOyAvLyAxIHNlY29uZFxyXG4gICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbGVycEVuZCA9IG51bGw7XHJcbiAgICAgICAgLy9jYW1lcmEgZWZmZWN0c1xyXG4gICAgICAgIHRoaXMuX2lzU2hha2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWCA9IDA7XHJcbiAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVZID0gMDtcclxuICAgICAgICB0aGlzLl9zaGFrZUR1cmF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLl9lbGFwc2VkU2hha2VUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl94U2hha2UgPSAwO1xyXG4gICAgICAgIHRoaXMuX3lTaGFrZSA9IDA7XHJcbiAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fem9vbVN0YXJ0ID0gMTtcclxuICAgICAgICB0aGlzLl96b29tRW5kID0gMTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Wm9vbVRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX3pvb21EdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5fem9vbUVhc2luZyA9IEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYztcclxuICAgICAgICB0aGlzLl9lYXNpbmcgPSBFYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWM7XHJcbiAgICAgICAgdGhpcy5faGFsZldpZHRoID0gMDtcclxuICAgICAgICB0aGlzLl9oYWxmSGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLl92aWV3cG9ydCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHpvb20oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3o7XHJcbiAgICB9XHJcbiAgICBzZXQgem9vbSh2YWwpIHtcclxuICAgICAgICB0aGlzLl96ID0gdmFsO1xyXG4gICAgICAgIGlmICh0aGlzLl9lbmdpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFsZldpZHRoID0gdGhpcy5fZW5naW5lLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbGZIZWlnaHQgPSB0aGlzLl9lbmdpbmUuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBjYW1lcmEncyBhbmd1bGFyIHZlbG9jaXR5XHJcbiAgICAgKi9cclxuICAgIGdldCBhbmd1bGFyVmVsb2NpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucng7XHJcbiAgICB9XHJcbiAgICBzZXQgYW5ndWxhclZlbG9jaXR5KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5yeCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9zO1xyXG4gICAgfVxyXG4gICAgc2V0IHBvcyh2ZWMpIHtcclxuICAgICAgICB0aGlzLl9wb3MgPSB3YXRjaEFueSh2ZWMsICgpID0+ICh0aGlzLl9wb3NDaGFuZ2VkID0gdHJ1ZSkpO1xyXG4gICAgICAgIHRoaXMuX3Bvc0NoYW5nZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNhbWVyYSdzIHggcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0IHgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zLng7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY2FtZXJhJ3MgeCBwb3NpdGlvbiAoY2Fubm90IGJlIHNldCB3aGVuIGZvbGxvd2luZyBhbiBbW0FjdG9yXV0gb3Igd2hlbiBtb3ZpbmcpXHJcbiAgICAgKi9cclxuICAgIHNldCB4KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mb2xsb3cgJiYgIXRoaXMuX2NhbWVyYU1vdmluZykge1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IHZlYyh2YWx1ZSwgdGhpcy5wb3MueSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNhbWVyYSdzIHkgcG9zaXRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0IHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zLnk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgY2FtZXJhJ3MgeSBwb3NpdGlvbiAoY2Fubm90IGJlIHNldCB3aGVuIGZvbGxvd2luZyBhbiBbW0FjdG9yXV0gb3Igd2hlbiBtb3ZpbmcpXHJcbiAgICAgKi9cclxuICAgIHNldCB5KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9mb2xsb3cgJiYgIXRoaXMuX2NhbWVyYU1vdmluZykge1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IHZlYyh0aGlzLnBvcy54LCB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBjYW1lcmEncyB4IHZlbG9jaXR5XHJcbiAgICAgKi9cclxuICAgIGdldCBkeCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52ZWwueDtcclxuICAgIH1cclxuICAgIHNldCBkeCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmVsID0gdmVjKHZhbHVlLCB0aGlzLnZlbC55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgY2FtZXJhJ3MgeSB2ZWxvY2l0eVxyXG4gICAgICovXHJcbiAgICBnZXQgZHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudmVsLnk7XHJcbiAgICB9XHJcbiAgICBzZXQgZHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnZlbCA9IHZlYyh0aGlzLnZlbC54LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIGNhbWVyYSdzIHggYWNjZWxlcmF0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldCBheCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY2MueDtcclxuICAgIH1cclxuICAgIHNldCBheCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuYWNjID0gdmVjKHZhbHVlLCB0aGlzLmFjYy55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgY2FtZXJhJ3MgeSBhY2NlbGVyYXRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0IGF5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjYy55O1xyXG4gICAgfVxyXG4gICAgc2V0IGF5KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5hY2MgPSB2ZWModGhpcy5hY2MueCwgdmFsdWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBmb2NhbCBwb2ludCBvZiB0aGUgY2FtZXJhLCBhIG5ldyBwb2ludCBnaXZpbmcgdGhlIHggYW5kIHkgcG9zaXRpb24gb2YgdGhlIGNhbWVyYVxyXG4gICAgICovXHJcbiAgICBnZXRGb2N1cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbW92ZXMgdGhlIGNhbWVyYSBmb2NhbCBwb2ludCB0byB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uIHVzaW5nIHNwZWNpZmllZCBlYXNpbmcgZnVuY3Rpb24uIENhbm5vdCBtb3ZlIHdoZW4gZm9sbG93aW5nIGFuIEFjdG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwb3MgVGhlIHRhcmdldCBwb3NpdGlvbiB0byBtb3ZlIHRvXHJcbiAgICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcyB0aGUgbW92ZSBzaG91bGQgbGFzdFxyXG4gICAgICogQHBhcmFtIFtlYXNpbmdGbl0gQW4gb3B0aW9uYWwgZWFzaW5nIGZ1bmN0aW9uIChbW2V4LkVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpY11dIGJ5IGRlZmF1bHQpXHJcbiAgICAgKiBAcmV0dXJucyBBIFtbUHJvbWlzZV1dIHRoYXQgcmVzb2x2ZXMgd2hlbiBtb3ZlbWVudCBpcyBmaW5pc2hlZCwgaW5jbHVkaW5nIGlmIGl0J3MgaW50ZXJydXB0ZWQuXHJcbiAgICAgKiAgICAgICAgICBUaGUgW1tQcm9taXNlXV0gdmFsdWUgaXMgdGhlIFtbVmVjdG9yXV0gb2YgdGhlIHRhcmdldCBwb3NpdGlvbi4gSXQgd2lsbCBiZSByZWplY3RlZCBpZiBhIG1vdmUgY2Fubm90IGJlIG1hZGUuXHJcbiAgICAgKi9cclxuICAgIG1vdmUocG9zLCBkdXJhdGlvbiwgZWFzaW5nRm4gPSBFYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWMpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGVhc2luZ0ZuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93ICdQbGVhc2Ugc3BlY2lmeSBhbiBFYXNpbmdGdW5jdGlvbic7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNhbm5vdCBtb3ZlIHdoZW4gZm9sbG93aW5nIGFuIGFjdG9yXHJcbiAgICAgICAgaWYgKHRoaXMuX2ZvbGxvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocG9zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gcmVzb2x2ZSBleGlzdGluZyBwcm9taXNlLCBpZiBhbnlcclxuICAgICAgICBpZiAodGhpcy5fbGVycFByb21pc2UgJiYgdGhpcy5fbGVycFJlc29sdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbGVycFJlc29sdmUocG9zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGVycFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwUmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gdGhpcy5nZXRGb2N1cygpLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5fbGVycER1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5fbGVycEVuZCA9IHBvcztcclxuICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYU1vdmluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fZWFzaW5nID0gZWFzaW5nRm47XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlcnBQcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBjYW1lcmEgdG8gc2hha2UgYXQgdGhlIHNwZWNpZmllZCBtYWduaXR1ZGVzIGZvciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uXHJcbiAgICAgKiBAcGFyYW0gbWFnbml0dWRlWCAgVGhlIHggbWFnbml0dWRlIG9mIHRoZSBzaGFrZVxyXG4gICAgICogQHBhcmFtIG1hZ25pdHVkZVkgIFRoZSB5IG1hZ25pdHVkZSBvZiB0aGUgc2hha2VcclxuICAgICAqIEBwYXJhbSBkdXJhdGlvbiAgICBUaGUgZHVyYXRpb24gb2YgdGhlIHNoYWtlIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICovXHJcbiAgICBzaGFrZShtYWduaXR1ZGVYLCBtYWduaXR1ZGVZLCBkdXJhdGlvbikge1xyXG4gICAgICAgIHRoaXMuX2lzU2hha2luZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVYID0gbWFnbml0dWRlWDtcclxuICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVkgPSBtYWduaXR1ZGVZO1xyXG4gICAgICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogWm9vbXMgdGhlIGNhbWVyYSBpbiBvciBvdXQgYnkgdGhlIHNwZWNpZmllZCBzY2FsZSBvdmVyIHRoZSBzcGVjaWZpZWQgZHVyYXRpb24uXHJcbiAgICAgKiBJZiBubyBkdXJhdGlvbiBpcyBzcGVjaWZpZWQsIGl0IHRha2UgZWZmZWN0IGltbWVkaWF0ZWx5LlxyXG4gICAgICogQHBhcmFtIHNjYWxlICAgIFRoZSBzY2FsZSBvZiB0aGUgem9vbVxyXG4gICAgICogQHBhcmFtIGR1cmF0aW9uIFRoZSBkdXJhdGlvbiBvZiB0aGUgem9vbSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgem9vbU92ZXJUaW1lKHNjYWxlLCBkdXJhdGlvbiA9IDAsIGVhc2luZ0ZuID0gRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dEN1YmljKSB7XHJcbiAgICAgICAgdGhpcy5fem9vbVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl96b29tUmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvb21FYXNpbmcgPSBlYXNpbmdGbjtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFpvb21UaW1lID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fem9vbUR1cmF0aW9uID0gZHVyYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX3pvb21TdGFydCA9IHRoaXMuem9vbTtcclxuICAgICAgICAgICAgdGhpcy5fem9vbUVuZCA9IHNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuem9vbSA9IHNjYWxlO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fem9vbVByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdmlld3BvcnQgb2YgdGhpcyBjYW1lcmEgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgZ2V0IHZpZXdwb3J0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl92aWV3cG9ydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goMCwgMCwgMCwgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgY2FtZXJhIHN0cmF0ZWd5IHRvIHRoaXMgY2FtZXJhXHJcbiAgICAgKiBAcGFyYW0gY2FtZXJhU3RyYXRlZ3kgSW5zdGFuY2Ugb2YgYW4gW1tDYW1lcmFTdHJhdGVneV1dXHJcbiAgICAgKi9cclxuICAgIGFkZFN0cmF0ZWd5KGNhbWVyYVN0cmF0ZWd5KSB7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhU3RyYXRlZ2llcy5wdXNoKGNhbWVyYVN0cmF0ZWd5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGNhbWVyYSBzdHJhdGVneSBieSByZWZlcmVuY2VcclxuICAgICAqIEBwYXJhbSBjYW1lcmFTdHJhdGVneSBJbnN0YW5jZSBvZiBhbiBbW0NhbWVyYVN0cmF0ZWd5XV1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlU3RyYXRlZ3koY2FtZXJhU3RyYXRlZ3kpIHtcclxuICAgICAgICByZW1vdmVJdGVtRnJvbUFycmF5KGNhbWVyYVN0cmF0ZWd5LCB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGFsbCBjYW1lcmEgc3RyYXRlZ2llcyBmcm9tIHRoZSBjYW1lcmFcclxuICAgICAqL1xyXG4gICAgY2xlYXJBbGxTdHJhdGVnaWVzKCkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYVN0cmF0ZWdpZXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJldXBkYXRlIGhhbmRsZXIgZm9yIFtbb25QcmVVcGRhdGVdXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcHJldXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBQcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblByZVVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblByZVVwZGF0ZSBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3ByZXVwZGF0ZScsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblByZVVwZGF0ZWAgaXMgY2FsbGVkIGRpcmVjdGx5IGJlZm9yZSBhIHNjZW5lIGlzIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIG9uUHJlVXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRhYmxlXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wcmV1cGRhdGUgaGFuZGxlciBmb3IgW1tvblBvc3RVcGRhdGVdXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcG9zdHVwZGF0ZShlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0dXBkYXRlJywgbmV3IFBvc3RVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblBvc3RVcGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25Qb3N0VXBkYXRlIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncHJldXBkYXRlJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUG9zdFVwZGF0ZWAgaXMgY2FsbGVkIGRpcmVjdGx5IGFmdGVyIGEgc2NlbmUgaXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgb25Qb3N0VXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRhYmxlXHJcbiAgICB9XHJcbiAgICBnZXQgaXNJbml0aWFsaXplZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZDtcclxuICAgIH1cclxuICAgIF9pbml0aWFsaXplKF9lbmdpbmUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUgPSBfZW5naW5lO1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50UmVzID0gdGhpcy5fZW5naW5lLnNjcmVlbi5yZXNvbHV0aW9uO1xyXG4gICAgICAgICAgICBsZXQgY2VudGVyID0gdmVjKGN1cnJlbnRSZXMud2lkdGggLyAyLCBjdXJyZW50UmVzLmhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2VuZ2luZS5sb2FkaW5nQ29tcGxldGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIHdhcyBhIGxvYWRpbmcgc2NyZWVuLCB3ZSBwZWVrIHRoZSBjb25maWd1cmVkIHJlc29sdXRpb25cclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHRoaXMuX2VuZ2luZS5zY3JlZW4ucGVla1Jlc29sdXRpb24oKTtcclxuICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjZW50ZXIgPSB2ZWMocmVzLndpZHRoIC8gMiwgcmVzLmhlaWdodCAvIDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbGZXaWR0aCA9IGNlbnRlci54O1xyXG4gICAgICAgICAgICB0aGlzLl9oYWxmSGVpZ2h0ID0gY2VudGVyLng7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSB1c2VyIGhhcyBub3Qgc2V0IHRoZSBjYW1lcmEgcG9zLCBhcHBseSBkZWZhdWx0IGNlbnRlciBzY3JlZW4gcG9zaXRpb25cclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wb3NDaGFuZ2VkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGNlbnRlcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLm9uSW5pdGlhbGl6ZShfZW5naW5lKTtcclxuICAgICAgICAgICAgc3VwZXIuZW1pdCgnaW5pdGlhbGl6ZScsIG5ldyBJbml0aWFsaXplRXZlbnQoX2VuZ2luZSwgdGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25Qb3N0VXBkYXRlIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncHJldXBkYXRlJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUG9zdFVwZGF0ZWAgaXMgY2FsbGVkIGRpcmVjdGx5IGFmdGVyIGEgc2NlbmUgaXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgb25Jbml0aWFsaXplKF9lbmdpbmUpIHtcclxuICAgICAgICAvLyBPdmVycmlkYWJsZVxyXG4gICAgfVxyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub25jZShldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9lbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZShfZW5naW5lKTtcclxuICAgICAgICB0aGlzLl9wcmV1cGRhdGUoX2VuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgIC8vIFVwZGF0ZSBwbGFjZW1lbnRzIGJhc2VkIG9uIGxpbmVhciBhbGdlYnJhXHJcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnBvcy5hZGQodGhpcy52ZWwuc2NhbGUoZGVsdGEgLyAxMDAwKSk7XHJcbiAgICAgICAgdGhpcy56b29tICs9ICh0aGlzLmR6ICogZGVsdGEpIC8gMTAwMDtcclxuICAgICAgICB0aGlzLnZlbCA9IHRoaXMudmVsLmFkZCh0aGlzLmFjYy5zY2FsZShkZWx0YSAvIDEwMDApKTtcclxuICAgICAgICB0aGlzLmR6ICs9ICh0aGlzLmF6ICogZGVsdGEpIC8gMTAwMDtcclxuICAgICAgICB0aGlzLnJvdGF0aW9uICs9ICh0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIGRlbHRhKSAvIDEwMDA7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzWm9vbWluZykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFpvb21UaW1lIDwgdGhpcy5fem9vbUR1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB6b29tRWFzaW5nID0gdGhpcy5fem9vbUVhc2luZztcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1pvb20gPSB6b29tRWFzaW5nKHRoaXMuX2N1cnJlbnRab29tVGltZSwgdGhpcy5fem9vbVN0YXJ0LCB0aGlzLl96b29tRW5kLCB0aGlzLl96b29tRHVyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tID0gbmV3Wm9vbTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRab29tVGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzWm9vbWluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy56b29tID0gdGhpcy5fem9vbUVuZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRab29tVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl96b29tUmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fY2FtZXJhTW92aW5nKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50TGVycFRpbWUgPCB0aGlzLl9sZXJwRHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG1vdmVFYXNpbmcgPSBFYXNpbmdGdW5jdGlvbnMuQ3JlYXRlVmVjdG9yRWFzaW5nRnVuY3Rpb24odGhpcy5fZWFzaW5nKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGxlcnBQb2ludCA9IG1vdmVFYXNpbmcodGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwU3RhcnQsIHRoaXMuX2xlcnBFbmQsIHRoaXMuX2xlcnBEdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IGxlcnBQb2ludDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gdGhpcy5fbGVycEVuZDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX2xlcnBFbmQuY2xvbmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXJwRW5kID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW1lcmFNb3ZpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIC8vIE9yZGVyIG1hdHRlcnMgaGVyZSwgcmVzb2x2ZSBzaG91bGQgYmUgbGFzdCBzbyBhbnkgY2hhaW4gcHJvbWlzZXMgaGF2ZSBhIGNsZWFuIHNsYXRlXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZXJwUmVzb2x2ZShlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9pc0RvbmVTaGFraW5nKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNTaGFraW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRTaGFrZVRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zaGFrZUR1cmF0aW9uID0gMDtcclxuICAgICAgICAgICAgdGhpcy5feFNoYWtlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5feVNoYWtlID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRTaGFrZVRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgIHRoaXMuX3hTaGFrZSA9ICgoTWF0aC5yYW5kb20oKSAqIHRoaXMuX3NoYWtlTWFnbml0dWRlWCkgfCAwKSArIDE7XHJcbiAgICAgICAgICAgIHRoaXMuX3lTaGFrZSA9ICgoTWF0aC5yYW5kb20oKSAqIHRoaXMuX3NoYWtlTWFnbml0dWRlWSkgfCAwKSArIDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gcy5hY3Rpb24uY2FsbChzLCBzLnRhcmdldCwgdGhpcywgX2VuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl92aWV3cG9ydCA9IG5ldyBCb3VuZGluZ0JveCh0aGlzLnggLSB0aGlzLl9oYWxmV2lkdGgsIHRoaXMueSAtIHRoaXMuX2hhbGZIZWlnaHQsIHRoaXMueCArIHRoaXMuX2hhbGZXaWR0aCwgdGhpcy55ICsgdGhpcy5faGFsZkhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fcG9zdHVwZGF0ZShfZW5naW5lLCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICBkcmF3KGN0eCkge1xyXG4gICAgICAgIGxldCBjYW52YXNXaWR0aCA9IDA7XHJcbiAgICAgICAgbGV0IGNhbnZhc0hlaWdodCA9IDA7XHJcbiAgICAgICAgaWYgKGN0eCBpbnN0YW5jZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICAgICAgICBjYW52YXNXaWR0aCA9IGN0eC5jYW52YXMud2lkdGg7XHJcbiAgICAgICAgICAgIGNhbnZhc0hlaWdodCA9IGN0eC5jYW52YXMuaGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY2FudmFzV2lkdGggPSBjdHgud2lkdGg7XHJcbiAgICAgICAgICAgIGNhbnZhc0hlaWdodCA9IGN0eC5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZvY3VzID0gdGhpcy5nZXRGb2N1cygpO1xyXG4gICAgICAgIGNvbnN0IHBpeGVsUmF0aW8gPSB0aGlzLl9lbmdpbmUgPyB0aGlzLl9lbmdpbmUucGl4ZWxSYXRpbyA6IDE7XHJcbiAgICAgICAgY29uc3Qgem9vbSA9IHRoaXMuem9vbTtcclxuICAgICAgICBjb25zdCBuZXdDYW52YXNXaWR0aCA9IGNhbnZhc1dpZHRoIC8gem9vbSAvIHBpeGVsUmF0aW87XHJcbiAgICAgICAgY29uc3QgbmV3Q2FudmFzSGVpZ2h0ID0gY2FudmFzSGVpZ2h0IC8gem9vbSAvIHBpeGVsUmF0aW87XHJcbiAgICAgICAgY3R4LnNjYWxlKHpvb20sIHpvb20pO1xyXG4gICAgICAgIGN0eC50cmFuc2xhdGUoLWZvY3VzLnggKyBuZXdDYW52YXNXaWR0aCAvIDIgKyB0aGlzLl94U2hha2UsIC1mb2N1cy55ICsgbmV3Q2FudmFzSGVpZ2h0IC8gMiArIHRoaXMuX3lTaGFrZSk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgZGVidWdEcmF3KF9jdHgpIHtcclxuICAgICAgICAvLyBwYXNzXHJcbiAgICB9XHJcbiAgICBfaXNEb25lU2hha2luZygpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuX2lzU2hha2luZyB8fCB0aGlzLl9lbGFwc2VkU2hha2VUaW1lID49IHRoaXMuX3NoYWtlRHVyYXRpb247XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL0FjdG9ycy50c1xuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgZ3VhcmQgdG8gZGV0ZWN0IGlmIHNvbWV0aGluZyBpcyBhbiBhY3RvclxyXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKiBAcGFyYW0gYWN0b3JcclxuICovXHJcbmZ1bmN0aW9uIGlzVmFuaWxsYUFjdG9yKGFjdG9yKSB7XHJcbiAgICByZXR1cm4gIShhY3RvciBpbnN0YW5jZW9mIFNjcmVlbkVsZW1lbnQpICYmICEoYWN0b3IgaW5zdGFuY2VvZiBUcmlnZ2VyKSAmJiAhKGFjdG9yIGluc3RhbmNlb2YgTGFiZWwpO1xyXG59XHJcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIHRvIGRldGVjdCBhIHNjcmVlbiBlbGVtZW50XHJcbiAqIEB0b2RvIG1vdmUgdG8gU2NyZWVuRWxlbWVudFxyXG4gKi9cclxuZnVuY3Rpb24gaXNTY3JlZW5FbGVtZW50KGFjdG9yKSB7XHJcbiAgICByZXR1cm4gYWN0b3IgaW5zdGFuY2VvZiBTY3JlZW5FbGVtZW50X1NjcmVlbkVsZW1lbnQ7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9UcmlnZ2VyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3QgdHJpZ2dlckRlZmF1bHRzID0ge1xyXG4gICAgcG9zOiBWZWN0b3IuWmVybyxcclxuICAgIHdpZHRoOiAxMCxcclxuICAgIGhlaWdodDogMTAsXHJcbiAgICB2aXNpYmxlOiBmYWxzZSxcclxuICAgIGFjdGlvbjogKCkgPT4ge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH0sXHJcbiAgICBmaWx0ZXI6ICgpID0+IHRydWUsXHJcbiAgICByZXBlYXQ6IC0xXHJcbn07XHJcbi8qKlxyXG4gKiBUcmlnZ2VycyBhcmUgYSBtZXRob2Qgb2YgZmlyaW5nIGFyYml0cmFyeSBjb2RlIG9uIGNvbGxpc2lvbi4gVGhlc2UgYXJlIHVzZWZ1bFxyXG4gKiBhcyAnYnV0dG9ucycsICdzd2l0Y2hlcycsIG9yIHRvIHRyaWdnZXIgZWZmZWN0cyBpbiBhIGdhbWUuIEJ5IGRlZmF1bHQgdHJpZ2dlcnNcclxuICogYXJlIGludmlzaWJsZSwgYW5kIGNhbiBvbmx5IGJlIHNlZW4gd2hlbiBbW1RyaWdnZXIudmlzaWJsZV1dIGlzIHNldCB0byBgdHJ1ZWAuXHJcbiAqL1xyXG5jbGFzcyBUcmlnZ2VyX1RyaWdnZXIgZXh0ZW5kcyBBY3RvciB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0cyBUcmlnZ2VyIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0cykge1xyXG4gICAgICAgIHN1cGVyKHsgeDogb3B0cy5wb3MueCwgeTogb3B0cy5wb3MueSwgd2lkdGg6IG9wdHMud2lkdGgsIGhlaWdodDogb3B0cy5oZWlnaHQgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWN0aW9uIHRvIGZpcmUgd2hlbiB0cmlnZ2VyZWQgYnkgY29sbGlzaW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY3Rpb24gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbHRlciB0byBhZGQgYWRkaXRpb25hbCBncmFudWxhcml0eSB0byBhY3Rpb24gZGlzcGF0Y2gsIGlmIGEgZmlsdGVyIGlzIHNwZWNpZmllZCB0aGUgYWN0aW9uIHdpbGwgb25seSBmaXJlIHdoZW5cclxuICAgICAgICAgKiBmaWx0ZXIgcmV0dXJuIHRydWUgZm9yIHRoZSBjb2xsaWRlZCBhY3Rvci5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZpbHRlciA9ICgpID0+IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCBiZWZvcmUga2lsbGluZyB0aGUgdHJpZ2dlcixcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlcGVhdCA9IC0xO1xyXG4gICAgICAgIG9wdHMgPSBleHRlbmQoe30sIHRyaWdnZXJEZWZhdWx0cywgb3B0cyk7XHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSBvcHRzLmZpbHRlciB8fCB0aGlzLmZpbHRlcjtcclxuICAgICAgICB0aGlzLnJlcGVhdCA9IG9wdHMucmVwZWF0IHx8IHRoaXMucmVwZWF0O1xyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gb3B0cy5hY3Rpb24gfHwgdGhpcy5hY3Rpb247XHJcbiAgICAgICAgaWYgKG9wdHMudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gb3B0cy50YXJnZXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MudmlzaWJsZSA9IG9wdHMudmlzaWJsZTtcclxuICAgICAgICB0aGlzLmJvZHkuY29sbGlzaW9uVHlwZSA9IENvbGxpc2lvblR5cGUuUGFzc2l2ZTtcclxuICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlciA9IG5ldyBFdmVudERpc3BhdGNoZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NvbGxpc2lvbnN0YXJ0JywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXIoZXZ0Lm90aGVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdlbnRlcicsIG5ldyBFbnRlclRyaWdnZXJFdmVudCh0aGlzLCBldnQub3RoZXIpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoQWN0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgdHJpZ2dlciBpZiBpdHMgZG9uZSwgLTEgcmVwZWF0IGZvcmV2ZXJcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMua2lsbCgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NvbGxpc2lvbmVuZCcsIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZmlsdGVyKGV2dC5vdGhlcikpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXhpdCcsIG5ldyBFeGl0VHJpZ2dlckV2ZW50KHRoaXMsIGV2dC5vdGhlcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZXQgdGFyZ2V0KHRhcmdldCkge1xyXG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLmZpbHRlciA9IChhY3RvcikgPT4gYWN0b3IgPT09IHRhcmdldDtcclxuICAgIH1cclxuICAgIGdldCB0YXJnZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RhcmdldDtcclxuICAgIH1cclxuICAgIF9pbml0aWFsaXplKGVuZ2luZSkge1xyXG4gICAgICAgIHN1cGVyLl9pbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICB9XHJcbiAgICBfZGlzcGF0Y2hBY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmVwZWF0ICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0aW9uLmNhbGwodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0LS07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGRlYnVnRHJhdyhjdHgpIHtcclxuICAgICAgICBzdXBlci5kZWJ1Z0RyYXcoY3R4KTtcclxuICAgICAgICAvLyBNZWFudCB0byBkcmF3IGRlYnVnIGluZm9ybWF0aW9uIGFib3V0IGFjdG9yc1xyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnBvcy54LCB0aGlzLnBvcy55KTtcclxuICAgICAgICBjb25zdCBiYiA9IHRoaXMuY29sbGlkZXIuYm91bmRzO1xyXG4gICAgICAgIGNvbnN0IHdwID0gdGhpcy5nZXRHbG9iYWxQb3MoKTtcclxuICAgICAgICBiYi5sZWZ0ID0gYmIubGVmdCAtIHdwLng7XHJcbiAgICAgICAgYmIucmlnaHQgPSBiYi5yaWdodCAtIHdwLng7XHJcbiAgICAgICAgYmIudG9wID0gYmIudG9wIC0gd3AueTtcclxuICAgICAgICBiYi5ib3R0b20gPSBiYi5ib3R0b20gLSB3cC55O1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvci5WaW9sZXQudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBDb2xvci5WaW9sZXQudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguZmlsbFRleHQoJ1RyaWdnZXInLCAxMCwgMTApO1xyXG4gICAgICAgIGJiLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FbnRpdHlDb21wb25lbnRTeXN0ZW0vU3lzdGVtLnRzXG4vKipcclxuICogRW51bSB0aGF0IGRldGVybWluZXMgd2hldGhlciB0byBydW4gdGhlIHN5c3RlbSBpbiB0aGUgdXBkYXRlIG9yIGRyYXcgcGhhc2VcclxuICovXHJcbnZhciBTeXN0ZW1UeXBlO1xyXG4oZnVuY3Rpb24gKFN5c3RlbVR5cGUpIHtcclxuICAgIFN5c3RlbVR5cGVbXCJVcGRhdGVcIl0gPSBcInVwZGF0ZVwiO1xyXG4gICAgU3lzdGVtVHlwZVtcIkRyYXdcIl0gPSBcImRyYXdcIjtcclxufSkoU3lzdGVtVHlwZSB8fCAoU3lzdGVtVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBBbiBFeGNhbGlidXIgW1tTeXN0ZW1dXSB0aGF0IHVwZGF0ZXMgZW50aXRpZXMgb2YgY2VydGFpbiB0eXBlcy5cclxuICogU3lzdGVtcyBhcmUgc2NlbmUgc3BlY2lmaWNcclxuICpcclxuICogRXhjYWxpYnVyIFN5c3RlbXMgY3VycmVudGx5IHJlcXVpcmUgYXQgbGVhc3QgMSBDb21wb25lbnQgdHlwZSB0byBvcGVyYXRlZFxyXG4gKlxyXG4gKiBNdWx0aXBsZSB0eXBlcyBhcmUgZGVjbGFyZWQgYXMgYSB0eXBlIHVuaW9uXHJcbiAqIEZvciBleGFtcGxlOlxyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15U3lzdGVtIGV4dGVuZHMgU3lzdGVtPENvbXBvbmVudEEgfCBDb21wb25lbnRCPiB7XHJcbiAqICAgcHVibGljIHJlYWRvbmx5IHR5cGVzID0gWydhJywgJ2InXSBhcyBjb25zdDtcclxuICogICBwdWJsaWMgcmVhZG9ubHkgc3lzdGVtVHlwZSA9IFN5c3RlbVR5cGUuVXBkYXRlO1xyXG4gKiAgIHB1YmxpYyB1cGRhdGUoZW50aXRpZXM6IEVudGl0eTxDb21wb25lbnRBIHwgQ29tcG9uZW50Qj4pIHtcclxuICogICAgICAuLi5cclxuICogICB9XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5jbGFzcyBTeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3lzdGVtIGNhbiBleGVjdXRlIGluIHByaW9yaXR5IG9yZGVyLCBieSBkZWZhdWx0IGFsbCBzeXN0ZW1zIGFyZSBwcmlvcml0eSAwLiBMb3dlciB2YWx1ZXMgaW5kaWNhdGVkIGhpZ2hlciBwcmlvcml0eS5cclxuICAgICAgICAgKiBGb3IgYSBzeXN0ZW0gdG8gZXhlY3V0ZSBiZWZvcmUgYWxsIG90aGVyIGEgbG93ZXIgcHJpb3JpdHkgdmFsdWUgKC0xIGZvciBleGFtcGxlKSBtdXN0IGJlIHNldC5cclxuICAgICAgICAgKiBGb3IgYSBzeXN0ZW0gdG8gZXhlY3R1ZSBhZnRlciBhbGwgb3RoZXIgYSBoaWdoZXIgcHJpb3JpdHkgdmFsdWUgKDEwIGZvciBleGFtcGxlKSBtdXN0IGJlIHNldC5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3lzdGVtcyBvYnNlcnZlIHdoZW4gZW50aXRpZXMgbWF0Y2ggdGhlaXIgdHlwZXMgb3Igbm8gbG9uZ2VyIG1hdGNoIHRoZWlyIHR5cGVzLCBvdmVycmlkZVxyXG4gICAgICogQHBhcmFtIF9lbnRpdHlBZGRlZE9yUmVtb3ZlZFxyXG4gICAgICovXHJcbiAgICBub3RpZnkoX2VudGl0eUFkZGVkT3JSZW1vdmVkKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQW4gW1tFbnRpdHldXSB3aXRoIFtbQ29tcG9uZW50XV0gdHlwZXMgdGhhdCBtYXRjaGVzIGEgW1tTeXN0ZW1dXSB0eXBlcyBleGlzdHMgaW4gdGhlIGN1cnJlbnQgc2NlbmUuXHJcbiAqL1xyXG5jbGFzcyBBZGRlZEVudGl0eSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnRW50aXR5IEFkZGVkJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVHlwZSBndWFyZCB0byBjaGVjayBmb3IgQWRkZWRFbnRpdHkgbWVzc2FnZXNcclxuICogQHBhcmFtIHhcclxuICovXHJcbmZ1bmN0aW9uIGlzQWRkZWRTeXN0ZW1FbnRpdHkoeCkge1xyXG4gICAgcmV0dXJuICEheCAmJiB4LnR5cGUgPT09ICdFbnRpdHkgQWRkZWQnO1xyXG59XHJcbi8qKlxyXG4gKiBBbiBbW0VudGl0eV1dIHdpdGggW1tDb21wb25lbnRdXSB0eXBlcyB0aGF0IG5vIGxvbmdlciBtYXRjaGVzIGEgW1tTeXN0ZW1dXSB0eXBlcyBleGlzdHMgaW4gdGhlIGN1cnJlbnQgc2NlbmUuXHJcbiAqL1xyXG5jbGFzcyBSZW1vdmVkRW50aXR5IHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdFbnRpdHkgUmVtb3ZlZCc7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIHR5cGUgZ3VhcmQgdG8gY2hlY2sgZm9yIHRoZSBSZW1vdmVkRW50aXR5IG1lc3NhZ2VcclxuICovXHJcbmZ1bmN0aW9uIGlzUmVtb3ZlU3lzdGVtRW50aXR5KHgpIHtcclxuICAgIHJldHVybiAhIXggJiYgeC50eXBlID09PSAnRW50aXR5IFJlbW92ZWQnO1xyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRW50aXR5Q29tcG9uZW50U3lzdGVtL0VudGl0eU1hbmFnZXIudHNcblxyXG5cclxuLy8gQWRkL1JlbW92ZSBlbnRpdHlzIGFuZCBjb21wb25lbnRzXHJcbmNsYXNzIEVudGl0eU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoX3dvcmxkKSB7XHJcbiAgICAgICAgdGhpcy5fd29ybGQgPSBfd29ybGQ7XHJcbiAgICAgICAgdGhpcy5lbnRpdGllcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eUluZGV4ID0ge307XHJcbiAgICAgICAgdGhpcy5fZW50aXRpZXNUb1JlbW92ZSA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSdW5zIHRoZSBlbnRpdHkgbGlmZWN5Y2xlXHJcbiAgICAgKiBAcGFyYW0gX2NvbnRleHRcclxuICAgICAqL1xyXG4gICAgdXBkYXRlRW50aXRpZXMoX2NvbnRleHQsIGVsYXBzZWQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gaXMgdGhpcyByaWdodD9cclxuICAgICAgICAgICAgZW50aXR5LnVwZGF0ZShfY29udGV4dC5lbmdpbmUsIGVsYXBzZWQpO1xyXG4gICAgICAgICAgICBpZiAoIWVudGl0eS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmaW5kRW50aXRpZXNGb3JSZW1vdmFsKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgaWYgKCFlbnRpdHkuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUVudGl0eShlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbnRpdHlNYW5hZ2VyIG9ic2VydmVzIGNoYW5nZXMgb24gZW50aXRpZXNcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIG5vdGlmeShtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGlzQWRkZWRDb21wb25lbnQobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgLy8gd2UgZG9uJ3QgbmVlZCB0aGUgY29tcG9uZW50LCBpdCdzIGFscmVhZHkgb24gdGhlIGVudGl0eVxyXG4gICAgICAgICAgICB0aGlzLl93b3JsZC5xdWVyeU1hbmFnZXIuYWRkRW50aXR5KG1lc3NhZ2UuZGF0YS5lbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSZW1vdmVkQ29tcG9uZW50KG1lc3NhZ2UpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkLnF1ZXJ5TWFuYWdlci5yZW1vdmVDb21wb25lbnQobWVzc2FnZS5kYXRhLmVudGl0eSwgbWVzc2FnZS5kYXRhLmNvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGFuIGVudGl0eSB0byBiZSB0cmFja2VkIGJ5IHRoZSBFbnRpdHlNYW5hZ2VyXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIGFkZEVudGl0eShlbnRpdHkpIHtcclxuICAgICAgICBlbnRpdHkuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZW50aXR5ICYmICF0aGlzLl9lbnRpdHlJbmRleFtlbnRpdHkuaWRdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VudGl0eUluZGV4W2VudGl0eS5pZF0gPSBlbnRpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuZW50aXRpZXMucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICB0aGlzLl93b3JsZC5xdWVyeU1hbmFnZXIuYWRkRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgICAgIGVudGl0eS5jb21wb25lbnRBZGRlZCQucmVnaXN0ZXIodGhpcyk7XHJcbiAgICAgICAgICAgIGVudGl0eS5jb21wb25lbnRSZW1vdmVkJC5yZWdpc3Rlcih0aGlzKTtcclxuICAgICAgICAgICAgLy8gaWYgZW50aXR5IGhhcyBjaGlsZHJlblxyXG4gICAgICAgICAgICBlbnRpdHkuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4gdGhpcy5hZGRFbnRpdHkoYykpO1xyXG4gICAgICAgICAgICBlbnRpdHkuY2hpbGRyZW5BZGRlZCQucmVnaXN0ZXIoe1xyXG4gICAgICAgICAgICAgICAgbm90aWZ5OiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRW50aXR5KGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZW50aXR5LmNoaWxkcmVuUmVtb3ZlZCQucmVnaXN0ZXIoe1xyXG4gICAgICAgICAgICAgICAgbm90aWZ5OiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRW50aXR5KGUsIGZhbHNlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlRW50aXR5KGlkT3JFbnRpdHksIGRlZmVycmVkID0gdHJ1ZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBsZXQgaWQgPSAwO1xyXG4gICAgICAgIGlmIChpZE9yRW50aXR5IGluc3RhbmNlb2YgRW50aXR5KSB7XHJcbiAgICAgICAgICAgIGlkID0gaWRPckVudGl0eS5pZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlkID0gaWRPckVudGl0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5fZW50aXR5SW5kZXhbaWRdO1xyXG4gICAgICAgIGlmIChlbnRpdHkgJiYgZW50aXR5LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICBlbnRpdHkua2lsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW50aXR5ICYmIGRlZmVycmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VudGl0aWVzVG9SZW1vdmUucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9lbnRpdHlJbmRleFtpZF07XHJcbiAgICAgICAgaWYgKGVudGl0eSkge1xyXG4gICAgICAgICAgICByZW1vdmVJdGVtRnJvbUFycmF5KGVudGl0eSwgdGhpcy5lbnRpdGllcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkLnF1ZXJ5TWFuYWdlci5yZW1vdmVFbnRpdHkoZW50aXR5KTtcclxuICAgICAgICAgICAgZW50aXR5LmNvbXBvbmVudEFkZGVkJC51bnJlZ2lzdGVyKHRoaXMpO1xyXG4gICAgICAgICAgICBlbnRpdHkuY29tcG9uZW50UmVtb3ZlZCQudW5yZWdpc3Rlcih0aGlzKTtcclxuICAgICAgICAgICAgLy8gaWYgZW50aXR5IGhhcyBjaGlsZHJlblxyXG4gICAgICAgICAgICBlbnRpdHkuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4gdGhpcy5yZW1vdmVFbnRpdHkoYywgZGVmZXJyZWQpKTtcclxuICAgICAgICAgICAgZW50aXR5LmNoaWxkcmVuQWRkZWQkLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIGVudGl0eS5jaGlsZHJlblJlbW92ZWQkLmNsZWFyKCk7XHJcbiAgICAgICAgICAgIC8vIHN0YXRzXHJcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLl93b3JsZC5jb250ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5naW5lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl93b3JsZC5jb250ZXh0LmVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLmtpbGxlZCsrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvY2Vzc0VudGl0eVJlbW92YWxzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuX2VudGl0aWVzVG9SZW1vdmUpIHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRW50aXR5KGVudGl0eSwgZmFsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHByb2Nlc3NDb21wb25lbnRSZW1vdmFscygpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIGVudGl0eS5wcm9jZXNzQ29tcG9uZW50UmVtb3ZhbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEJ5SWQoaWQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW50aXR5SW5kZXhbaWRdO1xyXG4gICAgfVxyXG4gICAgZ2V0QnlOYW1lKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbnRpdGllcy5maWx0ZXIoZSA9PiBlLm5hbWUgPT09IG5hbWUpO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUVudGl0eShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9VdGlsLnRzXG5jb25zdCBidWlsZFR5cGVLZXkgPSAodHlwZXMpID0+IHtcclxuICAgIGNvbnN0IGtleSA9IFsuLi50eXBlc10uc29ydCgoYSwgYikgPT4gYS5sb2NhbGVDb21wYXJlKGIpKS5qb2luKCcrJyk7XHJcbiAgICByZXR1cm4ga2V5O1xyXG59O1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9RdWVyeS50c1xuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBxdWVyeSBmb3IgZW50aXRpZXMgdGhhdCBtYXRjaCBhIGxpc3Qgb2YgdHlwZXMgdGhhdCBpcyBjYWNoZWQgYW5kIG9ic2VydmFibGVcclxuICpcclxuICogUXVlcmllcyBjYW4gYmUgc3Ryb25nbHkgdHlwZWQgYnkgc3VwcGx5aW5nIGEgdHlwZSB1bmlvbiBpbiB0aGUgb3B0aW9uYWwgdHlwZSBwYXJhbWV0ZXJcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBxdWVyeUFCID0gbmV3IGV4LlF1ZXJ5PENvbXBvbmVudFR5cGVBIHwgQ29tcG9uZW50VHlwZUI+KFsnQScsICdCJ10pO1xyXG4gKiBgYGBcclxuICovXHJcbmNsYXNzIFF1ZXJ5IGV4dGVuZHMgT2JzZXJ2YWJsZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0eXBlcykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fZW50aXRpZXMgPSBbXTtcclxuICAgICAgICBpZiAodHlwZXNbMF0gaW5zdGFuY2VvZiBGdW5jdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLnR5cGVzID0gdHlwZXMubWFwKFQgPT4gKG5ldyBUKS50eXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQga2V5KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9rZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9rZXkgPSBidWlsZFR5cGVLZXkodGhpcy50eXBlcykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlbnRpdGllcyB0aGF0IG1hdGNoIHRoZSBxdWVyeVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzb3J0IE9wdGlvbmFsIHNvcnRpbmcgZnVuY3Rpb24gdG8gc29ydCBlbnRpdGllcyByZXR1cm5lZCBmcm9tIHRoZSBxdWVyeVxyXG4gICAgICovXHJcbiAgICBnZXRFbnRpdGllcyhzb3J0KSB7XHJcbiAgICAgICAgaWYgKHNvcnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXMuc29ydChzb3J0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudGl0aWVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW4gZW50aXR5IHRvIHRoZSBxdWVyeSwgd2lsbCBvbmx5IGJlIGFkZGVkIGlmIHRoZSBlbnRpdHkgbWF0Y2hlcyB0aGUgcXVlcnkgdHlwZXNcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgYWRkRW50aXR5KGVudGl0eSkge1xyXG4gICAgICAgIGlmICghY29udGFpbnModGhpcy5fZW50aXRpZXMsIGVudGl0eSkgJiYgdGhpcy5tYXRjaGVzKGVudGl0eSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXMucHVzaChlbnRpdHkpO1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUFsbChuZXcgQWRkZWRFbnRpdHkoZW50aXR5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgZW50aXR5IGlzIHBhcnQgb2YgdGhlIHF1ZXJ5IGl0IHdpbGwgYmUgcmVtb3ZlZCByZWdhcmRsZXNzIG9mIHR5cGVzXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUVudGl0eShlbnRpdHkpIHtcclxuICAgICAgICBpZiAocmVtb3ZlSXRlbUZyb21BcnJheShlbnRpdHksIHRoaXMuX2VudGl0aWVzKSkge1xyXG4gICAgICAgICAgICB0aGlzLm5vdGlmeUFsbChuZXcgUmVtb3ZlZEVudGl0eShlbnRpdHkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYWxsIGVudGl0aWVzIGFuZCBvYnNlcnZlcnMgZnJvbSB0aGUgcXVlcnlcclxuICAgICAqL1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5fZW50aXRpZXMubGVuZ3RoID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIHRoaXMub2JzZXJ2ZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMudW5yZWdpc3RlcihvYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF0Y2hlcyh0eXBlc09yRW50aXR5KSB7XHJcbiAgICAgICAgbGV0IHR5cGVzID0gW107XHJcbiAgICAgICAgaWYgKHR5cGVzT3JFbnRpdHkgaW5zdGFuY2VvZiBFbnRpdHkpIHtcclxuICAgICAgICAgICAgdHlwZXMgPSB0eXBlc09yRW50aXR5LnR5cGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZXMgPSB0eXBlc09yRW50aXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbWF0Y2hlcyA9IHRydWU7XHJcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIHRoaXMudHlwZXMpIHtcclxuICAgICAgICAgICAgbWF0Y2hlcyA9IG1hdGNoZXMgJiYgdHlwZXMuaW5kZXhPZih0eXBlKSA+IC0xO1xyXG4gICAgICAgICAgICBpZiAoIW1hdGNoZXMpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWF0Y2hlcztcclxuICAgIH1cclxuICAgIGNvbnRhaW4odHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVzLmluZGV4T2YodHlwZSkgPiAtMTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9RdWVyeU1hbmFnZXIudHNcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBxdWVyeSBtYW5hZ2VyIGlzIHJlc3BvbnNpYmxlIGZvciB1cGRhdGluZyBhbGwgcXVlcmllcyB3aGVuIGVudGl0aWVzL2NvbXBvbmVudHMgY2hhbmdlXHJcbiAqL1xyXG5jbGFzcyBRdWVyeU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoX3dvcmxkKSB7XHJcbiAgICAgICAgdGhpcy5fd29ybGQgPSBfd29ybGQ7XHJcbiAgICAgICAgdGhpcy5fcXVlcmllcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgcXVlcnkgdG8gdGhlIG1hbmFnZXIgYW5kIHBvcHVsYXRlcyB3aXRoIGFueSBlbnRpdGllcyB0aGF0IG1hdGNoXHJcbiAgICAgKiBAcGFyYW0gcXVlcnlcclxuICAgICAqL1xyXG4gICAgX2FkZFF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICAgICAgdGhpcy5fcXVlcmllc1tidWlsZFR5cGVLZXkocXVlcnkudHlwZXMpXSA9IHF1ZXJ5O1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuX3dvcmxkLmVudGl0eU1hbmFnZXIuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgcXVlcnkuYWRkRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIHRoZSBxdWVyeSBpZiB0aGVyZSBhcmUgbm8gb2JzZXJ2ZXJzIGxlZnRcclxuICAgICAqIEBwYXJhbSBxdWVyeVxyXG4gICAgICovXHJcbiAgICBtYXliZVJlbW92ZVF1ZXJ5KHF1ZXJ5KSB7XHJcbiAgICAgICAgaWYgKHF1ZXJ5Lm9ic2VydmVycy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgcXVlcnkuY2xlYXIoKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3F1ZXJpZXNbYnVpbGRUeXBlS2V5KHF1ZXJ5LnR5cGVzKV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIHRoZSBlbnRpdHkgdG8gYW55IG1hdGNoaW5nIHF1ZXJ5IGluIHRoZSBxdWVyeSBtYW5hZ2VcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgYWRkRW50aXR5KGVudGl0eSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcXVlcnlUeXBlIGluIHRoaXMuX3F1ZXJpZXMpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3F1ZXJpZXNbcXVlcnlUeXBlXSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVlcmllc1txdWVyeVR5cGVdLmFkZEVudGl0eShlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGVudGl0eSBmcm9tIHF1ZXJpZXMgaWYgdGhlIHJlbW92ZWQgY29tcG9uZW50IGRpc3F1YWxpZmllcyBpdFxyXG4gICAgICogQHBhcmFtIGVudGl0eVxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudFxyXG4gICAgICovXHJcbiAgICByZW1vdmVDb21wb25lbnQoZW50aXR5LCBjb21wb25lbnQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5VHlwZSBpbiB0aGlzLl9xdWVyaWVzKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb21wb25lbnQgYmVpbmcgcmVtb3ZlZCBmcm9tIGFuIGVudGl0eSBpcyBhIHBhcnQgb2YgYSBxdWVyeSxcclxuICAgICAgICAgICAgLy8gaXQgaXMgbm93IGRpc3F1YWxpZmllZCBmcm9tIHRoYXQgcXVlcnksIHJlbW92ZSBpdFxyXG4gICAgICAgICAgICBpZiAodGhpcy5fcXVlcmllc1txdWVyeVR5cGVdLmNvbnRhaW4oY29tcG9uZW50LnR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWVyaWVzW3F1ZXJ5VHlwZV0ucmVtb3ZlRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gZW50aXR5IGZyb20gYWxsIHF1ZXJpZXMgaXQgaXMgY3VycmVudGx5IGEgcGFydCBvZlxyXG4gICAgICogQHBhcmFtIGVudGl0eVxyXG4gICAgICovXHJcbiAgICByZW1vdmVFbnRpdHkoZW50aXR5KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBxdWVyeVR5cGUgaW4gdGhpcy5fcXVlcmllcykge1xyXG4gICAgICAgICAgICB0aGlzLl9xdWVyaWVzW3F1ZXJ5VHlwZV0ucmVtb3ZlRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgcG9wdWxhdGVkIHF1ZXJ5IGFuZCByZXR1cm5zLCBpZiB0aGUgcXVlcnkgYWxyZWFkeSBleGlzdHMgdGhhdCB3aWxsIGJlIHJldHVybmVkIGluc3RlYWQgb2YgYSBuZXcgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB0eXBlc1xyXG4gICAgICovXHJcbiAgICBjcmVhdGVRdWVyeSh0eXBlcykge1xyXG4gICAgICAgIGNvbnN0IG1heWJlRXhpc3RpbmdRdWVyeSA9IHRoaXMuZ2V0UXVlcnkodHlwZXMpO1xyXG4gICAgICAgIGlmIChtYXliZUV4aXN0aW5nUXVlcnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1heWJlRXhpc3RpbmdRdWVyeTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSBuZXcgUXVlcnkodHlwZXMpO1xyXG4gICAgICAgIHRoaXMuX2FkZFF1ZXJ5KHF1ZXJ5KTtcclxuICAgICAgICByZXR1cm4gcXVlcnk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHJpZXZlcyBhbiBleGlzdGluZyBxdWVyeSBieSB0eXBlcyBpZiBpdCBleGlzdHMgb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxyXG4gICAgICogQHBhcmFtIHR5cGVzXHJcbiAgICAgKi9cclxuICAgIGdldFF1ZXJ5KHR5cGVzKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gYnVpbGRUeXBlS2V5KHR5cGVzKTtcclxuICAgICAgICBpZiAodGhpcy5fcXVlcmllc1trZXldKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9xdWVyaWVzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRW50aXR5Q29tcG9uZW50U3lzdGVtL1N5c3RlbU1hbmFnZXIudHNcblxyXG4vKipcclxuICogVGhlIFN5c3RlbU1hbmFnZXIgaXMgcmVzcG9uc2libGUgZm9yIGtlZXBpbmcgdHJhY2sgb2YgYWxsIHN5c3RlbXMgaW4gYSBzY2VuZS5cclxuICogU3lzdGVtcyBhcmUgc2NlbmUgc3BlY2lmaWNcclxuICovXHJcbmNsYXNzIFN5c3RlbU1hbmFnZXIge1xyXG4gICAgY29uc3RydWN0b3IoX3dvcmxkKSB7XHJcbiAgICAgICAgdGhpcy5fd29ybGQgPSBfd29ybGQ7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogTGlzdCBvZiBzeXN0ZW1zLCB0byBhZGQgYSBuZXcgc3lzdGVtIGNhbGwgW1tTeXN0ZW1NYW5hZ2VyLmFkZFN5c3RlbV1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zeXN0ZW1zID0gW107XHJcbiAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBzeXN0ZW0gcmVnaXN0ZXJlZCBpbiB0aGUgbWFuYWdlciBieSB0eXBlXHJcbiAgICAgKiBAcGFyYW0gc3lzdGVtVHlwZVxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgZ2V0KHN5c3RlbVR5cGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zeXN0ZW1zLmZpbmQoKHMpID0+IHMgaW5zdGFuY2VvZiBzeXN0ZW1UeXBlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHN5c3RlbSB0byB0aGUgbWFuYWdlciwgaXQgd2lsbCBub3cgYmUgdXBkYXRlZCBldmVyeSBmcmFtZVxyXG4gICAgICogQHBhcmFtIHN5c3RlbVxyXG4gICAgICovXHJcbiAgICBhZGRTeXN0ZW0oc3lzdGVtKSB7XHJcbiAgICAgICAgLy8gdmFsaWRhdGUgc3lzdGVtIGhhcyB0eXBlc1xyXG4gICAgICAgIGlmICghc3lzdGVtLnR5cGVzIHx8IHN5c3RlbS50eXBlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRlbXB0ZWQgdG8gYWRkIGEgU3lzdGVtIHdpdGhvdXQgYW55IHR5cGVzYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5fd29ybGQucXVlcnlNYW5hZ2VyLmNyZWF0ZVF1ZXJ5KHN5c3RlbS50eXBlcyk7XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1zLnB1c2goc3lzdGVtKTtcclxuICAgICAgICB0aGlzLnN5c3RlbXMuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xyXG4gICAgICAgIHF1ZXJ5LnJlZ2lzdGVyKHN5c3RlbSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQgJiYgc3lzdGVtLmluaXRpYWxpemUpIHtcclxuICAgICAgICAgICAgc3lzdGVtLmluaXRpYWxpemUodGhpcy5fd29ybGQuY29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgc3lzdGVtIGZyb20gdGhlIG1hbmFnZXIsIGl0IHdpbGwgbm8gbG9uZ2VyIGJlIHVwZGF0ZWRcclxuICAgICAqIEBwYXJhbSBzeXN0ZW1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlU3lzdGVtKHN5c3RlbSkge1xyXG4gICAgICAgIHJlbW92ZUl0ZW1Gcm9tQXJyYXkoc3lzdGVtLCB0aGlzLnN5c3RlbXMpO1xyXG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5fd29ybGQucXVlcnlNYW5hZ2VyLmdldFF1ZXJ5KHN5c3RlbS50eXBlcyk7XHJcbiAgICAgICAgaWYgKHF1ZXJ5KSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5LnVucmVnaXN0ZXIoc3lzdGVtKTtcclxuICAgICAgICAgICAgdGhpcy5fd29ybGQucXVlcnlNYW5hZ2VyLm1heWJlUmVtb3ZlUXVlcnkocXVlcnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBhbGwgc3lzdGVtc1xyXG4gICAgICogQHBhcmFtIHR5cGUgd2hldGhlciB0aGlzIGlzIGFuIHVwZGF0ZSBvciBkcmF3IHN5c3RlbVxyXG4gICAgICogQHBhcmFtIGNvbnRleHQgY29udGV4dCByZWZlcmVuY2VcclxuICAgICAqIEBwYXJhbSBkZWx0YSB0aW1lIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICovXHJcbiAgICB1cGRhdGVTeXN0ZW1zKHR5cGUsIGNvbnRleHQsIGRlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5zeXN0ZW1zKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocy5pbml0aWFsaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcy5pbml0aWFsaXplKHRoaXMuX3dvcmxkLmNvbnRleHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHN5c3RlbXMgPSB0aGlzLnN5c3RlbXMuZmlsdGVyKChzKSA9PiBzLnN5c3RlbVR5cGUgPT09IHR5cGUpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzeXN0ZW1zKSB7XHJcbiAgICAgICAgICAgIGlmIChzLnByZXVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcy5wcmV1cGRhdGUoY29udGV4dCwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzeXN0ZW1zKSB7XHJcbiAgICAgICAgICAgIC8vIEdldCBlbnRpdGllcyB0aGF0IG1hdGNoIHRoZSBzeXN0ZW0gdHlwZXMsIHByZS1zb3J0XHJcbiAgICAgICAgICAgIGNvbnN0IGVudGl0aWVzID0gdGhpcy5fd29ybGQucXVlcnlNYW5hZ2VyLmdldFF1ZXJ5KHMudHlwZXMpLmdldEVudGl0aWVzKHMuc29ydCk7XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgZW50aXRpZXMgaWYgbmVlZGVkXHJcbiAgICAgICAgICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgU2NlbmUpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW50aXR5Ll9pbml0aWFsaXplKGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5lbmdpbmUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHMudXBkYXRlKGVudGl0aWVzLCBkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgcyBvZiBzeXN0ZW1zKSB7XHJcbiAgICAgICAgICAgIGlmIChzLnBvc3R1cGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIHMucG9zdHVwZGF0ZShjb250ZXh0LCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHN5c3RlbSBvZiB0aGlzLnN5c3RlbXMpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVTeXN0ZW0oc3lzdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FbnRpdHlDb21wb25lbnRTeXN0ZW0vV29ybGQudHNcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBXb3JsZCBpcyBhIHNlbGYtY29udGFpbmVkIGVudGl0eSBjb21wb25lbnQgc3lzdGVtIGZvciBhIHBhcnRpY3VsYXIgY29udGV4dC5cclxuICovXHJcbmNsYXNzIFdvcmxkIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNvbnRleHQgdHlwZSBpcyBwYXNzZWQgdG8gdGhlIHN5c3RlbSB1cGRhdGVzXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcclxuICAgICAgICB0aGlzLnF1ZXJ5TWFuYWdlciA9IG5ldyBRdWVyeU1hbmFnZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyID0gbmV3IEVudGl0eU1hbmFnZXIodGhpcyk7XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1NYW5hZ2VyID0gbmV3IFN5c3RlbU1hbmFnZXIodGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBzeXN0ZW1zIGJ5IHR5cGUgYW5kIHRpbWUgZWxhcHNlZCBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKHR5cGUsIGRlbHRhKSB7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09IFN5c3RlbVR5cGUuVXBkYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW50aXR5TWFuYWdlci51cGRhdGVFbnRpdGllcyh0aGlzLmNvbnRleHQsIGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1NYW5hZ2VyLnVwZGF0ZVN5c3RlbXModHlwZSwgdGhpcy5jb250ZXh0LCBkZWx0YSk7XHJcbiAgICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyLmZpbmRFbnRpdGllc0ZvclJlbW92YWwoKTtcclxuICAgICAgICB0aGlzLmVudGl0eU1hbmFnZXIucHJvY2Vzc0NvbXBvbmVudFJlbW92YWxzKCk7XHJcbiAgICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyLnByb2Nlc3NFbnRpdHlSZW1vdmFscygpO1xyXG4gICAgfVxyXG4gICAgYWRkKGVudGl0eU9yU3lzdGVtKSB7XHJcbiAgICAgICAgaWYgKGVudGl0eU9yU3lzdGVtIGluc3RhbmNlb2YgRW50aXR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW50aXR5TWFuYWdlci5hZGRFbnRpdHkoZW50aXR5T3JTeXN0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW50aXR5T3JTeXN0ZW0gaW5zdGFuY2VvZiBTeXN0ZW0pIHtcclxuICAgICAgICAgICAgdGhpcy5zeXN0ZW1NYW5hZ2VyLmFkZFN5c3RlbShlbnRpdHlPclN5c3RlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlKGVudGl0eU9yU3lzdGVtLCBkZWZlcnJlZCA9IHRydWUpIHtcclxuICAgICAgICBpZiAoZW50aXR5T3JTeXN0ZW0gaW5zdGFuY2VvZiBFbnRpdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyLnJlbW92ZUVudGl0eShlbnRpdHlPclN5c3RlbSwgZGVmZXJyZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW50aXR5T3JTeXN0ZW0gaW5zdGFuY2VvZiBTeXN0ZW0pIHtcclxuICAgICAgICAgICAgdGhpcy5zeXN0ZW1NYW5hZ2VyLnJlbW92ZVN5c3RlbShlbnRpdHlPclN5c3RlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJFbnRpdGllcygpIHtcclxuICAgICAgICB0aGlzLmVudGl0eU1hbmFnZXIuY2xlYXIoKTtcclxuICAgIH1cclxuICAgIGNsZWFyU3lzdGVtcygpIHtcclxuICAgICAgICB0aGlzLnN5c3RlbU1hbmFnZXIuY2xlYXIoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9JbnRlZ3JhdG9yLnRzXG5jbGFzcyBFdWxlckludGVncmF0b3Ige1xyXG4gICAgc3RhdGljIGludGVncmF0ZSh0cmFuc2Zvcm0sIG1vdGlvbiwgdG90YWxBY2MsIGVsYXBzZWRNcykge1xyXG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBlbGFwc2VkTXMgLyAxMDAwO1xyXG4gICAgICAgIG1vdGlvbi52ZWwuYWRkRXF1YWwodG90YWxBY2Muc2NhbGUoc2Vjb25kcykpO1xyXG4gICAgICAgIHRyYW5zZm9ybS5wb3MuYWRkRXF1YWwobW90aW9uLnZlbC5zY2FsZShzZWNvbmRzKSkuYWRkRXF1YWwodG90YWxBY2Muc2NhbGUoMC41ICogc2Vjb25kcyAqIHNlY29uZHMpKTtcclxuICAgICAgICBtb3Rpb24uYW5ndWxhclZlbG9jaXR5ICs9IG1vdGlvbi50b3JxdWUgKiAoMS4wIC8gbW90aW9uLmluZXJ0aWEpICogc2Vjb25kcztcclxuICAgICAgICB0cmFuc2Zvcm0ucm90YXRpb24gKz0gbW90aW9uLmFuZ3VsYXJWZWxvY2l0eSAqIHNlY29uZHM7XHJcbiAgICAgICAgdHJhbnNmb3JtLnNjYWxlLmFkZEVxdWFsKG1vdGlvbi5zY2FsZUZhY3Rvci5zY2FsZShzZWNvbmRzKSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vTW90aW9uU3lzdGVtLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgTW90aW9uU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlcyA9IFsnZXgudHJhbnNmb3JtJywgJ2V4Lm1vdGlvbiddO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtVHlwZSA9IFN5c3RlbVR5cGUuVXBkYXRlO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAtMTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZW50aXRpZXMsIGVsYXBzZWRNcykge1xyXG4gICAgICAgIGxldCB0cmFuc2Zvcm07XHJcbiAgICAgICAgbGV0IG1vdGlvbjtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBfZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgICAgICBtb3Rpb24gPSBlbnRpdHkuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbmFsQm9keSA9IGVudGl0eS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25hbEJvZHkgPT09IG51bGwgfHwgb3B0aW9uYWxCb2R5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25hbEJvZHkuc2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsQWNjID0gbW90aW9uLmFjYy5jbG9uZSgpO1xyXG4gICAgICAgICAgICBpZiAoKG9wdGlvbmFsQm9keSA9PT0gbnVsbCB8fCBvcHRpb25hbEJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbmFsQm9keS5jb2xsaXNpb25UeXBlKSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUgJiYgKG9wdGlvbmFsQm9keSA9PT0gbnVsbCB8fCBvcHRpb25hbEJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbmFsQm9keS51c2VHcmF2aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgdG90YWxBY2MuYWRkRXF1YWwoUGh5c2ljcy5ncmF2aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcHRpb25hbEJvZHkgPT09IG51bGwgfHwgb3B0aW9uYWxCb2R5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25hbEJvZHkuY2FwdHVyZU9sZFRyYW5zZm9ybSgpO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdHJhbnNmb3JtIGFuZCBtb3Rpb24gYmFzZWQgb24gRXVsZXIgbGluZWFyIGFsZ2VicmFcclxuICAgICAgICAgICAgRXVsZXJJbnRlZ3JhdG9yLmludGVncmF0ZSh0cmFuc2Zvcm0sIG1vdGlvbiwgdG90YWxBY2MsIGVsYXBzZWRNcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVidWdEcmF3KF9jdHgpIHtcclxuICAgICAgICAvLyBwYXNzXHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vU29sdmVyL1NvbHZlci50c1xuLyoqXHJcbiAqIEEgY29sbGlzaW9uIHNvbHZlciBmaWd1cmVzIG91dCBob3cgdG8gcG9zaXRpb24gY29sbGlkZXJzIHN1Y2ggdGhhdCB0aGV5IGFyZSBubyBsb25nZXIgb3ZlcmxhcHBpbmdcclxuICpcclxuICogU29sdmVycyBhcmUgZXhlY3V0ZWQgaW4gdGhlIG9yZGVyXHJcbiAqXHJcbiAqIDEuIHByZVNvbHZlXHJcbiAqIDIuIHNvbHZlVmVsb2NpdHlcclxuICogMy4gc29sdmVQb3NpdGlvblxyXG4gKiA0LiBwb3N0U29sdmVcclxuICogQGluaGVyaXRkb2NcclxuICovXHJcbmNsYXNzIENvbGxpc2lvblNvbHZlciB7XHJcbiAgICAvKipcclxuICAgICAqIFNvbHZlcyBvdmVybGFwcGluZyBjb250YWN0IGluXHJcbiAgICAgKlxyXG4gICAgICogU29sdmVycyBhcmUgZXhlY3V0ZWQgaW4gdGhlIG9yZGVyXHJcbiAgICAgKiAxLiBwcmVTb2x2ZVxyXG4gICAgICogMi4gc29sdmVWZWxvY2l0eVxyXG4gICAgICogMy4gc29sdmVQb3NpdGlvblxyXG4gICAgICogNC4gcG9zdFNvbHZlXHJcbiAgICAgKiBAcGFyYW0gY29udGFjdHNcclxuICAgICAqL1xyXG4gICAgc29sdmUoY29udGFjdHMpIHtcclxuICAgICAgICAvLyBFdmVudHMgYW5kIGluaXRcclxuICAgICAgICB0aGlzLnByZVNvbHZlKGNvbnRhY3RzKTtcclxuICAgICAgICAvLyBSZW1vdmUgYW55IGNhbmNlbGVkIGNvbnRhY3RzXHJcbiAgICAgICAgY29udGFjdHMgPSBjb250YWN0cy5maWx0ZXIoYyA9PiAhYy5pc0NhbmNlbGVkKCkpO1xyXG4gICAgICAgIC8vIFNvbHZlIHZlbG9jaXR5IGZpcnN0XHJcbiAgICAgICAgdGhpcy5zb2x2ZVZlbG9jaXR5KGNvbnRhY3RzKTtcclxuICAgICAgICAvLyBTb2x2ZSBwb3NpdGlvbiBsYXN0IGJlY2F1c2Ugbm9uLW92ZXJsYXAgaXMgdGhlIG1vc3QgaW1wb3J0YW50XHJcbiAgICAgICAgdGhpcy5zb2x2ZVBvc2l0aW9uKGNvbnRhY3RzKTtcclxuICAgICAgICAvLyBFdmVudHMgYW5kIGFueSBjb250YWN0IGhvdXNlLWtlZXBpbmcgdGhlIHNvbHZlciBuZWVkc1xyXG4gICAgICAgIHRoaXMucG9zdFNvbHZlKGNvbnRhY3RzKTtcclxuICAgICAgICByZXR1cm4gY29udGFjdHM7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vU29sdmVyL0FyY2FkZVNvbHZlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogQXJjYWRlU29sdmVyIGlzIHRoZSBkZWZhdWx0IGluIEV4Y2FsaWJ1ci4gSXQgc29sdmVzIGNvbGxpc2lvbnMgc28gdGhhdCB0aGVyZSBpcyBubyBvdmVybGFwIGJldHdlZW4gY29udGFjdHMsXHJcbiAqIGFuZCBuZWdhdGVzIHZlbG9jaXR5IGFsb25nIHRoZSBjb2xsaXNpb24gbm9ybWFsLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHVzdWFsbHkgdGhlIHR5cGUgb2YgY29sbGlzaW9ucyB1c2VkIGZvciAyRCBnYW1lcyB0aGF0IGRvbid0IG5lZWQgYSBtb3JlIHJlYWxpc3RpYyBjb2xsaXNpb24gc2ltdWxhdGlvbi5cclxuICpcclxuICovXHJcbmNsYXNzIEFyY2FkZVNvbHZlciBleHRlbmRzIENvbGxpc2lvblNvbHZlciB7XHJcbiAgICBwcmVTb2x2ZShjb250YWN0cykge1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udGFjdCBvZiBjb250YWN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBzaWRlID0gU2lkZS5mcm9tRGlyZWN0aW9uKGNvbnRhY3QubXR2KTtcclxuICAgICAgICAgICAgY29uc3QgbXR2ID0gY29udGFjdC5tdHYubmVnYXRlKCk7XHJcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggY29sbGlzaW9uIGV2ZW50cyBvbiBib3RoIHBhcnRpY2lwYW50c1xyXG4gICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQS5ldmVudHMuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IFByZUNvbGxpc2lvbkV2ZW50KGNvbnRhY3QuY29sbGlkZXJBLCBjb250YWN0LmNvbGxpZGVyQiwgc2lkZSwgbXR2KSk7XHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdwcmVjb2xsaXNpb24nLCBuZXcgUHJlQ29sbGlzaW9uRXZlbnQoY29udGFjdC5jb2xsaWRlckIsIGNvbnRhY3QuY29sbGlkZXJBLCBTaWRlLmdldE9wcG9zaXRlKHNpZGUpLCBtdHYubmVnYXRlKCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwb3N0U29sdmUoY29udGFjdHMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udGFjdCBvZiBjb250YWN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlckEgPSBjb250YWN0LmNvbGxpZGVyQTtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJCID0gY29udGFjdC5jb2xsaWRlckI7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvZHlBID0gKF9hID0gY29sbGlkZXJBLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QiA9IChfYiA9IGNvbGxpZGVyQi5vd25lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKGJvZHlBICYmIGJvZHlCKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlIHx8IGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZGUgPSBTaWRlLmZyb21EaXJlY3Rpb24oY29udGFjdC5tdHYpO1xyXG4gICAgICAgICAgICBjb25zdCBtdHYgPSBjb250YWN0Lm10di5uZWdhdGUoKTtcclxuICAgICAgICAgICAgLy8gUHVibGlzaCBjb2xsaXNpb24gZXZlbnRzIG9uIGJvdGggcGFydGljaXBhbnRzXHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJBLmV2ZW50cy5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IFBvc3RDb2xsaXNpb25FdmVudChjb250YWN0LmNvbGxpZGVyQSwgY29udGFjdC5jb2xsaWRlckIsIHNpZGUsIG10dikpO1xyXG4gICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQi5ldmVudHMuZW1pdCgncG9zdGNvbGxpc2lvbicsIG5ldyBQb3N0Q29sbGlzaW9uRXZlbnQoY29udGFjdC5jb2xsaWRlckIsIGNvbnRhY3QuY29sbGlkZXJBLCBTaWRlLmdldE9wcG9zaXRlKHNpZGUpLCBtdHYubmVnYXRlKCkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzb2x2ZVBvc2l0aW9uKGNvbnRhY3RzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgbGV0IG10diA9IGNvbnRhY3QubXR2O1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlckEgPSBjb250YWN0LmNvbGxpZGVyQTtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJCID0gY29udGFjdC5jb2xsaWRlckI7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvZHlBID0gKF9hID0gY29sbGlkZXJBLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QiA9IChfYiA9IGNvbGxpZGVyQi5vd25lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKGJvZHlBICYmIGJvZHlCKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlIHx8IGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuQWN0aXZlICYmIGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BsaXQgb3ZlcmxhcHMgaWYgYm90aCBhcmUgQWN0aXZlXHJcbiAgICAgICAgICAgICAgICAgICAgbXR2ID0gbXR2LnNjYWxlKDAuNSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZlIG92ZXJsYXBzXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5wb3MueCAtPSBtdHYueDtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5wb3MueSAtPSBtdHYueTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChib2R5Qi5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvcy54ICs9IG10di54O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvcy55ICs9IG10di55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc29sdmVWZWxvY2l0eShjb250YWN0cykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250YWN0IG9mIGNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyQSA9IGNvbnRhY3QuY29sbGlkZXJBO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlckIgPSBjb250YWN0LmNvbGxpZGVyQjtcclxuICAgICAgICAgICAgY29uc3QgYm9keUEgPSAoX2EgPSBjb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvZHlCID0gKF9iID0gY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChib2R5QS5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlBhc3NpdmUgfHwgYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3JtYWwgPSBjb250YWN0Lm5vcm1hbDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9wcG9zaXRlID0gbm9ybWFsLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gQ2FuY2VsIG91dCB2ZWxvY2l0eSBvcHBvc2l0ZSBkaXJlY3Rpb24gb2YgY29sbGlzaW9uIG5vcm1hbFxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVsQWRqID0gbm9ybWFsLnNjYWxlKG5vcm1hbC5kb3QoYm9keUEudmVsLm5lZ2F0ZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEudmVsID0gYm9keUEudmVsLmFkZCh2ZWxBZGopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmVsQWRqID0gb3Bwb3NpdGUuc2NhbGUob3Bwb3NpdGUuZG90KGJvZHlCLnZlbC5uZWdhdGUoKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLnZlbCA9IGJvZHlCLnZlbC5hZGQodmVsQWRqKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Tb2x2ZXIvQ29udGFjdENvbnN0cmFpbnRQb2ludC50c1xuXHJcblxyXG4vKipcclxuICogSG9sZHMgaW5mb3JtYXRpb24gYWJvdXQgY29udGFjdCBwb2ludHMsIG1lYW50IHRvIGJlIHJldXNlZCBvdmVyIG11bHRpcGxlIGZyYW1lcyBvZiBjb250YWN0XHJcbiAqL1xyXG5jbGFzcyBDb250YWN0Q29uc3RyYWludFBvaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHBvaW50LCBsb2NhbCwgY29udGFjdCkge1xyXG4gICAgICAgIHRoaXMucG9pbnQgPSBwb2ludDtcclxuICAgICAgICB0aGlzLmxvY2FsID0gbG9jYWw7XHJcbiAgICAgICAgdGhpcy5jb250YWN0ID0gY29udGFjdDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbXB1bHNlIGFjY3VtdWxhdGVkIG92ZXIgdGltZSBpbiBub3JtYWwgZGlyZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ub3JtYWxJbXB1bHNlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbXB1bHNlIGFjY3VtdWxhdGVkIG92ZXIgdGltZSBpbiB0aGUgdGFuZ2VudCBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRhbmdlbnRJbXB1bHNlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFZmZlY3RpdmUgbWFzcyBzZWVuIGluIHRoZSBub3JtYWwgZGlyZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ub3JtYWxNYXNzID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFZmZlY3RpdmUgbWFzcyBzZWVuIGluIHRoZSB0YW5nZW50IGRpcmVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGFuZ2VudE1hc3MgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpcmVjdGlvbiBmcm9tIGNlbnRlciBvZiBtYXNzIG9mIGJvZHlBIHRvIGNvbnRhY3QgcG9pbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFUb0NvbnRhY3QgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERpcmVjdGlvbiBmcm9tIGNlbnRlciBvZiBtYXNzIG9mIGJvZHlCIHRvIGNvbnRhY3QgcG9pbnRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJUb0NvbnRhY3QgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbnRhY3QgaW5mb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgYm9keUEgPSAoX2EgPSB0aGlzLmNvbnRhY3QuY29sbGlkZXJBLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgIGNvbnN0IGJvZHlCID0gKF9iID0gdGhpcy5jb250YWN0LmNvbGxpZGVyQi5vd25lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsID0gdGhpcy5jb250YWN0Lm5vcm1hbDtcclxuICAgICAgICAgICAgY29uc3QgdGFuZ2VudCA9IHRoaXMuY29udGFjdC50YW5nZW50O1xyXG4gICAgICAgICAgICB0aGlzLmFUb0NvbnRhY3QgPSB0aGlzLnBvaW50LnN1Yihib2R5QS5wb3MpO1xyXG4gICAgICAgICAgICB0aGlzLmJUb0NvbnRhY3QgPSB0aGlzLnBvaW50LnN1Yihib2R5Qi5wb3MpO1xyXG4gICAgICAgICAgICBjb25zdCBhVG9Db250YWN0Tm9ybWFsID0gdGhpcy5hVG9Db250YWN0LmNyb3NzKG5vcm1hbCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJUb0NvbnRhY3ROb3JtYWwgPSB0aGlzLmJUb0NvbnRhY3QuY3Jvc3Mobm9ybWFsKTtcclxuICAgICAgICAgICAgdGhpcy5ub3JtYWxNYXNzID1cclxuICAgICAgICAgICAgICAgIGJvZHlBLmludmVyc2VNYXNzICtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5pbnZlcnNlTWFzcyArXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEuaW52ZXJzZUluZXJ0aWEgKiBhVG9Db250YWN0Tm9ybWFsICogYVRvQ29udGFjdE5vcm1hbCArXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIuaW52ZXJzZUluZXJ0aWEgKiBiVG9Db250YWN0Tm9ybWFsICogYlRvQ29udGFjdE5vcm1hbDtcclxuICAgICAgICAgICAgY29uc3QgYVRvQ29udGFjdFRhbmdlbnQgPSB0aGlzLmFUb0NvbnRhY3QuY3Jvc3ModGFuZ2VudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJUb0NvbnRhY3RUYW5nZW50ID0gdGhpcy5iVG9Db250YWN0LmNyb3NzKHRhbmdlbnQpO1xyXG4gICAgICAgICAgICB0aGlzLnRhbmdlbnRNYXNzID1cclxuICAgICAgICAgICAgICAgIGJvZHlBLmludmVyc2VNYXNzICtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5pbnZlcnNlTWFzcyArXHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUEuaW52ZXJzZUluZXJ0aWEgKiBhVG9Db250YWN0VGFuZ2VudCAqIGFUb0NvbnRhY3RUYW5nZW50ICtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5pbnZlcnNlSW5lcnRpYSAqIGJUb0NvbnRhY3RUYW5nZW50ICogYlRvQ29udGFjdFRhbmdlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZWxhdGl2ZSB2ZWxvY2l0eSBiZXR3ZW4gYm9keUEgYW5kIGJvZHlCXHJcbiAgICAgKi9cclxuICAgIGdldFJlbGF0aXZlVmVsb2NpdHkoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBib2R5QSA9IChfYSA9IHRoaXMuY29udGFjdC5jb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uc3QgYm9keUIgPSAoX2IgPSB0aGlzLmNvbnRhY3QuY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChib2R5QSAmJiBib2R5Qikge1xyXG4gICAgICAgICAgICAvLyBSZWxhdGl2ZSB2ZWxvY2l0eSBpbiBsaW5lYXIgdGVybXNcclxuICAgICAgICAgICAgLy8gQW5ndWxhciB0byBsaW5lYXIgdmVsb2NpdHkgZm9ybXVsYSAtPiBvbWVnYSA9IHZlbG9jaXR5L3JhZGl1cyBzbyBvbWVnYSB4IHJhZGl1cyA9IHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGNvbnN0IHZlbEEgPSBib2R5QS52ZWwuYWRkKFZlY3Rvci5jcm9zcyhib2R5QS5hbmd1bGFyVmVsb2NpdHksIHRoaXMuYVRvQ29udGFjdCkpO1xyXG4gICAgICAgICAgICBjb25zdCB2ZWxCID0gYm9keUIudmVsLmFkZChWZWN0b3IuY3Jvc3MoYm9keUIuYW5ndWxhclZlbG9jaXR5LCB0aGlzLmJUb0NvbnRhY3QpKTtcclxuICAgICAgICAgICAgcmV0dXJuIHZlbEIuc3ViKHZlbEEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gVmVjdG9yLlplcm87XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vU29sdmVyL1JlYWxpc3RpY1NvbHZlci50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgUmVhbGlzdGljU29sdmVyIGV4dGVuZHMgQ29sbGlzaW9uU29sdmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5sYXN0RnJhbWVDb250YWN0cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICAvLyBtYXAgY29udGFjdCBpZCB0byBjb250YWN0IHBvaW50c1xyXG4gICAgICAgIHRoaXMuaWRUb0NvbnRhY3RDb25zdHJhaW50ID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29udGFjdENvbnN0cmFpbnRzKGlkKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmlkVG9Db250YWN0Q29uc3RyYWludC5nZXQoaWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgIH1cclxuICAgIHByZVNvbHZlKGNvbnRhY3RzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250YWN0IG9mIGNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggY29sbGlzaW9uIGV2ZW50cyBvbiBib3RoIHBhcnRpY2lwYW50c1xyXG4gICAgICAgICAgICBjb25zdCBzaWRlID0gU2lkZS5mcm9tRGlyZWN0aW9uKGNvbnRhY3QubXR2KTtcclxuICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckEuZXZlbnRzLmVtaXQoJ3ByZWNvbGxpc2lvbicsIG5ldyBQcmVDb2xsaXNpb25FdmVudChjb250YWN0LmNvbGxpZGVyQSwgY29udGFjdC5jb2xsaWRlckIsIHNpZGUsIGNvbnRhY3QubXR2KSk7XHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJBLmV2ZW50cy5lbWl0KCdiZWZvcmVjb2xsaXNpb25yZXNvbHZlJywgbmV3IENvbGxpc2lvblByZVNvbHZlRXZlbnQoY29udGFjdC5jb2xsaWRlckEsIGNvbnRhY3QuY29sbGlkZXJCLCBzaWRlLCBjb250YWN0Lm10diwgY29udGFjdCkpO1xyXG4gICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQi5ldmVudHMuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IFByZUNvbGxpc2lvbkV2ZW50KGNvbnRhY3QuY29sbGlkZXJCLCBjb250YWN0LmNvbGxpZGVyQSwgU2lkZS5nZXRPcHBvc2l0ZShzaWRlKSwgY29udGFjdC5tdHYubmVnYXRlKCkpKTtcclxuICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckIuZXZlbnRzLmVtaXQoJ2JlZm9yZWNvbGxpc2lvbnJlc29sdmUnLCBuZXcgQ29sbGlzaW9uUHJlU29sdmVFdmVudChjb250YWN0LmNvbGxpZGVyQiwgY29udGFjdC5jb2xsaWRlckEsIFNpZGUuZ2V0T3Bwb3NpdGUoc2lkZSksIGNvbnRhY3QubXR2Lm5lZ2F0ZSgpLCBjb250YWN0KSk7XHJcbiAgICAgICAgICAgIC8vIE1hdGNoIGF3YWtlIHN0YXRlIGZvciBzbGVlcGluZ1xyXG4gICAgICAgICAgICBjb250YWN0Lm1hdGNoQXdha2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBjb250YWN0cyB0aGF0IGRvbmVcclxuICAgICAgICBjb25zdCBmaW5pc2hlZENvbnRhY3RJZHMgPSBBcnJheS5mcm9tKHRoaXMuaWRUb0NvbnRhY3RDb25zdHJhaW50LmtleXMoKSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250YWN0IG9mIGNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhbGwgY3VycmVudCBjb250YWN0cyB0aGF0IGFyZSBub3QgZG9uZVxyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGZpbmlzaGVkQ29udGFjdElkcy5pbmRleE9mKGNvbnRhY3QuaWQpO1xyXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgZmluaXNoZWRDb250YWN0SWRzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY29udGFjdFBvaW50cyA9IChfYSA9IHRoaXMuaWRUb0NvbnRhY3RDb25zdHJhaW50LmdldChjb250YWN0LmlkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XHJcbiAgICAgICAgICAgIGxldCBwb2ludEluZGV4ID0gMDtcclxuICAgICAgICAgICAgY29uc3QgYm9keUEgPSBjb250YWN0LmNvbGxpZGVyQS5vd25lci5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvZHlCID0gY29udGFjdC5jb2xsaWRlckIub3duZXIuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgY29udGFjdC5wb2ludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBub3JtYWwgPSBjb250YWN0Lm5vcm1hbDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YW5nZW50ID0gY29udGFjdC50YW5nZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFUb0NvbnRhY3QgPSBwb2ludC5zdWIoYm9keUEucG9zKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiVG9Db250YWN0ID0gcG9pbnQuc3ViKGJvZHlCLnBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVRvQ29udGFjdE5vcm1hbCA9IGFUb0NvbnRhY3QuY3Jvc3Mobm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiVG9Db250YWN0Tm9ybWFsID0gYlRvQ29udGFjdC5jcm9zcyhub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbE1hc3MgPSBib2R5QS5pbnZlcnNlTWFzcyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLmludmVyc2VNYXNzICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEuaW52ZXJzZUluZXJ0aWEgKiBhVG9Db250YWN0Tm9ybWFsICogYVRvQ29udGFjdE5vcm1hbCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLmludmVyc2VJbmVydGlhICogYlRvQ29udGFjdE5vcm1hbCAqIGJUb0NvbnRhY3ROb3JtYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVRvQ29udGFjdFRhbmdlbnQgPSBhVG9Db250YWN0LmNyb3NzKHRhbmdlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJUb0NvbnRhY3RUYW5nZW50ID0gYlRvQ29udGFjdC5jcm9zcyh0YW5nZW50KTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YW5nZW50TWFzcyA9IGJvZHlBLmludmVyc2VNYXNzICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuaW52ZXJzZU1hc3MgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIGFUb0NvbnRhY3RUYW5nZW50ICogYVRvQ29udGFjdFRhbmdlbnQgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5pbnZlcnNlSW5lcnRpYSAqIGJUb0NvbnRhY3RUYW5nZW50ICogYlRvQ29udGFjdFRhbmdlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgbm9ybWFsL3RhbmdlbnQgaW1wdWxzZSBieSByZS11c2luZyB0aGUgY29udGFjdCBwb2ludCBpZiBpdCdzIGNsb3NlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhY3RQb2ludHNbcG9pbnRJbmRleF0gJiYgKChfYyA9IChfYiA9IGNvbnRhY3RQb2ludHNbcG9pbnRJbmRleF0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wb2ludCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNxdWFyZURpc3RhbmNlKHBvaW50KSkgPCA0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3RQb2ludHNbcG9pbnRJbmRleF0ucG9pbnQgPSBwb2ludDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdFBvaW50c1twb2ludEluZGV4XS5sb2NhbCA9IGNvbnRhY3QubG9jYWxQb2ludHNbcG9pbnRJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXcgY29udGFjdCBpZiBpdCdzIG5vdCBjbG9zZSBvciBkb2Vzbid0IGV4aXN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3RQb2ludHNbcG9pbnRJbmRleF0gPSBuZXcgQ29udGFjdENvbnN0cmFpbnRQb2ludChwb2ludCwgY29udGFjdC5sb2NhbFBvaW50c1twb2ludEluZGV4XSwgY29udGFjdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBjb250YWN0IHBvaW50IGNhbGN1bGF0aW9uc1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RQb2ludHNbcG9pbnRJbmRleF0uYVRvQ29udGFjdCA9IGFUb0NvbnRhY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdFBvaW50c1twb2ludEluZGV4XS5iVG9Db250YWN0ID0gYlRvQ29udGFjdDtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0UG9pbnRzW3BvaW50SW5kZXhdLm5vcm1hbE1hc3MgPSBub3JtYWxNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RQb2ludHNbcG9pbnRJbmRleF0udGFuZ2VudE1hc3MgPSB0YW5nZW50TWFzcztcclxuICAgICAgICAgICAgICAgICAgICBwb2ludEluZGV4Kys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5pZFRvQ29udGFjdENvbnN0cmFpbnQuc2V0KGNvbnRhY3QuaWQsIGNvbnRhY3RQb2ludHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDbGVhbiB1cCBhbnkgY29udGFjdHMgdGhhdCBkaWQgbm90IG9jY3VyIGxhc3QgZnJhbWVcclxuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGZpbmlzaGVkQ29udGFjdElkcykge1xyXG4gICAgICAgICAgICB0aGlzLmlkVG9Db250YWN0Q29uc3RyYWludC5kZWxldGUoaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBXYXJtIGNvbnRhY3RzIHdpdGggYWNjdW11bGF0ZWQgaW1wdWxzZVxyXG4gICAgICAgIC8vIFVzZWZ1bCBmb3IgdGFsbCBzdGFja3NcclxuICAgICAgICBpZiAoUGh5c2ljcy53YXJtU3RhcnQpIHtcclxuICAgICAgICAgICAgdGhpcy53YXJtU3RhcnQoY29udGFjdHMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBjb250YWN0IG9mIGNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWN0UG9pbnRzID0gdGhpcy5nZXRDb250YWN0Q29uc3RyYWludHMoY29udGFjdC5pZCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGNvbnRhY3RQb2ludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludC5ub3JtYWxJbXB1bHNlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludC50YW5nZW50SW1wdWxzZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwb3N0U29sdmUoY29udGFjdHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgYm9keUEgPSBjb250YWN0LmNvbGxpZGVyQS5vd25lci5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvZHlCID0gY29udGFjdC5jb2xsaWRlckIub3duZXIuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgICAgIC8vIFNraXAgcG9zdCBzb2x2ZSBmb3IgYWN0aXZlK3Bhc3NpdmUgY29sbGlzaW9uc1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSB8fCBib2R5Qi5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlBhc3NpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBtb3Rpb24gdmFsdWVzIGZvciBzbGVlcGluZ1xyXG4gICAgICAgICAgICAgICAgYm9keUEudXBkYXRlTW90aW9uKCk7XHJcbiAgICAgICAgICAgICAgICBib2R5Qi51cGRhdGVNb3Rpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBQdWJsaXNoIGNvbGxpc2lvbiBldmVudHMgb24gYm90aCBwYXJ0aWNpcGFudHNcclxuICAgICAgICAgICAgY29uc3Qgc2lkZSA9IFNpZGUuZnJvbURpcmVjdGlvbihjb250YWN0Lm10dik7XHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJBLmV2ZW50cy5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IFBvc3RDb2xsaXNpb25FdmVudChjb250YWN0LmNvbGxpZGVyQSwgY29udGFjdC5jb2xsaWRlckIsIHNpZGUsIGNvbnRhY3QubXR2KSk7XHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJBLmV2ZW50cy5lbWl0KCdhZnRlcmNvbGxpc2lvbnJlc29sdmUnLCBuZXcgQ29sbGlzaW9uUG9zdFNvbHZlRXZlbnQoY29udGFjdC5jb2xsaWRlckEsIGNvbnRhY3QuY29sbGlkZXJCLCBzaWRlLCBjb250YWN0Lm10diwgY29udGFjdCkpO1xyXG4gICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQi5ldmVudHMuZW1pdCgncG9zdGNvbGxpc2lvbicsIG5ldyBQb3N0Q29sbGlzaW9uRXZlbnQoY29udGFjdC5jb2xsaWRlckIsIGNvbnRhY3QuY29sbGlkZXJBLCBTaWRlLmdldE9wcG9zaXRlKHNpZGUpLCBjb250YWN0Lm10di5uZWdhdGUoKSkpO1xyXG4gICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQi5ldmVudHMuZW1pdCgnYWZ0ZXJjb2xsaXNpb25yZXNvbHZlJywgbmV3IENvbGxpc2lvblBvc3RTb2x2ZUV2ZW50KGNvbnRhY3QuY29sbGlkZXJCLCBjb250YWN0LmNvbGxpZGVyQSwgU2lkZS5nZXRPcHBvc2l0ZShzaWRlKSwgY29udGFjdC5tdHYubmVnYXRlKCksIGNvbnRhY3QpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3RvcmUgY29udGFjdHNcclxuICAgICAgICB0aGlzLmxhc3RGcmFtZUNvbnRhY3RzLmNsZWFyKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGFzdEZyYW1lQ29udGFjdHMuc2V0KGMuaWQsIGMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2FybSB1cCBib2R5J3MgYmFzZWQgb24gcHJldmlvdXMgZnJhbWUgY29udGFjdCBwb2ludHNcclxuICAgICAqIEBwYXJhbSBjb250YWN0c1xyXG4gICAgICovXHJcbiAgICB3YXJtU3RhcnQoY29udGFjdHMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgYm9keUEgPSAoX2EgPSBjb250YWN0LmNvbGxpZGVyQS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgY29uc3QgYm9keUIgPSAoX2IgPSBjb250YWN0LmNvbGxpZGVyQi5vd25lcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKGJvZHlBICYmIGJvZHlCKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb250YWN0UG9pbnRzID0gKF9jID0gdGhpcy5pZFRvQ29udGFjdENvbnN0cmFpbnQuZ2V0KGNvbnRhY3QuaWQpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgY29udGFjdFBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzLndhcm1TdGFydCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxJbXB1bHNlID0gY29udGFjdC5ub3JtYWwuc2NhbGUocG9pbnQubm9ybWFsSW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhbmdlbnRJbXB1bHNlID0gY29udGFjdC50YW5nZW50LnNjYWxlKHBvaW50LnRhbmdlbnRJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1wdWxzZSA9IG5vcm1hbEltcHVsc2UuYWRkKHRhbmdlbnRJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEuYXBwbHlJbXB1bHNlKHBvaW50LnBvaW50LCBpbXB1bHNlLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuYXBwbHlJbXB1bHNlKHBvaW50LnBvaW50LCBpbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50Lm5vcm1hbEltcHVsc2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC50YW5nZW50SW1wdWxzZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdGVyYXRpdmVseSBzb2x2ZSB0aGUgcG9zaXRpb24gb3ZlcmxhcCBjb25zdHJhaW50XHJcbiAgICAgKiBAcGFyYW0gY29udGFjdHNcclxuICAgICAqL1xyXG4gICAgc29sdmVQb3NpdGlvbihjb250YWN0cykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUGh5c2ljcy5wb3NpdGlvbkl0ZXJhdGlvbnM7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlBID0gKF9hID0gY29udGFjdC5jb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5QiA9IChfYiA9IGNvbnRhY3QuY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBICYmIGJvZHlCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBzb2x2aW5nIGFjdGl2ZStwYXNzaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSB8fCBib2R5Qi5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlBhc3NpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gKF9jID0gdGhpcy5pZFRvQ29udGFjdENvbnN0cmFpbnQuZ2V0KGNvbnRhY3QuaWQpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IGNvbnRhY3Qubm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXBhcmF0aW9uID0gQ29sbGlzaW9uSnVtcFRhYmxlLkZpbmRDb250YWN0U2VwYXJhdGlvbihjb250YWN0LCBwb2ludC5sb2NhbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZWVyaW5nQ29uc3RhbnQgPSBQaHlzaWNzLnN0ZWVyaW5nRmFjdG9yOyAvLzAuMjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF4Q29ycmVjdGlvbiA9IC01O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzbG9wID0gUGh5c2ljcy5zbG9wOyAvLzE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsYW1wIHRvIGF2b2lkIG92ZXItY29ycmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGF0IHdlIGFyZSBzaG9vdGluZyBmb3IgMCBvdmVybGFwIGluIHRoZSBlbmRcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlZXJpbmdGb3JjZSA9IGNsYW1wKHN0ZWVyaW5nQ29uc3RhbnQgKiAoc2VwYXJhdGlvbiArIHNsb3ApLCBtYXhDb3JyZWN0aW9uLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1wdWxzZSA9IG5vcm1hbC5zY2FsZSgtc3RlZXJpbmdGb3JjZSAvIHBvaW50Lm5vcm1hbE1hc3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgcHNldWRvIGltcHVsc2UsIG1lYW5pbmcgd2UgYXJlbid0IGRvaW5nIGEgcmVhbCBpbXB1bHNlIGNhbGN1bGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGFkanVzdCBwb3NpdGlvbiBhbmQgcm90YXRpb24gaW5zdGVhZCBvZiBkb2luZyB0aGUgdmVsb2NpdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5wb3MgPSBib2R5QS5wb3MuYWRkKGltcHVsc2UubmVnYXRlKCkuc2NhbGUoYm9keUEuaW52ZXJzZU1hc3MpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLnJvdGF0aW9uIC09IHBvaW50LmFUb0NvbnRhY3QuY3Jvc3MoaW1wdWxzZSkgKiBib2R5QS5pbnZlcnNlSW5lcnRpYTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLnBvcyA9IGJvZHlCLnBvcy5hZGQoaW1wdWxzZS5zY2FsZShib2R5Qi5pbnZlcnNlTWFzcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIucm90YXRpb24gKz0gcG9pbnQuYlRvQ29udGFjdC5jcm9zcyhpbXB1bHNlKSAqIGJvZHlCLmludmVyc2VJbmVydGlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc29sdmVWZWxvY2l0eShjb250YWN0cykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgUGh5c2ljcy52ZWxvY2l0eUl0ZXJhdGlvbnM7IGkrKykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlBID0gKF9hID0gY29udGFjdC5jb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5QiA9IChfYiA9IGNvbnRhY3QuY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBICYmIGJvZHlCKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBzb2x2aW5nIGFjdGl2ZStwYXNzaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSB8fCBib2R5Qi5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlBhc3NpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3RpdHV0aW9uID0gYm9keUEuYm91bmNpbmVzcyAqIGJvZHlCLmJvdW5jaW5lc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJpY3Rpb24gPSBNYXRoLm1pbihib2R5QS5mcmljdGlvbiwgYm9keUIuZnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gKF9jID0gdGhpcy5pZFRvQ29udGFjdENvbnN0cmFpbnQuZ2V0KGNvbnRhY3QuaWQpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlVmVsb2NpdHkgPSBwb2ludC5nZXRSZWxhdGl2ZVZlbG9jaXR5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZ2F0ZSB2ZWxvY2l0eSBpbiB0YW5nZW50IGRpcmVjdGlvbiB0byBzaW11bGF0ZSBmcmljdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YW5nZW50VmVsb2NpdHkgPSAtcmVsYXRpdmVWZWxvY2l0eS5kb3QoY29udGFjdC50YW5nZW50KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltcHVsc2VEZWx0YSA9IHRhbmdlbnRWZWxvY2l0eSAvIHBvaW50LnRhbmdlbnRNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGFtcGluZyBiYXNlZCBpbiBFcmluIENhdHRvJ3MgR0RDIDIwMDYgdGFsa1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3JyZWN0IGNsYW1waW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9lcmluY2F0dG8vYm94MmQtbGl0ZS9ibG9iL21hc3Rlci9kb2NzL0dEQzIwMDZfQ2F0dG9fRXJpbl9QaHlzaWNzVHV0b3JpYWwucGRmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGVkIGZpY3Rpb24gaW1wdWxzZSBpcyBhbHdheXMgYmV0d2VlbiAtdU1heEZyaWN0aW9uIDwgZFQgPCB1TWF4RnJpY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGRlbHRhcyBjYW4gdmFyeVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhGcmljdGlvbiA9IGZyaWN0aW9uICogcG9pbnQubm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SW1wdWxzZSA9IGNsYW1wKHBvaW50LnRhbmdlbnRJbXB1bHNlICsgaW1wdWxzZURlbHRhLCAtbWF4RnJpY3Rpb24sIG1heEZyaWN0aW9uKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW1wdWxzZURlbHRhID0gbmV3SW1wdWxzZSAtIHBvaW50LnRhbmdlbnRJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC50YW5nZW50SW1wdWxzZSA9IG5ld0ltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltcHVsc2UgPSBjb250YWN0LnRhbmdlbnQuc2NhbGUoaW1wdWxzZURlbHRhKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEuYXBwbHlJbXB1bHNlKHBvaW50LnBvaW50LCBpbXB1bHNlLm5lZ2F0ZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuYXBwbHlJbXB1bHNlKHBvaW50LnBvaW50LCBpbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBjb25zdHJhaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHJlY2FsYyByZWxhdGl2ZSB2ZWxvY2l0eSBiZWNhdXNlIHRoZSBwcmV2aW91cyBzdGVwIGNvdWxkIGhhdmUgY2hhbmdlZCB2ZWxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVWZWxvY2l0eSA9IHBvaW50LmdldFJlbGF0aXZlVmVsb2NpdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29tcHV0ZSBpbXB1bHNlIGluIG5vcm1hbCBkaXJlY3Rpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsVmVsb2NpdHkgPSByZWxhdGl2ZVZlbG9jaXR5LmRvdChjb250YWN0Lm5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db2xsaXNpb25fcmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGltcHVsc2VEZWx0YSA9ICgtKDEgKyByZXN0aXR1dGlvbikgKiBub3JtYWxWZWxvY2l0eSkgLyBwb2ludC5ub3JtYWxNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGFtcGluZyBiYXNlZCBpbiBFcmluIENhdHRvJ3MgR0RDIDIwMTQgdGFsa1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlZCBpbXB1bHNlIHN0b3JlZCBpbiB0aGUgY29udGFjdCBpcyBhbHdheXMgcG9zaXRpdmUgKGRWID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQnV0IGRlbHRhcyBjYW4gYmUgbmVnYXRpdmVcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SW1wdWxzZSA9IE1hdGgubWF4KHBvaW50Lm5vcm1hbEltcHVsc2UgKyBpbXB1bHNlRGVsdGEsIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlRGVsdGEgPSBuZXdJbXB1bHNlIC0gcG9pbnQubm9ybWFsSW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQubm9ybWFsSW1wdWxzZSA9IG5ld0ltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGltcHVsc2UgPSBjb250YWN0Lm5vcm1hbC5zY2FsZShpbXB1bHNlRGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5hcHBseUltcHVsc2UocG9pbnQucG9pbnQsIGltcHVsc2UubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5hcHBseUltcHVsc2UocG9pbnQucG9pbnQsIGltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaXNpb25TeXN0ZW0udHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgQ29sbGlzaW9uU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlcyA9IFsnZXgudHJhbnNmb3JtJywgJ2V4Lm1vdGlvbicsICdleC5jb2xsaWRlciddO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtVHlwZSA9IFN5c3RlbVR5cGUuVXBkYXRlO1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAtMTtcclxuICAgICAgICB0aGlzLl9yZWFsaXN0aWNTb2x2ZXIgPSBuZXcgUmVhbGlzdGljU29sdmVyKCk7XHJcbiAgICAgICAgdGhpcy5fYXJjYWRlU29sdmVyID0gbmV3IEFyY2FkZVNvbHZlcigpO1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3NvciA9IG5ldyBEeW5hbWljVHJlZUNvbGxpc2lvblByb2Nlc3NvcigpO1xyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZUNvbnRhY3RzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZUNvbnRhY3RzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX3RyYWNrQ29sbGlkZXIgPSAoYykgPT4gdGhpcy5fcHJvY2Vzc29yLnRyYWNrKGMpO1xyXG4gICAgICAgIHRoaXMuX3VudHJhY2tDb2xsaWRlciA9IChjKSA9PiB0aGlzLl9wcm9jZXNzb3IudW50cmFjayhjKTtcclxuICAgIH1cclxuICAgIG5vdGlmeShtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKGlzQWRkZWRTeXN0ZW1FbnRpdHkobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJDb21wb25lbnQgPSBtZXNzYWdlLmRhdGEuZ2V0KENvbGxpZGVyQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgY29sbGlkZXJDb21wb25lbnQuJGNvbGxpZGVyQWRkZWQuc3Vic2NyaWJlKHRoaXMuX3RyYWNrQ29sbGlkZXIpO1xyXG4gICAgICAgICAgICBjb2xsaWRlckNvbXBvbmVudC4kY29sbGlkZXJSZW1vdmVkLnN1YnNjcmliZSh0aGlzLl91bnRyYWNrQ29sbGlkZXIpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlciA9IGNvbGxpZGVyQ29tcG9uZW50LmdldCgpO1xyXG4gICAgICAgICAgICBpZiAoY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3Nvci50cmFjayhjb2xsaWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyQ29tcG9uZW50ID0gbWVzc2FnZS5kYXRhLmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyID0gY29sbGlkZXJDb21wb25lbnQuZ2V0KCk7XHJcbiAgICAgICAgICAgIGlmIChjb2xsaWRlckNvbXBvbmVudCAmJiBjb2xsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc29yLnVudHJhY2soY29sbGlkZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShzY2VuZSkge1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZSA9IHNjZW5lLmVuZ2luZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZW50aXRpZXMsIGVsYXBzZWRNcykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoIVBoeXNpY3MuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENvbGxlY3QgdXAgYWxsIHRoZSBjb2xsaWRlcnNcclxuICAgICAgICBsZXQgY29sbGlkZXJzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgX2VudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyQ29tcCA9IGVudGl0eS5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlciA9IGNvbGxpZGVyQ29tcCA9PT0gbnVsbCB8fCBjb2xsaWRlckNvbXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbGxpZGVyQ29tcC5nZXQoKTtcclxuICAgICAgICAgICAgaWYgKGNvbGxpZGVyQ29tcCAmJiAoKF9hID0gY29sbGlkZXJDb21wLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlKSAmJiBjb2xsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXJDb21wLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsaWRlcnMgPSBjb2xsaWRlcnMuY29uY2F0KGNvbGxpZGVyLmdldENvbGxpZGVycygpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpZGVycy5wdXNoKGNvbGxpZGVyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIHNwYXRpYWwgcGFydGl0aW9uaW5nIGRhdGEgc3RydWN0dXJlc1xyXG4gICAgICAgIC8vIFRPRE8gaWYgY29sbGlkZXIgaW52YWxpZCBpdCB3aWxsIGJyZWFrIHRoZSBwcm9jZXNzb3JcclxuICAgICAgICAvLyBUT0RPIHJlbmFtZSBcInVwZGF0ZVwiIHRvIHNvbWV0aGluZyBtb3JlIHNwZWNpZmljXHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc29yLnVwZGF0ZShjb2xsaWRlcnMpO1xyXG4gICAgICAgIC8vIFJ1biBicm9hZHBoYXNlIG9uIGFsbCBjb2xsaWRlcnMgYW5kIGxvY2F0ZXMgcG90ZW50aWFsIGNvbGxpc2lvbnNcclxuICAgICAgICBjb25zdCBwYWlycyA9IHRoaXMuX3Byb2Nlc3Nvci5icm9hZHBoYXNlKGNvbGxpZGVycywgZWxhcHNlZE1zKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWVDb250YWN0cy5jbGVhcigpO1xyXG4gICAgICAgIC8vIEdpdmVuIHBvc3NpYmxlIHBhaXJzIGZpbmQgYWN0dWFsIGNvbnRhY3RzXHJcbiAgICAgICAgbGV0IGNvbnRhY3RzID0gdGhpcy5fcHJvY2Vzc29yLm5hcnJvd3BoYXNlKHBhaXJzLCB0aGlzLl9lbmdpbmUuZGVidWcuc3RhdHMuY3VyckZyYW1lKTtcclxuICAgICAgICBjb25zdCBzb2x2ZXIgPSB0aGlzLmdldFNvbHZlcigpO1xyXG4gICAgICAgIC8vIFNvbHZlLCB0aGlzIHJlc29sdmVzIHRoZSBwb3NpdGlvbi92ZWxvY2l0eSBzbyBlbnRpdGllcyBhcmVudCBvdmVybGFwcGluZ1xyXG4gICAgICAgIGNvbnRhY3RzID0gc29sdmVyLnNvbHZlKGNvbnRhY3RzKTtcclxuICAgICAgICAvLyBSZWNvcmQgY29udGFjdHNcclxuICAgICAgICBjb250YWN0cy5mb3JFYWNoKChjKSA9PiB0aGlzLl9jdXJyZW50RnJhbWVDb250YWN0cy5zZXQoYy5pZCwgYykpO1xyXG4gICAgICAgIC8vIEVtaXQgY29udGFjdCBzdGFydC9lbmQgZXZlbnRzXHJcbiAgICAgICAgdGhpcy5ydW5Db250YWN0U3RhcnRFbmQoKTtcclxuICAgICAgICAvLyByZXNldCB0aGUgbGFzdCBmcmFtZSBjYWNoZVxyXG4gICAgICAgIHRoaXMuX2xhc3RGcmFtZUNvbnRhY3RzLmNsZWFyKCk7XHJcbiAgICAgICAgLy8gS2VlcCB0cmFjayBvZiBjb2xsaXNpb25zIGNvbnRhY3RzIHRoYXQgaGF2ZSBzdGFydGVkIG9yIGVuZGVkXHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lQ29udGFjdHMgPSBuZXcgTWFwKHRoaXMuX2N1cnJlbnRGcmFtZUNvbnRhY3RzKTtcclxuICAgIH1cclxuICAgIGdldFNvbHZlcigpIHtcclxuICAgICAgICByZXR1cm4gUGh5c2ljcy5jb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPT09IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SZWFsaXN0aWMgPyB0aGlzLl9yZWFsaXN0aWNTb2x2ZXIgOiB0aGlzLl9hcmNhZGVTb2x2ZXI7XHJcbiAgICB9XHJcbiAgICBkZWJ1ZyhleCkge1xyXG4gICAgICAgIHRoaXMuX3Byb2Nlc3Nvci5kZWJ1ZyhleCk7XHJcbiAgICB9XHJcbiAgICBydW5Db250YWN0U3RhcnRFbmQoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIGNdIG9mIHRoaXMuX2N1cnJlbnRGcmFtZUNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgYWxsIG5ldyBjb250YWN0c1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2xhc3RGcmFtZUNvbnRhY3RzLmhhcyhpZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyQSA9IGMuY29sbGlkZXJBO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGlkZXJCID0gYy5jb2xsaWRlckI7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlckEuZXZlbnRzLmVtaXQoJ2NvbGxpc2lvbnN0YXJ0JywgbmV3IENvbGxpc2lvblN0YXJ0RXZlbnQoY29sbGlkZXJBLCBjb2xsaWRlckIsIGMpKTtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQS5ldmVudHMuZW1pdCgnY29udGFjdHN0YXJ0JywgbmV3IENvbnRhY3RTdGFydEV2ZW50KGNvbGxpZGVyQSwgY29sbGlkZXJCLCBjKSk7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlckIuZXZlbnRzLmVtaXQoJ2NvbGxpc2lvbnN0YXJ0JywgbmV3IENvbGxpc2lvblN0YXJ0RXZlbnQoY29sbGlkZXJCLCBjb2xsaWRlckEsIGMpKTtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQi5ldmVudHMuZW1pdCgnY29udGFjdHN0YXJ0JywgbmV3IENvbnRhY3RTdGFydEV2ZW50KGNvbGxpZGVyQiwgY29sbGlkZXJBLCBjKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZmluZCBhbGwgY29udGFjdHMgdGFodCBoYXZlIGNlYXNlZFxyXG4gICAgICAgIGZvciAoY29uc3QgW2lkLCBjXSBvZiB0aGlzLl9sYXN0RnJhbWVDb250YWN0cykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2N1cnJlbnRGcmFtZUNvbnRhY3RzLmhhcyhpZCkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyQSA9IGMuY29sbGlkZXJBO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGlkZXJCID0gYy5jb2xsaWRlckI7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlckEuZXZlbnRzLmVtaXQoJ2NvbGxpc2lvbmVuZCcsIG5ldyBDb2xsaXNpb25FbmRFdmVudChjb2xsaWRlckEsIGNvbGxpZGVyQikpO1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXJBLmV2ZW50cy5lbWl0KCdjb250YWN0ZW5kJywgbmV3IENvbnRhY3RFbmRFdmVudChjb2xsaWRlckEsIGNvbGxpZGVyQikpO1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdjb2xsaXNpb25lbmQnLCBuZXcgQ29sbGlzaW9uRW5kRXZlbnQoY29sbGlkZXJCLCBjb2xsaWRlckEpKTtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQi5ldmVudHMuZW1pdCgnY29udGFjdGVuZCcsIG5ldyBDb250YWN0RW5kRXZlbnQoY29sbGlkZXJCLCBjb2xsaWRlckEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0FuaW1hdGlvbi50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIEFuaW1hdGlvbkRpcmVjdGlvbjtcclxuKGZ1bmN0aW9uIChBbmltYXRpb25EaXJlY3Rpb24pIHtcclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIGlzIHBsYXlpbmcgZm9yd2FyZHNcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uRGlyZWN0aW9uW1wiRm9yd2FyZFwiXSA9IFwiZm9yd2FyZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbmltYXRpb24gaXMgcGxheSBiYWNrd2FyZHNcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uRGlyZWN0aW9uW1wiQmFja3dhcmRcIl0gPSBcImJhY2t3YXJkXCI7XHJcbn0pKEFuaW1hdGlvbkRpcmVjdGlvbiB8fCAoQW5pbWF0aW9uRGlyZWN0aW9uID0ge30pKTtcclxudmFyIEFuaW1hdGlvblN0cmF0ZWd5O1xyXG4oZnVuY3Rpb24gKEFuaW1hdGlvblN0cmF0ZWd5KSB7XHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbiBlbmRzIHdpdGhvdXQgZGlzcGxheWluZyBhbnl0aGluZ1xyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25TdHJhdGVneVtcIkVuZFwiXSA9IFwiZW5kXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbiBsb29wcyB0byB0aGUgZmlyc3QgZnJhbWUgYWZ0ZXIgdGhlIGxhc3QgZnJhbWVcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uU3RyYXRlZ3lbXCJMb29wXCJdID0gXCJsb29wXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbiBwbGF5cyB0byB0aGUgbGFzdCBmcmFtZSwgdGhlbiBiYWNrd2FyZHMgdG8gdGhlIGZpcnN0IGZyYW1lLCB0aGVuIHJlcGVhdHNcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uU3RyYXRlZ3lbXCJQaW5nUG9uZ1wiXSA9IFwicGluZ3BvbmdcIjtcclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIGVuZHMgc3RvcHBpbmcgb24gdGhlIGxhc3QgZnJhbWVcclxuICAgICAqL1xyXG4gICAgQW5pbWF0aW9uU3RyYXRlZ3lbXCJGcmVlemVcIl0gPSBcImZyZWV6ZVwiO1xyXG59KShBbmltYXRpb25TdHJhdGVneSB8fCAoQW5pbWF0aW9uU3RyYXRlZ3kgPSB7fSkpO1xyXG4vKipcclxuICogQ3JlYXRlIGFuIEFuaW1hdGlvbiBnaXZlbiBhIGxpc3Qgb2YgW1tGcmFtZXxmcmFtZXNdXSBpbiBbW0FuaW1hdGlvbk9wdGlvbnNdXVxyXG4gKlxyXG4gKiBUbyBjcmVhdGUgYW4gQW5pbWF0aW9uIGZyb20gYSBbW1Nwcml0ZVNoZWV0XV0sIHVzZSBbW0FuaW1hdGlvbi5mcm9tU3ByaXRlU2hlZXRdXVxyXG4gKi9cclxuY2xhc3MgQW5pbWF0aW9uIGV4dGVuZHMgR3JhcGhpYyB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIodGhpcyk7IC8vIFRPRE8gcmVwbGFjZSB3aXRoIG5ldyBFbWl0dGVyXHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnN0cmF0ZWd5ID0gQW5pbWF0aW9uU3RyYXRlZ3kuTG9vcDtcclxuICAgICAgICB0aGlzLmZyYW1lRHVyYXRpb24gPSAxMDA7XHJcbiAgICAgICAgdGhpcy50aW1lU2NhbGUgPSAxO1xyXG4gICAgICAgIHRoaXMuX2lkZW1wb3RlbmN5VG9rZW4gPSAtMTtcclxuICAgICAgICB0aGlzLl9maXJzdFRpY2sgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fdGltZUxlZnRJbkZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxOyAvLyBUT0RPIG9ubHkgdXNlZCBpbiBwaW5nLXBvbmdcclxuICAgICAgICB0aGlzLl9kb25lID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fcmV2ZXJzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IG9wdGlvbnMuZnJhbWVzO1xyXG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSAoX2EgPSBvcHRpb25zLnN0cmF0ZWd5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnN0cmF0ZWd5O1xyXG4gICAgICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IG9wdGlvbnMudG90YWxEdXJhdGlvbiA/IG9wdGlvbnMudG90YWxEdXJhdGlvbiAvIHRoaXMuZnJhbWVzLmxlbmd0aCA6IChfYiA9IG9wdGlvbnMuZnJhbWVEdXJhdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5mcmFtZUR1cmF0aW9uO1xyXG4gICAgICAgIGlmIChvcHRpb25zLnJldmVyc2UpIHtcclxuICAgICAgICAgICAgdGhpcy5yZXZlcnNlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ29Ub0ZyYW1lKDApO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb24oT2JqZWN0LmFzc2lnbih7IGZyYW1lczogdGhpcy5mcmFtZXMubWFwKChmKSA9PiAoT2JqZWN0LmFzc2lnbih7fSwgZikpKSwgZnJhbWVEdXJhdGlvbjogdGhpcy5mcmFtZUR1cmF0aW9uLCByZXZlcnNlOiB0aGlzLl9yZXZlcnNlZCwgc3RyYXRlZ3k6IHRoaXMuc3RyYXRlZ3kgfSwgdGhpcy5jbG9uZUdyYXBoaWNPcHRpb25zKCkpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIEFuaW1hdGlvbiBmcm9tIGEgW1tTcHJpdGVTaGVldF1dLCBhIGxpc3Qgb2YgaW5kaWNlcyBpbnRvIHRoZSBzcHJpdGUgc2hlZXQsIGEgZHVyYXRpb24gcGVyIGZyYW1lXHJcbiAgICAgKiBhbmQgb3B0aW9uYWwgW1tBbmltYXRpb25TdHJhdGVneV1dXHJcbiAgICAgKlxyXG4gICAgICogRXhhbXBsZTpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIGNvbnN0IHNwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXQuZnJvbUltYWdlU291cmNlKHsuLi59KTtcclxuICAgICAqXHJcbiAgICAgKiBjb25zdCBhbmltID0gQW5pbWF0aW9uLmZyb21TcHJpdGVTaGVldChzcHJpdGVTaGVldCwgcmFuZ2UoMCwgNSksIDIwMCwgQW5pbWF0aW9uU3RyYXRlZ3kuTG9vcCk7XHJcbiAgICAgKiBgYGBcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3ByaXRlU2hlZXRcclxuICAgICAqIEBwYXJhbSBmcmFtZUluZGljZXNcclxuICAgICAqIEBwYXJhbSBkdXJhdGlvblBlckZyYW1lTXNcclxuICAgICAqIEBwYXJhbSBzdHJhdGVneVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVNwcml0ZVNoZWV0KHNwcml0ZVNoZWV0LCBmcmFtZUluZGljZXMsIGR1cmF0aW9uUGVyRnJhbWVNcywgc3RyYXRlZ3kgPSBBbmltYXRpb25TdHJhdGVneS5Mb29wKSB7XHJcbiAgICAgICAgY29uc3QgbWF4SW5kZXggPSBzcHJpdGVTaGVldC5zcHJpdGVzLmxlbmd0aCAtIDE7XHJcbiAgICAgICAgY29uc3QgaW52YWxpZEluZGljZXMgPSBmcmFtZUluZGljZXMuZmlsdGVyKChpbmRleCkgPT4gaW5kZXggPCAwIHx8IGluZGV4ID4gbWF4SW5kZXgpO1xyXG4gICAgICAgIGlmIChpbnZhbGlkSW5kaWNlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgQW5pbWF0aW9uLl9MT0dHRVIud2FybihgSW5kaWNlcyBpbnRvIFNwcml0ZVNoZWV0IHdlcmUgcHJvdmlkZWQgdGhhdCBkb25cXCd0IGV4aXN0OiAke2ludmFsaWRJbmRpY2VzLmpvaW4oJywnKX0gbm8gZnJhbWUgd2lsbCBiZSBzaG93bmApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbih7XHJcbiAgICAgICAgICAgIGZyYW1lczogc3ByaXRlU2hlZXQuc3ByaXRlc1xyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoXywgaW5kZXgpID0+IGZyYW1lSW5kaWNlcy5pbmRleE9mKGluZGV4KSA+IC0xKVxyXG4gICAgICAgICAgICAgICAgLm1hcCgoZikgPT4gKHtcclxuICAgICAgICAgICAgICAgIGdyYXBoaWM6IGYsXHJcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb25QZXJGcmFtZU1zXHJcbiAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgc3RyYXRlZ3k6IHN0cmF0ZWd5XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGFuIGFuaW1hdGlvbiB0byBhIGxlZ2FjeSBhbmltYXRpb25cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcGFyYW0gZW5naW5lXHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uXHJcbiAgICAgKiBAcmV0dXJucyBMZWdhY3lEcmF3aW5nLkFuaW1hdGlvblxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdG9MZWdhY3lBbmltYXRpb24oZW5naW5lLCBhbmltYXRpb24pIHtcclxuICAgICAgICBjb25zdCBsZWdhY3lTcHJpdGVzID0gYW5pbWF0aW9uLmZyYW1lcy5tYXAoZiA9PiBTcHJpdGUudG9MZWdhY3lTcHJpdGUoZi5ncmFwaGljKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25fQW5pbWF0aW9uKHtcclxuICAgICAgICAgICAgc3ByaXRlczogbGVnYWN5U3ByaXRlcyxcclxuICAgICAgICAgICAgbG9vcDogYW5pbWF0aW9uLnN0cmF0ZWd5ID09PSBBbmltYXRpb25TdHJhdGVneS5Mb29wLFxyXG4gICAgICAgICAgICBmcmVlemVGcmFtZTogYW5pbWF0aW9uLnN0cmF0ZWd5ID09PSBBbmltYXRpb25TdHJhdGVneS5GcmVlemUgPyBsZWdhY3lTcHJpdGVzLmxlbmd0aCAtIDEgOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHNwZWVkOiBhbmltYXRpb24uZnJhbWVEdXJhdGlvbixcclxuICAgICAgICAgICAgZW5naW5lOiBlbmdpbmVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBGcmFtZSBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldCBjdXJyZW50RnJhbWUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRGcmFtZSA+PSAwICYmIHRoaXMuX2N1cnJlbnRGcmFtZSA8IHRoaXMuZnJhbWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcmFtZXNbdGhpcy5fY3VycmVudEZyYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgZnJhbWUgaW5kZXggb2YgdGhlIGFuaW1hdGlvblxyXG4gICAgICovXHJcbiAgICBnZXQgY3VycmVudEZyYW1lSW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRGcmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFuaW1hdGlvbiBpcyBwbGF5aW5nXHJcbiAgICAgKi9cclxuICAgIGdldCBpc1BsYXlpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BsYXlpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldmVyc2VzIHRoZSBwbGF5IGRpcmVjdGlvbiBvZiB0aGUgQW5pbWF0aW9uLCB0aGlzIHByZXNlcnZlcyB0aGUgY3VycmVudCBmcmFtZVxyXG4gICAgICovXHJcbiAgICByZXZlcnNlKCkge1xyXG4gICAgICAgIC8vIERvbid0IG11dGF0ZSB3aXRoIHRoZSBvcmlnaW5hbCBmcmFtZSBsaXN0LCBjcmVhdGUgYSBjb3B5XHJcbiAgICAgICAgdGhpcy5mcmFtZXMgPSB0aGlzLmZyYW1lcy5zbGljZSgpLnJldmVyc2UoKTtcclxuICAgICAgICB0aGlzLl9yZXZlcnNlZCA9ICF0aGlzLl9yZXZlcnNlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBwbGF5IGRpcmVjdGlvbiBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldCBkaXJlY3Rpb24oKSB7XHJcbiAgICAgICAgLy8gS2VlcCBsb2dpY2FsbHkgY29uc2lzdGVudCB3aXRoIHBpbmctcG9uZyBkaXJlY3Rpb25cclxuICAgICAgICAvLyBJZiBwaW5nLXBvbmcgaXMgZm9yd2FyZCA9IDEgYW5kIHJldmVyc2VkIGlzIHRydWUgdGhlbiB3ZSBhcmUgbG9naWNhbGx5IHJldmVyc2VkXHJcbiAgICAgICAgY29uc3QgcmV2ZXJzZWQgPSAodGhpcy5fcmV2ZXJzZWQgJiYgdGhpcy5fZGlyZWN0aW9uID09PSAxKSA/IHRydWUgOiBmYWxzZTtcclxuICAgICAgICByZXR1cm4gcmV2ZXJzZWQgPyBBbmltYXRpb25EaXJlY3Rpb24uQmFja3dhcmQgOiBBbmltYXRpb25EaXJlY3Rpb24uRm9yd2FyZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGxheXMgb3IgcmVzdW1lcyB0aGUgYW5pbWF0aW9uIGZyb20gdGhlIGN1cnJlbnQgZnJhbWVcclxuICAgICAqL1xyXG4gICAgcGxheSgpIHtcclxuICAgICAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGF1c2VzIHRoZSBhbmltYXRpb24gb24gdGhlIGN1cnJlbnQgZnJhbWVcclxuICAgICAqL1xyXG4gICAgcGF1c2UoKSB7XHJcbiAgICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2ZpcnN0VGljayA9IHRydWU7IC8vIGZpcnN0VGljayBtdXN0IGJlIHNldCB0byBlbWl0IHRoZSBwcm9wZXIgZnJhbWUgZXZlbnRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGFuaW1hdGlvbiBiYWNrIHRvIHRoZSBiZWdpbm5pbmcsIGluY2x1ZGluZyBpZiB0aGUgYW5pbWF0aW9uIHdlcmUgZG9uZVxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9kb25lID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZmlyc3RUaWNrID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYW5pbWF0aW9uIGNhbiBlbmRcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbkZpbmlzaCgpIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TdHJhdGVneS5FbmQ6XHJcbiAgICAgICAgICAgIGNhc2UgQW5pbWF0aW9uU3RyYXRlZ3kuRnJlZXplOiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBhbmltYXRpb24gaXMgZG9uZSwgZm9yIGxvb3BpbmcgdHlwZSBhbmltYXRpb25zXHJcbiAgICAgKiBgZXguQW5pbWF0aW9uU3RyYXRlZ3kuUGluZ1BvbmdgIGFuZCBgZXguQW5pbWF0aW9uU3RyYXRlZ3kuTG9vcGAgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gYGZhbHNlYFxyXG4gICAgICpcclxuICAgICAqIFNlZSB0aGUgYGV4LkFuaW1hdGlvbi5jYW5GaW5pc2goKWAgbWV0aG9kIHRvIGtub3cgaWYgYW4gYW5pbWF0aW9uIHR5cGUgY2FuIGVuZFxyXG4gICAgICovXHJcbiAgICBnZXQgZG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZG9uZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSnVtcCB0aGUgYW5pbWF0aW9uIGltbWVkaWF0ZWx5IHRvIGEgc3BlY2lmaWMgZnJhbWUgaWYgaXQgZXhpc3RzXHJcbiAgICAgKiBAcGFyYW0gZnJhbWVOdW1iZXJcclxuICAgICAqL1xyXG4gICAgZ29Ub0ZyYW1lKGZyYW1lTnVtYmVyKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSBmcmFtZU51bWJlcjtcclxuICAgICAgICB0aGlzLl90aW1lTGVmdEluRnJhbWUgPSB0aGlzLmZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgY29uc3QgbWF5YmVGcmFtZSA9IHRoaXMuZnJhbWVzW3RoaXMuX2N1cnJlbnRGcmFtZV07XHJcbiAgICAgICAgaWYgKG1heWJlRnJhbWUgJiYgIXRoaXMuX2RvbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGltZUxlZnRJbkZyYW1lID0gKG1heWJlRnJhbWUgPT09IG51bGwgfHwgbWF5YmVGcmFtZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbWF5YmVGcmFtZS5kdXJhdGlvbikgfHwgdGhpcy5mcmFtZUR1cmF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gKF9hID0gbWF5YmVGcmFtZS5ncmFwaGljKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gKF9iID0gbWF5YmVGcmFtZS5ncmFwaGljKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0O1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdmcmFtZScsIG1heWJlRnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9uZXh0RnJhbWUoKSB7XHJcbiAgICAgICAgY29uc3QgY3VycmVudEZyYW1lID0gdGhpcy5fY3VycmVudEZyYW1lO1xyXG4gICAgICAgIGlmICh0aGlzLl9kb25lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RnJhbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBuZXh0ID0gLTE7XHJcbiAgICAgICAgc3dpdGNoICh0aGlzLnN0cmF0ZWd5KSB7XHJcbiAgICAgICAgICAgIGNhc2UgQW5pbWF0aW9uU3RyYXRlZ3kuTG9vcDoge1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IChjdXJyZW50RnJhbWUgKyAxKSAlIHRoaXMuZnJhbWVzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnbG9vcCcsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TdHJhdGVneS5FbmQ6IHtcclxuICAgICAgICAgICAgICAgIG5leHQgPSBjdXJyZW50RnJhbWUgKyAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gdGhpcy5mcmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lID0gdGhpcy5mcmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2VuZCcsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TdHJhdGVneS5GcmVlemU6IHtcclxuICAgICAgICAgICAgICAgIG5leHQgPSBjbGFtcChjdXJyZW50RnJhbWUgKyAxLCAwLCB0aGlzLmZyYW1lcy5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgICAgIGlmIChuZXh0ID49IHRoaXMuZnJhbWVzLmxlbmd0aCAtIDEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdlbmQnLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgQW5pbWF0aW9uU3RyYXRlZ3kuUGluZ1Bvbmc6IHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RnJhbWUgKyB0aGlzLl9kaXJlY3Rpb24gPj0gdGhpcy5mcmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnbG9vcCcsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSArIHRoaXMuX2RpcmVjdGlvbiA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2xvb3AnLCB0aGlzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIG5leHQgPSBjdXJyZW50RnJhbWUgKyAodGhpcy5fZGlyZWN0aW9uICUgdGhpcy5mcmFtZXMubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXh0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgaW50ZXJuYWxseSBieSBFeGNhbGlidXIgdG8gdXBkYXRlIHRoZSBzdGF0ZSBvZiB0aGUgYW5pbWF0aW9uIHBvdGVudGlhbCB1cGRhdGUgdGhlIGN1cnJlbnQgZnJhbWVcclxuICAgICAqIEBwYXJhbSBlbGFwc2VkTWlsbGlzZWNvbmRzIE1pbGxpc2Vjb25kcyBlbGFwc2VkXHJcbiAgICAgKiBAcGFyYW0gaWRlbXBvdGVuY3lUb2tlbiBQcmV2ZW50cyBkb3VibGUgdGlja2luZyBpbiBhIGZyYW1lIGJ5IHBhc3NpbmcgYSB1bmlxdWUgdG9rZW4gdG8gdGhlIGZyYW1lXHJcbiAgICAgKi9cclxuICAgIHRpY2soZWxhcHNlZE1pbGxpc2Vjb25kcywgaWRlbXBvdGVuY3lUb2tlbiA9IDApIHtcclxuICAgICAgICBpZiAodGhpcy5faWRlbXBvdGVuY3lUb2tlbiA9PT0gaWRlbXBvdGVuY3lUb2tlbikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lkZW1wb3RlbmN5VG9rZW4gPSBpZGVtcG90ZW5jeVRva2VuO1xyXG4gICAgICAgIGlmICghdGhpcy5fcGxheWluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIGl0J3MgdGhlIGZpcnN0IGZyYW1lIGVtaXQgZnJhbWUgZXZlbnRcclxuICAgICAgICBpZiAodGhpcy5fZmlyc3RUaWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0VGljayA9IGZhbHNlO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdmcmFtZScsIHRoaXMuY3VycmVudEZyYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGltZUxlZnRJbkZyYW1lIC09IGVsYXBzZWRNaWxsaXNlY29uZHMgKiB0aGlzLnRpbWVTY2FsZTtcclxuICAgICAgICBpZiAodGhpcy5fdGltZUxlZnRJbkZyYW1lIDw9IDApIHtcclxuICAgICAgICAgICAgdGhpcy5nb1RvRnJhbWUodGhpcy5fbmV4dEZyYW1lKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRGltZW5zaW9ucygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRGcmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLndpZHRoID0gKF9hID0gdGhpcy5jdXJyZW50RnJhbWUuZ3JhcGhpYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmhlaWdodCA9IChfYiA9IHRoaXMuY3VycmVudEZyYW1lLmdyYXBoaWMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RyYXdJbWFnZShjdHgsIHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RnJhbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUuZ3JhcGhpYy5kcmF3KGN0eCwgeCwgeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbkFuaW1hdGlvbi5fTE9HR0VSID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvR3JhcGhpY3NHcm91cC50c1xuXHJcblxyXG5cclxuY2xhc3MgR3JhcGhpY3NHcm91cCBleHRlbmRzIEdyYXBoaWMge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMubWVtYmVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMubWVtYmVycyA9IG9wdGlvbnMubWVtYmVycztcclxuICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEdyYXBoaWNzR3JvdXAoT2JqZWN0LmFzc2lnbih7IG1lbWJlcnM6IFsuLi50aGlzLm1lbWJlcnNdIH0sIHRoaXMuY2xvbmVHcmFwaGljT3B0aW9ucygpKSk7XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRGltZW5zaW9ucygpIHtcclxuICAgICAgICBsZXQgYmIgPSBuZXcgQm91bmRpbmdCb3goKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHsgZ3JhcGhpYywgcG9zIH0gb2YgdGhpcy5tZW1iZXJzKSB7XHJcbiAgICAgICAgICAgIGJiID0gZ3JhcGhpYy5sb2NhbEJvdW5kcy50cmFuc2xhdGUocG9zKS5jb21iaW5lKGJiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IGJiLndpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gYmIuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiBiYjtcclxuICAgIH1cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICBsZXQgYmIgPSBuZXcgQm91bmRpbmdCb3goKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHsgZ3JhcGhpYywgcG9zIH0gb2YgdGhpcy5tZW1iZXJzKSB7XHJcbiAgICAgICAgICAgIGJiID0gZ3JhcGhpYy5sb2NhbEJvdW5kcy50cmFuc2xhdGUocG9zKS5jb21iaW5lKGJiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfVxyXG4gICAgX2lzQW5pbWF0aW9uT3JHcm91cChncmFwaGljKSB7XHJcbiAgICAgICAgcmV0dXJuIGdyYXBoaWMgaW5zdGFuY2VvZiBBbmltYXRpb24gfHwgZ3JhcGhpYyBpbnN0YW5jZW9mIEdyYXBoaWNzR3JvdXA7XHJcbiAgICB9XHJcbiAgICB0aWNrKGVsYXBzZWRNaWxsaXNlY29uZHMsIGlkZW1wb3RlbmN5VG9rZW4pIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0aGlzLm1lbWJlcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgbWF5YmVBbmltYXRpb24gPSBtZW1iZXIuZ3JhcGhpYztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQW5pbWF0aW9uT3JHcm91cChtYXliZUFuaW1hdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIG1heWJlQW5pbWF0aW9uLnRpY2soZWxhcHNlZE1pbGxpc2Vjb25kcywgaWRlbXBvdGVuY3lUb2tlbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0aGlzLm1lbWJlcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgbWF5YmVBbmltYXRpb24gPSBtZW1iZXIuZ3JhcGhpYztcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzQW5pbWF0aW9uT3JHcm91cChtYXliZUFuaW1hdGlvbikpIHtcclxuICAgICAgICAgICAgICAgIG1heWJlQW5pbWF0aW9uLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJlRHJhdyhleCwgeCwgeSkge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcclxuICAgICAgICBzdXBlci5fcHJlRHJhdyhleCwgeCwgeSk7XHJcbiAgICB9XHJcbiAgICBfZHJhd0ltYWdlKGV4LCB4LCB5KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGhpcy5tZW1iZXJzKSB7XHJcbiAgICAgICAgICAgIGV4LnNhdmUoKTtcclxuICAgICAgICAgICAgZXgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgICAgICBtZW1iZXIuZ3JhcGhpYy5kcmF3KGV4LCBtZW1iZXIucG9zLngsIG1lbWJlci5wb3MueSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnNob3dEZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgIGV4LmRlYnVnLmRyYXdSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBleC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUGFydGljbGVzLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBbiBlbnVtIHRoYXQgcmVwcmVzZW50cyB0aGUgdHlwZXMgb2YgZW1pdHRlciBub3p6bGVzXHJcbiAqL1xyXG52YXIgRW1pdHRlclR5cGU7XHJcbihmdW5jdGlvbiAoRW1pdHRlclR5cGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RhbnQgZm9yIHRoZSBjaXJjdWxhciBlbWl0dGVyIHR5cGVcclxuICAgICAqL1xyXG4gICAgRW1pdHRlclR5cGVbRW1pdHRlclR5cGVbXCJDaXJjbGVcIl0gPSAwXSA9IFwiQ2lyY2xlXCI7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0YW50IGZvciB0aGUgcmVjdGFuZ3VsYXIgZW1pdHRlciB0eXBlXHJcbiAgICAgKi9cclxuICAgIEVtaXR0ZXJUeXBlW0VtaXR0ZXJUeXBlW1wiUmVjdGFuZ2xlXCJdID0gMV0gPSBcIlJlY3RhbmdsZVwiO1xyXG59KShFbWl0dGVyVHlwZSB8fCAoRW1pdHRlclR5cGUgPSB7fSkpO1xyXG4vKipcclxuICogQGhpZGRlblxyXG4gKi9cclxuY2xhc3MgUGFydGljbGVJbXBsIGV4dGVuZHMgRW50aXR5IHtcclxuICAgIGNvbnN0cnVjdG9yKGVtaXR0ZXJPckNvbmZpZywgbGlmZSwgb3BhY2l0eSwgYmVnaW5Db2xvciwgZW5kQ29sb3IsIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYWNjZWxlcmF0aW9uLCBzdGFydFNpemUsIGVuZFNpemUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ID0gMDtcclxuICAgICAgICB0aGlzLmN1cnJlbnRSb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5mb2N1cyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5mb2N1c0FjY2VsID0gMDtcclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgIHRoaXMuYmVnaW5Db2xvciA9IENvbG9yLldoaXRlO1xyXG4gICAgICAgIHRoaXMuZW5kQ29sb3IgPSBDb2xvci5XaGl0ZTtcclxuICAgICAgICAvLyBMaWZlIGlzIGNvdW50ZWQgaW4gbXNcclxuICAgICAgICB0aGlzLmxpZmUgPSAzMDA7XHJcbiAgICAgICAgdGhpcy5mYWRlRmxhZyA9IGZhbHNlO1xyXG4gICAgICAgIC8vIENvbG9yIHRyYW5zaXRpb25zXHJcbiAgICAgICAgdGhpcy5fclJhdGUgPSAxO1xyXG4gICAgICAgIHRoaXMuX2dSYXRlID0gMTtcclxuICAgICAgICB0aGlzLl9iUmF0ZSA9IDE7XHJcbiAgICAgICAgdGhpcy5fYVJhdGUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvciA9IENvbG9yLldoaXRlO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSA1O1xyXG4gICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuc2l6ZVJhdGUgPSAwO1xyXG4gICAgICAgIHRoaXMuZWxhcHNlZE11bHRpcGxpZXIgPSAwO1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5pc09mZnNjcmVlbiA9IGZhbHNlO1xyXG4gICAgICAgIGxldCBlbWl0dGVyID0gZW1pdHRlck9yQ29uZmlnO1xyXG4gICAgICAgIGlmIChlbWl0dGVyICYmICEoZW1pdHRlck9yQ29uZmlnIGluc3RhbmNlb2YgUGFydGljbGVFbWl0dGVyKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBlbWl0dGVyT3JDb25maWc7XHJcbiAgICAgICAgICAgIGVtaXR0ZXIgPSBjb25maWcuZW1pdHRlcjtcclxuICAgICAgICAgICAgbGlmZSA9IGNvbmZpZy5saWZlO1xyXG4gICAgICAgICAgICBvcGFjaXR5ID0gY29uZmlnLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIGVuZENvbG9yID0gY29uZmlnLmVuZENvbG9yO1xyXG4gICAgICAgICAgICBiZWdpbkNvbG9yID0gY29uZmlnLmJlZ2luQ29sb3I7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uID0gY29uZmlnLnBvc2l0aW9uO1xyXG4gICAgICAgICAgICB2ZWxvY2l0eSA9IGNvbmZpZy52ZWxvY2l0eTtcclxuICAgICAgICAgICAgYWNjZWxlcmF0aW9uID0gY29uZmlnLmFjY2VsZXJhdGlvbjtcclxuICAgICAgICAgICAgc3RhcnRTaXplID0gY29uZmlnLnN0YXJ0U2l6ZTtcclxuICAgICAgICAgICAgZW5kU2l6ZSA9IGNvbmZpZy5lbmRTaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBlbWl0dGVyO1xyXG4gICAgICAgIHRoaXMubGlmZSA9IGxpZmUgfHwgdGhpcy5saWZlO1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IG9wYWNpdHkgfHwgdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgIHRoaXMuZW5kQ29sb3IgPSBlbmRDb2xvciB8fCB0aGlzLmVuZENvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gYmVnaW5Db2xvciB8fCB0aGlzLmJlZ2luQ29sb3IuY2xvbmUoKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSB0aGlzLmJlZ2luQ29sb3IuY2xvbmUoKTtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gKHBvc2l0aW9uIHx8IHRoaXMucG9zaXRpb24pLmFkZCh0aGlzLmVtaXR0ZXIucG9zKTtcclxuICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdmVsb2NpdHkgfHwgdGhpcy52ZWxvY2l0eTtcclxuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IGFjY2VsZXJhdGlvbiB8fCB0aGlzLmFjY2VsZXJhdGlvbjtcclxuICAgICAgICB0aGlzLl9yUmF0ZSA9ICh0aGlzLmVuZENvbG9yLnIgLSB0aGlzLmJlZ2luQ29sb3IucikgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgdGhpcy5fZ1JhdGUgPSAodGhpcy5lbmRDb2xvci5nIC0gdGhpcy5iZWdpbkNvbG9yLmcpIC8gdGhpcy5saWZlO1xyXG4gICAgICAgIHRoaXMuX2JSYXRlID0gKHRoaXMuZW5kQ29sb3IuYiAtIHRoaXMuYmVnaW5Db2xvci5iKSAvIHRoaXMubGlmZTtcclxuICAgICAgICB0aGlzLl9hUmF0ZSA9IHRoaXMub3BhY2l0eSAvIHRoaXMubGlmZTtcclxuICAgICAgICB0aGlzLnN0YXJ0U2l6ZSA9IHN0YXJ0U2l6ZSB8fCAwO1xyXG4gICAgICAgIHRoaXMuZW5kU2l6ZSA9IGVuZFNpemUgfHwgMDtcclxuICAgICAgICBpZiAodGhpcy5lbmRTaXplID4gMCAmJiB0aGlzLnN0YXJ0U2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5zaXplUmF0ZSA9ICh0aGlzLmVuZFNpemUgLSB0aGlzLnN0YXJ0U2l6ZSkgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVTaXplID0gdGhpcy5zdGFydFNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KCh0aGlzLnRyYW5zZm9ybSA9IG5ldyBUcmFuc2Zvcm1Db21wb25lbnQoKSkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBDYW52YXNEcmF3Q29tcG9uZW50KChjdHgpID0+IHRoaXMuZHJhdyhjdHgpKSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoKHRoaXMuZ3JhcGhpY3MgPSBuZXcgR3JhcGhpY3NDb21wb25lbnQoKSkpO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnBvcyA9IHRoaXMucG9zaXRpb247XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gPSB0aGlzLmN1cnJlbnRSb3RhdGlvbjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5zY2FsZSA9IHZlYygxLCAxKTsgLy8gVE9ETyB3dXRcclxuICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVNwcml0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MudXNlKFNwcml0ZS5mcm9tTGVnYWN5U3ByaXRlKHRoaXMucGFydGljbGVTcHJpdGUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3Mub25Qb3N0RHJhdyA9IChjdHgpID0+IHtcclxuICAgICAgICAgICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdyYXBoaWNzLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0bXBDb2xvciA9IHRoaXMuX2N1cnJlbnRDb2xvci5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgdG1wQ29sb3IuYSA9IDE7XHJcbiAgICAgICAgICAgICAgICBjdHguZGVidWcuZHJhd1BvaW50KHZlYygwLCAwKSwgeyBjb2xvcjogdG1wQ29sb3IsIHNpemU6IHRoaXMucGFydGljbGVTaXplIH0pO1xyXG4gICAgICAgICAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBraWxsKCkge1xyXG4gICAgICAgIHRoaXMuZW1pdHRlci5yZW1vdmVQYXJ0aWNsZSh0aGlzKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMubGlmZSA9IHRoaXMubGlmZSAtIGRlbHRhO1xyXG4gICAgICAgIHRoaXMuZWxhcHNlZE11bHRpcGxpZXIgPSB0aGlzLmVsYXBzZWRNdWx0aXBsaWVyICsgZGVsdGE7XHJcbiAgICAgICAgaWYgKHRoaXMubGlmZSA8IDApIHtcclxuICAgICAgICAgICAgdGhpcy5raWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZhZGVGbGFnKSB7XHJcbiAgICAgICAgICAgIHRoaXMub3BhY2l0eSA9IGNsYW1wKHRoaXMuX2FSYXRlICogdGhpcy5saWZlLCAwLjAwMDEsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdGFydFNpemUgPiAwICYmIHRoaXMuZW5kU2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSBjbGFtcCh0aGlzLnNpemVSYXRlICogZGVsdGEgKyB0aGlzLnBhcnRpY2xlU2l6ZSwgTWF0aC5taW4odGhpcy5zdGFydFNpemUsIHRoaXMuZW5kU2l6ZSksIE1hdGgubWF4KHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLnIgPSBjbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuciArIHRoaXMuX3JSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmcgPSBjbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuZyArIHRoaXMuX2dSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmIgPSBjbGFtcCh0aGlzLl9jdXJyZW50Q29sb3IuYiArIHRoaXMuX2JSYXRlICogZGVsdGEsIDAsIDI1NSk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmEgPSBjbGFtcCh0aGlzLm9wYWNpdHksIDAuMDAwMSwgMSk7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcclxuICAgICAgICAgICAgY29uc3QgYWNjZWwgPSB0aGlzLmZvY3VzXHJcbiAgICAgICAgICAgICAgICAuc3ViKHRoaXMucG9zaXRpb24pXHJcbiAgICAgICAgICAgICAgICAubm9ybWFsaXplKClcclxuICAgICAgICAgICAgICAgIC5zY2FsZSh0aGlzLmZvY3VzQWNjZWwpXHJcbiAgICAgICAgICAgICAgICAuc2NhbGUoZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHkuYWRkKGFjY2VsKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMudmVsb2NpdHkgPSB0aGlzLnZlbG9jaXR5LmFkZCh0aGlzLmFjY2VsZXJhdGlvbi5zY2FsZShkZWx0YSAvIDEwMDApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24uYWRkKHRoaXMudmVsb2NpdHkuc2NhbGUoZGVsdGEgLyAxMDAwKSk7XHJcbiAgICAgICAgaWYgKHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50Um90YXRpb24gPSAodGhpcy5jdXJyZW50Um90YXRpb24gKyAodGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSAqIGRlbHRhKSAvIDEwMDApICUgKDIgKiBNYXRoLlBJKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9zID0gdGhpcy5wb3NpdGlvbjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHRoaXMuY3VycmVudFJvdGF0aW9uO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnNjYWxlID0gdmVjKDEsIDEpOyAvLyB0b2RvIHd1dFxyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3Mub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuICAgIH1cclxuICAgIGRyYXcoY3R4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucGFydGljbGVTcHJpdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5vcGFjaXR5KHRoaXMub3BhY2l0eSk7XHJcbiAgICAgICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUuZHJhdyhjdHgsIDAsIDApO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yLmEgPSBjbGFtcCh0aGlzLm9wYWNpdHksIDAuMDAwMSwgMSk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuX2N1cnJlbnRDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguYXJjKDAsIDAsIHRoaXMucGFydGljbGVTaXplLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUGFydGljbGUgaXMgdXNlZCBpbiBhIFtbUGFydGljbGVFbWl0dGVyXV1cclxuICovXHJcbmNsYXNzIFBhcnRpY2xlIGV4dGVuZHMgQ29uZmlndXJhYmxlKFBhcnRpY2xlSW1wbCkge1xyXG4gICAgY29uc3RydWN0b3IoZW1pdHRlck9yQ29uZmlnLCBsaWZlLCBvcGFjaXR5LCBiZWdpbkNvbG9yLCBlbmRDb2xvciwgcG9zaXRpb24sIHZlbG9jaXR5LCBhY2NlbGVyYXRpb24sIHN0YXJ0U2l6ZSwgZW5kU2l6ZSkge1xyXG4gICAgICAgIHN1cGVyKGVtaXR0ZXJPckNvbmZpZywgbGlmZSwgb3BhY2l0eSwgYmVnaW5Db2xvciwgZW5kQ29sb3IsIHBvc2l0aW9uLCB2ZWxvY2l0eSwgYWNjZWxlcmF0aW9uLCBzdGFydFNpemUsIGVuZFNpemUpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVc2luZyBhIHBhcnRpY2xlIGVtaXR0ZXIgaXMgYSBncmVhdCB3YXkgdG8gY3JlYXRlIGludGVyZXN0aW5nIGVmZmVjdHNcclxuICogaW4geW91ciBnYW1lLCBsaWtlIHNtb2tlLCBmaXJlLCB3YXRlciwgZXhwbG9zaW9ucywgZXRjLiBgUGFydGljbGVFbWl0dGVyYFxyXG4gKiBleHRlbmQgW1tBY3Rvcl1dIGFsbG93aW5nIHlvdSB0byB1c2UgYWxsIG9mIHRoZSBmZWF0dXJlcyB0aGF0IGNvbWUgd2l0aC5cclxuICovXHJcbmNsYXNzIFBhcnRpY2xlRW1pdHRlciBleHRlbmRzIEFjdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZyBwYXJ0aWNsZSBlbWl0dGVyIG9wdGlvbnMgYmFnXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgc3VwZXIoeyB3aWR0aDogKF9hID0gY29uZmlnLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLCBoZWlnaHQ6IChfYiA9IGNvbmZpZy5oZWlnaHQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDAgfSk7XHJcbiAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ID0gMDtcclxuICAgICAgICB0aGlzLm51bVBhcnRpY2xlcyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBpc0VtaXR0aW5nIGZsYWdcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmlzRW1pdHRpbmcgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFja2luZyBwYXJ0aWNsZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJhY2tpbmcgZGVhZFBhcnRpY2xlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gcGFydGljbGUgdmVsb2NpdHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1pblZlbCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHBhcnRpY2xlIHZlbG9jaXR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXhWZWwgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYWNjZWxlcmF0aW9uIHZlY3RvciBmb3IgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gYW5nbGUgaW4gcmFkaWFuc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWluQW5nbGUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWF4aW11bSBhbmdsZSBpbiByYWRpYW5zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXhBbmdsZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbWlzc2lvbiByYXRlIGZvciBwYXJ0aWNsZXMgKHBhcnRpY2xlcy9zZWMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbWl0UmF0ZSA9IDE7IC8vcGFydGljbGVzL3NlY1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGlmZSBvZiBlYWNoIHBhcnRpY2xlIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFydGljbGVMaWZlID0gMjAwMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGZhZGUgZmxhZyB3aGljaCBjYXVzZXMgcGFydGljbGVzIHRvIGdyYWR1YWxseSBmYWRlIG91dCBvdmVyIHRoZSBjb3Vyc2Ugb2YgdGhlaXIgbGlmZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZhZGVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25hbCBmb2N1cyB3aGVyZSBhbGwgcGFydGljbGVzIHNob3VsZCBhY2NlbGVyYXRlIHRvd2FyZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZvY3VzID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGFjY2VsZXJhdGlvbiBmb3IgZm9jdXNpbmcgcGFydGljbGVzIGlmIGEgZm9jdXMgaGFzIGJlZW4gc3BlY2lmaWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mb2N1c0FjY2VsID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIHN0YXJ0aW5nIHNpemUgZm9yIHRoZSBwYXJ0aWNsZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN0YXJ0U2l6ZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBvcHRpb25hbCBlbmRpbmcgc2l6ZSBmb3IgdGhlIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZW5kU2l6ZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtaW5pbXVtIHNpemUgb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWluU2l6ZSA9IDU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIHNpemUgb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWF4U2l6ZSA9IDU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiZWdpbm5pbmcgY29sb3Igb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYmVnaW5Db2xvciA9IENvbG9yLldoaXRlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW5kaW5nIGNvbG9yIG9mIGFsbCBwYXJ0aWNsZXNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuZENvbG9yID0gQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgdGhpcy5fb2cgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZSA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbWl0dGVyIHR5cGUgZm9yIHRoZSBwYXJ0aWNsZSBlbWl0dGVyXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbWl0dGVyVHlwZSA9IEVtaXR0ZXJUeXBlLlJlY3RhbmdsZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXR0ZXIgcmFkaXVzLCBvbmx5IHRha2VzIGVmZmVjdCB3aGVuIHRoZSBbW2VtaXR0ZXJUeXBlXV0gaXMgW1tFbWl0dGVyVHlwZS5DaXJjbGVdXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHBhcnRpY2xlIHJvdGF0aW9uYWwgc3BlZWQgdmVsb2NpdHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBwYXJ0aWNsZXMgc2hvdWxkIHN0YXJ0IHdpdGggYSByYW5kb20gcm90YXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJhbmRvbVJvdGF0aW9uID0gZmFsc2U7XHJcbiAgICAgICAgY29uc3QgeyB4LCB5LCBwb3MsIGlzRW1pdHRpbmcsIG1pblZlbCwgbWF4VmVsLCBhY2NlbGVyYXRpb24sIG1pbkFuZ2xlLCBtYXhBbmdsZSwgZW1pdFJhdGUsIHBhcnRpY2xlTGlmZSwgb3BhY2l0eSwgZmFkZUZsYWcsIGZvY3VzLCBmb2N1c0FjY2VsLCBzdGFydFNpemUsIGVuZFNpemUsIG1pblNpemUsIG1heFNpemUsIGJlZ2luQ29sb3IsIGVuZENvbG9yLCBwYXJ0aWNsZVNwcml0ZSwgZW1pdHRlclR5cGUsIHJhZGl1cywgcGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHksIHJhbmRvbVJvdGF0aW9uLCByYW5kb20gfSA9IE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5wb3MgPSBwb3MgIT09IG51bGwgJiYgcG9zICE9PSB2b2lkIDAgPyBwb3MgOiB2ZWMoeCAhPT0gbnVsbCAmJiB4ICE9PSB2b2lkIDAgPyB4IDogMCwgeSAhPT0gbnVsbCAmJiB5ICE9PSB2b2lkIDAgPyB5IDogMCk7XHJcbiAgICAgICAgdGhpcy5pc0VtaXR0aW5nID0gaXNFbWl0dGluZyAhPT0gbnVsbCAmJiBpc0VtaXR0aW5nICE9PSB2b2lkIDAgPyBpc0VtaXR0aW5nIDogdGhpcy5pc0VtaXR0aW5nO1xyXG4gICAgICAgIHRoaXMubWluVmVsID0gbWluVmVsICE9PSBudWxsICYmIG1pblZlbCAhPT0gdm9pZCAwID8gbWluVmVsIDogdGhpcy5taW5WZWw7XHJcbiAgICAgICAgdGhpcy5tYXhWZWwgPSBtYXhWZWwgIT09IG51bGwgJiYgbWF4VmVsICE9PSB2b2lkIDAgPyBtYXhWZWwgOiB0aGlzLm1heFZlbDtcclxuICAgICAgICB0aGlzLmFjY2VsZXJhdGlvbiA9IGFjY2VsZXJhdGlvbiAhPT0gbnVsbCAmJiBhY2NlbGVyYXRpb24gIT09IHZvaWQgMCA/IGFjY2VsZXJhdGlvbiA6IHRoaXMuYWNjZWxlcmF0aW9uO1xyXG4gICAgICAgIHRoaXMubWluQW5nbGUgPSBtaW5BbmdsZSAhPT0gbnVsbCAmJiBtaW5BbmdsZSAhPT0gdm9pZCAwID8gbWluQW5nbGUgOiB0aGlzLm1pbkFuZ2xlO1xyXG4gICAgICAgIHRoaXMubWF4QW5nbGUgPSBtYXhBbmdsZSAhPT0gbnVsbCAmJiBtYXhBbmdsZSAhPT0gdm9pZCAwID8gbWF4QW5nbGUgOiB0aGlzLm1heEFuZ2xlO1xyXG4gICAgICAgIHRoaXMuZW1pdFJhdGUgPSBlbWl0UmF0ZSAhPT0gbnVsbCAmJiBlbWl0UmF0ZSAhPT0gdm9pZCAwID8gZW1pdFJhdGUgOiB0aGlzLmVtaXRSYXRlO1xyXG4gICAgICAgIHRoaXMucGFydGljbGVMaWZlID0gcGFydGljbGVMaWZlICE9PSBudWxsICYmIHBhcnRpY2xlTGlmZSAhPT0gdm9pZCAwID8gcGFydGljbGVMaWZlIDogdGhpcy5wYXJ0aWNsZUxpZmU7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eSAhPT0gbnVsbCAmJiBvcGFjaXR5ICE9PSB2b2lkIDAgPyBvcGFjaXR5IDogdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgIHRoaXMuZmFkZUZsYWcgPSBmYWRlRmxhZyAhPT0gbnVsbCAmJiBmYWRlRmxhZyAhPT0gdm9pZCAwID8gZmFkZUZsYWcgOiB0aGlzLmZhZGVGbGFnO1xyXG4gICAgICAgIHRoaXMuZm9jdXMgPSBmb2N1cyAhPT0gbnVsbCAmJiBmb2N1cyAhPT0gdm9pZCAwID8gZm9jdXMgOiB0aGlzLmZvY3VzO1xyXG4gICAgICAgIHRoaXMuZm9jdXNBY2NlbCA9IGZvY3VzQWNjZWwgIT09IG51bGwgJiYgZm9jdXNBY2NlbCAhPT0gdm9pZCAwID8gZm9jdXNBY2NlbCA6IHRoaXMuZm9jdXNBY2NlbDtcclxuICAgICAgICB0aGlzLnN0YXJ0U2l6ZSA9IHN0YXJ0U2l6ZSAhPT0gbnVsbCAmJiBzdGFydFNpemUgIT09IHZvaWQgMCA/IHN0YXJ0U2l6ZSA6IHRoaXMuc3RhcnRTaXplO1xyXG4gICAgICAgIHRoaXMuZW5kU2l6ZSA9IGVuZFNpemUgIT09IG51bGwgJiYgZW5kU2l6ZSAhPT0gdm9pZCAwID8gZW5kU2l6ZSA6IHRoaXMuZW5kU2l6ZTtcclxuICAgICAgICB0aGlzLm1pblNpemUgPSBtaW5TaXplICE9PSBudWxsICYmIG1pblNpemUgIT09IHZvaWQgMCA/IG1pblNpemUgOiB0aGlzLm1pblNpemU7XHJcbiAgICAgICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZSAhPT0gbnVsbCAmJiBtYXhTaXplICE9PSB2b2lkIDAgPyBtYXhTaXplIDogdGhpcy5tYXhTaXplO1xyXG4gICAgICAgIHRoaXMuYmVnaW5Db2xvciA9IGJlZ2luQ29sb3IgIT09IG51bGwgJiYgYmVnaW5Db2xvciAhPT0gdm9pZCAwID8gYmVnaW5Db2xvciA6IHRoaXMuYmVnaW5Db2xvcjtcclxuICAgICAgICB0aGlzLmVuZENvbG9yID0gZW5kQ29sb3IgIT09IG51bGwgJiYgZW5kQ29sb3IgIT09IHZvaWQgMCA/IGVuZENvbG9yIDogdGhpcy5lbmRDb2xvcjtcclxuICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlID0gcGFydGljbGVTcHJpdGUgIT09IG51bGwgJiYgcGFydGljbGVTcHJpdGUgIT09IHZvaWQgMCA/IHBhcnRpY2xlU3ByaXRlIDogdGhpcy5wYXJ0aWNsZVNwcml0ZTtcclxuICAgICAgICB0aGlzLmVtaXR0ZXJUeXBlID0gZW1pdHRlclR5cGUgIT09IG51bGwgJiYgZW1pdHRlclR5cGUgIT09IHZvaWQgMCA/IGVtaXR0ZXJUeXBlIDogdGhpcy5lbWl0dGVyVHlwZTtcclxuICAgICAgICB0aGlzLnJhZGl1cyA9IHJhZGl1cyAhPT0gbnVsbCAmJiByYWRpdXMgIT09IHZvaWQgMCA/IHJhZGl1cyA6IHRoaXMucmFkaXVzO1xyXG4gICAgICAgIHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSBwYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSAhPT0gbnVsbCAmJiBwYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSAhPT0gdm9pZCAwID8gcGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgOiB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5O1xyXG4gICAgICAgIHRoaXMucmFuZG9tUm90YXRpb24gPSByYW5kb21Sb3RhdGlvbiAhPT0gbnVsbCAmJiByYW5kb21Sb3RhdGlvbiAhPT0gdm9pZCAwID8gcmFuZG9tUm90YXRpb24gOiB0aGlzLnJhbmRvbVJvdGF0aW9uO1xyXG4gICAgICAgIHRoaXMuYm9keS5jb2xsaXNpb25UeXBlID0gQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG4gICAgICAgIHRoaXMucmFuZG9tID0gcmFuZG9tICE9PSBudWxsICYmIHJhbmRvbSAhPT0gdm9pZCAwID8gcmFuZG9tIDogbmV3IFJhbmRvbSgpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBvZmZzY3JlZW4gY3VsbGluZyBmcm9tIHBhcnRpY2xlIGVtaXR0ZXJzXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyYWl0cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy50cmFpdHNbaV0gaW5zdGFuY2VvZiBPZmZzY3JlZW5DdWxsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWl0cy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG9wYWNpdHkgb2YgZWFjaCBwYXJ0aWNsZSBmcm9tIDAgdG8gMS4wXHJcbiAgICAgKi9cclxuICAgIGdldCBvcGFjaXR5KCkge1xyXG4gICAgICAgIHJldHVybiBzdXBlci5ncmFwaGljcy5vcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBvcGFjaXR5IG9mIGVhY2ggcGFydGljbGUgZnJvbSAwIHRvIDEuMFxyXG4gICAgICovXHJcbiAgICBzZXQgb3BhY2l0eShvcGFjaXR5KSB7XHJcbiAgICAgICAgc3VwZXIuZ3JhcGhpY3Mub3BhY2l0eSA9IG9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc3ByaXRlIHRoYXQgYSBwYXJ0aWNsZSBzaG91bGQgdXNlXHJcbiAgICAgKi9cclxuICAgIGdldCBwYXJ0aWNsZVNwcml0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb2c7XHJcbiAgICB9XHJcbiAgICBzZXQgcGFydGljbGVTcHJpdGUodmFsKSB7XHJcbiAgICAgICAgdGhpcy5fb2cgPSB2YWw7XHJcbiAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGUgPSBTcHJpdGUuZnJvbUxlZ2FjeVNwcml0ZSh2YWwpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZVBhcnRpY2xlKHBhcnRpY2xlKSB7XHJcbiAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLnB1c2gocGFydGljbGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYXVzZXMgdGhlIGVtaXR0ZXIgdG8gZW1pdCBwYXJ0aWNsZXNcclxuICAgICAqIEBwYXJhbSBwYXJ0aWNsZUNvdW50ICBOdW1iZXIgb2YgcGFydGljbGVzIHRvIGVtaXQgcmlnaHQgbm93XHJcbiAgICAgKi9cclxuICAgIGVtaXRQYXJ0aWNsZXMocGFydGljbGVDb3VudCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2xlQ291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5fY3JlYXRlUGFydGljbGUoKTtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZXMucHVzaChwKTtcclxuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5zY2VuZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndvcmxkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLndvcmxkLmFkZChwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFyUGFydGljbGVzKCkge1xyXG4gICAgICAgIHRoaXMucGFydGljbGVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGVzIGEgbmV3IHBhcnRpY2xlIGdpdmVuIHRoZSBjb25zdHJhaW50cyBvZiB0aGUgZW1pdHRlclxyXG4gICAgX2NyZWF0ZVBhcnRpY2xlKCkge1xyXG4gICAgICAgIC8vIHRvZG8gaW1wbGVtZW50IGVtaXR0ZXIgY29uc3RyYWludHM7XHJcbiAgICAgICAgbGV0IHJhblggPSAwO1xyXG4gICAgICAgIGxldCByYW5ZID0gMDtcclxuICAgICAgICBjb25zdCBhbmdsZSA9IHJhbmRvbUluUmFuZ2UodGhpcy5taW5BbmdsZSwgdGhpcy5tYXhBbmdsZSwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgIGNvbnN0IHZlbCA9IHJhbmRvbUluUmFuZ2UodGhpcy5taW5WZWwsIHRoaXMubWF4VmVsLCB0aGlzLnJhbmRvbSk7XHJcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuc3RhcnRTaXplIHx8IHJhbmRvbUluUmFuZ2UodGhpcy5taW5TaXplLCB0aGlzLm1heFNpemUsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICBjb25zdCBkeCA9IHZlbCAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICBjb25zdCBkeSA9IHZlbCAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICBpZiAodGhpcy5lbWl0dGVyVHlwZSA9PT0gRW1pdHRlclR5cGUuUmVjdGFuZ2xlKSB7XHJcbiAgICAgICAgICAgIHJhblggPSByYW5kb21JblJhbmdlKDAsIHRoaXMud2lkdGgsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICAgICAgcmFuWSA9IHJhbmRvbUluUmFuZ2UoMCwgdGhpcy5oZWlnaHQsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5lbWl0dGVyVHlwZSA9PT0gRW1pdHRlclR5cGUuQ2lyY2xlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhZGl1cyA9IHJhbmRvbUluUmFuZ2UoMCwgdGhpcy5yYWRpdXMsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICAgICAgcmFuWCA9IHJhZGl1cyAqIE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICAgICAgcmFuWSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcCA9IG5ldyBQYXJ0aWNsZSh0aGlzLCB0aGlzLnBhcnRpY2xlTGlmZSwgdGhpcy5vcGFjaXR5LCB0aGlzLmJlZ2luQ29sb3IsIHRoaXMuZW5kQ29sb3IsIG5ldyBWZWN0b3IocmFuWCwgcmFuWSksIG5ldyBWZWN0b3IoZHgsIGR5KSwgdGhpcy5hY2NlbGVyYXRpb24sIHRoaXMuc3RhcnRTaXplLCB0aGlzLmVuZFNpemUpO1xyXG4gICAgICAgIHAuZmFkZUZsYWcgPSB0aGlzLmZhZGVGbGFnO1xyXG4gICAgICAgIHAucGFydGljbGVTaXplID0gc2l6ZTtcclxuICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVNwcml0ZSkge1xyXG4gICAgICAgICAgICBwLnBhcnRpY2xlU3ByaXRlID0gdGhpcy5wYXJ0aWNsZVNwcml0ZTtcclxuICAgICAgICAgICAgcC5ncmFwaGljcy5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICBwLmdyYXBoaWNzLnVzZSh0aGlzLl9zcHJpdGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ID0gdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eTtcclxuICAgICAgICBpZiAodGhpcy5yYW5kb21Sb3RhdGlvbikge1xyXG4gICAgICAgICAgICBwLmN1cnJlbnRSb3RhdGlvbiA9IHJhbmRvbUluUmFuZ2UoMCwgTWF0aC5QSSAqIDIsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcclxuICAgICAgICAgICAgcC5mb2N1cyA9IHRoaXMuZm9jdXMuYWRkKG5ldyBWZWN0b3IodGhpcy5wb3MueCwgdGhpcy5wb3MueSkpO1xyXG4gICAgICAgICAgICBwLmZvY3VzQWNjZWwgPSB0aGlzLmZvY3VzQWNjZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgc3VwZXIudXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzRW1pdHRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGFydGljbGVzVG9FbWl0ICs9IHRoaXMuZW1pdFJhdGUgKiAoZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3BhcnRpY2xlc1RvRW1pdCA+IDEuMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0UGFydGljbGVzKE1hdGguZmxvb3IodGhpcy5fcGFydGljbGVzVG9FbWl0KSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPSB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgLSBNYXRoLmZsb29yKHRoaXMuX3BhcnRpY2xlc1RvRW1pdCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZGVmZXJyZWQgcmVtb3ZhbFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kZWFkUGFydGljbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUl0ZW1Gcm9tQXJyYXkodGhpcy5kZWFkUGFydGljbGVzW2ldLCB0aGlzLnBhcnRpY2xlcyk7XHJcbiAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzID09PSBudWxsIHx8IHRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMuc2NlbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53b3JsZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zY2VuZS53b3JsZC5yZW1vdmUodGhpcy5kZWFkUGFydGljbGVzW2ldLCBmYWxzZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kZWFkUGFydGljbGVzLmxlbmd0aCA9IDA7XHJcbiAgICB9XHJcbiAgICBkcmF3KGN0eCkge1xyXG4gICAgICAgIC8vIHRvZG8gaXMgdGhlcmUgYSBtb3JlIGVmZmljaWVudCB0byBkcmF3XHJcbiAgICAgICAgLy8gcG9zc2libHkgdXNlIGEgd2ViZ2wgb2Zmc2NyZWVuIGNhbnZhcyBhbmQgc2hhZGVycyB0byBkbyBwYXJ0aWNsZXM/XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMuZm9yRWFjaCgocCkgPT4gcC5kcmF3KGN0eCkpO1xyXG4gICAgfVxyXG4gICAgZGVidWdEcmF3KGN0eCkge1xyXG4gICAgICAgIHN1cGVyLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvci5CbGFjay50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5maWxsVGV4dCgnUGFydGljbGVzOiAnICsgdGhpcy5wYXJ0aWNsZXMubGVuZ3RoLCB0aGlzLnBvcy54LCB0aGlzLnBvcy55ICsgMjApO1xyXG4gICAgICAgIGlmICh0aGlzLmZvY3VzKSB7XHJcbiAgICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLmZvY3VzLnggKyB0aGlzLnBvcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnBvcy55LCAzLCAzKTtcclxuICAgICAgICAgICAgbGluZShjdHgsIENvbG9yLlllbGxvdywgdGhpcy5mb2N1cy54ICsgdGhpcy5wb3MueCwgdGhpcy5mb2N1cy55ICsgdGhpcy5wb3MueSwgdGhpcy5jZW50ZXIueCwgdGhpcy5jZW50ZXIueSk7XHJcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dCgnRm9jdXMnLCB0aGlzLmZvY3VzLnggKyB0aGlzLnBvcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnBvcy55KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9HcmFwaGljc1N5c3RlbS50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBHcmFwaGljc1N5c3RlbSBleHRlbmRzIFN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZXMgPSBbJ2V4LnRyYW5zZm9ybScsICdleC5ncmFwaGljcyddO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtVHlwZSA9IFN5c3RlbVR5cGUuRHJhdztcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gMDtcclxuICAgICAgICB0aGlzLl90b2tlbiA9IDA7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKHNjZW5lKSB7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0ID0gc2NlbmUuZW5naW5lLmdyYXBoaWNzQ29udGV4dDtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBzY2VuZS5jYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lID0gc2NlbmUuZW5naW5lO1xyXG4gICAgfVxyXG4gICAgc29ydChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkueiAtIGIuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkuejtcclxuICAgIH1cclxuICAgIHVwZGF0ZShlbnRpdGllcywgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLl9jbGVhclNjcmVlbigpO1xyXG4gICAgICAgIHRoaXMuX3Rva2VuKys7XHJcbiAgICAgICAgbGV0IHRyYW5zZm9ybTtcclxuICAgICAgICBsZXQgZ3JhcGhpY3M7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdHJhbnNmb3JtID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgICAgICBncmFwaGljcyA9IGVudGl0eS5nZXQoR3JhcGhpY3NDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAvLyBGaWd1cmUgb3V0IGlmIGVudGl0aWVzIGFyZSBvZmZzY3JlZW5cclxuICAgICAgICAgICAgY29uc3QgZW50aXR5T2Zmc2NyZWVuID0gdGhpcy5faXNPZmZzY3JlZW4odHJhbnNmb3JtLCBncmFwaGljcyk7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHlPZmZzY3JlZW4gJiYgIWVudGl0eS5oYXNUYWcoJ29mZnNjcmVlbicpKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2V4aXR2aWV3cG9ydCcsIG5ldyBFeGl0Vmlld1BvcnRFdmVudChlbnRpdHkpKTtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5hZGRDb21wb25lbnQobmV3IFRhZ0NvbXBvbmVudCgnb2Zmc2NyZWVuJykpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZW50aXR5T2Zmc2NyZWVuICYmIGVudGl0eS5oYXNUYWcoJ29mZnNjcmVlbicpKSB7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2VudGVydmlld3BvcnQnLCBuZXcgRW50ZXJWaWV3UG9ydEV2ZW50KGVudGl0eSkpO1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LnJlbW92ZUNvbXBvbmVudCgnb2Zmc2NyZWVuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2tpcCBlbnRpdGllcyB0aGF0IGhhdmUgZ3JhcGhpY3Mgb2Zmc2NyZWVuXHJcbiAgICAgICAgICAgIGlmIChlbnRpdHlPZmZzY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRoaXMgb3B0aW9uYWxseSBzZXRzIG91ciBjYW1lcmEgYmFzZWQgb24gdGhlIGVudGl0eSBjb29yZCBwbGFuICh3b3JsZCB2cy4gc2NyZWVuKVxyXG4gICAgICAgICAgICB0aGlzLl9wdXNoQ2FtZXJhVHJhbnNmb3JtKHRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIC8vIFRpY2sgYW55IGdyYXBoaWNzIHN0YXRlIChidXQgb25seSBvbmNlKSBmb3IgYW5pbWF0aW9ucyBhbmQgZ3JhcGhpY3MgZ3JvdXBzXHJcbiAgICAgICAgICAgIGdyYXBoaWNzLnVwZGF0ZShkZWx0YSwgdGhpcy5fdG9rZW4pO1xyXG4gICAgICAgICAgICAvLyBQb3NpdGlvbiB0aGUgZW50aXR5XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5VHJhbnNmb3JtKGVudGl0eSk7XHJcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsbHkgcnVuIHRoZSBvblByZURyYXcgZ3JhcGhpY3MgbGlmZWN5Y2xlIGRyYXdcclxuICAgICAgICAgICAgaWYgKGdyYXBoaWNzLm9uUHJlRHJhdykge1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpY3Mub25QcmVEcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgaGFjayBvbiB0aGUgcGFydGljbGUgcmVkb1xyXG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNsZU9wYWNpdHkgPSAoZW50aXR5IGluc3RhbmNlb2YgUGFydGljbGUpID8gZW50aXR5Lm9wYWNpdHkgOiAxO1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQub3BhY2l0eSA9IGdyYXBoaWNzLm9wYWNpdHkgKiBwYXJ0aWNsZU9wYWNpdHk7XHJcbiAgICAgICAgICAgIC8vIERyYXcgdGhlIGdyYXBoaWNzIGNvbXBvbmVudFxyXG4gICAgICAgICAgICB0aGlzLl9kcmF3R3JhcGhpY3NDb21wb25lbnQoZ3JhcGhpY3MpO1xyXG4gICAgICAgICAgICAvLyBPcHRpb25hbGx5IHJ1biB0aGUgb25Qb3N0RHJhdyBncmFwaGljcyBsaWZlY3ljbGUgZHJhd1xyXG4gICAgICAgICAgICBpZiAoZ3JhcGhpY3Mub25Qb3N0RHJhdykge1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpY3Mub25Qb3N0RHJhdyh0aGlzLl9ncmFwaGljc0NvbnRleHQsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAvLyBSZXNldCB0aGUgdHJhbnNmb3JtIGJhY2sgdG8gdGhlIG9yaWdpbmFsXHJcbiAgICAgICAgICAgIHRoaXMuX3BvcENhbWVyYVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZmx1c2goKTtcclxuICAgICAgICB0aGlzLl9lbmdpbmUuc3RhdHMuY3VyckZyYW1lLmdyYXBoaWNzLmRyYXduSW1hZ2VzID0gR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3bkltYWdlc0NvdW50O1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZS5zdGF0cy5jdXJyRnJhbWUuZ3JhcGhpY3MuZHJhd0NhbGxzID0gR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3Q2FsbENvdW50O1xyXG4gICAgfVxyXG4gICAgX2NsZWFyU2NyZWVuKCkge1xyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgX2lzT2Zmc2NyZWVuKHRyYW5zZm9ybSwgZ3JhcGhpY3MpIHtcclxuICAgICAgICBpZiAodHJhbnNmb3JtLmNvb3JkUGxhbmUgPT09IENvb3JkUGxhbmUuV29ybGQpIHtcclxuICAgICAgICAgICAgY29uc3QgZ3JhcGhpY3NPZmZzY3JlZW4gPSAhdGhpcy5fY2FtZXJhLnZpZXdwb3J0LmludGVyc2VjdChncmFwaGljcy5sb2NhbEJvdW5kcy50cmFuc2Zvcm0odHJhbnNmb3JtLmdldEdsb2JhbE1hdHJpeCgpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBncmFwaGljc09mZnNjcmVlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gc2NlZW4gY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kcmF3R3JhcGhpY3NDb21wb25lbnQoZ3JhcGhpY3NDb21wb25lbnQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmIChncmFwaGljc0NvbXBvbmVudC52aXNpYmxlKSB7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIG1vdmVkIHRvIHRoZSBncmFwaGljcyBzeXN0ZW1cclxuICAgICAgICAgICAgZm9yIChjb25zdCBsYXllciBvZiBncmFwaGljc0NvbXBvbmVudC5sYXllcnMuZ2V0KCkpIHtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgeyBncmFwaGljLCBvcHRpb25zIH0gb2YgbGF5ZXIuZ3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgICAgICBsZXQgYW5jaG9yID0gZ3JhcGhpY3NDb21wb25lbnQuYW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBvZmZzZXQgPSBncmFwaGljc0NvbXBvbmVudC5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmNob3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYW5jaG9yID0gb3B0aW9ucy5hbmNob3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9wdWxsLzYxOSBmb3IgZGlzY3Vzc2lvbiBvbiB0aGlzIGZvcm11bGFcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRYID0gLWdyYXBoaWMud2lkdGggKiBhbmNob3IueCArIG9mZnNldC54O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSAtZ3JhcGhpYy5oZWlnaHQgKiBhbmNob3IueSArIG9mZnNldC55O1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoaWMgPT09IG51bGwgfHwgZ3JhcGhpYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JhcGhpYy5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCwgb2Zmc2V0WCArIGxheWVyLm9mZnNldC54LCBvZmZzZXRZICsgbGF5ZXIub2Zmc2V0LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5fZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEZWJ1ZykgJiYgdGhpcy5fZW5naW5lLmRlYnVnLmdyYXBoaWNzLnNob3dCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdmVjKG9mZnNldFggKyBsYXllci5vZmZzZXQueCwgb2Zmc2V0WSArIGxheWVyLm9mZnNldC55KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdyYXBoaWMgaW5zdGFuY2VvZiBHcmFwaGljc0dyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGcgb2YgZ3JhcGhpYy5tZW1iZXJzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gZy5ncmFwaGljKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubG9jYWxCb3VuZHMudHJhbnNsYXRlKG9mZnNldC5hZGQoZy5wb3MpKS5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCwgdGhpcy5fZW5naW5lLmRlYnVnLmdyYXBoaWNzLmJvdW5kc0NvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljID09PSBudWxsIHx8IGdyYXBoaWMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyYXBoaWMubG9jYWxCb3VuZHMudHJhbnNsYXRlKG9mZnNldCkuZHJhdyh0aGlzLl9ncmFwaGljc0NvbnRleHQsIHRoaXMuX2VuZ2luZS5kZWJ1Zy5ncmFwaGljcy5ib3VuZHNDb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgYXBwbGllcyB0aGUgY3VycmVudCBlbnRpdHkgdHJhbnNmb3JtIHRvIHRoZSBncmFwaGljcyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIF9hcHBseVRyYW5zZm9ybShlbnRpdHkpIHtcclxuICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBlbnRpdHkuZ2V0QW5jZXN0b3JzKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhbmNlc3RvciBvZiBhbmNlc3RvcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gYW5jZXN0b3IgPT09IG51bGwgfHwgYW5jZXN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuY2VzdG9yLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQudHJhbnNsYXRlKHRyYW5zZm9ybS5wb3MueCwgdHJhbnNmb3JtLnBvcy55KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5zY2FsZSh0cmFuc2Zvcm0uc2NhbGUueCwgdHJhbnNmb3JtLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnJvdGF0ZSh0cmFuc2Zvcm0ucm90YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBjdXJyZW50IGNhbWVyYSB0cmFuc2Zvcm0gaWYgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1cclxuICAgICAqL1xyXG4gICAgX3B1c2hDYW1lcmFUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XHJcbiAgICAgICAgLy8gRXN0YWJsaXNoIGNhbWVyYSBvZmZzZXQgcGVyIGVudGl0eVxyXG4gICAgICAgIGlmICh0cmFuc2Zvcm0uY29vcmRQbGFuZSA9PT0gQ29vcmRQbGFuZS5Xb3JsZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW1lcmEuZHJhdyh0aGlzLl9ncmFwaGljc0NvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgY2FtZXJhIHRyYW5zZm9ybSBpZiBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybVxyXG4gICAgICovXHJcbiAgICBfcG9wQ2FtZXJhVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xyXG4gICAgICAgIGlmICh0cmFuc2Zvcm0uY29vcmRQbGFuZSA9PT0gQ29vcmRQbGFuZS5Xb3JsZCkge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjYW1lcmEgd29ybGQgb2Zmc2V0XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRHJhd2luZy9DYW52YXNEcmF3aW5nU3lzdGVtLnRzXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIERyYXdzIGFueXRoaW5nIHdpdGggYSB0cmFuc2Zvcm0gYW5kIGEgXCJkcmF3XCIgbWV0aG9kXHJcbiAqIEBkZXByZWNhdGVkIFNoaW0gZm9yIGNhbnZhcyBkcmF3aW5nLCB3aWxsIGJlIHJlbW92ZWQgdjAuMjYuMFxyXG4gKi9cclxuY2xhc3MgQ2FudmFzRHJhd2luZ1N5c3RlbSBleHRlbmRzIFN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZXMgPSBbJ2V4LnRyYW5zZm9ybScsICdleC5jYW52YXMnXTtcclxuICAgICAgICB0aGlzLnN5c3RlbVR5cGUgPSBTeXN0ZW1UeXBlLkRyYXc7XHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IC0xO1xyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShzY2VuZSkge1xyXG4gICAgICAgIHRoaXMuX2N0eCA9IHNjZW5lLmVuZ2luZS5jdHg7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lID0gc2NlbmUuZW5naW5lO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IHNjZW5lLmNhbWVyYTtcclxuICAgIH1cclxuICAgIHNvcnQoYSwgYikge1xyXG4gICAgICAgIHJldHVybiBhLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLnogLSBiLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLno7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZW50aXRpZXMsIGRlbHRhKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJTY3JlZW4oKTtcclxuICAgICAgICBsZXQgdHJhbnNmb3JtO1xyXG4gICAgICAgIGxldCBjYW52YXNkcmF3O1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGVudGl0aWVzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGUgPSAoX2MgPSAoX2IgPSAoX2EgPSBlbnRpdGllc1tpXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdyYXBoaWNzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmlzaWJsZSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdHJ1ZTtcclxuICAgICAgICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gZW50aXRpZXNbaV0uaXNPZmZTY3JlZW47XHJcbiAgICAgICAgICAgIGlmICh2aXNpYmxlICYmICFvZmZzY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSA9IGVudGl0aWVzW2ldLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzZHJhdyA9IGVudGl0aWVzW2ldLmdldChDYW52YXNEcmF3Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdXNoQ2FtZXJhVHJhbnNmb3JtKHRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlUcmFuc2Zvcm0oZW50aXRpZXNbaV0pO1xyXG4gICAgICAgICAgICAgICAgY2FudmFzZHJhdy5kcmF3KHRoaXMuX2N0eCwgZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BvcENhbWVyYVRyYW5zZm9ybSh0cmFuc2Zvcm0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5fZW5naW5lLmlzRGVidWcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wdXNoQ2FtZXJhVHJhbnNmb3JtKHRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguc3Ryb2tlU3R5bGUgPSAneWVsbG93JztcclxuICAgICAgICAgICAgICAgIGVudGl0aWVzW2ldLmRlYnVnRHJhdyh0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wQ2FtZXJhVHJhbnNmb3JtKHRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9lbmdpbmUuaXNEZWJ1Zykge1xyXG4gICAgICAgICAgICB0aGlzLl9jdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW1lcmEuZHJhdyh0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW1lcmEuZGVidWdEcmF3KHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2N0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VuZ2luZS5zdGF0cy5jdXJyRnJhbWUuZ3JhcGhpY3MuZHJhd25JbWFnZXMgPSBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXduSW1hZ2VzQ291bnQ7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5ncmFwaGljcy5kcmF3Q2FsbHMgPSBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXdDYWxsQ291bnQ7XHJcbiAgICB9XHJcbiAgICBfYXBwbHlUcmFuc2Zvcm0oZW50aXR5KSB7XHJcbiAgICAgICAgY29uc3QgYW5jZXN0b3JzID0gZW50aXR5LmdldEFuY2VzdG9ycygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgYW5jZXN0b3Igb2YgYW5jZXN0b3JzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGFuY2VzdG9yID09PSBudWxsIHx8IGFuY2VzdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmNlc3Rvci5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LnRyYW5zbGF0ZSh0cmFuc2Zvcm0ucG9zLngsIHRyYW5zZm9ybS5wb3MueSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHgucm90YXRlKHRyYW5zZm9ybS5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHguc2NhbGUodHJhbnNmb3JtLnNjYWxlLngsIHRyYW5zZm9ybS5zY2FsZS55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9jbGVhclNjcmVlbigpIHtcclxuICAgICAgICB0aGlzLl9jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2N0eC5jYW52YXMud2lkdGgsIHRoaXMuX2N0eC5jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9jdHguZmlsbFN0eWxlID0gdGhpcy5fZW5naW5lLmJhY2tncm91bmRDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5maWxsUmVjdCgwLCAwLCB0aGlzLl9jdHguY2FudmFzLndpZHRoLCB0aGlzLl9jdHguY2FudmFzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICBfcHVzaENhbWVyYVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcclxuICAgICAgICBpZiAodHJhbnNmb3JtLmNvb3JkUGxhbmUgPT09IENvb3JkUGxhbmUuV29ybGQpIHtcclxuICAgICAgICAgICAgLy8gQXBwbHkgY2FtZXJhIHRyYW5zZm9ybSB0byBwbGFjZSBlbnRpdHkgaW4gd29ybGQgc3BhY2VcclxuICAgICAgICAgICAgdGhpcy5fY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbWVyYSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY2FtZXJhLmRyYXcodGhpcy5fY3R4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wb3BDYW1lcmFUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5jb29yZFBsYW5lID09PSBDb29yZFBsYW5lLldvcmxkKSB7XHJcbiAgICAgICAgICAgIC8vIFJlc3RvcmUgYmFjayB0byBzY3JlZW4gc3BhY2UgZnJvbSB3b3JsZCBzcGFjZSBpZiB3ZSB3ZXJlIGRyYXdpbmcgYW4gZW50aXR5IHRoZXJlXHJcbiAgICAgICAgICAgIHRoaXMuX2N0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRGVidWcvRGVidWdTeXN0ZW0udHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIERlYnVnU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlcyA9IFsnZXgudHJhbnNmb3JtJ107XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1UeXBlID0gU3lzdGVtVHlwZS5EcmF3O1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSA5OTk7IC8vIGxvd2VzdCBwcmlvcml0eVxyXG4gICAgfVxyXG4gICAgaW5pdGlhbGl6ZShzY2VuZSkge1xyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dCA9IHNjZW5lLmVuZ2luZS5ncmFwaGljc0NvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gc2NlbmUuY2FtZXJhO1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZSA9IHNjZW5lLmVuZ2luZTtcclxuICAgICAgICB0aGlzLl9jb2xsaXNpb25TeXN0ZW0gPSBzY2VuZS53b3JsZC5zeXN0ZW1NYW5hZ2VyLmdldChDb2xsaXNpb25TeXN0ZW0pO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGVudGl0aWVzLCBfZGVsdGEpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGlmICghdGhpcy5fZW5naW5lLmlzRGVidWcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBmaWx0ZXJTZXR0aW5ncyA9IHRoaXMuX2VuZ2luZS5kZWJ1Zy5maWx0ZXI7XHJcbiAgICAgICAgbGV0IGlkO1xyXG4gICAgICAgIGxldCBuYW1lO1xyXG4gICAgICAgIGNvbnN0IGVudGl0eVNldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLmVudGl0eTtcclxuICAgICAgICBsZXQgdHg7XHJcbiAgICAgICAgY29uc3QgdHhTZXR0aW5ncyA9IHRoaXMuX2VuZ2luZS5kZWJ1Zy50cmFuc2Zvcm07XHJcbiAgICAgICAgbGV0IG1vdGlvbjtcclxuICAgICAgICBjb25zdCBtb3Rpb25TZXR0aW5ncyA9IHRoaXMuX2VuZ2luZS5kZWJ1Zy5tb3Rpb247XHJcbiAgICAgICAgbGV0IGNvbGxpZGVyQ29tcDtcclxuICAgICAgICBjb25zdCBjb2xsaWRlclNldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLmNvbGxpZGVyO1xyXG4gICAgICAgIGNvbnN0IHBoeXNpY3NTZXR0aW5ncyA9IHRoaXMuX2VuZ2luZS5kZWJ1Zy5waHlzaWNzO1xyXG4gICAgICAgIGxldCBncmFwaGljcztcclxuICAgICAgICBjb25zdCBncmFwaGljc1NldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLmdyYXBoaWNzO1xyXG4gICAgICAgIGxldCBib2R5O1xyXG4gICAgICAgIGNvbnN0IGJvZHlTZXR0aW5ncyA9IHRoaXMuX2VuZ2luZS5kZWJ1Zy5ib2R5O1xyXG4gICAgICAgIGNvbnN0IGNhbWVyYVNldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLmNhbWVyYTtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5Lmhhc1RhZygnb2Zmc2NyZWVuJykpIHtcclxuICAgICAgICAgICAgICAgIC8vIHNraXAgb2Zmc2NyZWVuIGVudGl0aWVzXHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgUGFydGljbGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIFBhcnRpY2xlcyBjcnVzaCB0aGUgcmVuZGVyZXIgOihcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmaWx0ZXJTZXR0aW5ncy51c2VGaWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbElkcyA9IGZpbHRlclNldHRpbmdzLmlkcy5sZW5ndGggPT09IDA7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpZE1hdGNoID0gYWxsSWRzIHx8IGZpbHRlclNldHRpbmdzLmlkcy5pbmNsdWRlcyhlbnRpdHkuaWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpZE1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxOYW1lcyA9IGZpbHRlclNldHRpbmdzLm5hbWVRdWVyeSA9PT0gJyc7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lTWF0Y2ggPSBhbGxOYW1lcyB8fCBlbnRpdHkubmFtZS5pbmNsdWRlcyhmaWx0ZXJTZXR0aW5ncy5uYW1lUXVlcnkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFuYW1lTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBsZXQgY3Vyc29yID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSB2ZWMoMCwgMTYpO1xyXG4gICAgICAgICAgICBpZCA9IGVudGl0eS5pZDtcclxuICAgICAgICAgICAgbmFtZSA9IGVudGl0eS5uYW1lO1xyXG4gICAgICAgICAgICB0eCA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgLy8gVGhpcyBvcHRpb25hbGx5IHNldHMgb3VyIGNhbWVyYSBiYXNlZCBvbiB0aGUgZW50aXR5IGNvb3JkIHBsYW4gKHdvcmxkIHZzLiBzY3JlZW4pXHJcbiAgICAgICAgICAgIHRoaXMuX3B1c2hDYW1lcmFUcmFuc2Zvcm0odHgpO1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseVRyYW5zZm9ybShlbnRpdHkpO1xyXG4gICAgICAgICAgICBpZiAodHgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0eFNldHRpbmdzLnNob3dBbGwgfHwgdHhTZXR0aW5ncy5zaG93UG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1BvaW50KFZlY3Rvci5aZXJvLCB7IHNpemU6IDIsIGNvbG9yOiB0eFNldHRpbmdzLnBvc2l0aW9uQ29sb3IgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGBwb3Mke3R4LnBvcy50b1N0cmluZygyKX1gLCBjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5hZGQobGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50aXR5U2V0dGluZ3Muc2hvd0FsbCB8fCBlbnRpdHlTZXR0aW5ncy5zaG93SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYGlkKCR7aWR9KSAke3R4LnBhcmVudCA/ICdjaGlsZCBvZiBpZCgnICsgKChfYiA9IChfYSA9IHR4LnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWQpICsgJyknIDogJyd9YCwgY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IuYWRkKGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGVudGl0eVNldHRpbmdzLnNob3dBbGwgfHwgZW50aXR5U2V0dGluZ3Muc2hvd05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYG5hbWUoJHtuYW1lfSlgLCBjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5hZGQobGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodHhTZXR0aW5ncy5zaG93QWxsIHx8IHR4U2V0dGluZ3Muc2hvd1JvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRyYXdMaW5lKFZlY3Rvci5aZXJvLCBWZWN0b3IuZnJvbUFuZ2xlKHR4LnJvdGF0aW9uKS5zY2FsZSg1MCkuYWRkKFZlY3Rvci5aZXJvKSwgdHhTZXR0aW5ncy5yb3RhdGlvbkNvbG9yLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYHJvdCBkZWcoJHt0b0RlZ3JlZXModHgucm90YXRpb24pLnRvRml4ZWQoMil9KWAsIGN1cnNvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLmFkZChsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eFNldHRpbmdzLnNob3dBbGwgfHwgdHhTZXR0aW5ncy5zaG93U2NhbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZHJhd0xpbmUoVmVjdG9yLlplcm8sIHR4LnNjYWxlLmFkZChWZWN0b3IuWmVybyksIHR4U2V0dGluZ3Muc2NhbGVDb2xvciwgMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZ3JhcGhpY3MgPSBlbnRpdHkuZ2V0KEdyYXBoaWNzQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKGdyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZ3JhcGhpY3NTZXR0aW5ncy5zaG93QWxsIHx8IGdyYXBoaWNzU2V0dGluZ3Muc2hvd0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IGdyYXBoaWNzLmxvY2FsQm91bmRzO1xyXG4gICAgICAgICAgICAgICAgICAgIGJvdW5kcy5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCwgZ3JhcGhpY3NTZXR0aW5ncy5ib3VuZHNDb2xvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYm9keSA9IGVudGl0eS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChib2R5KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keVNldHRpbmdzLnNob3dBbGwgfHwgYm9keVNldHRpbmdzLnNob3dDb2xsaXNpb25Hcm91cCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgY29sbGlzaW9uIGdyb3VwKCR7Ym9keS5ncm91cC5uYW1lfSlgLCBjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5hZGQobGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keVNldHRpbmdzLnNob3dBbGwgfHwgYm9keVNldHRpbmdzLnNob3dDb2xsaXNpb25UeXBlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGBjb2xsaXNpb24gdHlwZSgke2JvZHkuY29sbGlzaW9uVHlwZX0pYCwgY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IuYWRkKGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlTZXR0aW5ncy5zaG93QWxsIHx8IGJvZHlTZXR0aW5ncy5zaG93TWFzcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgbWFzcygke2JvZHkubWFzc30pYCwgY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IuYWRkKGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlTZXR0aW5ncy5zaG93QWxsIHx8IGJvZHlTZXR0aW5ncy5zaG93TW90aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGBtb3Rpb24oJHtib2R5LnNsZWVwTW90aW9ufSlgLCBjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5hZGQobGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keVNldHRpbmdzLnNob3dBbGwgfHwgYm9keVNldHRpbmdzLnNob3dTbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgc2xlZXBpbmcoJHtib2R5LmNhblNsZWVwID8gYm9keS5zbGVlcGluZyA6ICdjYW50IHNsZWVwJ30pYCwgY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IuYWRkKGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIG1vdGlvbiA9IGVudGl0eS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKG1vdGlvbikge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1vdGlvblNldHRpbmdzLnNob3dBbGwgfHwgbW90aW9uU2V0dGluZ3Muc2hvd1ZlbG9jaXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGB2ZWwke21vdGlvbi52ZWwudG9TdHJpbmcoMil9YCwgY3Vyc29yLmFkZCh0eC5nbG9iYWxQb3MpKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZHJhd0xpbmUodHguZ2xvYmFsUG9zLCB0eC5nbG9iYWxQb3MuYWRkKG1vdGlvbi52ZWwpLCBtb3Rpb25TZXR0aW5ncy52ZWxvY2l0eUNvbG9yLCAyKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IuYWRkKGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKG1vdGlvblNldHRpbmdzLnNob3dBbGwgfHwgbW90aW9uU2V0dGluZ3Muc2hvd0FjY2VsZXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kcmF3TGluZSh0eC5nbG9iYWxQb3MsIHR4Lmdsb2JhbFBvcy5hZGQobW90aW9uLmFjYyksIG1vdGlvblNldHRpbmdzLmFjY2VsZXJhdGlvbkNvbG9yLCAyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDb2xsaWRlcnMgbGl2ZSBpbiB3b3JsZCBzcGFjZSBhbHJlYWR5IHNvIGFmdGVyIHRoZSByZXN0b3JlKClcclxuICAgICAgICAgICAgY29sbGlkZXJDb21wID0gZW50aXR5LmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChjb2xsaWRlckNvbXApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyID0gY29sbGlkZXJDb21wLmdldCgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKChjb2xsaWRlclNldHRpbmdzLnNob3dBbGwgfHwgY29sbGlkZXJTZXR0aW5ncy5zaG93R2VvbWV0cnkpICYmIGNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlkZXIuZGVidWcodGhpcy5fZ3JhcGhpY3NDb250ZXh0LCBjb2xsaWRlclNldHRpbmdzLmdlb21ldHJ5Q29sb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbGxpZGVyU2V0dGluZ3Muc2hvd0FsbCB8fCBjb2xsaWRlclNldHRpbmdzLnNob3dCb3VuZHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlkZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2xsaWRlcnMgPSBjb2xsaWRlci5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2xsaWRlciBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IGNvbGxpZGVyLmJvdW5kcztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHZlYyhib3VuZHMubGVmdCwgYm91bmRzLnRvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1JlY3QocG9zLngsIHBvcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQsIHsgY29sb3I6IGNvbGxpZGVyU2V0dGluZ3MuYm91bmRzQ29sb3IgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sbGlkZXJTZXR0aW5ncy5zaG93QWxsIHx8IGNvbGxpZGVyU2V0dGluZ3Muc2hvd093bmVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGBvd25lciBpZCgke2NvbGxpZGVyLm93bmVyLmlkfSlgLCBwb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpZGVyQ29tcC5ib3VuZHMuZHJhdyh0aGlzLl9ncmFwaGljc0NvbnRleHQsIGNvbGxpZGVyU2V0dGluZ3MuYm91bmRzQ29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb2xsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBib3VuZHMgPSBjb2xsaWRlckNvbXAuYm91bmRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSB2ZWMoYm91bmRzLmxlZnQsIGJvdW5kcy50b3ApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1JlY3QocG9zLngsIHBvcy55LCBib3VuZHMud2lkdGgsIGJvdW5kcy5oZWlnaHQsIHsgY29sb3I6IGNvbGxpZGVyU2V0dGluZ3MuYm91bmRzQ29sb3IgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaWRlclNldHRpbmdzLnNob3dBbGwgfHwgY29sbGlkZXJTZXR0aW5ncy5zaG93T3duZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgb3duZXIgaWQoJHtjb2xsaWRlckNvbXAub3duZXIuaWR9KWAsIHBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcG9wQ2FtZXJhVHJhbnNmb3JtKHR4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmEuZHJhdyh0aGlzLl9ncmFwaGljc0NvbnRleHQpO1xyXG4gICAgICAgIGlmIChwaHlzaWNzU2V0dGluZ3Muc2hvd0FsbCB8fCBwaHlzaWNzU2V0dGluZ3Muc2hvd0Jyb2FkcGhhc2VTcGFjZVBhcnRpdGlvbkRlYnVnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblN5c3RlbS5kZWJ1Zyh0aGlzLl9ncmFwaGljc0NvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocGh5c2ljc1NldHRpbmdzLnNob3dBbGwgfHwgcGh5c2ljc1NldHRpbmdzLnNob3dDb2xsaXNpb25Db250YWN0cyB8fCBwaHlzaWNzU2V0dGluZ3Muc2hvd0NvbGxpc2lvbk5vcm1hbHMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBbXywgY29udGFjdF0gb2YgdGhpcy5fZW5naW5lLmRlYnVnLnN0YXRzLmN1cnJGcmFtZS5waHlzaWNzLmNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocGh5c2ljc1NldHRpbmdzLnNob3dBbGwgfHwgcGh5c2ljc1NldHRpbmdzLnNob3dDb2xsaXNpb25Db250YWN0cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgY29udGFjdC5wb2ludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdQb2ludChwb2ludCwgeyBzaXplOiA1LCBjb2xvcjogcGh5c2ljc1NldHRpbmdzLmNvbGxpc2lvbkNvbnRhY3RDb2xvciB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocGh5c2ljc1NldHRpbmdzLnNob3dBbGwgfHwgcGh5c2ljc1NldHRpbmdzLnNob3dDb2xsaXNpb25Ob3JtYWxzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBjb250YWN0LnBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd0xpbmUocG9pbnQsIGNvbnRhY3Qubm9ybWFsLnNjYWxlKDMwKS5hZGQocG9pbnQpLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogcGh5c2ljc1NldHRpbmdzLmNvbGxpc2lvbk5vcm1hbENvbG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgIGlmIChjYW1lcmFTZXR0aW5ncykge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW1lcmEuZHJhdyh0aGlzLl9ncmFwaGljc0NvbnRleHQpO1xyXG4gICAgICAgICAgICBpZiAoY2FtZXJhU2V0dGluZ3Muc2hvd0FsbCB8fCBjYW1lcmFTZXR0aW5ncy5zaG93Rm9jdXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kcmF3Q2lyY2xlKHRoaXMuX2NhbWVyYS5wb3MsIDQsIGNhbWVyYVNldHRpbmdzLmZvY3VzQ29sb3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChjYW1lcmFTZXR0aW5ncy5zaG93QWxsIHx8IGNhbWVyYVNldHRpbmdzLnNob3dab29tKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYHpvb20oJHt0aGlzLl9jYW1lcmEuem9vbX0pYCwgdGhpcy5fY2FtZXJhLnBvcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmZsdXNoKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgYXBwbGllcyB0aGUgY3VycmVudCBlbnRpdHkgdHJhbnNmb3JtIHRvIHRoZSBncmFwaGljcyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIF9hcHBseVRyYW5zZm9ybShlbnRpdHkpIHtcclxuICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBlbnRpdHkuZ2V0QW5jZXN0b3JzKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhbmNlc3RvciBvZiBhbmNlc3RvcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gYW5jZXN0b3IgPT09IG51bGwgfHwgYW5jZXN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuY2VzdG9yLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQudHJhbnNsYXRlKHRyYW5zZm9ybS5wb3MueCwgdHJhbnNmb3JtLnBvcy55KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5zY2FsZSh0cmFuc2Zvcm0uc2NhbGUueCwgdHJhbnNmb3JtLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnJvdGF0ZSh0cmFuc2Zvcm0ucm90YXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBjdXJyZW50IGNhbWVyYSB0cmFuc2Zvcm0gaWYgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSB0cmFuc2Zvcm1cclxuICAgICAqL1xyXG4gICAgX3B1c2hDYW1lcmFUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XHJcbiAgICAgICAgLy8gRXN0YWJsaXNoIGNhbWVyYSBvZmZzZXQgcGVyIGVudGl0eVxyXG4gICAgICAgIGlmICh0cmFuc2Zvcm0uY29vcmRQbGFuZSA9PT0gQ29vcmRQbGFuZS5Xb3JsZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW1lcmEuZHJhdyh0aGlzLl9ncmFwaGljc0NvbnRleHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGN1cnJlbnQgY2FtZXJhIHRyYW5zZm9ybSBpZiBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybVxyXG4gICAgICovXHJcbiAgICBfcG9wQ2FtZXJhVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xyXG4gICAgICAgIGlmICh0cmFuc2Zvcm0uY29vcmRQbGFuZSA9PT0gQ29vcmRQbGFuZS5Xb3JsZCkge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjYW1lcmEgd29ybGQgb2Zmc2V0XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb25zU3lzdGVtLnRzXG5cclxuXHJcbmNsYXNzIEFjdGlvbnNTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGVzID0gWydleC5hY3Rpb25zJ107XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1UeXBlID0gU3lzdGVtVHlwZS5VcGRhdGU7XHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IC0xO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGVudGl0aWVzLCBkZWx0YSkge1xyXG4gICAgICAgIGxldCBhY3Rpb25zO1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIGFjdGlvbnMgPSBlbnRpdHkuZ2V0KEFjdGlvbnNDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBhY3Rpb25zLnVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vU2NlbmUudHNcbnZhciBTY2VuZV9kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBbW0FjdG9yfEFjdG9yc11dIGFyZSBjb21wb3NlZCB0b2dldGhlciBpbnRvIGdyb3VwaW5ncyBjYWxsZWQgU2NlbmVzIGluXHJcbiAqIEV4Y2FsaWJ1ci4gVGhlIG1ldGFwaG9yIG1vZGVscyB0aGUgc2FtZSBpZGVhIGJlaGluZCByZWFsIHdvcmxkXHJcbiAqIGFjdG9ycyBpbiBhIHNjZW5lLiBPbmx5IGFjdG9ycyBpbiBzY2VuZXMgd2lsbCBiZSB1cGRhdGVkIGFuZCBkcmF3bi5cclxuICpcclxuICogVHlwaWNhbCB1c2FnZXMgb2YgYSBzY2VuZSBpbmNsdWRlOiBsZXZlbHMsIG1lbnVzLCBsb2FkaW5nIHNjcmVlbnMsIGV0Yy5cclxuICovXHJcbmNsYXNzIFNjZW5lIGV4dGVuZHMgQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgY2FtZXJhIGZvciB0aGUgc2NlbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmEoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgRUNTIHdvcmxkIGZvciB0aGUgc2NlbmVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLndvcmxkID0gbmV3IFdvcmxkKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90aW1lcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jYW5jZWxRdWV1ZSA9IFtdO1xyXG4gICAgICAgIC8vIFRPRE8gaG93IHRvIHBlb3BsZSBkbyB0aGVyZSBvd24gc3lzdGVtc1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgc3lzdGVtc1xyXG4gICAgICAgIHRoaXMud29ybGQuYWRkKG5ldyBBY3Rpb25zU3lzdGVtKCkpO1xyXG4gICAgICAgIHRoaXMud29ybGQuYWRkKG5ldyBNb3Rpb25TeXN0ZW0oKSk7XHJcbiAgICAgICAgdGhpcy53b3JsZC5hZGQobmV3IENvbGxpc2lvblN5c3RlbSgpKTtcclxuICAgICAgICBpZiAoRmxhZ3MuaXNFbmFibGVkKExlZ2FjeS5MZWdhY3lEcmF3aW5nKSkge1xyXG4gICAgICAgICAgICB0aGlzLndvcmxkLmFkZChuZXcgQ2FudmFzRHJhd2luZ1N5c3RlbSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMud29ybGQuYWRkKG5ldyBHcmFwaGljc1N5c3RlbSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53b3JsZC5hZGQobmV3IERlYnVnU3lzdGVtKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgYWN0b3JzIGluIHRoZSBjdXJyZW50IHNjZW5lXHJcbiAgICAgKi9cclxuICAgIGdldCBhY3RvcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGQuZW50aXR5TWFuYWdlci5lbnRpdGllcy5maWx0ZXIoKGUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBBY3RvcjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGVudGl0aWVzIGluIHRoZSBjdXJyZW50IHNjZW5lXHJcbiAgICAgKi9cclxuICAgIGdldCBlbnRpdGllcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZC5lbnRpdHlNYW5hZ2VyLmVudGl0aWVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdHJpZ2dlcnMgaW4gdGhlIGN1cnJlbnQgc2NlbmVcclxuICAgICAqL1xyXG4gICAgZ2V0IHRyaWdnZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkLmVudGl0eU1hbmFnZXIuZW50aXRpZXMuZmlsdGVyKChlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgVHJpZ2dlcl9UcmlnZ2VyO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgW1tUaWxlTWFwXV1zIGluIHRoZSBzY2VuZSwgaWYgYW55XHJcbiAgICAgKi9cclxuICAgIGdldCB0aWxlTWFwcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZC5lbnRpdHlNYW5hZ2VyLmVudGl0aWVzLmZpbHRlcigoZSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIFRpbGVNYXA7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbW1NjcmVlbkVsZW1lbnRdXXMgaW4gYSBzY2VuZSwgaWYgYW55OyB0aGVzZSBhcmUgZHJhd24gbGFzdFxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbU2NlbmUuYWN0b3JzXV1cclxuICAgICAqL1xyXG4gICAgZ2V0IHNjcmVlbkVsZW1lbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdG9ycy5maWx0ZXIoKGEpID0+IGEgaW5zdGFuY2VvZiBTY3JlZW5FbGVtZW50X1NjcmVlbkVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub25jZShldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBvZiB0aGUgW1tTY2VuZV1dLiBJbml0aWFsaXplcyBzY2VuZSBtZW1iZXJzIGxpa2UgdGhlIGNhbWVyYS4gVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmVcclxuICAgICAqIG92ZXJyaWRkZW4uIFRoaXMgaXMgd2hlcmUgaW5pdGlhbGl6YXRpb24gb2YgY2hpbGQgYWN0b3JzIHNob3VsZCB0YWtlIHBsYWNlLlxyXG4gICAgICovXHJcbiAgICBvbkluaXRpYWxpemUoX2VuZ2luZSkge1xyXG4gICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBzY2VuZSBpcyBtYWRlIGFjdGl2ZSBhbmQgc3RhcnRlZC4gSXQgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbixcclxuICAgICAqIHRoaXMgaXMgd2hlcmUgeW91IHNob3VsZCBzZXR1cCBhbnkgRE9NIFVJIG9yIGV2ZW50IGhhbmRsZXJzIG5lZWRlZCBmb3IgdGhlIHNjZW5lLlxyXG4gICAgICovXHJcbiAgICBvbkFjdGl2YXRlKF9vbGRTY2VuZSwgX25ld1NjZW5lKSB7XHJcbiAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIG1hZGUgdHJhbnNpdGlvbmVkIGF3YXkgZnJvbSBhbmQgc3RvcHBlZC4gSXQgaXMgbWVhbnQgdG8gYmUgb3ZlcnJpZGRlbixcclxuICAgICAqIHRoaXMgaXMgd2hlcmUgeW91IHNob3VsZCBjbGVhbnVwIGFueSBET00gVUkgb3IgZXZlbnQgaGFuZGxlcnMgbmVlZGVkIGZvciB0aGUgc2NlbmUuXHJcbiAgICAgKi9cclxuICAgIG9uRGVhY3RpdmF0ZShfb2xkU2NlbmUsIF9uZXdTY2VuZSkge1xyXG4gICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUHJlVXBkYXRlIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncHJldXBkYXRlJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUHJlVXBkYXRlYCBpcyBjYWxsZWQgZGlyZWN0bHkgYmVmb3JlIGEgc2NlbmUgaXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgb25QcmVVcGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25Qb3N0VXBkYXRlIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncHJldXBkYXRlJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUG9zdFVwZGF0ZWAgaXMgY2FsbGVkIGRpcmVjdGx5IGFmdGVyIGEgc2NlbmUgaXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgb25Qb3N0VXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUHJlRHJhdyBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3ByZXVwZGF0ZScsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblByZURyYXdgIGlzIGNhbGxlZCBkaXJlY3RseSBiZWZvcmUgYSBzY2VuZSBpcyBkcmF3bi5cclxuICAgICAqL1xyXG4gICAgb25QcmVEcmF3KF9jdHgsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIHdpbGwgYmUgb3ZlcnJpZGRlblxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUG9zdERyYXcgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwcmV1cGRhdGUnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25Qb3N0RHJhd2AgaXMgY2FsbGVkIGRpcmVjdGx5IGFmdGVyIGEgc2NlbmUgaXMgZHJhd24uXHJcbiAgICAgKi9cclxuICAgIG9uUG9zdERyYXcoX2N0eCwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIGFjdG9ycyBpbiB0aGUgc2NlbmVcclxuICAgICAqL1xyXG4gICAgX2luaXRpYWxpemVDaGlsZHJlbigpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgY2hpbGQuX2luaXRpYWxpemUodGhpcy5lbmdpbmUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgW1tTY2VuZV1dIGhhcyBiZWVuIGluaXRpYWxpemVkXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0luaXRpYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0luaXRpYWxpemVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEluaXRpYWxpemVzIHRoZSBzY2VuZSBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSwgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IGVuZ2luZSBub3QgYnkgdXNlcnMgb2ZcclxuICAgICAqIEV4Y2FsaWJ1clxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9pbml0aWFsaXplKGVuZ2luZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICAvLyBJbml0aWFsaXplIGNhbWVyYSBmaXJzdFxyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgICAgICAgICAvLyBUaGlzIG9yZGVyIGlzIGltcG9ydGFudCEgd2Ugd2FudCB0byBiZSBzdXJlIGFueSBjdXN0b20gaW5pdCB0aGF0IGFkZCBhY3RvcnNcclxuICAgICAgICAgICAgLy8gZmlyZSBiZWZvcmUgdGhlIGFjdG9yIGluaXRcclxuICAgICAgICAgICAgdGhpcy5vbkluaXRpYWxpemUuY2FsbCh0aGlzLCBlbmdpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplQ2hpbGRyZW4oKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTY2VuZS5vbkluaXRpYWxpemUnLCB0aGlzLCBlbmdpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdpbml0aWFsaXplJywgbmV3IEluaXRpYWxpemVFdmVudChlbmdpbmUsIHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEFjdGl2YXRlcyB0aGUgc2NlbmUgd2l0aCB0aGUgYmFzZSBiZWhhdmlvciwgdGhlbiBjYWxscyB0aGUgb3ZlcnJpZGFibGUgYG9uQWN0aXZhdGVgIGltcGxlbWVudGF0aW9uLlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9hY3RpdmF0ZShvbGRTY2VuZSwgbmV3U2NlbmUpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1NjZW5lLm9uQWN0aXZhdGUnLCB0aGlzKTtcclxuICAgICAgICB0aGlzLm9uQWN0aXZhdGUob2xkU2NlbmUsIG5ld1NjZW5lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBEZWFjdGl2YXRlcyB0aGUgc2NlbmUgd2l0aCB0aGUgYmFzZSBiZWhhdmlvciwgdGhlbiBjYWxscyB0aGUgb3ZlcnJpZGFibGUgYG9uRGVhY3RpdmF0ZWAgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX2RlYWN0aXZhdGUob2xkU2NlbmUsIG5ld1NjZW5lKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTY2VuZS5vbkRlYWN0aXZhdGUnLCB0aGlzKTtcclxuICAgICAgICB0aGlzLm9uRGVhY3RpdmF0ZShvbGRTY2VuZSwgbmV3U2NlbmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wcmV1cGRhdGUgaGFuZGxlciBmb3IgW1tvblByZVVwZGF0ZV1dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wcmV1cGRhdGUoX2VuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBQcmVVcGRhdGVFdmVudChfZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25QcmVVcGRhdGUoX2VuZ2luZSwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiAgSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJldXBkYXRlIGhhbmRsZXIgZm9yIFtbb25Qb3N0VXBkYXRlXV0gbGlmZWN5Y2xlIGV2ZW50XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3Bvc3R1cGRhdGUoX2VuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3Bvc3R1cGRhdGUnLCBuZXcgUG9zdFVwZGF0ZUV2ZW50KF9lbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblBvc3RVcGRhdGUoX2VuZ2luZSwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wcmVkcmF3IGhhbmRsZXIgZm9yIFtbb25QcmVEcmF3XV0gbGlmZWN5Y2xlIGV2ZW50XHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wcmVkcmF3KF9jdHgsIF9kZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncHJlZHJhdycsIG5ldyBQcmVEcmF3RXZlbnQoX2N0eCwgX2RlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblByZURyYXcoX2N0eCwgX2RlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcG9zdGRyYXcgaGFuZGxlciBmb3IgW1tvblBvc3REcmF3XV0gbGlmZWN5Y2xlIGV2ZW50XHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wb3N0ZHJhdyhfY3R4LCBfZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkcmF3JywgbmV3IFBvc3REcmF3RXZlbnQoX2N0eCwgX2RlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblBvc3REcmF3KF9jdHgsIF9kZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgYWxsIHRoZSBhY3RvcnMgYW5kIHRpbWVycyBpbiB0aGUgc2NlbmUuIENhbGxlZCBieSB0aGUgW1tFbmdpbmVdXS5cclxuICAgICAqIEBwYXJhbSBlbmdpbmUgIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBFbmdpbmVcclxuICAgICAqIEBwYXJhbSBkZWx0YSAgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuX3ByZXVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICBpZiAodGhpcy5jYW1lcmEpIHtcclxuICAgICAgICAgICAgdGhpcy5jYW1lcmEudXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIGRpZmZlcmVkIGVudGl0eSByZW1vdmFsIGZvciB0aW1lcnNcclxuICAgICAgICBsZXQgaSwgbGVuO1xyXG4gICAgICAgIC8vIFJlbW92ZSB0aW1lcnMgaW4gdGhlIGNhbmNlbCBxdWV1ZSBiZWZvcmUgdXBkYXRpbmcgdGhlbVxyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX2NhbmNlbFF1ZXVlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIodGhpcy5fY2FuY2VsUXVldWVbaV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jYW5jZWxRdWV1ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIC8vIEN5Y2xlIHRocm91Z2ggdGltZXJzIHVwZGF0aW5nIHRpbWVyc1xyXG4gICAgICAgIGZvciAoY29uc3QgdGltZXIgb2YgdGhpcy5fdGltZXJzKSB7XHJcbiAgICAgICAgICAgIHRpbWVyLnVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud29ybGQudXBkYXRlKFN5c3RlbVR5cGUuVXBkYXRlLCBkZWx0YSk7XHJcbiAgICAgICAgdGhpcy5fY29sbGVjdEFjdG9yU3RhdHMoZW5naW5lKTtcclxuICAgICAgICBlbmdpbmUuaW5wdXQucG9pbnRlcnMuZGlzcGF0Y2hQb2ludGVyRXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5fcG9zdHVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYWxsIHRoZSBhY3RvcnMgaW4gdGhlIFNjZW5lLiBDYWxsZWQgYnkgdGhlIFtbRW5naW5lXV0uXHJcbiAgICAgKiBAcGFyYW0gY3R4ICAgIFRoZSBjdXJyZW50IHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IGRyYXdcclxuICAgICAqL1xyXG4gICAgZHJhdyhjdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHRoaXMuX3ByZWRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgdGhpcy53b3JsZC51cGRhdGUoU3lzdGVtVHlwZS5EcmF3LCBkZWx0YSk7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEZWJ1Zykge1xyXG4gICAgICAgICAgICB0aGlzLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9wb3N0ZHJhdyhjdHgsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgYWxsIHRoZSBhY3RvcnMnIGRlYnVnIGluZm9ybWF0aW9uIGluIHRoZSBTY2VuZS4gQ2FsbGVkIGJ5IHRoZSBbW0VuZ2luZV1dLlxyXG4gICAgICogQHBhcmFtIGN0eCAgVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBkZWJ1Z0RyYXcoY3R4KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVkZWJ1Z2RyYXcnLCBuZXcgUHJlRGVidWdEcmF3RXZlbnQoY3R4LCB0aGlzKSk7XHJcbiAgICAgICAgLy8gcGFzc1xyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdGRlYnVnZHJhdycsIG5ldyBQb3N0RGVidWdEcmF3RXZlbnQoY3R4LCB0aGlzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGFjdG9yIGlzIGNvbnRhaW5lZCBpbiB0aGlzIHNjZW5lIG9yIG5vdFxyXG4gICAgICovXHJcbiAgICBjb250YWlucyhhY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjdG9ycy5pbmRleE9mKGFjdG9yKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgYWRkKGVudGl0eSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgnZW50aXR5YWRkZWQnLCB7IHRhcmdldDogZW50aXR5IH0pO1xyXG4gICAgICAgIHRoaXMud29ybGQuYWRkKGVudGl0eSk7XHJcbiAgICAgICAgZW50aXR5LnNjZW5lID0gdGhpcztcclxuICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGltZXIpIHtcclxuICAgICAgICAgICAgaWYgKCFjb250YWlucyh0aGlzLl90aW1lcnMsIGVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkVGltZXIoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlKGVudGl0eSkge1xyXG4gICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBFbnRpdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlbnRpdHlyZW1vdmVkJywgeyB0YXJnZXQ6IGVudGl0eSB9KTtcclxuICAgICAgICAgICAgdGhpcy53b3JsZC5yZW1vdmUoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFRpbWVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlVGltZXIoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgKGFueSkgYWN0b3IgdG8gYWN0IGFzIGEgcGllY2Ugb2YgVUksIG1lYW5pbmcgaXQgaXMgYWx3YXlzIHBvc2l0aW9uZWRcclxuICAgICAqIGluIHNjcmVlbiBjb29yZGluYXRlcy4gVUkgYWN0b3JzIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBjb2xsaXNpb25zLlxyXG4gICAgICogQHRvZG8gU2hvdWxkIHRoaXMgYmUgYFNjcmVlbkVsZW1lbnRgIG9ubHk/XHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tTY2VuZS5hZGRdXVxyXG4gICAgICovXHJcbiAgICBhZGRTY3JlZW5FbGVtZW50KGFjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5hZGQoYWN0b3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIGFjdG9yIGFzIGEgcGllY2Ugb2YgVUlcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW1NjZW5lLnJlbW92ZV1dXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVNjcmVlbkVsZW1lbnQoYWN0b3IpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZShhY3Rvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBbW1RpbGVNYXBdXSB0byB0aGUgc2NlbmUsIG9uY2UgdGhpcyBpcyBkb25lIHRoZSBUaWxlTWFwIHdpbGwgYmUgZHJhd24gYW5kIHVwZGF0ZWQuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tTY2VuZS5hZGRdXVxyXG4gICAgICovXHJcbiAgICBhZGRUaWxlTWFwKHRpbGVNYXApIHtcclxuICAgICAgICB0aGlzLndvcmxkLmFkZCh0aWxlTWFwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIFtbVGlsZU1hcF1dIGZyb20gdGhlIHNjZW5lLCBpdCB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbU2NlbmUucmVtb3ZlXV1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlVGlsZU1hcCh0aWxlTWFwKSB7XHJcbiAgICAgICAgdGhpcy53b3JsZC5yZW1vdmUodGlsZU1hcCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBbW1RpbWVyXV0gdG8gdGhlIHNjZW5lXHJcbiAgICAgKiBAcGFyYW0gdGltZXIgIFRoZSB0aW1lciB0byBhZGRcclxuICAgICAqL1xyXG4gICAgYWRkVGltZXIodGltZXIpIHtcclxuICAgICAgICB0aGlzLl90aW1lcnMucHVzaCh0aW1lcik7XHJcbiAgICAgICAgdGltZXIuc2NlbmUgPSB0aGlzO1xyXG4gICAgICAgIHJldHVybiB0aW1lcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIFtbVGltZXJdXSBmcm9tIHRoZSBzY2VuZS5cclxuICAgICAqIEB3YXJuaW5nIENhbiBiZSBkYW5nZXJvdXMsIHVzZSBbW2NhbmNlbFRpbWVyXV0gaW5zdGVhZFxyXG4gICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gcmVtb3ZlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVRpbWVyKHRpbWVyKSB7XHJcbiAgICAgICAgY29uc3QgaSA9IHRoaXMuX3RpbWVycy5pbmRleE9mKHRpbWVyKTtcclxuICAgICAgICBpZiAoaSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGltZXJzLnNwbGljZShpLCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRpbWVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWxzIGEgW1tUaW1lcl1dLCByZW1vdmluZyBpdCBmcm9tIHRoZSBzY2VuZSBuaWNlbHlcclxuICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIGNhbmNlbFxyXG4gICAgICovXHJcbiAgICBjYW5jZWxUaW1lcih0aW1lcikge1xyXG4gICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlLnB1c2godGltZXIpO1xyXG4gICAgICAgIHJldHVybiB0aW1lcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgd2hldGhlciBhIFtbVGltZXJdXSBpcyBhY3RpdmUgaW4gdGhlIHNjZW5lXHJcbiAgICAgKi9cclxuICAgIGlzVGltZXJBY3RpdmUodGltZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGltZXJzLmluZGV4T2YodGltZXIpID4gLTEgJiYgIXRpbWVyLmNvbXBsZXRlO1xyXG4gICAgfVxyXG4gICAgaXNDdXJyZW50U2NlbmUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVuZ2luZS5jdXJyZW50U2NlbmUgPT09IHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIF9jb2xsZWN0QWN0b3JTdGF0cyhlbmdpbmUpIHtcclxuICAgICAgICBjb25zdCBzY3JlZW5FbGVtZW50cyA9IHRoaXMuYWN0b3JzLmZpbHRlcigoYSkgPT4gYSBpbnN0YW5jZW9mIFNjcmVlbkVsZW1lbnRfU2NyZWVuRWxlbWVudCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBfdWkgb2Ygc2NyZWVuRWxlbWVudHMpIHtcclxuICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5hY3RvcnMudWkrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBhY3RvciBvZiB0aGlzLmFjdG9ycykge1xyXG4gICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy5hbGl2ZSsrO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGFjdG9yLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNTY3JlZW5FbGVtZW50KGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gbm90IHRydWVcclxuICAgICAgICAgICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy51aSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5hY3RvcnMuYWxpdmUrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5TY2VuZV9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ1dpbGwgYmUgcmVtb3ZlZCBpbiBleGNhbGlidXIgdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnU2NyZWVuRWxlbWVudHMgbm93IGFyZSBub3JtYWwgYWN0b3JzIHdpdGggYSBUcmFuc2Zvcm0gQ29vcmRpbmF0ZSBQbGFuZSBvZiBTY3JlZW4nXHJcbiAgICB9KVxyXG5dLCBTY2VuZS5wcm90b3R5cGUsIFwic2NyZWVuRWxlbWVudHNcIiwgbnVsbCk7XHJcblNjZW5lX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHsgbWVzc2FnZTogJ1dpbGwgYmUgcmVtb3ZlZCBpbiBleGNhbGlidXIgdjAuMjYuMCcsIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBTY2VuZS5hZGQnIH0pXHJcbl0sIFNjZW5lLnByb3RvdHlwZSwgXCJhZGRTY3JlZW5FbGVtZW50XCIsIG51bGwpO1xyXG5TY2VuZV9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7IG1lc3NhZ2U6ICdXaWxsIGJlIHJlbW92ZWQgaW4gZXhjYWxpYnVyIHYwLjI2LjAnLCBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgU2NlbmUucmVtb3ZlJyB9KVxyXG5dLCBTY2VuZS5wcm90b3R5cGUsIFwicmVtb3ZlU2NyZWVuRWxlbWVudFwiLCBudWxsKTtcclxuU2NlbmVfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnV2lsbCBiZSByZW1vdmVkIGluIGV4Y2FsaWJ1ciB2MC4yNi4wJywgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIFNjZW5lLmFkZCcgfSlcclxuXSwgU2NlbmUucHJvdG90eXBlLCBcImFkZFRpbGVNYXBcIiwgbnVsbCk7XHJcblNjZW5lX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHsgbWVzc2FnZTogJ1dpbGwgYmUgcmVtb3ZlZCBpbiBleGNhbGlidXIgdjAuMjYuMCcsIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBTY2VuZS5yZW1vdmUnIH0pXHJcbl0sIFNjZW5lLnByb3RvdHlwZSwgXCJyZW1vdmVUaWxlTWFwXCIsIG51bGwpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1Bvc3RQcm9jZXNzaW5nL0NvbG9yQmxpbmRDb3JyZWN0b3IudHNcblxyXG52YXIgQ29sb3JCbGluZG5lc3M7XHJcbihmdW5jdGlvbiAoQ29sb3JCbGluZG5lc3MpIHtcclxuICAgIENvbG9yQmxpbmRuZXNzW0NvbG9yQmxpbmRuZXNzW1wiUHJvdGFub3BlXCJdID0gMF0gPSBcIlByb3Rhbm9wZVwiO1xyXG4gICAgQ29sb3JCbGluZG5lc3NbQ29sb3JCbGluZG5lc3NbXCJEZXV0ZXJhbm9wZVwiXSA9IDFdID0gXCJEZXV0ZXJhbm9wZVwiO1xyXG4gICAgQ29sb3JCbGluZG5lc3NbQ29sb3JCbGluZG5lc3NbXCJUcml0YW5vcGVcIl0gPSAyXSA9IFwiVHJpdGFub3BlXCI7XHJcbn0pKENvbG9yQmxpbmRuZXNzIHx8IChDb2xvckJsaW5kbmVzcyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGlzIHBvc3QgcHJvY2Vzc29yIGNhbiBjb3JyZWN0IGNvbG9ycyBhbmQgc2ltdWxhdGUgY29sb3IgYmxpbmRuZXNzLlxyXG4gKiBJdCBpcyBwb3NzaWJsZSB0byB1c2UgdGhpcyBvbiBldmVyeSBnYW1lLCBidXQgdGhlIGdhbWUncyBwZXJmb3JtYW5jZVxyXG4gKiB3aWxsIHN1ZmZlciBtZWFzdXJhYmx5LiBJdCdzIGJldHRlciB0byB1c2UgaXQgYXMgYSBoZWxwZnVsIHRvb2wgd2hpbGUgZGV2ZWxvcGluZyB5b3VyIGdhbWUuXHJcbiAqIFJlbWVtYmVyLCB0aGUgYmVzdCBwcmFjdGljZSBpcyB0byBkZXNpZ24gd2l0aCBjb2xvciBibGluZG5lc3MgaW4gbWluZC5cclxuICovXHJcbmNsYXNzIENvbG9yQmxpbmRDb3JyZWN0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lLCBzaW11bGF0ZSA9IGZhbHNlLCBjb2xvck1vZGUgPSBDb2xvckJsaW5kbmVzcy5Qcm90YW5vcGUpIHtcclxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLnNpbXVsYXRlID0gc2ltdWxhdGU7XHJcbiAgICAgICAgdGhpcy5jb2xvck1vZGUgPSBjb2xvck1vZGU7XHJcbiAgICAgICAgLyplc2xpbnQtZGlzYWJsZSAqL1xyXG4gICAgICAgIHRoaXMuX3ZlcnRleFNoYWRlciA9ICcnICtcclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247JyArXHJcbiAgICAgICAgICAgICdhdHRyaWJ1dGUgdmVjMiBhX3RleENvb3JkOycgK1xyXG4gICAgICAgICAgICAndW5pZm9ybSB2ZWMyIHVfcmVzb2x1dGlvbjsnICtcclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3RleENvb3JkOycgK1xyXG4gICAgICAgICAgICAndm9pZCBtYWluKCkgeycgK1xyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSByZWN0YW5nbGUgZnJvbSBwaXhlbHMgdG8gMC4wIHRvIDEuMFxyXG4gICAgICAgICAgICAndmVjMiB6ZXJvVG9PbmUgPSBhX3Bvc2l0aW9uIC8gdV9yZXNvbHV0aW9uOycgK1xyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGZyb20gMC0+MSB0byAwLT4yXHJcbiAgICAgICAgICAgICd2ZWMyIHplcm9Ub1R3byA9IHplcm9Ub09uZSAqIDIuMDsnICtcclxuICAgICAgICAgICAgLy8gY29udmVydCBmcm9tIDAtPjIgdG8gLTEtPisxIChjbGlwc3BhY2UpXHJcbiAgICAgICAgICAgICd2ZWMyIGNsaXBTcGFjZSA9IHplcm9Ub1R3byAtIDEuMDsnICtcclxuICAgICAgICAgICAgJ2dsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2UgKiB2ZWMyKDEsIC0xKSwgMCwgMSk7JyArXHJcbiAgICAgICAgICAgIC8vIHBhc3MgdGhlIHRleENvb3JkIHRvIHRoZSBmcmFnbWVudCBzaGFkZXJcclxuICAgICAgICAgICAgLy8gVGhlIEdQVSB3aWxsIGludGVycG9sYXRlIHRoaXMgdmFsdWUgYmV0d2VlbiBwb2ludHMuXHJcbiAgICAgICAgICAgICd2X3RleENvb3JkID0gYV90ZXhDb29yZDsnICtcclxuICAgICAgICAgICAgJ30nO1xyXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gJ3ByZWNpc2lvbiBtZWRpdW1wIGZsb2F0OycgK1xyXG4gICAgICAgICAgICAvLyBvdXIgdGV4dHVyZVxyXG4gICAgICAgICAgICAndW5pZm9ybSBzYW1wbGVyMkQgdV9pbWFnZTsnICtcclxuICAgICAgICAgICAgLy8gdGhlIHRleENvb3JkcyBwYXNzZWQgaW4gZnJvbSB0aGUgdmVydGV4IHNoYWRlci5cclxuICAgICAgICAgICAgJ3ZhcnlpbmcgdmVjMiB2X3RleENvb3JkOycgK1xyXG4gICAgICAgICAgICAvLyBDb2xvciBibGluZCBjb252ZXJzaW9uc1xyXG4gICAgICAgICAgICAvKidtYXQzIG1bOV0gPScgK1xyXG4gICAgICAgICAgICd7JyArXHJcbiAgICAgICAgICAgICAgJ21hdDMoMS4wLCAwLjAsIDAuMCwgIDAuMCwgMS4wLCAwLjAsICAwLjAsIDAuMCwgMS4wICApLCcgKyAvLyBub3JtYWxcclxuICAgICAgICAgICAgICAnbWF0MygwLjU2NywgMC40MzMsIDAuMCwgIDAuNTU4LCAwLjQ0MiwgMC4wLCAgMC4wLCAwLjI0MiwgMC43NTgpLCcgKyAvLyBwcm90YW5vcGlhXHJcbiAgICAgICAgICAgICAgJ21hdDMoMC44MTcsIDAuMTgzLCAwLjAsICAwLjMzMywgMC42NjcsIDAuMCwgIDAuMCwgMC4xMjUsMC44NzUpLCcgKyAvLyBwcm90YW5vbWFseVxyXG4gICAgICAgICAgICAgICdtYXQzKDAuNjI1LCAwLjM3NSwgMC4wLCAgMC43LCAwLjMsIDAuMCwgIDAuMCwgMC4zLDAuNyAgKSwnICsgLy8gZGV1dGVyYW5vcGlhXHJcbiAgICAgICAgICAgICAgJ21hdDMoMC44LCAwLjIsIDAuMCwgIDAuMjU4LCAwLjc0MiwgMC4wLCAgMC4wLCAwLjE0MiwwLjg1OCksJyArIC8vIGRldXRlcmFub21hbHlcclxuICAgICAgICAgICAgICAnbWF0MygwLjk1LCAwLjA1LCAwLjAsICAwLjAsIDAuNDMzLCAwLjU2NywgIDAuMCwgMC40NzUsMC41MjUpLCcgKyAvLyB0cml0YW5vcGlhXHJcbiAgICAgICAgICAgICAgJ21hdDMoMC45NjcsIDAuMDMzLCAwLjAsICAwLjAsIDAuNzMzLCAwLjI2NywgIDAuMCwgMC4xODMsMC44MTcpLCcgKyAvLyB0cml0YW5vbWFseVxyXG4gICAgICAgICAgICAgICdtYXQzKDAuMjk5LCAwLjU4NywgMC4xMTQsICAwLjI5OSwgMC41ODcsIDAuMTE0LCAgMC4yOTksIDAuNTg3LDAuMTE0KSwnICsgLy8gYWNocm9tYXRvcHNpYVxyXG4gICAgICAgICAgICAgICdtYXQzKDAuNjE4LCAwLjMyMCwgMC4wNjIsICAwLjE2MywgMC43NzUsIDAuMDYyLCAgMC4xNjMsIDAuMzIwLDAuNTE2KScgKyAgLy8gYWNocm9tYXRvbWFseVxyXG4gICAgICAgICAgICd9OycgKyovXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyArXHJcbiAgICAgICAgICAgICd2ZWM0IG8gPSAgdGV4dHVyZTJEKHVfaW1hZ2UsIHZfdGV4Q29vcmQpOycgK1xyXG4gICAgICAgICAgICAvLyBSR0IgdG8gTE1TIG1hdHJpeCBjb252ZXJzaW9uXHJcbiAgICAgICAgICAgICdmbG9hdCBMID0gKDE3Ljg4MjQgKiBvLnIpICsgKDQzLjUxNjEgKiBvLmcpICsgKDQuMTE5MzUgKiBvLmIpOycgK1xyXG4gICAgICAgICAgICAnZmxvYXQgTSA9ICgzLjQ1NTY1ICogby5yKSArICgyNy4xNTU0ICogby5nKSArICgzLjg2NzE0ICogby5iKTsnICtcclxuICAgICAgICAgICAgJ2Zsb2F0IFMgPSAoMC4wMjk5NTY2ICogby5yKSArICgwLjE4NDMwOSAqIG8uZykgKyAoMS40NjcwOSAqIG8uYik7JyArXHJcbiAgICAgICAgICAgIC8vIFNpbXVsYXRlIGNvbG9yIGJsaW5kbmVzc1xyXG4gICAgICAgICAgICAnLy9NT0RFIENPREUvLycgK1xyXG4gICAgICAgICAgICAvKiBEZXV0ZXJhbm9wZSBmb3IgdGVzdGluZ1xyXG4gICAgICAgICAgICAgICdmbG9hdCBsID0gMS4wICogTCArIDAuMCAqIE0gKyAwLjAgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICdmbG9hdCBtID0gMC40OTQyMDcgKiBMICsgMC4wICogTSArIDEuMjQ4MjcgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICdmbG9hdCBzID0gMC4wICogTCArIDAuMCAqIE0gKyAxLjAgKiBTOycgKyovXHJcbiAgICAgICAgICAgIC8vIExNUyB0byBSR0IgbWF0cml4IGNvbnZlcnNpb25cclxuICAgICAgICAgICAgJ3ZlYzQgZXJyb3I7JyArXHJcbiAgICAgICAgICAgICdlcnJvci5yID0gKDAuMDgwOTQ0NDQ3OSAqIGwpICsgKC0wLjEzMDUwNDQwOSAqIG0pICsgKDAuMTE2NzIxMDY2ICogcyk7JyArXHJcbiAgICAgICAgICAgICdlcnJvci5nID0gKC0wLjAxMDI0ODUzMzUgKiBsKSArICgwLjA1NDAxOTMyNjYgKiBtKSArICgtMC4xMTM2MTQ3MDggKiBzKTsnICtcclxuICAgICAgICAgICAgJ2Vycm9yLmIgPSAoLTAuMDAwMzY1Mjk2OTM4ICogbCkgKyAoLTAuMDA0MTIxNjE0NjkgKiBtKSArICgwLjY5MzUxMTQwNSAqIHMpOycgK1xyXG4gICAgICAgICAgICAnZXJyb3IuYSA9IDEuMDsnICtcclxuICAgICAgICAgICAgJ3ZlYzQgZGlmZiA9IG8gLSBlcnJvcjsnICtcclxuICAgICAgICAgICAgJ3ZlYzQgY29ycmVjdGlvbjsnICtcclxuICAgICAgICAgICAgJ2NvcnJlY3Rpb24uciA9IDAuMDsnICtcclxuICAgICAgICAgICAgJ2NvcnJlY3Rpb24uZyA9ICAoZGlmZi5yICogMC43KSArIChkaWZmLmcgKiAxLjApOycgK1xyXG4gICAgICAgICAgICAnY29ycmVjdGlvbi5iID0gIChkaWZmLnIgKiAwLjcpICsgKGRpZmYuYiAqIDEuMCk7JyArXHJcbiAgICAgICAgICAgICdjb3JyZWN0aW9uID0gbyArIGNvcnJlY3Rpb247JyArXHJcbiAgICAgICAgICAgICdjb3JyZWN0aW9uLmEgPSBvLmE7JyArXHJcbiAgICAgICAgICAgICcvL1NJTVVMQVRFLy8nICtcclxuICAgICAgICAgICAgJ30nO1xyXG4gICAgICAgIHRoaXMuX2ludGVybmFsQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgdGhpcy5faW50ZXJuYWxDYW52YXMud2lkdGggPSBlbmdpbmUuZHJhd1dpZHRoO1xyXG4gICAgICAgIHRoaXMuX2ludGVybmFsQ2FudmFzLmhlaWdodCA9IGVuZ2luZS5kcmF3SGVpZ2h0O1xyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxyXG4gICAgICAgIHRoaXMuX2dsID0gdGhpcy5faW50ZXJuYWxDYW52YXMuZ2V0Q29udGV4dCgnd2ViZ2wnLCB7IHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogdHJ1ZSB9KTtcclxuICAgICAgICB0aGlzLl9wcm9ncmFtID0gdGhpcy5fZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgICAgIGNvbnN0IGZyYWdtZW50U2hhZGVyID0gdGhpcy5fZ2V0U2hhZGVyKCdGcmFnbWVudCcsIHRoaXMuX2dldEZyYWdtZW50U2hhZGVyQnlNb2RlKGNvbG9yTW9kZSkpO1xyXG4gICAgICAgIGNvbnN0IHZlcnRleHRTaGFkZXIgPSB0aGlzLl9nZXRTaGFkZXIoJ1ZlcnRleCcsIHRoaXMuX3ZlcnRleFNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5fZ2wuYXR0YWNoU2hhZGVyKHRoaXMuX3Byb2dyYW0sIHZlcnRleHRTaGFkZXIpO1xyXG4gICAgICAgIHRoaXMuX2dsLmF0dGFjaFNoYWRlcih0aGlzLl9wcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5fZ2wubGlua1Byb2dyYW0odGhpcy5fcHJvZ3JhbSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHRoaXMuX3Byb2dyYW0sIHRoaXMuX2dsLkxJTktfU1RBVFVTKSkge1xyXG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignVW5hYmxlIHRvIGxpbmsgc2hhZGVyIHByb2dyYW0hJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2dsLnVzZVByb2dyYW0odGhpcy5fcHJvZ3JhbSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0RnJhZ21lbnRTaGFkZXJCeU1vZGUoY29sb3JNb2RlKSB7XHJcbiAgICAgICAgbGV0IGNvZGUgPSAnJztcclxuICAgICAgICBpZiAoY29sb3JNb2RlID09PSBDb2xvckJsaW5kbmVzcy5Qcm90YW5vcGUpIHtcclxuICAgICAgICAgICAgY29kZSA9XHJcbiAgICAgICAgICAgICAgICAnZmxvYXQgbCA9IDAuMCAqIEwgKyAyLjAyMzQ0ICogTSArIC0yLjUyNTgxICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbSA9IDAuMCAqIEwgKyAxLjAgKiBNICsgMC4wICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAnZmxvYXQgcyA9IDAuMCAqIEwgKyAwLjAgKiBNICsgMS4wICogUzsnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2xvck1vZGUgPT09IENvbG9yQmxpbmRuZXNzLkRldXRlcmFub3BlKSB7XHJcbiAgICAgICAgICAgIGNvZGUgPVxyXG4gICAgICAgICAgICAgICAgJ2Zsb2F0IGwgPSAxLjAgKiBMICsgMC4wICogTSArIDAuMCAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IG0gPSAwLjQ5NDIwNyAqIEwgKyAwLjAgKiBNICsgMS4yNDgyNyAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IHMgPSAwLjAgKiBMICsgMC4wICogTSArIDEuMCAqIFM7JztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29sb3JNb2RlID09PSBDb2xvckJsaW5kbmVzcy5Ucml0YW5vcGUpIHtcclxuICAgICAgICAgICAgY29kZSA9XHJcbiAgICAgICAgICAgICAgICAnZmxvYXQgbCA9IDEuMCAqIEwgKyAwLjAgKiBNICsgMC4wICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbSA9IDAuMCAqIEwgKyAxLjAgKiBNICsgMC4wICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAnZmxvYXQgcyA9IC0wLjM5NTkxMyAqIEwgKyAwLjgwMTEwOSAqIE0gKyAwLjAgKiBTOyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnNpbXVsYXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gdGhpcy5fZnJhZ21lbnRTaGFkZXIucmVwbGFjZSgnLy9TSU1VTEFURS8vJywgJ2dsX0ZyYWdDb2xvciA9IGVycm9yLnJnYmE7Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9mcmFnbWVudFNoYWRlciA9IHRoaXMuX2ZyYWdtZW50U2hhZGVyLnJlcGxhY2UoJy8vU0lNVUxBVEUvLycsICdnbF9GcmFnQ29sb3IgPSBjb3JyZWN0aW9uLnJnYmE7Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9mcmFnbWVudFNoYWRlci5yZXBsYWNlKCcvL01PREUgQ09ERS8vJywgY29kZSk7XHJcbiAgICB9XHJcbiAgICBfc2V0UmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICBjb25zdCB4MSA9IHg7XHJcbiAgICAgICAgY29uc3QgeDIgPSB4ICsgd2lkdGg7XHJcbiAgICAgICAgY29uc3QgeTEgPSB5O1xyXG4gICAgICAgIGNvbnN0IHkyID0geSArIGhlaWdodDtcclxuICAgICAgICB0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbeDEsIHkxLCB4MiwgeTEsIHgxLCB5MiwgeDEsIHkyLCB4MiwgeTEsIHgyLCB5Ml0pLCB0aGlzLl9nbC5TVEFUSUNfRFJBVyk7XHJcbiAgICB9XHJcbiAgICBfZ2V0U2hhZGVyKHR5cGUsIHByb2dyYW0pIHtcclxuICAgICAgICBsZXQgc2hhZGVyO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAnRnJhZ21lbnQnKSB7XHJcbiAgICAgICAgICAgIHNoYWRlciA9IHRoaXMuX2dsLmNyZWF0ZVNoYWRlcih0aGlzLl9nbC5GUkFHTUVOVF9TSEFERVIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0eXBlID09PSAnVmVydGV4Jykge1xyXG4gICAgICAgICAgICBzaGFkZXIgPSB0aGlzLl9nbC5jcmVhdGVTaGFkZXIodGhpcy5fZ2wuVkVSVEVYX1NIQURFUik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignRXJyb3IgdW5rbm93biBzaGFkZXIgdHlwZScsIHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBwcm9ncmFtKTtcclxuICAgICAgICB0aGlzLl9nbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9nbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCB0aGlzLl9nbC5DT01QSUxFX1NUQVRVUykpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ1VuYWJsZSB0byBjb21waWxlIHNoYWRlciEnLCB0aGlzLl9nbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcikpO1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgIH1cclxuICAgIHByb2Nlc3MoaW1hZ2UsIG91dCkge1xyXG4gICAgICAgIC8vIGxvb2sgdXAgd2hlcmUgdGhlIHZlcnRleCBkYXRhIG5lZWRzIHRvIGdvLlxyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uTG9jYXRpb24gPSB0aGlzLl9nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9wcm9ncmFtLCAnYV9wb3NpdGlvbicpO1xyXG4gICAgICAgIGNvbnN0IHRleENvb3JkTG9jYXRpb24gPSB0aGlzLl9nbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLl9wcm9ncmFtLCAnYV90ZXhDb29yZCcpO1xyXG4gICAgICAgIGNvbnN0IHRleENvb3JkQnVmZmVyID0gdGhpcy5fZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIHRleENvb3JkQnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9nbC5idWZmZXJEYXRhKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAxLjAsIDEuMCwgMC4wLCAxLjAsIDEuMF0pLCB0aGlzLl9nbC5TVEFUSUNfRFJBVyk7XHJcbiAgICAgICAgdGhpcy5fZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGV4Q29vcmRMb2NhdGlvbik7XHJcbiAgICAgICAgdGhpcy5fZ2wudmVydGV4QXR0cmliUG9pbnRlcih0ZXhDb29yZExvY2F0aW9uLCAyLCB0aGlzLl9nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIHRleHR1cmUuXHJcbiAgICAgICAgY29uc3QgdGV4dHVyZSA9IHRoaXMuX2dsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgICB0aGlzLl9nbC5iaW5kVGV4dHVyZSh0aGlzLl9nbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcclxuICAgICAgICAvLyBTZXQgdGhlIHBhcmFtZXRlcnMgc28gd2UgY2FuIHJlbmRlciBhbnkgc2l6ZSBpbWFnZS5cclxuICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9TLCB0aGlzLl9nbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl9nbC5DTEFNUF9UT19FREdFKTtcclxuICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5fZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgdGhpcy5fZ2wudGV4UGFyYW1ldGVyaSh0aGlzLl9nbC5URVhUVVJFXzJELCB0aGlzLl9nbC5URVhUVVJFX01BR19GSUxURVIsIHRoaXMuX2dsLk5FQVJFU1QpO1xyXG4gICAgICAgIC8vIEZsaXAgdGhlIHRleHR1cmUgd2hlbiB1bnBhY2tpbmcgaW50byB0aGUgZ2wgY29udGV4dCwgZ2wgcmVhZHMgdGV4dHVyZXMgaW4gdGhlIG9wcG9zaXRlIG9yZGVyIGFzIGV2ZXJ5dGhpbmcgZWxzZSA6L1xyXG4gICAgICAgIHRoaXMuX2dsLnBpeGVsU3RvcmVpKHRoaXMuX2dsLlVOUEFDS19GTElQX1lfV0VCR0wsIDEpO1xyXG4gICAgICAgIC8vIFVwbG9hZCB0aGUgaW1hZ2UgaW50byB0aGUgdGV4dHVyZS5cclxuICAgICAgICB0aGlzLl9nbC50ZXhJbWFnZTJEKHRoaXMuX2dsLlRFWFRVUkVfMkQsIDAsIHRoaXMuX2dsLlJHQkEsIHRoaXMuX2dsLlJHQkEsIHRoaXMuX2dsLlVOU0lHTkVEX0JZVEUsIGltYWdlKTtcclxuICAgICAgICAvLyBsb29rdXAgdW5pZm9ybXNcclxuICAgICAgICBjb25zdCByZXNvbHV0aW9uTG9jYXRpb24gPSB0aGlzLl9nbC5nZXRVbmlmb3JtTG9jYXRpb24odGhpcy5fcHJvZ3JhbSwgJ3VfcmVzb2x1dGlvbicpO1xyXG4gICAgICAgIC8vIHNldCB0aGUgcmVzb2x1dGlvblxyXG4gICAgICAgIHRoaXMuX2dsLnVuaWZvcm0yZihyZXNvbHV0aW9uTG9jYXRpb24sIHRoaXMuX2ludGVybmFsQ2FudmFzLndpZHRoLCB0aGlzLl9pbnRlcm5hbENhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIC8vIENyZWF0ZSBhIGJ1ZmZlciBmb3IgdGhlIHBvc2l0aW9uIG9mIHRoZSByZWN0YW5nbGUgY29ybmVycy5cclxuICAgICAgICBjb25zdCBwb3NpdGlvbkJ1ZmZlciA9IHRoaXMuX2dsLmNyZWF0ZUJ1ZmZlcigpO1xyXG4gICAgICAgIHRoaXMuX2dsLmJpbmRCdWZmZXIodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCBwb3NpdGlvbkJ1ZmZlcik7XHJcbiAgICAgICAgdGhpcy5fZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb25Mb2NhdGlvbik7XHJcbiAgICAgICAgdGhpcy5fZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbkxvY2F0aW9uLCAyLCB0aGlzLl9nbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xyXG4gICAgICAgIC8vIFNldCBhIHJlY3RhbmdsZSB0aGUgc2FtZSBzaXplIGFzIHRoZSBpbWFnZS5cclxuICAgICAgICB0aGlzLl9zZXRSZWN0YW5nbGUoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XHJcbiAgICAgICAgLy8gRHJhdyB0aGUgcmVjdGFuZ2xlLlxyXG4gICAgICAgIHRoaXMuX2dsLmRyYXdBcnJheXModGhpcy5fZ2wuVFJJQU5HTEVTLCAwLCA2KTtcclxuICAgICAgICAvLyBHcmFiIHRyYW5zZm9ybWVkIGltYWdlIGZyb20gaW50ZXJuYWwgY2FudmFzXHJcbiAgICAgICAgY29uc3QgcGl4ZWxEYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW1hZ2Uud2lkdGggKiBpbWFnZS5oZWlnaHQgKiA0KTtcclxuICAgICAgICB0aGlzLl9nbC5yZWFkUGl4ZWxzKDAsIDAsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQsIHRoaXMuX2dsLlJHQkEsIHRoaXMuX2dsLlVOU0lHTkVEX0JZVEUsIHBpeGVsRGF0YSk7XHJcbiAgICAgICAgaW1hZ2UuZGF0YS5zZXQocGl4ZWxEYXRhKTtcclxuICAgICAgICBvdXQucHV0SW1hZ2VEYXRhKGltYWdlLCAwLCAwKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0RlYnVnL0RlYnVnRmxhZ3MudHNcblxyXG5jbGFzcyBDb2xvckJsaW5kRmxhZ3Mge1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lKSB7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgfVxyXG4gICAgY29ycmVjdChjb2xvckJsaW5kbmVzcykge1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZS5wb3N0UHJvY2Vzc29ycy5wdXNoKG5ldyBDb2xvckJsaW5kQ29ycmVjdG9yKHRoaXMuX2VuZ2luZSwgZmFsc2UsIGNvbG9yQmxpbmRuZXNzKSk7XHJcbiAgICB9XHJcbiAgICBzaW11bGF0ZShjb2xvckJsaW5kbmVzcykge1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZS5wb3N0UHJvY2Vzc29ycy5wdXNoKG5ldyBDb2xvckJsaW5kQ29ycmVjdG9yKHRoaXMuX2VuZ2luZSwgdHJ1ZSwgY29sb3JCbGluZG5lc3MpKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0RlYnVnL0RlYnVnLnRzXG5cclxuXHJcbi8qKlxyXG4gKiBEZWJ1ZyBzdGF0aXN0aWNzIGFuZCBmbGFncyBmb3IgRXhjYWxpYnVyLiBJZiBwb2xsaW5nIHRoZXNlIHZhbHVlcywgaXQgd291bGQgYmVcclxuICogYmVzdCB0byBkbyBzbyBvbiB0aGUgYHBvc3R1cGRhdGVgIGV2ZW50IGZvciBbW0VuZ2luZV1dLCBhZnRlciBhbGwgdmFsdWVzIGhhdmUgYmVlblxyXG4gKiB1cGRhdGVkIGR1cmluZyBhIGZyYW1lLlxyXG4gKi9cclxuY2xhc3MgRGVidWcge1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUGVyZm9ybWFuY2Ugc3RhdGlzdGljc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhdHMgPSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBDdXJyZW50IGZyYW1lIHN0YXRpc3RpY3MuIEVuZ2luZSByZXVzZXMgdGhpcyBpbnN0YW5jZSwgdXNlIFtbRnJhbWVTdGF0cy5jbG9uZV1dIHRvIGNvcHkgZnJhbWUgc3RhdHMuXHJcbiAgICAgICAgICAgICAqIEJlc3QgYWNjZXNzZWQgb24gW1twb3N0ZnJhbWVdXSBldmVudC4gU2VlIFtbRnJhbWVTdGF0c11dXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBjdXJyRnJhbWU6IG5ldyBGcmFtZVN0YXRzKCksXHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBQcmV2aW91cyBmcmFtZSBzdGF0aXN0aWNzLiBFbmdpbmUgcmV1c2VzIHRoaXMgaW5zdGFuY2UsIHVzZSBbW0ZyYW1lU3RhdHMuY2xvbmVdXSB0byBjb3B5IGZyYW1lIHN0YXRzLlxyXG4gICAgICAgICAgICAgKiBCZXN0IGFjY2Vzc2VkIG9uIFtbcHJlZnJhbWVdXSBldmVudC4gQmVzdCBpbnNwZWN0ZWQgb24gZW5naW5lIGV2ZW50IGBwcmVmcmFtZWAuIFNlZSBbW0ZyYW1lU3RhdHNdXVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgcHJldkZyYW1lOiBuZXcgRnJhbWVTdGF0cygpXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGaWx0ZXIgZGVidWcgY29udGV4dCB0byBuYW1lZCBlbnRpdGllcyBvciBlbnRpdHkgaWRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maWx0ZXIgPSB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBUb2dnbGUgZmlsdGVyIG9uIG9yIG9mZiAoZGVmYXVsdCBvZmYpIG11c3QgYmUgb24gZm9yIERlYnVnRHJhdyB0byB1c2UgZmlsdGVyc1xyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdXNlRmlsdGVyOiBmYWxzZSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFF1ZXJ5IGZvciBlbnRpdGllcyBieSBuYW1lLCBpZiB0aGUgZW50aXR5IG5hbWUgY29udGFpbnMgYG5hbWVRdWVyeWAgaXQgd2lsbCBiZSBpbmNsdWRlZFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgbmFtZVF1ZXJ5OiAnJyxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFF1ZXJ5IGZvciBFbnRpdHkgaWRzLCBpZiB0aGUgaWQgbWF0Y2hlcyBpdCB3aWxsIGJlIGluY2x1ZGVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBpZHM6IFtdXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBFbnRpdHkgZGVidWcgc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVudGl0eSA9IHtcclxuICAgICAgICAgICAgc2hvd0FsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dJZDogdHJ1ZSxcclxuICAgICAgICAgICAgc2hvd05hbWU6IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUcmFuc2Zvcm0gY29tcG9uZW50IGRlYnVnIHNldHRpbmdzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB7XHJcbiAgICAgICAgICAgIHNob3dBbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93UG9zaXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgICBwb3NpdGlvbkNvbG9yOiBDb2xvci5ZZWxsb3csXHJcbiAgICAgICAgICAgIHNob3dTY2FsZTogZmFsc2UsXHJcbiAgICAgICAgICAgIHNjYWxlQ29sb3I6IENvbG9yLkdyZWVuLFxyXG4gICAgICAgICAgICBzaG93Um90YXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgICByb3RhdGlvbkNvbG9yOiBDb2xvci5CbHVlXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHcmFwaGljcyBjb21wb25lbnQgZGVidWcgc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdyYXBoaWNzID0ge1xyXG4gICAgICAgICAgICBzaG93QWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0JvdW5kczogdHJ1ZSxcclxuICAgICAgICAgICAgYm91bmRzQ29sb3I6IENvbG9yLlllbGxvd1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29sbGlkZXIgY29tcG9uZW50IGRlYnVnIHNldHRpbmdzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb2xsaWRlciA9IHtcclxuICAgICAgICAgICAgc2hvd0FsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dCb3VuZHM6IHRydWUsXHJcbiAgICAgICAgICAgIGJvdW5kc0NvbG9yOiBDb2xvci5CbHVlLFxyXG4gICAgICAgICAgICBzaG93T3duZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93R2VvbWV0cnk6IHRydWUsXHJcbiAgICAgICAgICAgIGdlb21ldHJ5Q29sb3I6IENvbG9yLkdyZWVuXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQaHlzaWNzIHNpbXVsYXRpb24gZGVidWcgc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBoeXNpY3MgPSB7XHJcbiAgICAgICAgICAgIHNob3dBbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93QnJvYWRwaGFzZVNwYWNlUGFydGl0aW9uRGVidWc6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93Q29sbGlzaW9uTm9ybWFsczogZmFsc2UsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbk5vcm1hbENvbG9yOiBDb2xvci5DeWFuLFxyXG4gICAgICAgICAgICBzaG93Q29sbGlzaW9uQ29udGFjdHM6IHRydWUsXHJcbiAgICAgICAgICAgIGNvbGxpc2lvbkNvbnRhY3RDb2xvcjogQ29sb3IuUmVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNb3Rpb24gY29tcG9uZW50IGRlYnVnIHNldHRpbmdzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tb3Rpb24gPSB7XHJcbiAgICAgICAgICAgIHNob3dBbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93VmVsb2NpdHk6IGZhbHNlLFxyXG4gICAgICAgICAgICB2ZWxvY2l0eUNvbG9yOiBDb2xvci5ZZWxsb3csXHJcbiAgICAgICAgICAgIHNob3dBY2NlbGVyYXRpb246IGZhbHNlLFxyXG4gICAgICAgICAgICBhY2NlbGVyYXRpb25Db2xvcjogQ29sb3IuUmVkXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCb2R5IGNvbXBvbmVudCBkZWJ1ZyBzZXR0aW5nc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYm9keSA9IHtcclxuICAgICAgICAgICAgc2hvd0FsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dDb2xsaXNpb25Hcm91cDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dDb2xsaXNpb25UeXBlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd1NsZWVwaW5nOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd01vdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dNYXNzOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2FtZXJhIGRlYnVnIHNldHRpbmdzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jYW1lcmEgPSB7XHJcbiAgICAgICAgICAgIHNob3dBbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93Rm9jdXM6IGZhbHNlLFxyXG4gICAgICAgICAgICBmb2N1c0NvbG9yOiBDb2xvci5SZWQsXHJcbiAgICAgICAgICAgIHNob3dab29tOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuY29sb3JCbGluZE1vZGUgPSBuZXcgQ29sb3JCbGluZEZsYWdzKHRoaXMuX2VuZ2luZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgZnJhbWUncyBzdGF0cy4gTWVhbnQgdG8gaGF2ZSB2YWx1ZXMgY29waWVkIHZpYSBbW0ZyYW1lU3RhdHMucmVzZXRdXSwgYXZvaWRcclxuICogY3JlYXRpbmcgaW5zdGFuY2VzIG9mIHRoaXMgZXZlcnkgZnJhbWUuXHJcbiAqL1xyXG5jbGFzcyBGcmFtZVN0YXRzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2lkID0gMDtcclxuICAgICAgICB0aGlzLl9kZWx0YSA9IDA7XHJcbiAgICAgICAgdGhpcy5fZnBzID0gMDtcclxuICAgICAgICB0aGlzLl9hY3RvclN0YXRzID0ge1xyXG4gICAgICAgICAgICBhbGl2ZTogMCxcclxuICAgICAgICAgICAga2lsbGVkOiAwLFxyXG4gICAgICAgICAgICB1aTogMCxcclxuICAgICAgICAgICAgZ2V0IHJlbWFpbmluZygpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFsaXZlIC0gdGhpcy5raWxsZWQ7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCB0b3RhbCgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbWFpbmluZyArIHRoaXMudWk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uU3RhdHMgPSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZTogMCxcclxuICAgICAgICAgICAgZHJhdzogMCxcclxuICAgICAgICAgICAgZ2V0IHRvdGFsKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlICsgdGhpcy5kcmF3O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9waHlzaWNzU3RhdHMgPSBuZXcgUGh5c2ljc1N0YXRzKCk7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NTdGF0cyA9IHtcclxuICAgICAgICAgICAgZHJhd0NhbGxzOiAwLFxyXG4gICAgICAgICAgICBkcmF3bkltYWdlczogMFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFplcm8gb3V0IHZhbHVlcyBvciBjbG9uZSBvdGhlciBJRnJhbWVTdGF0IHN0YXRzLiBBbGxvd3MgaW5zdGFuY2UgcmV1c2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIFtvdGhlclN0YXRzXSBPcHRpb25hbCBzdGF0cyB0byBjbG9uZVxyXG4gICAgICovXHJcbiAgICByZXNldChvdGhlclN0YXRzKSB7XHJcbiAgICAgICAgaWYgKG90aGVyU3RhdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IG90aGVyU3RhdHMuaWQ7XHJcbiAgICAgICAgICAgIHRoaXMuZGVsdGEgPSBvdGhlclN0YXRzLmRlbHRhO1xyXG4gICAgICAgICAgICB0aGlzLmZwcyA9IG90aGVyU3RhdHMuZnBzO1xyXG4gICAgICAgICAgICB0aGlzLmFjdG9ycy5hbGl2ZSA9IG90aGVyU3RhdHMuYWN0b3JzLmFsaXZlO1xyXG4gICAgICAgICAgICB0aGlzLmFjdG9ycy5raWxsZWQgPSBvdGhlclN0YXRzLmFjdG9ycy5raWxsZWQ7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzLnVpID0gb3RoZXJTdGF0cy5hY3RvcnMudWk7XHJcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24udXBkYXRlID0gb3RoZXJTdGF0cy5kdXJhdGlvbi51cGRhdGU7XHJcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24uZHJhdyA9IG90aGVyU3RhdHMuZHVyYXRpb24uZHJhdztcclxuICAgICAgICAgICAgdGhpcy5fcGh5c2ljc1N0YXRzLnJlc2V0KG90aGVyU3RhdHMucGh5c2ljcyk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd0NhbGxzID0gb3RoZXJTdGF0cy5ncmFwaGljcy5kcmF3Q2FsbHM7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd25JbWFnZXMgPSBvdGhlclN0YXRzLmdyYXBoaWNzLmRyYXduSW1hZ2VzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5pZCA9IHRoaXMuZGVsdGEgPSB0aGlzLmZwcyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzLmFsaXZlID0gdGhpcy5hY3RvcnMua2lsbGVkID0gdGhpcy5hY3RvcnMudWkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmR1cmF0aW9uLnVwZGF0ZSA9IHRoaXMuZHVyYXRpb24uZHJhdyA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3BoeXNpY3NTdGF0cy5yZXNldCgpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLmRyYXduSW1hZ2VzID0gdGhpcy5ncmFwaGljcy5kcmF3Q2FsbHMgPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBjb25zdCBmcyA9IG5ldyBGcmFtZVN0YXRzKCk7XHJcbiAgICAgICAgZnMucmVzZXQodGhpcyk7XHJcbiAgICAgICAgcmV0dXJuIGZzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGlkXHJcbiAgICAgKi9cclxuICAgIGdldCBpZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGZyYW1lJ3MgaWRcclxuICAgICAqL1xyXG4gICAgc2V0IGlkKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5faWQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZnJhbWUncyBkZWx0YSAodGltZSBzaW5jZSBsYXN0IGZyYW1lKVxyXG4gICAgICovXHJcbiAgICBnZXQgZGVsdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlbHRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBmcmFtZSdzIGRlbHRhICh0aW1lIHNpbmNlIGxhc3QgZnJhbWUpLiBJbnRlcm5hbCB1c2Ugb25seS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzZXQgZGVsdGEodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9kZWx0YSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGZyYW1lcy1wZXItc2Vjb25kIChGUFMpXHJcbiAgICAgKi9cclxuICAgIGdldCBmcHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZwcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZnJhbWUncyBmcmFtZXMtcGVyLXNlY29uZCAoRlBTKS4gSW50ZXJuYWwgdXNlIG9ubHkuXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgc2V0IGZwcyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2ZwcyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGFjdG9yIHN0YXRpc3RpY3NcclxuICAgICAqL1xyXG4gICAgZ2V0IGFjdG9ycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0b3JTdGF0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZnJhbWUncyBkdXJhdGlvbiBzdGF0aXN0aWNzXHJcbiAgICAgKi9cclxuICAgIGdldCBkdXJhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZHVyYXRpb25TdGF0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZnJhbWUncyBwaHlzaWNzIHN0YXRpc3RpY3NcclxuICAgICAqL1xyXG4gICAgZ2V0IHBoeXNpY3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BoeXNpY3NTdGF0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZnJhbWUncyBncmFwaGljcyBzdGF0aXN0aWNzXHJcbiAgICAgKi9cclxuICAgIGdldCBncmFwaGljcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY3NTdGF0cztcclxuICAgIH1cclxufVxyXG5jbGFzcyBQaHlzaWNzU3RhdHMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fcGFpcnMgPSAwO1xyXG4gICAgICAgIHRoaXMuX2NvbGxpc2lvbnMgPSAwO1xyXG4gICAgICAgIHRoaXMuX2NvbnRhY3RzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2Zhc3RCb2RpZXMgPSAwO1xyXG4gICAgICAgIHRoaXMuX2Zhc3RCb2R5Q29sbGlzaW9ucyA9IDA7XHJcbiAgICAgICAgdGhpcy5fYnJvYWRwaGFzZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fbmFycm93cGhhc2UgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBaZXJvIG91dCB2YWx1ZXMgb3IgY2xvbmUgb3RoZXIgSVBoeXNpY3NTdGF0cyBzdGF0cy4gQWxsb3dzIGluc3RhbmNlIHJldXNlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBbb3RoZXJTdGF0c10gT3B0aW9uYWwgc3RhdHMgdG8gY2xvbmVcclxuICAgICAqL1xyXG4gICAgcmVzZXQob3RoZXJTdGF0cykge1xyXG4gICAgICAgIGlmIChvdGhlclN0YXRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFpcnMgPSBvdGhlclN0YXRzLnBhaXJzO1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvbnMgPSBvdGhlclN0YXRzLmNvbGxpc2lvbnM7XHJcbiAgICAgICAgICAgIHRoaXMuY29udGFjdHMgPSBvdGhlclN0YXRzLmNvbnRhY3RzO1xyXG4gICAgICAgICAgICB0aGlzLmZhc3RCb2RpZXMgPSBvdGhlclN0YXRzLmZhc3RCb2RpZXM7XHJcbiAgICAgICAgICAgIHRoaXMuZmFzdEJvZHlDb2xsaXNpb25zID0gb3RoZXJTdGF0cy5mYXN0Qm9keUNvbGxpc2lvbnM7XHJcbiAgICAgICAgICAgIHRoaXMuYnJvYWRwaGFzZSA9IG90aGVyU3RhdHMuYnJvYWRwaGFzZTtcclxuICAgICAgICAgICAgdGhpcy5uYXJyb3dwaGFzZSA9IG90aGVyU3RhdHMubmFycm93cGhhc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBhaXJzID0gdGhpcy5jb2xsaXNpb25zID0gdGhpcy5mYXN0Qm9kaWVzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5mYXN0Qm9keUNvbGxpc2lvbnMgPSB0aGlzLmJyb2FkcGhhc2UgPSB0aGlzLm5hcnJvd3BoYXNlID0gMDtcclxuICAgICAgICAgICAgdGhpcy5jb250YWN0cy5jbGVhcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvdmlkZXMgYSBjbG9uZSBvZiB0aGlzIGluc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBjb25zdCBwcyA9IG5ldyBQaHlzaWNzU3RhdHMoKTtcclxuICAgICAgICBwcy5yZXNldCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gcHM7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFpcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhaXJzO1xyXG4gICAgfVxyXG4gICAgc2V0IHBhaXJzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcGFpcnMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBjb2xsaXNpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsaXNpb25zO1xyXG4gICAgfVxyXG4gICAgc2V0IGNvbGxpc2lvbnModmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9jb2xsaXNpb25zID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgY29udGFjdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhY3RzO1xyXG4gICAgfVxyXG4gICAgc2V0IGNvbnRhY3RzKGNvbnRhY3RzKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGFjdHMgPSBjb250YWN0cztcclxuICAgIH1cclxuICAgIGdldCBmYXN0Qm9kaWVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mYXN0Qm9kaWVzO1xyXG4gICAgfVxyXG4gICAgc2V0IGZhc3RCb2RpZXModmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9mYXN0Qm9kaWVzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgZmFzdEJvZHlDb2xsaXNpb25zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9mYXN0Qm9keUNvbGxpc2lvbnM7XHJcbiAgICB9XHJcbiAgICBzZXQgZmFzdEJvZHlDb2xsaXNpb25zKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZmFzdEJvZHlDb2xsaXNpb25zID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgYnJvYWRwaGFzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnJvYWRwaGFzZTtcclxuICAgIH1cclxuICAgIHNldCBicm9hZHBoYXNlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fYnJvYWRwaGFzZSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IG5hcnJvd3BoYXNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYXJyb3dwaGFzZTtcclxuICAgIH1cclxuICAgIHNldCBuYXJyb3dwaGFzZSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX25hcnJvd3BoYXNlID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnB1dC9LZXlib2FyZC50c1xuXHJcblxyXG5cclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHBoeXNpY2FsIGlucHV0IGtleSBjb2Rlc1xyXG4gKi9cclxudmFyIEtleXM7XHJcbihmdW5jdGlvbiAoS2V5cykge1xyXG4gICAgLy8gTlVNUEFEXHJcbiAgICBLZXlzW1wiTnVtMFwiXSA9IFwiTnVtcGFkMFwiO1xyXG4gICAgS2V5c1tcIk51bTFcIl0gPSBcIk51bXBhZDFcIjtcclxuICAgIEtleXNbXCJOdW0yXCJdID0gXCJOdW1wYWQyXCI7XHJcbiAgICBLZXlzW1wiTnVtM1wiXSA9IFwiTnVtcGFkM1wiO1xyXG4gICAgS2V5c1tcIk51bTRcIl0gPSBcIk51bXBhZDRcIjtcclxuICAgIEtleXNbXCJOdW01XCJdID0gXCJOdW1wYWQ1XCI7XHJcbiAgICBLZXlzW1wiTnVtNlwiXSA9IFwiTnVtcGFkNlwiO1xyXG4gICAgS2V5c1tcIk51bTdcIl0gPSBcIk51bXBhZDdcIjtcclxuICAgIEtleXNbXCJOdW04XCJdID0gXCJOdW1wYWQ4XCI7XHJcbiAgICBLZXlzW1wiTnVtOVwiXSA9IFwiTnVtcGFkOVwiO1xyXG4gICAgS2V5c1tcIk51bUFkZFwiXSA9IFwiTnVtcGFkQWRkXCI7XHJcbiAgICBLZXlzW1wiTnVtU3VidHJhY3RcIl0gPSBcIk51bXBhZFN1YnRyYWN0XCI7XHJcbiAgICBLZXlzW1wiTnVtTXVsdGlwbHlcIl0gPSBcIk51bXBhZE11bHRpcGx5XCI7XHJcbiAgICBLZXlzW1wiTnVtRGl2aWRlXCJdID0gXCJOdW1wYWREaXZpZGVcIjtcclxuICAgIC8vIE51bUNvbW1hID0gJ051bXBhZENvbW1hJywgLy8gbm90IHgtYnJvd3NlclxyXG4gICAgS2V5c1tcIk51bURlY2ltYWxcIl0gPSBcIk51bXBhZERlY2ltYWxcIjtcclxuICAgIEtleXNbXCJOdW1wYWQwXCJdID0gXCJOdW1wYWQwXCI7XHJcbiAgICBLZXlzW1wiTnVtcGFkMVwiXSA9IFwiTnVtcGFkMVwiO1xyXG4gICAgS2V5c1tcIk51bXBhZDJcIl0gPSBcIk51bXBhZDJcIjtcclxuICAgIEtleXNbXCJOdW1wYWQzXCJdID0gXCJOdW1wYWQzXCI7XHJcbiAgICBLZXlzW1wiTnVtcGFkNFwiXSA9IFwiTnVtcGFkNFwiO1xyXG4gICAgS2V5c1tcIk51bXBhZDVcIl0gPSBcIk51bXBhZDVcIjtcclxuICAgIEtleXNbXCJOdW1wYWQ2XCJdID0gXCJOdW1wYWQ2XCI7XHJcbiAgICBLZXlzW1wiTnVtcGFkN1wiXSA9IFwiTnVtcGFkN1wiO1xyXG4gICAgS2V5c1tcIk51bXBhZDhcIl0gPSBcIk51bXBhZDhcIjtcclxuICAgIEtleXNbXCJOdW1wYWQ5XCJdID0gXCJOdW1wYWQ5XCI7XHJcbiAgICBLZXlzW1wiTnVtcGFkQWRkXCJdID0gXCJOdW1wYWRBZGRcIjtcclxuICAgIEtleXNbXCJOdW1wYWRTdWJ0cmFjdFwiXSA9IFwiTnVtcGFkU3VidHJhY3RcIjtcclxuICAgIEtleXNbXCJOdW1wYWRNdWx0aXBseVwiXSA9IFwiTnVtcGFkTXVsdGlwbHlcIjtcclxuICAgIEtleXNbXCJOdW1wYWREaXZpZGVcIl0gPSBcIk51bXBhZERpdmlkZVwiO1xyXG4gICAgLy8gTnVtcGFkQ29tbWEgPSAnTnVtcGFkQ29tbWEnLCAvLyBub3QgeC1icm93c2VyXHJcbiAgICBLZXlzW1wiTnVtcGFkRGVjaW1hbFwiXSA9IFwiTnVtcGFkRGVjaW1hbFwiO1xyXG4gICAgLy8gTU9ESUZJRVJTXHJcbiAgICBLZXlzW1wiTnVtTG9ja1wiXSA9IFwiTnVtTG9ja1wiO1xyXG4gICAgS2V5c1tcIlNoaWZ0TGVmdFwiXSA9IFwiU2hpZnRMZWZ0XCI7XHJcbiAgICBLZXlzW1wiU2hpZnRSaWdodFwiXSA9IFwiU2hpZnRSaWdodFwiO1xyXG4gICAgS2V5c1tcIkFsdExlZnRcIl0gPSBcIkFsdExlZnRcIjtcclxuICAgIEtleXNbXCJBbHRSaWdodFwiXSA9IFwiQWx0UmlnaHRcIjtcclxuICAgIC8vIE5VTUJFUlNcclxuICAgIEtleXNbXCJLZXkwXCJdID0gXCJEaWdpdDBcIjtcclxuICAgIEtleXNbXCJLZXkxXCJdID0gXCJEaWdpdDFcIjtcclxuICAgIEtleXNbXCJLZXkyXCJdID0gXCJEaWdpdDJcIjtcclxuICAgIEtleXNbXCJLZXkzXCJdID0gXCJEaWdpdDNcIjtcclxuICAgIEtleXNbXCJLZXk0XCJdID0gXCJEaWdpdDRcIjtcclxuICAgIEtleXNbXCJLZXk1XCJdID0gXCJEaWdpdDVcIjtcclxuICAgIEtleXNbXCJLZXk2XCJdID0gXCJEaWdpdDZcIjtcclxuICAgIEtleXNbXCJLZXk3XCJdID0gXCJEaWdpdDdcIjtcclxuICAgIEtleXNbXCJLZXk4XCJdID0gXCJEaWdpdDhcIjtcclxuICAgIEtleXNbXCJLZXk5XCJdID0gXCJEaWdpdDlcIjtcclxuICAgIEtleXNbXCJEaWdpdDBcIl0gPSBcIkRpZ2l0MFwiO1xyXG4gICAgS2V5c1tcIkRpZ2l0MVwiXSA9IFwiRGlnaXQxXCI7XHJcbiAgICBLZXlzW1wiRGlnaXQyXCJdID0gXCJEaWdpdDJcIjtcclxuICAgIEtleXNbXCJEaWdpdDNcIl0gPSBcIkRpZ2l0M1wiO1xyXG4gICAgS2V5c1tcIkRpZ2l0NFwiXSA9IFwiRGlnaXQ0XCI7XHJcbiAgICBLZXlzW1wiRGlnaXQ1XCJdID0gXCJEaWdpdDVcIjtcclxuICAgIEtleXNbXCJEaWdpdDZcIl0gPSBcIkRpZ2l0NlwiO1xyXG4gICAgS2V5c1tcIkRpZ2l0N1wiXSA9IFwiRGlnaXQ3XCI7XHJcbiAgICBLZXlzW1wiRGlnaXQ4XCJdID0gXCJEaWdpdDhcIjtcclxuICAgIEtleXNbXCJEaWdpdDlcIl0gPSBcIkRpZ2l0OVwiO1xyXG4gICAgLy8gTEVUVEVSU1xyXG4gICAgS2V5c1tcIkFcIl0gPSBcIktleUFcIjtcclxuICAgIEtleXNbXCJCXCJdID0gXCJLZXlCXCI7XHJcbiAgICBLZXlzW1wiQ1wiXSA9IFwiS2V5Q1wiO1xyXG4gICAgS2V5c1tcIkRcIl0gPSBcIktleURcIjtcclxuICAgIEtleXNbXCJFXCJdID0gXCJLZXlFXCI7XHJcbiAgICBLZXlzW1wiRlwiXSA9IFwiS2V5RlwiO1xyXG4gICAgS2V5c1tcIkdcIl0gPSBcIktleUdcIjtcclxuICAgIEtleXNbXCJIXCJdID0gXCJLZXlIXCI7XHJcbiAgICBLZXlzW1wiSVwiXSA9IFwiS2V5SVwiO1xyXG4gICAgS2V5c1tcIkpcIl0gPSBcIktleUpcIjtcclxuICAgIEtleXNbXCJLXCJdID0gXCJLZXlLXCI7XHJcbiAgICBLZXlzW1wiTFwiXSA9IFwiS2V5TFwiO1xyXG4gICAgS2V5c1tcIk1cIl0gPSBcIktleU1cIjtcclxuICAgIEtleXNbXCJOXCJdID0gXCJLZXlOXCI7XHJcbiAgICBLZXlzW1wiT1wiXSA9IFwiS2V5T1wiO1xyXG4gICAgS2V5c1tcIlBcIl0gPSBcIktleVBcIjtcclxuICAgIEtleXNbXCJRXCJdID0gXCJLZXlRXCI7XHJcbiAgICBLZXlzW1wiUlwiXSA9IFwiS2V5UlwiO1xyXG4gICAgS2V5c1tcIlNcIl0gPSBcIktleVNcIjtcclxuICAgIEtleXNbXCJUXCJdID0gXCJLZXlUXCI7XHJcbiAgICBLZXlzW1wiVVwiXSA9IFwiS2V5VVwiO1xyXG4gICAgS2V5c1tcIlZcIl0gPSBcIktleVZcIjtcclxuICAgIEtleXNbXCJXXCJdID0gXCJLZXlXXCI7XHJcbiAgICBLZXlzW1wiWFwiXSA9IFwiS2V5WFwiO1xyXG4gICAgS2V5c1tcIllcIl0gPSBcIktleVlcIjtcclxuICAgIEtleXNbXCJaXCJdID0gXCJLZXlaXCI7XHJcbiAgICBLZXlzW1wiS2V5QVwiXSA9IFwiS2V5QVwiO1xyXG4gICAgS2V5c1tcIktleUJcIl0gPSBcIktleUJcIjtcclxuICAgIEtleXNbXCJLZXlDXCJdID0gXCJLZXlDXCI7XHJcbiAgICBLZXlzW1wiS2V5RFwiXSA9IFwiS2V5RFwiO1xyXG4gICAgS2V5c1tcIktleUVcIl0gPSBcIktleUVcIjtcclxuICAgIEtleXNbXCJLZXlGXCJdID0gXCJLZXlGXCI7XHJcbiAgICBLZXlzW1wiS2V5R1wiXSA9IFwiS2V5R1wiO1xyXG4gICAgS2V5c1tcIktleUhcIl0gPSBcIktleUhcIjtcclxuICAgIEtleXNbXCJLZXlJXCJdID0gXCJLZXlJXCI7XHJcbiAgICBLZXlzW1wiS2V5SlwiXSA9IFwiS2V5SlwiO1xyXG4gICAgS2V5c1tcIktleUtcIl0gPSBcIktleUtcIjtcclxuICAgIEtleXNbXCJLZXlMXCJdID0gXCJLZXlMXCI7XHJcbiAgICBLZXlzW1wiS2V5TVwiXSA9IFwiS2V5TVwiO1xyXG4gICAgS2V5c1tcIktleU5cIl0gPSBcIktleU5cIjtcclxuICAgIEtleXNbXCJLZXlPXCJdID0gXCJLZXlPXCI7XHJcbiAgICBLZXlzW1wiS2V5UFwiXSA9IFwiS2V5UFwiO1xyXG4gICAgS2V5c1tcIktleVFcIl0gPSBcIktleVFcIjtcclxuICAgIEtleXNbXCJLZXlSXCJdID0gXCJLZXlSXCI7XHJcbiAgICBLZXlzW1wiS2V5U1wiXSA9IFwiS2V5U1wiO1xyXG4gICAgS2V5c1tcIktleVRcIl0gPSBcIktleVRcIjtcclxuICAgIEtleXNbXCJLZXlVXCJdID0gXCJLZXlVXCI7XHJcbiAgICBLZXlzW1wiS2V5VlwiXSA9IFwiS2V5VlwiO1xyXG4gICAgS2V5c1tcIktleVdcIl0gPSBcIktleVdcIjtcclxuICAgIEtleXNbXCJLZXlYXCJdID0gXCJLZXlYXCI7XHJcbiAgICBLZXlzW1wiS2V5WVwiXSA9IFwiS2V5WVwiO1xyXG4gICAgS2V5c1tcIktleVpcIl0gPSBcIktleVpcIjtcclxuICAgIC8vIFNZTUJPTFNcclxuICAgIEtleXNbXCJTZW1pY29sb25cIl0gPSBcIlNlbWljb2xvblwiO1xyXG4gICAgS2V5c1tcIlF1b3RlXCJdID0gXCJRdW90ZVwiO1xyXG4gICAgS2V5c1tcIkNvbW1hXCJdID0gXCJDb21tYVwiO1xyXG4gICAgS2V5c1tcIk1pbnVzXCJdID0gXCJNaW51c1wiO1xyXG4gICAgS2V5c1tcIlBlcmlvZFwiXSA9IFwiUGVyaW9kXCI7XHJcbiAgICBLZXlzW1wiU2xhc2hcIl0gPSBcIlNsYXNoXCI7XHJcbiAgICBLZXlzW1wiRXF1YWxcIl0gPSBcIkVxdWFsXCI7XHJcbiAgICBLZXlzW1wiQnJhY2tldExlZnRcIl0gPSBcIkJyYWNrZXRMZWZ0XCI7XHJcbiAgICBLZXlzW1wiQmFja3NsYXNoXCJdID0gXCJCYWNrc2xhc2hcIjtcclxuICAgIEtleXNbXCJCcmFja2V0UmlnaHRcIl0gPSBcIkJyYWNrZXRSaWdodFwiO1xyXG4gICAgS2V5c1tcIkJhY2txdW90ZVwiXSA9IFwiQmFja3F1b3RlXCI7XHJcbiAgICAvLyBESVJFQ1RJT05TXHJcbiAgICBLZXlzW1wiVXBcIl0gPSBcIkFycm93VXBcIjtcclxuICAgIEtleXNbXCJEb3duXCJdID0gXCJBcnJvd0Rvd25cIjtcclxuICAgIEtleXNbXCJMZWZ0XCJdID0gXCJBcnJvd0xlZnRcIjtcclxuICAgIEtleXNbXCJSaWdodFwiXSA9IFwiQXJyb3dSaWdodFwiO1xyXG4gICAgS2V5c1tcIkFycm93VXBcIl0gPSBcIkFycm93VXBcIjtcclxuICAgIEtleXNbXCJBcnJvd0Rvd25cIl0gPSBcIkFycm93RG93blwiO1xyXG4gICAgS2V5c1tcIkFycm93TGVmdFwiXSA9IFwiQXJyb3dMZWZ0XCI7XHJcbiAgICBLZXlzW1wiQXJyb3dSaWdodFwiXSA9IFwiQXJyb3dSaWdodFwiO1xyXG4gICAgLy8gT1RIRVJcclxuICAgIEtleXNbXCJTcGFjZVwiXSA9IFwiU3BhY2VcIjtcclxuICAgIEtleXNbXCJFc2NcIl0gPSBcIkVzY2FwZVwiO1xyXG4gICAgS2V5c1tcIkVzY2FwZVwiXSA9IFwiRXNjYXBlXCI7XHJcbn0pKEtleXMgfHwgKEtleXMgPSB7fSkpO1xyXG4vKipcclxuICogRXZlbnQgdGhyb3duIG9uIGEgZ2FtZSBvYmplY3QgZm9yIGEga2V5IGV2ZW50XHJcbiAqL1xyXG5jbGFzcyBLZXlFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBrZXkgIFRoZSBrZXkgcmVzcG9uc2libGUgZm9yIHRocm93aW5nIHRoZSBldmVudFxyXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSBrZXkncyB0eXBlZCB2YWx1ZSB0aGUgYnJvd3NlciBkZXRlY3RlZFxyXG4gICAgICogQHBhcmFtIG9yaWdpbmFsRXZlbnQgVGhlIG9yaWdpbmFsIGtleWJvYXJkIGV2ZW50IHRoYXQgRXhjYWxpYnVyIGhhbmRsZWRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCB2YWx1ZSwgb3JpZ2luYWxFdmVudCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFByb3ZpZGVzIGtleWJvYXJkIHN1cHBvcnQgZm9yIEV4Y2FsaWJ1ci5cclxuICovXHJcbmNsYXNzIEtleWJvYXJkIGV4dGVuZHMgQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9rZXlzID0gW107XHJcbiAgICAgICAgdGhpcy5fa2V5c1VwID0gW107XHJcbiAgICAgICAgdGhpcy5fa2V5c0Rvd24gPSBbXTtcclxuICAgIH1cclxuICAgIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgS2V5Ym9hcmQgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgKi9cclxuICAgIGluaXQoZ2xvYmFsKSB7XHJcbiAgICAgICAgaWYgKCFnbG9iYWwpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIC8vIFRyeSBhbmQgbGlzdGVuIHRvIGV2ZW50cyBvbiB0b3Agd2luZG93IGZyYW1lIGlmIHdpdGhpbiBhbiBpZnJhbWUuXHJcbiAgICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9leGNhbGlidXJqcy9FeGNhbGlidXIvaXNzdWVzLzEyOTRcclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciwgd2hpY2ggdHJpZ2dlcnMgYSBET01FeGNlcHRpb24gb25cclxuICAgICAgICAgICAgICAgIC8vIGNyb3NzLW9yaWdpbiBpZnJhbWVzXHJcbiAgICAgICAgICAgICAgICBjb25zdCBub29wID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cudG9wLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBub29wKTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy50b3AucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHdpbmRvdyBpZiBub3QgZW1iZWRkZWQgd2l0aGluIGFuIGlmcmFtZVxyXG4gICAgICAgICAgICAgICAgZ2xvYmFsID0gd2luZG93LnRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgICAgIC8vIGZhbGxiYWNrIHRvIGN1cnJlbnQgZnJhbWVcclxuICAgICAgICAgICAgICAgIGdsb2JhbCA9IHdpbmRvdztcclxuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0ZhaWxlZCB0byBiaW5kIHRvIGtleWJvYXJkIGV2ZW50cyB0byB0b3AgZnJhbWUuICcgK1xyXG4gICAgICAgICAgICAgICAgICAgICdJZiB5b3UgYXJlIHRyeWluZyB0byBlbWJlZCBFeGNhbGlidXIgaW4gYSBjcm9zcy1vcmlnaW4gaWZyYW1lLCBrZXlib2FyZCBldmVudHMgd2lsbCBub3QgZmlyZS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fa2V5cy5sZW5ndGggPSAwOyAvLyBlbXB0aWVzIGFycmF5IGVmZmljaWVudGx5XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8ga2V5IHVwIGlzIG9uIHdpbmRvdyBiZWNhdXNlIGNhbnZhcyBjYW5ub3QgaGF2ZSBmb2N1c1xyXG4gICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb2RlID0gZXYuY29kZTtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5fa2V5cy5pbmRleE9mKGNvZGUpO1xyXG4gICAgICAgICAgICB0aGlzLl9rZXlzLnNwbGljZShrZXksIDEpO1xyXG4gICAgICAgICAgICB0aGlzLl9rZXlzVXAucHVzaChjb2RlKTtcclxuICAgICAgICAgICAgY29uc3Qga2V5RXZlbnQgPSBuZXcgS2V5RXZlbnQoY29kZSwgZXYua2V5LCBldik7XHJcbiAgICAgICAgICAgIC8vIGFsaWFzIHRoZSBvbGQgYXBpLCB3ZSBtYXkgd2FudCB0byBkZXByZWNhdGUgdGhpcyBpbiB0aGUgZnV0dXJlXHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3VwJywga2V5RXZlbnQpO1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdyZWxlYXNlJywga2V5RXZlbnQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIGtleSBkb3duIGlzIG9uIHdpbmRvdyBiZWNhdXNlIGNhbnZhcyBjYW5ub3QgaGF2ZSBmb2N1c1xyXG4gICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBldi5jb2RlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fa2V5cy5pbmRleE9mKGNvZGUpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5cy5wdXNoKGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5c0Rvd24ucHVzaChjb2RlKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGtleUV2ZW50ID0gbmV3IEtleUV2ZW50KGNvZGUsIGV2LmtleSwgZXYpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnZG93bicsIGtleUV2ZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3ByZXNzJywga2V5RXZlbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgLy8gUmVzZXQga2V5c0Rvd24gYW5kIGtleXNVcCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGVcclxuICAgICAgICB0aGlzLl9rZXlzRG93bi5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX2tleXNVcC5sZW5ndGggPSAwO1xyXG4gICAgICAgIC8vIEVtaXQgc3ludGhldGljIFwiaG9sZFwiIGV2ZW50XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9rZXlzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2hvbGQnLCBuZXcgS2V5RXZlbnQodGhpcy5fa2V5c1tpXSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBsaXN0IG9mIGtleXMgYmVpbmcgcHJlc3NlZCBkb3duXHJcbiAgICAgKi9cclxuICAgIGdldEtleXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgY2VydGFpbiBrZXkgd2FzIGp1c3QgcHJlc3NlZCB0aGlzIGZyYW1lLiBUaGlzIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiB0aGUgdXBkYXRlIGZyYW1lLlxyXG4gICAgICogQHBhcmFtIGtleSBUZXN0IHdoZXRoZXIgYSBrZXkgd2FzIGp1c3QgcHJlc3NlZFxyXG4gICAgICovXHJcbiAgICB3YXNQcmVzc2VkKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlzRG93bi5pbmRleE9mKGtleSkgPiAtMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgYSBjZXJ0YWluIGtleSBpcyBoZWxkIGRvd24uIFRoaXMgaXMgcGVyc2lzdGVkIGJldHdlZW4gZnJhbWVzLlxyXG4gICAgICogQHBhcmFtIGtleSAgVGVzdCB3aGV0aGVyIGEga2V5IGlzIGhlbGQgZG93blxyXG4gICAgICovXHJcbiAgICBpc0hlbGQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleXMuaW5kZXhPZihrZXkpID4gLTE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgY2VydGFpbiBrZXkgd2FzIGp1c3QgcmVsZWFzZWQgdGhpcyBmcmFtZS4gVGhpcyBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgdGhlIHVwZGF0ZSBmcmFtZS5cclxuICAgICAqIEBwYXJhbSBrZXkgIFRlc3Qgd2hldGhlciBhIGtleSB3YXMganVzdCByZWxlYXNlZFxyXG4gICAgICovXHJcbiAgICB3YXNSZWxlYXNlZChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5c1VwLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vSW5wdXQvUG9pbnRlci50c1xuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgdHlwZSBvZiBwb2ludGVyIGZvciBhIFtbUG9pbnRlckV2ZW50XV0uXHJcbiAqL1xyXG52YXIgUG9pbnRlclR5cGU7XHJcbihmdW5jdGlvbiAoUG9pbnRlclR5cGUpIHtcclxuICAgIFBvaW50ZXJUeXBlW1wiVG91Y2hcIl0gPSBcIlRvdWNoXCI7XHJcbiAgICBQb2ludGVyVHlwZVtcIk1vdXNlXCJdID0gXCJNb3VzZVwiO1xyXG4gICAgUG9pbnRlclR5cGVbXCJQZW5cIl0gPSBcIlBlblwiO1xyXG4gICAgUG9pbnRlclR5cGVbXCJVbmtub3duXCJdID0gXCJVbmtub3duXCI7XHJcbn0pKFBvaW50ZXJUeXBlIHx8IChQb2ludGVyVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHRoZSBzY29wZSBvZiBoYW5kbGluZyBtb3VzZS90b3VjaCBldmVudHMuIFNlZSBbW1BvaW50ZXJzXV0gZm9yIG1vcmUgaW5mb3JtYXRpb24uXHJcbiAqL1xyXG52YXIgUG9pbnRlclNjb3BlO1xyXG4oZnVuY3Rpb24gKFBvaW50ZXJTY29wZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgZXZlbnRzIG9uIHRoZSBgY2FudmFzYCBlbGVtZW50IG9ubHkuIEV2ZW50cyBvcmlnaW5hdGluZyBvdXRzaWRlIHRoZVxyXG4gICAgICogYGNhbnZhc2Agd2lsbCBub3QgYmUgaGFuZGxlZC5cclxuICAgICAqL1xyXG4gICAgUG9pbnRlclNjb3BlW1wiQ2FudmFzXCJdID0gXCJDYW52YXNcIjtcclxuICAgIC8qKlxyXG4gICAgICogSGFuZGxlcyBldmVudHMgb24gdGhlIGVudGlyZSBkb2N1bWVudC4gQWxsIGV2ZW50cyB3aWxsIGJlIGhhbmRsZWQgYnkgRXhjYWxpYnVyLlxyXG4gICAgICovXHJcbiAgICBQb2ludGVyU2NvcGVbXCJEb2N1bWVudFwiXSA9IFwiRG9jdW1lbnRcIjtcclxufSkoUG9pbnRlclNjb3BlIHx8IChQb2ludGVyU2NvcGUgPSB7fSkpO1xyXG4vKipcclxuICogQ2FwdHVyZXMgYW5kIGRpc3BhdGNoZXMgUG9pbnRlckV2ZW50c1xyXG4gKi9cclxuY2xhc3MgUG9pbnRlciBleHRlbmRzIENsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5pZCA9IFBvaW50ZXIuX01BWF9JRCsrO1xyXG4gICAgICAgIHRoaXMuX2lzRG93biA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3dhc0Rvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9hY3RvcnNVbmRlclBvaW50ZXIgPSB7IGxlbmd0aDogMCB9O1xyXG4gICAgICAgIHRoaXMuX2FjdG9ycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FjdG9yc0xhc3RGcmFtZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FjdG9yc05vTG9uZ2VyVW5kZXJQb2ludGVyID0gW107XHJcbiAgICAgICAgdGhpcy5fYWN0b3JTb3J0aW5nRmNuID0gKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGEueiA9PT0gYi56KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYi5pZCAtIGEuaWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGIueiAtIGEuejtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsYXN0IHBvc2l0aW9uIG9uIHRoZSBkb2N1bWVudCB0aGlzIHBvaW50ZXIgd2FzIGF0LiBDYW4gYmUgYG51bGxgIGlmIHBvaW50ZXIgd2FzIG5ldmVyIGFjdGl2ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxhc3RQYWdlUG9zID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGFzdCBwb3NpdGlvbiBvbiB0aGUgc2NyZWVuIHRoaXMgcG9pbnRlciB3YXMgYXQuIENhbiBiZSBgbnVsbGAgaWYgcG9pbnRlciB3YXMgbmV2ZXIgYWN0aXZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGFzdFNjcmVlblBvcyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxhc3QgcG9zaXRpb24gaW4gdGhlIGdhbWUgd29ybGQgY29vcmRpbmF0ZXMgdGhpcyBwb2ludGVyIHdhcyBhdC4gQ2FuIGJlIGBudWxsYCBpZiBwb2ludGVyIHdhcyBuZXZlciBhY3RpdmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sYXN0V29ybGRQb3MgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBkcmFnZ2luZyB0YXJnZXQgb3IgbnVsbCBpZiBpdCBpc24ndCBleGlzdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZHJhZ1RhcmdldCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5vbignbW92ZScsIHRoaXMuX29uUG9pbnRlck1vdmUpO1xyXG4gICAgICAgIHRoaXMub24oJ2Rvd24nLCB0aGlzLl9vblBvaW50ZXJEb3duKTtcclxuICAgICAgICB0aGlzLm9uKCd1cCcsIHRoaXMuX29uUG9pbnRlclVwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgUG9pbnRlciBpcyBjdXJyZW50bHkgZHJhZ2dpbmcuXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0RyYWdnaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Rvd247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhlIFBvaW50ZXIganVzdCBzdGFydGVkIGRyYWdnaW5nLlxyXG4gICAgICovXHJcbiAgICBnZXQgaXNEcmFnU3RhcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLl93YXNEb3duICYmIHRoaXMuX2lzRG93bjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgUG9pbnRlciBqdXN0IGVuZGVkIGRyYWdnaW5nLlxyXG4gICAgICovXHJcbiAgICBnZXQgaXNEcmFnRW5kKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl93YXNEb3duICYmICF0aGlzLl9pc0Rvd247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBwb2ludGVyIGhhcyBhbnkgYWN0b3JzIHVuZGVyXHJcbiAgICAgKi9cclxuICAgIGdldCBoYXNBY3RvcnNVbmRlclBvaW50ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fYWN0b3JzVW5kZXJQb2ludGVyLmxlbmd0aDtcclxuICAgIH1cclxuICAgIG9uKGV2ZW50LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub24oZXZlbnQsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb25jZShldmVudCwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9uY2UoZXZlbnQsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50LCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBzdGF0ZSBvZiBjdXJyZW50IHBvaW50ZXIsIG1lYW50IHRvIGJlIGNhbGxlZCBhIHRoZSBlbmQgb2YgZnJhbWVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl93YXNEb3duICYmICF0aGlzLl9pc0Rvd24pIHtcclxuICAgICAgICAgICAgdGhpcy5fd2FzRG93biA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghdGhpcy5fd2FzRG93biAmJiB0aGlzLl9pc0Rvd24pIHtcclxuICAgICAgICAgICAgdGhpcy5fd2FzRG93biA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2FjdG9yc0xhc3RGcmFtZSA9IFsuLi50aGlzLl9hY3RvcnNdO1xyXG4gICAgICAgIHRoaXMuX2FjdG9yc05vTG9uZ2VyVW5kZXJQb2ludGVyID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gQWN0b3IgdG8gYWN0b3JzVW5kZXJQb2ludGVyIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBhY3RvciBBbiBBY3RvciB0byBiZSBhZGRlZDtcclxuICAgICAqL1xyXG4gICAgYWRkQWN0b3JVbmRlclBvaW50ZXIoYWN0b3IpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNBY3RvckFsaXZlVW5kZXJQb2ludGVyKGFjdG9yKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvcnNVbmRlclBvaW50ZXJbYWN0b3IuaWRdID0gYWN0b3I7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yc1VuZGVyUG9pbnRlci5sZW5ndGggKz0gMTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3JzLnB1c2goYWN0b3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBBY3RvcnMgYXJlIHByb2Nlc3NlZCBpbiB6LW9yZGVyIGhpZ2hlc3QgeiB0byBsb3dlc3RcclxuICAgICAgICAvLyB0aWVzIGFyZSBicm9rZW4gYnkgaWQgaGlnaGVzdCBpZCAobmV3ZXN0KSB0byBsb3dlc3QgaWQgKG9sZGVzdClcclxuICAgICAgICB0aGlzLl9hY3RvcnMuc29ydCh0aGlzLl9hY3RvclNvcnRpbmdGY24pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFuIEFjdG9yIGZyb20gYWN0b3JzVW5kZXJQb2ludGVyIG9iamVjdC5cclxuICAgICAqIEBwYXJhbSBhY3RvciBBbiBBY3RvciB0byBiZSByZW1vdmVkO1xyXG4gICAgICovXHJcbiAgICByZW1vdmVBY3RvclVuZGVyUG9pbnRlcihhY3Rvcikge1xyXG4gICAgICAgIGlmICh0aGlzLmlzQWN0b3JBbGl2ZVVuZGVyUG9pbnRlcihhY3RvcikpIHtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2FjdG9yc1VuZGVyUG9pbnRlclthY3Rvci5pZF07XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yc1VuZGVyUG9pbnRlci5sZW5ndGggLT0gMTtcclxuICAgICAgICAgICAgcmVtb3ZlSXRlbUZyb21BcnJheShhY3RvciwgdGhpcy5fYWN0b3JzKTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3JzTm9Mb25nZXJVbmRlclBvaW50ZXIucHVzaChhY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBhY3RvcnMgdW5kZXIgdGhpcyBwb2ludGVyIHRoaXMgZnJhbWVcclxuICAgICAqL1xyXG4gICAgZ2V0QWN0b3JzVW5kZXJQb2ludGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RvcnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIGFjdG9ycyB0aGF0IGFyZSBubyBsb25nZXIgdW5kZXIgdGhlIHBvaW50ZXIgdGhpcyBmcmFtZVxyXG4gICAgICovXHJcbiAgICBnZXRBY3RvcnNVbmRlclBvaW50ZXJMYXN0RnJhbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdG9yc0xhc3RGcmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgYWN0b3JzIHJlbGV2YW50IGZvciBldmVudHMgdG8gcG9pbnRlciB0aGlzIGZyYW1lXHJcbiAgICAgKi9cclxuICAgIGdldEFjdG9yc0ZvckV2ZW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0b3JzXHJcbiAgICAgICAgICAgIC5jb25jYXQodGhpcy5fYWN0b3JzTGFzdEZyYW1lKVxyXG4gICAgICAgICAgICAuZmlsdGVyKChhY3RvciwgaSwgc2VsZikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5pbmRleE9mKGFjdG9yKSA9PT0gaTsgLy8gZGUtZHVwXHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLnNvcnQodGhpcy5fYWN0b3JTb3J0aW5nRmNuKTsgLy8gc29ydCBieSB6XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBQb2ludGVyIGxvY2F0aW9uIGhhcyBhIHNwZWNpZmljIEFjdG9yIGJvdW5kcyBjb250YWluZWQgdW5kZXJuZWF0aC5cclxuICAgICAqIEBwYXJhbSBhY3RvciBBbiBBY3RvciBmb3IgY2hlY2s7XHJcbiAgICAgKi9cclxuICAgIGNoZWNrQWN0b3JVbmRlclBvaW50ZXIoYWN0b3IpIHtcclxuICAgICAgICBpZiAodGhpcy5sYXN0V29ybGRQb3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFjdG9yLmNvbnRhaW5zKHRoaXMubGFzdFdvcmxkUG9zLngsIHRoaXMubGFzdFdvcmxkUG9zLnksICFpc1NjcmVlbkVsZW1lbnQoYWN0b3IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgYW4gYWN0b3Igd2FzIHVuZGVyIHRoZSBwb2ludGVyIGxhc3QgZnJhbWVcclxuICAgICAqIEBwYXJhbSBhY3RvclxyXG4gICAgICovXHJcbiAgICB3YXNBY3RvclVuZGVyUG9pbnRlcihhY3Rvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RvcnNMYXN0RnJhbWUuaW5kZXhPZihhY3RvcikgPiAtMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIFBvaW50ZXIgaGFzIGEgc3BlY2lmaWMgQWN0b3IgaW4gQWN0b3JzVW5kZXJQb2ludGVyIGxpc3QuXHJcbiAgICAgKiBAcGFyYW0gYWN0b3IgQW4gQWN0b3IgZm9yIGNoZWNrO1xyXG4gICAgICovXHJcbiAgICBpc0FjdG9yQWxpdmVVbmRlclBvaW50ZXIoYWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gISEoIWFjdG9yLmlzS2lsbGVkKCkgJiYgYWN0b3Iuc2NlbmUgJiYgdGhpcy5fYWN0b3JzVW5kZXJQb2ludGVyLmhhc093blByb3BlcnR5KGFjdG9yLmlkLnRvU3RyaW5nKCkpKTtcclxuICAgIH1cclxuICAgIF9vblBvaW50ZXJNb3ZlKGV2KSB7XHJcbiAgICAgICAgdGhpcy5sYXN0UGFnZVBvcyA9IG5ldyBWZWN0b3IoZXYucGFnZVBvcy54LCBldi5wYWdlUG9zLnkpO1xyXG4gICAgICAgIHRoaXMubGFzdFNjcmVlblBvcyA9IG5ldyBWZWN0b3IoZXYuc2NyZWVuUG9zLngsIGV2LnNjcmVlblBvcy55KTtcclxuICAgICAgICB0aGlzLmxhc3RXb3JsZFBvcyA9IG5ldyBWZWN0b3IoZXYud29ybGRQb3MueCwgZXYud29ybGRQb3MueSk7XHJcbiAgICB9XHJcbiAgICBfb25Qb2ludGVyRG93bihldikge1xyXG4gICAgICAgIHRoaXMubGFzdFBhZ2VQb3MgPSBuZXcgVmVjdG9yKGV2LnBhZ2VQb3MueCwgZXYucGFnZVBvcy55KTtcclxuICAgICAgICB0aGlzLmxhc3RTY3JlZW5Qb3MgPSBuZXcgVmVjdG9yKGV2LnNjcmVlblBvcy54LCBldi5zY3JlZW5Qb3MueSk7XHJcbiAgICAgICAgdGhpcy5sYXN0V29ybGRQb3MgPSBuZXcgVmVjdG9yKGV2LndvcmxkUG9zLngsIGV2LndvcmxkUG9zLnkpO1xyXG4gICAgICAgIHRoaXMuX2lzRG93biA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBfb25Qb2ludGVyVXAoX2V2KSB7XHJcbiAgICAgICAgdGhpcy5faXNEb3duID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kcmFnVGFyZ2V0ID0gbnVsbDtcclxuICAgIH1cclxufVxyXG5Qb2ludGVyLl9NQVhfSUQgPSAwO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lucHV0L1BvaW50ZXJFdmVudHMudHNcblxyXG4vKipcclxuICogTmF0aXZlIGJyb3dzZXIgYnV0dG9uIGVudW1lcmF0aW9uXHJcbiAqL1xyXG52YXIgTmF0aXZlUG9pbnRlckJ1dHRvbjtcclxuKGZ1bmN0aW9uIChOYXRpdmVQb2ludGVyQnV0dG9uKSB7XHJcbiAgICBOYXRpdmVQb2ludGVyQnV0dG9uW05hdGl2ZVBvaW50ZXJCdXR0b25bXCJOb0J1dHRvblwiXSA9IC0xXSA9IFwiTm9CdXR0b25cIjtcclxuICAgIE5hdGl2ZVBvaW50ZXJCdXR0b25bTmF0aXZlUG9pbnRlckJ1dHRvbltcIkxlZnRcIl0gPSAwXSA9IFwiTGVmdFwiO1xyXG4gICAgTmF0aXZlUG9pbnRlckJ1dHRvbltOYXRpdmVQb2ludGVyQnV0dG9uW1wiTWlkZGxlXCJdID0gMV0gPSBcIk1pZGRsZVwiO1xyXG4gICAgTmF0aXZlUG9pbnRlckJ1dHRvbltOYXRpdmVQb2ludGVyQnV0dG9uW1wiUmlnaHRcIl0gPSAyXSA9IFwiUmlnaHRcIjtcclxuICAgIE5hdGl2ZVBvaW50ZXJCdXR0b25bTmF0aXZlUG9pbnRlckJ1dHRvbltcIlVua25vd25cIl0gPSAzXSA9IFwiVW5rbm93blwiO1xyXG59KShOYXRpdmVQb2ludGVyQnV0dG9uIHx8IChOYXRpdmVQb2ludGVyQnV0dG9uID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBtb3VzZSBidXR0b24gYmVpbmcgcHJlc3NlZC5cclxuICovXHJcbnZhciBQb2ludGVyQnV0dG9uO1xyXG4oZnVuY3Rpb24gKFBvaW50ZXJCdXR0b24pIHtcclxuICAgIFBvaW50ZXJCdXR0b25bXCJMZWZ0XCJdID0gXCJMZWZ0XCI7XHJcbiAgICBQb2ludGVyQnV0dG9uW1wiTWlkZGxlXCJdID0gXCJNaWRkbGVcIjtcclxuICAgIFBvaW50ZXJCdXR0b25bXCJSaWdodFwiXSA9IFwiUmlnaHRcIjtcclxuICAgIFBvaW50ZXJCdXR0b25bXCJVbmtub3duXCJdID0gXCJVbmtub3duXCI7XHJcbiAgICBQb2ludGVyQnV0dG9uW1wiTm9CdXR0b25cIl0gPSBcIk5vQnV0dG9uXCI7XHJcbn0pKFBvaW50ZXJCdXR0b24gfHwgKFBvaW50ZXJCdXR0b24gPSB7fSkpO1xyXG52YXIgV2hlZWxEZWx0YU1vZGU7XHJcbihmdW5jdGlvbiAoV2hlZWxEZWx0YU1vZGUpIHtcclxuICAgIFdoZWVsRGVsdGFNb2RlW1wiUGl4ZWxcIl0gPSBcIlBpeGVsXCI7XHJcbiAgICBXaGVlbERlbHRhTW9kZVtcIkxpbmVcIl0gPSBcIkxpbmVcIjtcclxuICAgIFdoZWVsRGVsdGFNb2RlW1wiUGFnZVwiXSA9IFwiUGFnZVwiO1xyXG59KShXaGVlbERlbHRhTW9kZSB8fCAoV2hlZWxEZWx0YU1vZGUgPSB7fSkpO1xyXG4vKipcclxuICogUG9pbnRlciBldmVudHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIG1vdXNlLCB0b3VjaCwgb3Igc3R5bHVzIGV2ZW50LiBTZWUgW1tQb2ludGVyc11dIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uXHJcbiAqIGhhbmRsaW5nIHBvaW50ZXIgaW5wdXQuXHJcbiAqXHJcbiAqIEZvciBtb3VzZS1iYXNlZCBldmVudHMsIHlvdSBjYW4gaW5zcGVjdCBbW1BvaW50ZXJFdmVudC5idXR0b25dXSB0byBzZWUgd2hhdCBidXR0b24gd2FzIHByZXNzZWQuXHJcbiAqL1xyXG5jbGFzcyBQb2ludGVyRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29vcmRpbmF0ZXMgICAgICAgICBUaGUgW1tHbG9iYWxDb29yZGluYXRlc11dIG9mIHRoZSBldmVudFxyXG4gICAgICogQHBhcmFtIHBvaW50ZXIgICAgICAgICAgICAgVGhlIFtbUG9pbnRlcl1dIG9mIHRoZSBldmVudFxyXG4gICAgICogQHBhcmFtIGluZGV4ICAgICAgICAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBwb2ludGVyICh6ZXJvLWJhc2VkKVxyXG4gICAgICogQHBhcmFtIHBvaW50ZXJUeXBlICAgICAgICAgVGhlIHR5cGUgb2YgcG9pbnRlclxyXG4gICAgICogQHBhcmFtIGJ1dHRvbiAgICAgICAgICAgICAgVGhlIGJ1dHRvbiBwcmVzc2VkIChpZiBbW1BvaW50ZXJUeXBlLk1vdXNlXV0pXHJcbiAgICAgKiBAcGFyYW0gZXYgICAgICAgICAgICAgICAgICBUaGUgcmF3IERPTSBldmVudCBiZWluZyBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvb3JkaW5hdGVzLCBwb2ludGVyLCBpbmRleCwgcG9pbnRlclR5cGUsIGJ1dHRvbiwgZXYpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcclxuICAgICAgICB0aGlzLnBvaW50ZXIgPSBwb2ludGVyO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLnBvaW50ZXJUeXBlID0gcG9pbnRlclR5cGU7XHJcbiAgICAgICAgdGhpcy5idXR0b24gPSBidXR0b247XHJcbiAgICAgICAgdGhpcy5ldiA9IGV2O1xyXG4gICAgICAgIHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXQgbmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcclxuICAgIH1cclxuICAgIC8qKiBUaGUgd29ybGQgY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50LiAqL1xyXG4gICAgZ2V0IHdvcmxkUG9zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVzLndvcmxkUG9zLmNsb25lKCk7XHJcbiAgICB9XHJcbiAgICAvKiogVGhlIHBhZ2UgY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50LiAqL1xyXG4gICAgZ2V0IHBhZ2VQb3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZXMucGFnZVBvcy5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqIFRoZSBzY3JlZW4gY29vcmRpbmF0ZXMgb2YgdGhlIGV2ZW50LiAqL1xyXG4gICAgZ2V0IHNjcmVlblBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlcy5zY3JlZW5Qb3MuY2xvbmUoKTtcclxuICAgIH1cclxuICAgIGdldCBwb3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZXMud29ybGRQb3MuY2xvbmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VscyBwb2ludGVyIGV2ZW50IHByb3BvZ2F0aW9uLCBldmVudCB3aWxsIG5vdCBiZSB0cmFuc21pdHRlZCB0byBhbnkgb3RoZXIgYWN0b3JzXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICB0aGlzLl9jYW5jZWxlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgZXZlbnQgaXMgY2FuY2VsZWQgaXQgd2lsbCBubyBsb25nZXIgYmUgdHJhbnNtaXR0ZWQgdG8gYW55IG90aGVyIGFjdG9yc1xyXG4gICAgICovXHJcbiAgICBpc0NhbmNlbGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWxlZDtcclxuICAgIH1cclxuICAgIHByb3BhZ2F0ZShhY3Rvcikge1xyXG4gICAgICAgIHRoaXMuZG9BY3Rpb24oYWN0b3IpO1xyXG4gICAgICAgIGlmICh0aGlzLmJ1YmJsZXMgJiYgIXRoaXMuaXNDYW5jZWxlZCgpICYmIGFjdG9yLnBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZShhY3Rvci5wYXJlbnQpOyAvLyBUT0RPIG5vdCB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3Rpb24sIHRoYXQgY2FsbHMgd2hlbiBldmVudCBoYXBwZW5zXHJcbiAgICAgKi9cclxuICAgIGRvQWN0aW9uKGFjdG9yKSB7XHJcbiAgICAgICAgaWYgKGFjdG9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uQWN0aW9uU3RhcnQoYWN0b3IpO1xyXG4gICAgICAgICAgICBhY3Rvci5lbWl0KHRoaXMuX25hbWUsIHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLl9vbkFjdGlvbkVuZChhY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uQWN0aW9uU3RhcnQoX2FjdG9yKSB7XHJcbiAgICAgICAgLy8gdG8gYmUgcmV3cml0dGVuXHJcbiAgICB9XHJcbiAgICBfb25BY3Rpb25FbmQoX2FjdG9yKSB7XHJcbiAgICAgICAgLy8gdG8gYmUgcmV3cml0dGVuXHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUG9pbnRlckV2ZW50RmFjdG9yeSB7XHJcbiAgICBjb25zdHJ1Y3RvcihfcG9pbnRlckV2ZW50VHlwZSkge1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJFdmVudFR5cGUgPSBfcG9pbnRlckV2ZW50VHlwZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIHNwZWNpZmljIFBvaW50ZXJFdmVudFxyXG4gICAgICovXHJcbiAgICBjcmVhdGUoY29vcmRpbmF0ZXMsIHBvaW50ZXIsIGluZGV4LCBwb2ludGVyVHlwZSwgYnV0dG9uLCBldikge1xyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5fcG9pbnRlckV2ZW50VHlwZShjb29yZGluYXRlcywgcG9pbnRlciwgaW5kZXgsIHBvaW50ZXJUeXBlLCBidXR0b24sIGV2KTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBQb2ludGVyRHJhZ0V2ZW50IGV4dGVuZHMgUG9pbnRlckV2ZW50IHtcclxufVxyXG5jbGFzcyBQb2ludGVyVXBFdmVudCBleHRlbmRzIFBvaW50ZXJFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSAncG9pbnRlcnVwJztcclxuICAgIH1cclxuICAgIF9vbkFjdGlvbkVuZChhY3Rvcikge1xyXG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLnBvaW50ZXI7XHJcbiAgICAgICAgaWYgKHBvaW50ZXIuaXNEcmFnRW5kICYmIGFjdG9yLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVEcmFnRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVyZHJhZ2VuZCcsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBQb2ludGVyRG93bkV2ZW50IGV4dGVuZHMgUG9pbnRlckV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9ICdwb2ludGVyZG93bic7XHJcbiAgICB9XHJcbiAgICBfb25BY3Rpb25FbmQoYWN0b3IpIHtcclxuICAgICAgICBpZiAodGhpcy5wb2ludGVyLmlzRHJhZ1N0YXJ0ICYmIGFjdG9yLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVEcmFnRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVyZHJhZ3N0YXJ0JywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBvaW50ZXJNb3ZlRXZlbnQgZXh0ZW5kcyBQb2ludGVyRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gJ3BvaW50ZXJtb3ZlJztcclxuICAgICAgICAvLyBwcml2YXRlIF9vbkFjdG9yRW50ZXIoYWN0b3I6IEFjdG9yKSB7XHJcbiAgICAgICAgLy8gICBjb25zdCBwZSA9IGNyZWF0ZVBvaW50ZXJFdmVudEJ5TmFtZSgnZW50ZXInLCB0aGlzLmNvb3JkaW5hdGVzLCB0aGlzLnBvaW50ZXIsIHRoaXMuaW5kZXgsIHRoaXMucG9pbnRlclR5cGUsIHRoaXMuYnV0dG9uLCB0aGlzLmV2KTtcclxuICAgICAgICAvLyAgIHBlLnByb3BhZ2F0ZShhY3Rvcik7XHJcbiAgICAgICAgLy8gICB0aGlzLnBvaW50ZXIuYWRkQWN0b3JVbmRlclBvaW50ZXIoYWN0b3IpO1xyXG4gICAgICAgIC8vICAgaWYgKHRoaXMucG9pbnRlci5pc0RyYWdnaW5nKSB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMucG9pbnRlci5kcmFnVGFyZ2V0ID0gYWN0b3I7XHJcbiAgICAgICAgLy8gICB9XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIHByaXZhdGUgX29uQWN0b3JMZWF2ZShhY3RvcjogQWN0b3IpIHtcclxuICAgICAgICAvLyAgIGNvbnN0IHBlID0gY3JlYXRlUG9pbnRlckV2ZW50QnlOYW1lKCdsZWF2ZScsIHRoaXMuY29vcmRpbmF0ZXMsIHRoaXMucG9pbnRlciwgdGhpcy5pbmRleCwgdGhpcy5wb2ludGVyVHlwZSwgdGhpcy5idXR0b24sIHRoaXMuZXYpO1xyXG4gICAgICAgIC8vICAgcGUucHJvcGFnYXRlKGFjdG9yKTtcclxuICAgICAgICAvLyAgIHRoaXMucG9pbnRlci5yZW1vdmVBY3RvclVuZGVyUG9pbnRlcihhY3Rvcik7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgfVxyXG4gICAgcHJvcGFnYXRlKGFjdG9yKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlIGFjdG9yIHdhcyB1bmRlciB0aGUgcG9pbnRlciBsYXN0IGZyYW1lLCBidXQgbm90IHRoaXMgb25lIGl0IGxlZnRcclxuICAgICAgICAvLyBpZiAodGhpcy5wb2ludGVyLndhc0FjdG9yVW5kZXJQb2ludGVyKGFjdG9yKSAmJiAhdGhpcy5wb2ludGVyLmlzQWN0b3JVbmRlclBvaW50ZXIoYWN0b3IpKSB7XHJcbiAgICAgICAgLy8gICB0aGlzLl9vbkFjdG9yTGVhdmUoYWN0b3IpO1xyXG4gICAgICAgIC8vICAgcmV0dXJuO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBpZiAodGhpcy5wb2ludGVyLmlzQWN0b3JBbGl2ZVVuZGVyUG9pbnRlcihhY3RvcikpIHtcclxuICAgICAgICAgICAgdGhpcy5kb0FjdGlvbihhY3Rvcik7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1YmJsZXMgJiYgIXRoaXMuaXNDYW5jZWxlZCgpICYmIGFjdG9yLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wYWdhdGUoYWN0b3IucGFyZW50KTsgLy8gVE9ETyBub3QgdHJ1ZVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uQWN0aW9uU3RhcnQoYWN0b3IpIHtcclxuICAgICAgICBpZiAoIWFjdG9yLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVNb3ZlRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSW4gdGhlIGNhc2UgdGhpcyBpcyBuZXdcclxuICAgICAgICAvLyBpZiAodGhpcy5wb2ludGVyLmNoZWNrQWN0b3JVbmRlclBvaW50ZXIoYWN0b3IpICYmICF0aGlzLnBvaW50ZXIud2FzQWN0b3JVbmRlclBvaW50ZXIoYWN0b3IpKSB7XHJcbiAgICAgICAgLy8gICB0aGlzLl9vbkFjdG9yRW50ZXIoYWN0b3IpO1xyXG4gICAgICAgIC8vIH1cclxuICAgICAgICBpZiAodGhpcy5wb2ludGVyLmlzRHJhZ2dpbmcgJiYgYWN0b3IuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZURyYWdFdmVudHMpIHtcclxuICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3BvaW50ZXJkcmFnbW92ZScsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBQb2ludGVyRW50ZXJFdmVudCBleHRlbmRzIFBvaW50ZXJFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSAncG9pbnRlcmVudGVyJztcclxuICAgIH1cclxuICAgIF9vbkFjdGlvblN0YXJ0KGFjdG9yKSB7XHJcbiAgICAgICAgaWYgKCFhY3Rvci5jYXB0dXJlUG9pbnRlci5jYXB0dXJlTW92ZUV2ZW50cykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX29uQWN0aW9uRW5kKGFjdG9yKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IHRoaXMucG9pbnRlcjtcclxuICAgICAgICBpZiAocG9pbnRlci5pc0RyYWdnaW5nICYmIGFjdG9yLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVEcmFnRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIGFjdG9yLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdwb2ludGVyZHJhZ2VudGVyJywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBvaW50ZXJMZWF2ZUV2ZW50IGV4dGVuZHMgUG9pbnRlckV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9ICdwb2ludGVybGVhdmUnO1xyXG4gICAgfVxyXG4gICAgX29uQWN0aW9uU3RhcnQoYWN0b3IpIHtcclxuICAgICAgICBpZiAoIWFjdG9yLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVNb3ZlRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25BY3Rpb25FbmQoYWN0b3IpIHtcclxuICAgICAgICBjb25zdCBwb2ludGVyID0gdGhpcy5wb2ludGVyO1xyXG4gICAgICAgIGlmIChwb2ludGVyLmlzRHJhZ2dpbmcgJiYgYWN0b3IuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZURyYWdFdmVudHMpIHtcclxuICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3BvaW50ZXJkcmFnbGVhdmUnLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUG9pbnRlckNhbmNlbEV2ZW50IGV4dGVuZHMgUG9pbnRlckV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9ICdwb2ludGVyY2FuY2VsJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogV2hlZWwgRXZlbnRzXHJcbiAqXHJcbiAqIFJlcHJlc2VudHMgYSBtb3VzZSB3aGVlbCBldmVudC4gU2VlIFtbUG9pbnRlcnNdXSBmb3IgbW9yZSBpbmZvcm1hdGlvbiBvblxyXG4gKiBoYW5kbGluZyBwb2ludCBpbnB1dC5cclxuICovXHJcbmNsYXNzIFdoZWVsRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0geCAgICAgICAgICAgIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxyXG4gICAgICogQHBhcmFtIHkgICAgICAgICAgICBUaGUgYHlgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiB3b3JsZCBjb29yZGluYXRlcylcclxuICAgICAqIEBwYXJhbSBwYWdlWCAgICAgICAgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gZG9jdW1lbnQgY29vcmRpbmF0ZXMpXHJcbiAgICAgKiBAcGFyYW0gcGFnZVkgICAgICAgIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIGRvY3VtZW50IGNvb3JkaW5hdGVzKVxyXG4gICAgICogQHBhcmFtIHNjcmVlblggICAgICBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBzY3JlZW4gY29vcmRpbmF0ZXMpXHJcbiAgICAgKiBAcGFyYW0gc2NyZWVuWSAgICAgIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIHNjcmVlbiBjb29yZGluYXRlcylcclxuICAgICAqIEBwYXJhbSBpbmRleCAgICAgICAgVGhlIGluZGV4IG9mIHRoZSBwb2ludGVyICh6ZXJvLWJhc2VkKVxyXG4gICAgICogQHBhcmFtIGRlbHRhWCAgICAgICBUaGUgdHlwZSBvZiBwb2ludGVyXHJcbiAgICAgKiBAcGFyYW0gZGVsdGFZICAgICAgIFRoZSB0eXBlIG9mIHBvaW50ZXJcclxuICAgICAqIEBwYXJhbSBkZWx0YVogICAgICAgVGhlIHR5cGUgb2YgcG9pbnRlclxyXG4gICAgICogQHBhcmFtIGRlbHRhTW9kZSAgICBUaGUgdHlwZSBvZiBtb3ZlbWVudCBbW1doZWVsRGVsdGFNb2RlXV1cclxuICAgICAqIEBwYXJhbSBldiAgICAgICAgICAgVGhlIHJhdyBET00gZXZlbnQgYmVpbmcgaGFuZGxlZFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCBwYWdlWCwgcGFnZVksIHNjcmVlblgsIHNjcmVlblksIGluZGV4LCBkZWx0YVgsIGRlbHRhWSwgZGVsdGFaLCBkZWx0YU1vZGUsIGV2KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy5wYWdlWCA9IHBhZ2VYO1xyXG4gICAgICAgIHRoaXMucGFnZVkgPSBwYWdlWTtcclxuICAgICAgICB0aGlzLnNjcmVlblggPSBzY3JlZW5YO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuWSA9IHNjcmVlblk7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMuZGVsdGFYID0gZGVsdGFYO1xyXG4gICAgICAgIHRoaXMuZGVsdGFZID0gZGVsdGFZO1xyXG4gICAgICAgIHRoaXMuZGVsdGFaID0gZGVsdGFaO1xyXG4gICAgICAgIHRoaXMuZGVsdGFNb2RlID0gZGVsdGFNb2RlO1xyXG4gICAgICAgIHRoaXMuZXYgPSBldjtcclxuICAgICAgICB0aGlzLl9pc0NhbmNlbGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbmNlbHMgcG9pbnRlciBldmVudCBwcm9wb2dhdGlvbiwgZXZlbnQgd2lsbCBub3QgYmUgdHJhbnNtaXR0ZWQgdG8gYW55IG90aGVyIGFjdG9yc1xyXG4gICAgICovXHJcbiAgICBjYW5jZWwoKSB7XHJcbiAgICAgICAgdGhpcy5faXNDYW5jZWxlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBJZiB0aGUgZXZlbnQgaXMgY2FuY2VsZWQgaXQgd2lsbCBubyBsb25nZXIgYmUgdHJhbnNtaXR0ZWQgdG8gYW55IG90aGVyIGFjdG9yc1xyXG4gICAgICovXHJcbiAgICBpc0NhbmNlbGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NhbmNlbGVkO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUG9pbnRlckV2ZW50QnlOYW1lKGV2ZW50TmFtZSwgY29vcmRpbmF0ZXMsIHBvaW50ZXIsIGluZGV4LCBwb2ludGVyVHlwZSwgYnV0dG9uLCBldikge1xyXG4gICAgbGV0IGZhY3Rvcnk7XHJcbiAgICBzd2l0Y2ggKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGNhc2UgJ3VwJzpcclxuICAgICAgICAgICAgZmFjdG9yeSA9IG5ldyBQb2ludGVyRXZlbnRGYWN0b3J5KFBvaW50ZXJVcEV2ZW50KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZG93bic6XHJcbiAgICAgICAgICAgIGZhY3RvcnkgPSBuZXcgUG9pbnRlckV2ZW50RmFjdG9yeShQb2ludGVyRG93bkV2ZW50KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbW92ZSc6XHJcbiAgICAgICAgICAgIGZhY3RvcnkgPSBuZXcgUG9pbnRlckV2ZW50RmFjdG9yeShQb2ludGVyTW92ZUV2ZW50KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnY2FuY2VsJzpcclxuICAgICAgICAgICAgZmFjdG9yeSA9IG5ldyBQb2ludGVyRXZlbnRGYWN0b3J5KFBvaW50ZXJDYW5jZWxFdmVudCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJ2VudGVyJzpcclxuICAgICAgICAgICAgZmFjdG9yeSA9IG5ldyBQb2ludGVyRXZlbnRGYWN0b3J5KFBvaW50ZXJFbnRlckV2ZW50KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnbGVhdmUnOlxyXG4gICAgICAgICAgICBmYWN0b3J5ID0gbmV3IFBvaW50ZXJFdmVudEZhY3RvcnkoUG9pbnRlckxlYXZlRXZlbnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgIH1cclxuICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZShjb29yZGluYXRlcywgcG9pbnRlciwgaW5kZXgsIHBvaW50ZXJUeXBlLCBidXR0b24sIGV2KTtcclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL01hdGgvZ2xvYmFsLWNvb3JkaW5hdGVzLnRzXG5cclxuY2xhc3MgR2xvYmFsQ29vcmRpbmF0ZXMge1xyXG4gICAgY29uc3RydWN0b3Iod29ybGRQb3MsIHBhZ2VQb3MsIHNjcmVlblBvcykge1xyXG4gICAgICAgIHRoaXMud29ybGRQb3MgPSB3b3JsZFBvcztcclxuICAgICAgICB0aGlzLnBhZ2VQb3MgPSBwYWdlUG9zO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuUG9zID0gc2NyZWVuUG9zO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21QYWdlUG9zaXRpb24oeE9yUG9zLCB5T3JFbmdpbmUsIGVuZ2luZU9yVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbGV0IHBhZ2VYO1xyXG4gICAgICAgIGxldCBwYWdlWTtcclxuICAgICAgICBsZXQgcGFnZVBvcztcclxuICAgICAgICBsZXQgZW5naW5lO1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XHJcbiAgICAgICAgICAgIHBhZ2VYID0geE9yUG9zO1xyXG4gICAgICAgICAgICBwYWdlWSA9IHlPckVuZ2luZTtcclxuICAgICAgICAgICAgcGFnZVBvcyA9IG5ldyBWZWN0b3IocGFnZVgsIHBhZ2VZKTtcclxuICAgICAgICAgICAgZW5naW5lID0gZW5naW5lT3JVbmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBwYWdlUG9zID0geE9yUG9zO1xyXG4gICAgICAgICAgICBwYWdlWCA9IHBhZ2VQb3MueDtcclxuICAgICAgICAgICAgcGFnZVkgPSBwYWdlUG9zLnk7XHJcbiAgICAgICAgICAgIGVuZ2luZSA9IHlPckVuZ2luZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2NyZWVuUG9zID0gZW5naW5lLnNjcmVlbi5wYWdlVG9TY3JlZW5Db29yZGluYXRlcyhwYWdlUG9zKTtcclxuICAgICAgICBjb25zdCB3b3JsZFBvcyA9IGVuZ2luZS5zY3JlZW4uc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKHNjcmVlblBvcyk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBHbG9iYWxDb29yZGluYXRlcyh3b3JsZFBvcywgcGFnZVBvcywgc2NyZWVuUG9zKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lucHV0L1BvaW50ZXJzLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBIGNvbnN0YW50IHVzZWQgdG8gbm9ybWFsaXplIHdoZWVsIGV2ZW50cyBhY3Jvc3MgZGlmZmVyZW50IGJyb3dzZXJzXHJcbiAqXHJcbiAqIFRoaXMgbm9ybWFsaXphdGlvbiBmYWN0b3IgaXMgcHVsbGVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvRXZlbnRzL3doZWVsI0xpc3RlbmluZ190b190aGlzX2V2ZW50X2Fjcm9zc19icm93c2VyXHJcbiAqL1xyXG5jb25zdCBTY3JvbGxXaGVlbE5vcm1hbGl6YXRpb25GYWN0b3IgPSAtMSAvIDQwO1xyXG4vKipcclxuICogSGFuZGxlcyBwb2ludGVyIGV2ZW50cyAobW91c2UsIHRvdWNoLCBzdHlsdXMsIGV0Yy4pIGFuZCBub3JtYWxpemVzIHRvXHJcbiAqIFtXM0MgUG9pbnRlciBFdmVudHNdKGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvKS5cclxuICovXHJcbmNsYXNzIFBvaW50ZXJzIGV4dGVuZHMgQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9wb2ludGVyRG93biA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJVcCA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJNb3ZlID0gW107XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlckNhbmNlbCA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3doZWVsID0gW107XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9hY3RpdmVQb2ludGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLl9wb2ludGVycy5wdXNoKG5ldyBQb2ludGVyKCkpO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2ZVBvaW50ZXJzID0gWy0xXTtcclxuICAgICAgICB0aGlzLnByaW1hcnkgPSB0aGlzLl9wb2ludGVyc1swXTtcclxuICAgIH1cclxuICAgIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHBvaW50ZXIgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgKi9cclxuICAgIGluaXQodGFyZ2V0KSB7XHJcbiAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHRoaXMuX2VuZ2luZS5jYW52YXM7XHJcbiAgICAgICAgLy8gVG91Y2ggRXZlbnRzXHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KCdkb3duJywgdGhpcy5fcG9pbnRlckRvd24pKTtcclxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KCd1cCcsIHRoaXMuX3BvaW50ZXJVcCkpO1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KCdtb3ZlJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hjYW5jZWwnLCB0aGlzLl9oYW5kbGVUb3VjaEV2ZW50KCdjYW5jZWwnLCB0aGlzLl9wb2ludGVyQ2FuY2VsKSk7XHJcbiAgICAgICAgLy8gVzNDIFBvaW50ZXIgRXZlbnRzXHJcbiAgICAgICAgLy8gQ3VycmVudDogSUUxMSwgSUUxMFxyXG4gICAgICAgIGlmICh3aW5kb3cuUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIElFMTFcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLmNhbnZhcy5zdHlsZS50b3VjaEFjdGlvbiA9ICdub25lJztcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdkb3duJywgdGhpcy5fcG9pbnRlckRvd24pKTtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgndXAnLCB0aGlzLl9wb2ludGVyVXApKTtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdtb3ZlJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ2NhbmNlbCcsIHRoaXMuX3BvaW50ZXJDYW5jZWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAod2luZG93Lk1TUG9pbnRlckV2ZW50KSB7XHJcbiAgICAgICAgICAgIC8vIElFMTBcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLmNhbnZhcy5zdHlsZS5tc1RvdWNoQWN0aW9uID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyRG93bicsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgnZG93bicsIHRoaXMuX3BvaW50ZXJEb3duKSk7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJVcCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgndXAnLCB0aGlzLl9wb2ludGVyVXApKTtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlck1vdmUnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ21vdmUnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyQ2FuY2VsJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdjYW5jZWwnLCB0aGlzLl9wb2ludGVyQ2FuY2VsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNb3VzZSBFdmVudHNcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoJ2Rvd24nLCB0aGlzLl9wb2ludGVyRG93bikpO1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoJ3VwJywgdGhpcy5fcG9pbnRlclVwKSk7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVNb3VzZUV2ZW50KCdtb3ZlJywgdGhpcy5fcG9pbnRlck1vdmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTUROIE1vdXNlV2hlZWxFdmVudFxyXG4gICAgICAgIGNvbnN0IHdoZWVsT3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgcGFzc2l2ZTogISh0aGlzLl9lbmdpbmUucGFnZVNjcm9sbFByZXZlbnRpb25Nb2RlID09PSBTY3JvbGxQcmV2ZW50aW9uTW9kZS5BbGwgfHxcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5wYWdlU2Nyb2xsUHJldmVudGlvbk1vZGUgPT09IFNjcm9sbFByZXZlbnRpb25Nb2RlLkNhbnZhcylcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICgnb253aGVlbCcgaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JykpIHtcclxuICAgICAgICAgICAgLy8gTW9kZXJuIEJyb3dzZXJzXHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX2hhbmRsZVdoZWVsRXZlbnQoJ3doZWVsJywgdGhpcy5fd2hlZWwpLCB3aGVlbE9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudC5vbm1vdXNld2hlZWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAvLyBXZWJraXQgYW5kIElFXHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXdoZWVsJywgdGhpcy5faGFuZGxlV2hlZWxFdmVudCgnd2hlZWwnLCB0aGlzLl93aGVlbCksIHdoZWVsT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBSZW1haW5pbmcgYnJvd3NlciBhbmQgb2xkZXIgRmlyZWZveFxyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignTW96TW91c2VQaXhlbFNjcm9sbCcsIHRoaXMuX2hhbmRsZVdoZWVsRXZlbnQoJ3doZWVsJywgdGhpcy5fd2hlZWwpLCB3aGVlbE9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3ludGhlc2l6ZSBhIHBvaW50ZXIgZXZlbnQgdGhhdCBsb29rcyBsaWtlIGEgcmVhbCBicm93c2VyIGV2ZW50IHRvIGV4Y2FsaWJ1clxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZVxyXG4gICAgICogQHBhcmFtIHBvc1xyXG4gICAgICovXHJcbiAgICB0cmlnZ2VyRXZlbnQoZXZlbnROYW1lLCBwb3MsIGJ1dHRvbiA9IE5hdGl2ZVBvaW50ZXJCdXR0b24uTGVmdCwgcG9pbnRlclR5cGUgPSAnbW91c2UnLCBwb2ludGVySWQgPSAwKSB7XHJcbiAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgIGxldCB5ID0gMDtcclxuICAgICAgICBsZXQgY29vcmRzO1xyXG4gICAgICAgIGlmIChwb3MgaW5zdGFuY2VvZiBHbG9iYWxDb29yZGluYXRlcykge1xyXG4gICAgICAgICAgICB4ID0gcG9zLnBhZ2VQb3MueDtcclxuICAgICAgICAgICAgeSA9IHBvcy5wYWdlUG9zLnk7XHJcbiAgICAgICAgICAgIGNvb3JkcyA9IHBvcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHggPSBwb3MueDtcclxuICAgICAgICAgICAgeSA9IHBvcy55O1xyXG4gICAgICAgICAgICBjb29yZHMgPSBuZXcgR2xvYmFsQ29vcmRpbmF0ZXMocG9zLmNsb25lKCksIHBvcy5jbG9uZSgpLCBwb3MuY2xvbmUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGV2ZW50aXNoID0ge1xyXG4gICAgICAgICAgICBwYWdlWDogeCxcclxuICAgICAgICAgICAgcGFnZVk6IHksXHJcbiAgICAgICAgICAgIHBvaW50ZXJJZDogcG9pbnRlcklkLFxyXG4gICAgICAgICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXHJcbiAgICAgICAgICAgIGJ1dHRvbjogYnV0dG9uLFxyXG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdDogKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLyogZG8gbm90aGluZyAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICBzd2l0Y2ggKGV2ZW50TmFtZSkge1xyXG4gICAgICAgICAgICBjYXNlICdtb3ZlJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChldmVudE5hbWUsIHRoaXMuX3BvaW50ZXJNb3ZlLCBjb29yZHMpKGV2ZW50aXNoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdkb3duJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChldmVudE5hbWUsIHRoaXMuX3BvaW50ZXJEb3duLCBjb29yZHMpKGV2ZW50aXNoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICd1cCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoZXZlbnROYW1lLCB0aGlzLl9wb2ludGVyVXAsIGNvb3JkcykoZXZlbnRpc2gpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2NhbmNlbCc6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoZXZlbnROYW1lLCB0aGlzLl9wb2ludGVyQ2FuY2VsLCBjb29yZHMpKGV2ZW50aXNoKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGFjdG9yIG9mIHRoaXMuX2VuZ2luZS5jdXJyZW50U2NlbmUuYWN0b3JzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVQb2ludGVyID0gYWN0b3IudHJhaXRzLmZpbHRlcigodCkgPT4gdCBpbnN0YW5jZW9mIENhcHR1cmVQb2ludGVyKVswXTtcclxuICAgICAgICAgICAgaWYgKGNhcHR1cmVQb2ludGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjYXB0dXJlUG9pbnRlci51cGRhdGUoYWN0b3IsIHRoaXMuX2VuZ2luZSwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kaXNwYXRjaFBvaW50ZXJFdmVudHMoKTtcclxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgYWxsIHBvaW50ZXIgZXZlbnRzIGFuZCBwb2ludGVycywgbWVhbnQgdG8gYmUgY2FsbGVkIGF0IHRoZSBlbmQgb2YgZnJhbWVcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJVcC5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJEb3duLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlck1vdmUubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9wb2ludGVyQ2FuY2VsLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fd2hlZWwubGVuZ3RoID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BvaW50ZXJzW2ldLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZWx5IGdldHMgYSBQb2ludGVyIGF0IGEgc3BlY2lmaWMgaW5kZXggYW5kIGluaXRpYWxpemVzIG9uZSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxyXG4gICAgICogQHBhcmFtIGluZGV4ICBUaGUgcG9pbnRlciBpbmRleCB0byByZXRyaWV2ZVxyXG4gICAgICovXHJcbiAgICBhdChpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9wb2ludGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgLy8gRW5zdXJlIHRoZXJlIGlzIGEgcG9pbnRlciB0byByZXRyaWV2ZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcG9pbnRlcnMubGVuZ3RoIC0gMSwgbWF4ID0gaW5kZXg7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9pbnRlcnMucHVzaChuZXcgUG9pbnRlcigpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBvaW50ZXJzLnB1c2goLTEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVyc1tpbmRleF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBudW1iZXIgb2YgcG9pbnRlcnMgYmVpbmcgd2F0Y2hlZFxyXG4gICAgICovXHJcbiAgICBjb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRlcnMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY2hlY2tBbmRVcGRhdGVBY3RvclVuZGVyUG9pbnRlcihhY3Rvcikge1xyXG4gICAgICAgIGZvciAoY29uc3QgcG9pbnRlciBvZiB0aGlzLl9wb2ludGVycykge1xyXG4gICAgICAgICAgICBpZiAocG9pbnRlci5jaGVja0FjdG9yVW5kZXJQb2ludGVyKGFjdG9yKSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlci5hZGRBY3RvclVuZGVyUG9pbnRlcihhY3Rvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLnJlbW92ZUFjdG9yVW5kZXJQb2ludGVyKGFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kaXNwYXRjaFdpdGhCdWJibGUoZXZlbnRzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBldnQgb2YgZXZlbnRzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWN0b3Igb2YgZXZ0LnBvaW50ZXIuZ2V0QWN0b3JzRm9yRXZlbnRzKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghZXZ0LmlzQ2FuY2VsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGV2dC5wcm9wYWdhdGUoYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKCFldnQuYnViYmxlcyB8fCBldnQuaXNDYW5jZWxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGV2ZW50IHN0b3BzIGJ1YmJsaW5nIHBhcnQgd2F5IHN0b3AgcHJvY2Vzc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2Rpc3BhdGNoUG9pbnRlckxlYXZlRXZlbnRzKCkge1xyXG4gICAgICAgIGNvbnN0IGxhc3RNb3ZlRXZlbnRQZXJQb2ludGVyUGVyQWN0b3IgPSB7fTtcclxuICAgICAgICBjb25zdCBwb2ludGVyTGVhdmUgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGV2dCBvZiB0aGlzLl9wb2ludGVyTW92ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdG9yIG9mIGV2dC5wb2ludGVyLmdldEFjdG9yc0ZvckV2ZW50cygpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYWN0b3Igd2FzIHVuZGVyIHRoZSBwb2ludGVyIGxhc3QgZnJhbWUsIGJ1dCBub3QgdGhpcyB0aGlzIGZyYW1lLCBwb2ludGVyIGxlZnRcclxuICAgICAgICAgICAgICAgIGlmICghbGFzdE1vdmVFdmVudFBlclBvaW50ZXJQZXJBY3RvcltldnQucG9pbnRlci5pZCArICcrJyArIGFjdG9yLmlkXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV2dC5wb2ludGVyLndhc0FjdG9yVW5kZXJQb2ludGVyKGFjdG9yKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFldnQucG9pbnRlci5pc0FjdG9yQWxpdmVVbmRlclBvaW50ZXIoYWN0b3IpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWV2dC5pc0NhbmNlbGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0TW92ZUV2ZW50UGVyUG9pbnRlclBlckFjdG9yW2V2dC5wb2ludGVyLmlkICsgJysnICsgYWN0b3IuaWRdID0gZXZ0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlID0gY3JlYXRlUG9pbnRlckV2ZW50QnlOYW1lKCdsZWF2ZScsIG5ldyBHbG9iYWxDb29yZGluYXRlcyhldnQud29ybGRQb3MsIGV2dC5wYWdlUG9zLCBldnQuc2NyZWVuUG9zKSwgZXZ0LnBvaW50ZXIsIGV2dC5pbmRleCwgZXZ0LnBvaW50ZXJUeXBlLCBldnQuYnV0dG9uLCBldnQuZXYpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBlLnByb3BhZ2F0ZShhY3Rvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRlckxlYXZlLnB1c2gocGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb2ludGVyTGVhdmU7XHJcbiAgICB9XHJcbiAgICBfZGlzcGF0Y2hQb2ludGVyRW50ZXJFdmVudHMoKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdE1vdmVFdmVudFBlclBvaW50ZXIgPSB7fTtcclxuICAgICAgICBjb25zdCBwb2ludGVyRW50ZXIgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGV2dCBvZiB0aGlzLl9wb2ludGVyTW92ZSkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdG9yIG9mIGV2dC5wb2ludGVyLmdldEFjdG9yc0ZvckV2ZW50cygpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYWN0b3Igd2FzIG5vdCB1bmRlciB0aGUgcG9pbnRlciBsYXN0IGZyYW1lLCBidXQgaXQgaXMgdGhpcyBmcmFtZSwgcG9pbnRlciBlbnRlcmVkXHJcbiAgICAgICAgICAgICAgICBpZiAoIWxhc3RNb3ZlRXZlbnRQZXJQb2ludGVyW2V2dC5wb2ludGVyLmlkXSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFldnQucG9pbnRlci53YXNBY3RvclVuZGVyUG9pbnRlcihhY3RvcikgJiZcclxuICAgICAgICAgICAgICAgICAgICBldnQucG9pbnRlci5pc0FjdG9yQWxpdmVVbmRlclBvaW50ZXIoYWN0b3IpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWV2dC5pc0NhbmNlbGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBsYXN0TW92ZUV2ZW50UGVyUG9pbnRlcltldnQucG9pbnRlci5pZF0gPSBldnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGUgPSBjcmVhdGVQb2ludGVyRXZlbnRCeU5hbWUoJ2VudGVyJywgbmV3IEdsb2JhbENvb3JkaW5hdGVzKGV2dC53b3JsZFBvcywgZXZ0LnBhZ2VQb3MsIGV2dC5zY3JlZW5Qb3MpLCBldnQucG9pbnRlciwgZXZ0LmluZGV4LCBldnQucG9pbnRlclR5cGUsIGV2dC5idXR0b24sIGV2dC5ldik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGUucHJvcGFnYXRlKGFjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyRW50ZXIucHVzaChwZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgcG9pbnRlciBpcyBkcmFnZ2luZyBzZXQgdGhlIGRyYWcgdGFyZ2V0XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2dC5wb2ludGVyLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZ0LnBvaW50ZXIuZHJhZ1RhcmdldCA9IGFjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcG9pbnRlckVudGVyO1xyXG4gICAgfVxyXG4gICAgZGlzcGF0Y2hQb2ludGVyRXZlbnRzKCkge1xyXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoV2l0aEJ1YmJsZSh0aGlzLl9wb2ludGVyRG93bik7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hXaXRoQnViYmxlKHRoaXMuX3BvaW50ZXJVcCk7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hXaXRoQnViYmxlKHRoaXMuX3BvaW50ZXJNb3ZlKTtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaFBvaW50ZXJMZWF2ZUV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUG9pbnRlckVudGVyRXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hXaXRoQnViYmxlKHRoaXMuX3BvaW50ZXJDYW5jZWwpO1xyXG4gICAgICAgIC8vIFRPRE8gc29tZSBkdXBsaWNhdGlvbiBoZXJlXHJcbiAgICAgICAgZm9yIChjb25zdCBldnQgb2YgdGhpcy5fd2hlZWwpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBhY3RvciBvZiB0aGlzLl9wb2ludGVyc1tldnQuaW5kZXhdLmdldEFjdG9yc1VuZGVyUG9pbnRlcigpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wYWdhdGVXaGVlbFBvaW50ZXJFdmVudChhY3RvciwgZXZ0KTtcclxuICAgICAgICAgICAgICAgIGlmICghZXZ0LmJ1YmJsZXMgfHwgZXZ0LmlzQ2FuY2VsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBldmVudCBzdG9wcyBidWJibGluZyBwYXJ0IHdheSBzdG9wIHByb2Nlc3NpbmdcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wcm9wYWdhdGVXaGVlbFBvaW50ZXJFdmVudChhY3Rvciwgd2hlZWxFdmVudCkge1xyXG4gICAgICAgIGFjdG9yLmVtaXQoJ3BvaW50ZXJ3aGVlbCcsIHdoZWVsRXZlbnQpO1xyXG4gICAgICAgIC8vIFJlY3Vyc2UgYW5kIHByb3BhZ2F0ZVxyXG4gICAgICAgIGlmICh3aGVlbEV2ZW50LmJ1YmJsZXMgJiYgIXdoZWVsRXZlbnQuaXNDYW5jZWxlZCgpICYmIGFjdG9yLnBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wcm9wYWdhdGVXaGVlbFBvaW50ZXJFdmVudChhY3Rvci5wYXJlbnQsIHdoZWVsRXZlbnQpOyAvLyBUT0RPIG5vdCB0cnVlXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZU1vdXNlRXZlbnQoZXZlbnROYW1lLCBldmVudEFycikge1xyXG4gICAgICAgIHJldHVybiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLmF0KDApO1xyXG4gICAgICAgICAgICBjb25zdCBjb29yZGluYXRlcyA9IEdsb2JhbENvb3JkaW5hdGVzLmZyb21QYWdlUG9zaXRpb24oZS5wYWdlWCwgZS5wYWdlWSwgdGhpcy5fZW5naW5lKTtcclxuICAgICAgICAgICAgY29uc3QgcGUgPSBjcmVhdGVQb2ludGVyRXZlbnRCeU5hbWUoZXZlbnROYW1lLCBjb29yZGluYXRlcywgcG9pbnRlciwgMCwgUG9pbnRlclR5cGUuTW91c2UsIHRoaXMuX25hdGl2ZUJ1dHRvblRvUG9pbnRlckJ1dHRvbihlLmJ1dHRvbiksIGUpO1xyXG4gICAgICAgICAgICBldmVudEFyci5wdXNoKHBlKTtcclxuICAgICAgICAgICAgcG9pbnRlci5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIHBlKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZVRvdWNoRXZlbnQoZXZlbnROYW1lLCBldmVudEFycikge1xyXG4gICAgICAgIHJldHVybiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBlLmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEgPyB0aGlzLl9nZXRQb2ludGVySW5kZXgoZS5jaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyKSA6IDA7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb2ludGVyID0gdGhpcy5hdChpbmRleCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb29yZGluYXRlcyA9IEdsb2JhbENvb3JkaW5hdGVzLmZyb21QYWdlUG9zaXRpb24oZS5jaGFuZ2VkVG91Y2hlc1tpXS5wYWdlWCwgZS5jaGFuZ2VkVG91Y2hlc1tpXS5wYWdlWSwgdGhpcy5fZW5naW5lKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBlID0gY3JlYXRlUG9pbnRlckV2ZW50QnlOYW1lKGV2ZW50TmFtZSwgY29vcmRpbmF0ZXMsIHBvaW50ZXIsIGluZGV4LCBQb2ludGVyVHlwZS5Ub3VjaCwgUG9pbnRlckJ1dHRvbi5Vbmtub3duLCBlKTtcclxuICAgICAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRlci5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIHBlKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudE5hbWUsIHBlKTtcclxuICAgICAgICAgICAgICAgIC8vIG9ubHkgd2l0aCBtdWx0aS1wb2ludGVyXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09ICd1cCcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBvaW50ZXIgSUQgZnJvbSBwb29sIHdoZW4gcG9pbnRlciBpcyBsaWZ0ZWRcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2Rvd24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIElEIHRvIGdpdmVuIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZVBvaW50ZXJzW2luZGV4XSA9IGUuY2hhbmdlZFRvdWNoZXNbaV0uaWRlbnRpZmllcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZVBvaW50ZXJFdmVudChldmVudE5hbWUsIGV2ZW50QXJyLCBjb29yZHMpIHtcclxuICAgICAgICByZXR1cm4gKGUpID0+IHtcclxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAvLyBnZXQgdGhlIGluZGV4IGZvciB0aGlzIHBvaW50ZXIgSUQgaWYgbXVsdGktcG9pbnRlciBpcyBhc2tlZCBmb3JcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9wb2ludGVycy5sZW5ndGggPiAxID8gdGhpcy5fZ2V0UG9pbnRlckluZGV4KGUucG9pbnRlcklkKSA6IDA7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBwb2ludGVyID0gdGhpcy5hdChpbmRleCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gY29vcmRzIHx8IEdsb2JhbENvb3JkaW5hdGVzLmZyb21QYWdlUG9zaXRpb24oZS5wYWdlWCwgZS5wYWdlWSwgdGhpcy5fZW5naW5lKTtcclxuICAgICAgICAgICAgY29uc3QgcGUgPSBjcmVhdGVQb2ludGVyRXZlbnRCeU5hbWUoZXZlbnROYW1lLCBjb29yZGluYXRlcywgcG9pbnRlciwgaW5kZXgsIHRoaXMuX3N0cmluZ1RvUG9pbnRlclR5cGUoZS5wb2ludGVyVHlwZSksIHRoaXMuX25hdGl2ZUJ1dHRvblRvUG9pbnRlckJ1dHRvbihlLmJ1dHRvbiksIGUpO1xyXG4gICAgICAgICAgICBldmVudEFyci5wdXNoKHBlKTtcclxuICAgICAgICAgICAgcG9pbnRlci5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIHBlKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgcGUpO1xyXG4gICAgICAgICAgICAvLyBvbmx5IHdpdGggbXVsdGktcG9pbnRlclxyXG4gICAgICAgICAgICBpZiAodGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBwb2ludGVyIElEIGZyb20gcG9vbCB3aGVuIHBvaW50ZXIgaXMgbGlmdGVkXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gLTE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudE5hbWUgPT09ICdkb3duJykge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBwb2ludGVyIElEIHRvIGdpdmVuIGluZGV4XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gZS5wb2ludGVySWQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZVdoZWVsRXZlbnQoZXZlbnROYW1lLCBldmVudEFycikge1xyXG4gICAgICAgIHJldHVybiAoZSkgPT4ge1xyXG4gICAgICAgICAgICAvLyBTaG91bGQgd2UgcHJldmVudCBwYWdlIHNjcm9sbCBiZWNhdXNlIG9mIHRoaXMgZXZlbnRcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2VuZ2luZS5wYWdlU2Nyb2xsUHJldmVudGlvbk1vZGUgPT09IFNjcm9sbFByZXZlbnRpb25Nb2RlLkFsbCB8fFxyXG4gICAgICAgICAgICAgICAgKHRoaXMuX2VuZ2luZS5wYWdlU2Nyb2xsUHJldmVudGlvbk1vZGUgPT09IFNjcm9sbFByZXZlbnRpb25Nb2RlLkNhbnZhcyAmJiBlLnRhcmdldCA9PT0gdGhpcy5fZW5naW5lLmNhbnZhcykpIHtcclxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBzY3JlZW4gPSB0aGlzLl9lbmdpbmUuc2NyZWVuLnBhZ2VUb1NjcmVlbkNvb3JkaW5hdGVzKHZlYyhlLnBhZ2VYLCBlLnBhZ2VZKSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHdvcmxkID0gdGhpcy5fZW5naW5lLnNjcmVlbi5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMoc2NyZWVuKTtcclxuICAgICAgICAgICAgLy8gZGVsdGFYLCBkZWx0YVksIGFuZCBkZWx0YVogYXJlIHRoZSBzdGFuZGFyZCBtb2Rlcm4gcHJvcGVydGllc1xyXG4gICAgICAgICAgICAvLyB3aGVlbERlbHRhWCwgd2hlZWxEZWx0YVksIGFyZSBsZWdhY3kgcHJvcGVydGllcyBpbiB3ZWJraXQgYnJvd3NlcnMgYW5kIG9sZGVyIElFXHJcbiAgICAgICAgICAgIC8vIGUuZGV0YWlsIGlzIG9ubHkgdXNlZCBpbiBvcGVyYVxyXG4gICAgICAgICAgICBjb25zdCBkZWx0YVggPSBlLmRlbHRhWCB8fCBlLndoZWVsRGVsdGFYICogU2Nyb2xsV2hlZWxOb3JtYWxpemF0aW9uRmFjdG9yIHx8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWSA9IGUuZGVsdGFZIHx8IGUud2hlZWxEZWx0YVkgKiBTY3JvbGxXaGVlbE5vcm1hbGl6YXRpb25GYWN0b3IgfHwgZS53aGVlbERlbHRhICogU2Nyb2xsV2hlZWxOb3JtYWxpemF0aW9uRmFjdG9yIHx8IGUuZGV0YWlsIHx8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWiA9IGUuZGVsdGFaIHx8IDA7XHJcbiAgICAgICAgICAgIGxldCBkZWx0YU1vZGUgPSBXaGVlbERlbHRhTW9kZS5QaXhlbDtcclxuICAgICAgICAgICAgaWYgKGUuZGVsdGFNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUgPT09IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWx0YU1vZGUgPSBXaGVlbERlbHRhTW9kZS5MaW5lO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZS5kZWx0YU1vZGUgPT09IDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWx0YU1vZGUgPSBXaGVlbERlbHRhTW9kZS5QYWdlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHdlID0gbmV3IFdoZWVsRXZlbnQod29ybGQueCwgd29ybGQueSwgZS5wYWdlWCwgZS5wYWdlWSwgc2NyZWVuLngsIHNjcmVlbi55LCAwLCBkZWx0YVgsIGRlbHRhWSwgZGVsdGFaLCBkZWx0YU1vZGUsIGUpO1xyXG4gICAgICAgICAgICBldmVudEFyci5wdXNoKHdlKTtcclxuICAgICAgICAgICAgdGhpcy5hdCgwKS5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIHdlKTtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgd2UpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGluZGV4IG9mIHRoZSBwb2ludGVyIHNwZWNpZmllZCBmb3IgdGhlIGdpdmVuIHBvaW50ZXIgSUQgb3IgZmluZHMgdGhlIG5leHQgZW1wdHkgcG9pbnRlciBzbG90IGF2YWlsYWJsZS5cclxuICAgICAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBJRTEwLzExIHVzZXMgaW5jcmVtZW50aW5nIHBvaW50ZXIgSURzIHNvIHdlIG5lZWQgdG8gc3RvcmUgYSBtYXBwaW5nIG9mIElEID0+IGlkeFxyXG4gICAgICovXHJcbiAgICBfZ2V0UG9pbnRlckluZGV4KHBvaW50ZXJJZCkge1xyXG4gICAgICAgIGxldCBpZHg7XHJcbiAgICAgICAgaWYgKChpZHggPSB0aGlzLl9hY3RpdmVQb2ludGVycy5pbmRleE9mKHBvaW50ZXJJZCkpID4gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGlkeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9hY3RpdmVQb2ludGVycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlUG9pbnRlcnNbaV0gPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZ25vcmUgcG9pbnRlciBiZWNhdXNlIGdhbWUgaXNuJ3Qgd2F0Y2hpbmdcclxuICAgICAgICByZXR1cm4gLTE7XHJcbiAgICB9XHJcbiAgICBfbmF0aXZlQnV0dG9uVG9Qb2ludGVyQnV0dG9uKHMpIHtcclxuICAgICAgICBzd2l0Y2ggKHMpIHtcclxuICAgICAgICAgICAgY2FzZSBOYXRpdmVQb2ludGVyQnV0dG9uLk5vQnV0dG9uOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJCdXR0b24uTm9CdXR0b247XHJcbiAgICAgICAgICAgIGNhc2UgTmF0aXZlUG9pbnRlckJ1dHRvbi5MZWZ0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJCdXR0b24uTGVmdDtcclxuICAgICAgICAgICAgY2FzZSBOYXRpdmVQb2ludGVyQnV0dG9uLk1pZGRsZTpcclxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyQnV0dG9uLk1pZGRsZTtcclxuICAgICAgICAgICAgY2FzZSBOYXRpdmVQb2ludGVyQnV0dG9uLlJpZ2h0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJCdXR0b24uUmlnaHQ7XHJcbiAgICAgICAgICAgIGNhc2UgTmF0aXZlUG9pbnRlckJ1dHRvbi5Vbmtub3duOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJCdXR0b24uVW5rbm93bjtcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWlsKHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zdHJpbmdUb1BvaW50ZXJUeXBlKHMpIHtcclxuICAgICAgICBzd2l0Y2ggKHMpIHtcclxuICAgICAgICAgICAgY2FzZSAndG91Y2gnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJUeXBlLlRvdWNoO1xyXG4gICAgICAgICAgICBjYXNlICdtb3VzZSc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlclR5cGUuTW91c2U7XHJcbiAgICAgICAgICAgIGNhc2UgJ3Blbic6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlclR5cGUuUGVuO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJUeXBlLlVua25vd247XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vSW5wdXQvR2FtZXBhZC50c1xuXHJcblxyXG4vKipcclxuICogRXhjYWxpYnVyIGxldmVyYWdlcyB0aGUgSFRNTDUgR2FtZXBhZCBBUEkgW3doZXJlIGl0IGlzIHN1cHBvcnRlZF0oaHR0cDovL2Nhbml1c2UuY29tLyNmZWF0PWdhbWVwYWQpXHJcbiAqIHRvIHByb3ZpZGUgY29udHJvbGxlciBzdXBwb3J0IGZvciB5b3VyIGdhbWVzLlxyXG4gKi9cclxuY2xhc3MgR2FtZXBhZHMgZXh0ZW5kcyBDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRvIHBvbGwgZm9yIEdhbWVwYWQgaW5wdXQgKGRlZmF1bHQ6IGBmYWxzZWApXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgR2FtZXBhZCBBUEkgaXMgc3VwcG9ydGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdXBwb3J0ZWQgPSAhIW5hdmlnYXRvci5nZXRHYW1lcGFkcztcclxuICAgICAgICB0aGlzLl9nYW1lUGFkVGltZVN0YW1wcyA9IFswLCAwLCAwLCAwXTtcclxuICAgICAgICB0aGlzLl9vbGRQYWRzID0gW107XHJcbiAgICAgICAgdGhpcy5fcGFkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2luaXRTdWNjZXNzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbmF2aWdhdG9yID0gbmF2aWdhdG9yO1xyXG4gICAgICAgIHRoaXMuX21pbmltdW1Db25maWd1cmF0aW9uID0gbnVsbDtcclxuICAgIH1cclxuICAgIGluaXQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9pbml0U3VjY2Vzcykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluIENocm9tZSwgdGhpcyB3aWxsIHJldHVybiA0IHVuZGVmaW5lZCBpdGVtcyB1bnRpbCBhIGJ1dHRvbiBpcyBwcmVzc2VkXHJcbiAgICAgICAgLy8gSW4gRkYsIHRoaXMgd2lsbCBub3QgcmV0dXJuIGFueSBpdGVtcyB1bnRpbCBhIGJ1dHRvbiBpcyBwcmVzc2VkXHJcbiAgICAgICAgdGhpcy5fb2xkUGFkcyA9IHRoaXMuX2Nsb25lUGFkcyh0aGlzLl9uYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX29sZFBhZHMubGVuZ3RoICYmIHRoaXMuX29sZFBhZHNbMF0pIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdFN1Y2Nlc3MgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgbWluaW11bSBnYW1lcGFkIGNvbmZpZ3VyYXRpb24sIGZvciBleGFtcGxlIHtheGlzOiA0LCBidXR0b25zOiA0fSBtZWFuc1xyXG4gICAgICogdGhpcyBnYW1lIHJlcXVpcmVzIGF0IG1pbmltdW0gNCBheGlzIGlucHV0cyBhbmQgNCBidXR0b25zLCB0aGlzIGlzIG5vdCByZXN0cmljdGl2ZVxyXG4gICAgICogYWxsIG90aGVyIGNvbnRyb2xsZXJzIHdpdGggbW9yZSBheGlzIG9yIGJ1dHRvbnMgYXJlIHZhbGlkIGFzIHdlbGwuIElmIG5vIG1pbmltdW1cclxuICAgICAqIGNvbmZpZ3VyYXRpb24gaXMgc2V0IGFsbCBwYWRzIGFyZSB2YWxpZC5cclxuICAgICAqL1xyXG4gICAgc2V0TWluaW11bUdhbWVwYWRDb25maWd1cmF0aW9uKGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpOyAvLyBpZiBjb25maWcgaXMgdXNlZCwgaW1wbGljaXRseSBlbmFibGVcclxuICAgICAgICB0aGlzLl9taW5pbXVtQ29uZmlndXJhdGlvbiA9IGNvbmZpZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2hlbiBpbXBsaWNpdGx5IGVuYWJsZWQsIHNldCB0aGUgZW5hYmxlZCBmbGFnIGFuZCBydW4gYW4gdXBkYXRlIHNvIGluZm9ybWF0aW9uIGlzIHVwZGF0ZWRcclxuICAgICAqL1xyXG4gICAgX2VuYWJsZUFuZFVwZGF0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGEgbmF2aWdhdG9yIGdhbWVwYWQgYWdhaW5zdCB0aGUgbWluaW11bSBjb25maWd1cmF0aW9uIGlmIHByZXNlbnQuXHJcbiAgICAgKi9cclxuICAgIF9pc0dhbWVwYWRWYWxpZChwYWQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21pbmltdW1Db25maWd1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXBhZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGF4ZXNMZW5ndGggPSBwYWQuYXhlcy5maWx0ZXIoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9KS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgYnV0dG9uTGVuZ3RoID0gcGFkLmJ1dHRvbnMuZmlsdGVyKCh2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgICAgIHJldHVybiBheGVzTGVuZ3RoID49IHRoaXMuX21pbmltdW1Db25maWd1cmF0aW9uLmF4aXMgJiYgYnV0dG9uTGVuZ3RoID49IHRoaXMuX21pbmltdW1Db25maWd1cmF0aW9uLmJ1dHRvbnMgJiYgcGFkLmNvbm5lY3RlZDtcclxuICAgIH1cclxuICAgIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpOyAvLyBpbXBsaWNpdGx5IGVuYWJsZVxyXG4gICAgICAgIHN1cGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBvZmYoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7IC8vIGltcGxpY2l0bHkgZW5hYmxlXHJcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgR2FtZXBhZCBzdGF0ZSBhbmQgcHVibGlzaGVzIEdhbWVwYWQgZXZlbnRzXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5zdXBwb3J0ZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgICAgICBjb25zdCBnYW1lcGFkcyA9IHRoaXMuX25hdmlnYXRvci5nZXRHYW1lcGFkcygpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZ2FtZXBhZHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKCFnYW1lcGFkc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZ2FtZXBhZCA9IHRoaXMuYXQoaSk7XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB3YXMgY29ubmVjdGVkLCBidXQgbm93IGlzbid0IGVtaXQgdGhlIGRpc2Nvbm5lY3QgZXZlbnRcclxuICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkLmNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2Rpc2Nvbm5lY3QnLCBuZXcgR2FtZXBhZERpc2Nvbm5lY3RFdmVudChpLCBnYW1lcGFkKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBSZXNldCBjb25uZWN0aW9uIHN0YXR1c1xyXG4gICAgICAgICAgICAgICAgZ2FtZXBhZC5jb25uZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmF0KGkpLmNvbm5lY3RlZCAmJiB0aGlzLl9pc0dhbWVwYWRWYWxpZChnYW1lcGFkc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdjb25uZWN0JywgbmV3IEdhbWVwYWRDb25uZWN0RXZlbnQoaSwgdGhpcy5hdChpKSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gU2V0IGNvbm5lY3Rpb24gc3RhdHVzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmNvbm5lY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gT25seSBzdXBwb3J0ZWQgaW4gQ2hyb21lXHJcbiAgICAgICAgICAgIGlmIChnYW1lcGFkc1tpXS50aW1lc3RhbXAgJiYgZ2FtZXBhZHNbaV0udGltZXN0YW1wID09PSB0aGlzLl9nYW1lUGFkVGltZVN0YW1wc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZ2FtZVBhZFRpbWVTdGFtcHNbaV0gPSBnYW1lcGFkc1tpXS50aW1lc3RhbXA7XHJcbiAgICAgICAgICAgIC8vIEFkZCByZWZlcmVuY2UgdG8gbmF2aWdhdG9yIGdhbWVwYWRcclxuICAgICAgICAgICAgdGhpcy5hdChpKS5uYXZpZ2F0b3JHYW1lcGFkID0gZ2FtZXBhZHNbaV07XHJcbiAgICAgICAgICAgIC8vIEJ1dHRvbnNcclxuICAgICAgICAgICAgbGV0IGIsIGJpLCBhLCBhaSwgdmFsdWU7XHJcbiAgICAgICAgICAgIGZvciAoYiBpbiBCdXR0b25zKSB7XHJcbiAgICAgICAgICAgICAgICBiaSA9IEJ1dHRvbnNbYl07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChnYW1lcGFkc1tpXS5idXR0b25zW2JpXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdhbWVwYWRzW2ldLmJ1dHRvbnNbYmldLnZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMuX29sZFBhZHNbaV0uZ2V0QnV0dG9uKGJpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLmJ1dHRvbnNbYmldLnByZXNzZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUJ1dHRvbihiaSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2J1dHRvbicsIG5ldyBHYW1lcGFkQnV0dG9uRXZlbnQoYmksIHZhbHVlLCB0aGlzLmF0KGkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUJ1dHRvbihiaSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQXhlc1xyXG4gICAgICAgICAgICBmb3IgKGEgaW4gQXhlcykge1xyXG4gICAgICAgICAgICAgICAgYWkgPSBBeGVzW2FdO1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhaSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdhbWVwYWRzW2ldLmF4ZXNbYWldO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fb2xkUGFkc1tpXS5nZXRBeGVzKGFpKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLnVwZGF0ZUF4ZXMoYWksIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS5ldmVudERpc3BhdGNoZXIuZW1pdCgnYXhpcycsIG5ldyBHYW1lcGFkQXhpc0V2ZW50KGFpLCB2YWx1ZSwgdGhpcy5hdChpKSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9vbGRQYWRzW2ldID0gdGhpcy5fY2xvbmVQYWQoZ2FtZXBhZHNbaV0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZWx5IHJldHJpZXZlcyBhIEdhbWVwYWQgYXQgYSBzcGVjaWZpYyBpbmRleCBhbmQgY3JlYXRlcyBvbmUgaWYgaXQgZG9lc24ndCB5ZXQgZXhpc3RcclxuICAgICAqL1xyXG4gICAgYXQoaW5kZXgpIHtcclxuICAgICAgICB0aGlzLl9lbmFibGVBbmRVcGRhdGUoKTsgLy8gaW1wbGljaXRseSBlbmFibGUgZ2FtZXBhZHMgd2hlbiBhdCgpIGlzIGNhbGxlZFxyXG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLl9wYWRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgYSBwYWQgdG8gcmV0cmlldmVcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX3BhZHMubGVuZ3RoIC0gMSwgbWF4ID0gaW5kZXg7IGkgPCBtYXg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGFkcy5wdXNoKG5ldyBHYW1lcGFkKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fb2xkUGFkcy5wdXNoKG5ldyBHYW1lcGFkKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRzW2luZGV4XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYWxsIHZhbGlkIGdhbWVwYWRzIHRoYXQgbWVldCB0aGUgbWluaW11bSBjb25maWd1cmF0aW9uIHJlcXVpcmVtZW50LlxyXG4gICAgICovXHJcbiAgICBnZXRWYWxpZEdhbWVwYWRzKCkge1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpO1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGFkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNHYW1lcGFkVmFsaWQodGhpcy5hdChpKS5uYXZpZ2F0b3JHYW1lcGFkKSAmJiB0aGlzLmF0KGkpLmNvbm5lY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5hdChpKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgbnVtYmVyIG9mIGNvbm5lY3RlZCBnYW1lcGFkc1xyXG4gICAgICovXHJcbiAgICBjb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFkcy5maWx0ZXIoKHApID0+IHAuY29ubmVjdGVkKS5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBfY2xvbmVQYWRzKHBhZHMpIHtcclxuICAgICAgICBjb25zdCBhcnIgPSBbXTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gcGFkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBhcnIucHVzaCh0aGlzLl9jbG9uZVBhZChwYWRzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhcnI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZhc3Rlc3Qgd2F5IHRvIGNsb25lIGEga25vd24gb2JqZWN0IGlzIHRvIGRvIGl0IHlvdXJzZWxmXHJcbiAgICAgKi9cclxuICAgIF9jbG9uZVBhZChwYWQpIHtcclxuICAgICAgICBsZXQgaSwgbGVuO1xyXG4gICAgICAgIGNvbnN0IGNsb25lZFBhZCA9IG5ldyBHYW1lcGFkKCk7XHJcbiAgICAgICAgaWYgKCFwYWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNsb25lZFBhZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gcGFkLmJ1dHRvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHBhZC5idXR0b25zW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjbG9uZWRQYWQudXBkYXRlQnV0dG9uKGksIHBhZC5idXR0b25zW2ldLnZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYWQuYXhlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjbG9uZWRQYWQudXBkYXRlQXhlcyhpLCBwYWQuYXhlc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjbG9uZWRQYWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSBtaW5pbXVtIHZhbHVlIGFuIGF4aXMgaGFzIHRvIG1vdmUgYmVmb3JlIGNvbnNpZGVyaW5nIGl0IGEgY2hhbmdlXHJcbiAqL1xyXG5HYW1lcGFkcy5NaW5BeGlzTW92ZVRocmVzaG9sZCA9IDAuMDU7XHJcbi8qKlxyXG4gKiBHYW1lcGFkIGhvbGRzIHN0YXRlIGluZm9ybWF0aW9uIGZvciBhIGNvbm5lY3RlZCBjb250cm9sbGVyLiBTZWUgW1tHYW1lcGFkc11dXHJcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhhbmRsaW5nIGNvbnRyb2xsZXIgaW5wdXQuXHJcbiAqL1xyXG5jbGFzcyBHYW1lcGFkIGV4dGVuZHMgQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2J1dHRvbnMgPSBuZXcgQXJyYXkoMTYpO1xyXG4gICAgICAgIHRoaXMuX2F4ZXMgPSBuZXcgQXJyYXkoNCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idXR0b25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2J1dHRvbnNbaV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2F4ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fYXhlc1tpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgZ2l2ZW4gYnV0dG9uIGlzIHByZXNzZWRcclxuICAgICAqIEBwYXJhbSBidXR0b24gICAgIFRoZSBidXR0b24gdG8gcXVlcnlcclxuICAgICAqIEBwYXJhbSB0aHJlc2hvbGQgIFRoZSB0aHJlc2hvbGQgb3ZlciB3aGljaCB0aGUgYnV0dG9uIGlzIGNvbnNpZGVyZWQgdG8gYmUgcHJlc3NlZFxyXG4gICAgICovXHJcbiAgICBpc0J1dHRvblByZXNzZWQoYnV0dG9uLCB0aHJlc2hvbGQgPSAxKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbnNbYnV0dG9uXSA+PSB0aHJlc2hvbGQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGdpdmVuIGJ1dHRvbiB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDFcclxuICAgICAqL1xyXG4gICAgZ2V0QnV0dG9uKGJ1dHRvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9idXR0b25zW2J1dHRvbl07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGdpdmVuIGF4aXMgdmFsdWUgYmV0d2VlbiAtMSBhbmQgMS4gVmFsdWVzIGJlbG93XHJcbiAgICAgKiBbW01pbkF4aXNNb3ZlVGhyZXNob2xkXV0gYXJlIGNvbnNpZGVyZWQgMC5cclxuICAgICAqL1xyXG4gICAgZ2V0QXhlcyhheGVzKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLl9heGVzW2F4ZXNdO1xyXG4gICAgICAgIGlmIChNYXRoLmFicyh2YWx1ZSkgPCBHYW1lcGFkcy5NaW5BeGlzTW92ZVRocmVzaG9sZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVCdXR0b24oYnV0dG9uSW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fYnV0dG9uc1tidXR0b25JbmRleF0gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHVwZGF0ZUF4ZXMoYXhlc0luZGV4LCB2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2F4ZXNbYXhlc0luZGV4XSA9IHZhbHVlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBHYW1lcGFkIEJ1dHRvbnMgZW51bWVyYXRpb25cclxuICovXHJcbnZhciBCdXR0b25zO1xyXG4oZnVuY3Rpb24gKEJ1dHRvbnMpIHtcclxuICAgIC8qKlxyXG4gICAgICogRmFjZSAxIGJ1dHRvbiAoZS5nLiBBKVxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlMVwiXSA9IDBdID0gXCJGYWNlMVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGYWNlIDIgYnV0dG9uIChlLmcuIEIpXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2UyXCJdID0gMV0gPSBcIkZhY2UyXCI7XHJcbiAgICAvKipcclxuICAgICAqIEZhY2UgMyBidXR0b24gKGUuZy4gWClcclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTNcIl0gPSAyXSA9IFwiRmFjZTNcIjtcclxuICAgIC8qKlxyXG4gICAgICogRmFjZSA0IGJ1dHRvbiAoZS5nLiBZKVxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlNFwiXSA9IDNdID0gXCJGYWNlNFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMZWZ0IGJ1bXBlciBidXR0b25cclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiTGVmdEJ1bXBlclwiXSA9IDRdID0gXCJMZWZ0QnVtcGVyXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJpZ2h0IGJ1bXBlciBidXR0b25cclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiUmlnaHRCdW1wZXJcIl0gPSA1XSA9IFwiUmlnaHRCdW1wZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogTGVmdCB0cmlnZ2VyIGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0VHJpZ2dlclwiXSA9IDZdID0gXCJMZWZ0VHJpZ2dlclwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSaWdodCB0cmlnZ2VyIGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodFRyaWdnZXJcIl0gPSA3XSA9IFwiUmlnaHRUcmlnZ2VyXCI7XHJcbiAgICAvKipcclxuICAgICAqIFNlbGVjdCBidXR0b25cclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiU2VsZWN0XCJdID0gOF0gPSBcIlNlbGVjdFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydCBidXR0b25cclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiU3RhcnRcIl0gPSA5XSA9IFwiU3RhcnRcIjtcclxuICAgIC8qKlxyXG4gICAgICogTGVmdCBhbmFsb2cgc3RpY2sgcHJlc3MgKGUuZy4gTDMpXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkxlZnRTdGlja1wiXSA9IDEwXSA9IFwiTGVmdFN0aWNrXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJpZ2h0IGFuYWxvZyBzdGljayBwcmVzcyAoZS5nLiBSMylcclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiUmlnaHRTdGlja1wiXSA9IDExXSA9IFwiUmlnaHRTdGlja1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBELXBhZCB1cFxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkVXBcIl0gPSAxMl0gPSBcIkRwYWRVcFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBELXBhZCBkb3duXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWREb3duXCJdID0gMTNdID0gXCJEcGFkRG93blwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBELXBhZCBsZWZ0XHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWRMZWZ0XCJdID0gMTRdID0gXCJEcGFkTGVmdFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBELXBhZCByaWdodFxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJEcGFkUmlnaHRcIl0gPSAxNV0gPSBcIkRwYWRSaWdodFwiO1xyXG59KShCdXR0b25zIHx8IChCdXR0b25zID0ge30pKTtcclxuLyoqXHJcbiAqIEdhbWVwYWQgQXhlcyBlbnVtZXJhdGlvblxyXG4gKi9cclxudmFyIEF4ZXM7XHJcbihmdW5jdGlvbiAoQXhlcykge1xyXG4gICAgLyoqXHJcbiAgICAgKiBMZWZ0IGFuYWxvZ3VlIHN0aWNrIFggZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIEF4ZXNbQXhlc1tcIkxlZnRTdGlja1hcIl0gPSAwXSA9IFwiTGVmdFN0aWNrWFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMZWZ0IGFuYWxvZ3VlIHN0aWNrIFkgZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIEF4ZXNbQXhlc1tcIkxlZnRTdGlja1lcIl0gPSAxXSA9IFwiTGVmdFN0aWNrWVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSaWdodCBhbmFsb2d1ZSBzdGljayBYIGRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBBeGVzW0F4ZXNbXCJSaWdodFN0aWNrWFwiXSA9IDJdID0gXCJSaWdodFN0aWNrWFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSaWdodCBhbmFsb2d1ZSBzdGljayBZIGRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBBeGVzW0F4ZXNbXCJSaWdodFN0aWNrWVwiXSA9IDNdID0gXCJSaWdodFN0aWNrWVwiO1xyXG59KShBeGVzIHx8IChBeGVzID0ge30pKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL0Jyb3dzZXIudHNcbmNsYXNzIEJyb3dzZXJDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IobmF0aXZlQ29tcG9uZW50KSB7XHJcbiAgICAgICAgdGhpcy5uYXRpdmVDb21wb25lbnQgPSBuYXRpdmVDb21wb25lbnQ7XHJcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbmF0aXZlSGFuZGxlcnMgPSB7fTtcclxuICAgIH1cclxuICAgIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIGlmICh0aGlzLl9uYXRpdmVIYW5kbGVyc1tldmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgdGhpcy5fbmF0aXZlSGFuZGxlcnNbZXZlbnROYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX25hdGl2ZUhhbmRsZXJzW2V2ZW50TmFtZV0gPSB0aGlzLl9kZWNvcmF0ZShoYW5kbGVyKTtcclxuICAgICAgICB0aGlzLm5hdGl2ZUNvbXBvbmVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdGhpcy5fbmF0aXZlSGFuZGxlcnNbZXZlbnROYW1lXSk7XHJcbiAgICB9XHJcbiAgICBvZmYoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKCFoYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIgPSB0aGlzLl9uYXRpdmVIYW5kbGVyc1tldmVudE5hbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm5hdGl2ZUNvbXBvbmVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgdGhpcy5fbmF0aXZlSGFuZGxlcnNbZXZlbnROYW1lXSA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBfZGVjb3JhdGUoaGFuZGxlcikge1xyXG4gICAgICAgIHJldHVybiAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICBoYW5kbGVyKGV2dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcGF1c2UoKSB7XHJcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc3VtZSgpIHtcclxuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgaW4gdGhpcy5fbmF0aXZlSGFuZGxlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5vZmYoZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBCcm93c2VyRXZlbnRzIHtcclxuICAgIGNvbnN0cnVjdG9yKF93aW5kb3dHbG9iYWwsIF9kb2N1bWVudEdsb2JhbCkge1xyXG4gICAgICAgIHRoaXMuX3dpbmRvd0dsb2JhbCA9IF93aW5kb3dHbG9iYWw7XHJcbiAgICAgICAgdGhpcy5fZG9jdW1lbnRHbG9iYWwgPSBfZG9jdW1lbnRHbG9iYWw7XHJcbiAgICAgICAgdGhpcy5fd2luZG93Q29tcG9uZW50ID0gbmV3IEJyb3dzZXJDb21wb25lbnQodGhpcy5fd2luZG93R2xvYmFsKTtcclxuICAgICAgICB0aGlzLl9kb2N1bWVudENvbXBvbmVudCA9IG5ldyBCcm93c2VyQ29tcG9uZW50KHRoaXMuX2RvY3VtZW50R2xvYmFsKTtcclxuICAgIH1cclxuICAgIGdldCB3aW5kb3coKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dpbmRvd0NvbXBvbmVudDtcclxuICAgIH1cclxuICAgIGdldCBkb2N1bWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZG9jdW1lbnRDb21wb25lbnQ7XHJcbiAgICB9XHJcbiAgICBwYXVzZSgpIHtcclxuICAgICAgICB0aGlzLndpbmRvdy5wYXVzZSgpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnQucGF1c2UoKTtcclxuICAgIH1cclxuICAgIHJlc3VtZSgpIHtcclxuICAgICAgICB0aGlzLndpbmRvdy5yZXN1bWUoKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50LnJlc3VtZSgpO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy53aW5kb3cuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLmRvY3VtZW50LmNsZWFyKCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzLnRzXG5cclxuXHJcblxyXG5cclxuY2xhc3MgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNEZWJ1ZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihfZXgpIHtcclxuICAgICAgICB0aGlzLl9leCA9IF9leDtcclxuICAgICAgICB0aGlzLl9kZWJ1Z1RleHQgPSBuZXcgRGVidWdUZXh0KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXcgYSBkZWJ1ZyByZWN0YW5nbGUgdG8gdGhlIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICogQHBhcmFtIHdpZHRoXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0XHJcbiAgICAgKi9cclxuICAgIGRyYXdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguc3Ryb2tlU3R5bGUgPSAncmVkJztcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5zdHJva2VSZWN0KHRoaXMuX2V4LnNuYXBUb1BpeGVsID8gfn54IDogeCwgdGhpcy5fZXguc25hcFRvUGl4ZWwgPyB+fnkgOiB5LCB0aGlzLl9leC5zbmFwVG9QaXhlbCA/IH5+d2lkdGggOiB3aWR0aCwgdGhpcy5fZXguc25hcFRvUGl4ZWwgPyB+fmhlaWdodCA6IGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gICAgZHJhd0xpbmUoc3RhcnQsIGVuZCwgbGluZU9wdGlvbnMgPSB7IGNvbG9yOiBDb2xvci5CbGFjayB9KSB7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LnN0cm9rZVN0eWxlID0gbGluZU9wdGlvbnMuY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5tb3ZlVG8odGhpcy5fZXguc25hcFRvUGl4ZWwgPyB+fnN0YXJ0LnggOiBzdGFydC54LCB0aGlzLl9leC5zbmFwVG9QaXhlbCA/IH5+c3RhcnQueSA6IHN0YXJ0LnkpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LmxpbmVUbyh0aGlzLl9leC5zbmFwVG9QaXhlbCA/IH5+ZW5kLnggOiBlbmQueCwgdGhpcy5fZXguc25hcFRvUGl4ZWwgPyB+fmVuZC55IDogZW5kLnkpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gICAgZHJhd1BvaW50KHBvaW50LCBwb2ludE9wdGlvbnMgPSB7IGNvbG9yOiBDb2xvci5CbGFjaywgc2l6ZTogNSB9KSB7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LmZpbGxTdHlsZSA9IHBvaW50T3B0aW9ucy5jb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LmFyYyh0aGlzLl9leC5zbmFwVG9QaXhlbCA/IH5+cG9pbnQueCA6IHBvaW50LngsIHRoaXMuX2V4LnNuYXBUb1BpeGVsID8gfn5wb2ludC55IDogcG9pbnQueSwgcG9pbnRPcHRpb25zLnNpemUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5maWxsKCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gICAgZHJhd1RleHQodGV4dCwgcG9zKSB7XHJcbiAgICAgICAgdGhpcy5fZGVidWdUZXh0LndyaXRlKHRoaXMuX2V4LCB0ZXh0LCBwb3MpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IENvbG9yLkV4Y2FsaWJ1ckJsdWU7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgU3RhdGVTdGFjaygpO1xyXG4gICAgICAgIHRoaXMuc25hcFRvUGl4ZWwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZGVidWcgPSBuZXcgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXNEZWJ1Zyh0aGlzKTtcclxuICAgICAgICBjb25zdCB7IGNhbnZhc0VsZW1lbnQsIGVuYWJsZVRyYW5zcGFyZW5jeSwgc25hcFRvUGl4ZWwsIHNtb290aGluZywgYmFja2dyb3VuZENvbG9yIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuX19jdHggPSBjYW52YXNFbGVtZW50LmdldENvbnRleHQoJzJkJywge1xyXG4gICAgICAgICAgICBhbHBoYTogZW5hYmxlVHJhbnNwYXJlbmN5ICE9PSBudWxsICYmIGVuYWJsZVRyYW5zcGFyZW5jeSAhPT0gdm9pZCAwID8gZW5hYmxlVHJhbnNwYXJlbmN5IDogdHJ1ZVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yICE9PSBudWxsICYmIGJhY2tncm91bmRDb2xvciAhPT0gdm9pZCAwID8gYmFja2dyb3VuZENvbG9yIDogdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgdGhpcy5zbmFwVG9QaXhlbCA9IHNuYXBUb1BpeGVsICE9PSBudWxsICYmIHNuYXBUb1BpeGVsICE9PSB2b2lkIDAgPyBzbmFwVG9QaXhlbCA6IHRoaXMuc25hcFRvUGl4ZWw7XHJcbiAgICAgICAgdGhpcy5zbW9vdGhpbmcgPSBzbW9vdGhpbmcgIT09IG51bGwgJiYgc21vb3RoaW5nICE9PSB2b2lkIDAgPyBzbW9vdGhpbmcgOiB0aGlzLnNtb290aGluZztcclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2N0eC5jYW52YXMud2lkdGg7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fY3R4LmNhbnZhcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBnZXQgb3BhY2l0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGUuY3VycmVudC5vcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgc2V0IG9wYWNpdHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZS5jdXJyZW50Lm9wYWNpdHkgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBzbW9vdGhpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkO1xyXG4gICAgfVxyXG4gICAgc2V0IHNtb290aGluZyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX19jdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICByZXNldFRyYW5zZm9ybSgpIHtcclxuICAgICAgICB0aGlzLl9fY3R4LnJlc2V0VHJhbnNmb3JtKCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVWaWV3cG9ydCgpIHtcclxuICAgICAgICAvLyBwYXNzXHJcbiAgICB9XHJcbiAgICBkcmF3SW1hZ2UoaW1hZ2UsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0LCBkeCwgZHksIGR3aWR0aCwgZGhlaWdodCkge1xyXG4gICAgICAgIGlmIChzd2lkdGggPT09IDAgfHwgc2hlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIHplcm8gZGltZW5zaW9uIGRlc3QgZXhpdCBlYXJseVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChkd2lkdGggPT09IDAgfHwgZGhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIHplcm8gZGltZW5zaW9uIGRlc3QgZXhpdCBlYXJseVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpbWFnZS53aWR0aCA9PT0gMCB8fCBpbWFnZS5oZWlnaHQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyB6ZXJvIGRpbWVuc2lvbiBzb3VyY2UgZXhpdCBlYXJseVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9fY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbaW1hZ2UsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0LCBkeCwgZHksIGR3aWR0aCwgZGhlaWdodF1cclxuICAgICAgICAgICAgLmZpbHRlcigoYSkgPT4gYSAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICAubWFwKChhKSA9PiAodHlwZW9mIGEgPT09ICdudW1iZXInICYmIHRoaXMuc25hcFRvUGl4ZWwgPyB+fmEgOiBhKSk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5kcmF3SW1hZ2UuYXBwbHkodGhpcy5fX2N0eCwgYXJncyk7XHJcbiAgICAgICAgR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3Q2FsbENvdW50Kys7XHJcbiAgICAgICAgR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3bkltYWdlc0NvdW50ID0gMTtcclxuICAgIH1cclxuICAgIGRyYXdMaW5lKHN0YXJ0LCBlbmQsIGNvbG9yLCB0aGlja25lc3MgPSAxKSB7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLl9fY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLl9fY3R4Lm1vdmVUbyh0aGlzLnNuYXBUb1BpeGVsID8gfn5zdGFydC54IDogc3RhcnQueCwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+c3RhcnQueSA6IHN0YXJ0LnkpO1xyXG4gICAgICAgIHRoaXMuX19jdHgubGluZVRvKHRoaXMuc25hcFRvUGl4ZWwgPyB+fmVuZC54IDogZW5kLngsIHRoaXMuc25hcFRvUGl4ZWwgPyB+fmVuZC55IDogZW5kLnkpO1xyXG4gICAgICAgIHRoaXMuX19jdHgubGluZVdpZHRoID0gdGhpY2tuZXNzO1xyXG4gICAgICAgIHRoaXMuX19jdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLl9fY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIGRyYXdSZWN0YW5nbGUocG9zLCB3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xyXG4gICAgICAgIHRoaXMuX19jdHguc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuX19jdHguZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLl9fY3R4LmZpbGxSZWN0KHRoaXMuc25hcFRvUGl4ZWwgPyB+fnBvcy54IDogcG9zLngsIHRoaXMuc25hcFRvUGl4ZWwgPyB+fnBvcy55IDogcG9zLnksIHRoaXMuc25hcFRvUGl4ZWwgPyB+fndpZHRoIDogd2lkdGgsIHRoaXMuc25hcFRvUGl4ZWwgPyB+fmhlaWdodCA6IGhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgICBkcmF3Q2lyY2xlKHBvcywgcmFkaXVzLCBjb2xvcikge1xyXG4gICAgICAgIHRoaXMuX19jdHguc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuX19jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX19jdHguYXJjKHRoaXMuc25hcFRvUGl4ZWwgPyB+fnBvcy54IDogcG9zLngsIHRoaXMuc25hcFRvUGl4ZWwgPyB+fnBvcy55IDogcG9zLnksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgIHRoaXMuX19jdHguZmlsbCgpO1xyXG4gICAgICAgIHRoaXMuX19jdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhdmUgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNhbnZhcyB0byB0aGUgc3RhY2sgKHRyYW5zZm9ybXMgYW5kIG9wYWNpdHkpXHJcbiAgICAgKi9cclxuICAgIHNhdmUoKSB7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5zYXZlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBjYW52YXMgZnJvbSB0aGUgc3RhY2tcclxuICAgICAqL1xyXG4gICAgcmVzdG9yZSgpIHtcclxuICAgICAgICB0aGlzLl9fY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNsYXRlIHRoZSBvcmlnaW4gb2YgdGhlIGNvbnRleHQgYnkgYW4geCBhbmQgeVxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKi9cclxuICAgIHRyYW5zbGF0ZSh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5fX2N0eC50cmFuc2xhdGUodGhpcy5zbmFwVG9QaXhlbCA/IH5+eCA6IHgsIHRoaXMuc25hcFRvUGl4ZWwgPyB+fnkgOiB5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlIHRoZSBjb250ZXh0IGFib3V0IHRoZSBjdXJyZW50IG9yaWdpblxyXG4gICAgICovXHJcbiAgICByb3RhdGUoYW5nbGUpIHtcclxuICAgICAgICB0aGlzLl9fY3R4LnJvdGF0ZShhbmdsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNjYWxlIHRoZSBjb250ZXh0IGJ5IGFuIHggYW5kIHkgZmFjdG9yXHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgc2NhbGUoeCwgeSkge1xyXG4gICAgICAgIHRoaXMuX19jdHguc2NhbGUoeCwgeSk7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICAvLyBDbGVhciBmcmFtZVxyXG4gICAgICAgIHRoaXMuX19jdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9fY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5maWxsUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgR3JhcGhpY3NEaWFnbm9zdGljcy5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGbHVzaGVzIHRoZSBiYXRjaGVkIGRyYXcgY2FsbHMgdG8gdGhlIHNjcmVlblxyXG4gICAgICovXHJcbiAgICBmbHVzaCgpIHtcclxuICAgICAgICAvLyBwYXNzXHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FbmdpbmUudHNcbnZhciBFbmdpbmVfZGVjb3JhdGUgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcblxyXG5cclxuXHJcbnBvbHlmaWxsKCk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgbW91c2V3aGVlbCBldmVudCBidWJibGUgcHJldmVudGlvblxyXG4gKi9cclxudmFyIFNjcm9sbFByZXZlbnRpb25Nb2RlO1xyXG4oZnVuY3Rpb24gKFNjcm9sbFByZXZlbnRpb25Nb2RlKSB7XHJcbiAgICAvKipcclxuICAgICAqIERvIG5vdCBwcmV2ZW50IGFueSBwYWdlIHNjcm9sbGluZ1xyXG4gICAgICovXHJcbiAgICBTY3JvbGxQcmV2ZW50aW9uTW9kZVtTY3JvbGxQcmV2ZW50aW9uTW9kZVtcIk5vbmVcIl0gPSAwXSA9IFwiTm9uZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmV2ZW50IHBhZ2Ugc2Nyb2xsIGlmIG1vdXNlIGlzIG92ZXIgdGhlIGdhbWUgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIFNjcm9sbFByZXZlbnRpb25Nb2RlW1Njcm9sbFByZXZlbnRpb25Nb2RlW1wiQ2FudmFzXCJdID0gMV0gPSBcIkNhbnZhc1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBQcmV2ZW50IGFsbCBwYWdlIHNjcm9sbGluZyB2aWEgbW91c2Ugd2hlZWxcclxuICAgICAqL1xyXG4gICAgU2Nyb2xsUHJldmVudGlvbk1vZGVbU2Nyb2xsUHJldmVudGlvbk1vZGVbXCJBbGxcIl0gPSAyXSA9IFwiQWxsXCI7XHJcbn0pKFNjcm9sbFByZXZlbnRpb25Nb2RlIHx8IChTY3JvbGxQcmV2ZW50aW9uTW9kZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgRXhjYWxpYnVyIEVuZ2luZVxyXG4gKlxyXG4gKiBUaGUgW1tFbmdpbmVdXSBpcyB0aGUgbWFpbiBkcml2ZXIgZm9yIGEgZ2FtZS4gSXQgaXMgcmVzcG9uc2libGUgZm9yXHJcbiAqIHN0YXJ0aW5nL3N0b3BwaW5nIHRoZSBnYW1lLCBtYWludGFpbmluZyBzdGF0ZSwgdHJhbnNtaXR0aW5nIGV2ZW50cyxcclxuICogbG9hZGluZyByZXNvdXJjZXMsIGFuZCBtYW5hZ2luZyB0aGUgc2NlbmUuXHJcbiAqL1xyXG5jbGFzcyBFbmdpbmUgZXh0ZW5kcyBDbGFzcyB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgZ2FtZSB1c2luZyB0aGUgZ2l2ZW4gW1tFbmdpbmVPcHRpb25zXV0uIEJ5IGRlZmF1bHQsIGlmIG5vIG9wdGlvbnMgYXJlIHByb3ZpZGVkLFxyXG4gICAgICogdGhlIGdhbWUgd2lsbCBiZSByZW5kZXJlZCBmdWxsIHNjcmVlbiAodGFraW5nIHVwIGFsbCBhdmFpbGFibGUgYnJvd3NlciB3aW5kb3cgc3BhY2UpLlxyXG4gICAgICogWW91IGNhbiBjdXN0b21pemUgdGhlIGdhbWUgcmVuZGVyaW5nIHRocm91Z2ggW1tFbmdpbmVPcHRpb25zXV0uXHJcbiAgICAgKlxyXG4gICAgICogRXhhbXBsZTpcclxuICAgICAqXHJcbiAgICAgKiBgYGBqc1xyXG4gICAgICogdmFyIGdhbWUgPSBuZXcgZXguRW5naW5lKHtcclxuICAgICAqICAgd2lkdGg6IDAsIC8vIHRoZSB3aWR0aCBvZiB0aGUgY2FudmFzXHJcbiAgICAgKiAgIGhlaWdodDogMCwgLy8gdGhlIGhlaWdodCBvZiB0aGUgY2FudmFzXHJcbiAgICAgKiAgIGVuYWJsZUNhbnZhc1RyYW5zcGFyZW5jeTogdHJ1ZSwgLy8gdGhlIHRyYW5zcGFyZW5jeVNlY3Rpb24gb2YgdGhlIGNhbnZhc1xyXG4gICAgICogICBjYW52YXNFbGVtZW50SWQ6ICcnLCAvLyB0aGUgRE9NIGNhbnZhcyBlbGVtZW50IElELCBpZiB5b3UgYXJlIHByb3ZpZGluZyB5b3VyIG93blxyXG4gICAgICogICBkaXNwbGF5TW9kZTogZXguRGlzcGxheU1vZGUuRnVsbFNjcmVlbiwgLy8gdGhlIGRpc3BsYXkgbW9kZVxyXG4gICAgICogICBwb2ludGVyU2NvcGU6IGV4LklucHV0LlBvaW50ZXJTY29wZS5Eb2N1bWVudCwgLy8gdGhlIHNjb3BlIG9mIGNhcHR1cmluZyBwb2ludGVyIChtb3VzZS90b3VjaCkgZXZlbnRzXHJcbiAgICAgKiAgIGJhY2tncm91bmRDb2xvcjogZXguQ29sb3IuZnJvbUhleCgnIzIxODVkMCcpIC8vIGJhY2tncm91bmQgY29sb3Igb2YgdGhlIGVuZ2luZVxyXG4gICAgICogfSk7XHJcbiAgICAgKlxyXG4gICAgICogLy8gY2FsbCBnYW1lLnN0YXJ0LCB3aGljaCBpcyBhIFByb21pc2VcclxuICAgICAqIGdhbWUuc3RhcnQoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAqICAgLy8gcmVhZHksIHNldCwgZ28hXHJcbiAgICAgKiB9KTtcclxuICAgICAqIGBgYFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9oYXNTdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBsaXN0IG9mIHBvc3QgcHJvY2Vzc29ycyB0byBhcHBseSBhdCB0aGUgZW5kIG9mIGRyYXdpbmcgYSBmcmFtZSAoc3VjaCBhcyBbW0NvbG9yQmxpbmRDb3JyZWN0b3JdXSlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBvc3RQcm9jZXNzb3JzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29udGFpbnMgYWxsIHRoZSBzY2VuZXMgY3VycmVudGx5IHJlZ2lzdGVyZWQgd2l0aCBFeGNhbGlidXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjZW5lcyA9IHt9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBoaWRkZW5cclxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9zdXBwcmVzc1BsYXlCdXR0b24gPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBhdWRpbyBzaG91bGQgYmUgcGF1c2VkIHdoZW4gdGhlIGdhbWUgaXMgbm8gbG9uZ2VyIHZpc2libGUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYXVzZUF1ZGlvV2hlbkhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVuZ2luZSBzaG91bGQgZHJhdyB3aXRoIGRlYnVnIGluZm9ybWF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5faXNEZWJ1ZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZGVidWdDb2xvciA9IG5ldyBDb2xvcigyNTUsIDI1NSwgMjU1KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTZXRzIHRoZSBUcmFuc3BhcmVuY3kgZm9yIHRoZSBlbmdpbmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmFibGVDYW52YXNUcmFuc3BhcmVuY3kgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhY3Rpb24gdG8gdGFrZSB3aGVuIGEgZmF0YWwgZXhjZXB0aW9uIGlzIHRocm93blxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub25GYXRhbEV4Y2VwdGlvbiA9IChlKSA9PiB7XHJcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmZhdGFsKGUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fdGltZXNjYWxlID0gMS4wO1xyXG4gICAgICAgIHRoaXMuX2lzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kZWZlcnJlZEdvVG8gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2xvYWRpbmdDb21wbGV0ZSA9IGZhbHNlO1xyXG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIEVuZ2luZS5fREVGQVVMVF9FTkdJTkVfT1BUSU9OUyksIG9wdGlvbnMpO1xyXG4gICAgICAgIEZsYWdzLmZyZWV6ZSgpO1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgYnJvd3NlciBldmVudHMgZmFjYWRlXHJcbiAgICAgICAgdGhpcy5icm93c2VyID0gbmV3IEJyb3dzZXJFdmVudHMod2luZG93LCBkb2N1bWVudCk7XHJcbiAgICAgICAgLy8gQ2hlY2sgY29tcGF0aWJpbGl0eVxyXG4gICAgICAgIGNvbnN0IGRldGVjdG9yID0gbmV3IERldGVjdG9yKCk7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLnN1cHByZXNzTWluaW11bUJyb3dzZXJGZWF0dXJlRGV0ZWN0aW9uICYmICEodGhpcy5fY29tcGF0aWJsZSA9IGRldGVjdG9yLnRlc3QoKSkpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICBtZXNzYWdlLmlubmVyVGV4dCA9ICdTb3JyeSwgeW91ciBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYWxsIHRoZSBmZWF0dXJlcyBuZWVkZWQgZm9yIEV4Y2FsaWJ1cic7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIGRldGVjdG9yLmZhaWxlZFRlc3RzLmZvckVhY2goZnVuY3Rpb24gKHRlc3QpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RNZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgICAgICB0ZXN0TWVzc2FnZS5pbm5lclRleHQgPSAnQnJvd3NlciBmZWF0dXJlIG1pc3NpbmcgJyArIHRlc3Q7XHJcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRlc3RNZXNzYWdlKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5jYW52YXNFbGVtZW50SWQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNhbnZhcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKGNhbnZhcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcGF0aWJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVzZSBuYXRpdmUgY29uc29sZSBBUEkgZm9yIGNvbG9yIGZ1blxyXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgICAgaWYgKGNvbnNvbGUubG9nICYmICFvcHRpb25zLnN1cHByZXNzQ29uc29sZUJvb3RNZXNzYWdlKSB7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGAlY1Bvd2VyZWQgYnkgRXhjYWxpYnVyLmpzICh2JHtFWF9WRVJTSU9OfSlgLCAnYmFja2dyb3VuZDogIzE3NkJBQTsgY29sb3I6IHdoaXRlOyBib3JkZXItcmFkaXVzOiA1cHg7IHBhZGRpbmc6IDE1cHg7IGZvbnQtc2l6ZTogMS41ZW07IGxpbmUtaGVpZ2h0OiA4MHB4OycpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnXFxuXFxcclxuICAgICAgL3wgX19fX19fX19fX19fX19fX1xcblxcXHJcbk98PT09fCogPl9fX19fX19fX19fX19fX18+XFxuXFxcclxuICAgICAgXFxcXHwnKTtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1Zpc2l0JywgJ2h0dHA6Ly9leGNhbGlidXJqcy5jb20nLCAnZm9yIG1vcmUgaW5mb3JtYXRpb24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU3VwcHJlc3MgcGxheSBidXR0b25cclxuICAgICAgICBpZiAob3B0aW9ucy5zdXBwcmVzc1BsYXlCdXR0b24pIHtcclxuICAgICAgICAgICAgdGhpcy5fc3VwcHJlc3NQbGF5QnV0dG9uID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgLy8gSWYgZGVidWcgaXMgZW5hYmxlZCwgbGV0J3MgbG9nIGJyb3dzZXIgZmVhdHVyZXMgdG8gdGhlIGNvbnNvbGUuXHJcbiAgICAgICAgaWYgKHRoaXMuX2xvZ2dlci5kZWZhdWx0TGV2ZWwgPT09IExvZ0xldmVsLkRlYnVnKSB7XHJcbiAgICAgICAgICAgIGRldGVjdG9yLmxvZ0Jyb3dzZXJGZWF0dXJlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0J1aWxkaW5nIGVuZ2luZS4uLicpO1xyXG4gICAgICAgIHRoaXMuY2FudmFzRWxlbWVudElkID0gb3B0aW9ucy5jYW52YXNFbGVtZW50SWQ7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMuY2FudmFzRWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnVXNpbmcgQ2FudmFzIGVsZW1lbnQgc3BlY2lmaWVkOiAnICsgb3B0aW9ucy5jYW52YXNFbGVtZW50SWQpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG9wdGlvbnMuY2FudmFzRWxlbWVudElkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5jYW52YXNFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnVXNpbmcgQ2FudmFzIGVsZW1lbnQgc3BlY2lmaWVkOicsIG9wdGlvbnMuY2FudmFzRWxlbWVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gb3B0aW9ucy5jYW52YXNFbGVtZW50O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdVc2luZyBnZW5lcmF0ZWQgY2FudmFzIGVsZW1lbnQnKTtcclxuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGRpc3BsYXlNb2RlID0gKF9hID0gb3B0aW9ucy5kaXNwbGF5TW9kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogRGlzcGxheU1vZGUuRml4ZWQ7XHJcbiAgICAgICAgaWYgKChvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0KSB8fCBvcHRpb25zLnZpZXdwb3J0KSB7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmRpc3BsYXlNb2RlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIGRpc3BsYXlNb2RlID0gRGlzcGxheU1vZGUuRml4ZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdFbmdpbmUgdmlld3BvcnQgaXMgc2l6ZSAnICsgb3B0aW9ucy53aWR0aCArICcgeCAnICsgb3B0aW9ucy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICghb3B0aW9ucy5kaXNwbGF5TW9kZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0VuZ2luZSB2aWV3cG9ydCBpcyBmaXQnKTtcclxuICAgICAgICAgICAgZGlzcGxheU1vZGUgPSBEaXNwbGF5TW9kZS5GaXRTY3JlZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChGbGFncy5pc0VuYWJsZWQoTGVnYWN5LkNhbnZhcykpIHtcclxuICAgICAgICAgICAgY29uc3QgZXgyZEN0eCA9IG5ldyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhcyh7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNFbGVtZW50OiB0aGlzLmNhbnZhcyxcclxuICAgICAgICAgICAgICAgIGVuYWJsZVRyYW5zcGFyZW5jeTogdGhpcy5lbmFibGVDYW52YXNUcmFuc3BhcmVuY3ksXHJcbiAgICAgICAgICAgICAgICBzbW9vdGhpbmc6IG9wdGlvbnMuYW50aWFsaWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgICAgIHNuYXBUb1BpeGVsOiBvcHRpb25zLnNuYXBUb1BpeGVsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dCA9IGV4MmRDdHg7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gZXgyZEN0eC5fX2N0eDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGV4V2ViZ2xDdHggPSBuZXcgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0woe1xyXG4gICAgICAgICAgICAgICAgY2FudmFzRWxlbWVudDogdGhpcy5jYW52YXMsXHJcbiAgICAgICAgICAgICAgICBlbmFibGVUcmFuc3BhcmVuY3k6IHRoaXMuZW5hYmxlQ2FudmFzVHJhbnNwYXJlbmN5LFxyXG4gICAgICAgICAgICAgICAgc21vb3RoaW5nOiBvcHRpb25zLmFudGlhbGlhc2luZyxcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXHJcbiAgICAgICAgICAgICAgICBzbmFwVG9QaXhlbDogb3B0aW9ucy5zbmFwVG9QaXhlbFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0NvbnRleHQgPSBleFdlYmdsQ3R4O1xyXG4gICAgICAgICAgICB0aGlzLmN0eCA9IGV4V2ViZ2xDdHguX19jdHg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2NyZWVuID0gbmV3IFNjcmVlbih7XHJcbiAgICAgICAgICAgIGNhbnZhczogdGhpcy5jYW52YXMsXHJcbiAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuZ3JhcGhpY3NDb250ZXh0LFxyXG4gICAgICAgICAgICBhbnRpYWxpYXNpbmc6IChfYiA9IG9wdGlvbnMuYW50aWFsaWFzaW5nKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlLFxyXG4gICAgICAgICAgICBicm93c2VyOiB0aGlzLmJyb3dzZXIsXHJcbiAgICAgICAgICAgIHZpZXdwb3J0OiAoX2MgPSBvcHRpb25zLnZpZXdwb3J0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAob3B0aW9ucy53aWR0aCAmJiBvcHRpb25zLmhlaWdodCA/IHsgd2lkdGg6IG9wdGlvbnMud2lkdGgsIGhlaWdodDogb3B0aW9ucy5oZWlnaHQgfSA6IFJlc29sdXRpb24uU1ZHQSksXHJcbiAgICAgICAgICAgIHJlc29sdXRpb246IG9wdGlvbnMucmVzb2x1dGlvbixcclxuICAgICAgICAgICAgZGlzcGxheU1vZGUsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uOiBvcHRpb25zLnBvc2l0aW9uLFxyXG4gICAgICAgICAgICBwaXhlbFJhdGlvOiBvcHRpb25zLnN1cHByZXNzSGlEUElTY2FsaW5nID8gMSA6IG51bGxcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAob3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IpIHtcclxuICAgICAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBvcHRpb25zLmJhY2tncm91bmRDb2xvci5jbG9uZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVuYWJsZUNhbnZhc1RyYW5zcGFyZW5jeSA9IG9wdGlvbnMuZW5hYmxlQ2FudmFzVHJhbnNwYXJlbmN5O1xyXG4gICAgICAgIHRoaXMuX2xvYWRlciA9IG5ldyBMb2FkZXIoKTtcclxuICAgICAgICB0aGlzLmRlYnVnID0gbmV3IERlYnVnKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemUob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5yb290U2NlbmUgPSB0aGlzLmN1cnJlbnRTY2VuZSA9IG5ldyBTY2VuZSgpO1xyXG4gICAgICAgIHRoaXMuYWRkU2NlbmUoJ3Jvb3QnLCB0aGlzLnJvb3RTY2VuZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgZ2FtZSBjYW52YXMgaW4gcGl4ZWxzIChwaHlzaWNhbCB3aWR0aCBjb21wb25lbnQgb2YgdGhlXHJcbiAgICAgKiByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgZWxlbWVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbnZhc1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5jYW52YXNXaWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBoYWxmIHdpZHRoIG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKGhhbGYgcGh5c2ljYWwgd2lkdGggY29tcG9uZW50KVxyXG4gICAgICovXHJcbiAgICBnZXQgaGFsZkNhbnZhc1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5oYWxmQ2FudmFzV2lkdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBoZWlnaHQgb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscywgKHBoeXNpY2FsIGhlaWdodCBjb21wb25lbnQgb2ZcclxuICAgICAqIHRoZSByZXNvbHV0aW9uIG9mIHRoZSBjYW52YXMgZWxlbWVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbnZhc0hlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uY2FudmFzSGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhhbGYgaGVpZ2h0IG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKGhhbGYgcGh5c2ljYWwgaGVpZ2h0IGNvbXBvbmVudClcclxuICAgICAqL1xyXG4gICAgZ2V0IGhhbGZDYW52YXNIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmhhbGZDYW52YXNIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdpZHRoIG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyYXdXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uZHJhd1dpZHRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhhbGYgdGhlIHdpZHRoIG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhhbGZEcmF3V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmhhbGZEcmF3V2lkdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGhlaWdodCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgKi9cclxuICAgIGdldCBkcmF3SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5kcmF3SGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhhbGYgdGhlIGhlaWdodCBvZiB0aGUgZW5naW5lJ3MgdmlzaWJsZSBkcmF3aW5nIHN1cmZhY2UgaW4gcGl4ZWxzIGluY2x1ZGluZyB6b29tIGFuZCBkZXZpY2UgcGl4ZWwgcmF0aW8uXHJcbiAgICAgKi9cclxuICAgIGdldCBoYWxmRHJhd0hlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgd2hldGhlciBleGNhbGlidXIgZGV0ZWN0cyB0aGUgY3VycmVudCBzY3JlZW4gdG8gYmUgSGlEUElcclxuICAgICAqL1xyXG4gICAgZ2V0IGlzSGlEcGkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmlzSGlEcGk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjY2VzcyBbW3N0YXRzXV0gdGhhdCBob2xkcyBmcmFtZSBzdGF0aXN0aWNzLlxyXG4gICAgICovXHJcbiAgICBnZXQgc3RhdHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVidWcuc3RhdHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBlbmdpbmUgaXMgc2V0IHRvIGZ1bGxzY3JlZW4gb3Igbm90XHJcbiAgICAgKi9cclxuICAgIGdldCBpc0Z1bGxzY3JlZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmlzRnVsbFNjcmVlbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHRoZSBjdXJyZW50IFtbRGlzcGxheU1vZGVdXSBvZiB0aGUgZW5naW5lLlxyXG4gICAgICovXHJcbiAgICBnZXQgZGlzcGxheU1vZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmRpc3BsYXlNb2RlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHBpeGVsIHJhdGlvbiBmb3IgdXNlIGluIHJlbmRlcmluZ1xyXG4gICAgICovXHJcbiAgICBnZXQgcGl4ZWxSYXRpbygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4ucGl4ZWxSYXRpbztcclxuICAgIH1cclxuICAgIGdldCBpc0RlYnVnKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RlYnVnO1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub25jZShldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgQm91bmRpbmdCb3ggb2YgdGhlIHRvcCBsZWZ0IGNvcm5lciBvZiB0aGUgc2NyZWVuXHJcbiAgICAgKiBhbmQgdGhlIGJvdHRvbSByaWdodCBjb3JuZXIgb2YgdGhlIHNjcmVlbi5cclxuICAgICAqL1xyXG4gICAgZ2V0V29ybGRCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmdldFdvcmxkQm91bmRzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgZW5naW5lIHRpbWVzY2FsZSBmYWN0b3IgKGRlZmF1bHQgaXMgMS4wIHdoaWNoIGlzIDE6MSB0aW1lKVxyXG4gICAgICovXHJcbiAgICBnZXQgdGltZXNjYWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aW1lc2NhbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGN1cnJlbnQgZW5naW5lIHRpbWVzY2FsZSBmYWN0b3IuIFVzZWZ1bCBmb3IgY3JlYXRpbmcgc2xvdy1tb3Rpb24gZWZmZWN0cyBvciBmYXN0LWZvcndhcmQgZWZmZWN0c1xyXG4gICAgICogd2hlbiB1c2luZyB0aW1lLWJhc2VkIG1vdmVtZW50LlxyXG4gICAgICovXHJcbiAgICBzZXQgdGltZXNjYWxlKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDw9IDApIHtcclxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nhbm5vdCBzZXQgZW5naW5lLnRpbWVzY2FsZSB0byBhIHZhbHVlIG9mIDAgb3IgbGVzcyB0aGFuIDAuJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdGltZXNjYWxlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBsYXlzIGEgc3ByaXRlIGFuaW1hdGlvbiBvbiB0aGUgc2NyZWVuIGF0IHRoZSBzcGVjaWZpZWQgYHhgIGFuZCBgeWBcclxuICAgICAqIChpbiBnYW1lIGNvb3JkaW5hdGVzLCBub3Qgc2NyZWVuIHBpeGVscykuIFRoZXNlIGFuaW1hdGlvbnMgcGxheVxyXG4gICAgICogaW5kZXBlbmRlbnQgb2YgYWN0b3JzLCBhbmQgd2lsbCBiZSBjbGVhbmVkIHVwIGludGVybmFsbHkgYXMgc29vblxyXG4gICAgICogYXMgdGhleSBhcmUgY29tcGxldGUuIE5vdGUgYW5pbWF0aW9ucyB0aGF0IGxvb3Agd2lsbCBuZXZlciBiZVxyXG4gICAgICogY2xlYW5lZCB1cC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uICBBbmltYXRpb24gdG8gcGxheVxyXG4gICAgICogQHBhcmFtIHggICAgICAgICAgeCBnYW1lIGNvb3JkaW5hdGUgdG8gcGxheSB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0geSAgICAgICAgICB5IGdhbWUgY29vcmRpbmF0ZSB0byBwbGF5IHRoZSBhbmltYXRpb25cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIHBsYXlBbmltYXRpb24oYW5pbWF0aW9uLCB4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9ucy5wdXNoKG5ldyBBbmltYXRpb25Ob2RlKGFuaW1hdGlvbiwgeCwgeSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgW1tUaWxlTWFwXV0gdG8gdGhlIFtbY3VycmVudFNjZW5lXV0sIG9uY2UgdGhpcyBpcyBkb25lIHRoZSBUaWxlTWFwXHJcbiAgICAgKiB3aWxsIGJlIGRyYXduIGFuZCB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBhZGRUaWxlTWFwKHRpbGVNYXApIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5hZGRUaWxlTWFwKHRpbGVNYXApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgW1tUaWxlTWFwXV0gZnJvbSB0aGUgW1tjdXJyZW50U2NlbmVdXSwgaXQgd2lsbCBubyBsb25nZXIgYmUgZHJhd24gb3IgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlVGlsZU1hcCh0aWxlTWFwKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlVGlsZU1hcCh0aWxlTWFwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIFtbVGltZXJdXSB0byB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIGFkZCB0byB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAqL1xyXG4gICAgYWRkVGltZXIodGltZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2NlbmUuYWRkVGltZXIodGltZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgW1tUaW1lcl1dIGZyb20gdGhlIFtbY3VycmVudFNjZW5lXV0uXHJcbiAgICAgKiBAcGFyYW0gdGltZXIgIFRoZSB0aW1lciB0byByZW1vdmUgdG8gdGhlIFtbY3VycmVudFNjZW5lXV0uXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVRpbWVyKHRpbWVyKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZVRpbWVyKHRpbWVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIFtbU2NlbmVdXSB0byB0aGUgZW5naW5lLCB0aGluayBvZiBzY2VuZXMgaW4gRXhjYWxpYnVyIGFzIHlvdVxyXG4gICAgICogd291bGQgbGV2ZWxzIG9yIG1lbnVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXkgIFRoZSBuYW1lIG9mIHRoZSBzY2VuZSwgbXVzdCBiZSB1bmlxdWVcclxuICAgICAqIEBwYXJhbSBzY2VuZSBUaGUgc2NlbmUgdG8gYWRkIHRvIHRoZSBlbmdpbmVcclxuICAgICAqL1xyXG4gICAgYWRkU2NlbmUoa2V5LCBzY2VuZSkge1xyXG4gICAgICAgIGlmICh0aGlzLnNjZW5lc1trZXldKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci53YXJuKCdTY2VuZScsIGtleSwgJ2FscmVhZHkgZXhpc3RzIG92ZXJ3cml0aW5nJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2NlbmVzW2tleV0gPSBzY2VuZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVNjZW5lKGVudGl0eSkge1xyXG4gICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBTY2VuZSkge1xyXG4gICAgICAgICAgICAvLyByZW1vdmUgc2NlbmVcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5zY2VuZXMpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNjZW5lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVzW2tleV0gPT09IGVudGl0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zY2VuZXNba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBzY2VuZVxyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5zY2VuZXNbZW50aXR5XTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGQoZW50aXR5KSB7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRTY2VuZShhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2RlZmVycmVkR29UbyAmJiB0aGlzLnNjZW5lc1t0aGlzLl9kZWZlcnJlZEdvVG9dKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NlbmVzW3RoaXMuX2RlZmVycmVkR29Ub10uYWRkKGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5hZGQoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmUoZW50aXR5KSB7XHJcbiAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEVudGl0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmUoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFNjZW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2NlbmUoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRpdHkgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2NlbmUoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoYW5nZXMgdGhlIGN1cnJlbnRseSB1cGRhdGluZyBhbmQgZHJhd2luZyBzY2VuZSB0byBhIGRpZmZlcmVudCxcclxuICAgICAqIG5hbWVkIHNjZW5lLiBDYWxscyB0aGUgW1tTY2VuZV1dIGxpZmVjeWNsZSBldmVudHMuXHJcbiAgICAgKiBAcGFyYW0ga2V5ICBUaGUga2V5IG9mIHRoZSBzY2VuZSB0byB0cmFuc2l0aW9uIHRvLlxyXG4gICAgICovXHJcbiAgICBnb1RvU2NlbmUoa2V5KSB7XHJcbiAgICAgICAgLy8gaWYgbm90IHlldCBpbml0aWFsaXplZCBkZWZlciBnb1RvU2NlbmVcclxuICAgICAgICBpZiAoIXRoaXMuaXNJbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kZWZlcnJlZEdvVG8gPSBrZXk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2NlbmVzW2tleV0pIHtcclxuICAgICAgICAgICAgY29uc3Qgb2xkU2NlbmUgPSB0aGlzLmN1cnJlbnRTY2VuZTtcclxuICAgICAgICAgICAgY29uc3QgbmV3U2NlbmUgPSB0aGlzLnNjZW5lc1trZXldO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0dvaW5nIHRvIHNjZW5lOicsIGtleSk7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgZGVhY3RpdmF0ZSB3aGVuIGluaXRpYWxpemVkXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTY2VuZS5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5fZGVhY3RpdmF0ZS5hcHBseSh0aGlzLmN1cnJlbnRTY2VuZSwgW29sZFNjZW5lLCBuZXdTY2VuZV0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2RlYWN0aXZhdGUnLCBuZXcgRGVhY3RpdmF0ZUV2ZW50KG5ld1NjZW5lLCB0aGlzLmN1cnJlbnRTY2VuZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIHNldCBjdXJyZW50IHNjZW5lIHRvIG5ldyBvbmVcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUgPSBuZXdTY2VuZTtcclxuICAgICAgICAgICAgdGhpcy5zY3JlZW4uc2V0Q3VycmVudENhbWVyYShuZXdTY2VuZS5jYW1lcmEpO1xyXG4gICAgICAgICAgICAvLyBpbml0aWFsaXplIHRoZSBjdXJyZW50IHNjZW5lIGlmIGhhcyBub3QgYmVlbiBhbHJlYWR5XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLl9pbml0aWFsaXplKHRoaXMpO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5fYWN0aXZhdGUuYXBwbHkodGhpcy5jdXJyZW50U2NlbmUsIFtvbGRTY2VuZSwgbmV3U2NlbmVdKTtcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2FjdGl2YXRlJywgbmV3IEFjdGl2YXRlRXZlbnQob2xkU2NlbmUsIHRoaXMuY3VycmVudFNjZW5lKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZXJyb3IoJ1NjZW5lJywga2V5LCAnZG9lcyBub3QgZXhpc3QhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm1zIHRoZSBjdXJyZW50IHgsIHkgZnJvbSBzY3JlZW4gY29vcmRpbmF0ZXMgdG8gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSBwb2ludCAgU2NyZWVuIGNvb3JkaW5hdGUgdG8gY29udmVydFxyXG4gICAgICovXHJcbiAgICBzY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMocG9pbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKHBvaW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVHJhbnNmb3JtcyBhIHdvcmxkIGNvb3JkaW5hdGUsIHRvIGEgc2NyZWVuIGNvb3JkaW5hdGVcclxuICAgICAqIEBwYXJhbSBwb2ludCAgV29ybGQgY29vcmRpbmF0ZSB0byBjb252ZXJ0XHJcbiAgICAgKi9cclxuICAgIHdvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhwb2ludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMocG9pbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgY2FudmFzLCByZW5kZXJpbmcgY29udGV4dCwgZGlzcGxheSBtb2RlLCBhbmQgbmF0aXZlIGV2ZW50IGxpc3RlbmVyc1xyXG4gICAgICovXHJcbiAgICBfaW5pdGlhbGl6ZShvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5wYWdlU2Nyb2xsUHJldmVudGlvbk1vZGUgPSBvcHRpb25zLnNjcm9sbFByZXZlbnRpb25Nb2RlO1xyXG4gICAgICAgIC8vIGluaXRpYWxpemUgaW5wdXRzXHJcbiAgICAgICAgdGhpcy5pbnB1dCA9IHtcclxuICAgICAgICAgICAga2V5Ym9hcmQ6IG5ldyBLZXlib2FyZCgpLFxyXG4gICAgICAgICAgICBwb2ludGVyczogbmV3IFBvaW50ZXJzKHRoaXMpLFxyXG4gICAgICAgICAgICBnYW1lcGFkczogbmV3IEdhbWVwYWRzKClcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuaW5wdXQua2V5Ym9hcmQuaW5pdCgpO1xyXG4gICAgICAgIHRoaXMuaW5wdXQucG9pbnRlcnMuaW5pdChvcHRpb25zICYmIG9wdGlvbnMucG9pbnRlclNjb3BlID09PSBQb2ludGVyU2NvcGUuRG9jdW1lbnQgPyBkb2N1bWVudCA6IHRoaXMuY2FudmFzKTtcclxuICAgICAgICB0aGlzLmlucHV0LmdhbWVwYWRzLmluaXQoKTtcclxuICAgICAgICAvLyBJc3N1ZSAjMzg1IG1ha2UgdXNlIG9mIHRoZSB2aXNpYmlsaXR5IGFwaVxyXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0d1aWRlL1VzZXJfZXhwZXJpZW5jZS9Vc2luZ190aGVfUGFnZV9WaXNpYmlsaXR5X0FQSVxyXG4gICAgICAgIGxldCBoaWRkZW4sIHZpc2liaWxpdHlDaGFuZ2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudC5oaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIC8vIE9wZXJhIDEyLjEwIGFuZCBGaXJlZm94IDE4IGFuZCBsYXRlciBzdXBwb3J0XHJcbiAgICAgICAgICAgIGhpZGRlbiA9ICdoaWRkZW4nO1xyXG4gICAgICAgICAgICB2aXNpYmlsaXR5Q2hhbmdlID0gJ3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnbXNIaWRkZW4nIGluIGRvY3VtZW50KSB7XHJcbiAgICAgICAgICAgIGhpZGRlbiA9ICdtc0hpZGRlbic7XHJcbiAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnbXN2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoJ3dlYmtpdEhpZGRlbicgaW4gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgaGlkZGVuID0gJ3dlYmtpdEhpZGRlbic7XHJcbiAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYnJvd3Nlci5kb2N1bWVudC5vbih2aXNpYmlsaXR5Q2hhbmdlLCAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudFtoaWRkZW5dKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdoaWRkZW4nLCBuZXcgSGlkZGVuRXZlbnQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdXaW5kb3cgaGlkZGVuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCd2aXNpYmxlJywgbmV3IFZpc2libGVFdmVudCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1dpbmRvdyB2aXNpYmxlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIXRoaXMuY2FudmFzRWxlbWVudElkICYmICFvcHRpb25zLmNhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmNhbnZhcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgb25Jbml0aWFsaXplKF9lbmdpbmUpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIsIHRoaXMgd2lsbCBzZXQgdGhlIGFudGlhbGlhc2luZyBmbGFnIG9uIHRoZVxyXG4gICAgICogY2FudmFzLiBTZXQgdGhpcyB0byBgZmFsc2VgIGlmIHlvdSB3YW50IGEgJ2phZ2dlZCcgcGl4ZWwgYXJ0IGxvb2sgdG8geW91clxyXG4gICAgICogaW1hZ2UgcmVzb3VyY2VzLlxyXG4gICAgICogQHBhcmFtIGlzU21vb3RoICBTZXQgc21vb3RoaW5nIHRvIHRydWUgb3IgZmFsc2VcclxuICAgICAqL1xyXG4gICAgc2V0QW50aWFsaWFzaW5nKGlzU21vb3RoKSB7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4uYW50aWFsaWFzaW5nID0gaXNTbW9vdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB0aGUgY3VycmVudCBzbW9vdGhpbmcgc3RhdHVzIG9mIHRoZSBjYW52YXNcclxuICAgICAqL1xyXG4gICAgZ2V0QW50aWFsaWFzaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5hbnRpYWxpYXNpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgd2hldGhlciB0aGUgYWN0b3IgaXMgSW5pdGlhbGl6ZWRcclxuICAgICAqL1xyXG4gICAgZ2V0IGlzSW5pdGlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5pdGlhbGl6ZWQ7XHJcbiAgICB9XHJcbiAgICBfb3ZlcnJpZGVJbml0aWFsaXplKGVuZ2luZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMub25Jbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoJ2luaXRpYWxpemUnLCBuZXcgSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSwgdGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RlZmVycmVkR29Ubykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nb1RvU2NlbmUodGhpcy5fZGVmZXJyZWRHb1RvKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ29Ub1NjZW5lKCdyb290Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGVudGlyZSBzdGF0ZSBvZiB0aGUgZ2FtZVxyXG4gICAgICogQHBhcmFtIGRlbHRhICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxyXG4gICAgICovXHJcbiAgICBfdXBkYXRlKGRlbHRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzTG9hZGluZykge1xyXG4gICAgICAgICAgICAvLyBzdXNwZW5kIHVwZGF0ZXMgdW50aWwgbG9hZGluZyBpcyBmaW5pc2hlZFxyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIudXBkYXRlKHRoaXMsIGRlbHRhKTtcclxuICAgICAgICAgICAgLy8gVXBkYXRlIGlucHV0IGxpc3RlbmVyc1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmtleWJvYXJkLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LnBvaW50ZXJzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB0aGlzLmlucHV0LmdhbWVwYWRzLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX292ZXJyaWRlSW5pdGlhbGl6ZSh0aGlzKTtcclxuICAgICAgICAvLyBQdWJsaXNoIHByZXVwZGF0ZSBldmVudHNcclxuICAgICAgICB0aGlzLl9wcmV1cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgIC8vIHByb2Nlc3MgZW5naW5lIGxldmVsIGV2ZW50c1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnVwZGF0ZSh0aGlzLCBkZWx0YSk7XHJcbiAgICAgICAgLy8gdXBkYXRlIGFuaW1hdGlvbnNcclxuICAgICAgICAvLyBUT0RPIHJlbW92ZVxyXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbnMgPSB0aGlzLl9hbmltYXRpb25zLmZpbHRlcihmdW5jdGlvbiAoYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gIWEuYW5pbWF0aW9uLmlzRG9uZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIC8vIFVwZGF0ZSBpbnB1dCBsaXN0ZW5lcnNcclxuICAgICAgICB0aGlzLmlucHV0LmtleWJvYXJkLnVwZGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuaW5wdXQucG9pbnRlcnMudXBkYXRlKCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5nYW1lcGFkcy51cGRhdGUoKTtcclxuICAgICAgICAvLyBQdWJsaXNoIHVwZGF0ZSBldmVudFxyXG4gICAgICAgIHRoaXMuX3Bvc3R1cGRhdGUoZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3ByZXVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncHJldXBkYXRlJywgbmV3IFByZVVwZGF0ZUV2ZW50KHRoaXMsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblByZVVwZGF0ZSh0aGlzLCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICBvblByZVVwZGF0ZShfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3Bvc3R1cGRhdGUoZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3Bvc3R1cGRhdGUnLCBuZXcgUG9zdFVwZGF0ZUV2ZW50KHRoaXMsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblBvc3RVcGRhdGUodGhpcywgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgb25Qb3N0VXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBlbnRpcmUgZ2FtZVxyXG4gICAgICogQHBhcmFtIGRlbHRhICBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgZHJhdy5cclxuICAgICAqL1xyXG4gICAgX2RyYXcoZGVsdGEpIHtcclxuICAgICAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcclxuICAgICAgICB0aGlzLl9wcmVkcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0xvYWRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyLmNhbnZhcy5kcmF3KHRoaXMuZ3JhcGhpY3NDb250ZXh0LCAwLCAwKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljc0NvbnRleHQuZmx1c2goKTtcclxuICAgICAgICAgICAgLy8gRHJhd2luZyBub3RoaW5nIGVsc2Ugd2hpbGUgbG9hZGluZ1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gbW92ZSB0byBncmFwaGljcyBzeXN0ZW1zP1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NDb250ZXh0LmJhY2tncm91bmRDb2xvciA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmRyYXcodGhpcy5jdHgsIGRlbHRhKTtcclxuICAgICAgICAvLyB0b2RvIG5lZWRzIHRvIGJlIGEgYmV0dGVyIHdheSBvZiBkb2luZyB0aGlzXHJcbiAgICAgICAgbGV0IGEgPSAwO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuX2FuaW1hdGlvbnMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoYTsgYSA8IGxlbjsgYSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbnNbYV0uYW5pbWF0aW9uLmRyYXcoY3R4LCB0aGlzLl9hbmltYXRpb25zW2FdLngsIHRoaXMuX2FuaW1hdGlvbnNbYV0ueSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERyYXcgZGVidWcgaW5mb3JtYXRpb25cclxuICAgICAgICAvLyBUT0RPIGRvbid0IGFjY2VzcyBjdHggZGlyZWN0bHlcclxuICAgICAgICBpZiAodGhpcy5pc0RlYnVnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmZvbnQgPSAnQ29uc29sYXMnO1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSB0aGlzLmRlYnVnQ29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuaW5wdXQua2V5Ym9hcmQuZ2V0S2V5cygpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KGtleXNbal0udG9TdHJpbmcoKSArICcgOiAnICsgKEtleXNba2V5c1tqXV0gPyBLZXlzW2tleXNbal1dIDogJ05vdCBNYXBwZWQnKSwgMTAwLCAxMCAqIGogKyAxMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoJ0ZQUzonICsgdGhpcy5zdGF0cy5jdXJyRnJhbWUuZnBzLnRvRml4ZWQoMikudG9TdHJpbmcoKSwgMTAsIDEwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG9zdCBwcm9jZXNzaW5nXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBvc3RQcm9jZXNzb3JzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zdFByb2Nlc3NvcnNbaV0ucHJvY2Vzcyh0aGlzLmN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy5jYW52YXNXaWR0aCwgdGhpcy5jYW52YXNIZWlnaHQpLCB0aGlzLmN0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Bvc3RkcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3ByZWRyYXcoX2N0eCwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZWRyYXcnLCBuZXcgUHJlRHJhd0V2ZW50KF9jdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblByZURyYXcoX2N0eCwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgb25QcmVEcmF3KF9jdHgsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcG9zdGRyYXcoX2N0eCwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkcmF3JywgbmV3IFBvc3REcmF3RXZlbnQoX2N0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUG9zdERyYXcoX2N0eCwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgb25Qb3N0RHJhdyhfY3R4LCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFbmFibGUgb3IgZGlzYWJsZSBFeGNhbGlidXIgZGVidWdnaW5nIGZ1bmN0aW9uYWxpdHkuXHJcbiAgICAgKiBAcGFyYW0gdG9nZ2xlIGEgdmFsdWUgdGhhdCBkZWJ1ZyBkcmF3aW5nIHdpbGwgYmUgY2hhbmdlZCB0b1xyXG4gICAgICovXHJcbiAgICBzaG93RGVidWcodG9nZ2xlKSB7XHJcbiAgICAgICAgdGhpcy5faXNEZWJ1ZyA9IHRvZ2dsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG9nZ2xlIEV4Y2FsaWJ1ciBkZWJ1Z2dpbmcgZnVuY3Rpb25hbGl0eS5cclxuICAgICAqL1xyXG4gICAgdG9nZ2xlRGVidWcoKSB7XHJcbiAgICAgICAgdGhpcy5faXNEZWJ1ZyA9ICF0aGlzLl9pc0RlYnVnO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0RlYnVnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgd2hlbiBsb2FkaW5nIGlzIHRvdGFsbHkgY29tcGxldGUgYW5kIHRoZSBwbGF5ZXIgaGFzIGNsaWNrZWQgc3RhcnRcclxuICAgICAqL1xyXG4gICAgZ2V0IGxvYWRpbmdDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9hZGluZ0NvbXBsZXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIGludGVybmFsIGdhbWUgbG9vcCBmb3IgRXhjYWxpYnVyIGFmdGVyIGxvYWRpbmdcclxuICAgICAqIGFueSBwcm92aWRlZCBhc3NldHMuXHJcbiAgICAgKiBAcGFyYW0gbG9hZGVyICBPcHRpb25hbCBbW0xvYWRlcl1dIHRvIHVzZSB0byBsb2FkIHJlc291cmNlcy4gVGhlIGRlZmF1bHQgbG9hZGVyIGlzIFtbTG9hZGVyXV0sIG92ZXJyaWRlIHRvIHByb3ZpZGUgeW91ciBvd25cclxuICAgICAqIGN1c3RvbSBsb2FkZXIuXHJcbiAgICAgKi9cclxuICAgIHN0YXJ0KGxvYWRlcikge1xyXG4gICAgICAgIGlmICghdGhpcy5fY29tcGF0aWJsZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoJ0V4Y2FsaWJ1ciBpcyBpbmNvbXBhdGlibGUgd2l0aCB5b3VyIGJyb3dzZXInKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGxvYWRpbmdDb21wbGV0ZTtcclxuICAgICAgICAvLyBQdXNoIHRoZSBjdXJyZW50IHVzZXIgZW50ZXJlZCByZXNvbHV0aW9uL3ZpZXdwb3J0XHJcbiAgICAgICAgdGhpcy5zY3JlZW4ucHVzaFJlc29sdXRpb25BbmRWaWV3cG9ydCgpO1xyXG4gICAgICAgIC8vIENvbmZpZ3VyZSByZXNvbHV0aW9uIGZvciBsb2FkZXJcclxuICAgICAgICB0aGlzLnNjcmVlbi5yZXNvbHV0aW9uID0gdGhpcy5zY3JlZW4udmlld3BvcnQ7XHJcbiAgICAgICAgdGhpcy5zY3JlZW4uYXBwbHlSZXNvbHV0aW9uQW5kVmlld3BvcnQoKTtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dC51cGRhdGVWaWV3cG9ydCgpO1xyXG4gICAgICAgIGlmIChsb2FkZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyID0gbG9hZGVyO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIuc3VwcHJlc3NQbGF5QnV0dG9uID0gdGhpcy5fc3VwcHJlc3NQbGF5QnV0dG9uIHx8IHRoaXMuX2xvYWRlci5zdXBwcmVzc1BsYXlCdXR0b247XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci53aXJlRW5naW5lKHRoaXMpO1xyXG4gICAgICAgICAgICBsb2FkaW5nQ29tcGxldGUgPSB0aGlzLmxvYWQodGhpcy5fbG9hZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxvYWRpbmdDb21wbGV0ZSA9IFByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsb2FkaW5nQ29tcGxldGUudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuLnBvcFJlc29sdXRpb25BbmRWaWV3cG9ydCgpO1xyXG4gICAgICAgICAgICB0aGlzLnNjcmVlbi5hcHBseVJlc29sdXRpb25BbmRWaWV3cG9ydCgpO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dC51cGRhdGVWaWV3cG9ydCgpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0YXJ0JywgbmV3IEdhbWVTdGFydEV2ZW50KHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGluZ0NvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIXRoaXMuX2hhc1N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgLy8gaGFzIHN0YXJ0ZWQgaXMgYSBzbGlnaHQgbWlzbm9tZXIsIGl0J3MgcmVhbGx5IG1haW5sb29wIHN0YXJ0ZWRcclxuICAgICAgICAgICAgdGhpcy5faGFzU3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU3RhcnRpbmcgZ2FtZS4uLicpO1xyXG4gICAgICAgICAgICB0aGlzLmJyb3dzZXIucmVzdW1lKCk7XHJcbiAgICAgICAgICAgIEVuZ2luZS5jcmVhdGVNYWluTG9vcCh0aGlzLCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBEYXRlLm5vdykoKTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdHYW1lIHN0YXJ0ZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEdhbWUgYWxyZWFkeSBzdGFydGVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbG9hZGluZ0NvbXBsZXRlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyZWF0ZU1haW5Mb29wKGdhbWUsIHJhZiwgbm93Rm4pIHtcclxuICAgICAgICBsZXQgbGFzdFRpbWUgPSBub3dGbigpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtYWlubG9vcCgpIHtcclxuICAgICAgICAgICAgaWYgKCFnYW1lLl9oYXNTdGFydGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGdhbWUuX3JlcXVlc3RJZCA9IHJhZihtYWlubG9vcCk7XHJcbiAgICAgICAgICAgICAgICBnYW1lLmVtaXQoJ3ByZWZyYW1lJywgbmV3IFByZUZyYW1lRXZlbnQoZ2FtZSwgZ2FtZS5zdGF0cy5wcmV2RnJhbWUpKTtcclxuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGltZSB0byBjYWxjdWxhdGUgdGltZS1lbGFwc2VkXHJcbiAgICAgICAgICAgICAgICBjb25zdCBub3cgPSBub3dGbigpO1xyXG4gICAgICAgICAgICAgICAgbGV0IGVsYXBzZWQgPSBNYXRoLmZsb29yKG5vdyAtIGxhc3RUaW1lKSB8fCAxO1xyXG4gICAgICAgICAgICAgICAgLy8gUmVzb2x2ZXMgaXNzdWUgIzEzOCBpZiB0aGUgZ2FtZSBoYXMgYmVlbiBwYXVzZWQsIG9yIGJsdXJyZWQgZm9yXHJcbiAgICAgICAgICAgICAgICAvLyBtb3JlIHRoYW4gYSAyMDAgbWlsbGlzZWNvbmRzLCByZXNldCBlbGFwc2VkIHRpbWUgdG8gMS4gVGhpcyBpbXByb3ZlcyByZWxpYWJpbGl0eVxyXG4gICAgICAgICAgICAgICAgLy8gYW5kIHByb3ZpZGVzIG1vcmUgZXhwZWN0ZWQgYmVoYXZpb3Igd2hlbiB0aGUgZW5naW5lIGNvbWVzIGJhY2tcclxuICAgICAgICAgICAgICAgIC8vIGludG8gZm9jdXNcclxuICAgICAgICAgICAgICAgIGlmIChlbGFwc2VkID4gMjAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxhcHNlZCA9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkZWx0YSA9IGVsYXBzZWQgKiBnYW1lLnRpbWVzY2FsZTtcclxuICAgICAgICAgICAgICAgIC8vIHJlc2V0IGZyYW1lIHN0YXRzIChyZXVzZSBleGlzdGluZyBpbnN0YW5jZXMpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBmcmFtZUlkID0gZ2FtZS5zdGF0cy5wcmV2RnJhbWUuaWQgKyAxO1xyXG4gICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUucmVzZXQoKTtcclxuICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMuY3VyckZyYW1lLmlkID0gZnJhbWVJZDtcclxuICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMuY3VyckZyYW1lLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5mcHMgPSAxLjAgLyAoZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZVVwZGF0ZSA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgICAgICBnYW1lLl91cGRhdGUoZGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXJVcGRhdGUgPSBub3dGbigpO1xyXG4gICAgICAgICAgICAgICAgZ2FtZS5fZHJhdyhkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlckRyYXcgPSBub3dGbigpO1xyXG4gICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUuZHVyYXRpb24udXBkYXRlID0gYWZ0ZXJVcGRhdGUgLSBiZWZvcmVVcGRhdGU7XHJcbiAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5kdXJhdGlvbi5kcmF3ID0gYWZ0ZXJEcmF3IC0gYWZ0ZXJVcGRhdGU7XHJcbiAgICAgICAgICAgICAgICBsYXN0VGltZSA9IG5vdztcclxuICAgICAgICAgICAgICAgIGdhbWUuZW1pdCgncG9zdGZyYW1lJywgbmV3IFBvc3RGcmFtZUV2ZW50KGdhbWUsIGdhbWUuc3RhdHMuY3VyckZyYW1lKSk7XHJcbiAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLnByZXZGcmFtZS5yZXNldChnYW1lLnN0YXRzLmN1cnJGcmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShnYW1lLl9yZXF1ZXN0SWQpO1xyXG4gICAgICAgICAgICAgICAgZ2FtZS5zdG9wKCk7XHJcbiAgICAgICAgICAgICAgICBnYW1lLm9uRmF0YWxFeGNlcHRpb24oZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wcyBFeGNhbGlidXIncyBtYWluIGxvb3AsIHVzZWZ1bCBmb3IgcGF1c2luZyB0aGUgZ2FtZS5cclxuICAgICAqL1xyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5faGFzU3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnLCBuZXcgR2FtZVN0b3BFdmVudCh0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuYnJvd3Nlci5wYXVzZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9oYXNTdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnR2FtZSBzdG9wcGVkJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBFbmdpbmUncyBSdW5uaW5nIHN0YXR1cywgVXNlZnVsIGZvciBjaGVja2luZyB3aGV0aGVyIGVuZ2luZSBpcyBydW5uaW5nIG9yIHBhdXNlZC5cclxuICAgICAqL1xyXG4gICAgaXNQYXVzZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLl9oYXNTdGFydGVkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBhIHNjcmVlbiBzaG90IG9mIHRoZSBjdXJyZW50IHZpZXdwb3J0IGFuZCByZXR1cm5zIGl0IGFzIGFuXHJcbiAgICAgKiBIVE1MIEltYWdlIEVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHNjcmVlbnNob3QoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgY29uc3QgcmF3ID0gdGhpcy5jYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKTtcclxuICAgICAgICByZXN1bHQuc3JjID0gcmF3O1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFub3RoZXIgb3B0aW9uIGF2YWlsYWJsZSB0byB5b3UgdG8gbG9hZCByZXNvdXJjZXMgaW50byB0aGUgZ2FtZS5cclxuICAgICAqIEltbWVkaWF0ZWx5IGFmdGVyIGNhbGxpbmcgdGhpcyB0aGUgZ2FtZSB3aWxsIHBhdXNlIGFuZCB0aGUgbG9hZGluZyBzY3JlZW5cclxuICAgICAqIHdpbGwgYXBwZWFyLlxyXG4gICAgICogQHBhcmFtIGxvYWRlciAgU29tZSBbW0xvYWRhYmxlXV0gc3VjaCBhcyBhIFtbTG9hZGVyXV0gY29sbGVjdGlvbiwgW1tTb3VuZF1dLCBvciBbW1RleHR1cmVdXS5cclxuICAgICAqL1xyXG4gICAgbG9hZChsb2FkZXIpIHtcclxuICAgICAgICBjb25zdCBjb21wbGV0ZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzTG9hZGluZyA9IHRydWU7XHJcbiAgICAgICAgICAgIGxvYWRlci5sb2FkKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3VwcHJlc3NQbGF5QnV0dG9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlbGF5IGlzIHRvIGdpdmUgdGhlIGxvZ28gYSBjaGFuY2UgdG8gc2hvdywgb3RoZXJ3aXNlIGRvbid0IGRlbGF5XHJcbiAgICAgICAgICAgICAgICAgICAgfSwgNTAwKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2lzTG9hZGluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZWZhdWx0IFtbRW5naW5lT3B0aW9uc11dXHJcbiAqL1xyXG5FbmdpbmUuX0RFRkFVTFRfRU5HSU5FX09QVElPTlMgPSB7XHJcbiAgICB3aWR0aDogMCxcclxuICAgIGhlaWdodDogMCxcclxuICAgIGVuYWJsZUNhbnZhc1RyYW5zcGFyZW5jeTogdHJ1ZSxcclxuICAgIGNhbnZhc0VsZW1lbnRJZDogJycsXHJcbiAgICBjYW52YXNFbGVtZW50OiB1bmRlZmluZWQsXHJcbiAgICBzbmFwVG9QaXhlbDogZmFsc2UsXHJcbiAgICBwb2ludGVyU2NvcGU6IFBvaW50ZXJTY29wZS5DYW52YXMsXHJcbiAgICBzdXBwcmVzc0NvbnNvbGVCb290TWVzc2FnZTogbnVsbCxcclxuICAgIHN1cHByZXNzTWluaW11bUJyb3dzZXJGZWF0dXJlRGV0ZWN0aW9uOiBudWxsLFxyXG4gICAgc3VwcHJlc3NIaURQSVNjYWxpbmc6IG51bGwsXHJcbiAgICBzdXBwcmVzc1BsYXlCdXR0b246IG51bGwsXHJcbiAgICBzY3JvbGxQcmV2ZW50aW9uTW9kZTogU2Nyb2xsUHJldmVudGlvbk1vZGUuQ2FudmFzLFxyXG4gICAgYmFja2dyb3VuZENvbG9yOiBDb2xvci5mcm9tSGV4KCcjMjE4NWQwJykgLy8gRXhjYWxpYnVyIGJsdWVcclxufTtcclxuRW5naW5lX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHsgbWVzc2FnZTogJ1dpbGwgYmUgcmVtb3ZlZCBpbiBleGNhbGlidXIgdjAuMjYuMCcsIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBBY3Rvci5ncmFwaGljcycgfSlcclxuXSwgRW5naW5lLnByb3RvdHlwZSwgXCJwbGF5QW5pbWF0aW9uXCIsIG51bGwpO1xyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqIEBkZXByZWNhdGVkXHJcbiAqL1xyXG5sZXQgQW5pbWF0aW9uTm9kZSA9IGNsYXNzIEFuaW1hdGlvbk5vZGUge1xyXG4gICAgY29uc3RydWN0b3IoYW5pbWF0aW9uLCB4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5hbmltYXRpb24gPSBhbmltYXRpb247XHJcbiAgICAgICAgdGhpcy54ID0geDtcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgfVxyXG59O1xyXG5BbmltYXRpb25Ob2RlID0gRW5naW5lX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHsgbWVzc2FnZTogJ1dpbGwgYmUgcmVtb3ZlZCBpbiBleGNhbGlidXIgdjAuMjYuMCcgfSlcclxuXSwgQW5pbWF0aW9uTm9kZSk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTWF0aC9JbmRleC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0RlYnVnL2luZGV4LnRzXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0V2ZW50cy9NZWRpYUV2ZW50cy50c1xuXHJcbmNsYXNzIE1lZGlhRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBfbmFtZSA9ICdNZWRpYUV2ZW50Jykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9IF9uYW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNZWRpYSBldmVudCBjYW5ub3QgYnViYmxlXHJcbiAgICAgKi9cclxuICAgIHNldCBidWJibGVzKF92YWx1ZSkge1xyXG4gICAgICAgIC8vIHN0dWJiZWRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWVkaWEgZXZlbnQgY2Fubm90IGJ1YmJsZVxyXG4gICAgICovXHJcbiAgICBnZXQgYnViYmxlcygpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1lZGlhIGV2ZW50IGNhbm5vdCBidWJibGUsIHNvIHRoZXkgaGF2ZSBubyBwYXRoXHJcbiAgICAgKi9cclxuICAgIGdldCBfcGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWVkaWEgZXZlbnQgY2Fubm90IGJ1YmJsZSwgc28gdGhleSBoYXZlIG5vIHBhdGhcclxuICAgICAqL1xyXG4gICAgc2V0IF9wYXRoKF92YWwpIHtcclxuICAgICAgICAvLyBzdHViYmVkXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByZXZlbnRzIGV2ZW50IGZyb20gYnViYmxpbmdcclxuICAgICAqL1xyXG4gICAgc3RvcFByb3BhZ2F0aW9uKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0dWJcclxuICAgICAgICAgKi9cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWN0aW9uLCB0aGF0IGNhbGxzIHdoZW4gZXZlbnQgaGFwcGVuc1xyXG4gICAgICovXHJcbiAgICBhY3Rpb24oKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3R1YlxyXG4gICAgICAgICAqL1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9wYWdhdGUgZXZlbnQgZnVydGhlciB0aHJvdWdoIGV2ZW50IHBhdGhcclxuICAgICAqL1xyXG4gICAgcHJvcGFnYXRlKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFN0dWJcclxuICAgICAgICAgKi9cclxuICAgIH1cclxuICAgIGxheVBhdGgoX2FjdG9yKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3R1YlxyXG4gICAgICAgICAqL1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE5hdGl2ZVNvdW5kRXZlbnQgZXh0ZW5kcyBNZWRpYUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgdHJhY2spIHtcclxuICAgICAgICBzdXBlcih0YXJnZXQsICdOYXRpdmVTb3VuZEV2ZW50Jyk7XHJcbiAgICAgICAgdGhpcy50cmFjayA9IHRyYWNrO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIE5hdGl2ZVNvdW5kUHJvY2Vzc2VkRXZlbnQgZXh0ZW5kcyBNZWRpYUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgX3Byb2Nlc3NlZERhdGEpIHtcclxuICAgICAgICBzdXBlcih0YXJnZXQsICdOYXRpdmVTb3VuZFByb2Nlc3NlZEV2ZW50Jyk7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc2VkRGF0YSA9IF9wcm9jZXNzZWREYXRhO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuX3Byb2Nlc3NlZERhdGE7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Gb250LnRzXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIEZvbnQgZXh0ZW5kcyBSYXN0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX207XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRm9udCBxdWFsaXR5IGRldGVybWluZXMgdGhlIHNpemUgb2YgdGhlIHVuZGVybHlpbmcgcmFzdGVyZWQgdGV4dCwgaGlnaGVyIHF1YWxpdHkgbWVhbnMgbGVzcyBqYWdnZWQgZWRnZXMuXHJcbiAgICAgICAgICogSWYgcXVhbGl0eSBpcyBzZXQgdG8gMSwgdGhlbiBqdXN0IGVub3VnaCByYXN0ZXIgYml0bWFwIGlzIGdlbmVyYXRlZCB0byByZW5kZXIgdGhlIHRleHQuXHJcbiAgICAgICAgICpcclxuICAgICAgICAgKiBZb3UgY2FuIHRoaW5rIG9mIHF1YWxpdHkgYXMgaG93IHpvb21lZCBpbiB0byB0aGUgdGV4dCB5b3UgY2FuIGdldCBiZWZvcmUgc2VlaW5nIGphZ2dlZCBlZGdlcy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIChEZWZhdWx0IDQpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5xdWFsaXR5ID0gMjtcclxuICAgICAgICB0aGlzLmZhbWlseSA9ICdzYW5zLXNlcmlmJztcclxuICAgICAgICB0aGlzLnN0eWxlID0gRm9udFN0eWxlLk5vcm1hbDtcclxuICAgICAgICB0aGlzLmJvbGQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLnVuaXQgPSBGb250VW5pdC5QeDtcclxuICAgICAgICB0aGlzLnRleHRBbGlnbiA9IFRleHRBbGlnbi5MZWZ0O1xyXG4gICAgICAgIHRoaXMuYmFzZUFsaWduID0gQmFzZUFsaWduLkFscGhhYmV0aWM7XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSBEaXJlY3Rpb24uTGVmdFRvUmlnaHQ7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMTA7XHJcbiAgICAgICAgdGhpcy5zaGFkb3cgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RleHRCb3VuZHMgPSBuZXcgQm91bmRpbmdCb3goKTtcclxuICAgICAgICB0aGlzLl90ZXh0V2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3RleHRIZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMuZmFtaWx5ID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZhbWlseSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5mYW1pbHk7XHJcbiAgICAgICAgdGhpcy5zdHlsZSA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdHlsZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5zdHlsZTtcclxuICAgICAgICB0aGlzLmJvbGQgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9sZCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdGhpcy5ib2xkO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaXplKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLnNpemU7XHJcbiAgICAgICAgdGhpcy51bml0ID0gKF9lID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVuaXQpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMudW5pdDtcclxuICAgICAgICB0aGlzLnRleHRBbGlnbiA9IChfZiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50ZXh0QWxpZ24pICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRoaXMudGV4dEFsaWduO1xyXG4gICAgICAgIHRoaXMuYmFzZUFsaWduID0gKF9nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmJhc2VBbGlnbikgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdGhpcy5iYXNlQWxpZ247XHJcbiAgICAgICAgdGhpcy5kaXJlY3Rpb24gPSAoX2ggPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlyZWN0aW9uKSAhPT0gbnVsbCAmJiBfaCAhPT0gdm9pZCAwID8gX2ggOiB0aGlzLmRpcmVjdGlvbjtcclxuICAgICAgICB0aGlzLnF1YWxpdHkgPSAoX2ogPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucXVhbGl0eSkgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogdGhpcy5xdWFsaXR5O1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2hhZG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93ID0ge307XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93LmJsdXIgPSAoX2sgPSBvcHRpb25zLnNoYWRvdy5ibHVyKSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiB0aGlzLnNoYWRvdy5ibHVyO1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5vZmZzZXQgPSAoX2wgPSBvcHRpb25zLnNoYWRvdy5vZmZzZXQpICE9PSBudWxsICYmIF9sICE9PSB2b2lkIDAgPyBfbCA6IHRoaXMuc2hhZG93Lm9mZnNldDtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cuY29sb3IgPSAoX20gPSBvcHRpb25zLnNoYWRvdy5jb2xvcikgIT09IG51bGwgJiYgX20gIT09IHZvaWQgMCA/IF9tIDogdGhpcy5zaGFkb3cuY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEZvbnQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY2xvbmVHcmFwaGljT3B0aW9ucygpKSwgdGhpcy5jbG9uZVJhc3Rlck9wdGlvbnMoKSksIHsgc2l6ZTogdGhpcy5zaXplLCB1bml0OiB0aGlzLnVuaXQsIGZhbWlseTogdGhpcy5mYW1pbHksIHN0eWxlOiB0aGlzLnN0eWxlLCBib2xkOiB0aGlzLmJvbGQsIHRleHRBbGlnbjogdGhpcy50ZXh0QWxpZ24sIGJhc2VBbGlnbjogdGhpcy5iYXNlQWxpZ24sIGRpcmVjdGlvbjogdGhpcy5kaXJlY3Rpb24sIHNoYWRvdzogdGhpcy5zaGFkb3dcclxuICAgICAgICAgICAgICAgID8ge1xyXG4gICAgICAgICAgICAgICAgICAgIGJsdXI6IHRoaXMuc2hhZG93LmJsdXIsXHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLnNoYWRvdy5vZmZzZXQsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6IHRoaXMuc2hhZG93LmNvbG9yXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICA6IG51bGwgfSkpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGZvbnRTdHJpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuc3R5bGV9ICR7dGhpcy5ib2xkID8gJ2JvbGQnIDogJyd9ICR7dGhpcy5zaXplfSR7dGhpcy51bml0fSAke3RoaXMuZmFtaWx5fWA7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRXaWR0aDtcclxuICAgIH1cclxuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3RleHRXaWR0aCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IG51bUxpbmVzID0gKF9iID0gKF9hID0gdGhpcy5fbGluZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHRIZWlnaHQgKiBudW1MaW5lcztcclxuICAgIH1cclxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IG51bUxpbmVzID0gKF9iID0gKF9hID0gdGhpcy5fbGluZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XHJcbiAgICAgICAgdGhpcy5fdGV4dEhlaWdodCA9IHZhbHVlIC8gbnVtTGluZXM7XHJcbiAgICB9XHJcbiAgICBnZXQgX3Jhc3RlcldpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9iaXRtYXAud2lkdGg7XHJcbiAgICB9XHJcbiAgICBnZXQgX3Jhc3RlckhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYml0bWFwLmhlaWdodDtcclxuICAgIH1cclxuICAgIGdldCBfaGFsZlJhc3RlcldpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuX2JpdG1hcC53aWR0aCAvIDIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IF9oYWxmUmFzdGVySGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHRoaXMuX2JpdG1hcC5oZWlnaHQgLyAyKTtcclxuICAgIH1cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEJvdW5kcztcclxuICAgIH1cclxuICAgIF9kcmF3SW1hZ2UoZXgsIHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLnJhc3Rlcml6ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBleC5kcmF3SW1hZ2UodGhpcy5fYml0bWFwLCAwLCAwLCB0aGlzLl9yYXN0ZXJXaWR0aCwgdGhpcy5fcmFzdGVySGVpZ2h0LCB4IC0gdGhpcy5fcmFzdGVyV2lkdGggLyB0aGlzLnF1YWxpdHkgLyAyLCB5IC0gdGhpcy5fcmFzdGVySGVpZ2h0IC8gdGhpcy5xdWFsaXR5IC8gMiwgdGhpcy5fcmFzdGVyV2lkdGggLyB0aGlzLnF1YWxpdHksIHRoaXMuX3Jhc3RlckhlaWdodCAvIHRoaXMucXVhbGl0eSk7XHJcbiAgICB9XHJcbiAgICBfcm90YXRlKGV4KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIC8vIFRPRE8gdGhpcyBuZWVkcyB0byBjaGFuZ2UgZGVwZW5kaW5nIG9uIHRoZSBib3VuZGluZyBib3guLi5cclxuICAgICAgICBjb25zdCBvcmlnaW4gPSAoX2EgPSB0aGlzLm9yaWdpbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5fdGV4dEJvdW5kcy5jZW50ZXI7XHJcbiAgICAgICAgZXgudHJhbnNsYXRlKG9yaWdpbi54LCBvcmlnaW4ueSk7XHJcbiAgICAgICAgZXgucm90YXRlKHRoaXMucm90YXRpb24pO1xyXG4gICAgICAgIGV4LnRyYW5zbGF0ZSgtb3JpZ2luLngsIC1vcmlnaW4ueSk7XHJcbiAgICB9XHJcbiAgICBfZmxpcChleCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsaXBIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgIGV4LnRyYW5zbGF0ZSh0aGlzLl90ZXh0Qm91bmRzLndpZHRoIC8gdGhpcy5zY2FsZS54LCAwKTtcclxuICAgICAgICAgICAgZXguc2NhbGUoLTEsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5mbGlwVmVydGljYWwpIHtcclxuICAgICAgICAgICAgZXgudHJhbnNsYXRlKDAsIC10aGlzLl90ZXh0Qm91bmRzLmhlaWdodCAvIDIgLyB0aGlzLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICBleC5zY2FsZSgxLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdXBkYXRlVGV4dCh0ZXh0KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RleHQgIT09IHRleHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dCA9IHRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzID0gdGhpcy5fdGV4dC5zcGxpdCgnXFxuJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcclxuICAgICAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlRGltZW5zaW9ucygpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUZvbnQodGhpcy5fY3R4KTtcclxuICAgICAgICAgICAgY29uc3QgbWF4V2lkdGhMaW5lID0gdGhpcy5fbGluZXMucmVkdWNlKChhLCBiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggPiBiLmxlbmd0aCA/IGEgOiBiO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgbWV0cmljcyA9IHRoaXMuX2N0eC5tZWFzdXJlVGV4dChtYXhXaWR0aExpbmUpO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0V2lkdGggPSBNYXRoLmFicyhtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdCkgKyBNYXRoLmFicyhtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94UmlnaHQpO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0SGVpZ2h0ID0gTWF0aC5hYnMobWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCkgKyBNYXRoLmFicyhtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94RGVzY2VudCk7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gbGluZWhlaWdodCBtYWtlcyB0aGUgdGV4dCBib3VuZHMgd29ua3lcclxuICAgICAgICAgICAgY29uc3QgbGluZUFkanVzdGVkSGVpZ2h0ID0gdGhpcy5fdGV4dEhlaWdodCAqIHRoaXMuX2xpbmVzLmxlbmd0aDtcclxuICAgICAgICAgICAgLy8gdGhpcy5fdGV4dEhlaWdodCA9IGxpbmVBZGp1c3RlZEhlaWdodDtcclxuICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIHdpZHRoIGFuZCBoZWlnaHQgY2xlYXJzIHRoZSBjb250ZXh0IHByb3BlcnRpZXNcclxuICAgICAgICAgICAgLy8gV2UgZG91YmxlIHRoZSBiaXRtYXAgd2lkdGggdG8gYWNjb3VudCBmb3IgYWxpZ25tZW50XHJcbiAgICAgICAgICAgIC8vIFdlIHNjYWxlIGJ5IFwicXVhbGl0eVwiIHNvIHdlIHJlbmRlciB0ZXh0IHdpdGhvdXQgamFnZ2llc1xyXG4gICAgICAgICAgICB0aGlzLl9iaXRtYXAud2lkdGggPSAodGhpcy5fdGV4dFdpZHRoICsgdGhpcy5wYWRkaW5nICogMikgKiAyICogdGhpcy5xdWFsaXR5O1xyXG4gICAgICAgICAgICB0aGlzLl9iaXRtYXAuaGVpZ2h0ID0gKGxpbmVBZGp1c3RlZEhlaWdodCArIHRoaXMucGFkZGluZyAqIDIpICogMiAqIHRoaXMucXVhbGl0eTtcclxuICAgICAgICAgICAgLy8gVGhlc2UgYm91bmRzIGV4aXN0IGluIHJhc3RlciBiaXRtYXAgc3BhY2Ugd2hlcmUgdGhlIHRvcCBsZWZ0IGNvcm5lciBpcyB0aGUgY29yZGVyIG9mIHRoZSBiaXRtYXBcclxuICAgICAgICAgICAgY29uc3QgeCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHkgPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBib3R0b21Cb3VuZHMgPSBsaW5lQWRqdXN0ZWRIZWlnaHQgLSBNYXRoLmFicyhtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50KTtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dEJvdW5kcyA9IG5ldyBCb3VuZGluZ0JveCh7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiB4IC0gTWF0aC5hYnMobWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveExlZnQpIC0gdGhpcy5wYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgdG9wOiB5IC0gTWF0aC5hYnMobWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveEFzY2VudCkgLSB0aGlzLnBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICBib3R0b206IHkgKyBib3R0b21Cb3VuZHMgKyB0aGlzLnBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICByaWdodDogeCArIE1hdGguYWJzKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodCkgKyB0aGlzLnBhZGRpbmdcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3ByZURyYXcoZXgsIHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy5kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLl9wcmVEcmF3KGV4LCB4LCB5KTtcclxuICAgIH1cclxuICAgIF9wb3N0RHJhdyhleCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNob3dEZWJ1Zykge1xyXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICBleC5kZWJ1Zy5kcmF3UmVjdCgtdGhpcy5faGFsZlJhc3RlcldpZHRoLCAtdGhpcy5faGFsZlJhc3RlckhlaWdodCwgdGhpcy5fcmFzdGVyV2lkdGgsIHRoaXMuX3Jhc3RlckhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIF9hcHBseUZvbnQoY3R4KSB7XHJcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnBhZGRpbmcgKyB0aGlzLl9oYWxmUmFzdGVyV2lkdGgsIHRoaXMucGFkZGluZyArIHRoaXMuX2hhbGZSYXN0ZXJIZWlnaHQpO1xyXG4gICAgICAgIGN0eC5zY2FsZSh0aGlzLnF1YWxpdHksIHRoaXMucXVhbGl0eSk7XHJcbiAgICAgICAgY3R4LnRleHRBbGlnbiA9IHRoaXMudGV4dEFsaWduO1xyXG4gICAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0aGlzLmJhc2VBbGlnbjtcclxuICAgICAgICBjdHguZm9udCA9IHRoaXMuZm9udFN0cmluZztcclxuICAgICAgICBjdHguZGlyZWN0aW9uID0gdGhpcy5kaXJlY3Rpb247XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XHJcbiAgICAgICAgICAgIGN0eC5zaGFkb3dDb2xvciA9IHRoaXMuc2hhZG93LmNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGN0eC5zaGFkb3dCbHVyID0gdGhpcy5zaGFkb3cuYmx1cjtcclxuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFggPSB0aGlzLnNoYWRvdy5vZmZzZXQueDtcclxuICAgICAgICAgICAgY3R4LnNoYWRvd09mZnNldFkgPSB0aGlzLnNoYWRvdy5vZmZzZXQueTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBleGVjdXRlKGN0eCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90ZXh0KSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSByZWFzb24gd2UgbmVlZCB0byByZS1hcHBseSB0aGUgZm9udCBpcyBzZXR0aW5nIHJhc3RlciBwcm9wZXJ0aWVzIChsaWtlIHdpZHRoL2hlaWdodCkgY2FuIHJlc2V0IHRoZSBjb250ZXh0IHByb3BzXHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5UmFzdGVyUHJvcGVyaXRlcyhjdHgpO1xyXG4gICAgICAgICAgICB0aGlzLl9hcHBseUZvbnQoY3R4KTtcclxuICAgICAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IHRoaXMuX3RleHRIZWlnaHQ7IC8vIFRPRE8gdXNlciBzcGVjaWZpZWQgbGluZSBoZWlnaHRcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9saW5lcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IHRoaXMuX2xpbmVzW2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguZmlsbFRleHQobGluZSwgMCwgaSAqIGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3Ryb2tlQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdHguc3Ryb2tlVGV4dChsaW5lLCAwLCBpICogbGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0RlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBIb3Jpem9udGFsIGxpbmVcclxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgICAgICBsaW5lKGN0eCwgQ29sb3IuUmVkLCAtdGhpcy5faGFsZlJhc3RlcldpZHRoLCAwLCB0aGlzLl9oYWxmUmFzdGVyV2lkdGgsIDAsIDIpO1xyXG4gICAgICAgICAgICAgICAgLy8gVmVydGljYWwgbGluZVxyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgIGxpbmUoY3R4LCBDb2xvci5SZWQsIDAsIC10aGlzLl9oYWxmUmFzdGVySGVpZ2h0LCAwLCB0aGlzLl9oYWxmUmFzdGVySGVpZ2h0LCAyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbmRlcihleCwgdGV4dCwgeCwgeSkge1xyXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dCh0ZXh0KTtcclxuICAgICAgICB0aGlzLmRyYXcoZXgsIHgsIHkpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvVGV4dC50c1xuXHJcblxyXG5cclxuXHJcbmNsYXNzIFRleHQgZXh0ZW5kcyBHcmFwaGljIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX3RleHQgPSAnJztcclxuICAgICAgICAvLyBUaGlzIG9yZGVyIGlzIGltcG9ydGFudCBmb250LCBjb2xvciwgdGhlbiB0ZXh0XHJcbiAgICAgICAgdGhpcy5mb250ID0gKF9hID0gb3B0aW9ucy5mb250KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXcgRm9udCgpO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSAoX2IgPSBvcHRpb25zLmNvbG9yKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmNvbG9yO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IG9wdGlvbnMudGV4dDtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVGV4dCh7XHJcbiAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dC5zbGljZSgpLFxyXG4gICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvci5jbG9uZSgpLFxyXG4gICAgICAgICAgICBmb250OiB0aGlzLmZvbnQuY2xvbmUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IHRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XHJcbiAgICB9XHJcbiAgICBzZXQgdGV4dCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3RleHQgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmZvbnQudXBkYXRlVGV4dCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvLyBUT0RPIFNwcml0ZUZvbnQgZG9lc24ndCBzdXBwb3J0IGEgY29sb3IgeWV0IDooXHJcbiAgICBnZXQgY29sb3IoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9udCBpbnN0YW5jZW9mIEZvbnQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9udC5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLkJsYWNrO1xyXG4gICAgfVxyXG4gICAgc2V0IGNvbG9yKGNvbG9yKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9udCBpbnN0YW5jZW9mIEZvbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5mb250LmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGZvbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvbnQ7XHJcbiAgICB9XHJcbiAgICBzZXQgZm9udChmb250KSB7XHJcbiAgICAgICAgaWYgKGZvbnQgaW5zdGFuY2VvZiBGb250KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvbnQgPSB3YXRjaChmb250LCAoZm9udCkgPT4gZm9udC5mbGFnRGlydHkoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9mb250ID0gZm9udDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udC53aWR0aDtcclxuICAgIH1cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udC5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udC5sb2NhbEJvdW5kcztcclxuICAgIH1cclxuICAgIF9yb3RhdGUoX2V4KSB7XHJcbiAgICAgICAgLy8gTm9uZSB0aGlzIGlzIGRlbGVnYXRlZCB0byBmb250XHJcbiAgICAgICAgLy8gVGhpcyBvdmVycmlkZSBlcmFzZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3JcclxuICAgIH1cclxuICAgIF9mbGlwKF9leCkge1xyXG4gICAgICAgIC8vIE5vbmUgdGhpcyBpcyBkZWxlZ2F0ZWQgdG8gZm9udFxyXG4gICAgICAgIC8vIFRoaXMgb3ZlcnJpZGUgZXJhc2VzIHRoZSBkZWZhdWx0IGJlaGF2aW9yXHJcbiAgICB9XHJcbiAgICBfZHJhd0ltYWdlKGV4LCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9udCBpbnN0YW5jZW9mIEZvbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5mb250LmNvbG9yID0gdGhpcy5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mb250LmZsaXBIb3Jpem9udGFsID0gdGhpcy5mbGlwSG9yaXpvbnRhbDtcclxuICAgICAgICB0aGlzLmZvbnQuZmxpcFZlcnRpY2FsID0gdGhpcy5mbGlwVmVydGljYWw7XHJcbiAgICAgICAgdGhpcy5mb250LnNjYWxlID0gdGhpcy5zY2FsZTtcclxuICAgICAgICB0aGlzLmZvbnQucm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgICAgIHRoaXMuZm9udC5vcmlnaW4gPSB0aGlzLm9yaWdpbjtcclxuICAgICAgICB0aGlzLmZvbnQub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICB0aGlzLmZvbnQucmVuZGVyKGV4LCB0aGlzLl90ZXh0LCB4LCB5KTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0xhYmVsLnRzXG52YXIgTGFiZWxfZGVjb3JhdGUgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogTGFiZWxzIGFyZSB0aGUgd2F5IHRvIGRyYXcgc21hbGwgYW1vdW50cyBvZiB0ZXh0IHRvIHRoZSBzY3JlZW4uIFRoZXkgYXJlXHJcbiAqIGFjdG9ycyBhbmQgaW5oZXJpdCBhbGwgb2YgdGhlIGJlbmVmaXRzIGFuZCBjYXBhYmlsaXRpZXMuXHJcbiAqL1xyXG5jbGFzcyBMYWJlbF9MYWJlbCBleHRlbmRzIEFjdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgYSBuZXcgbGFiZWxcclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmZvbnQgPSBuZXcgRm9udCgpO1xyXG4gICAgICAgIHRoaXMuX3RleHQgPSBuZXcgVGV4dCh7IHRleHQ6ICcnLCBmb250OiB0aGlzLmZvbnQgfSk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBsZXR0ZXIgc3BhY2luZyBvbiBhIExhYmVsLiBPbmx5IHN1cHBvcnRlZCB3aXRoIFNwcml0ZSBGb250cy5cclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tTcHJpdGVGb250LnNwYWNpbmddXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGV0dGVyU3BhY2luZyA9IDA7IC8vcHhcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgW1tTcHJpdGVGb250XV0gd2lsbCBiZSBjYXNlLXNlbnNpdGl2ZSB3aGVuIG1hdGNoaW5nIGNoYXJhY3RlcnMuXHJcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIEdyYXBoaWNzLlNwcml0ZUZvbnQuY2FzZUluc2Vuc2l0dmVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IHRydWU7XHJcbiAgICAgICAgY29uc3QgeyB0ZXh0LCBwb3MsIHgsIHksIHNwcml0ZUZvbnQsIGZvbnQsIGNvbG9yIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMucG9zID0gcG9zICE9PSBudWxsICYmIHBvcyAhPT0gdm9pZCAwID8gcG9zIDogKHggJiYgeSA/IHZlYyh4LCB5KSA6IHRoaXMucG9zKTtcclxuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0ICE9PSBudWxsICYmIHRleHQgIT09IHZvaWQgMCA/IHRleHQgOiB0aGlzLnRleHQ7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVGb250ID0gc3ByaXRlRm9udCAhPT0gbnVsbCAmJiBzcHJpdGVGb250ICE9PSB2b2lkIDAgPyBzcHJpdGVGb250IDogdGhpcy5zcHJpdGVGb250O1xyXG4gICAgICAgIHRoaXMuZm9udCA9IGZvbnQgIT09IG51bGwgJiYgZm9udCAhPT0gdm9pZCAwID8gZm9udCA6IHRoaXMuZm9udDtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3IgIT09IG51bGwgJiYgY29sb3IgIT09IHZvaWQgMCA/IGNvbG9yIDogdGhpcy5jb2xvcjtcclxuICAgICAgICBjb25zdCBnZnggPSB0aGlzLmdldChHcmFwaGljc0NvbXBvbmVudCk7XHJcbiAgICAgICAgZ2Z4LmFuY2hvciA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIGdmeC51c2UodGhpcy5fdGV4dCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IHRvIGRyYXcuXHJcbiAgICAgKi9cclxuICAgIGdldCB0ZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0LnRleHQ7XHJcbiAgICB9XHJcbiAgICBzZXQgdGV4dCh0ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5fdGV4dC50ZXh0ID0gdGV4dDtcclxuICAgIH1cclxuICAgIGdldCBjb2xvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dC5jb2xvcjtcclxuICAgIH1cclxuICAgIHNldCBjb2xvcihjb2xvcikge1xyXG4gICAgICAgIHRoaXMuX3RleHQuY29sb3IgPSBjb2xvcjtcclxuICAgIH1cclxuICAgIGdldCBvcGFjaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0Lm9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICBzZXQgb3BhY2l0eShvcGFjaXR5KSB7XHJcbiAgICAgICAgdGhpcy5fdGV4dC5vcGFjaXR5ID0gb3BhY2l0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBvciBnZXRzIHRoZSBib2xkIHByb3BlcnR5IG9mIHRoZSBsYWJlbCdzIHRleHQsIGJ5IGRlZmF1bHQgaXQncyBmYWxzZVxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbRm9udC5ib2xkfExhYmVsLmZvbnQuYm9sZF1dXHJcbiAgICAgKi9cclxuICAgIGdldCBib2xkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvbnQuYm9sZDtcclxuICAgIH1cclxuICAgIHNldCBib2xkKGlzQm9sZCkge1xyXG4gICAgICAgIHRoaXMuZm9udC5ib2xkID0gaXNCb2xkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgQ1NTIGZvbnQgZmFtaWx5IHN0cmluZyAoZS5nLiBgc2Fucy1zZXJpZmAsIGBEcm9pZCBTYW5zIFByb2ApLiBXZWIgZm9udHNcclxuICAgICAqIGFyZSBzdXBwb3J0ZWQsIHNhbWUgYXMgaW4gQ1NTLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbRm9udC5mYW1pbHl8TGFiZWwuZm9udC5mYW1pbHldXVxyXG4gICAgICovXHJcbiAgICBnZXQgZm9udEZhbWlseSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb250LmZhbWlseTtcclxuICAgIH1cclxuICAgIHNldCBmb250RmFtaWx5KGZhbWlseSkge1xyXG4gICAgICAgIHRoaXMuZm9udC5mYW1pbHkgPSBmYW1pbHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBmb250IHNpemUgaW4gdGhlIHNlbGVjdGVkIHVuaXRzLCBkZWZhdWx0IGlzIDEwIChkZWZhdWx0IHVuaXRzIGlzIHBpeGVsKVxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbRm9udC5zaXplfExhYmVsLmZvbnQuc2l6ZV1dXHJcbiAgICAgKi9cclxuICAgIGdldCBmb250U2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb250LnNpemU7XHJcbiAgICB9XHJcbiAgICBzZXQgZm9udFNpemUoc2l6ZUluVW5pdCkge1xyXG4gICAgICAgIHRoaXMuZm9udC5zaXplID0gc2l6ZUluVW5pdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZvbnQgc3R5bGUgZm9yIHRoaXMgbGFiZWwsIHRoZSBkZWZhdWx0IGlzIFtbRm9udFN0eWxlLk5vcm1hbF1dXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tGb250LnN0eWxlfExhYmVsLmZvbnQuc3R5bGVdXVxyXG4gICAgICovXHJcbiAgICBnZXQgZm9udFN0eWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvbnQuc3R5bGU7XHJcbiAgICB9XHJcbiAgICBzZXQgZm9udFN0eWxlKHN0eWxlKSB7XHJcbiAgICAgICAgdGhpcy5mb250LnN0eWxlID0gc3R5bGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBjc3MgdW5pdHMgZm9yIGEgZm9udCBzaXplIHN1Y2ggYXMgcHgsIHB0LCBlbSAoU3ByaXRlRm9udCBvbmx5IHN1cHBvcnQgcHgpLCBieSBkZWZhdWx0IGlzICdweCc7XHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tGb250LnVuaXR8TGFiZWwuZm9udC51bml0XV1cclxuICAgICAqL1xyXG4gICAgZ2V0IGZvbnRVbml0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvbnQudW5pdDtcclxuICAgIH1cclxuICAgIHNldCBmb250VW5pdCh1bml0KSB7XHJcbiAgICAgICAgdGhpcy5mb250LnVuaXQgPSB1bml0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGhvcml6b250YWwgdGV4dCBhbGlnbm1lbnQgcHJvcGVydHkgZm9yIHRoZSBsYWJlbC5cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW0ZvbnQudGV4dEFsaWdufExhYmVsLmZvbnQudGV4dEFsaWduXV1cclxuICAgICAqL1xyXG4gICAgZ2V0IHRleHRBbGlnbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb250LnRleHRBbGlnbjtcclxuICAgIH1cclxuICAgIHNldCB0ZXh0QWxpZ24oYWxpZ24pIHtcclxuICAgICAgICB0aGlzLmZvbnQudGV4dEFsaWduID0gYWxpZ247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFzZWxpbmUgYWxpZ25tZW50IHByb3BlcnR5IGZvciB0aGUgbGFiZWwuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tGb250LmJhc2VBbGlnbnxMYWJlbC5mb250LmJhc2VBbGlnbl1dXHJcbiAgICAgKi9cclxuICAgIGdldCBiYXNlQWxpZ24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udC5iYXNlQWxpZ247XHJcbiAgICB9XHJcbiAgICBzZXQgYmFzZUFsaWduKGFsaWduKSB7XHJcbiAgICAgICAgdGhpcy5mb250LmJhc2VBbGlnbiA9IGFsaWduO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgW1tMZWdhY3lEcmF3aW5nLlNwcml0ZUZvbnRdXSB0byB1c2UsIGlmIGFueS4gT3ZlcnJpZGVzIFtbZm9udEZhbWlseV1dIGlmIHByZXNlbnQuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tTcHJpdGVGb250XV1cclxuICAgICAqL1xyXG4gICAgZ2V0IHNwcml0ZUZvbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZ2FjeVNwcml0ZUZvbnQ7XHJcbiAgICB9XHJcbiAgICBzZXQgc3ByaXRlRm9udChzZikge1xyXG4gICAgICAgIGlmIChzZikge1xyXG4gICAgICAgICAgICBpZiAoc2YgaW5zdGFuY2VvZiBTcHJpdGVGb250KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sZWdhY3lTcHJpdGVGb250ID0gc2Y7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGVGb250ID0gU3ByaXRlRm9udF9TcHJpdGVGb250LmZyb21MZWdhY3lTcHJpdGVGb250KHNmKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RleHQuZm9udCA9IHRoaXMuX3Nwcml0ZUZvbnQ7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlRm9udCA9IHNmO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0LmZvbnQgPSB0aGlzLl9zcHJpdGVGb250O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9pbml0aWFsaXplKGVuZ2luZSkge1xyXG4gICAgICAgIHN1cGVyLl9pbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0ID0gZW5naW5lLmdyYXBoaWNzQ29udGV4dDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIHRleHQgaW4gdGhlIGxhYmVsIChpbiBwaXhlbHMpO1xyXG4gICAgICovXHJcbiAgICBnZXRUZXh0V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQud2lkdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRleHQgc2hhZG93IGZvciBzcHJpdGUgZm9udHNcclxuICAgICAqIEBwYXJhbSBvZmZzZXRYICAgICAgVGhlIHggb2Zmc2V0IGluIHBpeGVscyB0byBwbGFjZSB0aGUgc2hhZG93XHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0WSAgICAgIFRoZSB5IG9mZnNldCBpbiBwaXhlbHMgdG8gcGxhY2UgdGhlIHNoYWRvd1xyXG4gICAgICogQHBhcmFtIHNoYWRvd0NvbG9yICBUaGUgY29sb3Igb2YgdGhlIHRleHQgc2hhZG93XHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tGb250LnNoYWRvd3xMYWJlbC5mb250LnNoYWRvd11dXHJcbiAgICAgKi9cclxuICAgIHNldFRleHRTaGFkb3cob2Zmc2V0WCwgb2Zmc2V0WSwgc2hhZG93Q29sb3IpIHtcclxuICAgICAgICB0aGlzLmZvbnQuc2hhZG93ID0geyBvZmZzZXQ6IHZlYyhvZmZzZXRYLCBvZmZzZXRZKSwgYmx1cjogMiwgY29sb3I6IHNoYWRvd0NvbG9yIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvZ2dsZXMgdGV4dCBzaGFkb3dzIG9uIG9yIG9mZiwgb25seSBhcHBsaWVzIHdoZW4gdXNpbmcgc3ByaXRlIGZvbnRzXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tGb250LnNoYWRvd3xMYWJlbC5mb250LnNoYWRvd11dXHJcbiAgICAgKi9cclxuICAgIHVzZVRleHRTaGFkb3cob24pIHtcclxuICAgICAgICBpZiAodGhpcy5zcHJpdGVGb250KSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlRm9udC51c2VUZXh0U2hhZG93KG9uKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgY3VycmVudCB0ZXh0IHNoYWRvd1xyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbRm9udC5zaGFkb3d8TGFiZWwuZm9udC5zaGFkb3ddXVxyXG4gICAgICovXHJcbiAgICBjbGVhclRleHRTaGFkb3coKSB7XHJcbiAgICAgICAgdGhpcy5mb250LnNoYWRvdyA9IG51bGw7XHJcbiAgICB9XHJcbiAgICBkcmF3KF9jdHgsIF9kZWx0YSkge1xyXG4gICAgICAgIGNvbnN0IGV4Y3R4ID0gdGhpcy5fZ3JhcGhpY3NDb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX3RleHQuZHJhdyhleGN0eCwgMCwgMCk7XHJcbiAgICB9XHJcbn1cclxuTGFiZWxfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdMYWJlbC5ib2xkIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgTGFiZWwuZm9udC5ib2xkJ1xyXG4gICAgfSlcclxuXSwgTGFiZWxfTGFiZWwucHJvdG90eXBlLCBcImJvbGRcIiwgbnVsbCk7XHJcbkxhYmVsX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnTGFiZWwuZm9udEZhbWlseSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIExhYmVsLmZvbnQuZmFtaWx5J1xyXG4gICAgfSlcclxuXSwgTGFiZWxfTGFiZWwucHJvdG90eXBlLCBcImZvbnRGYW1pbHlcIiwgbnVsbCk7XHJcbkxhYmVsX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnTGFiZWwuZm9udFNpemUgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBMYWJlbC5mb250LnNpemUnXHJcbiAgICB9KVxyXG5dLCBMYWJlbF9MYWJlbC5wcm90b3R5cGUsIFwiZm9udFNpemVcIiwgbnVsbCk7XHJcbkxhYmVsX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnTGFiZWwuZm9udFN0eWxlIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgTGFibGUuZm9udC5zdHlsZSdcclxuICAgIH0pXHJcbl0sIExhYmVsX0xhYmVsLnByb3RvdHlwZSwgXCJmb250U3R5bGVcIiwgbnVsbCk7XHJcbkxhYmVsX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnTGFiZWwuZm9udFVuaXQgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBMYWJlbC5mb250LnVuaXQnXHJcbiAgICB9KVxyXG5dLCBMYWJlbF9MYWJlbC5wcm90b3R5cGUsIFwiZm9udFVuaXRcIiwgbnVsbCk7XHJcbkxhYmVsX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnTGFiZWwudGV4dEFsaWduIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgTGFiZWwuZm9udC50ZXh0QWxpZ24nXHJcbiAgICB9KVxyXG5dLCBMYWJlbF9MYWJlbC5wcm90b3R5cGUsIFwidGV4dEFsaWduXCIsIG51bGwpO1xyXG5MYWJlbF9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0xhYmVsLmJhc2VBbGlnbiB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIExhYmVsLmZvbnQuYmFzZUFsaWduJ1xyXG4gICAgfSlcclxuXSwgTGFiZWxfTGFiZWwucHJvdG90eXBlLCBcImJhc2VBbGlnblwiLCBudWxsKTtcclxuTGFiZWxfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoKVxyXG5dLCBMYWJlbF9MYWJlbC5wcm90b3R5cGUsIFwic3ByaXRlRm9udFwiLCBudWxsKTtcclxuTGFiZWxfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdMYWJlbC5zZXRUZXh0U2hhZG93IHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgTGFiZWwuZm9udC5zaGFkb3cnXHJcbiAgICB9KVxyXG5dLCBMYWJlbF9MYWJlbC5wcm90b3R5cGUsIFwic2V0VGV4dFNoYWRvd1wiLCBudWxsKTtcclxuTGFiZWxfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdMYWJlbC51c2VUZXh0U2hhZG93IHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgTGFiZWwuZm9udC5zaGFkb3cnXHJcbiAgICB9KVxyXG5dLCBMYWJlbF9MYWJlbC5wcm90b3R5cGUsIFwidXNlVGV4dFNoYWRvd1wiLCBudWxsKTtcclxuTGFiZWxfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdMYWJlbC5jbGVhclRleHRTaGFkb3cgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBMYWJlbC5mb250LnNoYWRvdydcclxuICAgIH0pXHJcbl0sIExhYmVsX0xhYmVsLnByb3RvdHlwZSwgXCJjbGVhclRleHRTaGFkb3dcIiwgbnVsbCk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9JbmRleC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vR3JvdXAvQ29sbGlzaW9uR3JvdXBNYW5hZ2VyLnRzXG5cclxuLyoqXHJcbiAqIFN0YXRpYyBjbGFzcyBmb3IgbWFuYWdpbmcgY29sbGlzaW9uIGdyb3VwcyBpbiBleGNhbGlidXIsIHRoZXJlIGlzIGEgbWF4aW11bSBvZiAzMiBjb2xsaXNpb24gZ3JvdXBzIHBvc3NpYmxlIGluIGV4Y2FsaWJ1clxyXG4gKi9cclxuY2xhc3MgQ29sbGlzaW9uR3JvdXBNYW5hZ2VyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IG5hbWVkIGNvbGxpc2lvbiBncm91cCB1cCB0byBhIG1heCBvZiAzMi5cclxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgZm9yIHRoZSBjb2xsaXNpb24gZ3JvdXBcclxuICAgICAqIEBwYXJhbSBtYXNrIE9wdGlvbmFsbHkgcHJvdmlkZSB5b3VyIG93biAzMi1iaXQgbWFzaywgaWYgbm9uZSBpcyBwcm92aWRlIHRoZSBtYW5hZ2VyIHdpbGwgZ2VuZXJhdGUgb25lXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjcmVhdGUobmFtZSwgbWFzaykge1xyXG4gICAgICAgIGlmICh0aGlzLl9DVVJSRU5UX0dST1VQID4gdGhpcy5fTUFYX0dST1VQUykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBoYXZlIG1vcmUgdGhhbiAke3RoaXMuX01BWF9HUk9VUFN9IGNvbGxpc2lvbiBncm91cHNgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX0dST1VQUy5nZXQobmFtZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2xsaXNpb24gZ3JvdXAgJHtuYW1lfSBhbHJlYWR5IGV4aXN0c2ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBncm91cCA9IG5ldyBDb2xsaXNpb25Hcm91cChuYW1lLCB0aGlzLl9DVVJSRU5UX0JJVCwgbWFzayAhPT0gdW5kZWZpbmVkID8gbWFzayA6IH50aGlzLl9DVVJSRU5UX0JJVCk7XHJcbiAgICAgICAgdGhpcy5fQ1VSUkVOVF9CSVQgPSAodGhpcy5fQ1VSUkVOVF9CSVQgPDwgMSkgfCAwO1xyXG4gICAgICAgIHRoaXMuX0NVUlJFTlRfR1JPVVArKztcclxuICAgICAgICB0aGlzLl9HUk9VUFMuc2V0KG5hbWUsIGdyb3VwKTtcclxuICAgICAgICByZXR1cm4gZ3JvdXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhbGwgY29sbGlzaW9uIGdyb3VwcyBjdXJyZW50bHkgdHJhY2tlZCBieSBleGNhbGlidXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBncm91cHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fR1JPVVBTLnZhbHVlcygpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgY29sbGlzaW9uIGdyb3VwIGJ5IGl0J3MgbmFtZVxyXG4gICAgICogQHBhcmFtIG5hbWVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdyb3VwQnlOYW1lKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fR1JPVVBTLmdldChuYW1lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBtYW5hZ2VycyBpbnRlcm5hbCBncm91cCBtYW5hZ2VtZW50IHN0YXRlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9HUk9VUFMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fQ1VSUkVOVF9CSVQgPSB0aGlzLl9TVEFSVElOR19CSVQ7XHJcbiAgICAgICAgdGhpcy5fQ1VSUkVOVF9HUk9VUCA9IDE7XHJcbiAgICB9XHJcbn1cclxuLy8gdXNpbmcgYml0bWFza2luZyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZ3JvdXBzIGlzIDMyLCBiZWNhdXNlIHRoYXQgaXMgdGhlIGhpZ2hlc3QgMzJiaXQgaW50ZWdlciB0aGF0IEpTIGNhbiBwcmVzZW50LlxyXG5Db2xsaXNpb25Hcm91cE1hbmFnZXIuX1NUQVJUSU5HX0JJVCA9IDBiMSB8IDA7XHJcbkNvbGxpc2lvbkdyb3VwTWFuYWdlci5fTUFYX0dST1VQUyA9IDMyO1xyXG5Db2xsaXNpb25Hcm91cE1hbmFnZXIuX0NVUlJFTlRfR1JPVVAgPSAxO1xyXG5Db2xsaXNpb25Hcm91cE1hbmFnZXIuX0NVUlJFTlRfQklUID0gQ29sbGlzaW9uR3JvdXBNYW5hZ2VyLl9TVEFSVElOR19CSVQ7XHJcbkNvbGxpc2lvbkdyb3VwTWFuYWdlci5fR1JPVVBTID0gbmV3IE1hcCgpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9JbmRleC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRHJhd2luZy9Qb2x5Z29uLnRzXG52YXIgUG9seWdvbl9kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuXHJcblxyXG4vKipcclxuICogQ3JlYXRlcyBhIGNsb3NlZCBwb2x5Z29uIGRyYXdpbmcgZ2l2ZW4gYSBsaXN0IG9mIFtbVmVjdG9yXV1zLlxyXG4gKlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgW1tQb2x5Z29uXV1cclxuICogQHdhcm5pbmcgVXNlIHNwYXJpbmdseSBhcyBQb2x5Z29ucyBhcmUgcGVyZm9ybWFuY2UgaW50ZW5zaXZlXHJcbiAqL1xyXG5sZXQgUG9seWdvbiA9IGNsYXNzIFBvbHlnb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRzICBUaGUgdmVjdG9ycyB0byB1c2UgdG8gYnVpbGQgdGhlIHBvbHlnb24gaW4gb3JkZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IocG9pbnRzKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHdpZHRoIG9mIHRoZSBsaW5lcyBvZiB0aGUgcG9seWdvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGluZVdpZHRoID0gNTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgcG9seWdvbiBpcyBmaWxsZWQgb3Igbm90LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5hbmNob3IgPSBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLm9mZnNldCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBWZWN0b3IuT25lO1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRzID0gcG9pbnRzO1xyXG4gICAgICAgIGNvbnN0IG1pblggPSB0aGlzLl9wb2ludHMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihwcmV2LCBjdXJyLngpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIGNvbnN0IG1heFggPSB0aGlzLl9wb2ludHMucmVkdWNlKChwcmV2LCBjdXJyKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1heChwcmV2LCBjdXJyLngpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIHRoaXMuZHJhd1dpZHRoID0gbWF4WCAtIG1pblg7XHJcbiAgICAgICAgY29uc3QgbWluWSA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHByZXYsIGN1cnIueSk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgY29uc3QgbWF4WSA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHByZXYsIGN1cnIueSk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgdGhpcy5kcmF3SGVpZ2h0ID0gbWF4WSAtIG1pblk7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmRyYXdIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuZHJhd1dpZHRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbm90aW1wbGVtZW50ZWQgRWZmZWN0cyBhcmUgbm90IHN1cHBvcnRlZCBvbiBgUG9seWdvbmBcclxuICAgICAqL1xyXG4gICAgYWRkRWZmZWN0KCkge1xyXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgb24gcG9seWdvbnNcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG5vdGltcGxlbWVudGVkIEVmZmVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gYFBvbHlnb25gXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUVmZmVjdCgpIHtcclxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIG9uIHBvbHlnb25zXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBub3RpbXBsZW1lbnRlZCBFZmZlY3RzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIGBQb2x5Z29uYFxyXG4gICAgICovXHJcbiAgICBjbGVhckVmZmVjdHMoKSB7XHJcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBvbiBwb2x5Z29uc1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgLy9wYXNzXHJcbiAgICB9XHJcbiAgICBkcmF3KGN0eE9yT3B0aW9ucywgeCwgeSkge1xyXG4gICAgICAgIGlmIChjdHhPck9wdGlvbnMgaW5zdGFuY2VvZiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZHJhd1dpdGhPcHRpb25zKHsgY3R4OiBjdHhPck9wdGlvbnMsIHgsIHkgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9kcmF3V2l0aE9wdGlvbnMoY3R4T3JPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZHJhd1dpdGhPcHRpb25zKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfajtcclxuICAgICAgICBjb25zdCB7IGN0eCwgeCwgeSwgcm90YXRpb24sIGRyYXdXaWR0aCwgZHJhd0hlaWdodCwgYW5jaG9yLCBvZmZzZXQsIG9wYWNpdHksIGZsaXBIb3Jpem9udGFsLCBmbGlwVmVydGljYWwgfSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgcm90YXRpb246IChfYSA9IG9wdGlvbnMucm90YXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucm90YXRpb24sIGRyYXdXaWR0aDogKF9iID0gb3B0aW9ucy5kcmF3V2lkdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuZHJhd1dpZHRoLCBkcmF3SGVpZ2h0OiAoX2MgPSBvcHRpb25zLmRyYXdIZWlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMuZHJhd0hlaWdodCwgZmxpcEhvcml6b250YWw6IChfZCA9IG9wdGlvbnMuZmxpcEhvcml6b250YWwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRoaXMuZmxpcEhvcml6b250YWwsIGZsaXBWZXJ0aWNhbDogKF9lID0gb3B0aW9ucy5mbGlwVmVydGljYWwpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMuZmxpcFZlcnRpY2FsLCBhbmNob3I6IChfZiA9IG9wdGlvbnMuYW5jaG9yKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0aGlzLmFuY2hvciwgb2Zmc2V0OiAoX2cgPSBvcHRpb25zLm9mZnNldCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdGhpcy5vZmZzZXQsIG9wYWNpdHk6ICgoX2ggPSBvcHRpb25zLm9wYWNpdHkpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IDEpICogKChfaiA9IHRoaXMub3BhY2l0eSkgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogMSkgfSk7XHJcbiAgICAgICAgY29uc3QgeHBvaW50ID0gZHJhd1dpZHRoICogYW5jaG9yLnggKyBvZmZzZXQueCArIHg7XHJcbiAgICAgICAgY29uc3QgeXBvaW50ID0gZHJhd0hlaWdodCAqIGFuY2hvci55ICsgb2Zmc2V0LnkgKyB5O1xyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh4cG9pbnQsIHlwb2ludCk7XHJcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55KTtcclxuICAgICAgICBjdHgucm90YXRlKHJvdGF0aW9uKTtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IHRoaXMubGluZVdpZHRoO1xyXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc3VwcGxpZWQgcG9pbnRzIGFuZCBjb25zdHJ1Y3QgYSAncG9seWdvbidcclxuICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gdGhpcy5fcG9pbnRzWzBdO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLl9wb2ludHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5fcG9pbnRzW2ldLngsIHRoaXMuX3BvaW50c1tpXS55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGlmICh0aGlzLmZpbGxlZCkge1xyXG4gICAgICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5maWxsQ29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gdGhpcy5saW5lQ29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAoZmxpcEhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShkcmF3V2lkdGgsIDApO1xyXG4gICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmxpcFZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgZHJhd0hlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9sZEFscGhhID0gY3R4Lmdsb2JhbEFscGhhO1xyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9sZEFscGhhO1xyXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbn07XHJcblBvbHlnb24gPSBQb2x5Z29uX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnUG9seWdvbiB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIEdyYXBoaWNzLlBvbHlnb24nXHJcbiAgICB9KVxyXG5dLCBQb2x5Z29uKTtcclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRHJhd2luZy9JbmRleC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnRlcmZhY2VzL0F1ZGlvSW1wbGVtZW50YXRpb24udHNcbmNsYXNzIEV4UmVzcG9uc2Uge1xyXG59XHJcbkV4UmVzcG9uc2UudHlwZSA9IHtcclxuICAgIGFueTogJycsXHJcbiAgICBibG9iOiAnYmxvYicsXHJcbiAgICBqc29uOiAnanNvbicsXHJcbiAgICB0ZXh0OiAndGV4dCcsXHJcbiAgICBkb2N1bWVudDogJ2RvY3VtZW50JyxcclxuICAgIGFycmF5YnVmZmVyOiAnYXJyYXlidWZmZXInXHJcbn07XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vSW50ZXJmYWNlcy9MaWZlY3ljbGVFdmVudHMudHNcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIGNoZWNraW5nIGZvciBpbnRlcm5hbCBpbml0aWFsaXplIG1ldGhvZFxyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIGFcclxuICovXHJcbmZ1bmN0aW9uIGhhc19pbml0aWFsaXplKGEpIHtcclxuICAgIHJldHVybiAhIWEuX2luaXRpYWxpemU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNPbkluaXRpYWxpemUoYSkge1xyXG4gICAgcmV0dXJuICEhYS5vbkluaXRpYWxpemU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNfcHJldXBkYXRlKGEpIHtcclxuICAgIHJldHVybiAhIWEuX3ByZXVwZGF0ZTtcclxufVxyXG4vKipcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGhhc09uUHJlVXBkYXRlKGEpIHtcclxuICAgIHJldHVybiAhIWEub25QcmVVcGRhdGU7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNfcG9zdHVwZGF0ZShhKSB7XHJcbiAgICByZXR1cm4gISFhLm9uUG9zdFVwZGF0ZTtcclxufVxyXG4vKipcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGhhc09uUG9zdFVwZGF0ZShhKSB7XHJcbiAgICByZXR1cm4gISFhLm9uUG9zdFVwZGF0ZTtcclxufVxyXG4vKipcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGhhc1ByZURyYXcoYSkge1xyXG4gICAgcmV0dXJuICEhYS5vblByZURyYXc7XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNQb3N0RHJhdyhhKSB7XHJcbiAgICByZXR1cm4gISFhLm9uUG9zdERyYXc7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnRlcmZhY2VzL0luZGV4LnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1Bvc3RQcm9jZXNzaW5nL0luZGV4LnRzXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUmVzb3VyY2VzL1NvdW5kL1dlYkF1ZGlvSW5zdGFuY2UudHNcblxyXG5cclxuLyoqXHJcbiAqIEludGVybmFsIGNsYXNzIHJlcHJlc2VudGluZyBhIFdlYiBBdWRpbyBBdWRpb0J1ZmZlclNvdXJjZU5vZGUgaW5zdGFuY2VcclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2ViX0F1ZGlvX0FQSVxyXG4gKi9cclxuY2xhc3MgV2ViQXVkaW9JbnN0YW5jZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfc3JjKSB7XHJcbiAgICAgICAgdGhpcy5fc3JjID0gX3NyYztcclxuICAgICAgICB0aGlzLl92b2x1bWUgPSAxO1xyXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2F1ZGlvQ29udGV4dCA9IEF1ZGlvQ29udGV4dEZhY3RvcnkuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy5fdm9sdW1lTm9kZSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBwbGF5YmFjayBvZmZzZXQgKGluIHNlY29uZHMpXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3JlYXRlTmV3QnVmZmVyU291cmNlKCk7XHJcbiAgICB9XHJcbiAgICBzZXQgbG9vcCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2xvb3AgPSB2YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UubG9vcCA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IGxvb3AoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3A7XHJcbiAgICB9XHJcbiAgICBzZXQgdm9sdW1lKHZhbHVlKSB7XHJcbiAgICAgICAgdmFsdWUgPSBjbGFtcCh2YWx1ZSwgMCwgMS4wKTtcclxuICAgICAgICB0aGlzLl92b2x1bWUgPSB2YWx1ZTtcclxuICAgICAgICBpZiAodGhpcy5faXNQbGF5aW5nICYmIHRoaXMuX3ZvbHVtZU5vZGUuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUpIHtcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0F1ZGlvUGFyYW0vc2V0VGFyZ2V0QXRUaW1lXHJcbiAgICAgICAgICAgIC8vIEFmdGVyIGVhY2ggLjEgc2Vjb25kcyB0aW1lc3RlcCwgdGhlIHRhcmdldCB2YWx1ZSB3aWxsIH42My4yJSBjbG9zZXIgdG8gdGhlIHRhcmdldCB2YWx1ZS5cclxuICAgICAgICAgICAgLy8gVGhpcyBleHBvbmVudGlhbCByYW1wIHByb3ZpZGVzIGEgbW9yZSBwbGVhc2FudCB0cmFuc2l0aW9uIGluIGdhaW5cclxuICAgICAgICAgICAgdGhpcy5fdm9sdW1lTm9kZS5nYWluLnNldFRhcmdldEF0VGltZSh2YWx1ZSwgdGhpcy5fYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lLCAwLjEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdm9sdW1lTm9kZS5nYWluLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHZvbHVtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lO1xyXG4gICAgfVxyXG4gICAgc2V0IGR1cmF0aW9uKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHVyYXRpb24gb2YgdGhlIHNvdW5kLCBpbiBzZWNvbmRzLlxyXG4gICAgICovXHJcbiAgICBnZXQgZHVyYXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgZ2V0IF9wbGF5YmFja1JhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2luc3RhbmNlID8gMSAvICh0aGlzLl9pbnN0YW5jZS5wbGF5YmFja1JhdGUudmFsdWUgfHwgMS4wKSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICBpc1BsYXlpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzUGxheWluZztcclxuICAgIH1cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cclxuICAgIHBsYXkocGxheVN0YXJ0ZWQgPSAoKSA9PiB7IH0pIHtcclxuICAgICAgICBpZiAodGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzdW1lUGxheUJhY2soKTtcclxuICAgICAgICAgICAgcGxheVN0YXJ0ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRQbGF5QmFjaygpO1xyXG4gICAgICAgICAgICBwbGF5U3RhcnRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcGxheWluZ1Byb21pc2U7XHJcbiAgICB9XHJcbiAgICBwYXVzZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5zdG9wKDApO1xyXG4gICAgICAgIC8vIFBsYXliYWNrIHJhdGUgd2lsbCBiZSBhIHNjYWxlIGZhY3RvciBvZiBob3cgZmFzdC9zbG93IHRoZSBhdWRpbyBpcyBiZWluZyBwbGF5ZWRcclxuICAgICAgICAvLyBkZWZhdWx0IGlzIDEuMFxyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gaW52ZXJ0IGl0IHRvIGdldCB0aGUgdGltZSBzY2FsZVxyXG4gICAgICAgIHRoaXMuX3NldFBhdXNlT2Zmc2V0KCk7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5zdG9wKDApO1xyXG4gICAgICAgIC8vIGhhbmRsZXIgd2lsbCBub3QgYmUgd2lyZWQgdXAgaWYgd2Ugd2VyZSBsb29waW5nXHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZS5vbmVuZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZU9uRW5kZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc3RhcnRQbGF5QmFjaygpIHtcclxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcGxheWluZ1Byb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5aW5nUmVzb2x2ZSA9IHJlc29sdmU7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVOZXdCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVtZW1iZXJTdGFydFRpbWUoKTtcclxuICAgICAgICB0aGlzLl92b2x1bWVOb2RlLmNvbm5lY3QodGhpcy5fYXVkaW9Db250ZXh0LmRlc3RpbmF0aW9uKTtcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5zdGFydCgwLCAwKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICB9XHJcbiAgICBfcmVzdW1lUGxheUJhY2soKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICAvLyBhIGJ1ZmZlciBzb3VyY2UgY2FuIG9ubHkgYmUgc3RhcnRlZCBvbmNlXHJcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBkaXNwb3NlIG9mIHRoZSBwcmV2aW91cyBpbnN0YW5jZSBiZWZvcmVcclxuICAgICAgICAvLyBcInJlc3VtaW5nXCIgdGhlIG5leHQgb25lXHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2Uub25lbmRlZCA9IG51bGw7IC8vIGRpc3Bvc2Ugb2YgYW55IHByZXZpb3VzIGV2ZW50IGhhbmRsZXJcclxuICAgICAgICB0aGlzLl9jcmVhdGVOZXdCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IHRoaXMuX3BsYXliYWNrUmF0ZSAqIHRoaXMuX3NyYy5kdXJhdGlvbjtcclxuICAgICAgICBjb25zdCByZXN0YXJ0VGltZSA9IHRoaXMuX2N1cnJlbnRPZmZzZXQgJSBkdXJhdGlvbjtcclxuICAgICAgICB0aGlzLl9yZW1lbWJlclN0YXJ0VGltZShyZXN0YXJ0VGltZSAqIC0xMDAwKTtcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5zdGFydCgwLCByZXN0YXJ0VGltZSk7XHJcbiAgICAgICAgdGhpcy5fd2lyZVVwT25FbmRlZCgpO1xyXG4gICAgfVxyXG4gICAgX3dpcmVVcE9uRW5kZWQoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmxvb3ApIHtcclxuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2Uub25lbmRlZCA9ICgpID0+IHRoaXMuX2hhbmRsZU9uRW5kZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlT25FbmRlZCgpIHtcclxuICAgICAgICAvLyBwYXVzaW5nIGNhbGxzIHN0b3AoMCkgd2hpY2ggdHJpZ2dlcnMgb25lbmRlZCBldmVudFxyXG4gICAgICAgIC8vIHNvIHdlIGRvbid0IFwicmVzb2x2ZVwiIHlldCAod2hlbiB3ZSByZXN1bWUgd2UnbGwgdHJ5IGFnYWluKVxyXG4gICAgICAgIGlmICghdGhpcy5faXNQYXVzZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdSZXNvbHZlKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9yZW1lbWJlclN0YXJ0VGltZShhbWVuZCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgKGFtZW5kIHwgMCk7XHJcbiAgICB9XHJcbiAgICBfc2V0UGF1c2VPZmZzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE9mZnNldCA9ICgobmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9zdGFydFRpbWUpICogdGhpcy5fcGxheWJhY2tSYXRlKSAvIDEwMDA7IC8vIGluIHNlY29uZHNcclxuICAgIH1cclxuICAgIF9jcmVhdGVOZXdCdWZmZXJTb3VyY2UoKSB7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UgPSB0aGlzLl9hdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyU291cmNlKCk7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UuYnVmZmVyID0gdGhpcy5fc3JjO1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlLmxvb3AgPSB0aGlzLmxvb3A7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UucGxheWJhY2tSYXRlLnNldFZhbHVlQXRUaW1lKDEuMCwgMCk7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UuY29ubmVjdCh0aGlzLl92b2x1bWVOb2RlKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvU291bmQudHNcblxyXG4vKipcclxuICogV2hldGhlciBvciBub3QgdGhlIGJyb3dzZXIgY2FuIHBsYXkgdGhpcyBmaWxlIGFzIEhUTUw1IEF1ZGlvXHJcbiAqL1xyXG5mdW5jdGlvbiBjYW5QbGF5RmlsZShmaWxlKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGEgPSBuZXcgQXVkaW8oKTtcclxuICAgICAgICBjb25zdCBmaWxldHlwZSA9IC8uKlxcLihbQS1aYS16MC05XSspJC87XHJcbiAgICAgICAgY29uc3QgdHlwZSA9IGZpbGUubWF0Y2goZmlsZXR5cGUpWzFdO1xyXG4gICAgICAgIGlmIChhLmNhblBsYXlUeXBlKCdhdWRpby8nICsgdHlwZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdDYW5ub3QgZGV0ZXJtaW5lIGF1ZGlvIHN1cHBvcnQsIGFzc3VtaW5nIG5vIHN1cHBvcnQgZm9yIHRoZSBBdWRpbyBUYWcnLCBlKTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9SZXNvdXJjZXMvU291bmQvU291bmQudHNcbnZhciBTb3VuZF9hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgW1tTb3VuZF1dIG9iamVjdCBhbGxvd3MgZ2FtZXMgYnVpbHQgaW4gRXhjYWxpYnVyIHRvIGxvYWQgYXVkaW9cclxuICogY29tcG9uZW50cywgZnJvbSBzb3VuZHRyYWNrcyB0byBzb3VuZCBlZmZlY3RzLiBbW1NvdW5kXV0gaXMgYW4gW1tMb2FkYWJsZV1dXHJcbiAqIHdoaWNoIG1lYW5zIGl0IGNhbiBiZSBwYXNzZWQgdG8gYSBbW0xvYWRlcl1dIHRvIHByZS1sb2FkIGJlZm9yZSBhIGdhbWUgb3IgbGV2ZWwuXHJcbiAqL1xyXG5jbGFzcyBTb3VuZCBleHRlbmRzIENsYXNzIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHBhdGhzIEEgbGlzdCBvZiBhdWRpbyBzb3VyY2VzIChjbGlwLndhdiwgY2xpcC5tcDMsIGNsaXAub2dnKSBmb3IgdGhpcyBhdWRpbyBjbGlwLiBUaGlzIGlzIGRvbmUgZm9yIGJyb3dzZXIgY29tcGF0aWJpbGl0eS5cclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoLi4ucGF0aHMpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3ZvbHVtZSA9IDE7XHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5faXNTdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90cmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9hdWRpb0NvbnRleHQgPSBBdWRpb0NvbnRleHRGYWN0b3J5LmNyZWF0ZSgpO1xyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlID0gbmV3IFJlc291cmNlKCcnLCBFeFJlc3BvbnNlLnR5cGUuYXJyYXlidWZmZXIpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENocm9tZSA6IE1QMywgV0FWLCBPZ2dcclxuICAgICAgICAgKiBGaXJlZm94IDogV0FWLCBPZ2csXHJcbiAgICAgICAgICogSUUgOiBNUDMsIFdBViBjb21pbmcgc29vblxyXG4gICAgICAgICAqIFNhZmFyaSBNUDMsIFdBViwgT2dnXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZm9yIChjb25zdCBwYXRoIG9mIHBhdGhzKSB7XHJcbiAgICAgICAgICAgIGlmIChjYW5QbGF5RmlsZShwYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5wYXRoKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFueSBvZiB0aGUgYXVkaW8gZmlsZXMgc3BlY2lmaWVkOicsIHBhdGhzLmpvaW4oJywgJykpO1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdBdHRlbXB0aW5nIHRvIHVzZScsIHBhdGhzWzBdKTtcclxuICAgICAgICAgICAgdGhpcy5wYXRoID0gcGF0aHNbMF07IC8vIHNlbGVjdCB0aGUgZmlyc3Qgc3BlY2lmaWVkXHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgY2xpcCBzaG91bGQgbG9vcCB3aGVuIGNvbXBsZXRlXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgIFNldCB0aGUgbG9vcGluZyBmbGFnXHJcbiAgICAgKi9cclxuICAgIHNldCBsb29wKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbG9vcCA9IHZhbHVlO1xyXG4gICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2YgdGhpcy5fdHJhY2tzKSB7XHJcbiAgICAgICAgICAgIHRyYWNrLmxvb3AgPSB0aGlzLl9sb29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnU2V0IGxvb3AgZm9yIGFsbCBpbnN0YW5jZXMgb2Ygc291bmQnLCB0aGlzLnBhdGgsICd0bycsIHRoaXMuX2xvb3ApO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvb3AoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvb3A7XHJcbiAgICB9XHJcbiAgICBzZXQgdm9sdW1lKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdm9sdW1lID0gdmFsdWU7XHJcbiAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiB0aGlzLl90cmFja3MpIHtcclxuICAgICAgICAgICAgdHJhY2sudm9sdW1lID0gdGhpcy5fdm9sdW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVtaXQoJ3ZvbHVtZWNoYW5nZScsIG5ldyBOYXRpdmVTb3VuZEV2ZW50KHRoaXMpKTtcclxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnU2V0IGxvb3AgZm9yIGFsbCBpbnN0YW5jZXMgb2Ygc291bmQnLCB0aGlzLnBhdGgsICd0bycsIHRoaXMuX3ZvbHVtZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgdm9sdW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92b2x1bWU7XHJcbiAgICB9XHJcbiAgICBnZXQgZHVyYXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2R1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYXJyYXkgb2YgQ3VycmVudCBBdWRpb0luc3RhbmNlcyBwbGF5aW5nIG9yIGJlaW5nIHBhdXNlZFxyXG4gICAgICovXHJcbiAgICBnZXQgaW5zdGFuY2VzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja3M7XHJcbiAgICB9XHJcbiAgICBnZXQgcGF0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2UucGF0aDtcclxuICAgIH1cclxuICAgIHNldCBwYXRoKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlLnBhdGggPSB2YWw7XHJcbiAgICB9XHJcbiAgICBpc0xvYWRlZCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmRhdGE7XHJcbiAgICB9XHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIHJldHVybiBTb3VuZF9hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGFycmF5YnVmZmVyID0geWllbGQgdGhpcy5fcmVzb3VyY2UubG9hZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBhdWRpb2J1ZmZlciA9IHlpZWxkIHRoaXMuZGVjb2RlQXVkaW8oYXJyYXlidWZmZXIuc2xpY2UoMCkpO1xyXG4gICAgICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IHR5cGVvZiBhdWRpb2J1ZmZlciA9PT0gJ29iamVjdCcgPyBhdWRpb2J1ZmZlci5kdXJhdGlvbiA6IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwcm9jZXNzZWQnLCBuZXcgTmF0aXZlU291bmRQcm9jZXNzZWRFdmVudCh0aGlzLCBhdWRpb2J1ZmZlcikpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhID0gYXVkaW9idWZmZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBkZWNvZGVBdWRpbyhkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIFNvdW5kX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5fYXVkaW9Db250ZXh0LmRlY29kZUF1ZGlvRGF0YShkYXRhLnNsaWNlKDApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZXJyb3IoJ1VuYWJsZSB0byBkZWNvZGUgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyB0aGlzIGJyb3dzZXIgbWF5IG5vdCBmdWxseSBzdXBwb3J0IHRoaXMgZm9ybWF0LCBvciB0aGUgZmlsZSBtYXkgYmUgY29ycnVwdCwgJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2lmIHRoaXMgaXMgYW4gbXAzIHRyeSByZW1vdmluZyBpZDMgdGFncyBhbmQgYWxidW0gYXJ0IGZyb20gdGhlIGZpbGUuJyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5yZWplY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgd2lyZUVuZ2luZShlbmdpbmUpIHtcclxuICAgICAgICBpZiAoZW5naW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLm9uKCdoaWRkZW4nLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW5naW5lLnBhdXNlQXVkaW9XaGVuSGlkZGVuICYmIHRoaXMuaXNQbGF5aW5nKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5vbigndmlzaWJsZScsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlbmdpbmUucGF1c2VBdWRpb1doZW5IaWRkZW4gJiYgdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2FzUGxheWluZ09uSGlkZGVuID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUub24oJ3N0YXJ0JywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNTdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUub24oJ3N0b3AnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2lzU3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBob3cgbWFueSBpbnN0YW5jZXMgb2YgdGhlIHNvdW5kIGFyZSBjdXJyZW50bHkgcGxheWluZ1xyXG4gICAgICovXHJcbiAgICBpbnN0YW5jZUNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja3MubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgc291bmQgaXMgcGxheWluZyByaWdodCBub3dcclxuICAgICAqL1xyXG4gICAgaXNQbGF5aW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja3Muc29tZSgodCkgPT4gdC5pc1BsYXlpbmcoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFBsYXkgdGhlIHNvdW5kLCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHNvdW5kIGlzIGRvbmUgcGxheWluZ1xyXG4gICAgICogQW4gb3B0aW9uYWwgdm9sdW1lIGFyZ3VtZW50IGNhbiBiZSBwYXNzZWQgaW4gdG8gcGxheSB0aGUgc291bmQuIE1heCB2b2x1bWUgaXMgMS4wXHJcbiAgICAgKi9cclxuICAgIHBsYXkodm9sdW1lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzTG9hZGVkKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignQ2Fubm90IHN0YXJ0IHBsYXlpbmcuIFJlc291cmNlJywgdGhpcy5wYXRoLCAnaXMgbm90IGxvYWRlZCB5ZXQnKTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzU3RvcHBlZCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdDYW5ub3Qgc3RhcnQgcGxheWluZy4gRW5naW5lIGlzIGluIGEgc3RvcHBlZCBzdGF0ZS4nKTtcclxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudm9sdW1lID0gdm9sdW1lIHx8IHRoaXMudm9sdW1lO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVzdW1lUGxheWJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydFBsYXliYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRoZSBzb3VuZCwgYW5kIGRvIG5vdCByZXdpbmRcclxuICAgICAqL1xyXG4gICAgcGF1c2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzUGxheWluZygpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiB0aGlzLl90cmFja3MpIHtcclxuICAgICAgICAgICAgdHJhY2sucGF1c2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuZW1pdCgncGF1c2UnLCBuZXcgTmF0aXZlU291bmRFdmVudCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1BhdXNlZCBhbGwgaW5zdGFuY2VzIG9mIHNvdW5kJywgdGhpcy5wYXRoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RvcCB0aGUgc291bmQgaWYgaXQgaXMgY3VycmVudGx5IHBsYXlpbmcgYW5kIHJld2luZCB0aGUgdHJhY2suIElmIHRoZSBzb3VuZCBpcyBub3QgcGxheWluZywgcmV3aW5kcyB0aGUgdHJhY2suXHJcbiAgICAgKi9cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiB0aGlzLl90cmFja3MpIHtcclxuICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmVtaXQoJ3N0b3AnLCBuZXcgTmF0aXZlU291bmRFdmVudCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90cmFja3MubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnU3RvcHBlZCBhbGwgaW5zdGFuY2VzIG9mIHNvdW5kJywgdGhpcy5wYXRoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IElkIG9mIHByb3ZpZGVkIEF1ZGlvSW5zdGFuY2UgaW4gY3VycmVudCB0cmFja0xpc3RcclxuICAgICAqIEBwYXJhbSB0cmFjayBbW0F1ZGlvXV0gd2hpY2ggSWQgaXMgdG8gYmUgZ2l2ZW5cclxuICAgICAqL1xyXG4gICAgZ2V0VHJhY2tJZCh0cmFjaykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFja3MuaW5kZXhPZih0cmFjayk7XHJcbiAgICB9XHJcbiAgICBfcmVzdW1lUGxheWJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIFNvdW5kX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdW1lZCA9IFtdO1xyXG4gICAgICAgICAgICAgICAgLy8gZW5zdXJlIHdlIHJlc3VtZSAqY3VycmVudCogdHJhY2tzIChpZiBwYXVzZWQpXHJcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHRoaXMuX3RyYWNrcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VtZWQucHVzaCh0cmFjay5wbGF5KCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgncmVzdW1lJywgbmV3IE5hdGl2ZVNvdW5kRXZlbnQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1Jlc3VtaW5nIHBhdXNlZCBpbnN0YW5jZXMgZm9yIHNvdW5kJywgdGhpcy5wYXRoLCB0aGlzLl90cmFja3MpO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzb2x2ZSB3aGVuIHJlc3VtZWQgdHJhY2tzIGFyZSBkb25lXHJcbiAgICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChyZXN1bWVkKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3RhcnRzIHBsYXliYWNrLCByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gcGxheWJhY2sgaXMgY29tcGxldGVcclxuICAgICAqL1xyXG4gICAgX3N0YXJ0UGxheWJhY2soKSB7XHJcbiAgICAgICAgcmV0dXJuIFNvdW5kX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrID0geWllbGQgdGhpcy5fZ2V0VHJhY2tJbnN0YW5jZSh0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICBjb25zdCBjb21wbGV0ZSA9IHlpZWxkIHRyYWNrLnBsYXkoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdwbGF5YmFja3N0YXJ0JywgbmV3IE5hdGl2ZVNvdW5kRXZlbnQodGhpcywgdHJhY2spKTtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdQbGF5aW5nIG5ldyBpbnN0YW5jZSBmb3Igc291bmQnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gd2hlbiBkb25lLCByZW1vdmUgdHJhY2tcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCdwbGF5YmFja2VuZCcsIG5ldyBOYXRpdmVTb3VuZEV2ZW50KHRoaXMsIHRyYWNrKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrcy5zcGxpY2UodGhpcy5nZXRUcmFja0lkKHRyYWNrKSwgMSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb21wbGV0ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9nZXRUcmFja0luc3RhbmNlKGRhdGEpIHtcclxuICAgICAgICBjb25zdCBuZXdUcmFjayA9IG5ldyBXZWJBdWRpb0luc3RhbmNlKGRhdGEpO1xyXG4gICAgICAgIG5ld1RyYWNrLmxvb3AgPSB0aGlzLmxvb3A7XHJcbiAgICAgICAgbmV3VHJhY2sudm9sdW1lID0gdGhpcy52b2x1bWU7XHJcbiAgICAgICAgbmV3VHJhY2suZHVyYXRpb24gPSB0aGlzLmR1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX3RyYWNrcy5wdXNoKG5ld1RyYWNrKTtcclxuICAgICAgICByZXR1cm4gbmV3VHJhY2s7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9SZXNvdXJjZXMvU291bmQvSW5kZXgudHNcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUmVzb3VyY2VzL0dpZi50c1xudmFyIEdpZl9hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBbW1RleHR1cmVdXSBvYmplY3QgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGltYWdlIHJlc291cmNlcy5cclxuICogW1tUZXh0dXJlXV0gaXMgYW4gW1tMb2FkYWJsZV1dIHdoaWNoIG1lYW5zIGl0IGNhbiBiZSBwYXNzZWQgdG8gYSBbW0xvYWRlcl1dXHJcbiAqIHRvIHByZS1sb2FkIGJlZm9yZSBzdGFydGluZyBhIGxldmVsIG9yIGdhbWUuXHJcbiAqL1xyXG5jbGFzcyBHaWYge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcGF0aCAgICAgICBQYXRoIHRvIHRoZSBpbWFnZSByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIGNvbG9yICAgICAgT3B0aW9uYWxseSBzZXQgdGhlIGNvbG9yIHRvIHRyZWF0IGFzIHRyYW5zcGFyZW50IHRoZSBnaWYsIGJ5IGRlZmF1bHQgW1tDb2xvci5NYWdlbnRhXV1cclxuICAgICAqIEBwYXJhbSBidXN0Q2FjaGUgIE9wdGlvbmFsbHkgbG9hZCB0ZXh0dXJlIHdpdGggY2FjaGUgYnVzdGluZ1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBjb2xvciA9IENvbG9yLk1hZ2VudGEsIGJ1c3RDYWNoZSA9IHRydWUpIHtcclxuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuICAgICAgICB0aGlzLmJ1c3RDYWNoZSA9IGJ1c3RDYWNoZTtcclxuICAgICAgICB0aGlzLl9zdHJlYW0gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2dpZiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGV4dHVyZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9hbmltYXRpb24gPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcGFyZW50Q29sb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlID0gbmV3IFJlc291cmNlKHBhdGgsICdhcnJheWJ1ZmZlcicsIGJ1c3RDYWNoZSk7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwYXJlbnRDb2xvciA9IGNvbG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCZWdpbnMgbG9hZGluZyB0aGUgdGV4dHVyZSBhbmQgcmV0dXJucyBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgb24gY29tcGxldGlvblxyXG4gICAgICovXHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIHJldHVybiBHaWZfYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgYXJyYXlidWZmZXIgPSB5aWVsZCB0aGlzLl9yZXNvdXJjZS5sb2FkKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0cmVhbSA9IG5ldyBTdHJlYW0oYXJyYXlidWZmZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9naWYgPSBuZXcgUGFyc2VHaWYodGhpcy5fc3RyZWFtLCB0aGlzLl90cmFuc3BhcmVudENvbG9yKTtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2VzID0gdGhpcy5fZ2lmLmltYWdlcy5tYXAoaSA9PiBuZXcgSW1hZ2VTb3VyY2UoaS5zcmMsIGZhbHNlKSk7XHJcbiAgICAgICAgICAgIC8vIExvYWQgYWxsIHRleHR1cmVzXHJcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKGltYWdlcy5tYXAodCA9PiB0LmxvYWQoKSkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhID0gdGhpcy5fdGV4dHVyZXMgPSBpbWFnZXM7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBpc0xvYWRlZCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmRhdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGZyYW1lIG9mIHRoZSBnaWYgYXMgYSBsZWdhY3kgc3ByaXRlIGJ5IGluZGV4XHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICovXHJcbiAgICB0b0xlZ2FjeVNwcml0ZShpZCA9IDApIHtcclxuICAgICAgICByZXR1cm4gU3ByaXRlLnRvTGVnYWN5U3ByaXRlKHRoaXMudG9TcHJpdGUoaWQpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBnaWYgYXMgYSBsZWdhY3kgc3ByaXRlc2hlZXRcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICB0b0xlZ2FjeVNwcml0ZVNoZWV0KCkge1xyXG4gICAgICAgIHJldHVybiBTcHJpdGVTaGVldC50b0xlZ2FjeVNwcml0ZVNoZWV0KHRoaXMudG9TcHJpdGVTaGVldCgpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBnaWYgYXMgYSBsZWdhY3kgYW5pbWF0aW9uXHJcbiAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICogQHBhcmFtIHNwZWVkXHJcbiAgICAgKi9cclxuICAgIHRvTGVnYWN5QW5pbWF0aW9uKGVuZ2luZSwgc3BlZWQpIHtcclxuICAgICAgICByZXR1cm4gQW5pbWF0aW9uLnRvTGVnYWN5QW5pbWF0aW9uKGVuZ2luZSwgdGhpcy50b0FuaW1hdGlvbihzcGVlZCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gYSBmcmFtZSBvZiB0aGUgZ2lmIGFzIGEgc3ByaXRlIGJ5IGlkXHJcbiAgICAgKiBAcGFyYW0gaWRcclxuICAgICAqL1xyXG4gICAgdG9TcHJpdGUoaWQgPSAwKSB7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlID0gdGhpcy5fdGV4dHVyZXNbaWRdLnRvU3ByaXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHNwcml0ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBnaWYgYXMgYSBzcHJpdGVzaGVldFxyXG4gICAgICovXHJcbiAgICB0b1Nwcml0ZVNoZWV0KCkge1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZXMgPSB0aGlzLl90ZXh0dXJlcy5tYXAoKGltYWdlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBpbWFnZS50b1Nwcml0ZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlU2hlZXQoeyBzcHJpdGVzIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm0gdGhlIEdJRiBpbnRvIGFuIGFuaW1hdGlvbiB3aXRoIGR1cmF0aW9uIHBlciBmcmFtZVxyXG4gICAgICovXHJcbiAgICB0b0FuaW1hdGlvbihkdXJhdGlvblBlckZyYW1lTXMpIHtcclxuICAgICAgICBjb25zdCBzcHJpdGVTaGVldCA9IHRoaXMudG9TcHJpdGVTaGVldCgpO1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHNwcml0ZVNoZWV0LnNwcml0ZXMubGVuZ3RoO1xyXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IEFuaW1hdGlvbi5mcm9tU3ByaXRlU2hlZXQoc3ByaXRlU2hlZXQsIHJhbmdlKDAsIGxlbmd0aCksIGR1cmF0aW9uUGVyRnJhbWVNcyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGlvbjtcclxuICAgIH1cclxuICAgIGdldCByZWFkQ2hlY2tCeXRlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2lmLmNoZWNrQnl0ZXM7XHJcbiAgICB9XHJcbn1cclxuY29uc3QgYml0c1RvTnVtID0gKGJhKSA9PiB7XHJcbiAgICByZXR1cm4gYmEucmVkdWNlKGZ1bmN0aW9uIChzLCBuKSB7XHJcbiAgICAgICAgcmV0dXJuIHMgKiAyICsgbjtcclxuICAgIH0sIDApO1xyXG59O1xyXG5jb25zdCBieXRlVG9CaXRBcnIgPSAoYml0ZSkgPT4ge1xyXG4gICAgY29uc3QgYSA9IFtdO1xyXG4gICAgZm9yIChsZXQgaSA9IDc7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgYS5wdXNoKCEhKGJpdGUgJiAoMSA8PCBpKSkpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGE7XHJcbn07XHJcbmNsYXNzIFN0cmVhbSB7XHJcbiAgICBjb25zdHJ1Y3RvcihkYXRhQXJyYXkpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubGVuID0gMDtcclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gMDtcclxuICAgICAgICB0aGlzLnJlYWRCeXRlID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA+PSB0aGlzLmRhdGEuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdHRlbXB0ZWQgdG8gcmVhZCBwYXN0IGVuZCBvZiBzdHJlYW0uJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLnBvc2l0aW9uKytdO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZWFkQnl0ZXMgPSAobikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaCh0aGlzLnJlYWRCeXRlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBieXRlcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVhZCA9IChuKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzID0gJyc7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5yZWFkQnl0ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcztcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVhZFVuc2lnbmVkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBMaXR0bGUtZW5kaWFuLlxyXG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcy5yZWFkQnl0ZXMoMik7XHJcbiAgICAgICAgICAgIHJldHVybiAoYVsxXSA8PCA4KSArIGFbMF07XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheShkYXRhQXJyYXkpO1xyXG4gICAgICAgIHRoaXMubGVuID0gdGhpcy5kYXRhLmJ5dGVMZW5ndGg7XHJcbiAgICAgICAgaWYgKHRoaXMubGVuID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YSBsb2FkZWQgZnJvbSBmaWxlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNvbnN0IGx6d0RlY29kZSA9IGZ1bmN0aW9uIChtaW5Db2RlU2l6ZSwgZGF0YSkge1xyXG4gICAgLy8gVE9ETzogTm93IHRoYXQgdGhlIEdJRiBwYXJzZXIgaXMgYSBiaXQgZGlmZmVyZW50LCBtYXliZSB0aGlzIHNob3VsZCBnZXQgYW4gYXJyYXkgb2YgYnl0ZXMgaW5zdGVhZCBvZiBhIFN0cmluZz9cclxuICAgIGxldCBwb3MgPSAwOyAvLyBNYXliZSB0aGlzIHN0cmVhbWluZyB0aGluZyBzaG91bGQgYmUgbWVyZ2VkIHdpdGggdGhlIFN0cmVhbT9cclxuICAgIGNvbnN0IHJlYWRDb2RlID0gZnVuY3Rpb24gKHNpemUpIHtcclxuICAgICAgICBsZXQgY29kZSA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGRhdGEuY2hhckNvZGVBdChwb3MgPj4gMykgJiAoMSA8PCAocG9zICYgNykpKSB7XHJcbiAgICAgICAgICAgICAgICBjb2RlIHw9IDEgPDwgaTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwb3MrKztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvZGU7XHJcbiAgICB9O1xyXG4gICAgY29uc3Qgb3V0cHV0ID0gW107XHJcbiAgICBjb25zdCBjbGVhckNvZGUgPSAxIDw8IG1pbkNvZGVTaXplO1xyXG4gICAgY29uc3QgZW9pQ29kZSA9IGNsZWFyQ29kZSArIDE7XHJcbiAgICBsZXQgY29kZVNpemUgPSBtaW5Db2RlU2l6ZSArIDE7XHJcbiAgICBsZXQgZGljdCA9IFtdO1xyXG4gICAgY29uc3QgY2xlYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZGljdCA9IFtdO1xyXG4gICAgICAgIGNvZGVTaXplID0gbWluQ29kZVNpemUgKyAxO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xlYXJDb2RlOyBpKyspIHtcclxuICAgICAgICAgICAgZGljdFtpXSA9IFtpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGljdFtjbGVhckNvZGVdID0gW107XHJcbiAgICAgICAgZGljdFtlb2lDb2RlXSA9IG51bGw7XHJcbiAgICB9O1xyXG4gICAgbGV0IGNvZGU7XHJcbiAgICBsZXQgbGFzdDtcclxuICAgIHdoaWxlICh0cnVlKSB7XHJcbiAgICAgICAgbGFzdCA9IGNvZGU7XHJcbiAgICAgICAgY29kZSA9IHJlYWRDb2RlKGNvZGVTaXplKTtcclxuICAgICAgICBpZiAoY29kZSA9PT0gY2xlYXJDb2RlKSB7XHJcbiAgICAgICAgICAgIGNsZWFyKCk7XHJcbiAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29kZSA9PT0gZW9pQ29kZSkge1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGNvZGUgPCBkaWN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBpZiAobGFzdCAhPT0gY2xlYXJDb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBkaWN0LnB1c2goZGljdFtsYXN0XS5jb25jYXQoZGljdFtjb2RlXVswXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBpZiAoY29kZSAhPT0gZGljdC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMWlcgY29kZS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaWN0LnB1c2goZGljdFtsYXN0XS5jb25jYXQoZGljdFtsYXN0XVswXSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBvdXRwdXQucHVzaC5hcHBseShvdXRwdXQsIGRpY3RbY29kZV0pO1xyXG4gICAgICAgIGlmIChkaWN0Lmxlbmd0aCA9PT0gMSA8PCBjb2RlU2l6ZSAmJiBjb2RlU2l6ZSA8IDEyKSB7XHJcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGF0IHRoZSBsYXN0IGNvZGUgYW5kIGNvZGVTaXplIGlzIDEyLCB0aGUgbmV4dCBjb2RlIHdpbGwgYmUgYSBjbGVhckNvZGUsIGFuZCBpdCdsbCBiZSAxMiBiaXRzIGxvbmcuXHJcbiAgICAgICAgICAgIGNvZGVTaXplKys7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gSSBkb24ndCBrbm93IGlmIHRoaXMgaXMgdGVjaG5pY2FsbHkgYW4gZXJyb3IsIGJ1dCBzb21lIEdJRnMgZG8gaXQuXHJcbiAgICAvL2lmIChNYXRoLmNlaWwocG9zIC8gOCkgIT09IGRhdGEubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0V4dHJhbmVvdXMgTFpXIGJ5dGVzLicpO1xyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufTtcclxuLy8gVGhlIGFjdHVhbCBwYXJzaW5nOyByZXR1cm5zIGFuIG9iamVjdCB3aXRoIHByb3BlcnRpZXMuXHJcbmNsYXNzIFBhcnNlR2lmIHtcclxuICAgIGNvbnN0cnVjdG9yKHN0cmVhbSwgY29sb3IgPSBDb2xvci5NYWdlbnRhKSB7XHJcbiAgICAgICAgdGhpcy5fc3QgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXIgPSB7fTtcclxuICAgICAgICB0aGlzLl90cmFuc3BhcmVudENvbG9yID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuaW1hZ2VzID0gW107XHJcbiAgICAgICAgdGhpcy5nbG9iYWxDb2xvclRhYmxlID0gW107XHJcbiAgICAgICAgdGhpcy5jaGVja0J5dGVzID0gW107XHJcbiAgICAgICAgLy8gTFpXIChHSUYtc3BlY2lmaWMpXHJcbiAgICAgICAgdGhpcy5wYXJzZUNvbG9yVGFibGUgPSAoZW50cmllcykgPT4ge1xyXG4gICAgICAgICAgICAvLyBFYWNoIGVudHJ5IGlzIDMgYnl0ZXMsIGZvciBSR0IuXHJcbiAgICAgICAgICAgIGNvbnN0IGN0ID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cmllczsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZ2IgPSB0aGlzLl9zdC5yZWFkQnl0ZXMoMyk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZ2JhID0gJyMnICtcclxuICAgICAgICAgICAgICAgICAgICByZ2JcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoeCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoZXggPSB4LnRvU3RyaW5nKDE2KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJycpO1xyXG4gICAgICAgICAgICAgICAgY3QucHVzaChyZ2JhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gY3Q7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJlYWRTdWJCbG9ja3MgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBzaXplLCBkYXRhO1xyXG4gICAgICAgICAgICBkYXRhID0gJyc7XHJcbiAgICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgICAgIHNpemUgPSB0aGlzLl9zdC5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgZGF0YSArPSB0aGlzLl9zdC5yZWFkKHNpemUpO1xyXG4gICAgICAgICAgICB9IHdoaWxlIChzaXplICE9PSAwKTtcclxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnBhcnNlSGVhZGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBoZHIgPSB7XHJcbiAgICAgICAgICAgICAgICBzaWc6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB2ZXI6IG51bGwsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogbnVsbCxcclxuICAgICAgICAgICAgICAgIGNvbG9yUmVzOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZ2xvYmFsQ29sb3JUYWJsZVNpemU6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBnY3RGbGFnOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgc29ydGVkOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgZ2xvYmFsQ29sb3JUYWJsZTogW10sXHJcbiAgICAgICAgICAgICAgICBiZ0NvbG9yOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgcGl4ZWxBc3BlY3RSYXRpbzogbnVsbCAvLyBpZiBub3QgMCwgYXNwZWN0UmF0aW8gPSAocGl4ZWxBc3BlY3RSYXRpbyArIDE1KSAvIDY0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGhkci5zaWcgPSB0aGlzLl9zdC5yZWFkKDMpO1xyXG4gICAgICAgICAgICBoZHIudmVyID0gdGhpcy5fc3QucmVhZCgzKTtcclxuICAgICAgICAgICAgaWYgKGhkci5zaWcgIT09ICdHSUYnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIEdJRiBmaWxlLicpOyAvLyBYWFg6IFRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGhhbmRsZWQgbW9yZSBuaWNlbHkuXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaGRyLndpZHRoID0gdGhpcy5fc3QucmVhZFVuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgIGhkci5oZWlnaHQgPSB0aGlzLl9zdC5yZWFkVW5zaWduZWQoKTtcclxuICAgICAgICAgICAgY29uc3QgYml0cyA9IGJ5dGVUb0JpdEFycih0aGlzLl9zdC5yZWFkQnl0ZSgpKTtcclxuICAgICAgICAgICAgaGRyLmdjdEZsYWcgPSBiaXRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGhkci5jb2xvclJlcyA9IGJpdHNUb051bShiaXRzLnNwbGljZSgwLCAzKSk7XHJcbiAgICAgICAgICAgIGhkci5zb3J0ZWQgPSBiaXRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGhkci5nbG9iYWxDb2xvclRhYmxlU2l6ZSA9IGJpdHNUb051bShiaXRzLnNwbGljZSgwLCAzKSk7XHJcbiAgICAgICAgICAgIGhkci5iZ0NvbG9yID0gdGhpcy5fc3QucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgaGRyLnBpeGVsQXNwZWN0UmF0aW8gPSB0aGlzLl9zdC5yZWFkQnl0ZSgpOyAvLyBpZiBub3QgMCwgYXNwZWN0UmF0aW8gPSAocGl4ZWxBc3BlY3RSYXRpbyArIDE1KSAvIDY0XHJcbiAgICAgICAgICAgIGlmIChoZHIuZ2N0RmxhZykge1xyXG4gICAgICAgICAgICAgICAgaGRyLmdsb2JhbENvbG9yVGFibGUgPSB0aGlzLnBhcnNlQ29sb3JUYWJsZSgxIDw8IChoZHIuZ2xvYmFsQ29sb3JUYWJsZVNpemUgKyAxKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdsb2JhbENvbG9yVGFibGUgPSBoZHIuZ2xvYmFsQ29sb3JUYWJsZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlci5oZHIgJiYgdGhpcy5faGFuZGxlci5oZHIoaGRyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5faGFuZGxlci5oZHIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnBhcnNlRXh0ID0gKGJsb2NrKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlR0NFeHQgPSAoYmxvY2spID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX3N0LnJlYWRCeXRlKCkpOyAvLyBBbHdheXMgNFxyXG4gICAgICAgICAgICAgICAgY29uc3QgYml0cyA9IGJ5dGVUb0JpdEFycih0aGlzLl9zdC5yZWFkQnl0ZSgpKTtcclxuICAgICAgICAgICAgICAgIGJsb2NrLnJlc2VydmVkID0gYml0cy5zcGxpY2UoMCwgMyk7IC8vIFJlc2VydmVkOyBzaG91bGQgYmUgMDAwLlxyXG4gICAgICAgICAgICAgICAgYmxvY2suZGlzcG9zYWxNZXRob2QgPSBiaXRzVG9OdW0oYml0cy5zcGxpY2UoMCwgMykpO1xyXG4gICAgICAgICAgICAgICAgYmxvY2sudXNlcklucHV0ID0gYml0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgYmxvY2sudHJhbnNwYXJlbmN5R2l2ZW4gPSBiaXRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBibG9jay5kZWxheVRpbWUgPSB0aGlzLl9zdC5yZWFkVW5zaWduZWQoKTtcclxuICAgICAgICAgICAgICAgIGJsb2NrLnRyYW5zcGFyZW5jeUluZGV4ID0gdGhpcy5fc3QucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgIGJsb2NrLnRlcm1pbmF0b3IgPSB0aGlzLl9zdC5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXIuZ2NlICYmIHRoaXMuX2hhbmRsZXIuZ2NlKGJsb2NrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX2hhbmRsZXIuZ2NlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VDb21FeHQgPSAoYmxvY2spID0+IHtcclxuICAgICAgICAgICAgICAgIGJsb2NrLmNvbW1lbnQgPSB0aGlzLnJlYWRTdWJCbG9ja3MoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyLmNvbSAmJiB0aGlzLl9oYW5kbGVyLmNvbShibG9jaykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9oYW5kbGVyLmNvbSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUFRFeHQgPSAoYmxvY2spID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX3N0LnJlYWRCeXRlKCkpOyAvLyBBbHdheXMgMTJcclxuICAgICAgICAgICAgICAgIGJsb2NrLnB0SGVhZGVyID0gdGhpcy5fc3QucmVhZEJ5dGVzKDEyKTtcclxuICAgICAgICAgICAgICAgIGJsb2NrLnB0RGF0YSA9IHRoaXMucmVhZFN1YkJsb2NrcygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXIucHRlICYmIHRoaXMuX2hhbmRsZXIucHRlKGJsb2NrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX2hhbmRsZXIucHRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VBcHBFeHQgPSAoYmxvY2spID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlTmV0c2NhcGVFeHQgPSAoYmxvY2spID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9zdC5yZWFkQnl0ZSgpKTsgLy8gQWx3YXlzIDNcclxuICAgICAgICAgICAgICAgICAgICBibG9jay51bmtub3duID0gdGhpcy5fc3QucmVhZEJ5dGUoKTsgLy8gUTogQWx3YXlzIDE/IFdoYXQgaXMgdGhpcz9cclxuICAgICAgICAgICAgICAgICAgICBibG9jay5pdGVyYXRpb25zID0gdGhpcy5fc3QucmVhZFVuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sudGVybWluYXRvciA9IHRoaXMuX3N0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXIuYXBwICYmIHRoaXMuX2hhbmRsZXIuYXBwLk5FVFNDQVBFICYmIHRoaXMuX2hhbmRsZXIuYXBwLk5FVFNDQVBFKGJsb2NrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9oYW5kbGVyLmFwcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlVW5rbm93bkFwcEV4dCA9IChibG9jaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmFwcERhdGEgPSB0aGlzLnJlYWRTdWJCbG9ja3MoKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogVGhpcyB3b24ndCB3b3JrIGlmIGEgaGFuZGxlciB3YW50cyB0byBtYXRjaCBvbiBhbnkgaWRlbnRpZmllci5cclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlci5hcHAgJiYgdGhpcy5faGFuZGxlci5hcHBbYmxvY2suaWRlbnRpZmllcl0gJiYgdGhpcy5faGFuZGxlci5hcHBbYmxvY2suaWRlbnRpZmllcl0oYmxvY2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX2hhbmRsZXIuYXBwW2Jsb2NrLmlkZW50aWZpZXJdKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5fc3QucmVhZEJ5dGUoKSk7IC8vIEFsd2F5cyAxMVxyXG4gICAgICAgICAgICAgICAgYmxvY2suaWRlbnRpZmllciA9IHRoaXMuX3N0LnJlYWQoOCk7XHJcbiAgICAgICAgICAgICAgICBibG9jay5hdXRoQ29kZSA9IHRoaXMuX3N0LnJlYWQoMyk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJsb2NrLmlkZW50aWZpZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdORVRTQ0FQRSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlTmV0c2NhcGVFeHQoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZVVua25vd25BcHBFeHQoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VVbmtub3duRXh0ID0gKGJsb2NrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBibG9jay5kYXRhID0gdGhpcy5yZWFkU3ViQmxvY2tzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlci51bmtub3duICYmIHRoaXMuX2hhbmRsZXIudW5rbm93bihibG9jaykpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9oYW5kbGVyLnVua25vd24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBibG9jay5sYWJlbCA9IHRoaXMuX3N0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYmxvY2subGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMHhmOTpcclxuICAgICAgICAgICAgICAgICAgICBibG9jay5leHRUeXBlID0gJ2djZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VHQ0V4dChibG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmU6XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZXh0VHlwZSA9ICdjb20nO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlQ29tRXh0KGJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMHgwMTpcclxuICAgICAgICAgICAgICAgICAgICBibG9jay5leHRUeXBlID0gJ3B0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VQVEV4dChibG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZmY6XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZXh0VHlwZSA9ICdhcHAnO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlQXBwRXh0KGJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZXh0VHlwZSA9ICd1bmtub3duJztcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZVVua25vd25FeHQoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnBhcnNlSW1nID0gKGltZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBkZWludGVybGFjZSA9IChwaXhlbHMsIHdpZHRoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBPZiBjb3Vyc2UgdGhpcyBkZWZlYXRzIHRoZSBwdXJwb3NlIG9mIGludGVybGFjaW5nLiBBbmQgaXQncyAqcHJvYmFibHkqXHJcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGVhc3QgZWZmaWNpZW50IHdheSBpdCdzIGV2ZXIgYmVlbiBpbXBsZW1lbnRlZC4gQnV0IG5ldmVydGhlbGVzcy4uLlxyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3UGl4ZWxzID0gbmV3IEFycmF5KHBpeGVscy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgcm93cyA9IHBpeGVscy5sZW5ndGggLyB3aWR0aDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNwUm93ID0gKHRvUm93LCBmcm9tUm93KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZnJvbVBpeGVscyA9IHBpeGVscy5zbGljZShmcm9tUm93ICogd2lkdGgsIChmcm9tUm93ICsgMSkgKiB3aWR0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3UGl4ZWxzLnNwbGljZS5hcHBseShuZXdQaXhlbHMsIFt0b1JvdyAqIHdpZHRoLCB3aWR0aF0uY29uY2F0KGZyb21QaXhlbHMpKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRzID0gWzAsIDQsIDIsIDFdO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcHMgPSBbOCwgOCwgNCwgMl07XHJcbiAgICAgICAgICAgICAgICBsZXQgZnJvbVJvdyA9IDA7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBwYXNzID0gMDsgcGFzcyA8IDQ7IHBhc3MrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHRvUm93ID0gb2Zmc2V0c1twYXNzXTsgdG9Sb3cgPCByb3dzOyB0b1JvdyArPSBzdGVwc1twYXNzXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjcFJvdyh0b1JvdywgZnJvbVJvdyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21Sb3crKztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3UGl4ZWxzO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBpbWcubGVmdFBvcyA9IHRoaXMuX3N0LnJlYWRVbnNpZ25lZCgpO1xyXG4gICAgICAgICAgICBpbWcudG9wUG9zID0gdGhpcy5fc3QucmVhZFVuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgIGltZy53aWR0aCA9IHRoaXMuX3N0LnJlYWRVbnNpZ25lZCgpO1xyXG4gICAgICAgICAgICBpbWcuaGVpZ2h0ID0gdGhpcy5fc3QucmVhZFVuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJpdHMgPSBieXRlVG9CaXRBcnIodGhpcy5fc3QucmVhZEJ5dGUoKSk7XHJcbiAgICAgICAgICAgIGltZy5sY3RGbGFnID0gYml0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpbWcuaW50ZXJsYWNlZCA9IGJpdHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgaW1nLnNvcnRlZCA9IGJpdHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgaW1nLnJlc2VydmVkID0gYml0cy5zcGxpY2UoMCwgMik7XHJcbiAgICAgICAgICAgIGltZy5sY3RTaXplID0gYml0c1RvTnVtKGJpdHMuc3BsaWNlKDAsIDMpKTtcclxuICAgICAgICAgICAgaWYgKGltZy5sY3RGbGFnKSB7XHJcbiAgICAgICAgICAgICAgICBpbWcubGN0ID0gdGhpcy5wYXJzZUNvbG9yVGFibGUoMSA8PCAoaW1nLmxjdFNpemUgKyAxKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaW1nLmx6d01pbkNvZGVTaXplID0gdGhpcy5fc3QucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgY29uc3QgbHp3RGF0YSA9IHRoaXMucmVhZFN1YkJsb2NrcygpO1xyXG4gICAgICAgICAgICBpbWcucGl4ZWxzID0gbHp3RGVjb2RlKGltZy5sendNaW5Db2RlU2l6ZSwgbHp3RGF0YSk7XHJcbiAgICAgICAgICAgIGlmIChpbWcuaW50ZXJsYWNlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gTW92ZVxyXG4gICAgICAgICAgICAgICAgaW1nLnBpeGVscyA9IGRlaW50ZXJsYWNlKGltZy5waXhlbHMsIGltZy53aWR0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5mcmFtZXMucHVzaChpbWcpO1xyXG4gICAgICAgICAgICB0aGlzLmFycmF5VG9JbWFnZShpbWcpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlci5pbWcgJiYgdGhpcy5faGFuZGxlci5pbWcoaW1nKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5faGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucGFyc2VCbG9jayA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB7XHJcbiAgICAgICAgICAgICAgICBzZW50aW5lbDogdGhpcy5fc3QucmVhZEJ5dGUoKSxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICcnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoYmxvY2suc2VudGluZWwpO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGJsb2NrQ2hhcikge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnISc6XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sudHlwZSA9ICdleHQnO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VFeHQoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnLCc6XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sudHlwZSA9ICdpbWcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyc2VJbWcoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnOyc6XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2sudHlwZSA9ICdlb2YnO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyLmVvZiAmJiB0aGlzLl9oYW5kbGVyLmVvZihibG9jaykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5faGFuZGxlci5lb2YpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJsb2NrOiAweCcgKyBibG9jay5zZW50aW5lbC50b1N0cmluZygxNikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChibG9jay50eXBlICE9PSAnZW9mJykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUJsb2NrKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuYXJyYXlUb0ltYWdlID0gKGZyYW1lKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgYy5pZCA9IGNvdW50LnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgIGMud2lkdGggPSBmcmFtZS53aWR0aDtcclxuICAgICAgICAgICAgYy5oZWlnaHQgPSBmcmFtZS5oZWlnaHQ7XHJcbiAgICAgICAgICAgIGNvdW50Kys7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSBjLmdldENvbnRleHQoJzJkJyk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBpeFNpemUgPSAxO1xyXG4gICAgICAgICAgICBsZXQgeSA9IDA7XHJcbiAgICAgICAgICAgIGxldCB4ID0gMDtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmcmFtZS5waXhlbHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGlmICh4ICUgZnJhbWUud2lkdGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB5Kys7XHJcbiAgICAgICAgICAgICAgICAgICAgeCA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nbG9iYWxDb2xvclRhYmxlW2ZyYW1lLnBpeGVsc1tpXV0gPT09IHRoaXMuX3RyYW5zcGFyZW50Q29sb3IudG9IZXgoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gYHJnYmEoMCwgMCwgMCwgMClgO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmdsb2JhbENvbG9yVGFibGVbZnJhbWUucGl4ZWxzW2ldXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnRleHQuZmlsbFJlY3QoeCwgeSwgcGl4U2l6ZSwgcGl4U2l6ZSk7XHJcbiAgICAgICAgICAgICAgICB4Kys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIGltZy5zcmMgPSBjLnRvRGF0YVVSTCgpO1xyXG4gICAgICAgICAgICB0aGlzLmltYWdlcy5wdXNoKGltZyk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9zdCA9IHN0cmVhbTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVyID0ge307XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwYXJlbnRDb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIHRoaXMucGFyc2VIZWFkZXIoKTtcclxuICAgICAgICB0aGlzLnBhcnNlQmxvY2soKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1Jlc291cmNlcy9JbmRleC50c1xuXHJcblxyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FbnRpdHlDb21wb25lbnRTeXN0ZW0vaW5kZXgudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL1BvbHlnb24udHNcblxyXG5cclxuLyoqXHJcbiAqIEEgcG9seWdvbiBbW0dyYXBoaWNdXSBmb3IgZHJhd2luZyBhcmJpdHJhcnkgcG9seWdvbnMgdG8gdGhlIFtbRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0XV1cclxuICovXHJcbmNsYXNzIFBvbHlnb25fUG9seWdvbiBleHRlbmRzIFJhc3RlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBvcHRpb25zLnBvaW50cztcclxuICAgICAgICB0aGlzLnJhc3Rlcml6ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBvaW50cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9pbnRzO1xyXG4gICAgfVxyXG4gICAgc2V0IHBvaW50cyhwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgY29uc3QgbWluID0gdGhpcy5taW5Qb2ludDtcclxuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5fcG9pbnRzLnJlZHVjZSgobWF4LCBwKSA9PiBNYXRoLm1heChwLngsIG1heCksIDApIC0gbWluLng7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLl9wb2ludHMucmVkdWNlKChtYXgsIHApID0+IE1hdGgubWF4KHAueSwgbWF4KSwgMCkgLSBtaW4ueTtcclxuICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG1pblBvaW50KCkge1xyXG4gICAgICAgIGNvbnN0IG1pblggPSB0aGlzLl9wb2ludHMucmVkdWNlKChtaW4sIHApID0+IE1hdGgubWluKHAueCwgbWluKSwgSW5maW5pdHkpO1xyXG4gICAgICAgIGNvbnN0IG1pblkgPSB0aGlzLl9wb2ludHMucmVkdWNlKChtaW4sIHApID0+IE1hdGgubWluKHAueSwgbWluKSwgSW5maW5pdHkpO1xyXG4gICAgICAgIHJldHVybiB2ZWMobWluWCwgbWluWSk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25fUG9seWdvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBwb2ludHM6IHRoaXMucG9pbnRzLm1hcCgocCkgPT4gcC5jbG9uZSgpKSB9LCB0aGlzLmNsb25lR3JhcGhpY09wdGlvbnMoKSksIHRoaXMuY2xvbmVSYXN0ZXJPcHRpb25zKCkpKTtcclxuICAgIH1cclxuICAgIGV4ZWN1dGUoY3R4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucG9pbnRzICYmIHRoaXMucG9pbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc3VwcGxpZWQgcG9pbnRzIGFuZCBjb25zdHJ1Y3QgYSAncG9seWdvbidcclxuICAgICAgICAgICAgY29uc3QgbWluID0gdGhpcy5taW5Qb2ludC5uZWdhdGUoKTtcclxuICAgICAgICAgICAgY29uc3QgZmlyc3RQb2ludCA9IHRoaXMucG9pbnRzWzBdLmFkZChtaW4pO1xyXG4gICAgICAgICAgICBjdHgubW92ZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICAgICAgdGhpcy5wb2ludHMuZm9yRWFjaCgocG9pbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnQueCArIG1pbi54LCBwb2ludC55ICsgbWluLnkpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuc3Ryb2tlQ29sb3IpIHtcclxuICAgICAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL2luZGV4LnRzXG4vLyBHcmFwaGljc1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyBHcmFwaGljcyBFQ1NcclxuXHJcblxyXG4vLyBSYXN0ZXIgZ3JhcGhpY3NcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vSW5wdXQvSW5kZXgudHNcbi8qKlxyXG4gKiBAbW9kdWxlXHJcbiAqIFByb3ZpZGVzIHN1cHBvcnQgZm9yIG1pY2UsIGtleWJvYXJkcywgYW5kIGNvbnRyb2xsZXJzLlxyXG4gKi9cclxuLyoqXHJcbiAqIEB0eXBlZG9jXHJcbiAqL1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9UcmFpdHMvSW5kZXgudHNcbi8qKlxyXG4gKiBAbW9kdWxlXHJcbiAqL1xyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9JbmRleC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL1NvcnRlZExpc3QudHNcbnZhciBTb3J0ZWRMaXN0X2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEEgc29ydGVkIGxpc3QgaW1wbGVtZW50YXRpb24uIE5PVEU6IHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IHNlbGYtYmFsYW5jaW5nXHJcbiAqIEBkZXByZWNhdGVkIFdJbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wIFVzZSBidWlsdCBpbiBKUyBhcnJheS5zb3J0XHJcbiAqL1xyXG5sZXQgU29ydGVkTGlzdCA9IGNsYXNzIFNvcnRlZExpc3Qge1xyXG4gICAgY29uc3RydWN0b3IoZ2V0Q29tcGFyYWJsZSkge1xyXG4gICAgICAgIHRoaXMuX2dldENvbXBhcmFibGUgPSBnZXRDb21wYXJhYmxlO1xyXG4gICAgfVxyXG4gICAgZmluZChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmQodGhpcy5fcm9vdCwgZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBfZmluZChub2RlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUoZWxlbWVudCkgPT09IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgaWYgKG5vZGUuZ2V0RGF0YSgpLmluZGV4T2YoZWxlbWVudCkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZShlbGVtZW50KSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmQobm9kZS5nZXRMZWZ0KCksIGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmQobm9kZS5nZXRSaWdodCgpLCBlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyByZXR1cm5zIHRoZSBhcnJheSBvZiBlbGVtZW50cyBhdCBhIHNwZWNpZmljIGtleSB2YWx1ZVxyXG4gICAgZ2V0KGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZXQodGhpcy5fcm9vdCwga2V5KTtcclxuICAgIH1cclxuICAgIF9nZXQobm9kZSwga2V5KSB7XHJcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZS5nZXREYXRhKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldChub2RlLmdldExlZnQoKSwga2V5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXQobm9kZS5nZXRSaWdodCgpLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3Jvb3QgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yb290ID0gbmV3IEJpbmFyeVRyZWVOb2RlKHRoaXMuX2dldENvbXBhcmFibGUoZWxlbWVudCksIFtlbGVtZW50XSwgbnVsbCwgbnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydCh0aGlzLl9yb290LCBlbGVtZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaW5zZXJ0KG5vZGUsIGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAobm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlKGVsZW1lbnQpID09PSBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXREYXRhKCkuaW5kZXhPZihlbGVtZW50KSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB0aGUgZWxlbWVudCB3ZSdyZSB0cnlpbmcgdG8gaW5zZXJ0IGFscmVhZHkgZXhpc3RzXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLmdldERhdGEoKS5wdXNoKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUoZWxlbWVudCkgPCBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0TGVmdChuZXcgQmluYXJ5VHJlZU5vZGUodGhpcy5fZ2V0Q29tcGFyYWJsZShlbGVtZW50KSwgW2VsZW1lbnRdLCBudWxsLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KG5vZGUuZ2V0TGVmdCgpLCBlbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0UmlnaHQobmV3IEJpbmFyeVRyZWVOb2RlKHRoaXMuX2dldENvbXBhcmFibGUoZWxlbWVudCksIFtlbGVtZW50XSwgbnVsbCwgbnVsbCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luc2VydChub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJlbW92ZUJ5Q29tcGFyYWJsZShlbGVtZW50KSB7XHJcbiAgICAgICAgdGhpcy5fcm9vdCA9IHRoaXMuX3JlbW92ZSh0aGlzLl9yb290LCBlbGVtZW50KTtcclxuICAgIH1cclxuICAgIF9yZW1vdmUobm9kZSwgZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChub2RlID09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUoZWxlbWVudCkgPT09IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgY29uc3QgZWxlbWVudEluZGV4ID0gbm9kZS5nZXREYXRhKCkuaW5kZXhPZihlbGVtZW50KTtcclxuICAgICAgICAgICAgLy8gaWYgdGhlIG5vZGUgY29udGFpbnMgdGhlIGVsZW1lbnQsIHJlbW92ZSB0aGUgZWxlbWVudFxyXG4gICAgICAgICAgICBpZiAoZWxlbWVudEluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0RGF0YSgpLnNwbGljZShlbGVtZW50SW5kZXgsIDEpO1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgaGF2ZSByZW1vdmVkIHRoZSBsYXN0IGVsZW1lbnQgYXQgdGhpcyBub2RlLCByZW1vdmUgdGhlIG5vZGVcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldERhdGEoKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBpcyBhIGxlYWZcclxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCAmJiBub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRSaWdodCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5nZXRMZWZ0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIG5vZGUgaGFzIDIgY2hpbGRyZW5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZW1wID0gdGhpcy5fZmluZE1pbk5vZGUobm9kZS5nZXRSaWdodCgpKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEtleSh0ZW1wLmdldEtleSgpKTtcclxuICAgICAgICAgICAgICAgICAgICBub2RlLnNldERhdGEodGVtcC5nZXREYXRhKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0UmlnaHQodGhpcy5fY2xlYW51cChub2RlLmdldFJpZ2h0KCksIHRlbXApKTsgLy9cImNsZWFudXAgbm9kZXNcIiAobW92ZSB0aGVtIHVwIHJlY3Vyc2l2ZWx5KVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBwcmV2ZW50cyB0aGUgbm9kZSBmcm9tIGJlaW5nIHJlbW92ZWQgc2luY2UgaXQgc3RpbGwgY29udGFpbnMgZWxlbWVudHNcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlKGVsZW1lbnQpIDwgbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICBub2RlLnNldExlZnQodGhpcy5fcmVtb3ZlKG5vZGUuZ2V0TGVmdCgpLCBlbGVtZW50KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbm9kZS5zZXRSaWdodCh0aGlzLl9yZW1vdmUobm9kZS5nZXRSaWdodCgpLCBlbGVtZW50KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8vIGNhbGxlZCBvbmNlIHdlIGhhdmUgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQgdGhlIGVsZW1lbnQgd2Ugd2FudGVkLCByZWN1cnNpdmVseSBjb3JyZWN0cyB0aGUgcGFydCBvZiB0aGUgdHJlZSBiZWxvdyB0aGUgcmVtb3ZlZCBub2RlXHJcbiAgICBfY2xlYW51cChub2RlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3QgY29tcGFyYWJsZSA9IGVsZW1lbnQuZ2V0S2V5KCk7XHJcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29tcGFyYWJsZSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBpcyBhIGxlYWZcclxuICAgICAgICAgICAgaWYgKG5vZGUuZ2V0TGVmdCgpID09IG51bGwgJiYgbm9kZS5nZXRSaWdodCgpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuZ2V0TGVmdCgpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldFJpZ2h0KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5nZXRSaWdodCgpID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldExlZnQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBpZiBub2RlIGhhcyAyIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIGNvbnN0IHRlbXAgPSB0aGlzLl9maW5kTWluTm9kZShub2RlLmdldFJpZ2h0KCkpO1xyXG4gICAgICAgICAgICBub2RlLnNldEtleSh0ZW1wLmdldEtleSgpKTtcclxuICAgICAgICAgICAgbm9kZS5zZXREYXRhKHRlbXAuZ2V0RGF0YSgpKTtcclxuICAgICAgICAgICAgbm9kZS5zZXRSaWdodCh0aGlzLl9jbGVhbnVwKG5vZGUuZ2V0UmlnaHQoKSwgdGVtcCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5nZXRLZXkoKSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgbm9kZS5zZXRMZWZ0KHRoaXMuX2NsZWFudXAobm9kZS5nZXRMZWZ0KCksIGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLnNldFJpZ2h0KHRoaXMuX2NsZWFudXAobm9kZS5nZXRSaWdodCgpLCBlbGVtZW50KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9maW5kTWluTm9kZShub2RlKSB7XHJcbiAgICAgICAgbGV0IGN1cnJlbnQgPSBub2RlO1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50LmdldExlZnQoKSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LmdldExlZnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XHJcbiAgICB9XHJcbiAgICBsaXN0KCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICB0aGlzLl9saXN0KHRoaXMuX3Jvb3QsIHJlc3VsdHMpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgX2xpc3QodHJlZU5vZGUsIHJlc3VsdHMpIHtcclxuICAgICAgICBpZiAodHJlZU5vZGUgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0KHRyZWVOb2RlLmdldExlZnQoKSwgcmVzdWx0cyk7XHJcbiAgICAgICAgICAgIHRyZWVOb2RlLmdldERhdGEoKS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9saXN0KHRyZWVOb2RlLmdldFJpZ2h0KCksIHJlc3VsdHMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuU29ydGVkTGlzdCA9IFNvcnRlZExpc3RfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnV2lsbCBiZSByZW1vdmVkIGluIGV4Y2FsaWJ1ciB2MC4yNi4wJywgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIGJ1aWx0IGluIEpTIGFycmF5LnNvcnQnIH0pXHJcbl0sIFNvcnRlZExpc3QpO1xyXG5cclxuLyoqXHJcbiAqIEEgdHJlZSBub2RlIHBhcnQgb2YgW1tTb3J0ZWRMaXN0XV1cclxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmxldCBCaW5hcnlUcmVlTm9kZSA9IGNsYXNzIEJpbmFyeVRyZWVOb2RlIHtcclxuICAgIGNvbnN0cnVjdG9yKGtleSwgZGF0YSwgbGVmdCwgcmlnaHQpIHtcclxuICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICAgICAgdGhpcy5fZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy5fbGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcclxuICAgIH1cclxuICAgIGdldEtleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5O1xyXG4gICAgfVxyXG4gICAgc2V0S2V5KGtleSkge1xyXG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcclxuICAgIH1cclxuICAgIGdldERhdGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGE7XHJcbiAgICB9XHJcbiAgICBzZXREYXRhKGRhdGEpIHtcclxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcclxuICAgIH1cclxuICAgIGdldExlZnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlZnQ7XHJcbiAgICB9XHJcbiAgICBzZXRMZWZ0KGxlZnQpIHtcclxuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcclxuICAgIH1cclxuICAgIGdldFJpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yaWdodDtcclxuICAgIH1cclxuICAgIHNldFJpZ2h0KHJpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5fcmlnaHQgPSByaWdodDtcclxuICAgIH1cclxufTtcclxuQmluYXJ5VHJlZU5vZGUgPSBTb3J0ZWRMaXN0X2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHsgbWVzc2FnZTogJ1dpbGwgYmUgcmVtb3ZlZCBpbiBleGNhbGlidXIgdjAuMjYuMCcgfSlcclxuXSwgQmluYXJ5VHJlZU5vZGUpO1xyXG5cclxuLyoqXHJcbiAqIE1vY2sgZWxlbWVudCBmb3IgdGVzdGluZ1xyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmNsYXNzIE1vY2tlZEVsZW1lbnQge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5KSB7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0gMDtcclxuICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICB9XHJcbiAgICBnZXRUaGVLZXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleTtcclxuICAgIH1cclxuICAgIHNldEtleShrZXkpIHtcclxuICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Qcm9taXNlcy50c1xuLy8gUHJvbWlzZXMvQSsgU3BlYyBodHRwOi8vcHJvbWlzZXMtYXBsdXMuZ2l0aHViLmlvL3Byb21pc2VzLXNwZWMvXHJcbnZhciBQcm9taXNlc19kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIFByb21pc2VfMTtcclxuXHJcbi8qKlxyXG4gKiBWYWxpZCBzdGF0ZXMgZm9yIGEgcHJvbWlzZSB0byBiZSBpblxyXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxudmFyIFByb21pc2VTdGF0ZTtcclxuKGZ1bmN0aW9uIChQcm9taXNlU3RhdGUpIHtcclxuICAgIFByb21pc2VTdGF0ZVtQcm9taXNlU3RhdGVbXCJSZXNvbHZlZFwiXSA9IDBdID0gXCJSZXNvbHZlZFwiO1xyXG4gICAgUHJvbWlzZVN0YXRlW1Byb21pc2VTdGF0ZVtcIlJlamVjdGVkXCJdID0gMV0gPSBcIlJlamVjdGVkXCI7XHJcbiAgICBQcm9taXNlU3RhdGVbUHJvbWlzZVN0YXRlW1wiUGVuZGluZ1wiXSA9IDJdID0gXCJQZW5kaW5nXCI7XHJcbn0pKFByb21pc2VTdGF0ZSB8fCAoUHJvbWlzZVN0YXRlID0ge30pKTtcclxuLyoqXHJcbiAqIFByb21pc2VzIGFyZSB1c2VkIHRvIGRvIGFzeW5jaHJvbm91cyB3b3JrIGFuZCB0aGV5IGFyZSB1c2VmdWwgZm9yXHJcbiAqIGNyZWF0aW5nIGEgY2hhaW4gb2YgYWN0aW9ucy4gSW4gRXhjYWxpYnVyIHRoZXkgYXJlIHVzZWQgZm9yIGxvYWRpbmcsXHJcbiAqIHNvdW5kcywgYW5pbWF0aW9uLCBhY3Rpb25zLCBhbmQgbW9yZS5cclxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmxldCBQcm9taXNlc19Qcm9taXNlID0gUHJvbWlzZV8xID0gY2xhc3MgUHJvbWlzZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IFByb21pc2VTdGF0ZS5QZW5kaW5nO1xyXG4gICAgICAgIHRoaXMuX3N1Y2Nlc3NDYWxsYmFja3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayA9ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbmQgcmVzb2x2ZSBhIFByb21pc2Ugd2l0aCBhbiBvcHRpb25hbCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHZhbHVlICBBbiBvcHRpb25hbCB2YWx1ZSB0byB3cmFwIGluIGEgcmVzb2x2ZWQgcHJvbWlzZVxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGJyb3dzZXIgbmF0aXZlIHByb21pc2VzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZXNvbHZlKHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlXzEoKS5yZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuZCByZWplY3QgYSBQcm9taXNlIHdpdGggYW4gb3B0aW9uYWwgdmFsdWVcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgQW4gb3B0aW9uYWwgdmFsdWUgdG8gd3JhcCBpbiBhIHJlamVjdGVkIHByb21pc2VcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBicm93c2VyIG5hdGl2ZSBwcm9taXNlc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgcmVqZWN0KHZhbHVlKSB7XHJcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlXzEoKS5yZWplY3QodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGpvaW4oKSB7XHJcbiAgICAgICAgbGV0IHByb21pc2VzID0gW107XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwICYmICFBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHByb21pc2VzW19pIC0gMF0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEgJiYgQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMF0pKSB7XHJcbiAgICAgICAgICAgIHByb21pc2VzID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBqb2luZWRQcm9taXNlID0gbmV3IFByb21pc2VfMSgpO1xyXG4gICAgICAgIGlmICghcHJvbWlzZXMgfHwgIXByb21pc2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gam9pbmVkUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHRvdGFsID0gcHJvbWlzZXMubGVuZ3RoO1xyXG4gICAgICAgIGxldCBzdWNjZXNzZXMgPSAwO1xyXG4gICAgICAgIGxldCByZWplY3RzID0gMDtcclxuICAgICAgICBjb25zdCBlcnJvcnMgPSBbXTtcclxuICAgICAgICBwcm9taXNlcy5mb3JFYWNoKChwKSA9PiB7XHJcbiAgICAgICAgICAgIHAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBzdWNjZXNzZXMgKz0gMTtcclxuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgPT09IHRvdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzdWNjZXNzZXMgKyByZWplY3RzICsgZXJyb3JzLmxlbmd0aCA9PT0gdG90YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlamVjdChlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZWplY3RzICs9IDE7XHJcbiAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzc2VzICsgcmVqZWN0cyArIGVycm9ycy5sZW5ndGggPT09IHRvdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZWplY3QoZXJyb3JzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSkuZXJyb3IoKGUpID0+IHtcclxuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGVycm9ycy5sZW5ndGggKyBzdWNjZXNzZXMgKyByZWplY3RzID09PSB0b3RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVqZWN0KGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBqb2luZWRQcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGFpbiBzdWNjZXNzIGFuZCByZWplY3QgY2FsbGJhY2tzIGFmdGVyIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkXHJcbiAgICAgKiBAcGFyYW0gc3VjY2Vzc0NhbGxiYWNrICBDYWxsIG9uIHJlc29sdXRpb24gb2YgcHJvbWlzZVxyXG4gICAgICogQHBhcmFtIHJlamVjdENhbGxiYWNrICAgQ2FsbCBvbiByZWplY3Rpb24gb2YgcHJvbWlzZVxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGJyb3dzZXIgbmF0aXZlIHByb21pc2VzXHJcbiAgICAgKi9cclxuICAgIHRoZW4oc3VjY2Vzc0NhbGxiYWNrLCByZWplY3RDYWxsYmFjaykge1xyXG4gICAgICAgIGlmIChzdWNjZXNzQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy5fc3VjY2Vzc0NhbGxiYWNrcy5wdXNoKHN1Y2Nlc3NDYWxsYmFjayk7XHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBwcm9taXNlIGlzIGFscmVhZHkgcmVzb2x2ZWQgY2FsbCBpbW1lZGlhdGVseVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSgpID09PSBQcm9taXNlU3RhdGUuUmVzb2x2ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcihlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVqZWN0Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVqZWN0Q2FsbGJhY2sgPSByZWplY3RDYWxsYmFjaztcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHByb21pc2UgaXMgYWxyZWFkeSByZWplY3RlZCBjYWxsIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlKCkgPT09IFByb21pc2VTdGF0ZS5SZWplY3RlZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZWplY3RDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBlcnJvciBjYWxsYmFjayB0byB0aGUgcHJvbWlzZVxyXG4gICAgICogQHBhcmFtIGVycm9yQ2FsbGJhY2sgIENhbGwgaWYgdGhlcmUgd2FzIGFuIGVycm9yIGluIGEgY2FsbGJhY2tcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBicm93c2VyIG5hdGl2ZSBwcm9taXNlc1xyXG4gICAgICovXHJcbiAgICBlcnJvcihlcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKGVycm9yQ2FsbGJhY2spIHtcclxuICAgICAgICAgICAgdGhpcy5fZXJyb3JDYWxsYmFjayA9IGVycm9yQ2FsbGJhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNvbHZlIHRoZSBwcm9taXNlIGFuZCBwYXNzIGFuIG9wdGlvbiB2YWx1ZSB0byB0aGUgc3VjY2VzcyBjYWxsYmFja3NcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgVmFsdWUgdG8gcGFzcyB0byB0aGUgc3VjY2VzcyBjYWxsYmFja3NcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBicm93c2VyIG5hdGl2ZSBwcm9taXNlc1xyXG4gICAgICovXHJcbiAgICByZXNvbHZlKHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBQcm9taXNlU3RhdGUuUGVuZGluZykge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBQcm9taXNlU3RhdGUuUmVzb2x2ZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdWNjZXNzQ2FsbGJhY2tzLmZvckVhY2goKGNiKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2IuY2FsbCh0aGlzLCB0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHRoYXQgaXMgbm90IGluIGEgcGVuZGluZyBzdGF0ZSEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlamVjdCB0aGUgcHJvbWlzZSBhbmQgcGFzcyBhbiBvcHRpb24gdmFsdWUgdG8gdGhlIHJlamVjdCBjYWxsYmFja3NcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgVmFsdWUgdG8gcGFzcyB0byB0aGUgcmVqZWN0IGNhbGxiYWNrc1xyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGJyb3dzZXIgbmF0aXZlIHByb21pc2VzXHJcbiAgICAgKi9cclxuICAgIHJlamVjdCh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gUHJvbWlzZVN0YXRlLlBlbmRpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gUHJvbWlzZVN0YXRlLlJlamVjdGVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVqZWN0Q2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZWplY3QgYSBwcm9taXNlIHRoYXQgaXMgbm90IGluIGEgcGVuZGluZyBzdGF0ZSEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc3BlY3QgdGhlIGN1cnJlbnQgc3RhdGUgb2YgYSBwcm9taXNlXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYnJvd3NlciBuYXRpdmUgcHJvbWlzZXNcclxuICAgICAqL1xyXG4gICAgc3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xyXG4gICAgfVxyXG4gICAgX2hhbmRsZUVycm9yKGUpIHtcclxuICAgICAgICBpZiAodGhpcy5fZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJvckNhbGxiYWNrLmNhbGwodGhpcywgZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyByZXRocm93IGVycm9yXHJcbiAgICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5Qcm9taXNlc19Qcm9taXNlID0gUHJvbWlzZV8xID0gUHJvbWlzZXNfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdleC5Qcm9taXNlcyBhcmUgYmVpbmcgcmVwbGFjZWQgYnkgbmF0aXZlIGJyb3dzZXIgcHJvbWlzZXMgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIGJyb3dzZXIgbmF0aXZlIHByb21pc2VzJ1xyXG4gICAgfSlcclxuXSwgUHJvbWlzZXNfUHJvbWlzZSk7XHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2luZGV4LnRzXG4vKipcclxuICogVGhlIGN1cnJlbnQgRXhjYWxpYnVyIHZlcnNpb24gc3RyaW5nXHJcbiAqIEBkZXNjcmlwdGlvbiBgcHJvY2Vzcy5lbnYuX19FWF9WRVJTSU9OYCBnZXRzIHJlcGxhY2VkIGJ5IFdlYnBhY2sgb24gYnVpbGRcclxuICovXHJcbmNvbnN0IEVYX1ZFUlNJT04gPSBcIjAuMjUuMVwiO1xyXG5cclxucG9seWZpbGwoKTtcclxuLy8gVGhpcyBmaWxlIGlzIHVzZWQgYXMgdGhlIGJ1bmRsZSBlbnRyeSBwb2ludCBhbmQgZXhwb3J0cyBldmVyeXRoaW5nXHJcbi8vIHRoYXQgd2lsbCBiZSBleHBvc2VkIGFzIHRoZSBgZXhgIGdsb2JhbCB2YXJpYWJsZS5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vIGV4LkxlZ2FjeURyYXdpbmcgbmFtZXNwYWNlXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gZXguRXZlbnRzIG5hbWVzcGFjZVxyXG5cclxuXHJcbi8vIGV4LklucHV0IG5hbWVzcGFjZVxyXG5cclxuXHJcbi8vIGV4LlRyYWl0cyBuYW1lc3BhY2VcclxuXHJcblxyXG4vLyBleC5VdGlsIG5hbWVzcGFjZXNcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gZXguRGVwcmVjYXRlZFxyXG5cclxuLy8gaW1wb3J0ICogYXMgZGVwcmVjYXRlZCBmcm9tICcuL0RlcHJlY2F0ZWQnO1xyXG4vLyBleHBvcnQgeyBkZXByZWNhdGVkIGFzIERlcHJlY2F0ZWQgfTtcclxuLy8gZXhwb3J0ICogZnJvbSAnLi9EZXByZWNhdGVkJztcclxuXG59KSgpO1xuXG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0FjdGlvbkNvbnRleHQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmZXbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWN0aW9uUXVldWUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLklhODtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWN0aW9uc0NvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18uaExJO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BY3Rpb25zU3lzdGVtID0gX193ZWJwYWNrX2V4cG9ydHNfXy55eXY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0FjdGl2YXRlRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnRYNTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWN0b3IgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnZ0WDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWRkZWRDb21wb25lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnI3SztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWRkZWRFbnRpdHkgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmxDaDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5pbWF0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5md0Y7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0FuaW1hdGlvbkRpcmVjdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uc2NlO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BbmltYXRpb25TdHJhdGVneSA9IF9fd2VicGFja19leHBvcnRzX18uX2M3O1xudmFyIF9fd2VicGFja19leHBvcnRzX19BcmNhZGVTb2x2ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLktVcztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQXVkaW9Db250ZXh0RmFjdG9yeSA9IF9fd2VicGFja19leHBvcnRzX18uQWpwO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BeGlzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SRGg7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Jhc2VBbGlnbiA9IF9fd2VicGFja19leHBvcnRzX18uX0g5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19CaW5hcnlUcmVlTm9kZSA9IF9fd2VicGFja19leHBvcnRzX18uVWxmO1xudmFyIF9fd2VicGFja19leHBvcnRzX19CbGluayA9IF9fd2VicGFja19leHBvcnRzX18ubXhzO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Cb2R5Q29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5PbUQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0JvdW5kaW5nQm94ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5rQmY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Jyb2FkcGhhc2VTdHJhdGVneSA9IF9fd2VicGFja19leHBvcnRzX18uQzRGO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Ccm93c2VyQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5OUXQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Jyb3dzZXJFdmVudHMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkpqTjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ2FtZXJhID0gX193ZWJwYWNrX2V4cG9ydHNfXy5WMXM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NhbnZhcyA9IF9fd2VicGFja19leHBvcnRzX18uWHo3O1xudmFyIF9fd2VicGFja19leHBvcnRzX19DZWxsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5iTGQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NpcmNsZSA9IF9fd2VicGFja19leHBvcnRzX18uQ2RjO1xudmFyIF9fd2VicGFja19leHBvcnRzX19DaXJjbGVDb2xsaWRlciA9IF9fd2VicGFja19leHBvcnRzX18uRktuO1xudmFyIF9fd2VicGFja19leHBvcnRzX19DbGFzcyA9IF9fd2VicGFja19leHBvcnRzX18ud1RXO1xudmFyIF9fd2VicGFja19leHBvcnRzX19DbG9zZXN0TGluZSA9IF9fd2VicGFja19leHBvcnRzX18uYWIyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19DbG9zZXN0TGluZUp1bXBUYWJsZSA9IF9fd2VicGFja19leHBvcnRzX18uR2ZaO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaWRlciA9IF9fd2VicGFja19leHBvcnRzX18uWU1TO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaWRlckNvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18ub3l2O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25Db250YWN0ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5hVWI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvbkVuZEV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5TZEQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvbkdyb3VwID0gX193ZWJwYWNrX2V4cG9ydHNfXy5KVXY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvbkdyb3VwTWFuYWdlciA9IF9fd2VicGFja19leHBvcnRzX18uakVqO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25KdW1wVGFibGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlRGcTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uUG9zdFNvbHZlRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkhEVTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uUHJlU29sdmVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uUl95O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnlkTjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uU29sdmVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5fTjI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblN0YXJ0RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnQ1MDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uU3lzdGVtID0gX193ZWJwYWNrX2V4cG9ydHNfXy5zJCQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblR5cGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnYyRztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3IgPSBfX3dlYnBhY2tfZXhwb3J0c19fLklsaztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3JCbGluZENvcnJlY3RvciA9IF9fd2VicGFja19leHBvcnRzX18uSF85O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xvckJsaW5kRmxhZ3MgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnM5aTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3JCbGluZG5lc3MgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmtzbDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy53QTI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbXBvc2l0ZUNvbGxpZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SX3A7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbmZpZ3VyYWJsZSA9IF9fd2VicGFja19leHBvcnRzX18uSVEkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db25zb2xlQXBwZW5kZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkk1RjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29udGFjdENvbnN0cmFpbnRQb2ludCA9IF9fd2VicGFja19leHBvcnRzX18uWDgkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db250YWN0RW5kRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkZSNjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29udGFjdFN0YXJ0RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlU4bztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29vcmRQbGFuZSA9IF9fd2VicGFja19leHBvcnRzX18ua2JHO1xudmFyIF9fd2VicGFja19leHBvcnRzX19DdWxsaW5nQm94ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5vZUo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RlYWN0aXZhdGVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uaVNfO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EZWJ1ZyA9IF9fd2VicGFja19leHBvcnRzX18uY0dHO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EZWJ1Z1N5c3RlbSA9IF9fd2VicGFja19leHBvcnRzX18uc2tiO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EZWJ1Z1RleHQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlNMVTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGVncmVlT2ZGcmVlZG9tID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SZEo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RldGVjdG9yID0gX193ZWJwYWNrX2V4cG9ydHNfXy5nVTc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RpZSA9IF9fd2VicGFja19leHBvcnRzX18uTFNrO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EaXJlY3Rpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLk5tcDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGlzcGxheU1vZGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmQxWTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRHluYW1pY1RyZWUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnhyTDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRHluYW1pY1RyZWVDb2xsaXNpb25Qcm9jZXNzb3IgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnNSVztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRVhfVkVSU0lPTiA9IF9fd2VicGFja19leHBvcnRzX18uY21WO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FYXNlVG8gPSBfX3dlYnBhY2tfZXhwb3J0c19fLk4wUTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRWFzaW5nRnVuY3Rpb25zID0gX193ZWJwYWNrX2V4cG9ydHNfXy5xOGI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0VkZ2VDb2xsaWRlciA9IF9fd2VicGFja19leHBvcnRzX18ueW5CO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FbGFzdGljVG9BY3RvclN0cmF0ZWd5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5qVDk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0VtaXR0ZXJUeXBlID0gX193ZWJwYWNrX2V4cG9ydHNfXy53QXo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0VuZ2luZSA9IF9fd2VicGFja19leHBvcnRzX18uRDRWO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FbnRlclRyaWdnZXJFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uTjZIO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FbnRlclZpZXdQb3J0RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlcxQTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRW50aXR5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5KSFc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0VudGl0eU1hbmFnZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnYySztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRXZlbnREaXNwYXRjaGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5wQmY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0V2ZW50VHlwZXMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkdNbDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRXZlbnRzID0gX193ZWJwYWNrX2V4cG9ydHNfXy56VzI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0V4UmVzcG9uc2UgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkIwSztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk52NztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0wgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkNfcDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRXhpdFRyaWdnZXJFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uTVVBO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FeGl0Vmlld1BvcnRFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18ueHFVO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FeHBlcmltZW50cyA9IF9fd2VicGFja19leHBvcnRzX18ucGVHO1xudmFyIF9fd2VicGFja19leHBvcnRzX19GYWRlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5wVHA7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ZsYWdzID0gX193ZWJwYWNrX2V4cG9ydHNfXy52VUs7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ZvbGxvdyA9IF9fd2VicGFja19leHBvcnRzX18uajlsO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Gb250ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5aeHc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ZvbnRTdHlsZSA9IF9fd2VicGFja19leHBvcnRzX18uSGR4O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Gb250VW5pdCA9IF9fd2VicGFja19leHBvcnRzX18uWiRkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19GcmFtZVN0YXRzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5vJDc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dhbWVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uWm0kO1xudmFyIF9fd2VicGFja19leHBvcnRzX19HYW1lU3RhcnRFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uJFFIO1xudmFyIF9fd2VicGFja19leHBvcnRzX19HYW1lU3RvcEV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5pNzg7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dhbWVwYWRBeGlzRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmg2dTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZXBhZEJ1dHRvbkV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5odHM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dhbWVwYWRDb25uZWN0RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmo4ODtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZXBhZERpc2Nvbm5lY3RFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uVk1FO1xudmFyIF9fd2VicGFja19leHBvcnRzX19HaWYgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm50O1xudmFyIF9fd2VicGFja19leHBvcnRzX19HbG9iYWxDb29yZGluYXRlcyA9IF9fd2VicGFja19leHBvcnRzX18uVWtyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljID0gX193ZWJwYWNrX2V4cG9ydHNfXy56c3U7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dyYXBoaWNzQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5vQTY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dyYXBoaWNzR3JvdXAgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlRWaDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpY3NMYXllciA9IF9fd2VicGFja19leHBvcnRzX18uVHdaO1xudmFyIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc0xheWVycyA9IF9fd2VicGFja19leHBvcnRzX18uR1RUO1xudmFyIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc1N5c3RlbSA9IF9fd2VicGFja19leHBvcnRzX18ueHhqO1xudmFyIF9fd2VicGFja19leHBvcnRzX19IaWRkZW5FdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uWGRLO1xudmFyIF9fd2VicGFja19leHBvcnRzX19JbWFnZVNvdXJjZSA9IF9fd2VicGFja19leHBvcnRzX18uY1hvO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Jbml0aWFsaXplRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkRtNTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fSW5wdXQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLklJQjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fSW50ZWdyYXRvciA9IF9fd2VicGFja19leHBvcnRzX18uekkwO1xudmFyIF9fd2VicGFja19leHBvcnRzX19LaWxsRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlNLWjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTGFiZWwgPSBfX3dlYnBhY2tfZXhwb3J0c19fLl9fSjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTGVnYWN5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5EdnI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0xlZ2FjeURyYXdpbmcgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlRmOTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTGltaXRDYW1lcmFCb3VuZHNTdHJhdGVneSA9IF9fd2VicGFja19leHBvcnRzX18uUkkkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19MaW5lID0gX193ZWJwYWNrX2V4cG9ydHNfXy54MTI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0xvYWRlciA9IF9fd2VicGFja19leHBvcnRzX18uYU53O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Mb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneSA9IF9fd2VicGFja19leHBvcnRzX18ueHduO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Mb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5kTks7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0xvZ0xldmVsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5pbmk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0xvZ2dlciA9IF9fd2VicGFja19leHBvcnRzX18uWWRIO1xudmFyIF9fd2VicGFja19leHBvcnRzX19NYXRyaXggPSBfX3dlYnBhY2tfZXhwb3J0c19fLnkzRztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTWF0cml4TG9jYXRpb25zID0gX193ZWJwYWNrX2V4cG9ydHNfXy5sNTc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX01lZGlhRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnhuMDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTWVldCA9IF9fd2VicGFja19leHBvcnRzX18udDJWO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Nb2NrZWRFbGVtZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5aeVM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX01vdGlvbkNvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18udXhCO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Nb3Rpb25TeXN0ZW0gPSBfX3dlYnBhY2tfZXhwb3J0c19fLmNwZDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTW92ZUJ5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5maXk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX01vdmVUbyA9IF9fd2VicGFja19leHBvcnRzX18uJFhaO1xudmFyIF9fd2VicGFja19leHBvcnRzX19OYXRpdmVTb3VuZEV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy51cUs7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX05hdGl2ZVNvdW5kUHJvY2Vzc2VkRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlNURTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fT2JzZXJ2YWJsZSA9IF9fd2VicGFja19leHBvcnRzX18ueSR6O1xudmFyIF9fd2VicGFja19leHBvcnRzX19QYWlyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5zT3E7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BhcnNlR2lmID0gX193ZWJwYWNrX2V4cG9ydHNfXy5TcXM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BhcnRpY2xlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ocFo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BhcnRpY2xlRW1pdHRlciA9IF9fd2VicGFja19leHBvcnRzX18uVm9sO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QaHlzaWNzID0gX193ZWJwYWNrX2V4cG9ydHNfXy53SVo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BoeXNpY3NTdGF0cyA9IF9fd2VicGFja19leHBvcnRzX18uY0JpO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qb2x5Z29uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5tZ3E7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BvbHlnb25Db2xsaWRlciA9IF9fd2VicGFja19leHBvcnRzX18uWVZBO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qb29sID0gX193ZWJwYWNrX2V4cG9ydHNfXy5LZ3A7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Bvc3RDb2xsaXNpb25FdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uSEgkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qb3N0RGVidWdEcmF3RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk1fZDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUG9zdERyYXdFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18ucmdoO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qb3N0RnJhbWVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uUmE2O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qb3N0S2lsbEV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5LaFI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Bvc3RVcGRhdGVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uQlM1O1xudmFyIF9fd2VicGFja19leHBvcnRzX19QcmVDb2xsaXNpb25FdmVudCA9IF9fd2VicGFja19leHBvcnRzX18ueGh6O1xudmFyIF9fd2VicGFja19leHBvcnRzX19QcmVEZWJ1Z0RyYXdFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18ueE9xO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QcmVEcmF3RXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmE5ajtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUHJlRnJhbWVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uYkhrO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QcmVLaWxsRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkNnSztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUHJlVXBkYXRlRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmN1WTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUHJvamVjdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18ua3ZFO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qcm9taXNlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5KRGI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Byb21pc2VTdGF0ZSA9IF9fd2VicGFja19leHBvcnRzX18uQ2JpO1xudmFyIF9fd2VicGFja19leHBvcnRzX19RdWVyeSA9IF9fd2VicGFja19leHBvcnRzX18uQUVfO1xudmFyIF9fd2VicGFja19leHBvcnRzX19RdWVyeU1hbmFnZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmN0TztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneSA9IF9fd2VicGFja19leHBvcnRzX18uT0xIO1xudmFyIF9fd2VicGFja19leHBvcnRzX19SYW5kb20gPSBfX3dlYnBhY2tfZXhwb3J0c19fLmtreTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmFzdGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5uU0Y7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1JheSA9IF9fd2VicGFja19leHBvcnRzX18uekhuO1xudmFyIF9fd2VicGFja19leHBvcnRzX19SZWFsaXN0aWNTb2x2ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnp3eDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmVjdGFuZ2xlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5BZUo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1JlbW92ZWRDb21wb25lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmhMejtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmVtb3ZlZEVudGl0eSA9IF9fd2VicGFja19leHBvcnRzX18uRDlnO1xudmFyIF9fd2VicGFja19leHBvcnRzX19SZXBlYXQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLndBO1xudmFyIF9fd2VicGFja19leHBvcnRzX19SZXBlYXRGb3JldmVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5qaHI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Jlc29sdXRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLkdWcztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmVzb3VyY2UgPSBfX3dlYnBhY2tfZXhwb3J0c19fLl96TztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUm90YXRlQnkgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnc2JDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUm90YXRlVG8gPSBfX3dlYnBhY2tfZXhwb3J0c19fLm1oVjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUm90YXRpb25UeXBlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5NT0Q7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NjYWxlQnkgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmt3ZDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU2NhbGVUbyA9IF9fd2VicGFja19leHBvcnRzX18uTG1yO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TY2VuZSA9IF9fd2VicGFja19leHBvcnRzX18ueHNTO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TY3JlZW4gPSBfX3dlYnBhY2tfZXhwb3J0c19fLmxMcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU2NyZWVuQXBwZW5kZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlokcjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU2NyZWVuRWxlbWVudCA9IF9fd2VicGFja19leHBvcnRzX18uSVhiO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TY3JvbGxQcmV2ZW50aW9uTW9kZSA9IF9fd2VicGFja19leHBvcnRzX18uU01qO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TaGFwZSA9IF9fd2VicGFja19leHBvcnRzX18uYm5GO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TaWRlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5NRkE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NvcnRlZExpc3QgPSBfX3dlYnBhY2tfZXhwb3J0c19fLiRYQztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU291bmQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLiR1VTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3ByaXRlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5qeWk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Nwcml0ZUZvbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkUwMztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3ByaXRlU2hlZXQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlY2cTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3RyYXRlZ3lDb250YWluZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm5WbztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3RyZWFtID0gX193ZWJwYWNrX2V4cG9ydHNfXy5GNk47XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1N1YnNjcmliZUV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5hZDM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1N5c3RlbSA9IF9fd2VicGFja19leHBvcnRzX18ueFA3O1xudmFyIF9fd2VicGFja19leHBvcnRzX19TeXN0ZW1NYW5hZ2VyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5PZHE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1N5c3RlbVR5cGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlppZjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVGFnQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5aR0o7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1RleHQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnh2VDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVGV4dEFsaWduID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QSE07XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1RpbGVNYXAgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkt3TztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVGltZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkI3eTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVHJhaXRzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5TRnA7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1RyYW5zZm9ybUNvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18uVXZuO1xudmFyIF9fd2VicGFja19leHBvcnRzX19UcmVlTm9kZSA9IF9fd2VicGFja19leHBvcnRzX18uT0ZUO1xudmFyIF9fd2VicGFja19leHBvcnRzX19UcmlnZ2VyID0gX193ZWJwYWNrX2V4cG9ydHNfXy54ek47XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Vuc3Vic2NyaWJlRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkg2ajtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVXRpbCA9IF9fd2VicGFja19leHBvcnRzX18uWnJOO1xudmFyIF9fd2VicGFja19leHBvcnRzX19WZWN0b3IgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk9XcztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVmVjdG9yVmlldyA9IF9fd2VicGFja19leHBvcnRzX18uZEY5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19WaXNpYmxlRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlZIbztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fV2ViQXVkaW9JbnN0YW5jZSA9IF9fd2VicGFja19leHBvcnRzX18uUiRFO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Xb3JsZCA9IF9fd2VicGFja19leHBvcnRzX18ucTNJO1xudmFyIF9fd2VicGFja19leHBvcnRzX19jYW5vbmljYWxpemVBbmdsZSA9IF9fd2VicGFja19leHBvcnRzX18uUGFiO1xudmFyIF9fd2VicGFja19leHBvcnRzX19jbGFtcCA9IF9fd2VicGFja19leHBvcnRzX18udVo1O1xudmFyIF9fd2VicGFja19leHBvcnRzX19jcmVhdGVJZCA9IF9fd2VicGFja19leHBvcnRzX18uTWNLO1xudmFyIF9fd2VicGFja19leHBvcnRzX19oYXNHcmFwaGljc1RpY2sgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmswYjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faGFzT25Jbml0aWFsaXplID0gX193ZWJwYWNrX2V4cG9ydHNfXy5oblQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc09uUG9zdFVwZGF0ZSA9IF9fd2VicGFja19leHBvcnRzX18uUlNKO1xudmFyIF9fd2VicGFja19leHBvcnRzX19oYXNPblByZVVwZGF0ZSA9IF9fd2VicGFja19leHBvcnRzX18uTWt1O1xudmFyIF9fd2VicGFja19leHBvcnRzX19oYXNQb3N0RHJhdyA9IF9fd2VicGFja19leHBvcnRzX18uaDkwO1xudmFyIF9fd2VicGFja19leHBvcnRzX19oYXNQcmVEcmF3ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ybXM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc19pbml0aWFsaXplID0gX193ZWJwYWNrX2V4cG9ydHNfXy5FclA7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc19wb3N0dXBkYXRlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5hVmc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc19wcmV1cGRhdGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmxQYztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faXNBZGRlZENvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18uWjhFO1xudmFyIF9fd2VicGFja19leHBvcnRzX19pc0FkZGVkU3lzdGVtRW50aXR5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5OTkE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2lzUmVtb3ZlU3lzdGVtRW50aXR5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy55Rm47XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2lzUmVtb3ZlZENvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18ubE52O1xudmFyIF9fd2VicGFja19leHBvcnRzX19tYXhNZXNzYWdlcyA9IF9fd2VicGFja19leHBvcnRzX18uTVpRO1xudmFyIF9fd2VicGFja19leHBvcnRzX19vYnNvbGV0ZSA9IF9fd2VicGFja19leHBvcnRzX18uRlVNO1xudmFyIF9fd2VicGFja19leHBvcnRzX19yYW5kb21JblJhbmdlID0gX193ZWJwYWNrX2V4cG9ydHNfXy52ZGY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX3JhbmRvbUludEluUmFuZ2UgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmlhTDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fcmFuZ2UgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnc2SDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fcmVzZXRPYnNvbGV0ZUNvdW50ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlE0YztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fdG9EZWdyZWVzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5VeGI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX3RvUmFkaWFucyA9IF9fd2VicGFja19leHBvcnRzX18uWXI1O1xudmFyIF9fd2VicGFja19leHBvcnRzX192ZWMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkJodztcbmV4cG9ydCB7IF9fd2VicGFja19leHBvcnRzX19BY3Rpb25Db250ZXh0IGFzIEFjdGlvbkNvbnRleHQsIF9fd2VicGFja19leHBvcnRzX19BY3Rpb25RdWV1ZSBhcyBBY3Rpb25RdWV1ZSwgX193ZWJwYWNrX2V4cG9ydHNfX0FjdGlvbnNDb21wb25lbnQgYXMgQWN0aW9uc0NvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0FjdGlvbnNTeXN0ZW0gYXMgQWN0aW9uc1N5c3RlbSwgX193ZWJwYWNrX2V4cG9ydHNfX0FjdGl2YXRlRXZlbnQgYXMgQWN0aXZhdGVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0FjdG9yIGFzIEFjdG9yLCBfX3dlYnBhY2tfZXhwb3J0c19fQWRkZWRDb21wb25lbnQgYXMgQWRkZWRDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19BZGRlZEVudGl0eSBhcyBBZGRlZEVudGl0eSwgX193ZWJwYWNrX2V4cG9ydHNfX0FuaW1hdGlvbiBhcyBBbmltYXRpb24sIF9fd2VicGFja19leHBvcnRzX19BbmltYXRpb25EaXJlY3Rpb24gYXMgQW5pbWF0aW9uRGlyZWN0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fQW5pbWF0aW9uU3RyYXRlZ3kgYXMgQW5pbWF0aW9uU3RyYXRlZ3ksIF9fd2VicGFja19leHBvcnRzX19BcmNhZGVTb2x2ZXIgYXMgQXJjYWRlU29sdmVyLCBfX3dlYnBhY2tfZXhwb3J0c19fQXVkaW9Db250ZXh0RmFjdG9yeSBhcyBBdWRpb0NvbnRleHRGYWN0b3J5LCBfX3dlYnBhY2tfZXhwb3J0c19fQXhpcyBhcyBBeGlzLCBfX3dlYnBhY2tfZXhwb3J0c19fQmFzZUFsaWduIGFzIEJhc2VBbGlnbiwgX193ZWJwYWNrX2V4cG9ydHNfX0JpbmFyeVRyZWVOb2RlIGFzIEJpbmFyeVRyZWVOb2RlLCBfX3dlYnBhY2tfZXhwb3J0c19fQmxpbmsgYXMgQmxpbmssIF9fd2VicGFja19leHBvcnRzX19Cb2R5Q29tcG9uZW50IGFzIEJvZHlDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19Cb3VuZGluZ0JveCBhcyBCb3VuZGluZ0JveCwgX193ZWJwYWNrX2V4cG9ydHNfX0Jyb2FkcGhhc2VTdHJhdGVneSBhcyBCcm9hZHBoYXNlU3RyYXRlZ3ksIF9fd2VicGFja19leHBvcnRzX19Ccm93c2VyQ29tcG9uZW50IGFzIEJyb3dzZXJDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19Ccm93c2VyRXZlbnRzIGFzIEJyb3dzZXJFdmVudHMsIF9fd2VicGFja19leHBvcnRzX19DYW1lcmEgYXMgQ2FtZXJhLCBfX3dlYnBhY2tfZXhwb3J0c19fQ2FudmFzIGFzIENhbnZhcywgX193ZWJwYWNrX2V4cG9ydHNfX0NlbGwgYXMgQ2VsbCwgX193ZWJwYWNrX2V4cG9ydHNfX0NpcmNsZSBhcyBDaXJjbGUsIF9fd2VicGFja19leHBvcnRzX19DaXJjbGVDb2xsaWRlciBhcyBDaXJjbGVDb2xsaWRlciwgX193ZWJwYWNrX2V4cG9ydHNfX0NsYXNzIGFzIENsYXNzLCBfX3dlYnBhY2tfZXhwb3J0c19fQ2xvc2VzdExpbmUgYXMgQ2xvc2VzdExpbmUsIF9fd2VicGFja19leHBvcnRzX19DbG9zZXN0TGluZUp1bXBUYWJsZSBhcyBDbG9zZXN0TGluZUp1bXBUYWJsZSwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpZGVyIGFzIENvbGxpZGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlkZXJDb21wb25lbnQgYXMgQ29sbGlkZXJDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25Db250YWN0IGFzIENvbGxpc2lvbkNvbnRhY3QsIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25FbmRFdmVudCBhcyBDb2xsaXNpb25FbmRFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvbkdyb3VwIGFzIENvbGxpc2lvbkdyb3VwLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uR3JvdXBNYW5hZ2VyIGFzIENvbGxpc2lvbkdyb3VwTWFuYWdlciwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvbkp1bXBUYWJsZSBhcyBDb2xsaXNpb25KdW1wVGFibGUsIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25Qb3N0U29sdmVFdmVudCBhcyBDb2xsaXNpb25Qb3N0U29sdmVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblByZVNvbHZlRXZlbnQgYXMgQ29sbGlzaW9uUHJlU29sdmVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSBhcyBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3ksIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25Tb2x2ZXIgYXMgQ29sbGlzaW9uU29sdmVyLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uU3RhcnRFdmVudCBhcyBDb2xsaXNpb25TdGFydEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uU3lzdGVtIGFzIENvbGxpc2lvblN5c3RlbSwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblR5cGUgYXMgQ29sbGlzaW9uVHlwZSwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbG9yIGFzIENvbG9yLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3JCbGluZENvcnJlY3RvciBhcyBDb2xvckJsaW5kQ29ycmVjdG9yLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3JCbGluZEZsYWdzIGFzIENvbG9yQmxpbmRGbGFncywgX193ZWJwYWNrX2V4cG9ydHNfX0NvbG9yQmxpbmRuZXNzIGFzIENvbG9yQmxpbmRuZXNzLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29tcG9uZW50IGFzIENvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbXBvc2l0ZUNvbGxpZGVyIGFzIENvbXBvc2l0ZUNvbGxpZGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29uZmlndXJhYmxlIGFzIENvbmZpZ3VyYWJsZSwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbnNvbGVBcHBlbmRlciBhcyBDb25zb2xlQXBwZW5kZXIsIF9fd2VicGFja19leHBvcnRzX19Db250YWN0Q29uc3RyYWludFBvaW50IGFzIENvbnRhY3RDb25zdHJhaW50UG9pbnQsIF9fd2VicGFja19leHBvcnRzX19Db250YWN0RW5kRXZlbnQgYXMgQ29udGFjdEVuZEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQ29udGFjdFN0YXJ0RXZlbnQgYXMgQ29udGFjdFN0YXJ0RXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Db29yZFBsYW5lIGFzIENvb3JkUGxhbmUsIF9fd2VicGFja19leHBvcnRzX19DdWxsaW5nQm94IGFzIEN1bGxpbmdCb3gsIF9fd2VicGFja19leHBvcnRzX19EZWFjdGl2YXRlRXZlbnQgYXMgRGVhY3RpdmF0ZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fRGVidWcgYXMgRGVidWcsIF9fd2VicGFja19leHBvcnRzX19EZWJ1Z1N5c3RlbSBhcyBEZWJ1Z1N5c3RlbSwgX193ZWJwYWNrX2V4cG9ydHNfX0RlYnVnVGV4dCBhcyBEZWJ1Z1RleHQsIF9fd2VicGFja19leHBvcnRzX19EZWdyZWVPZkZyZWVkb20gYXMgRGVncmVlT2ZGcmVlZG9tLCBfX3dlYnBhY2tfZXhwb3J0c19fRGV0ZWN0b3IgYXMgRGV0ZWN0b3IsIF9fd2VicGFja19leHBvcnRzX19EaWUgYXMgRGllLCBfX3dlYnBhY2tfZXhwb3J0c19fRGlyZWN0aW9uIGFzIERpcmVjdGlvbiwgX193ZWJwYWNrX2V4cG9ydHNfX0Rpc3BsYXlNb2RlIGFzIERpc3BsYXlNb2RlLCBfX3dlYnBhY2tfZXhwb3J0c19fRHluYW1pY1RyZWUgYXMgRHluYW1pY1RyZWUsIF9fd2VicGFja19leHBvcnRzX19EeW5hbWljVHJlZUNvbGxpc2lvblByb2Nlc3NvciBhcyBEeW5hbWljVHJlZUNvbGxpc2lvblByb2Nlc3NvciwgX193ZWJwYWNrX2V4cG9ydHNfX0VYX1ZFUlNJT04gYXMgRVhfVkVSU0lPTiwgX193ZWJwYWNrX2V4cG9ydHNfX0Vhc2VUbyBhcyBFYXNlVG8sIF9fd2VicGFja19leHBvcnRzX19FYXNpbmdGdW5jdGlvbnMgYXMgRWFzaW5nRnVuY3Rpb25zLCBfX3dlYnBhY2tfZXhwb3J0c19fRWRnZUNvbGxpZGVyIGFzIEVkZ2VDb2xsaWRlciwgX193ZWJwYWNrX2V4cG9ydHNfX0VsYXN0aWNUb0FjdG9yU3RyYXRlZ3kgYXMgRWxhc3RpY1RvQWN0b3JTdHJhdGVneSwgX193ZWJwYWNrX2V4cG9ydHNfX0VtaXR0ZXJUeXBlIGFzIEVtaXR0ZXJUeXBlLCBfX3dlYnBhY2tfZXhwb3J0c19fRW5naW5lIGFzIEVuZ2luZSwgX193ZWJwYWNrX2V4cG9ydHNfX0VudGVyVHJpZ2dlckV2ZW50IGFzIEVudGVyVHJpZ2dlckV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fRW50ZXJWaWV3UG9ydEV2ZW50IGFzIEVudGVyVmlld1BvcnRFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0VudGl0eSBhcyBFbnRpdHksIF9fd2VicGFja19leHBvcnRzX19FbnRpdHlNYW5hZ2VyIGFzIEVudGl0eU1hbmFnZXIsIF9fd2VicGFja19leHBvcnRzX19FdmVudERpc3BhdGNoZXIgYXMgRXZlbnREaXNwYXRjaGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fRXZlbnRUeXBlcyBhcyBFdmVudFR5cGVzLCBfX3dlYnBhY2tfZXhwb3J0c19fRXZlbnRzIGFzIEV2ZW50cywgX193ZWJwYWNrX2V4cG9ydHNfX0V4UmVzcG9uc2UgYXMgRXhSZXNwb25zZSwgX193ZWJwYWNrX2V4cG9ydHNfX0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzIGFzIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzLCBfX3dlYnBhY2tfZXhwb3J0c19fRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0wgYXMgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0wsIF9fd2VicGFja19leHBvcnRzX19FeGl0VHJpZ2dlckV2ZW50IGFzIEV4aXRUcmlnZ2VyRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19FeGl0Vmlld1BvcnRFdmVudCBhcyBFeGl0Vmlld1BvcnRFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0V4cGVyaW1lbnRzIGFzIEV4cGVyaW1lbnRzLCBfX3dlYnBhY2tfZXhwb3J0c19fRmFkZSBhcyBGYWRlLCBfX3dlYnBhY2tfZXhwb3J0c19fRmxhZ3MgYXMgRmxhZ3MsIF9fd2VicGFja19leHBvcnRzX19Gb2xsb3cgYXMgRm9sbG93LCBfX3dlYnBhY2tfZXhwb3J0c19fRm9udCBhcyBGb250LCBfX3dlYnBhY2tfZXhwb3J0c19fRm9udFN0eWxlIGFzIEZvbnRTdHlsZSwgX193ZWJwYWNrX2V4cG9ydHNfX0ZvbnRVbml0IGFzIEZvbnRVbml0LCBfX3dlYnBhY2tfZXhwb3J0c19fRnJhbWVTdGF0cyBhcyBGcmFtZVN0YXRzLCBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZUV2ZW50IGFzIEdhbWVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0dhbWVTdGFydEV2ZW50IGFzIEdhbWVTdGFydEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZVN0b3BFdmVudCBhcyBHYW1lU3RvcEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZXBhZEF4aXNFdmVudCBhcyBHYW1lcGFkQXhpc0V2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZXBhZEJ1dHRvbkV2ZW50IGFzIEdhbWVwYWRCdXR0b25FdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0dhbWVwYWRDb25uZWN0RXZlbnQgYXMgR2FtZXBhZENvbm5lY3RFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0dhbWVwYWREaXNjb25uZWN0RXZlbnQgYXMgR2FtZXBhZERpc2Nvbm5lY3RFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0dpZiBhcyBHaWYsIF9fd2VicGFja19leHBvcnRzX19HbG9iYWxDb29yZGluYXRlcyBhcyBHbG9iYWxDb29yZGluYXRlcywgX193ZWJwYWNrX2V4cG9ydHNfX0dyYXBoaWMgYXMgR3JhcGhpYywgX193ZWJwYWNrX2V4cG9ydHNfX0dyYXBoaWNzQ29tcG9uZW50IGFzIEdyYXBoaWNzQ29tcG9uZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpY3NHcm91cCBhcyBHcmFwaGljc0dyb3VwLCBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpY3NMYXllciBhcyBHcmFwaGljc0xheWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpY3NMYXllcnMgYXMgR3JhcGhpY3NMYXllcnMsIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc1N5c3RlbSBhcyBHcmFwaGljc1N5c3RlbSwgX193ZWJwYWNrX2V4cG9ydHNfX0hpZGRlbkV2ZW50IGFzIEhpZGRlbkV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fSW1hZ2VTb3VyY2UgYXMgSW1hZ2VTb3VyY2UsIF9fd2VicGFja19leHBvcnRzX19Jbml0aWFsaXplRXZlbnQgYXMgSW5pdGlhbGl6ZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fSW5wdXQgYXMgSW5wdXQsIF9fd2VicGFja19leHBvcnRzX19JbnRlZ3JhdG9yIGFzIEludGVncmF0b3IsIF9fd2VicGFja19leHBvcnRzX19LaWxsRXZlbnQgYXMgS2lsbEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fTGFiZWwgYXMgTGFiZWwsIF9fd2VicGFja19leHBvcnRzX19MZWdhY3kgYXMgTGVnYWN5LCBfX3dlYnBhY2tfZXhwb3J0c19fTGVnYWN5RHJhd2luZyBhcyBMZWdhY3lEcmF3aW5nLCBfX3dlYnBhY2tfZXhwb3J0c19fTGltaXRDYW1lcmFCb3VuZHNTdHJhdGVneSBhcyBMaW1pdENhbWVyYUJvdW5kc1N0cmF0ZWd5LCBfX3dlYnBhY2tfZXhwb3J0c19fTGluZSBhcyBMaW5lLCBfX3dlYnBhY2tfZXhwb3J0c19fTG9hZGVyIGFzIExvYWRlciwgX193ZWJwYWNrX2V4cG9ydHNfX0xvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5IGFzIExvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5LCBfX3dlYnBhY2tfZXhwb3J0c19fTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneSBhcyBMb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5LCBfX3dlYnBhY2tfZXhwb3J0c19fTG9nTGV2ZWwgYXMgTG9nTGV2ZWwsIF9fd2VicGFja19leHBvcnRzX19Mb2dnZXIgYXMgTG9nZ2VyLCBfX3dlYnBhY2tfZXhwb3J0c19fTWF0cml4IGFzIE1hdHJpeCwgX193ZWJwYWNrX2V4cG9ydHNfX01hdHJpeExvY2F0aW9ucyBhcyBNYXRyaXhMb2NhdGlvbnMsIF9fd2VicGFja19leHBvcnRzX19NZWRpYUV2ZW50IGFzIE1lZGlhRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19NZWV0IGFzIE1lZXQsIF9fd2VicGFja19leHBvcnRzX19Nb2NrZWRFbGVtZW50IGFzIE1vY2tlZEVsZW1lbnQsIF9fd2VicGFja19leHBvcnRzX19Nb3Rpb25Db21wb25lbnQgYXMgTW90aW9uQ29tcG9uZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fTW90aW9uU3lzdGVtIGFzIE1vdGlvblN5c3RlbSwgX193ZWJwYWNrX2V4cG9ydHNfX01vdmVCeSBhcyBNb3ZlQnksIF9fd2VicGFja19leHBvcnRzX19Nb3ZlVG8gYXMgTW92ZVRvLCBfX3dlYnBhY2tfZXhwb3J0c19fTmF0aXZlU291bmRFdmVudCBhcyBOYXRpdmVTb3VuZEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fTmF0aXZlU291bmRQcm9jZXNzZWRFdmVudCBhcyBOYXRpdmVTb3VuZFByb2Nlc3NlZEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fT2JzZXJ2YWJsZSBhcyBPYnNlcnZhYmxlLCBfX3dlYnBhY2tfZXhwb3J0c19fUGFpciBhcyBQYWlyLCBfX3dlYnBhY2tfZXhwb3J0c19fUGFyc2VHaWYgYXMgUGFyc2VHaWYsIF9fd2VicGFja19leHBvcnRzX19QYXJ0aWNsZSBhcyBQYXJ0aWNsZSwgX193ZWJwYWNrX2V4cG9ydHNfX1BhcnRpY2xlRW1pdHRlciBhcyBQYXJ0aWNsZUVtaXR0ZXIsIF9fd2VicGFja19leHBvcnRzX19QaHlzaWNzIGFzIFBoeXNpY3MsIF9fd2VicGFja19leHBvcnRzX19QaHlzaWNzU3RhdHMgYXMgUGh5c2ljc1N0YXRzLCBfX3dlYnBhY2tfZXhwb3J0c19fUG9seWdvbiBhcyBQb2x5Z29uLCBfX3dlYnBhY2tfZXhwb3J0c19fUG9seWdvbkNvbGxpZGVyIGFzIFBvbHlnb25Db2xsaWRlciwgX193ZWJwYWNrX2V4cG9ydHNfX1Bvb2wgYXMgUG9vbCwgX193ZWJwYWNrX2V4cG9ydHNfX1Bvc3RDb2xsaXNpb25FdmVudCBhcyBQb3N0Q29sbGlzaW9uRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Qb3N0RGVidWdEcmF3RXZlbnQgYXMgUG9zdERlYnVnRHJhd0V2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fUG9zdERyYXdFdmVudCBhcyBQb3N0RHJhd0V2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fUG9zdEZyYW1lRXZlbnQgYXMgUG9zdEZyYW1lRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Qb3N0S2lsbEV2ZW50IGFzIFBvc3RLaWxsRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Qb3N0VXBkYXRlRXZlbnQgYXMgUG9zdFVwZGF0ZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fUHJlQ29sbGlzaW9uRXZlbnQgYXMgUHJlQ29sbGlzaW9uRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19QcmVEZWJ1Z0RyYXdFdmVudCBhcyBQcmVEZWJ1Z0RyYXdFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1ByZURyYXdFdmVudCBhcyBQcmVEcmF3RXZlbnQsIF9fd2VicGFja19leHBvcnRzX19QcmVGcmFtZUV2ZW50IGFzIFByZUZyYW1lRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19QcmVLaWxsRXZlbnQgYXMgUHJlS2lsbEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fUHJlVXBkYXRlRXZlbnQgYXMgUHJlVXBkYXRlRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Qcm9qZWN0aW9uIGFzIFByb2plY3Rpb24sIF9fd2VicGFja19leHBvcnRzX19Qcm9taXNlIGFzIFByb21pc2UsIF9fd2VicGFja19leHBvcnRzX19Qcm9taXNlU3RhdGUgYXMgUHJvbWlzZVN0YXRlLCBfX3dlYnBhY2tfZXhwb3J0c19fUXVlcnkgYXMgUXVlcnksIF9fd2VicGFja19leHBvcnRzX19RdWVyeU1hbmFnZXIgYXMgUXVlcnlNYW5hZ2VyLCBfX3dlYnBhY2tfZXhwb3J0c19fUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneSBhcyBSYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5LCBfX3dlYnBhY2tfZXhwb3J0c19fUmFuZG9tIGFzIFJhbmRvbSwgX193ZWJwYWNrX2V4cG9ydHNfX1Jhc3RlciBhcyBSYXN0ZXIsIF9fd2VicGFja19leHBvcnRzX19SYXkgYXMgUmF5LCBfX3dlYnBhY2tfZXhwb3J0c19fUmVhbGlzdGljU29sdmVyIGFzIFJlYWxpc3RpY1NvbHZlciwgX193ZWJwYWNrX2V4cG9ydHNfX1JlY3RhbmdsZSBhcyBSZWN0YW5nbGUsIF9fd2VicGFja19leHBvcnRzX19SZW1vdmVkQ29tcG9uZW50IGFzIFJlbW92ZWRDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19SZW1vdmVkRW50aXR5IGFzIFJlbW92ZWRFbnRpdHksIF9fd2VicGFja19leHBvcnRzX19SZXBlYXQgYXMgUmVwZWF0LCBfX3dlYnBhY2tfZXhwb3J0c19fUmVwZWF0Rm9yZXZlciBhcyBSZXBlYXRGb3JldmVyLCBfX3dlYnBhY2tfZXhwb3J0c19fUmVzb2x1dGlvbiBhcyBSZXNvbHV0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fUmVzb3VyY2UgYXMgUmVzb3VyY2UsIF9fd2VicGFja19leHBvcnRzX19Sb3RhdGVCeSBhcyBSb3RhdGVCeSwgX193ZWJwYWNrX2V4cG9ydHNfX1JvdGF0ZVRvIGFzIFJvdGF0ZVRvLCBfX3dlYnBhY2tfZXhwb3J0c19fUm90YXRpb25UeXBlIGFzIFJvdGF0aW9uVHlwZSwgX193ZWJwYWNrX2V4cG9ydHNfX1NjYWxlQnkgYXMgU2NhbGVCeSwgX193ZWJwYWNrX2V4cG9ydHNfX1NjYWxlVG8gYXMgU2NhbGVUbywgX193ZWJwYWNrX2V4cG9ydHNfX1NjZW5lIGFzIFNjZW5lLCBfX3dlYnBhY2tfZXhwb3J0c19fU2NyZWVuIGFzIFNjcmVlbiwgX193ZWJwYWNrX2V4cG9ydHNfX1NjcmVlbkFwcGVuZGVyIGFzIFNjcmVlbkFwcGVuZGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fU2NyZWVuRWxlbWVudCBhcyBTY3JlZW5FbGVtZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fU2Nyb2xsUHJldmVudGlvbk1vZGUgYXMgU2Nyb2xsUHJldmVudGlvbk1vZGUsIF9fd2VicGFja19leHBvcnRzX19TaGFwZSBhcyBTaGFwZSwgX193ZWJwYWNrX2V4cG9ydHNfX1NpZGUgYXMgU2lkZSwgX193ZWJwYWNrX2V4cG9ydHNfX1NvcnRlZExpc3QgYXMgU29ydGVkTGlzdCwgX193ZWJwYWNrX2V4cG9ydHNfX1NvdW5kIGFzIFNvdW5kLCBfX3dlYnBhY2tfZXhwb3J0c19fU3ByaXRlIGFzIFNwcml0ZSwgX193ZWJwYWNrX2V4cG9ydHNfX1Nwcml0ZUZvbnQgYXMgU3ByaXRlRm9udCwgX193ZWJwYWNrX2V4cG9ydHNfX1Nwcml0ZVNoZWV0IGFzIFNwcml0ZVNoZWV0LCBfX3dlYnBhY2tfZXhwb3J0c19fU3RyYXRlZ3lDb250YWluZXIgYXMgU3RyYXRlZ3lDb250YWluZXIsIF9fd2VicGFja19leHBvcnRzX19TdHJlYW0gYXMgU3RyZWFtLCBfX3dlYnBhY2tfZXhwb3J0c19fU3Vic2NyaWJlRXZlbnQgYXMgU3Vic2NyaWJlRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19TeXN0ZW0gYXMgU3lzdGVtLCBfX3dlYnBhY2tfZXhwb3J0c19fU3lzdGVtTWFuYWdlciBhcyBTeXN0ZW1NYW5hZ2VyLCBfX3dlYnBhY2tfZXhwb3J0c19fU3lzdGVtVHlwZSBhcyBTeXN0ZW1UeXBlLCBfX3dlYnBhY2tfZXhwb3J0c19fVGFnQ29tcG9uZW50IGFzIFRhZ0NvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1RleHQgYXMgVGV4dCwgX193ZWJwYWNrX2V4cG9ydHNfX1RleHRBbGlnbiBhcyBUZXh0QWxpZ24sIF9fd2VicGFja19leHBvcnRzX19UaWxlTWFwIGFzIFRpbGVNYXAsIF9fd2VicGFja19leHBvcnRzX19UaW1lciBhcyBUaW1lciwgX193ZWJwYWNrX2V4cG9ydHNfX1RyYWl0cyBhcyBUcmFpdHMsIF9fd2VicGFja19leHBvcnRzX19UcmFuc2Zvcm1Db21wb25lbnQgYXMgVHJhbnNmb3JtQ29tcG9uZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fVHJlZU5vZGUgYXMgVHJlZU5vZGUsIF9fd2VicGFja19leHBvcnRzX19UcmlnZ2VyIGFzIFRyaWdnZXIsIF9fd2VicGFja19leHBvcnRzX19VbnN1YnNjcmliZUV2ZW50IGFzIFVuc3Vic2NyaWJlRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19VdGlsIGFzIFV0aWwsIF9fd2VicGFja19leHBvcnRzX19WZWN0b3IgYXMgVmVjdG9yLCBfX3dlYnBhY2tfZXhwb3J0c19fVmVjdG9yVmlldyBhcyBWZWN0b3JWaWV3LCBfX3dlYnBhY2tfZXhwb3J0c19fVmlzaWJsZUV2ZW50IGFzIFZpc2libGVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1dlYkF1ZGlvSW5zdGFuY2UgYXMgV2ViQXVkaW9JbnN0YW5jZSwgX193ZWJwYWNrX2V4cG9ydHNfX1dvcmxkIGFzIFdvcmxkLCBfX3dlYnBhY2tfZXhwb3J0c19fY2Fub25pY2FsaXplQW5nbGUgYXMgY2Fub25pY2FsaXplQW5nbGUsIF9fd2VicGFja19leHBvcnRzX19jbGFtcCBhcyBjbGFtcCwgX193ZWJwYWNrX2V4cG9ydHNfX2NyZWF0ZUlkIGFzIGNyZWF0ZUlkLCBfX3dlYnBhY2tfZXhwb3J0c19faGFzR3JhcGhpY3NUaWNrIGFzIGhhc0dyYXBoaWNzVGljaywgX193ZWJwYWNrX2V4cG9ydHNfX2hhc09uSW5pdGlhbGl6ZSBhcyBoYXNPbkluaXRpYWxpemUsIF9fd2VicGFja19leHBvcnRzX19oYXNPblBvc3RVcGRhdGUgYXMgaGFzT25Qb3N0VXBkYXRlLCBfX3dlYnBhY2tfZXhwb3J0c19faGFzT25QcmVVcGRhdGUgYXMgaGFzT25QcmVVcGRhdGUsIF9fd2VicGFja19leHBvcnRzX19oYXNQb3N0RHJhdyBhcyBoYXNQb3N0RHJhdywgX193ZWJwYWNrX2V4cG9ydHNfX2hhc1ByZURyYXcgYXMgaGFzUHJlRHJhdywgX193ZWJwYWNrX2V4cG9ydHNfX2hhc19pbml0aWFsaXplIGFzIGhhc19pbml0aWFsaXplLCBfX3dlYnBhY2tfZXhwb3J0c19faGFzX3Bvc3R1cGRhdGUgYXMgaGFzX3Bvc3R1cGRhdGUsIF9fd2VicGFja19leHBvcnRzX19oYXNfcHJldXBkYXRlIGFzIGhhc19wcmV1cGRhdGUsIF9fd2VicGFja19leHBvcnRzX19pc0FkZGVkQ29tcG9uZW50IGFzIGlzQWRkZWRDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19pc0FkZGVkU3lzdGVtRW50aXR5IGFzIGlzQWRkZWRTeXN0ZW1FbnRpdHksIF9fd2VicGFja19leHBvcnRzX19pc1JlbW92ZVN5c3RlbUVudGl0eSBhcyBpc1JlbW92ZVN5c3RlbUVudGl0eSwgX193ZWJwYWNrX2V4cG9ydHNfX2lzUmVtb3ZlZENvbXBvbmVudCBhcyBpc1JlbW92ZWRDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19tYXhNZXNzYWdlcyBhcyBtYXhNZXNzYWdlcywgX193ZWJwYWNrX2V4cG9ydHNfX29ic29sZXRlIGFzIG9ic29sZXRlLCBfX3dlYnBhY2tfZXhwb3J0c19fcmFuZG9tSW5SYW5nZSBhcyByYW5kb21JblJhbmdlLCBfX3dlYnBhY2tfZXhwb3J0c19fcmFuZG9tSW50SW5SYW5nZSBhcyByYW5kb21JbnRJblJhbmdlLCBfX3dlYnBhY2tfZXhwb3J0c19fcmFuZ2UgYXMgcmFuZ2UsIF9fd2VicGFja19leHBvcnRzX19yZXNldE9ic29sZXRlQ291bnRlciBhcyByZXNldE9ic29sZXRlQ291bnRlciwgX193ZWJwYWNrX2V4cG9ydHNfX3RvRGVncmVlcyBhcyB0b0RlZ3JlZXMsIF9fd2VicGFja19leHBvcnRzX190b1JhZGlhbnMgYXMgdG9SYWRpYW5zLCBfX3dlYnBhY2tfZXhwb3J0c19fdmVjIGFzIHZlYyB9O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1leGNhbGlidXIuanMubWFwIiwiaW1wb3J0IHsgQWN0b3IsIENvbGxpc2lvblR5cGUsIEVuZ2luZSwgSW5wdXQsIFZlY3RvciwgdmVjIH0gZnJvbSBcImV4Y2FsaWJ1clwiO1xuaW1wb3J0IHsgU3ByaXRlU2hlZXRzIH0gZnJvbSBcIi4uL3Jlc291cmNlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXIgZXh0ZW5kcyBBY3RvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHg6IDY0LFxuICAgICAgeTogNjQsXG4gICAgICB3aWR0aDogNjQsXG4gICAgICBoZWlnaHQ6IDMyLFxuICAgICAgY29sbGlzaW9uVHlwZTogQ29sbGlzaW9uVHlwZS5BY3RpdmUsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgb25Jbml0aWFsaXplKF9lbmdpbmU6IEVuZ2luZSkge1xuICAgIHRoaXMuZ3JhcGhpY3MudXNlKFNwcml0ZVNoZWV0cy5wbGF5ZXJfaWRsZS5zcHJpdGVzWzBdKTtcbiAgfVxuXG4gIHB1YmxpYyBvblBvc3RVcGRhdGUoZW5naW5lOiBFbmdpbmUsIF9kZWx0YTogbnVtYmVyKSB7XG4gICAgaWYgKGVuZ2luZS5pbnB1dC5rZXlib2FyZC5pc0hlbGQoSW5wdXQuS2V5cy5SaWdodCkpIHtcbiAgICAgIHRoaXMubW92ZSh2ZWMoMSwgMCkpO1xuICAgIH1cblxuICAgIGlmIChlbmdpbmUuaW5wdXQua2V5Ym9hcmQuaXNIZWxkKElucHV0LktleXMuTGVmdCkpIHtcbiAgICAgIHRoaXMubW92ZSh2ZWMoLTEsIDApKTtcbiAgICB9XG5cbiAgICBpZiAoZW5naW5lLmlucHV0LmtleWJvYXJkLndhc1ByZXNzZWQoSW5wdXQuS2V5cy5TcGFjZSkpIHtcbiAgICAgIHRoaXMudmVsLnkgLT0gMTAwO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgbW92ZSh2ZWM6IFZlY3Rvcikge1xuICAgIHRoaXMucG9zLnggKz0gdmVjLng7XG4gICAgdGhpcy5wb3MueSArPSB2ZWMueTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgSW1hZ2VTb3VyY2UsIExvYWRlciwgU3ByaXRlU2hlZXQgfSBmcm9tIFwiZXhjYWxpYnVyXCI7XG5pbXBvcnQgcGxheWVySWRsZUZpbGUgZnJvbSBcIi4uL2Fzc2V0cy9pbWFnZXMvcGxheWVyX2lkbGUucG5nXCI7XG5cbmNvbnN0IEltYWdlczogeyBba2V5OiBzdHJpbmddOiBJbWFnZVNvdXJjZSB9ID0ge1xuICBwbGF5ZXJJZGxlOiBuZXcgSW1hZ2VTb3VyY2UocGxheWVySWRsZUZpbGUpLFxufTtcblxuY29uc3QgU3ByaXRlU2hlZXRzOiB7IFtrZXk6IHN0cmluZ106IFNwcml0ZVNoZWV0IH0gPSB7XG4gIHBsYXllcl9pZGxlOiBTcHJpdGVTaGVldC5mcm9tSW1hZ2VTb3VyY2Uoe1xuICAgIGltYWdlOiBJbWFnZXMucGxheWVySWRsZSxcbiAgICBncmlkOiB7XG4gICAgICBjb2x1bW5zOiAxLFxuICAgICAgcm93czogMSxcbiAgICAgIHNwcml0ZVdpZHRoOiA2NCxcbiAgICAgIHNwcml0ZUhlaWdodDogMzIsXG4gICAgfSxcbiAgfSksXG59O1xuXG5jb25zdCBsb2FkZXIgPSBuZXcgTG9hZGVyKCk7XG5mb3IgKGNvbnN0IGltYWdlIGluIEltYWdlcykge1xuICBsb2FkZXIuYWRkUmVzb3VyY2UoSW1hZ2VzW2ltYWdlXSk7XG59XG5cbmV4cG9ydCB7IGxvYWRlciwgU3ByaXRlU2hlZXRzIH07XG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwidmFyIHNjcmlwdFVybDtcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmcuaW1wb3J0U2NyaXB0cykgc2NyaXB0VXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmxvY2F0aW9uICsgXCJcIjtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5kb2N1bWVudDtcbmlmICghc2NyaXB0VXJsICYmIGRvY3VtZW50KSB7XG5cdGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjXG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkgc2NyaXB0VXJsID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLnNyY1xuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybDsiLCJpbXBvcnQgeyBBY3RvciwgQ29sbGlzaW9uVHlwZSwgQ29sb3IsIEVuZ2luZSwgUGh5c2ljcywgdmVjIH0gZnJvbSBcImV4Y2FsaWJ1clwiO1xuaW1wb3J0IFBsYXllciBmcm9tIFwiLi9hY3RvcnMvcGxheWVyXCI7XG5pbXBvcnQgeyBsb2FkZXIgfSBmcm9tIFwiLi9yZXNvdXJjZXNcIjtcblxuUGh5c2ljcy5hY2MgPSB2ZWMoMCwgNTAwKTtcblxuY29uc3QgZ2FtZSA9IG5ldyBFbmdpbmUoe1xuICB3aWR0aDogODAwLFxuICBoZWlnaHQ6IDYwMCxcbn0pO1xuXG5nYW1lLnN0YXJ0KGxvYWRlcik7XG5cbmNvbnN0IHBsYXllciA9IG5ldyBQbGF5ZXIoKTtcbmNvbnN0IGdyb3VuZCA9IG5ldyBBY3Rvcih7XG4gIHBvczogdmVjKGdhbWUuaGFsZkRyYXdXaWR0aCwgZ2FtZS5kcmF3SGVpZ2h0KSxcbiAgd2lkdGg6IGdhbWUuZHJhd0hlaWdodCxcbiAgaGVpZ2h0OiAxMDAsXG4gIGNvbG9yOiBDb2xvci5HcmVlbixcbiAgY29sbGlzaW9uVHlwZTogQ29sbGlzaW9uVHlwZS5GaXhlZCxcbn0pO1xuXG5nYW1lLmFkZChncm91bmQpO1xuZ2FtZS5hZGQocGxheWVyKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==