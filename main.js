/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/excalibur/build/esm/excalibur.js":
/*!*******************************************************!*\
  !*** ./node_modules/excalibur/build/esm/excalibur.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ActionContext": () => (/* binding */ __webpack_exports__ActionContext),
/* harmony export */   "ActionQueue": () => (/* binding */ __webpack_exports__ActionQueue),
/* harmony export */   "ActionsComponent": () => (/* binding */ __webpack_exports__ActionsComponent),
/* harmony export */   "ActionsSystem": () => (/* binding */ __webpack_exports__ActionsSystem),
/* harmony export */   "ActivateEvent": () => (/* binding */ __webpack_exports__ActivateEvent),
/* harmony export */   "Actor": () => (/* binding */ __webpack_exports__Actor),
/* harmony export */   "AddedComponent": () => (/* binding */ __webpack_exports__AddedComponent),
/* harmony export */   "AddedEntity": () => (/* binding */ __webpack_exports__AddedEntity),
/* harmony export */   "Animation": () => (/* binding */ __webpack_exports__Animation),
/* harmony export */   "AnimationDirection": () => (/* binding */ __webpack_exports__AnimationDirection),
/* harmony export */   "AnimationStrategy": () => (/* binding */ __webpack_exports__AnimationStrategy),
/* harmony export */   "ArcadeSolver": () => (/* binding */ __webpack_exports__ArcadeSolver),
/* harmony export */   "AudioContextFactory": () => (/* binding */ __webpack_exports__AudioContextFactory),
/* harmony export */   "Axis": () => (/* binding */ __webpack_exports__Axis),
/* harmony export */   "BaseAlign": () => (/* binding */ __webpack_exports__BaseAlign),
/* harmony export */   "BinaryTreeNode": () => (/* binding */ __webpack_exports__BinaryTreeNode),
/* harmony export */   "Blink": () => (/* binding */ __webpack_exports__Blink),
/* harmony export */   "BodyComponent": () => (/* binding */ __webpack_exports__BodyComponent),
/* harmony export */   "BoundingBox": () => (/* binding */ __webpack_exports__BoundingBox),
/* harmony export */   "BroadphaseStrategy": () => (/* binding */ __webpack_exports__BroadphaseStrategy),
/* harmony export */   "BrowserComponent": () => (/* binding */ __webpack_exports__BrowserComponent),
/* harmony export */   "BrowserEvents": () => (/* binding */ __webpack_exports__BrowserEvents),
/* harmony export */   "Camera": () => (/* binding */ __webpack_exports__Camera),
/* harmony export */   "Canvas": () => (/* binding */ __webpack_exports__Canvas),
/* harmony export */   "Cell": () => (/* binding */ __webpack_exports__Cell),
/* harmony export */   "Circle": () => (/* binding */ __webpack_exports__Circle),
/* harmony export */   "CircleCollider": () => (/* binding */ __webpack_exports__CircleCollider),
/* harmony export */   "Class": () => (/* binding */ __webpack_exports__Class),
/* harmony export */   "ClosestLine": () => (/* binding */ __webpack_exports__ClosestLine),
/* harmony export */   "ClosestLineJumpTable": () => (/* binding */ __webpack_exports__ClosestLineJumpTable),
/* harmony export */   "Collider": () => (/* binding */ __webpack_exports__Collider),
/* harmony export */   "ColliderComponent": () => (/* binding */ __webpack_exports__ColliderComponent),
/* harmony export */   "CollisionContact": () => (/* binding */ __webpack_exports__CollisionContact),
/* harmony export */   "CollisionEndEvent": () => (/* binding */ __webpack_exports__CollisionEndEvent),
/* harmony export */   "CollisionGroup": () => (/* binding */ __webpack_exports__CollisionGroup),
/* harmony export */   "CollisionGroupManager": () => (/* binding */ __webpack_exports__CollisionGroupManager),
/* harmony export */   "CollisionJumpTable": () => (/* binding */ __webpack_exports__CollisionJumpTable),
/* harmony export */   "CollisionPostSolveEvent": () => (/* binding */ __webpack_exports__CollisionPostSolveEvent),
/* harmony export */   "CollisionPreSolveEvent": () => (/* binding */ __webpack_exports__CollisionPreSolveEvent),
/* harmony export */   "CollisionResolutionStrategy": () => (/* binding */ __webpack_exports__CollisionResolutionStrategy),
/* harmony export */   "CollisionSolver": () => (/* binding */ __webpack_exports__CollisionSolver),
/* harmony export */   "CollisionStartEvent": () => (/* binding */ __webpack_exports__CollisionStartEvent),
/* harmony export */   "CollisionSystem": () => (/* binding */ __webpack_exports__CollisionSystem),
/* harmony export */   "CollisionType": () => (/* binding */ __webpack_exports__CollisionType),
/* harmony export */   "Color": () => (/* binding */ __webpack_exports__Color),
/* harmony export */   "ColorBlindCorrector": () => (/* binding */ __webpack_exports__ColorBlindCorrector),
/* harmony export */   "ColorBlindFlags": () => (/* binding */ __webpack_exports__ColorBlindFlags),
/* harmony export */   "ColorBlindness": () => (/* binding */ __webpack_exports__ColorBlindness),
/* harmony export */   "Component": () => (/* binding */ __webpack_exports__Component),
/* harmony export */   "CompositeCollider": () => (/* binding */ __webpack_exports__CompositeCollider),
/* harmony export */   "Configurable": () => (/* binding */ __webpack_exports__Configurable),
/* harmony export */   "ConsoleAppender": () => (/* binding */ __webpack_exports__ConsoleAppender),
/* harmony export */   "ContactConstraintPoint": () => (/* binding */ __webpack_exports__ContactConstraintPoint),
/* harmony export */   "ContactEndEvent": () => (/* binding */ __webpack_exports__ContactEndEvent),
/* harmony export */   "ContactStartEvent": () => (/* binding */ __webpack_exports__ContactStartEvent),
/* harmony export */   "CoordPlane": () => (/* binding */ __webpack_exports__CoordPlane),
/* harmony export */   "CullingBox": () => (/* binding */ __webpack_exports__CullingBox),
/* harmony export */   "DeactivateEvent": () => (/* binding */ __webpack_exports__DeactivateEvent),
/* harmony export */   "Debug": () => (/* binding */ __webpack_exports__Debug),
/* harmony export */   "DebugSystem": () => (/* binding */ __webpack_exports__DebugSystem),
/* harmony export */   "DebugText": () => (/* binding */ __webpack_exports__DebugText),
/* harmony export */   "DegreeOfFreedom": () => (/* binding */ __webpack_exports__DegreeOfFreedom),
/* harmony export */   "Detector": () => (/* binding */ __webpack_exports__Detector),
/* harmony export */   "Die": () => (/* binding */ __webpack_exports__Die),
/* harmony export */   "Direction": () => (/* binding */ __webpack_exports__Direction),
/* harmony export */   "DisplayMode": () => (/* binding */ __webpack_exports__DisplayMode),
/* harmony export */   "DynamicTree": () => (/* binding */ __webpack_exports__DynamicTree),
/* harmony export */   "DynamicTreeCollisionProcessor": () => (/* binding */ __webpack_exports__DynamicTreeCollisionProcessor),
/* harmony export */   "EX_VERSION": () => (/* binding */ __webpack_exports__EX_VERSION),
/* harmony export */   "EaseTo": () => (/* binding */ __webpack_exports__EaseTo),
/* harmony export */   "EasingFunctions": () => (/* binding */ __webpack_exports__EasingFunctions),
/* harmony export */   "EdgeCollider": () => (/* binding */ __webpack_exports__EdgeCollider),
/* harmony export */   "ElasticToActorStrategy": () => (/* binding */ __webpack_exports__ElasticToActorStrategy),
/* harmony export */   "EmitterType": () => (/* binding */ __webpack_exports__EmitterType),
/* harmony export */   "Engine": () => (/* binding */ __webpack_exports__Engine),
/* harmony export */   "EnterTriggerEvent": () => (/* binding */ __webpack_exports__EnterTriggerEvent),
/* harmony export */   "EnterViewPortEvent": () => (/* binding */ __webpack_exports__EnterViewPortEvent),
/* harmony export */   "Entity": () => (/* binding */ __webpack_exports__Entity),
/* harmony export */   "EntityManager": () => (/* binding */ __webpack_exports__EntityManager),
/* harmony export */   "EventDispatcher": () => (/* binding */ __webpack_exports__EventDispatcher),
/* harmony export */   "EventTypes": () => (/* binding */ __webpack_exports__EventTypes),
/* harmony export */   "Events": () => (/* binding */ __webpack_exports__Events),
/* harmony export */   "ExResponse": () => (/* binding */ __webpack_exports__ExResponse),
/* harmony export */   "ExcaliburGraphicsContext2DCanvas": () => (/* binding */ __webpack_exports__ExcaliburGraphicsContext2DCanvas),
/* harmony export */   "ExcaliburGraphicsContextWebGL": () => (/* binding */ __webpack_exports__ExcaliburGraphicsContextWebGL),
/* harmony export */   "ExitTriggerEvent": () => (/* binding */ __webpack_exports__ExitTriggerEvent),
/* harmony export */   "ExitViewPortEvent": () => (/* binding */ __webpack_exports__ExitViewPortEvent),
/* harmony export */   "Experiments": () => (/* binding */ __webpack_exports__Experiments),
/* harmony export */   "Fade": () => (/* binding */ __webpack_exports__Fade),
/* harmony export */   "Flags": () => (/* binding */ __webpack_exports__Flags),
/* harmony export */   "Follow": () => (/* binding */ __webpack_exports__Follow),
/* harmony export */   "Font": () => (/* binding */ __webpack_exports__Font),
/* harmony export */   "FontStyle": () => (/* binding */ __webpack_exports__FontStyle),
/* harmony export */   "FontUnit": () => (/* binding */ __webpack_exports__FontUnit),
/* harmony export */   "FrameStats": () => (/* binding */ __webpack_exports__FrameStats),
/* harmony export */   "GameEvent": () => (/* binding */ __webpack_exports__GameEvent),
/* harmony export */   "GameStartEvent": () => (/* binding */ __webpack_exports__GameStartEvent),
/* harmony export */   "GameStopEvent": () => (/* binding */ __webpack_exports__GameStopEvent),
/* harmony export */   "GamepadAxisEvent": () => (/* binding */ __webpack_exports__GamepadAxisEvent),
/* harmony export */   "GamepadButtonEvent": () => (/* binding */ __webpack_exports__GamepadButtonEvent),
/* harmony export */   "GamepadConnectEvent": () => (/* binding */ __webpack_exports__GamepadConnectEvent),
/* harmony export */   "GamepadDisconnectEvent": () => (/* binding */ __webpack_exports__GamepadDisconnectEvent),
/* harmony export */   "Gif": () => (/* binding */ __webpack_exports__Gif),
/* harmony export */   "GlobalCoordinates": () => (/* binding */ __webpack_exports__GlobalCoordinates),
/* harmony export */   "Graphic": () => (/* binding */ __webpack_exports__Graphic),
/* harmony export */   "GraphicsComponent": () => (/* binding */ __webpack_exports__GraphicsComponent),
/* harmony export */   "GraphicsGroup": () => (/* binding */ __webpack_exports__GraphicsGroup),
/* harmony export */   "GraphicsLayer": () => (/* binding */ __webpack_exports__GraphicsLayer),
/* harmony export */   "GraphicsLayers": () => (/* binding */ __webpack_exports__GraphicsLayers),
/* harmony export */   "GraphicsSystem": () => (/* binding */ __webpack_exports__GraphicsSystem),
/* harmony export */   "HiddenEvent": () => (/* binding */ __webpack_exports__HiddenEvent),
/* harmony export */   "ImageSource": () => (/* binding */ __webpack_exports__ImageSource),
/* harmony export */   "InitializeEvent": () => (/* binding */ __webpack_exports__InitializeEvent),
/* harmony export */   "Input": () => (/* binding */ __webpack_exports__Input),
/* harmony export */   "Integrator": () => (/* binding */ __webpack_exports__Integrator),
/* harmony export */   "KillEvent": () => (/* binding */ __webpack_exports__KillEvent),
/* harmony export */   "Label": () => (/* binding */ __webpack_exports__Label),
/* harmony export */   "Legacy": () => (/* binding */ __webpack_exports__Legacy),
/* harmony export */   "LegacyDrawing": () => (/* binding */ __webpack_exports__LegacyDrawing),
/* harmony export */   "LimitCameraBoundsStrategy": () => (/* binding */ __webpack_exports__LimitCameraBoundsStrategy),
/* harmony export */   "Line": () => (/* binding */ __webpack_exports__Line),
/* harmony export */   "Loader": () => (/* binding */ __webpack_exports__Loader),
/* harmony export */   "LockCameraToActorAxisStrategy": () => (/* binding */ __webpack_exports__LockCameraToActorAxisStrategy),
/* harmony export */   "LockCameraToActorStrategy": () => (/* binding */ __webpack_exports__LockCameraToActorStrategy),
/* harmony export */   "LogLevel": () => (/* binding */ __webpack_exports__LogLevel),
/* harmony export */   "Logger": () => (/* binding */ __webpack_exports__Logger),
/* harmony export */   "Matrix": () => (/* binding */ __webpack_exports__Matrix),
/* harmony export */   "MatrixLocations": () => (/* binding */ __webpack_exports__MatrixLocations),
/* harmony export */   "MediaEvent": () => (/* binding */ __webpack_exports__MediaEvent),
/* harmony export */   "Meet": () => (/* binding */ __webpack_exports__Meet),
/* harmony export */   "MockedElement": () => (/* binding */ __webpack_exports__MockedElement),
/* harmony export */   "MotionComponent": () => (/* binding */ __webpack_exports__MotionComponent),
/* harmony export */   "MotionSystem": () => (/* binding */ __webpack_exports__MotionSystem),
/* harmony export */   "MoveBy": () => (/* binding */ __webpack_exports__MoveBy),
/* harmony export */   "MoveTo": () => (/* binding */ __webpack_exports__MoveTo),
/* harmony export */   "NativeSoundEvent": () => (/* binding */ __webpack_exports__NativeSoundEvent),
/* harmony export */   "NativeSoundProcessedEvent": () => (/* binding */ __webpack_exports__NativeSoundProcessedEvent),
/* harmony export */   "Observable": () => (/* binding */ __webpack_exports__Observable),
/* harmony export */   "Pair": () => (/* binding */ __webpack_exports__Pair),
/* harmony export */   "ParseGif": () => (/* binding */ __webpack_exports__ParseGif),
/* harmony export */   "Particle": () => (/* binding */ __webpack_exports__Particle),
/* harmony export */   "ParticleEmitter": () => (/* binding */ __webpack_exports__ParticleEmitter),
/* harmony export */   "Physics": () => (/* binding */ __webpack_exports__Physics),
/* harmony export */   "PhysicsStats": () => (/* binding */ __webpack_exports__PhysicsStats),
/* harmony export */   "Polygon": () => (/* binding */ __webpack_exports__Polygon),
/* harmony export */   "PolygonCollider": () => (/* binding */ __webpack_exports__PolygonCollider),
/* harmony export */   "Pool": () => (/* binding */ __webpack_exports__Pool),
/* harmony export */   "PostCollisionEvent": () => (/* binding */ __webpack_exports__PostCollisionEvent),
/* harmony export */   "PostDebugDrawEvent": () => (/* binding */ __webpack_exports__PostDebugDrawEvent),
/* harmony export */   "PostDrawEvent": () => (/* binding */ __webpack_exports__PostDrawEvent),
/* harmony export */   "PostFrameEvent": () => (/* binding */ __webpack_exports__PostFrameEvent),
/* harmony export */   "PostKillEvent": () => (/* binding */ __webpack_exports__PostKillEvent),
/* harmony export */   "PostUpdateEvent": () => (/* binding */ __webpack_exports__PostUpdateEvent),
/* harmony export */   "PreCollisionEvent": () => (/* binding */ __webpack_exports__PreCollisionEvent),
/* harmony export */   "PreDebugDrawEvent": () => (/* binding */ __webpack_exports__PreDebugDrawEvent),
/* harmony export */   "PreDrawEvent": () => (/* binding */ __webpack_exports__PreDrawEvent),
/* harmony export */   "PreFrameEvent": () => (/* binding */ __webpack_exports__PreFrameEvent),
/* harmony export */   "PreKillEvent": () => (/* binding */ __webpack_exports__PreKillEvent),
/* harmony export */   "PreUpdateEvent": () => (/* binding */ __webpack_exports__PreUpdateEvent),
/* harmony export */   "Projection": () => (/* binding */ __webpack_exports__Projection),
/* harmony export */   "Promise": () => (/* binding */ __webpack_exports__Promise),
/* harmony export */   "PromiseState": () => (/* binding */ __webpack_exports__PromiseState),
/* harmony export */   "Query": () => (/* binding */ __webpack_exports__Query),
/* harmony export */   "QueryManager": () => (/* binding */ __webpack_exports__QueryManager),
/* harmony export */   "RadiusAroundActorStrategy": () => (/* binding */ __webpack_exports__RadiusAroundActorStrategy),
/* harmony export */   "Random": () => (/* binding */ __webpack_exports__Random),
/* harmony export */   "Raster": () => (/* binding */ __webpack_exports__Raster),
/* harmony export */   "Ray": () => (/* binding */ __webpack_exports__Ray),
/* harmony export */   "RealisticSolver": () => (/* binding */ __webpack_exports__RealisticSolver),
/* harmony export */   "Rectangle": () => (/* binding */ __webpack_exports__Rectangle),
/* harmony export */   "RemovedComponent": () => (/* binding */ __webpack_exports__RemovedComponent),
/* harmony export */   "RemovedEntity": () => (/* binding */ __webpack_exports__RemovedEntity),
/* harmony export */   "Repeat": () => (/* binding */ __webpack_exports__Repeat),
/* harmony export */   "RepeatForever": () => (/* binding */ __webpack_exports__RepeatForever),
/* harmony export */   "Resolution": () => (/* binding */ __webpack_exports__Resolution),
/* harmony export */   "Resource": () => (/* binding */ __webpack_exports__Resource),
/* harmony export */   "RotateBy": () => (/* binding */ __webpack_exports__RotateBy),
/* harmony export */   "RotateTo": () => (/* binding */ __webpack_exports__RotateTo),
/* harmony export */   "RotationType": () => (/* binding */ __webpack_exports__RotationType),
/* harmony export */   "ScaleBy": () => (/* binding */ __webpack_exports__ScaleBy),
/* harmony export */   "ScaleTo": () => (/* binding */ __webpack_exports__ScaleTo),
/* harmony export */   "Scene": () => (/* binding */ __webpack_exports__Scene),
/* harmony export */   "Screen": () => (/* binding */ __webpack_exports__Screen),
/* harmony export */   "ScreenAppender": () => (/* binding */ __webpack_exports__ScreenAppender),
/* harmony export */   "ScreenElement": () => (/* binding */ __webpack_exports__ScreenElement),
/* harmony export */   "ScrollPreventionMode": () => (/* binding */ __webpack_exports__ScrollPreventionMode),
/* harmony export */   "Shape": () => (/* binding */ __webpack_exports__Shape),
/* harmony export */   "Side": () => (/* binding */ __webpack_exports__Side),
/* harmony export */   "SortedList": () => (/* binding */ __webpack_exports__SortedList),
/* harmony export */   "Sound": () => (/* binding */ __webpack_exports__Sound),
/* harmony export */   "Sprite": () => (/* binding */ __webpack_exports__Sprite),
/* harmony export */   "SpriteFont": () => (/* binding */ __webpack_exports__SpriteFont),
/* harmony export */   "SpriteSheet": () => (/* binding */ __webpack_exports__SpriteSheet),
/* harmony export */   "StrategyContainer": () => (/* binding */ __webpack_exports__StrategyContainer),
/* harmony export */   "Stream": () => (/* binding */ __webpack_exports__Stream),
/* harmony export */   "SubscribeEvent": () => (/* binding */ __webpack_exports__SubscribeEvent),
/* harmony export */   "System": () => (/* binding */ __webpack_exports__System),
/* harmony export */   "SystemManager": () => (/* binding */ __webpack_exports__SystemManager),
/* harmony export */   "SystemType": () => (/* binding */ __webpack_exports__SystemType),
/* harmony export */   "TagComponent": () => (/* binding */ __webpack_exports__TagComponent),
/* harmony export */   "Text": () => (/* binding */ __webpack_exports__Text),
/* harmony export */   "TextAlign": () => (/* binding */ __webpack_exports__TextAlign),
/* harmony export */   "TileMap": () => (/* binding */ __webpack_exports__TileMap),
/* harmony export */   "Timer": () => (/* binding */ __webpack_exports__Timer),
/* harmony export */   "Traits": () => (/* binding */ __webpack_exports__Traits),
/* harmony export */   "TransformComponent": () => (/* binding */ __webpack_exports__TransformComponent),
/* harmony export */   "TreeNode": () => (/* binding */ __webpack_exports__TreeNode),
/* harmony export */   "Trigger": () => (/* binding */ __webpack_exports__Trigger),
/* harmony export */   "UnsubscribeEvent": () => (/* binding */ __webpack_exports__UnsubscribeEvent),
/* harmony export */   "Util": () => (/* binding */ __webpack_exports__Util),
/* harmony export */   "Vector": () => (/* binding */ __webpack_exports__Vector),
/* harmony export */   "VectorView": () => (/* binding */ __webpack_exports__VectorView),
/* harmony export */   "VisibleEvent": () => (/* binding */ __webpack_exports__VisibleEvent),
/* harmony export */   "WebAudioInstance": () => (/* binding */ __webpack_exports__WebAudioInstance),
/* harmony export */   "World": () => (/* binding */ __webpack_exports__World),
/* harmony export */   "canonicalizeAngle": () => (/* binding */ __webpack_exports__canonicalizeAngle),
/* harmony export */   "clamp": () => (/* binding */ __webpack_exports__clamp),
/* harmony export */   "createId": () => (/* binding */ __webpack_exports__createId),
/* harmony export */   "hasGraphicsTick": () => (/* binding */ __webpack_exports__hasGraphicsTick),
/* harmony export */   "hasOnInitialize": () => (/* binding */ __webpack_exports__hasOnInitialize),
/* harmony export */   "hasOnPostUpdate": () => (/* binding */ __webpack_exports__hasOnPostUpdate),
/* harmony export */   "hasOnPreUpdate": () => (/* binding */ __webpack_exports__hasOnPreUpdate),
/* harmony export */   "hasPostDraw": () => (/* binding */ __webpack_exports__hasPostDraw),
/* harmony export */   "hasPreDraw": () => (/* binding */ __webpack_exports__hasPreDraw),
/* harmony export */   "has_initialize": () => (/* binding */ __webpack_exports__has_initialize),
/* harmony export */   "has_postupdate": () => (/* binding */ __webpack_exports__has_postupdate),
/* harmony export */   "has_preupdate": () => (/* binding */ __webpack_exports__has_preupdate),
/* harmony export */   "isAddedComponent": () => (/* binding */ __webpack_exports__isAddedComponent),
/* harmony export */   "isAddedSystemEntity": () => (/* binding */ __webpack_exports__isAddedSystemEntity),
/* harmony export */   "isRemoveSystemEntity": () => (/* binding */ __webpack_exports__isRemoveSystemEntity),
/* harmony export */   "isRemovedComponent": () => (/* binding */ __webpack_exports__isRemovedComponent),
/* harmony export */   "maxMessages": () => (/* binding */ __webpack_exports__maxMessages),
/* harmony export */   "obsolete": () => (/* binding */ __webpack_exports__obsolete),
/* harmony export */   "randomInRange": () => (/* binding */ __webpack_exports__randomInRange),
/* harmony export */   "randomIntInRange": () => (/* binding */ __webpack_exports__randomIntInRange),
/* harmony export */   "range": () => (/* binding */ __webpack_exports__range),
/* harmony export */   "resetObsoleteCounter": () => (/* binding */ __webpack_exports__resetObsoleteCounter),
/* harmony export */   "toDegrees": () => (/* binding */ __webpack_exports__toDegrees),
/* harmony export */   "toRadians": () => (/* binding */ __webpack_exports__toRadians),
/* harmony export */   "vec": () => (/* binding */ __webpack_exports__vec)
/* harmony export */ });
/*!
 * excalibur - 0.25.1 - 2021-11-5
 * https://github.com/excaliburjs/Excalibur
 * Copyright (c) 2021 Excalibur.js <https://github.com/excaliburjs/Excalibur/graphs/contributors>
 * Licensed BSD-2-Clause
 * @preserve
 */
/******/ var __webpack_modules__ = ({

/***/ 4662:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_315__) => {

__nested_webpack_require_315__(3430);
var entryUnbind = __nested_webpack_require_315__(8791);

module.exports = entryUnbind('Array', 'sort');


/***/ }),

/***/ 8343:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_529__) => {

__nested_webpack_require_529__(4769);
var path = __nested_webpack_require_529__(9276);

module.exports = path.Object.keys;


/***/ }),

/***/ 7111:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_724__) => {

var isCallable = __nested_webpack_require_724__(6733);
var tryToString = __nested_webpack_require_724__(9821);

// `Assert: IsCallable(argument) is true`
module.exports = function (argument) {
  if (isCallable(argument)) return argument;
  throw TypeError(tryToString(argument) + ' is not a function');
};


/***/ }),

/***/ 1176:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1102__) => {

var isObject = __nested_webpack_require_1102__(5052);

// `Assert: Type(argument) is Object`
module.exports = function (argument) {
  if (isObject(argument)) return argument;
  throw TypeError(String(argument) + ' is not an object');
};


/***/ }),

/***/ 9540:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_1421__) => {

var toIndexedObject = __nested_webpack_require_1421__(905);
var toLength = __nested_webpack_require_1421__(4237);
var toAbsoluteIndex = __nested_webpack_require_1421__(3231);

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare -- NaN check
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare -- NaN check
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.es/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.es/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ 6038:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_2769__) => {


var fails = __nested_webpack_require_2769__(4229);

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal -- required for testing
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ 3867:
/***/ ((module) => {

// TODO: use something more complex like timsort?
var floor = Math.floor;

var mergeSort = function (array, comparefn) {
  var length = array.length;
  var middle = floor(length / 2);
  return length < 8 ? insertionSort(array, comparefn) : merge(
    mergeSort(array.slice(0, middle), comparefn),
    mergeSort(array.slice(middle), comparefn),
    comparefn
  );
};

var insertionSort = function (array, comparefn) {
  var length = array.length;
  var i = 1;
  var element, j;

  while (i < length) {
    j = i;
    element = array[i];
    while (j && comparefn(array[j - 1], element) > 0) {
      array[j] = array[--j];
    }
    if (j !== i++) array[j] = element;
  } return array;
};

var merge = function (left, right, comparefn) {
  var llength = left.length;
  var rlength = right.length;
  var lindex = 0;
  var rindex = 0;
  var result = [];

  while (lindex < llength || rindex < rlength) {
    if (lindex < llength && rindex < rlength) {
      result.push(comparefn(left[lindex], right[rindex]) <= 0 ? left[lindex++] : right[rindex++]);
    } else {
      result.push(lindex < llength ? left[lindex++] : right[rindex++]);
    }
  } return result;
};

module.exports = mergeSort;


/***/ }),

/***/ 7079:
/***/ ((module) => {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ 1589:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_4580__) => {

var TO_STRING_TAG_SUPPORT = __nested_webpack_require_4580__(1601);
var isCallable = __nested_webpack_require_4580__(6733);
var classofRaw = __nested_webpack_require_4580__(7079);
var wellKnownSymbol = __nested_webpack_require_4580__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && isCallable(O.callee) ? 'Arguments' : result;
};


/***/ }),

/***/ 7081:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_5670__) => {

var has = __nested_webpack_require_5670__(816);
var ownKeys = __nested_webpack_require_5670__(4826);
var getOwnPropertyDescriptorModule = __nested_webpack_require_5670__(7933);
var definePropertyModule = __nested_webpack_require_5670__(1787);

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ 5762:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_6316__) => {

var DESCRIPTORS = __nested_webpack_require_6316__(7400);
var definePropertyModule = __nested_webpack_require_6316__(1787);
var createPropertyDescriptor = __nested_webpack_require_6316__(5358);

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ 5358:
/***/ ((module) => {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ 7400:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_7012__) => {

var fails = __nested_webpack_require_7012__(4229);

// Detect IE8's incomplete defineProperty implementation
module.exports = !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- required for testing
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ 2635:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_7410__) => {

var global = __nested_webpack_require_7410__(9859);
var isObject = __nested_webpack_require_7410__(5052);

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ 2671:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_7831__) => {

var userAgent = __nested_webpack_require_7831__(598);

var firefox = userAgent.match(/firefox\/(\d+)/i);

module.exports = !!firefox && +firefox[1];


/***/ }),

/***/ 8506:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_8062__) => {

var UA = __nested_webpack_require_8062__(598);

module.exports = /MSIE|Trident/.test(UA);


/***/ }),

/***/ 598:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_8233__) => {

var getBuiltIn = __nested_webpack_require_8233__(1333);

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ 6358:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_8433__) => {

var global = __nested_webpack_require_8433__(9859);
var userAgent = __nested_webpack_require_8433__(598);

var process = global.process;
var Deno = global.Deno;
var versions = process && process.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] < 4 ? 1 : match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ 9811:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_9100__) => {

var userAgent = __nested_webpack_require_9100__(598);

var webkit = userAgent.match(/AppleWebKit\/(\d+)\./);

module.exports = !!webkit && +webkit[1];


/***/ }),

/***/ 8791:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_9333__) => {

var global = __nested_webpack_require_9333__(9859);
var bind = __nested_webpack_require_9333__(7636);

var call = Function.call;

module.exports = function (CONSTRUCTOR, METHOD, length) {
  return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);
};


/***/ }),

/***/ 3837:
/***/ ((module) => {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ 3103:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_9887__) => {

var global = __nested_webpack_require_9887__(9859);
var getOwnPropertyDescriptor = __nested_webpack_require_9887__(7933).f;
var createNonEnumerableProperty = __nested_webpack_require_9887__(5762);
var redefine = __nested_webpack_require_9887__(7487);
var setGlobal = __nested_webpack_require_9887__(2079);
var copyConstructorProperties = __nested_webpack_require_9887__(7081);
var isForced = __nested_webpack_require_9887__(6541);

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
  options.name        - the .name of the function if it does not match the key
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ 4229:
/***/ ((module) => {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ 7636:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_12617__) => {

var aCallable = __nested_webpack_require_12617__(7111);

// optional / simple context binding
module.exports = function (fn, that, length) {
  aCallable(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ 1805:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_13301__) => {

var DESCRIPTORS = __nested_webpack_require_13301__(7400);
var has = __nested_webpack_require_13301__(816);

var FunctionPrototype = Function.prototype;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;

var EXISTS = has(FunctionPrototype, 'name');
// additional protection from minified / mangled / dropped function names
var PROPER = EXISTS && (function something() { /* empty */ }).name === 'something';
var CONFIGURABLE = EXISTS && (!DESCRIPTORS || (DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable));

module.exports = {
  EXISTS: EXISTS,
  PROPER: PROPER,
  CONFIGURABLE: CONFIGURABLE
};


/***/ }),

/***/ 1333:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_14074__) => {

var global = __nested_webpack_require_14074__(9859);
var isCallable = __nested_webpack_require_14074__(6733);

var aFunction = function (argument) {
  return isCallable(argument) ? argument : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];
};


/***/ }),

/***/ 5300:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_14511__) => {

var aCallable = __nested_webpack_require_14511__(7111);

// `GetMethod` abstract operation
// https://tc39.es/ecma262/#sec-getmethod
module.exports = function (V, P) {
  var func = V[P];
  return func == null ? undefined : aCallable(func);
};


/***/ }),

/***/ 9859:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_14835__) => {

var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line es/no-global-this -- safe
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  // eslint-disable-next-line no-restricted-globals -- safe
  check(typeof self == 'object' && self) ||
  check(typeof __nested_webpack_require_14835__.g == 'object' && __nested_webpack_require_14835__.g) ||
  // eslint-disable-next-line no-new-func -- fallback
  (function () { return this; })() || Function('return this')();


/***/ }),

/***/ 816:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_15548__) => {

var toObject = __nested_webpack_require_15548__(2991);

var hasOwnProperty = {}.hasOwnProperty;

module.exports = Object.hasOwn || function hasOwn(it, key) {
  return hasOwnProperty.call(toObject(it), key);
};


/***/ }),

/***/ 5977:
/***/ ((module) => {

module.exports = {};


/***/ }),

/***/ 4394:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_15907__) => {

var DESCRIPTORS = __nested_webpack_require_15907__(7400);
var fails = __nested_webpack_require_15907__(4229);
var createElement = __nested_webpack_require_15907__(2635);

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  // eslint-disable-next-line es/no-object-defineproperty -- requied for testing
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ 9337:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_16424__) => {

var fails = __nested_webpack_require_16424__(4229);
var classof = __nested_webpack_require_16424__(7079);

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins -- safe
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ 8511:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_17015__) => {

var isCallable = __nested_webpack_require_17015__(6733);
var store = __nested_webpack_require_17015__(5353);

var functionToString = Function.toString;

// this helper broken in `core-js@3.4.1-3.4.4`, so we can't use `shared` helper
if (!isCallable(store.inspectSource)) {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ 6407:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_17480__) => {

var NATIVE_WEAK_MAP = __nested_webpack_require_17480__(8694);
var global = __nested_webpack_require_17480__(9859);
var isObject = __nested_webpack_require_17480__(5052);
var createNonEnumerableProperty = __nested_webpack_require_17480__(5762);
var objectHas = __nested_webpack_require_17480__(816);
var shared = __nested_webpack_require_17480__(5353);
var sharedKey = __nested_webpack_require_17480__(4399);
var hiddenKeys = __nested_webpack_require_17480__(5977);

var OBJECT_ALREADY_INITIALIZED = 'Object already initialized';
var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    if (wmhas.call(store, it)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    if (objectHas(it, STATE)) throw new TypeError(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ 6733:
/***/ ((module) => {

// `IsCallable` abstract operation
// https://tc39.es/ecma262/#sec-iscallable
module.exports = function (argument) {
  return typeof argument === 'function';
};


/***/ }),

/***/ 6541:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_19613__) => {

var fails = __nested_webpack_require_19613__(4229);
var isCallable = __nested_webpack_require_19613__(6733);

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : isCallable(detection) ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ 5052:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_20311__) => {

var isCallable = __nested_webpack_require_20311__(6733);

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : isCallable(it);
};


/***/ }),

/***/ 4231:
/***/ ((module) => {

module.exports = false;


/***/ }),

/***/ 9395:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_20621__) => {

var isCallable = __nested_webpack_require_20621__(6733);
var getBuiltIn = __nested_webpack_require_20621__(1333);
var USE_SYMBOL_AS_UID = __nested_webpack_require_20621__(6969);

module.exports = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  var $Symbol = getBuiltIn('Symbol');
  return isCallable($Symbol) && Object(it) instanceof $Symbol;
};


/***/ }),

/***/ 3839:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_21064__) => {

/* eslint-disable es/no-symbol -- required for testing */
var V8_VERSION = __nested_webpack_require_21064__(6358);
var fails = __nested_webpack_require_21064__(4229);

// eslint-disable-next-line es/no-object-getownpropertysymbols -- required for testing
module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  var symbol = Symbol();
  // Chrome 38 Symbol has incorrect toString conversion
  // `get-own-property-symbols` polyfill symbols converted to object are not Symbol instances
  return !String(symbol) || !(Object(symbol) instanceof Symbol) ||
    // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});


/***/ }),

/***/ 8694:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_21847__) => {

var global = __nested_webpack_require_21847__(9859);
var isCallable = __nested_webpack_require_21847__(6733);
var inspectSource = __nested_webpack_require_21847__(8511);

var WeakMap = global.WeakMap;

module.exports = isCallable(WeakMap) && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ 1787:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_22188__) => {

var DESCRIPTORS = __nested_webpack_require_22188__(7400);
var IE8_DOM_DEFINE = __nested_webpack_require_22188__(4394);
var anObject = __nested_webpack_require_22188__(1176);
var toPropertyKey = __nested_webpack_require_22188__(9310);

// eslint-disable-next-line es/no-object-defineproperty -- safe
var $defineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.es/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? $defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPropertyKey(P);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return $defineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ 7933:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_23085__) => {

var DESCRIPTORS = __nested_webpack_require_23085__(7400);
var propertyIsEnumerableModule = __nested_webpack_require_23085__(9195);
var createPropertyDescriptor = __nested_webpack_require_23085__(5358);
var toIndexedObject = __nested_webpack_require_23085__(905);
var toPropertyKey = __nested_webpack_require_23085__(9310);
var has = __nested_webpack_require_23085__(816);
var IE8_DOM_DEFINE = __nested_webpack_require_23085__(4394);

// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.es/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPropertyKey(P);
  if (IE8_DOM_DEFINE) try {
    return $getOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ 8151:
/***/ ((__unused_webpack_module, exports, __nested_webpack_require_24123__) => {

var internalObjectKeys = __nested_webpack_require_24123__(140);
var enumBugKeys = __nested_webpack_require_24123__(3837);

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.es/ecma262/#sec-object.getownpropertynames
// eslint-disable-next-line es/no-object-getownpropertynames -- safe
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ 894:
/***/ ((__unused_webpack_module, exports) => {

// eslint-disable-next-line es/no-object-getownpropertysymbols -- safe
exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ 140:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_24849__) => {

var has = __nested_webpack_require_24849__(816);
var toIndexedObject = __nested_webpack_require_24849__(905);
var indexOf = __nested_webpack_require_24849__(9540).indexOf;
var hiddenKeys = __nested_webpack_require_24849__(5977);

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ 5632:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_25482__) => {

var internalObjectKeys = __nested_webpack_require_25482__(140);
var enumBugKeys = __nested_webpack_require_25482__(3837);

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
// eslint-disable-next-line es/no-object-keys -- safe
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ 9195:
/***/ ((__unused_webpack_module, exports) => {


var $propertyIsEnumerable = {}.propertyIsEnumerable;
// eslint-disable-next-line es/no-object-getownpropertydescriptor -- safe
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.es/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable;


/***/ }),

/***/ 2914:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_26596__) => {

var isCallable = __nested_webpack_require_26596__(6733);
var isObject = __nested_webpack_require_26596__(5052);

// `OrdinaryToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-ordinarytoprimitive
module.exports = function (input, pref) {
  var fn, val;
  if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;
  if (isCallable(fn = input.valueOf) && !isObject(val = fn.call(input))) return val;
  if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ 4826:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_27294__) => {

var getBuiltIn = __nested_webpack_require_27294__(1333);
var getOwnPropertyNamesModule = __nested_webpack_require_27294__(8151);
var getOwnPropertySymbolsModule = __nested_webpack_require_27294__(894);
var anObject = __nested_webpack_require_27294__(1176);

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ 9276:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_27926__) => {

var global = __nested_webpack_require_27926__(9859);

module.exports = global;


/***/ }),

/***/ 7487:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_28086__) => {

var global = __nested_webpack_require_28086__(9859);
var isCallable = __nested_webpack_require_28086__(6733);
var has = __nested_webpack_require_28086__(816);
var createNonEnumerableProperty = __nested_webpack_require_28086__(5762);
var setGlobal = __nested_webpack_require_28086__(2079);
var inspectSource = __nested_webpack_require_28086__(8511);
var InternalStateModule = __nested_webpack_require_28086__(6407);
var CONFIGURABLE_FUNCTION_NAME = __nested_webpack_require_28086__(1805).CONFIGURABLE;

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  var name = options && options.name !== undefined ? options.name : key;
  var state;
  if (isCallable(value)) {
    if (String(name).slice(0, 7) === 'Symbol(') {
      name = '[' + String(name).replace(/^Symbol\(([^)]*)\)/, '$1') + ']';
    }
    if (!has(value, 'name') || (CONFIGURABLE_FUNCTION_NAME && value.name !== name)) {
      createNonEnumerableProperty(value, 'name', name);
    }
    state = enforceInternalState(value);
    if (!state.source) {
      state.source = TEMPLATE.join(typeof name == 'string' ? name : '');
    }
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return isCallable(this) && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ 8885:
/***/ ((module) => {

// `RequireObjectCoercible` abstract operation
// https://tc39.es/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ 2079:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_30300__) => {

var global = __nested_webpack_require_30300__(9859);

module.exports = function (key, value) {
  try {
    // eslint-disable-next-line es/no-object-defineproperty -- safe
    Object.defineProperty(global, key, { value: value, configurable: true, writable: true });
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ 4399:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_30712__) => {

var shared = __nested_webpack_require_30712__(3036);
var uid = __nested_webpack_require_30712__(1441);

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ 5353:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_30995__) => {

var global = __nested_webpack_require_30995__(9859);
var setGlobal = __nested_webpack_require_30995__(2079);

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ 3036:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_31286__) => {

var IS_PURE = __nested_webpack_require_31286__(4231);
var store = __nested_webpack_require_31286__(5353);

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.18.1',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: ' 2021 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ 3231:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_31715__) => {

var toInteger = __nested_webpack_require_31715__(6051);

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ 905:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_32238__) => {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __nested_webpack_require_32238__(9337);
var requireObjectCoercible = __nested_webpack_require_32238__(8885);

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ 6051:
/***/ ((module) => {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.es/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ 4237:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_32877__) => {

var toInteger = __nested_webpack_require_32877__(6051);

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.es/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ 2991:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_33259__) => {

var requireObjectCoercible = __nested_webpack_require_33259__(8885);

// `ToObject` abstract operation
// https://tc39.es/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ 2066:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_33577__) => {

var isObject = __nested_webpack_require_33577__(5052);
var isSymbol = __nested_webpack_require_33577__(9395);
var getMethod = __nested_webpack_require_33577__(5300);
var ordinaryToPrimitive = __nested_webpack_require_33577__(2914);
var wellKnownSymbol = __nested_webpack_require_33577__(95);

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');

// `ToPrimitive` abstract operation
// https://tc39.es/ecma262/#sec-toprimitive
module.exports = function (input, pref) {
  if (!isObject(input) || isSymbol(input)) return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === undefined) pref = 'default';
    result = exoticToPrim.call(input, pref);
    if (!isObject(result) || isSymbol(result)) return result;
    throw TypeError("Can't convert object to primitive value");
  }
  if (pref === undefined) pref = 'number';
  return ordinaryToPrimitive(input, pref);
};


/***/ }),

/***/ 9310:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_34529__) => {

var toPrimitive = __nested_webpack_require_34529__(2066);
var isSymbol = __nested_webpack_require_34529__(9395);

// `ToPropertyKey` abstract operation
// https://tc39.es/ecma262/#sec-topropertykey
module.exports = function (argument) {
  var key = toPrimitive(argument, 'string');
  return isSymbol(key) ? key : String(key);
};


/***/ }),

/***/ 1601:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_34926__) => {

var wellKnownSymbol = __nested_webpack_require_34926__(95);

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ 3326:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_35212__) => {

var classof = __nested_webpack_require_35212__(1589);

module.exports = function (argument) {
  if (classof(argument) === 'Symbol') throw TypeError('Cannot convert a Symbol value to a string');
  return String(argument);
};


/***/ }),

/***/ 9821:
/***/ ((module) => {

module.exports = function (argument) {
  try {
    return String(argument);
  } catch (error) {
    return 'Object';
  }
};


/***/ }),

/***/ 1441:
/***/ ((module) => {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ 6969:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_35912__) => {

/* eslint-disable es/no-symbol -- required for testing */
var NATIVE_SYMBOL = __nested_webpack_require_35912__(3839);

module.exports = NATIVE_SYMBOL
  && !Symbol.sham
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ 95:
/***/ ((module, __unused_webpack_exports, __nested_webpack_require_36200__) => {

var global = __nested_webpack_require_36200__(9859);
var shared = __nested_webpack_require_36200__(3036);
var has = __nested_webpack_require_36200__(816);
var uid = __nested_webpack_require_36200__(1441);
var NATIVE_SYMBOL = __nested_webpack_require_36200__(3839);
var USE_SYMBOL_AS_UID = __nested_webpack_require_36200__(6969);

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == 'string')) {
    if (NATIVE_SYMBOL && has(Symbol, name)) {
      WellKnownSymbolsStore[name] = Symbol[name];
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ 3430:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_37114__) => {


var $ = __nested_webpack_require_37114__(3103);
var aCallable = __nested_webpack_require_37114__(7111);
var toObject = __nested_webpack_require_37114__(2991);
var toLength = __nested_webpack_require_37114__(4237);
var toString = __nested_webpack_require_37114__(3326);
var fails = __nested_webpack_require_37114__(4229);
var internalSort = __nested_webpack_require_37114__(3867);
var arrayMethodIsStrict = __nested_webpack_require_37114__(6038);
var FF = __nested_webpack_require_37114__(2671);
var IE_OR_EDGE = __nested_webpack_require_37114__(8506);
var V8 = __nested_webpack_require_37114__(6358);
var WEBKIT = __nested_webpack_require_37114__(9811);

var test = [];
var nativeSort = test.sort;

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var STRICT_METHOD = arrayMethodIsStrict('sort');

var STABLE_SORT = !fails(function () {
  // feature detection can be too slow, so check engines versions
  if (V8) return V8 < 70;
  if (FF && FF > 3) return;
  if (IE_OR_EDGE) return true;
  if (WEBKIT) return WEBKIT < 603;

  var result = '';
  var code, chr, value, index;

  // generate an array with more 512 elements (Chakra and old V8 fails only in this case)
  for (code = 65; code < 76; code++) {
    chr = String.fromCharCode(code);

    switch (code) {
      case 66: case 69: case 70: case 72: value = 3; break;
      case 68: case 71: value = 4; break;
      default: value = 2;
    }

    for (index = 0; index < 47; index++) {
      test.push({ k: chr + index, v: value });
    }
  }

  test.sort(function (a, b) { return b.v - a.v; });

  for (index = 0; index < test.length; index++) {
    chr = test[index].k.charAt(0);
    if (result.charAt(result.length - 1) !== chr) result += chr;
  }

  return result !== 'DGBEFHACIJK';
});

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || !STRICT_METHOD || !STABLE_SORT;

var getSortCompare = function (comparefn) {
  return function (x, y) {
    if (y === undefined) return -1;
    if (x === undefined) return 1;
    if (comparefn !== undefined) return +comparefn(x, y) || 0;
    return toString(x) > toString(y) ? 1 : -1;
  };
};

// `Array.prototype.sort` method
// https://tc39.es/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    if (comparefn !== undefined) aCallable(comparefn);

    var array = toObject(this);

    if (STABLE_SORT) return comparefn === undefined ? nativeSort.call(array) : nativeSort.call(array, comparefn);

    var items = [];
    var arrayLength = toLength(array.length);
    var itemsLength, index;

    for (index = 0; index < arrayLength; index++) {
      if (index in array) items.push(array[index]);
    }

    items = internalSort(items, getSortCompare(comparefn));
    itemsLength = items.length;
    index = 0;

    while (index < itemsLength) array[index] = items[index++];
    while (index < arrayLength) delete array[index++];

    return array;
  }
});


/***/ }),

/***/ 4769:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __nested_webpack_require_40120__) => {

var $ = __nested_webpack_require_40120__(3103);
var toObject = __nested_webpack_require_40120__(2991);
var nativeKeys = __nested_webpack_require_40120__(5632);
var fails = __nested_webpack_require_40120__(4229);

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.es/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ 1388:
/***/ ((module, __webpack_exports__, __nested_webpack_require_40644__) => {

/* harmony export */ __nested_webpack_require_40644__.d(__webpack_exports__, {
/* harmony export */   "Z": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_40644__(272);
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_40644__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_40644__(2609);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_40644__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition: background 250ms ease-in-out, transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n", "",{"version":3,"sources":["webpack://./Loader.css"],"names":[],"mappings":"AAAA,yBAAyB;;AAEzB;EACE,qBAAqB;EACrB,kBAAkB;EAClB,YAAY;EACZ,kBAAkB;EAClB,YAAY;EACZ;;+BAE6B;EAC7B,8BAA8B;EAC9B,SAAS;EACT,qBAAqB;EACrB,mBAAmB;EACnB,cAAc;EACd,uBAAuB;EACvB,eAAe;EACf,mBAAmB;EACnB,cAAc;EACd,eAAe;EACf,kBAAkB;EAClB,8DAA8D;EAC9D,wBAAwB;EACxB,qBAAqB;;EAErB,gDAAgD,EAAE,oCAAoC;EACtF,6CAA6C,EAAE,iBAAiB;EAChE,4CAA4C,EAAE,sBAAsB;EACpE,2CAA2C,EAAE,iBAAiB;EAC9D,wCAAwC;AAC1C;;AAEA;;;EAGE;;AAEF;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,uDAAuD;EACvD,UAAU;EACV,SAAS;EACT,QAAQ;EACR,SAAS;AACX;;AAEA;EACE,kBAAkB;EAClB,WAAW;EACX,iBAAiB;EACjB,UAAU;EACV,SAAS;EACT,mBAAmB;EACnB,WAAW;EACX,YAAY;AACd;;AAEA;;EAEE,mBAAmB;AACrB;;AAEA;EACE,uBAAuB;EACvB,oBAAoB;AACtB;;AAEA;EACE,sBAAsB;AACxB;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,oCAAoC;AACpC;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,sBAAsB;AACtB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA,iBAAiB;AACjB;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF","sourcesContent":["/* Buttons styles start */\r\n\r\nbutton#excalibur-play {\r\n  display: inline-block;\r\n  position: relative;\r\n  z-index: 999;\r\n  border-radius: 6px;\r\n  border: none;\r\n  /*border: 3px solid;\r\n    border-color: white;\r\n    box-shadow: 0 0 10px #ccc;*/\r\n  padding: 1rem 1.5rem 1rem 4rem;\r\n  margin: 0;\r\n  text-decoration: none;\r\n  background: #00b233;\r\n  color: #ffffff;\r\n  font-family: sans-serif;\r\n  font-size: 2rem;\r\n  white-space: nowrap;\r\n  line-height: 1;\r\n  cursor: pointer;\r\n  text-align: center;\r\n  transition: background 250ms ease-in-out, transform 150ms ease;\r\n  -webkit-appearance: none;\r\n  -moz-appearance: none;\r\n\r\n  -webkit-animation: excalibur-button-fadein 200ms; /* Safari, Chrome and Opera > 12.1 */\r\n  -moz-animation: excalibur-button-fadein 200ms; /* Firefox < 16 */\r\n  -ms-animation: excalibur-button-fadein 200ms; /* Internet Explorer */\r\n  -o-animation: excalibur-button-fadein 200ms; /* Opera < 12.1 */\r\n  animation: excalibur-button-fadein 200ms;\r\n}\r\n\r\n/*\r\nbutton#excalibur-play {\r\n  display: none;\r\n}*/\r\n\r\nbutton#excalibur-play:after {\r\n  position: absolute;\r\n  content: '';\r\n  border: 8px solid;\r\n  border-color: transparent transparent transparent white;\r\n  left: 35px;\r\n  top: 24px;\r\n  width: 0;\r\n  height: 0;\r\n}\r\n\r\nbutton#excalibur-play:before {\r\n  position: absolute;\r\n  content: '';\r\n  border: 3px solid;\r\n  left: 19px;\r\n  top: 14px;\r\n  border-radius: 20px;\r\n  width: 30px;\r\n  height: 30px;\r\n}\r\n\r\nbutton#excalibur-play:hover,\r\nbutton#excalibur-play:focus {\r\n  background: #00982c;\r\n}\r\n\r\nbutton#excalibur-play:focus {\r\n  outline: 1px solid #fff;\r\n  outline-offset: -4px;\r\n}\r\n\r\nbutton#excalibur-play:active {\r\n  transform: scale(0.99);\r\n}\r\n\r\n@keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Firefox < 16 */\r\n@-moz-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Safari, Chrome and Opera > 12.1 */\r\n@-webkit-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Internet Explorer */\r\n@-ms-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n\r\n/* Opera < 12.1 */\r\n@-o-keyframes excalibur-button-fadein {\r\n  from {\r\n    opacity: 0;\r\n  }\r\n  to {\r\n    opacity: 1;\r\n  }\r\n}\r\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ 2609:
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = []; // return the list of modules as css string

  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";

      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }

      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }

      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }

      content += cssWithMappingToString(item);

      if (needLayer) {
        content += "}";
      }

      if (item[2]) {
        content += "}";
      }

      if (item[4]) {
        content += "}";
      }

      return content;
    }).join("");
  }; // import a list of modules into the list


  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }

    var alreadyImportedModules = {};

    if (dedupe) {
      for (var _i = 0; _i < this.length; _i++) {
        var id = this[_i][0];

        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }

    for (var _i2 = 0; _i2 < modules.length; _i2++) {
      var item = [].concat(modules[_i2]);

      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }

      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }

      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }

      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }

      list.push(item);
    }
  };

  return list;
};

/***/ }),

/***/ 272:
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];

  if (!cssMapping) {
    return content;
  }

  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    var sourceURLs = cssMapping.sources.map(function (source) {
      return "/*# sourceURL=".concat(cssMapping.sourceRoot || "").concat(source, " */");
    });
    return [content].concat(sourceURLs).concat([sourceMapping]).join("\n");
  }

  return [content].join("\n");
};

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __nested_webpack_require_51441__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_51441__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/ (() => {
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_51441__.n = (module) => {
/******/ 		var getter = module && module.__esModule ?
/******/ 			() => (module['default']) :
/******/ 			() => (module);
/******/ 		__nested_webpack_require_51441__.d(getter, { a: getter });
/******/ 		return getter;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__nested_webpack_require_51441__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__nested_webpack_require_51441__.o(definition, key) && !__nested_webpack_require_51441__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/global */
/******/ (() => {
/******/ 	__nested_webpack_require_51441__.g = (function() {
/******/ 		if (typeof globalThis === 'object') return globalThis;
/******/ 		try {
/******/ 			return this || new Function('return this')();
/******/ 		} catch (e) {
/******/ 			if (typeof window === 'object') return window;
/******/ 		}
/******/ 	})();
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__nested_webpack_require_51441__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_51441__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {

// EXPORTS
__nested_webpack_require_51441__.d(__webpack_exports__, {
  "fWn": () => (/* reexport */ ActionContext),
  "Ia8": () => (/* reexport */ ActionQueue),
  "hLI": () => (/* reexport */ ActionsComponent),
  "yyv": () => (/* reexport */ ActionsSystem),
  "tX5": () => (/* reexport */ ActivateEvent),
  "vtX": () => (/* reexport */ Actor),
  "r7K": () => (/* reexport */ AddedComponent),
  "lCh": () => (/* reexport */ AddedEntity),
  "fwF": () => (/* reexport */ Animation),
  "sce": () => (/* reexport */ AnimationDirection),
  "_c7": () => (/* reexport */ AnimationStrategy),
  "KUs": () => (/* reexport */ ArcadeSolver),
  "Ajp": () => (/* reexport */ AudioContextFactory),
  "RDh": () => (/* reexport */ Axis),
  "_H9": () => (/* reexport */ BaseAlign),
  "Ulf": () => (/* reexport */ BinaryTreeNode),
  "mxs": () => (/* reexport */ Blink),
  "OmD": () => (/* reexport */ BodyComponent),
  "kBf": () => (/* reexport */ BoundingBox),
  "C4F": () => (/* reexport */ BroadphaseStrategy),
  "NQt": () => (/* reexport */ BrowserComponent),
  "JjN": () => (/* reexport */ BrowserEvents),
  "V1s": () => (/* reexport */ Camera),
  "Xz7": () => (/* reexport */ Canvas),
  "bLd": () => (/* reexport */ Cell),
  "Cdc": () => (/* reexport */ Circle),
  "FKn": () => (/* reexport */ CircleCollider),
  "wTW": () => (/* reexport */ Class),
  "ab2": () => (/* reexport */ ClosestLine),
  "GfZ": () => (/* reexport */ ClosestLineJumpTable),
  "YMS": () => (/* reexport */ Collider),
  "oyv": () => (/* reexport */ ColliderComponent),
  "aUb": () => (/* reexport */ CollisionContact),
  "SdD": () => (/* reexport */ CollisionEndEvent),
  "JUv": () => (/* reexport */ CollisionGroup),
  "jEj": () => (/* reexport */ CollisionGroupManager),
  "TFq": () => (/* reexport */ CollisionJumpTable),
  "HDU": () => (/* reexport */ CollisionPostSolveEvent),
  "R_y": () => (/* reexport */ CollisionPreSolveEvent),
  "ydN": () => (/* reexport */ CollisionResolutionStrategy),
  "_N2": () => (/* reexport */ CollisionSolver),
  "t50": () => (/* reexport */ CollisionStartEvent),
  "s$$": () => (/* reexport */ CollisionSystem),
  "v2G": () => (/* reexport */ CollisionType),
  "Ilk": () => (/* reexport */ Color),
  "H_9": () => (/* reexport */ ColorBlindCorrector),
  "s9i": () => (/* reexport */ ColorBlindFlags),
  "ksl": () => (/* reexport */ ColorBlindness),
  "wA2": () => (/* reexport */ Component),
  "R_p": () => (/* reexport */ CompositeCollider),
  "IQ$": () => (/* reexport */ Configurable),
  "I5F": () => (/* reexport */ ConsoleAppender),
  "X8$": () => (/* reexport */ ContactConstraintPoint),
  "FR6": () => (/* reexport */ ContactEndEvent),
  "U8o": () => (/* reexport */ ContactStartEvent),
  "kbG": () => (/* reexport */ CoordPlane),
  "oeJ": () => (/* reexport */ CullingBox),
  "iS_": () => (/* reexport */ DeactivateEvent),
  "cGG": () => (/* reexport */ Debug),
  "skb": () => (/* reexport */ DebugSystem),
  "SLU": () => (/* reexport */ DebugText),
  "RdJ": () => (/* reexport */ DegreeOfFreedom),
  "gU7": () => (/* reexport */ Detector),
  "LSk": () => (/* reexport */ Die),
  "Nmp": () => (/* reexport */ Direction),
  "d1Y": () => (/* reexport */ DisplayMode),
  "xrL": () => (/* reexport */ DynamicTree),
  "sRW": () => (/* reexport */ DynamicTreeCollisionProcessor),
  "cmV": () => (/* binding */ EX_VERSION),
  "N0Q": () => (/* reexport */ EaseTo),
  "q8b": () => (/* reexport */ EasingFunctions),
  "ynB": () => (/* reexport */ EdgeCollider),
  "jT9": () => (/* reexport */ ElasticToActorStrategy),
  "wAz": () => (/* reexport */ EmitterType),
  "D4V": () => (/* reexport */ Engine),
  "N6H": () => (/* reexport */ EnterTriggerEvent),
  "W1A": () => (/* reexport */ EnterViewPortEvent),
  "JHW": () => (/* reexport */ Entity),
  "v2K": () => (/* reexport */ EntityManager),
  "pBf": () => (/* reexport */ EventDispatcher),
  "GMl": () => (/* reexport */ EventTypes),
  "zW2": () => (/* reexport */ Events_namespaceObject),
  "B0K": () => (/* reexport */ ExResponse),
  "Nv7": () => (/* reexport */ ExcaliburGraphicsContext2DCanvas),
  "C_p": () => (/* reexport */ ExcaliburGraphicsContextWebGL),
  "MUA": () => (/* reexport */ ExitTriggerEvent),
  "xqU": () => (/* reexport */ ExitViewPortEvent),
  "peG": () => (/* reexport */ Experiments),
  "pTp": () => (/* reexport */ Fade),
  "vUK": () => (/* reexport */ Flags),
  "j9l": () => (/* reexport */ Follow),
  "Zxw": () => (/* reexport */ Font),
  "Hdx": () => (/* reexport */ FontStyle),
  "Z$d": () => (/* reexport */ FontUnit),
  "o$7": () => (/* reexport */ FrameStats),
  "Zm$": () => (/* reexport */ GameEvent),
  "$QH": () => (/* reexport */ GameStartEvent),
  "i78": () => (/* reexport */ GameStopEvent),
  "h6u": () => (/* reexport */ GamepadAxisEvent),
  "hts": () => (/* reexport */ GamepadButtonEvent),
  "j88": () => (/* reexport */ GamepadConnectEvent),
  "VME": () => (/* reexport */ GamepadDisconnectEvent),
  "nt": () => (/* reexport */ Gif),
  "Ukr": () => (/* reexport */ GlobalCoordinates),
  "zsu": () => (/* reexport */ Graphic),
  "oA6": () => (/* reexport */ GraphicsComponent),
  "TVh": () => (/* reexport */ GraphicsGroup),
  "TwZ": () => (/* reexport */ GraphicsLayer),
  "GTT": () => (/* reexport */ GraphicsLayers),
  "xxj": () => (/* reexport */ GraphicsSystem),
  "XdK": () => (/* reexport */ HiddenEvent),
  "cXo": () => (/* reexport */ ImageSource),
  "Dm5": () => (/* reexport */ InitializeEvent),
  "IIB": () => (/* reexport */ Input_Index_namespaceObject),
  "zI0": () => (/* reexport */ Integrator),
  "SKZ": () => (/* reexport */ KillEvent),
  "__J": () => (/* reexport */ Label_Label),
  "Dvr": () => (/* reexport */ Legacy),
  "Tf9": () => (/* reexport */ Drawing_Index_namespaceObject),
  "RI$": () => (/* reexport */ LimitCameraBoundsStrategy),
  "x12": () => (/* reexport */ Line),
  "aNw": () => (/* reexport */ Loader),
  "xwn": () => (/* reexport */ LockCameraToActorAxisStrategy),
  "dNK": () => (/* reexport */ LockCameraToActorStrategy),
  "ini": () => (/* reexport */ LogLevel),
  "YdH": () => (/* reexport */ Logger),
  "y3G": () => (/* reexport */ Matrix),
  "l57": () => (/* reexport */ MatrixLocations),
  "xn0": () => (/* reexport */ MediaEvent),
  "t2V": () => (/* reexport */ Meet),
  "ZyS": () => (/* reexport */ MockedElement),
  "uxB": () => (/* reexport */ MotionComponent),
  "cpd": () => (/* reexport */ MotionSystem),
  "fiy": () => (/* reexport */ MoveBy),
  "$XZ": () => (/* reexport */ MoveTo),
  "uqK": () => (/* reexport */ NativeSoundEvent),
  "STE": () => (/* reexport */ NativeSoundProcessedEvent),
  "y$z": () => (/* reexport */ Observable),
  "sOq": () => (/* reexport */ Pair),
  "Sqs": () => (/* reexport */ ParseGif),
  "hpZ": () => (/* reexport */ Particle),
  "Vol": () => (/* reexport */ ParticleEmitter),
  "wIZ": () => (/* reexport */ Physics),
  "cBi": () => (/* reexport */ PhysicsStats),
  "mgq": () => (/* reexport */ Polygon_Polygon),
  "YVA": () => (/* reexport */ PolygonCollider),
  "Kgp": () => (/* reexport */ Pool),
  "HH$": () => (/* reexport */ PostCollisionEvent),
  "M_d": () => (/* reexport */ PostDebugDrawEvent),
  "rgh": () => (/* reexport */ PostDrawEvent),
  "Ra6": () => (/* reexport */ PostFrameEvent),
  "KhR": () => (/* reexport */ PostKillEvent),
  "BS5": () => (/* reexport */ PostUpdateEvent),
  "xhz": () => (/* reexport */ PreCollisionEvent),
  "xOq": () => (/* reexport */ PreDebugDrawEvent),
  "a9j": () => (/* reexport */ PreDrawEvent),
  "bHk": () => (/* reexport */ PreFrameEvent),
  "CgK": () => (/* reexport */ PreKillEvent),
  "cuY": () => (/* reexport */ PreUpdateEvent),
  "kvE": () => (/* reexport */ Projection),
  "JDb": () => (/* reexport */ Promises_Promise),
  "Cbi": () => (/* reexport */ PromiseState),
  "AE_": () => (/* reexport */ Query),
  "ctO": () => (/* reexport */ QueryManager),
  "OLH": () => (/* reexport */ RadiusAroundActorStrategy),
  "kky": () => (/* reexport */ Random),
  "nSF": () => (/* reexport */ Raster),
  "zHn": () => (/* reexport */ Ray),
  "zwx": () => (/* reexport */ RealisticSolver),
  "AeJ": () => (/* reexport */ Rectangle),
  "hLz": () => (/* reexport */ RemovedComponent),
  "D9g": () => (/* reexport */ RemovedEntity),
  "wA": () => (/* reexport */ Repeat),
  "jhr": () => (/* reexport */ RepeatForever),
  "GVs": () => (/* reexport */ Resolution),
  "_zO": () => (/* reexport */ Resource),
  "w6$": () => (/* reexport */ RotateBy),
  "mhV": () => (/* reexport */ RotateTo),
  "MOD": () => (/* reexport */ RotationType),
  "kwd": () => (/* reexport */ ScaleBy),
  "Lmr": () => (/* reexport */ ScaleTo),
  "xsS": () => (/* reexport */ Scene),
  "lLr": () => (/* reexport */ Screen),
  "Z$r": () => (/* reexport */ ScreenAppender),
  "IXb": () => (/* reexport */ ScreenElement_ScreenElement),
  "SMj": () => (/* reexport */ ScrollPreventionMode),
  "bnF": () => (/* reexport */ Shape),
  "MFA": () => (/* reexport */ Side),
  "$XC": () => (/* reexport */ SortedList),
  "$uU": () => (/* reexport */ Sound),
  "jyi": () => (/* reexport */ Sprite),
  "E03": () => (/* reexport */ SpriteFont_SpriteFont),
  "V6q": () => (/* reexport */ SpriteSheet),
  "nVo": () => (/* reexport */ StrategyContainer),
  "F6N": () => (/* reexport */ Stream),
  "ad3": () => (/* reexport */ SubscribeEvent),
  "xP7": () => (/* reexport */ System),
  "Odq": () => (/* reexport */ SystemManager),
  "Zif": () => (/* reexport */ SystemType),
  "ZGJ": () => (/* reexport */ TagComponent),
  "xvT": () => (/* reexport */ Text),
  "PHM": () => (/* reexport */ TextAlign),
  "KwO": () => (/* reexport */ TileMap),
  "B7y": () => (/* reexport */ Timer),
  "SFp": () => (/* reexport */ Traits_Index_namespaceObject),
  "Uvn": () => (/* reexport */ TransformComponent),
  "OFT": () => (/* reexport */ TreeNode),
  "xzN": () => (/* reexport */ Trigger_Trigger),
  "H6j": () => (/* reexport */ UnsubscribeEvent),
  "ZrN": () => (/* reexport */ Util_Index_namespaceObject),
  "OWs": () => (/* reexport */ Vector),
  "dF9": () => (/* reexport */ VectorView),
  "VHo": () => (/* reexport */ VisibleEvent),
  "R$E": () => (/* reexport */ WebAudioInstance),
  "q3I": () => (/* reexport */ World),
  "Pab": () => (/* reexport */ canonicalizeAngle),
  "uZ5": () => (/* reexport */ clamp),
  "McK": () => (/* reexport */ createId),
  "k0b": () => (/* reexport */ hasGraphicsTick),
  "hnT": () => (/* reexport */ hasOnInitialize),
  "RSJ": () => (/* reexport */ hasOnPostUpdate),
  "Mku": () => (/* reexport */ hasOnPreUpdate),
  "h90": () => (/* reexport */ hasPostDraw),
  "rms": () => (/* reexport */ hasPreDraw),
  "ErP": () => (/* reexport */ has_initialize),
  "aVg": () => (/* reexport */ has_postupdate),
  "lPc": () => (/* reexport */ has_preupdate),
  "Z8E": () => (/* reexport */ isAddedComponent),
  "NNA": () => (/* reexport */ isAddedSystemEntity),
  "yFn": () => (/* reexport */ isRemoveSystemEntity),
  "lNv": () => (/* reexport */ isRemovedComponent),
  "MZQ": () => (/* reexport */ maxMessages),
  "FUM": () => (/* reexport */ obsolete),
  "vdf": () => (/* reexport */ randomInRange),
  "iaL": () => (/* reexport */ randomIntInRange),
  "w6H": () => (/* reexport */ range),
  "Q4c": () => (/* reexport */ resetObsoleteCounter),
  "Uxb": () => (/* reexport */ toDegrees),
  "Yr5": () => (/* reexport */ toRadians),
  "Bhw": () => (/* reexport */ vec)
});

// NAMESPACE OBJECT: ./Events.ts
var Events_namespaceObject = {};
__nested_webpack_require_51441__.r(Events_namespaceObject);
__nested_webpack_require_51441__.d(Events_namespaceObject, {
  "ActivateEvent": () => (ActivateEvent),
  "CollisionEndEvent": () => (CollisionEndEvent),
  "CollisionPostSolveEvent": () => (CollisionPostSolveEvent),
  "CollisionPreSolveEvent": () => (CollisionPreSolveEvent),
  "CollisionStartEvent": () => (CollisionStartEvent),
  "ContactEndEvent": () => (ContactEndEvent),
  "ContactStartEvent": () => (ContactStartEvent),
  "DeactivateEvent": () => (DeactivateEvent),
  "EnterTriggerEvent": () => (EnterTriggerEvent),
  "EnterViewPortEvent": () => (EnterViewPortEvent),
  "EventTypes": () => (EventTypes),
  "ExitTriggerEvent": () => (ExitTriggerEvent),
  "ExitViewPortEvent": () => (ExitViewPortEvent),
  "GameEvent": () => (GameEvent),
  "GameStartEvent": () => (GameStartEvent),
  "GameStopEvent": () => (GameStopEvent),
  "GamepadAxisEvent": () => (GamepadAxisEvent),
  "GamepadButtonEvent": () => (GamepadButtonEvent),
  "GamepadConnectEvent": () => (GamepadConnectEvent),
  "GamepadDisconnectEvent": () => (GamepadDisconnectEvent),
  "HiddenEvent": () => (HiddenEvent),
  "InitializeEvent": () => (InitializeEvent),
  "KillEvent": () => (KillEvent),
  "PostCollisionEvent": () => (PostCollisionEvent),
  "PostDebugDrawEvent": () => (PostDebugDrawEvent),
  "PostDrawEvent": () => (PostDrawEvent),
  "PostFrameEvent": () => (PostFrameEvent),
  "PostKillEvent": () => (PostKillEvent),
  "PostUpdateEvent": () => (PostUpdateEvent),
  "PreCollisionEvent": () => (PreCollisionEvent),
  "PreDebugDrawEvent": () => (PreDebugDrawEvent),
  "PreDrawEvent": () => (PreDrawEvent),
  "PreFrameEvent": () => (PreFrameEvent),
  "PreKillEvent": () => (PreKillEvent),
  "PreUpdateEvent": () => (PreUpdateEvent),
  "SubscribeEvent": () => (SubscribeEvent),
  "UnsubscribeEvent": () => (UnsubscribeEvent),
  "VisibleEvent": () => (VisibleEvent)
});

// NAMESPACE OBJECT: ./Drawing/SpriteEffects.ts
var SpriteEffects_namespaceObject = {};
__nested_webpack_require_51441__.r(SpriteEffects_namespaceObject);
__nested_webpack_require_51441__.d(SpriteEffects_namespaceObject, {
  "Colorize": () => (Colorize),
  "Darken": () => (Darken),
  "Desaturate": () => (Desaturate),
  "Fill": () => (Fill),
  "Grayscale": () => (Grayscale),
  "Invert": () => (Invert),
  "Lighten": () => (Lighten),
  "Opacity": () => (Opacity),
  "Saturate": () => (Saturate)
});

// NAMESPACE OBJECT: ./Util/DrawUtil.ts
var DrawUtil_namespaceObject = {};
__nested_webpack_require_51441__.r(DrawUtil_namespaceObject);
__nested_webpack_require_51441__.d(DrawUtil_namespaceObject, {
  "circle": () => (circle),
  "line": () => (line),
  "point": () => (point),
  "roundRect": () => (roundRect),
  "vector": () => (vector)
});

// NAMESPACE OBJECT: ./Drawing/Index.ts
var Drawing_Index_namespaceObject = {};
__nested_webpack_require_51441__.r(Drawing_Index_namespaceObject);
__nested_webpack_require_51441__.d(Drawing_Index_namespaceObject, {
  "Animation": () => (Animation_Animation),
  "CanvasDrawComponent": () => (CanvasDrawComponent),
  "CanvasDrawingSystem": () => (CanvasDrawingSystem),
  "Effects": () => (SpriteEffects_namespaceObject),
  "Polygon": () => (Polygon),
  "Sprite": () => (Sprite_Sprite),
  "SpriteFont": () => (SpriteFont),
  "SpriteSheet": () => (SpriteSheet_SpriteSheet),
  "Texture": () => (Texture)
});

// NAMESPACE OBJECT: ./Input/Index.ts
var Input_Index_namespaceObject = {};
__nested_webpack_require_51441__.r(Input_Index_namespaceObject);
__nested_webpack_require_51441__.d(Input_Index_namespaceObject, {
  "Axes": () => (Axes),
  "Buttons": () => (Buttons),
  "Gamepad": () => (Gamepad),
  "Gamepads": () => (Gamepads),
  "KeyEvent": () => (KeyEvent),
  "Keyboard": () => (Keyboard),
  "Keys": () => (Keys),
  "NativePointerButton": () => (NativePointerButton),
  "Pointer": () => (Pointer),
  "PointerButton": () => (PointerButton),
  "PointerCancelEvent": () => (PointerCancelEvent),
  "PointerDownEvent": () => (PointerDownEvent),
  "PointerDragEvent": () => (PointerDragEvent),
  "PointerEnterEvent": () => (PointerEnterEvent),
  "PointerEvent": () => (PointerEvent),
  "PointerEventFactory": () => (PointerEventFactory),
  "PointerLeaveEvent": () => (PointerLeaveEvent),
  "PointerMoveEvent": () => (PointerMoveEvent),
  "PointerScope": () => (PointerScope),
  "PointerType": () => (PointerType),
  "PointerUpEvent": () => (PointerUpEvent),
  "Pointers": () => (Pointers),
  "WheelDeltaMode": () => (WheelDeltaMode),
  "WheelEvent": () => (WheelEvent),
  "createPointerEventByName": () => (createPointerEventByName)
});

// NAMESPACE OBJECT: ./Traits/Index.ts
var Traits_Index_namespaceObject = {};
__nested_webpack_require_51441__.r(Traits_Index_namespaceObject);
__nested_webpack_require_51441__.d(Traits_Index_namespaceObject, {
  "CapturePointer": () => (CapturePointer),
  "OffscreenCulling": () => (OffscreenCulling)
});

// NAMESPACE OBJECT: ./Util/Index.ts
var Util_Index_namespaceObject = {};
__nested_webpack_require_51441__.r(Util_Index_namespaceObject);
__nested_webpack_require_51441__.d(Util_Index_namespaceObject, {
  "Collection": () => (Collection),
  "ConsoleAppender": () => (ConsoleAppender),
  "DrawUtil": () => (DrawUtil_namespaceObject),
  "EasingFunctions": () => (EasingFunctions),
  "LogLevel": () => (LogLevel),
  "Logger": () => (Logger),
  "Observable": () => (Observable),
  "ScreenAppender": () => (ScreenAppender),
  "TwoPI": () => (TwoPI),
  "addItemToArray": () => (addItemToArray),
  "base64Encode": () => (base64Encode),
  "canonicalizeAngle": () => (canonicalizeAngle),
  "clamp": () => (clamp),
  "contains": () => (contains),
  "delay": () => (delay),
  "extend": () => (extend),
  "fail": () => (fail),
  "getOppositeSide": () => (getOppositeSide),
  "getPosition": () => (getPosition),
  "getSideFromDirection": () => (getSideFromDirection),
  "nullish": () => (nullish),
  "randomInRange": () => (randomInRange),
  "randomIntInRange": () => (randomIntInRange),
  "range": () => (range),
  "removeItemFromArray": () => (removeItemFromArray),
  "toDegrees": () => (toDegrees),
  "toRadians": () => (toRadians)
});

// EXTERNAL MODULE: ../../node_modules/core-js/es/array/sort.js
var sort = __nested_webpack_require_51441__(4662);
// EXTERNAL MODULE: ../../node_modules/core-js/es/object/keys.js
var keys = __nested_webpack_require_51441__(8343);
;// CONCATENATED MODULE: ./Polyfill.ts


/**
 * Polyfill adding function
 */
function polyfill() {
    /* istanbul ignore next */
    if (typeof window === 'undefined') {
        window = {
            audioContext: function () {
                return;
            }
        };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.requestAnimationFrame) {
        window.requestAnimationFrame =
            window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setInterval(callback, 1000 / 60);
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.cancelAnimationFrame) {
        window.cancelAnimationFrame =
            window.webkitCancelAnimationFrame ||
                window.mozCancelAnimationFrame ||
                function () {
                    return;
                };
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.AudioContext) {
        if (window.webkitAudioContext) {
            const ctx = window.webkitAudioContext;
            const replaceMe = ctx.prototype.decodeAudioData;
            window.webkitAudioContext.prototype.decodeAudioData = function (arrayBuffer) {
                return new Promise((resolve, reject) => {
                    replaceMe.call(this, arrayBuffer, resolve, reject);
                });
            };
        }
        window.AudioContext =
            window.AudioContext ||
                window.webkitAudioContext ||
                window.mozAudioContext ||
                window.msAudioContext ||
                window.oAudioContext;
    }
    /* istanbul ignore next */
    if (typeof window !== 'undefined' && !window.devicePixelRatio) {
        window.devicePixelRatio = window.devicePixelRatio || 1;
    }
}

;// CONCATENATED MODULE: ./Flags.ts
/**
 * Features in preview
 */
var Experiments;
(function (Experiments) {
    Experiments["WebGL"] = "use-webgl";
})(Experiments || (Experiments = {}));
/**
 * Legacy features that will go away
 */
var Legacy;
(function (Legacy) {
    Legacy["Canvas"] = "use-canvas-context";
    Legacy["LegacyDrawing"] = "use-legacy-drawing";
})(Legacy || (Legacy = {}));
/**
 * Flags is a feature flag implementation for Excalibur. They can only be operated **before [[Engine]] construction**
 * after which they are frozen and are read-only.
 *
 * Flags are used to enable experimental or preview features in Excalibur.
 */
class Flags {
    /**
     * Freeze all flag modifications making them readonly
     */
    static freeze() {
        Flags._FROZEN = true;
    }
    /**
     * Resets internal flag state, not meant to be called by users. Only used for testing.
     *
     * Calling this in your game is UNSUPPORTED
     * @internal
     */
    static _reset() {
        Flags._FROZEN = false;
        Flags._FLAGS = {};
    }
    /**
     * Turn on webgl support
     */
    static useWebGL() {
        Flags.enable(Experiments.WebGL);
    }
    static useCanvasGraphicsContext() {
        Flags.enable(Legacy.Canvas);
    }
    /**
     * @deprecated Recommended not to use legacy drawing, going away in v0.26.0
     */
    static useLegacyDrawing() {
        Flags.enable(Legacy.LegacyDrawing);
    }
    /**
     * Enable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static enable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be enabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = true;
    }
    /**
     * Disable a specific feature flag by name. **Note: can only be set before [[Engine]] constructor time**
     * @param flagName
     */
    static disable(flagName) {
        if (this._FROZEN) {
            throw Error('Feature flags can only be disabled before Engine constructor time');
        }
        Flags._FLAGS[flagName] = false;
    }
    /**
     * Check if a flag is enabled. If the flag is disabled or does not exist `false` is returned
     * @param flagName
     */
    static isEnabled(flagName) {
        return !!Flags._FLAGS[flagName];
    }
    /**
     * Show a list of currently known flags
     */
    static show() {
        return Object.keys(Flags._FLAGS);
    }
}
Flags._FROZEN = false;
Flags._FLAGS = {};

;// CONCATENATED MODULE: ./Id.ts
/**
 *
 */
function createId(type, value) {
    return { type, value };
}
;

;// CONCATENATED MODULE: ./Util/Log.ts
/* eslint-disable no-console */
/**
 * Logging level that Excalibur will tag
 */
var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["Debug"] = 0] = "Debug";
    LogLevel[LogLevel["Info"] = 1] = "Info";
    LogLevel[LogLevel["Warn"] = 2] = "Warn";
    LogLevel[LogLevel["Error"] = 3] = "Error";
    LogLevel[LogLevel["Fatal"] = 4] = "Fatal";
})(LogLevel || (LogLevel = {}));
/**
 * Static singleton that represents the logging facility for Excalibur.
 * Excalibur comes built-in with a [[ConsoleAppender]] and [[ScreenAppender]].
 * Derive from [[Appender]] to create your own logging appenders.
 */
class Logger {
    constructor() {
        this._appenders = [];
        /**
         * Gets or sets the default logging level. Excalibur will only log
         * messages if equal to or above this level. Default: [[LogLevel.Info]]
         */
        this.defaultLevel = LogLevel.Info;
        if (Logger._INSTANCE) {
            throw new Error('Logger is a singleton');
        }
        Logger._INSTANCE = this;
        // Default console appender
        Logger._INSTANCE.addAppender(new ConsoleAppender());
        return Logger._INSTANCE;
    }
    /**
     * Gets the current static instance of Logger
     */
    static getInstance() {
        if (Logger._INSTANCE == null) {
            Logger._INSTANCE = new Logger();
        }
        return Logger._INSTANCE;
    }
    /**
     * Adds a new [[Appender]] to the list of appenders to write to
     */
    addAppender(appender) {
        this._appenders.push(appender);
    }
    /**
     * Clears all appenders from the logger
     */
    clearAppenders() {
        this._appenders.length = 0;
    }
    /**
     * Logs a message at a given LogLevel
     * @param level  The LogLevel`to log the message at
     * @param args   An array of arguments to write to an appender
     */
    _log(level, args) {
        if (level == null) {
            level = this.defaultLevel;
        }
        const len = this._appenders.length;
        for (let i = 0; i < len; i++) {
            if (level >= this.defaultLevel) {
                this._appenders[i].log(level, args);
            }
        }
    }
    /**
     * Writes a log message at the [[LogLevel.Debug]] level
     * @param args  Accepts any number of arguments
     */
    debug(...args) {
        this._log(LogLevel.Debug, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Info]] level
     * @param args  Accepts any number of arguments
     */
    info(...args) {
        this._log(LogLevel.Info, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Warn]] level
     * @param args  Accepts any number of arguments
     */
    warn(...args) {
        this._log(LogLevel.Warn, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Error]] level
     * @param args  Accepts any number of arguments
     */
    error(...args) {
        this._log(LogLevel.Error, args);
    }
    /**
     * Writes a log message at the [[LogLevel.Fatal]] level
     * @param args  Accepts any number of arguments
     */
    fatal(...args) {
        this._log(LogLevel.Fatal, args);
    }
}
Logger._INSTANCE = null;
/**
 * Console appender for browsers (i.e. `console.log`)
 */
class ConsoleAppender {
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        // Check for console support
        if (!console && !console.log && console.warn && console.error) {
            // todo maybe do something better than nothing
            return;
        }
        // Create a new console args array
        const consoleArgs = [];
        consoleArgs.unshift.apply(consoleArgs, args);
        consoleArgs.unshift('[' + LogLevel[level] + '] : ');
        if (level < LogLevel.Warn) {
            // Call .log for Debug/Info
            if (console.log.apply) {
                // this is required on some older browsers that don't support apply on console.log :(
                console.log.apply(console, consoleArgs);
            }
            else {
                console.log(consoleArgs.join(' '));
            }
        }
        else if (level < LogLevel.Error) {
            // Call .warn for Warn
            if (console.warn.apply) {
                console.warn.apply(console, consoleArgs);
            }
            else {
                console.warn(consoleArgs.join(' '));
            }
        }
        else {
            // Call .error for Error/Fatal
            if (console.error.apply) {
                console.error.apply(console, consoleArgs);
            }
            else {
                console.error(consoleArgs.join(' '));
            }
        }
    }
}
/**
 * On-screen (canvas) appender
 */
class ScreenAppender {
    /**
     * @param width   Width of the screen appender in pixels
     * @param height  Height of the screen appender in pixels
     */
    constructor(width, height) {
        // @todo Clean this up
        this._messages = [];
        this._canvas = document.createElement('canvas');
        this._canvas.width = width || window.innerWidth;
        this._canvas.height = height || window.innerHeight;
        this._canvas.style.position = 'absolute';
        // eslint-disable-next-line
        this._ctx = this._canvas.getContext('2d'); // eslint-disable-line
        document.body.appendChild(this._canvas);
    }
    /**
     * Logs a message at the given [[LogLevel]]
     * @param level  Level to log at
     * @param args   Arguments to log
     */
    log(level, args) {
        const message = args.join(',');
        this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
        this._messages.unshift('[' + LogLevel[level] + '] : ' + message);
        let pos = 10;
        let opacity = 1.0;
        for (let i = 0; i < this._messages.length; i++) {
            this._ctx.fillStyle = 'rgba(255,255,255,' + opacity.toFixed(2) + ')';
            this._ctx.fillText(this._messages[i], 200, pos);
            pos += 10;
            opacity = opacity > 0 ? opacity - 0.05 : 0;
        }
    }
}

;// CONCATENATED MODULE: ./Math/Random.ts
/**
 * @module
 * Pseudo-Random Utility
 *
 * A pseudo-random utility to add seeded random support for help in
 * generating things like terrain or reproducible randomness. Uses the
 * [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister) algorithm.
 */
/**
 * 32-bit mask
 */
const BITMASK32 = 0xffffffff;
/**
 * Pseudo-random number generator following the Mersenne_Twister algorithm. Given a seed this generator will produce the same sequence
 * of numbers each time it is called.
 * See https://en.wikipedia.org/wiki/Mersenne_Twister for more details.
 * Uses the MT19937-32 (2002) implementation documented here http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html
 *
 * Api inspired by http://chancejs.com/# https://github.com/chancejs/chancejs
 */
class Random {
    /**
     * If no seed is specified, the Date.now() is used
     */
    constructor(seed) {
        this.seed = seed;
        // Separation point of one one word, the number of bits in the lower bitmask 0 <= r <= w-1
        this._lowerMask = 0x7fffffff; // 31 bits same as _r
        this._upperMask = 0x80000000; // 34 high bits
        // Word size, 64 bits
        this._w = 32;
        // Degree of recurrence
        this._n = 624;
        // Middle word, an offset used in the recurrence defining the series x, 1<=m<n
        this._m = 397;
        // coefficients of teh rational normal form twist matrix
        this._a = 0x9908b0df;
        // tempering bit shifts and masks
        this._u = 11;
        this._s = 7;
        this._b = 0x9d2c5680;
        this._t = 15;
        this._c = 0xefc60000;
        this._l = 18;
        this._f = 1812433253;
        this._mt = new Array(this._n);
        // need to mask to support higher bit machines
        this._mt[0] = (seed || Date.now()) >>> 0;
        for (let i = 1; i < this._n; i++) {
            const s = this._mt[i - 1] ^ (this._mt[i - 1] >>> (this._w - 2));
            // numbers are bigger than the JS max safe int, add in 16-bit chunks to prevent IEEE rounding errors on high bits
            this._mt[i] = (((this._f * ((s & 0xffff0000) >>> 16)) << 16) + this._f * (s & 0xffff) + i) >>> 0;
        }
        this._index = this._n;
    }
    /**
     * Apply the twist
     */
    _twist() {
        const mag01 = [0x0, this._a];
        let y = 0, i = 0;
        for (; i < this._n - this._m; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + this._m] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        for (; i < this._n - 1; i++) {
            y = (this._mt[i] & this._upperMask) | (this._mt[i + 1] & this._lowerMask);
            this._mt[i] = this._mt[i + (this._m - this._n)] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        }
        y = (this._mt[this._n - 1] & this._upperMask) | (this._mt[0] & this._lowerMask);
        this._mt[this._n - 1] = this._mt[this._m - 1] ^ (y >>> 1) ^ (mag01[y & 0x1] & BITMASK32);
        this._index = 0;
    }
    /**
     * Return next 32 bit integer number in sequence
     */
    nextInt() {
        if (this._index >= this._n) {
            this._twist();
        }
        let y = this._mt[this._index++];
        y ^= y >>> this._u;
        y ^= (y << this._s) & this._b;
        y ^= (y << this._t) & this._c;
        y ^= y >>> this._l;
        return y >>> 0;
    }
    /**
     * Return a random floating point number between [0, 1)
     */
    next() {
        return this.nextInt() * (1.0 / 4294967296.0); // divided by 2^32
    }
    /**
     * Return a random floating point in range [min, max) min is included, max is not included
     */
    floating(min, max) {
        return (max - min) * this.next() + min;
    }
    /**
     * Return a random integer in range [min, max] min is included, max is included.
     * Implemented with rejection sampling, see https://medium.com/@betable/tifu-by-using-math-random-f1c308c4fd9d#.i13tdiu5a
     */
    integer(min, max) {
        return Math.floor((max - min + 1) * this.next() + min);
    }
    /**
     * Returns true or false randomly with 50/50 odds by default.
     * By default the likelihood of returning a true is .5 (50%).
     * @param likelihood takes values between [0, 1]
     */
    bool(likelihood = 0.5) {
        return this.next() <= likelihood;
    }
    /**
     * Returns one element from an array at random
     */
    pickOne(array) {
        return array[this.integer(0, array.length - 1)];
    }
    /**
     * Returns a new array random picking elements from the original
     * @param array Original array to pick from
     * @param numPicks can be any positive number
     * @param allowDuplicates indicates whether the returned set is allowed duplicates (it does not mean there will always be duplicates
     * just that it is possible)
     */
    pickSet(array, numPicks, allowDuplicates = false) {
        if (allowDuplicates) {
            return this._pickSetWithDuplicates(array, numPicks);
        }
        else {
            return this._pickSetWithoutDuplicates(array, numPicks);
        }
    }
    /**
     * Returns a new array randomly picking elements in the original (not reused)
     * @param array Array to pick elements out of
     * @param numPicks must be less than or equal to the number of elements in the array.
     */
    _pickSetWithoutDuplicates(array, numPicks) {
        if (numPicks > array.length || numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 < n <= length');
        }
        if (numPicks === array.length) {
            return array;
        }
        const result = new Array(numPicks);
        let currentPick = 0;
        const tempArray = array.slice(0);
        while (currentPick < numPicks) {
            const index = this.integer(0, tempArray.length - 1);
            result[currentPick++] = tempArray[index];
            tempArray.splice(index, 1);
        }
        return result;
    }
    /**
     * Returns a new array random picking elements from the original allowing duplicates
     * @param array Array to pick elements out of
     * @param numPicks can be any positive number
     */
    _pickSetWithDuplicates(array, numPicks) {
        // Typescript numbers are all floating point, so do we add check for int? (or floor the input?)
        if (numPicks < 0) {
            throw new Error('Invalid number of elements to pick, must pick a value 0 <= n < MAX_INT');
        }
        const result = new Array(numPicks);
        for (let i = 0; i < numPicks; i++) {
            result[i] = this.pickOne(array);
        }
        return result;
    }
    /**
     * Returns a new array that has its elements shuffled. Using the Fisher/Yates method
     * https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
     */
    shuffle(array) {
        const tempArray = array.slice(0);
        let swap = null;
        for (let i = 0; i < tempArray.length - 2; i++) {
            const randomIndex = this.integer(i, tempArray.length - 1);
            swap = tempArray[i];
            tempArray[i] = tempArray[randomIndex];
            tempArray[randomIndex] = swap;
        }
        return tempArray;
    }
    /**
     * Generate a list of random integer numbers
     * @param length the length of the final array
     * @param min the minimum integer number to generate inclusive
     * @param max the maximum integer number to generate inclusive
     */
    range(length, min, max) {
        const result = new Array(length);
        for (let i = 0; i < length; i++) {
            result[i] = this.integer(min, max);
        }
        return result;
    }
    /**
     * Returns the result of a d4 dice roll
     */
    d4() {
        return this.integer(1, 4);
    }
    /**
     * Returns the result of a d6 dice roll
     */
    d6() {
        return this.integer(1, 6);
    }
    /**
     * Returns the result of a d8 dice roll
     */
    d8() {
        return this.integer(1, 8);
    }
    /**
     * Returns the result of a d10 dice roll
     */
    d10() {
        return this.integer(1, 10);
    }
    /**
     * Returns the result of a d12 dice roll
     */
    d12() {
        return this.integer(1, 12);
    }
    /**
     * Returns the result of a d20 dice roll
     */
    d20() {
        return this.integer(1, 20);
    }
}

;// CONCATENATED MODULE: ./Collision/Side.ts

/**
 * An enum that describes the sides of an axis aligned box for collision
 */
var Side;
(function (Side) {
    Side["None"] = "None";
    Side["Top"] = "Top";
    Side["Bottom"] = "Bottom";
    Side["Left"] = "Left";
    Side["Right"] = "Right";
})(Side || (Side = {}));
(function (Side) {
    /**
     * Returns the opposite side from the current
     */
    function getOpposite(side) {
        if (side === Side.Top) {
            return Side.Bottom;
        }
        if (side === Side.Bottom) {
            return Side.Top;
        }
        if (side === Side.Left) {
            return Side.Right;
        }
        if (side === Side.Right) {
            return Side.Left;
        }
        return Side.None;
    }
    Side.getOpposite = getOpposite;
    /**
     * Given a vector, return the Side most in that direction (via dot product)
     */
    function fromDirection(direction) {
        const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];
        const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];
        let max = -Number.MAX_VALUE;
        let maxIndex = -1;
        for (let i = 0; i < directions.length; i++) {
            if (directions[i].dot(direction) > max) {
                max = directions[i].dot(direction);
                maxIndex = i;
            }
        }
        return directionEnum[maxIndex];
    }
    Side.fromDirection = fromDirection;
})(Side || (Side = {}));

;// CONCATENATED MODULE: ./Util/Util.ts



/**
 * Two PI constant
 */
const TwoPI = Math.PI * 2;
/**
 * Merges one or more objects into a single target object
 *
 * @returns Merged object with properties from other objects
 * @credit https://gomakethings.com/vanilla-javascript-version-of-jquery-extend/
 */
function extend() {
    const extended = {};
    let deep = false;
    let i = 0;
    const length = arguments.length;
    // Check if a deep merge
    if (Object.prototype.toString.call(arguments[0]) === '[object Boolean]') {
        deep = arguments[0];
        i++;
    }
    // Merge the object into the extended object
    const assignExists = typeof Object.assign === 'function';
    let merge = null;
    if (!assignExists) {
        merge = function (obj) {
            for (const prop in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                    // If deep merge and property is an object, merge properties
                    if (deep && Object.prototype.toString.call(obj[prop]) === '[object Object]') {
                        extended[prop] = extend(true, extended[prop], obj[prop]);
                    }
                    else {
                        extended[prop] = obj[prop];
                    }
                }
            }
        };
    }
    else {
        merge = Object.assign;
    }
    // Loop through each object and conduct a merge
    for (; i < length; i++) {
        const obj = arguments[i];
        if (!assignExists) {
            merge(obj);
        }
        else {
            merge(extended, obj);
        }
    }
    return extended;
}
/**
 * Encode a string in base64
 * @deprecated This will be removed in v0.26.0
 */
function base64Encode(inputStr) {
    const b64 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    let outputStr = '';
    let i = 0;
    while (i < inputStr.length) {
        //all three "& 0xff" added below are there to fix a known bug
        //with bytes returned by xhr.responseText
        const byte1 = inputStr.charCodeAt(i++) & 0xff;
        const byte2 = inputStr.charCodeAt(i++) & 0xff;
        const byte3 = inputStr.charCodeAt(i++) & 0xff;
        const enc1 = byte1 >> 2;
        const enc2 = ((byte1 & 3) << 4) | (byte2 >> 4);
        let enc3, enc4;
        if (isNaN(byte2)) {
            enc3 = enc4 = 64;
        }
        else {
            enc3 = ((byte2 & 15) << 2) | (byte3 >> 6);
            if (isNaN(byte3)) {
                enc4 = 64;
            }
            else {
                enc4 = byte3 & 63;
            }
        }
        outputStr += b64.charAt(enc1) + b64.charAt(enc2) + b64.charAt(enc3) + b64.charAt(enc4);
    }
    return outputStr;
}
/**
 * Sugar that will use `nullishVal` if it's not null or undefined. Simulates the `??` operator
 * @param nullishVal
 * @param defaultVal
 */
function nullish(nullishVal, defaultVal) {
    return nullishVal !== null && nullishVal !== undefined ? nullishVal : defaultVal;
}
/**
 * Clamps a value between a min and max inclusive
 */
function clamp(val, min, max) {
    return Math.min(Math.max(min, val), max);
}
/**
 * Find a random floating point number in range
 */
function randomInRange(min, max, random = new Random()) {
    return random ? random.floating(min, max) : min + Math.random() * (max - min);
}
/**
 * Find a random integer in a range
 */
function randomIntInRange(min, max, random = new Random()) {
    return random ? random.integer(min, max) : Math.round(randomInRange(min, max));
}
/**
 * Convert an angle to be the equivalent in the range [0, 2PI]
 */
function canonicalizeAngle(angle) {
    let tmpAngle = angle;
    if (angle > TwoPI) {
        while (tmpAngle > TwoPI) {
            tmpAngle -= TwoPI;
        }
    }
    if (angle < 0) {
        while (tmpAngle < 0) {
            tmpAngle += TwoPI;
        }
    }
    return tmpAngle;
}
/**
 * Convert radians to degrees
 */
function toDegrees(radians) {
    return (180 / Math.PI) * radians;
}
/**
 * Convert degrees to radians
 */
function toRadians(degrees) {
    return (degrees / 180) * Math.PI;
}
/**
 * Find the screen position of an HTML element
 */
function getPosition(el) {
    let oLeft = 0, oTop = 0;
    const calcOffsetLeft = (parent) => {
        oLeft += parent.offsetLeft;
        if (parent.offsetParent) {
            calcOffsetLeft(parent.offsetParent);
        }
    };
    const calcOffsetTop = (parent) => {
        oTop += parent.offsetTop;
        if (parent.offsetParent) {
            calcOffsetTop(parent.offsetParent);
        }
    };
    calcOffsetLeft(el);
    calcOffsetTop(el);
    return new Vector(oLeft, oTop);
}
/**
 * Add an item to an array list if it doesn't already exist. Returns true if added, false if not and already exists in the array.
 * @deprecated Will be removed in v0.26.0
 */
function addItemToArray(item, array) {
    if (array.indexOf(item) === -1) {
        array.push(item);
        return true;
    }
    return false;
}
/**
 * Remove an item from an list
 * @deprecated Will be removed in v0.26.0
 */
function removeItemFromArray(item, array) {
    let index = -1;
    if ((index = array.indexOf(item)) > -1) {
        array.splice(index, 1);
        return true;
    }
    return false;
}
/**
 * See if an array contains something
 */
function contains(array, obj) {
    for (let i = 0; i < array.length; i++) {
        if (array[i] === obj) {
            return true;
        }
    }
    return false;
}
/**
 * Get the opposit side
 * TODO: Move to Side type
 * @deprecated Will be removed in v0.26.0
 */
function getOppositeSide(side) {
    if (side === Side.Top) {
        return Side.Bottom;
    }
    if (side === Side.Bottom) {
        return Side.Top;
    }
    if (side === Side.Left) {
        return Side.Right;
    }
    if (side === Side.Right) {
        return Side.Left;
    }
    return Side.None;
}
/**
 * Returns the side in the direction of the vector supplied
 * @param direction Vector to check
 * @deprecated
 * TODO: Move to Side type
 */
function getSideFromDirection(direction) {
    const directions = [Vector.Left, Vector.Right, Vector.Up, Vector.Down];
    const directionEnum = [Side.Left, Side.Right, Side.Top, Side.Bottom];
    let max = -Number.MAX_VALUE;
    let maxIndex = -1;
    for (let i = 0; i < directions.length; i++) {
        if (directions[i].dot(direction) > max) {
            max = directions[i].dot(direction);
            maxIndex = i;
        }
    }
    return directionEnum[maxIndex];
}
/**
 * Excalibur's dynamically resizing collection
 * @deprecated Will be removed v0.26.0
 */
class Collection {
    /**
     * @param initialSize  Initial size of the internal backing array
     */
    constructor(initialSize = Collection.DefaultSize) {
        this._internalArray = null;
        this._endPointer = 0;
        this._internalArray = new Array(initialSize);
    }
    _resize() {
        const newSize = this._internalArray.length * 2;
        const newArray = new Array(newSize);
        const count = this.count();
        for (let i = 0; i < count; i++) {
            newArray[i] = this._internalArray[i];
        }
        delete this._internalArray;
        this._internalArray = newArray;
    }
    /**
     * Push elements to the end of the collection
     */
    push(element) {
        if (this._endPointer === this._internalArray.length) {
            this._resize();
        }
        return (this._internalArray[this._endPointer++] = element);
    }
    /**
     * Removes elements from the end of the collection
     */
    pop() {
        this._endPointer = this._endPointer - 1 < 0 ? 0 : this._endPointer - 1;
        return this._internalArray[this._endPointer];
    }
    /**
     * Returns the count of the collection
     */
    count() {
        return this._endPointer;
    }
    /**
     * Empties the collection
     */
    clear() {
        this._endPointer = 0;
    }
    /**
     * Returns the size of the internal backing array
     */
    internalSize() {
        return this._internalArray.length;
    }
    /**
     * Returns an element at a specific index
     * @param index  Index of element to retrieve
     */
    elementAt(index) {
        if (index >= this.count()) {
            //Logger.getInstance().error('Invalid parameter: ' + index);
            throw new Error('Invalid index ' + index);
        }
        return this._internalArray[index];
    }
    /**
     * Inserts an element at a specific index
     * @param index  Index to insert the element
     * @param value  Element to insert
     */
    insert(index, value) {
        if (index >= this.count()) {
            this._resize();
        }
        return (this._internalArray[index] = value);
    }
    /**
     * Removes an element at a specific index
     * @param index  Index of element to remove
     */
    remove(index) {
        const count = this.count();
        if (count === 0) {
            //Logger.getInstance().error('Invalid parameter: ' + index);
            throw new Error('Invalid parameter ' + index);
        }
        // O(n) Shift
        const removed = this._internalArray[index];
        for (let i = index; i < count; i++) {
            this._internalArray[i] = this._internalArray[i + 1];
        }
        this._endPointer--;
        return removed;
    }
    /**
     * Removes an element by reference
     * @param element  Element to retrieve
     */
    removeElement(element) {
        const index = this._internalArray.indexOf(element);
        this.remove(index);
    }
    /**
     * Returns a array representing the collection
     */
    toArray() {
        return this._internalArray.slice(0, this._endPointer);
    }
    /**
     * Iterate over every element in the collection
     * @param func  Callback to call for each element passing a reference to the element and its index, returned values are ignored
     */
    forEach(func) {
        let i = 0;
        const count = this.count();
        for (i; i < count; i++) {
            func.call(this, this._internalArray[i], i);
        }
    }
    /**
     * Mutate every element in the collection
     * @param func  Callback to call for each element passing a reference to the element and its index, any values returned mutate
     * the collection
     */
    map(func) {
        const count = this.count();
        for (let i = 0; i < count; i++) {
            this._internalArray[i] = func.call(this, this._internalArray[i], i);
        }
    }
}
/**
 * Default collection size
 */
Collection.DefaultSize = 200;
/**
 * Used for exhaustive checks at compile time
 */
function fail(message) {
    throw new Error(message);
}
/**
 * Generate a range of numbers
 * For example: range(0, 5) -> [0, 1, 2, 3, 4, 5]
 * @param from inclusive
 * @param to inclusive
 */
const range = (from, to) => Array.from(new Array(to - from + 1), (_x, i) => i + from);
/**
 * Create a promise that resolves after a certain number of milliseconds
 * @param milliseconds
 */
function delay(milliseconds) {
    return new Promise((resolve) => {
        setTimeout(() => {
            resolve();
        }, milliseconds);
    });
}

;// CONCATENATED MODULE: ./Util/Decorators.ts



const maxMessages = 5;
const obsoleteMessage = {};
const resetObsoleteCounter = () => {
    for (const message in obsoleteMessage) {
        obsoleteMessage[message] = 0;
    }
};
const logMessage = (message, options) => {
    const suppressObsoleteMessages = Flags.isEnabled('suppress-obsolete-message');
    if (obsoleteMessage[message] < maxMessages && !suppressObsoleteMessages) {
        Logger.getInstance().warn(message);
        // tslint:disable-next-line: no-console
        if (console.trace && options.showStackTrace) {
            // tslint:disable-next-line: no-console
            console.trace();
        }
    }
    obsoleteMessage[message]++;
};
/**
 * Obsolete decorator for marking Excalibur methods obsolete, you can optionally specify a custom message and/or alternate replacement
 * method do the deprecated one. Inspired by https://github.com/jayphelps/core-decorators.js
 */
function obsolete(options) {
    options = extend({}, {
        message: 'This feature will be removed in future versions of Excalibur.',
        alternateMethod: null,
        showStackTrack: false
    }, options);
    return function (target, property, descriptor) {
        if (descriptor &&
            !(typeof descriptor.value === 'function' || typeof descriptor.get === 'function' || typeof descriptor.set === 'function')) {
            throw new SyntaxError('Only classes/functions/getters/setters can be marked as obsolete');
        }
        const methodSignature = `${target.name || ''}${target.name && property ? '.' : ''}${property ? property : ''}`;
        const message = `${methodSignature} is marked obsolete: ${options.message}` +
            (options.alternateMethod ? ` Use ${options.alternateMethod} instead` : '');
        if (!obsoleteMessage[message]) {
            obsoleteMessage[message] = 0;
        }
        // If descriptor is null it is a class
        const method = descriptor ? Object.assign({}, descriptor) : target;
        if (!descriptor) {
            // with es2015 classes we need to change our decoration tactic
            class DecoratedClass extends method {
                constructor(...args) {
                    logMessage(message, options);
                    super(...args);
                }
            }
            return DecoratedClass;
        }
        if (descriptor && descriptor.value) {
            method.value = function () {
                logMessage(message, options);
                return descriptor.value.apply(this, arguments);
            };
            return method;
        }
        if (descriptor && descriptor.get) {
            method.get = function () {
                logMessage(message, options);
                return descriptor.get.apply(this, arguments);
            };
        }
        if (descriptor && descriptor.set) {
            method.set = function () {
                logMessage(message, options);
                return descriptor.set.apply(this, arguments);
            };
        }
        return method;
    };
}

;// CONCATENATED MODULE: ./Math/vector.ts
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * A 2D vector on a plane.
 */
class Vector {
    /**
     * @param x  X component of the Vector
     * @param y  Y component of the Vector
     */
    constructor(x, y) {
        this._x = 0;
        this._y = 0;
        this._x = x;
        this._y = y;
    }
    /**
     * A (0, 0) vector
     */
    static get Zero() {
        return new Vector(0, 0);
    }
    /**
     * A (1, 1) vector
     */
    static get One() {
        return new Vector(1, 1);
    }
    /**
     * A (0.5, 0.5) vector
     */
    static get Half() {
        return new Vector(0.5, 0.5);
    }
    /**
     * A unit vector pointing up (0, -1)
     */
    static get Up() {
        return new Vector(0, -1);
    }
    /**
     * A unit vector pointing down (0, 1)
     */
    static get Down() {
        return new Vector(0, 1);
    }
    /**
     * A unit vector pointing left (-1, 0)
     */
    static get Left() {
        return new Vector(-1, 0);
    }
    /**
     * A unit vector pointing right (1, 0)
     */
    static get Right() {
        return new Vector(1, 0);
    }
    /**
     * Returns a vector of unit length in the direction of the specified angle in Radians.
     * @param angle The angle to generate the vector
     */
    static fromAngle(angle) {
        return new Vector(Math.cos(angle), Math.sin(angle));
    }
    /**
     * Checks if vector is not null, undefined, or if any of its components are NaN or Infinity.
     */
    static isValid(vec) {
        if (vec === null || vec === undefined) {
            return false;
        }
        if (isNaN(vec.x) || isNaN(vec.y)) {
            return false;
        }
        if (vec.x === Infinity || vec.y === Infinity || vec.x === -Infinity || vec.y === -Infinity) {
            return false;
        }
        return true;
    }
    /**
     * Calculates distance between two Vectors
     * @param vec1
     * @param vec2
     */
    static distance(vec1, vec2) {
        return Math.sqrt(Math.pow(vec1.x - vec2.x, 2) + Math.pow(vec1.y - vec2.y, 2));
    }
    /**
     * Get the x component of the vector
     */
    get x() {
        return this._x;
    }
    /**
     * Set the x component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set x(val) {
        this._x = val;
    }
    /**
     * Get the y component of the vector
     */
    get y() {
        return this._y;
    }
    /**
     * Set the y component, THIS MUTATES the current vector. It is usually better to create a new vector.
     * @warning **Be very careful setting components on shared vectors, mutating shared vectors can cause hard to find bugs**
     */
    set y(val) {
        this._y = val;
    }
    /**
     * Sets the x and y components at once, THIS MUTATES the current vector. It is usually better to create a new vector.
     *
     * @warning **Be very careful using this, mutating vectors can cause hard to find bugs**
     */
    setTo(x, y) {
        this.x = x;
        this.y = y;
    }
    /**
     * Compares this point against another and tests for equality
     * @param vector The other point to compare to
     * @param tolerance Amount of euclidean distance off we are willing to tolerate
     */
    equals(vector, tolerance = 0.001) {
        return Math.abs(this.x - vector.x) <= tolerance && Math.abs(this.y - vector.y) <= tolerance;
    }
    /**
     * The distance to another vector. If no other Vector is specified, this will return the [[magnitude]].
     * @param v  The other vector. Leave blank to use origin vector.
     */
    distance(v) {
        if (!v) {
            v = Vector.Zero;
        }
        return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2));
    }
    squareDistance(v) {
        if (!v) {
            v = Vector.Zero;
        }
        return Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2);
    }
    /**
     * The magnitude (size) of the Vector
     * @deprecated magnitude will be removed in favour of '.size' in version 0.25.0
     */
    magnitude() {
        return this.distance();
    }
    /**
     * The size (magnitude) of the Vector
     */
    get size() {
        return this.distance();
    }
    /**
     * Setting the size mutates the current vector
     *
     * @warning Can be used to set the size of the vector, **be very careful using this, mutating vectors can cause hard to find bugs**
     */
    set size(newLength) {
        const v = this.normalize().scale(newLength);
        this.setTo(v.x, v.y);
    }
    /**
     * Normalizes a vector to have a magnitude of 1.
     */
    normalize() {
        const d = this.distance();
        if (d > 0) {
            return new Vector(this.x / d, this.y / d);
        }
        else {
            return new Vector(0, 1);
        }
    }
    /**
     * Returns the average (midpoint) between the current point and the specified
     */
    average(vec) {
        return this.add(vec).scale(0.5);
    }
    scale(sizeOrScale) {
        if (sizeOrScale instanceof Vector) {
            return new Vector(this.x * sizeOrScale.x, this.y * sizeOrScale.y);
        }
        else {
            return new Vector(this.x * sizeOrScale, this.y * sizeOrScale);
        }
    }
    /**
     * Adds one vector to another
     * @param v The vector to add
     */
    add(v) {
        return new Vector(this.x + v.x, this.y + v.y);
    }
    /**
     * Subtracts a vector from another, if you subtract vector `B.sub(A)` the resulting vector points from A -> B
     * @param v The vector to subtract
     */
    sub(v) {
        return new Vector(this.x - v.x, this.y - v.y);
    }
    /**
     * Adds one vector to this one modifying the original
     * @param v The vector to add
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    addEqual(v) {
        this.setTo(this.x + v.x, this.y + v.y);
        return this;
    }
    /**
     * Subtracts a vector from this one modifying the original
     * @param v The vector to subtract
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    subEqual(v) {
        this.setTo(this.x - v.x, this.y - v.y);
        return this;
    }
    /**
     * Scales this vector by a factor of size and modifies the original
     * @warning Be very careful using this, mutating vectors can cause hard to find bugs
     */
    scaleEqual(size) {
        this.setTo(this.x * size, this.y * size);
        return this;
    }
    /**
     * Performs a dot product with another vector
     * @param v  The vector to dot
     */
    dot(v) {
        return this.x * v.x + this.y * v.y;
    }
    cross(v) {
        if (v instanceof Vector) {
            return this.x * v.y - this.y * v.x;
        }
        else if (typeof v === 'number') {
            return new Vector(v * this.y, -v * this.x);
        }
    }
    static cross(num, vec) {
        return new Vector(-num * vec.y, num * vec.x);
    }
    /**
     * Returns the perpendicular vector to this one
     */
    perpendicular() {
        return new Vector(this.y, -this.x);
    }
    /**
     * Returns the normal vector to this one, same as the perpendicular of length 1
     */
    normal() {
        return this.perpendicular().normalize();
    }
    /**
     * Negate the current vector
     */
    negate() {
        return this.scale(-1);
    }
    /**
     * Returns the angle of this vector.
     */
    toAngle() {
        return Math.atan2(this.y, this.x);
    }
    /**
     * Rotates the current vector around a point by a certain number of
     * degrees in radians
     */
    rotate(angle, anchor) {
        if (!anchor) {
            anchor = new Vector(0, 0);
        }
        const sinAngle = Math.sin(angle);
        const cosAngle = Math.cos(angle);
        const x = cosAngle * (this.x - anchor.x) - sinAngle * (this.y - anchor.y) + anchor.x;
        const y = sinAngle * (this.x - anchor.x) + cosAngle * (this.y - anchor.y) + anchor.y;
        return new Vector(x, y);
    }
    /**
     * Creates new vector that has the same values as the previous.
     */
    clone() {
        return new Vector(this.x, this.y);
    }
    /**
     * Returns a string representation of the vector.
     */
    toString(fixed) {
        if (fixed) {
            return `(${this.x.toFixed(fixed)}, ${this.y.toFixed(fixed)})`;
        }
        return `(${this.x}, ${this.y})`;
    }
}
__decorate([
    obsolete({ message: 'will be removed in favour of `.size` in version 0.25.0' })
], Vector.prototype, "magnitude", null);
/**
 * Shorthand for creating new Vectors - returns a new Vector instance with the
 * provided X and Y components.
 *
 * @param x  X component of the Vector
 * @param y  Y component of the Vector
 */
function vec(x, y) {
    return new Vector(x, y);
}

;// CONCATENATED MODULE: ./Color.ts
var Color_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * Provides standard colors (e.g. [[Color.Black]])
 * but you can also create custom colors using RGB, HSL, or Hex. Also provides
 * useful color operations like [[Color.lighten]], [[Color.darken]], and more.
 */
class Color {
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    constructor(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a != null ? a : 1;
    }
    /**
     * Creates a new instance of Color from an r, g, b, a
     *
     * @param r  The red component of color (0-255)
     * @param g  The green component of color (0-255)
     * @param b  The blue component of color (0-255)
     * @param a  The alpha component of color (0-1.0)
     */
    static fromRGB(r, g, b, a) {
        return new Color(r, g, b, a);
    }
    /**
     * Creates a new instance of Color from a rgb string
     *
     * @param string  CSS color string of the form rgba(255, 255, 255, 1) or rgb(255, 255, 255)
     */
    static fromRGBString(string) {
        const rgbaRegEx = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)/i;
        let match = null;
        if ((match = string.match(rgbaRegEx))) {
            const r = parseInt(match[1], 10);
            const g = parseInt(match[2], 10);
            const b = parseInt(match[3], 10);
            let a = 1;
            if (match[4]) {
                a = parseFloat(match[4]);
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid rgb/a string: ' + string);
        }
    }
    /**
     * Creates a new instance of Color from a hex string
     *
     * @param hex  CSS color string of the form #ffffff, the alpha component is optional
     */
    static fromHex(hex) {
        const hexRegEx = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?$/i;
        let match = null;
        if ((match = hex.match(hexRegEx))) {
            const r = parseInt(match[1], 16);
            const g = parseInt(match[2], 16);
            const b = parseInt(match[3], 16);
            let a = 1;
            if (match[4]) {
                a = parseInt(match[4], 16) / 255;
            }
            return new Color(r, g, b, a);
        }
        else {
            throw new Error('Invalid hex string: ' + hex);
        }
    }
    /**
     * Creates a new instance of Color from hsla values
     *
     * @param h  Hue is represented [0-1]
     * @param s  Saturation is represented [0-1]
     * @param l  Luminance is represented [0-1]
     * @param a  Alpha is represented [0-1]
     */
    static fromHSL(h, s, l, a = 1.0) {
        const temp = new HSLColor(h, s, l, a);
        return temp.toRGBA();
    }
    /**
     * Lightens the current color by a specified amount
     *
     * @param factor  The amount to lighten by [0-1]
     */
    lighten(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l += (1 - temp.l) * factor;
        return temp.toRGBA();
    }
    /**
     * Darkens the current color by a specified amount
     *
     * @param factor  The amount to darken by [0-1]
     */
    darken(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.l -= temp.l * factor;
        return temp.toRGBA();
    }
    /**
     * Saturates the current color by a specified amount
     *
     * @param factor  The amount to saturate by [0-1]
     */
    saturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s += temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Desaturates the current color by a specified amount
     *
     * @param factor  The amount to desaturate by [0-1]
     */
    desaturate(factor = 0.1) {
        const temp = HSLColor.fromRGBA(this.r, this.g, this.b, this.a);
        temp.s -= temp.s * factor;
        return temp.toRGBA();
    }
    /**
     * Multiplies a color by another, results in a darker color
     *
     * @param color  The other color
     */
    multiply(color) {
        const newR = (((color.r / 255) * this.r) / 255) * 255;
        const newG = (((color.g / 255) * this.g) / 255) * 255;
        const newB = (((color.b / 255) * this.b) / 255) * 255;
        const newA = color.a * this.a;
        return new Color(newR, newG, newB, newA);
    }
    /**
     * Multiplies a color by another, results in a darker color
     * @param color
     * @deprecated Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0
     */
    mulitiply(color) {
        return this.multiply(color);
    }
    /**
     * Screens a color by another, results in a lighter color
     *
     * @param color  The other color
     */
    screen(color) {
        const color1 = color.invert();
        const color2 = color.invert();
        return color1.multiply(color2).invert();
    }
    /**
     * Inverts the current color
     */
    invert() {
        return new Color(255 - this.r, 255 - this.g, 255 - this.b, 1.0 - this.a);
    }
    /**
     * Averages the current color with another
     *
     * @param color  The other color
     */
    average(color) {
        const newR = (color.r + this.r) / 2;
        const newG = (color.g + this.g) / 2;
        const newB = (color.b + this.b) / 2;
        const newA = (color.a + this.a) / 2;
        return new Color(newR, newG, newB, newA);
    }
    equal(color) {
        return this.toString() === color.toString();
    }
    /**
     * Returns a CSS string representation of a color.
     *
     * @param format Color representation, accepts: rgb, hsl, or hex
     */
    toString(format = 'rgb') {
        switch (format) {
            case 'rgb':
                return this.toRGBA();
            case 'hsl':
                return this.toHSLA();
            case 'hex':
                return this.toHex();
            default:
                throw new Error('Invalid Color format');
        }
    }
    /**
     * Returns Hex Value of a color component
     * @param c color component
     * @see https://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb
     */
    _componentToHex(c) {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }
    /**
     * Return Hex representation of a color.
     */
    toHex() {
        return '#' + this._componentToHex(this.r) + this._componentToHex(this.g) + this._componentToHex(this.b);
    }
    /**
     * Return RGBA representation of a color.
     */
    toRGBA() {
        const result = String(this.r.toFixed(0)) + ', ' + String(this.g.toFixed(0)) + ', ' + String(this.b.toFixed(0));
        if (this.a !== undefined || this.a !== null) {
            return 'rgba(' + result + ', ' + String(this.a) + ')';
        }
        return 'rgb(' + result + ')';
    }
    /**
     * Return HSLA representation of a color.
     */
    toHSLA() {
        return HSLColor.fromRGBA(this.r, this.g, this.b, this.a).toString();
    }
    /**
     * Returns a CSS string representation of a color.
     */
    fillStyle() {
        return this.toString();
    }
    /**
     * Returns a clone of the current color.
     */
    clone() {
        return new Color(this.r, this.g, this.b, this.a);
    }
    /**
     * Black (#000000)
     */
    static get Black() {
        return Color.fromHex('#000000');
    }
    /**
     * White (#FFFFFF)
     */
    static get White() {
        return Color.fromHex('#FFFFFF');
    }
    /**
     * Gray (#808080)
     */
    static get Gray() {
        return Color.fromHex('#808080');
    }
    /**
     * Light gray (#D3D3D3)
     */
    static get LightGray() {
        return Color.fromHex('#D3D3D3');
    }
    /**
     * Dark gray (#A9A9A9)
     */
    static get DarkGray() {
        return Color.fromHex('#A9A9A9');
    }
    /**
     * Yellow (#FFFF00)
     */
    static get Yellow() {
        return Color.fromHex('#FFFF00');
    }
    /**
     * Orange (#FFA500)
     */
    static get Orange() {
        return Color.fromHex('#FFA500');
    }
    /**
     * Red (#FF0000)
     */
    static get Red() {
        return Color.fromHex('#FF0000');
    }
    /**
     * Vermilion (#FF5B31)
     */
    static get Vermilion() {
        return Color.fromHex('#FF5B31');
    }
    /**
     * Vermilion (#FF5B31)
     * @deprecated Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0
     */
    static get Vermillion() {
        return Color.Vermilion;
    }
    /**
     * Rose (#FF007F)
     */
    static get Rose() {
        return Color.fromHex('#FF007F');
    }
    /**
     * Magenta (#FF00FF)
     */
    static get Magenta() {
        return Color.fromHex('#FF00FF');
    }
    /**
     * Violet (#7F00FF)
     */
    static get Violet() {
        return Color.fromHex('#7F00FF');
    }
    /**
     * Blue (#0000FF)
     */
    static get Blue() {
        return Color.fromHex('#0000FF');
    }
    /**
     * Azure (#007FFF)
     */
    static get Azure() {
        return Color.fromHex('#007FFF');
    }
    /**
     * Cyan (#00FFFF)
     */
    static get Cyan() {
        return Color.fromHex('#00FFFF');
    }
    /**
     * Viridian (#59978F)
     */
    static get Viridian() {
        return Color.fromHex('#59978F');
    }
    /**
     * Green (#00FF00)
     */
    static get Green() {
        return Color.fromHex('#00FF00');
    }
    /**
     * Chartreuse (#7FFF00)
     */
    static get Chartreuse() {
        return Color.fromHex('#7FFF00');
    }
    /**
     * Transparent (#FFFFFF00)
     */
    static get Transparent() {
        return Color.fromHex('#FFFFFF00');
    }
    /**
     * ExcaliburBlue (#176BAA)
     */
    static get ExcaliburBlue() {
        return Color.fromHex('#176BAA');
    }
}
Color_decorate([
    obsolete({ message: 'Alias for incorrect spelling used in older versions, use multiply instead, will be removed in v0.25.0' })
], Color.prototype, "mulitiply", null);
Color_decorate([
    obsolete({
        message: 'Alias for incorrect spelling used in older versions',
        alternateMethod: 'Vermilion'
    })
], Color, "Vermillion", null);
/**
 * Internal HSL Color representation
 *
 * http://en.wikipedia.org/wiki/HSL_and_HSV
 * http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
 */
class HSLColor {
    constructor(h, s, l, a) {
        this.h = h;
        this.s = s;
        this.l = l;
        this.a = a;
    }
    static hue2rgb(p, q, t) {
        if (t < 0) {
            t += 1;
        }
        if (t > 1) {
            t -= 1;
        }
        if (t < 1 / 6) {
            return p + (q - p) * 6 * t;
        }
        if (t < 1 / 2) {
            return q;
        }
        if (t < 2 / 3) {
            return p + (q - p) * (2 / 3 - t) * 6;
        }
        return p;
    }
    static fromRGBA(r, g, b, a) {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s;
        const l = (max + min) / 2;
        if (max === min) {
            h = s = 0; // achromatic
        }
        else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }
        return new HSLColor(h, s, l, a);
    }
    toRGBA() {
        let r, g, b;
        if (this.s === 0) {
            r = g = b = this.l; // achromatic
        }
        else {
            const q = this.l < 0.5 ? this.l * (1 + this.s) : this.l + this.s - this.l * this.s;
            const p = 2 * this.l - q;
            r = HSLColor.hue2rgb(p, q, this.h + 1 / 3);
            g = HSLColor.hue2rgb(p, q, this.h);
            b = HSLColor.hue2rgb(p, q, this.h - 1 / 3);
        }
        return new Color(r * 255, g * 255, b * 255, this.a);
    }
    toString() {
        const h = this.h.toFixed(0), s = this.s.toFixed(0), l = this.l.toFixed(0), a = this.a.toFixed(0);
        return `hsla(${h}, ${s}, ${l}, ${a})`;
    }
}

;// CONCATENATED MODULE: ./Collision/BoundingBox.ts



/**
 * Axis Aligned collision primitive for Excalibur.
 */
class BoundingBox {
    /**
     * Constructor allows passing of either an object with all coordinate components,
     * or the coordinate components passed separately.
     * @param leftOrOptions    Either x coordinate of the left edge or an options object
     * containing the four coordinate components.
     * @param top     y coordinate of the top edge
     * @param right   x coordinate of the right edge
     * @param bottom  y coordinate of the bottom edge
     */
    constructor(leftOrOptions = 0, top = 0, right = 0, bottom = 0) {
        if (typeof leftOrOptions === 'object') {
            this.left = leftOrOptions.left;
            this.top = leftOrOptions.top;
            this.right = leftOrOptions.right;
            this.bottom = leftOrOptions.bottom;
        }
        else if (typeof leftOrOptions === 'number') {
            this.left = leftOrOptions;
            this.top = top;
            this.right = right;
            this.bottom = bottom;
        }
    }
    /**
     * Given bounding box A & B, returns the side relative to A when intersection is performed.
     * @param intersection Intersection vector between 2 bounding boxes
     */
    static getSideFromIntersection(intersection) {
        if (!intersection) {
            return Side.None;
        }
        if (intersection) {
            if (Math.abs(intersection.x) > Math.abs(intersection.y)) {
                if (intersection.x < 0) {
                    return Side.Right;
                }
                return Side.Left;
            }
            else {
                if (intersection.y < 0) {
                    return Side.Bottom;
                }
                return Side.Top;
            }
        }
        return Side.None;
    }
    static fromPoints(points) {
        let minX = Infinity;
        let minY = Infinity;
        let maxX = -Infinity;
        let maxY = -Infinity;
        for (let i = 0; i < points.length; i++) {
            if (points[i].x < minX) {
                minX = points[i].x;
            }
            if (points[i].x > maxX) {
                maxX = points[i].x;
            }
            if (points[i].y < minY) {
                minY = points[i].y;
            }
            if (points[i].y > maxY) {
                maxY = points[i].y;
            }
        }
        return new BoundingBox(minX, minY, maxX, maxY);
    }
    static fromDimension(width, height, anchor = Vector.Half, pos = Vector.Zero) {
        return new BoundingBox(-width * anchor.x + pos.x, -height * anchor.y + pos.y, width - width * anchor.x + pos.x, height - height * anchor.y + pos.y);
    }
    /**
     * Returns the calculated width of the bounding box
     */
    get width() {
        return this.right - this.left;
    }
    /**
     * Returns the calculated height of the bounding box
     */
    get height() {
        return this.bottom - this.top;
    }
    /**
     * Return whether the bounding box has zero dimensions in height,width or both
     */
    hasZeroDimensions() {
        return this.width === 0 || this.height === 0;
    }
    /**
     * Returns the center of the bounding box
     */
    get center() {
        return new Vector((this.left + this.right) / 2, (this.top + this.bottom) / 2);
    }
    translate(pos) {
        return new BoundingBox(this.left + pos.x, this.top + pos.y, this.right + pos.x, this.bottom + pos.y);
    }
    /**
     * Rotates a bounding box by and angle and around a point, if no point is specified (0, 0) is used by default. The resulting bounding
     * box is also axis-align. This is useful when a new axis-aligned bounding box is needed for rotated geometry.
     */
    rotate(angle, point = Vector.Zero) {
        const points = this.getPoints().map((p) => p.rotate(angle, point));
        return BoundingBox.fromPoints(points);
    }
    scale(scale, point = Vector.Zero) {
        const shifted = this.translate(point);
        return new BoundingBox(shifted.left * scale.x, shifted.top * scale.y, shifted.right * scale.x, shifted.bottom * scale.y);
    }
    transform(matrix) {
        const points = this.getPoints().map((p) => matrix.multv(p));
        return BoundingBox.fromPoints(points);
    }
    /**
     * Returns the perimeter of the bounding box
     */
    getPerimeter() {
        const wx = this.width;
        const wy = this.height;
        return 2 * (wx + wy);
    }
    getPoints() {
        const results = [];
        results.push(new Vector(this.left, this.top));
        results.push(new Vector(this.right, this.top));
        results.push(new Vector(this.right, this.bottom));
        results.push(new Vector(this.left, this.bottom));
        return results;
    }
    /**
     * Determines whether a ray intersects with a bounding box
     */
    rayCast(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        return tmax >= Math.max(0, tmin) && tmin < farClipDistance;
    }
    rayCastTime(ray, farClipDistance = Infinity) {
        // algorithm from https://tavianator.com/fast-branchless-raybounding-box-intersections/
        let tmin = -Infinity;
        let tmax = +Infinity;
        const xinv = ray.dir.x === 0 ? Number.MAX_VALUE : 1 / ray.dir.x;
        const yinv = ray.dir.y === 0 ? Number.MAX_VALUE : 1 / ray.dir.y;
        const tx1 = (this.left - ray.pos.x) * xinv;
        const tx2 = (this.right - ray.pos.x) * xinv;
        tmin = Math.min(tx1, tx2);
        tmax = Math.max(tx1, tx2);
        const ty1 = (this.top - ray.pos.y) * yinv;
        const ty2 = (this.bottom - ray.pos.y) * yinv;
        tmin = Math.max(tmin, Math.min(ty1, ty2));
        tmax = Math.min(tmax, Math.max(ty1, ty2));
        if (tmax >= Math.max(0, tmin) && tmin < farClipDistance) {
            return tmin;
        }
        return -1;
    }
    contains(val) {
        if (val instanceof Vector) {
            return this.left <= val.x && this.top <= val.y && this.bottom >= val.y && this.right >= val.x;
        }
        else if (val instanceof BoundingBox) {
            if (this.left < val.left && this.top < val.top && val.bottom < this.bottom && val.right < this.right) {
                return true;
            }
            return false;
        }
        return false;
    }
    /**
     * Combines this bounding box and another together returning a new bounding box
     * @param other  The bounding box to combine
     */
    combine(other) {
        const compositeBB = new BoundingBox(Math.min(this.left, other.left), Math.min(this.top, other.top), Math.max(this.right, other.right), Math.max(this.bottom, other.bottom));
        return compositeBB;
    }
    get dimensions() {
        return new Vector(this.width, this.height);
    }
    /**
     * Test wether this bounding box intersects with another returning
     * the intersection vector that can be used to resolve the collision. If there
     * is no intersection null is returned.
     *
     * @param other  Other [[BoundingBox]] to test intersection with
     * @returns A Vector in the direction of the current BoundingBox, this <- other
     */
    intersect(other) {
        const totalBoundingBox = this.combine(other);
        // If the total bounding box is less than or equal the sum of the 2 bounds then there is collision
        if (totalBoundingBox.width < other.width + this.width &&
            totalBoundingBox.height < other.height + this.height &&
            !totalBoundingBox.dimensions.equals(other.dimensions) &&
            !totalBoundingBox.dimensions.equals(this.dimensions)) {
            // collision
            let overlapX = 0;
            // right edge is between the other's left and right edge
            /**
             *     +-this-+
             *     |      |
             *     |    +-other-+
             *     +----|-+     |
             *          |       |
             *          +-------+
             *         <---
             *          ^ overlap
             */
            if (this.right >= other.left && this.right <= other.right) {
                overlapX = other.left - this.right;
                // right edge is past the other's right edge
                /**
                 *     +-other-+
                 *     |       |
                 *     |    +-this-+
                 *     +----|--+   |
                 *          |      |
                 *          +------+
                 *          --->
                 *          ^ overlap
                 */
            }
            else {
                overlapX = other.right - this.left;
            }
            let overlapY = 0;
            // top edge is between the other's top and bottom edge
            /**
             *     +-other-+
             *     |       |
             *     |    +-this-+   | <- overlap
             *     +----|--+   |   |
             *          |      |  \ /
             *          +------+   '
             */
            if (this.top <= other.bottom && this.top >= other.top) {
                overlapY = other.bottom - this.top;
                // top edge is above the other top edge
                /**
                 *     +-this-+         .
                 *     |      |        / \
                 *     |    +-other-+   | <- overlap
                 *     +----|-+     |   |
                 *          |       |
                 *          +-------+
                 */
            }
            else {
                overlapY = other.top - this.bottom;
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new Vector(overlapX, 0);
            }
            else {
                return new Vector(0, overlapY);
            }
            // Case of total containment of one bounding box by another
        }
        else if (totalBoundingBox.dimensions.equals(other.dimensions) || totalBoundingBox.dimensions.equals(this.dimensions)) {
            let overlapX = 0;
            // this is wider than the other
            if (this.width - other.width >= 0) {
                // This right edge is closest to the others right edge
                if (this.right - other.right <= other.left - this.left) {
                    overlapX = other.left - this.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = other.right - this.left;
                }
                // other is wider than this
            }
            else {
                // This right edge is closest to the others right edge
                if (other.right - this.right <= this.left - other.left) {
                    overlapX = this.left - other.right;
                    // This left edge is closest to the others left edge
                }
                else {
                    overlapX = this.right - other.left;
                }
            }
            let overlapY = 0;
            // this is taller than other
            if (this.height - other.height >= 0) {
                // The bottom edge is closest to the others bottom edge
                if (this.bottom - other.bottom <= other.top - this.top) {
                    overlapY = other.top - this.bottom;
                }
                else {
                    overlapY = other.bottom - this.top;
                }
                // other is taller than this
            }
            else {
                // The bottom edge is closest to the others bottom edge
                if (other.bottom - this.bottom <= this.top - other.top) {
                    overlapY = this.top - other.bottom;
                }
                else {
                    overlapY = this.bottom - other.top;
                }
            }
            if (Math.abs(overlapX) < Math.abs(overlapY)) {
                return new Vector(overlapX, 0);
            }
            else {
                return new Vector(0, overlapY);
            }
        }
        else {
            return null;
        }
    }
    /**
     * Test whether the bounding box has intersected with another bounding box, returns the side of the current bb that intersected.
     * @param bb The other actor to test
     */
    intersectWithSide(bb) {
        const intersect = this.intersect(bb);
        return BoundingBox.getSideFromIntersection(intersect);
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Yellow) {
        ctx.strokeStyle = color.toString();
        ctx.strokeRect(this.left, this.top, this.width, this.height);
    }
    /**
     * Draw a debug bounding box
     * @param ex
     * @param color
     */
    draw(ex, color = Color.Yellow) {
        ex.debug.drawRect(this.left, this.top, this.width, this.height, { color });
    }
}

;// CONCATENATED MODULE: ./Math/matrix.ts



var MatrixLocations;
(function (MatrixLocations) {
    MatrixLocations[MatrixLocations["X"] = 12] = "X";
    MatrixLocations[MatrixLocations["Y"] = 13] = "Y";
})(MatrixLocations || (MatrixLocations = {}));
const sign = (val) => {
    if (val === 0) {
        return 0;
    }
    return val < 0 ? -1 : 1;
};
// const multMatch = (a: number, b: number) => {
//   if (sign(a) < 0 && sign(b) < 0) {
//     return -Math.abs(a * b);
//   }
//   return a * b;
// }
// const epsilon = (val: number) => {
//   if (val * val < .0001) {
//     return 0;
//   }
//   return val;
// }
/**
 * Excalibur Matrix helper for 4x4 matrices
 *
 * Useful for webgl 4x4 matrices
 */
class Matrix {
    constructor() {
        /**
         *  4x4 matrix in column major order
         *
         * |         |         |          |          |
         * | ------- | ------- | -------- |          |
         * | data[0] | data[4] | data[8]  | data[12] |
         * | data[1] | data[5] | data[9]  | data[13] |
         * | data[2] | data[6] | data[10] | data[14] |
         * | data[3] | data[7] | data[11] | data[15] |
         *
         */
        this.data = new Float32Array(16);
        this._scaleSignX = 1;
        this._scaleSignY = 1;
    }
    /**
     * Creates an orthographic (flat non-perspective) projection
     * https://en.wikipedia.org/wiki/Orthographic_projection
     * @param left
     * @param right
     * @param bottom
     * @param top
     * @param near
     * @param far
     */
    static ortho(left, right, bottom, top, near, far) {
        const mat = new Matrix();
        mat.data[0] = 2 / (right - left);
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 2 / (top - bottom);
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = -2 / (far - near);
        mat.data[11] = 0;
        mat.data[12] = -(right + left) / (right - left);
        mat.data[13] = -(top + bottom) / (top - bottom);
        mat.data[14] = -(far + near) / (far - near);
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a new Matrix with the same data as the current 4x4
     */
    clone() {
        const mat = new Matrix();
        mat.data[0] = this.data[0];
        mat.data[1] = this.data[1];
        mat.data[2] = this.data[2];
        mat.data[3] = this.data[3];
        mat.data[4] = this.data[4];
        mat.data[5] = this.data[5];
        mat.data[6] = this.data[6];
        mat.data[7] = this.data[7];
        mat.data[8] = this.data[8];
        mat.data[9] = this.data[9];
        mat.data[10] = this.data[10];
        mat.data[11] = this.data[11];
        mat.data[12] = this.data[12];
        mat.data[13] = this.data[13];
        mat.data[14] = this.data[14];
        mat.data[15] = this.data[15];
        return mat;
    }
    /**
     * Creates a new identity matrix (a matrix that when applied does nothing)
     */
    static identity() {
        const mat = new Matrix();
        mat.data[0] = 1;
        mat.data[1] = 0;
        mat.data[2] = 0;
        mat.data[3] = 0;
        mat.data[4] = 0;
        mat.data[5] = 1;
        mat.data[6] = 0;
        mat.data[7] = 0;
        mat.data[8] = 0;
        mat.data[9] = 0;
        mat.data[10] = 1;
        mat.data[11] = 0;
        mat.data[12] = 0;
        mat.data[13] = 0;
        mat.data[14] = 0;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new translation matrix at the specified 3d point
     * @param x
     * @param y
     */
    static translation(x, y) {
        const mat = Matrix.identity();
        mat.data[12] = x;
        mat.data[13] = y;
        return mat;
    }
    /**
     * Creates a brand new scaling matrix with the specified scaling factor
     * @param sx
     * @param sy
     */
    static scale(sx, sy) {
        const mat = Matrix.identity();
        mat.data[0] = sx;
        mat.data[5] = sy;
        mat.data[10] = 1;
        mat.data[15] = 1;
        return mat;
    }
    /**
     * Creates a brand new rotation matrix with the specified angle
     * @param angleRadians
     */
    static rotation(angleRadians) {
        const mat = Matrix.identity();
        mat.data[0] = Math.cos(angleRadians);
        mat.data[4] = -Math.sin(angleRadians);
        mat.data[1] = Math.sin(angleRadians);
        mat.data[5] = Math.cos(angleRadians);
        return mat;
    }
    multv(other) {
        const z = 0;
        if (other instanceof Vector) {
            return new Vector(other.x * this.data[0] + other.y * this.data[4] + z * this.data[6] + 1 * this.data[12], other.x * this.data[1] + other.y * this.data[5] + z * this.data[9] + 1 * this.data[13]);
        }
        else {
            const dest = [
                other[0] * this.data[0] + other[1] * this.data[4] + z * this.data[6] + 1 * this.data[12],
                other[0] * this.data[1] + other[1] * this.data[5] + z * this.data[9] + 1 * this.data[13]
            ];
            return dest;
        }
    }
    /**
     * Multiplies the current matrix by another and returns the resulting matrix
     * @param other
     */
    multm(other) {
        const dest = new Matrix();
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const a13 = this.data[8];
        const a23 = this.data[9];
        const a33 = this.data[10];
        const a43 = this.data[11];
        const a14 = this.data[12];
        const a24 = this.data[13];
        const a34 = this.data[14];
        const a44 = this.data[15];
        const b11 = other.data[0];
        const b21 = other.data[1];
        const b31 = other.data[2];
        const b41 = other.data[3];
        const b12 = other.data[4];
        const b22 = other.data[5];
        const b32 = other.data[6];
        const b42 = other.data[7];
        const b13 = other.data[8];
        const b23 = other.data[9];
        const b33 = other.data[10];
        const b43 = other.data[11];
        const b14 = other.data[12];
        const b24 = other.data[13];
        const b34 = other.data[14];
        const b44 = other.data[15];
        dest.data[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        dest.data[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        dest.data[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        dest.data[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        dest.data[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        dest.data[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        dest.data[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        dest.data[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        dest.data[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        dest.data[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        dest.data[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        dest.data[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        dest.data[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        dest.data[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        dest.data[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        dest.data[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        const s = this.getScale();
        dest._scaleSignX = sign(s.x) * sign(dest._scaleSignX);
        dest._scaleSignY = sign(s.y) * sign(dest._scaleSignY);
        return dest;
    }
    /**
     * Applies translation to the current matrix mutating it
     * @param x
     * @param y
     */
    translate(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const a13 = this.data[8];
        const a23 = this.data[9];
        const a33 = this.data[10];
        const a43 = this.data[11];
        const a14 = this.data[12];
        const a24 = this.data[13];
        const a34 = this.data[14];
        const a44 = this.data[15];
        // Doesn't change z
        const z = 0;
        const w = 1;
        this.data[12] = a11 * x + a12 * y + a13 * z + a14 * w;
        this.data[13] = a21 * x + a22 * y + a23 * z + a24 * w;
        this.data[14] = a31 * x + a32 * y + a33 * z + a34 * w;
        this.data[15] = a41 * x + a42 * y + a43 * z + a44 * w;
        return this;
    }
    setPosition(x, y) {
        this.data[12] = x;
        this.data[13] = y;
    }
    getPosition() {
        return vec(this.data[12], this.data[13]);
    }
    /**
     * Applies rotation to the current matrix mutating it
     * @param angle in Radians
     */
    rotate(angle) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * a11 + sine * a12;
        this.data[1] = cosine * a21 + sine * a22;
        this.data[2] = cosine * a31 + sine * a32;
        this.data[3] = cosine * a41 + sine * a42;
        this.data[4] = cosine * a12 - sine * a11;
        this.data[5] = cosine * a22 - sine * a21;
        this.data[6] = cosine * a32 - sine * a31;
        this.data[7] = cosine * a42 - sine * a41;
        return this;
    }
    /**
     * Applies scaling to the current matrix mutating it
     * @param x
     * @param y
     */
    scale(x, y) {
        const a11 = this.data[0];
        const a21 = this.data[1];
        const a31 = this.data[2];
        const a41 = this.data[3];
        const a12 = this.data[4];
        const a22 = this.data[5];
        const a32 = this.data[6];
        const a42 = this.data[7];
        this.data[0] = a11 * x;
        this.data[1] = a21 * x;
        this.data[2] = a31 * x;
        this.data[3] = a41 * x;
        this.data[4] = a12 * y;
        this.data[5] = a22 * y;
        this.data[6] = a32 * y;
        this.data[7] = a42 * y;
        return this;
    }
    setRotation(angle) {
        const currentScale = this.getScale();
        const sine = Math.sin(angle);
        const cosine = Math.cos(angle);
        this.data[0] = cosine * currentScale.x;
        this.data[1] = sine * currentScale.y;
        this.data[4] = -sine * currentScale.x;
        this.data[5] = cosine * currentScale.y;
    }
    getRotation() {
        const angle = Math.atan2(this.data[1] / this.getScaleY(), this.data[0] / this.getScaleX());
        return canonicalizeAngle(angle);
    }
    getScaleX() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const xscale = vec(this.data[0], this.data[4]).size;
        return this._scaleSignX * xscale;
    }
    getScaleY() {
        // absolute scale of the matrix (we lose sign so need to add it back)
        const yscale = vec(this.data[1], this.data[5]).size;
        return this._scaleSignY * yscale;
    }
    /**
     * Get the scale of the matrix
     */
    getScale() {
        return vec(this.getScaleX(), this.getScaleY());
    }
    setScaleX(val) {
        this._scaleSignX = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const xscale = vec(this.data[0] * this._scaleSignX, this.data[4] * this._scaleSignX).normalize();
        this.data[0] = xscale.x * val;
        this.data[4] = xscale.y * val;
    }
    setScaleY(val) {
        this._scaleSignY = sign(val);
        // negative scale acts like a 180 rotation, so flip
        const yscale = vec(this.data[1] * this._scaleSignY, this.data[5] * this._scaleSignY).normalize();
        this.data[1] = yscale.x * val;
        this.data[5] = yscale.y * val;
    }
    setScale(scale) {
        this.setScaleX(scale.x);
        this.setScaleY(scale.y);
    }
    /**
     * Determinant of the upper left 2x2 matrix
     */
    getBasisDeterminant() {
        return this.data[0] * this.data[5] - this.data[1] * this.data[4];
    }
    getAffineInverse() {
        // See http://negativeprobability.blogspot.com/2011/11/affine-transformations-and-their.html
        // See https://www.mathsisfun.com/algebra/matrix-inverse.html
        // Since we are actually only doing 2D transformations we can use this hack
        // We don't actually use the 3rd or 4th dimension
        const det = this.getBasisDeterminant();
        const inverseDet = 1 / det; // todo zero check
        const a = this.data[0];
        const b = this.data[4];
        const c = this.data[1];
        const d = this.data[5];
        const m = Matrix.identity();
        // inverts rotation and scale
        m.data[0] = d * inverseDet;
        m.data[1] = -c * inverseDet;
        m.data[4] = -b * inverseDet;
        m.data[5] = a * inverseDet;
        const tx = this.data[12];
        const ty = this.data[13];
        // invert translation
        // transform translation into the matrix basis created by rot/scale
        m.data[12] = -(tx * m.data[0] + ty * m.data[4]);
        m.data[13] = -(tx * m.data[1] + ty * m.data[5]);
        return m;
    }
    isIdentity() {
        return (this.data[0] === 1 &&
            this.data[1] === 0 &&
            this.data[2] === 0 &&
            this.data[3] === 0 &&
            this.data[4] === 0 &&
            this.data[5] === 1 &&
            this.data[6] === 0 &&
            this.data[7] === 0 &&
            this.data[8] === 0 &&
            this.data[9] === 0 &&
            this.data[10] === 1 &&
            this.data[11] === 0 &&
            this.data[12] === 0 &&
            this.data[13] === 0 &&
            this.data[14] === 0 &&
            this.data[15] === 1);
    }
    toString() {
        return `
[${this.data[0]} ${this.data[4]} ${this.data[8]} ${this.data[12]}]
[${this.data[1]} ${this.data[5]} ${this.data[9]} ${this.data[13]}]
[${this.data[2]} ${this.data[6]} ${this.data[10]} ${this.data[14]}]
[${this.data[3]} ${this.data[7]} ${this.data[11]} ${this.data[15]}]
`;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/transform-stack.ts

class TransformStack {
    constructor() {
        this._transforms = [];
        this._currentTransform = Matrix.identity();
    }
    save() {
        this._transforms.push(this._currentTransform);
        this._currentTransform = this._currentTransform.clone();
    }
    restore() {
        this._currentTransform = this._transforms.pop();
    }
    translate(x, y) {
        return this._currentTransform.translate(x, y);
    }
    rotate(angle) {
        return this._currentTransform.rotate(angle);
    }
    scale(x, y) {
        return this._currentTransform.scale(x, y);
    }
    set current(matrix) {
        this._currentTransform = matrix;
    }
    get current() {
        return this._currentTransform;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/state-stack.ts
class StateStack {
    constructor() {
        this._states = [];
        this._currentState = this._getDefaultState();
    }
    _getDefaultState() {
        return {
            opacity: 1
        };
    }
    _cloneState() {
        return {
            opacity: this._currentState.opacity
        };
    }
    save() {
        this._states.push(this._currentState);
        this._currentState = this._cloneState();
    }
    restore() {
        this._currentState = this._states.pop();
    }
    get current() {
        return this._currentState;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shader.ts
/**
 * Create a shader program for the Excalibur WebGL Graphics Context
 */
class Shader {
    /**
     * Create a shader program in excalibur
     * @param _gl WebGL graphics context
     * @param _vertexSource Vertex shader source as a string
     * @param _fragmentSource Fragment shader source as a string
     */
    constructor(_gl, _vertexSource, _fragmentSource) {
        this._gl = _gl;
        this._vertexSource = _vertexSource;
        this._fragmentSource = _fragmentSource;
        this.program = null;
        this.uniforms = {};
        this.attributes = {};
        this.layout = [];
        this.compile(_gl);
    }
    _createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        if (program === null) {
            throw Error('Could not create graphics shader program');
        }
        // attach the shaders.
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        // link the program.
        gl.linkProgram(program);
        const success = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!success) {
            throw Error(`Could not link the program: [${gl.getProgramInfoLog(program)}]`);
        }
        return program;
    }
    _compileShader(gl, source, type) {
        const shader = gl.createShader(type);
        if (shader === null) {
            throw Error(`Could not build shader: [${source}]`);
        }
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        const success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!success) {
            throw Error(`Could not compile shader [${gl.getShaderInfoLog(shader)}]`);
        }
        return shader;
    }
    /**
     * Compile the current shader against a webgl context
     * @param gl WebGL context
     */
    compile(gl) {
        const vertexShader = this._compileShader(gl, this._vertexSource, gl.VERTEX_SHADER);
        const fragmentShader = this._compileShader(gl, this._fragmentSource, gl.FRAGMENT_SHADER);
        const program = this._createProgram(gl, vertexShader, fragmentShader);
        return (this.program = program);
    }
    /**
     * Add a uniform [[Matrix]] to the shader
     * @param name Name of the uniform in the shader source
     * @param data (4x4) matrix in column major order
     */
    addUniformMatrix(name, data) {
        if (!data) {
            throw Error(`Shader Uniform Matrix '${name}' was set to null or undefined`);
        }
        const gl = this._gl;
        this.uniforms[name] = {
            name,
            type: 'matrix',
            location: gl.getUniformLocation(this.program, name),
            data: data
        };
    }
    /**
     * Add a uniform array of numbers to the shader
     * @param name Name of the uniform in the shader source
     * @param data List of numbers
     */
    addUniformIntegerArray(name, data) {
        if (!data) {
            throw Error(`Shader Uniform Integery Array '${name}' was set to null or undefined`);
        }
        const gl = this._gl;
        this.uniforms[name] = {
            name,
            type: 'numbers',
            location: gl.getUniformLocation(this.program, name),
            data: data
        };
    }
    /**
     * Add attributes in the order they appear in the VBO
     * @param name Name of the attribute in the shader source
     * @param size The size of the attribute in gl.Type units, for example `vec2 a_pos` would be 2 gl.FLOAT
     * @param glType The gl.Type of the attribute
     */
    addAttribute(name, size, glType, normalized = false) {
        const gl = this._gl;
        // TODO needs to be compiled first
        const location = gl.getAttribLocation(this.program, name);
        this.attributes[name] = {
            name,
            size,
            glType,
            normalized,
            location
        };
        this.layout.push(this.attributes[name]);
    }
    /**
     * Number of javascript floats a vertex will take up
     */
    get vertexAttributeSize() {
        let vertexSize = 0;
        for (const vert of this.layout) {
            vertexSize += vert.size;
        }
        return vertexSize;
    }
    /**
     * Total number of bytes that the vertex will take up
     */
    get totalVertexSizeBytes() {
        let vertexSize = 0;
        for (const vert of this.layout) {
            let typeSize = 1;
            switch (vert.glType) {
                case this._gl.FLOAT: {
                    typeSize = 4;
                    break;
                }
                default: {
                    typeSize = 1;
                }
            }
            vertexSize += typeSize * vert.size;
        }
        return vertexSize;
    }
    /**
     * Get a previously defined attribute size in bytes
     * @param name
     */
    getAttributeSize(name) {
        let typeSize = 1;
        switch (this.attributes[name].glType) {
            case this._gl.FLOAT: {
                typeSize = 4;
                break;
            }
            default: {
                typeSize = 1;
            }
        }
        return typeSize * this.attributes[name].size;
    }
    /**
     * Sets this shader program as the current in the underlying webgl context
     *
     * **Must** specify all attributes and uniforms before calling this
     */
    use() {
        const gl = this._gl;
        gl.useProgram(this.program);
        let offset = 0;
        for (const vert of this.layout) {
            gl.vertexAttribPointer(vert.location, vert.size, vert.glType, vert.normalized, this.totalVertexSizeBytes, offset);
            gl.enableVertexAttribArray(vert.location);
            offset += this.getAttributeSize(vert.name);
        }
        for (const key in this.uniforms) {
            const uniform = this.uniforms[key];
            switch (uniform.type) {
                case 'matrix': {
                    gl.uniformMatrix4fv(uniform.location, false, uniform.data);
                    break;
                }
                case 'numbers': {
                    gl.uniform1iv(uniform.location, uniform.data);
                    break;
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shaders/line-vertex.glsl
/* harmony default export */ const line_vertex = ("attribute vec4 a_position;\r\nattribute vec4 a_color;\r\n\r\nvarying lowp vec4 v_color;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * a_position;\r\n\r\n   // Passthrough the color\r\n   v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/shaders/line-fragment.glsl
/* harmony default export */ const line_fragment = ("precision mediump float;\r\n\r\n// Color\r\nvarying lowp vec4 v_color;\r\n\r\n\r\nvoid main() {\r\n  gl_FragColor = v_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/batch.ts
class BatchCommand {
    constructor(max) {
        this.max = max;
        this._pool = undefined;
        this.commands = [];
    }
    isFull() {
        if (this.commands.length >= this.max) {
            return true;
        }
        return false;
    }
    canAdd() {
        return !this.isFull();
    }
    add(cmd) {
        this.commands.push(cmd);
    }
    dispose() {
        this.commands.length = 0;
        return this;
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsDiagnostics.ts
class GraphicsDiagnostics {
    static clear() {
        GraphicsDiagnostics.DrawCallCount = 0;
        GraphicsDiagnostics.DrawnImagesCount = 0;
    }
}
GraphicsDiagnostics.DrawCallCount = 0;
GraphicsDiagnostics.DrawnImagesCount = 0;

;// CONCATENATED MODULE: ./Util/Pool.ts

class Pool {
    constructor(builder, recycler, maxObjects = 100) {
        this.builder = builder;
        this.recycler = recycler;
        this.maxObjects = maxObjects;
        this.totalAllocations = 0;
        this.index = 0;
        this.objects = [];
        this._logger = Logger.getInstance();
    }
    /**
     * Use many instances out of the in the context and return all to the pool.
     *
     * By returning values out of the contex they will be un-hooked from the pool and are free to be passed to consumers
     * @param context
     */
    using(context) {
        const result = context(this);
        if (result) {
            return this.done(...result);
        }
        return this.done();
    }
    /**
     * Use a single instance out of th pool and immediately return it to the pool
     * @param context
     */
    borrow(context) {
        const object = this.get();
        context(object);
        this.index--;
    }
    /**
     * Retrieve a value from the pool, will allocate a new instance if necessary or recycle from the pool
     * @param args
     */
    get(...args) {
        if (this.index === this.maxObjects) {
            // TODO implement hard or soft cap
            this._logger.warn('Max pooled objects reached, possible memory leak? Doubling');
            this.maxObjects = this.maxObjects * 2;
            // throw new Error('Max pooled objects reached, possible memory leak?');
        }
        if (this.objects[this.index]) {
            // Pool has an available object already constructed
            return this.recycler(this.objects[this.index++], ...args);
        }
        else {
            // New allocation
            this.totalAllocations++;
            const object = (this.objects[this.index++] = this.builder(...args));
            object._pool = this;
            return object;
        }
    }
    done(...objects) {
        // All objects in pool now considered "free"
        this.index = 0;
        for (const object of objects) {
            const poolIndex = this.objects.indexOf(object);
            // Build a new object to take the pool place
            this.objects[poolIndex] = this.builder(); // TODO problematic 0-arg only support
            this.objects[poolIndex]._pool = this;
            this.totalAllocations++;
            // Unhook object from the pool
            object._pool = undefined;
        }
        return objects;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/renderer.ts

// import { Pool, Poolable } from './pool';


class BatchRenderer {
    constructor(options) {
        var _a, _b, _c;
        this.priority = 0;
        this._buffer = null;
        this._maxCommandsPerBatch = 2000;
        this._batches = [];
        this._gl = options.gl;
        const command = options.command;
        this._verticesPerCommand = (_a = options === null || options === void 0 ? void 0 : options.verticesPerCommand) !== null && _a !== void 0 ? _a : 1;
        this._maxCommandsPerBatch = (_b = options === null || options === void 0 ? void 0 : options.maxCommandsPerBatch) !== null && _b !== void 0 ? _b : this._maxCommandsPerBatch;
        const batchFactory = (_c = options === null || options === void 0 ? void 0 : options.batchFactory) !== null && _c !== void 0 ? _c : (() => new BatchCommand(this._maxCommandsPerBatch));
        this.commands = new Pool(() => new command(), (c) => c.dispose(), this._maxCommandsPerBatch);
        this._batchPool = new Pool(batchFactory, (b) => b.dispose(), 100);
    }
    /**
     * Initialize render, builds shader and initialized webgl buffers
     */
    init() {
        const gl = this._gl;
        this.shader = this.buildShader(gl);
        // Initialize VBO
        // https://groups.google.com/forum/#!topic/webgl-dev-list/vMNXSNRAg8M
        this._vertices = new Float32Array(this.shader.vertexAttributeSize * this._verticesPerCommand * this._maxCommandsPerBatch);
        this._buffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
        gl.bufferData(gl.ARRAY_BUFFER, this._vertices, gl.DYNAMIC_DRAW);
    }
    get vertexSize() {
        return this.shader.vertexAttributeSize;
    }
    addCommand(cmd) {
        if (this._batches.length === 0) {
            this._batches.push(this._batchPool.get());
        }
        const lastBatch = this._batches[this._batches.length - 1];
        if (lastBatch.canAdd()) {
            lastBatch.add(cmd);
        }
        else {
            const newBatch = this._batchPool.get();
            newBatch.add(cmd);
            this._batches.push(newBatch);
        }
    }
    /**
     * Build batch geometry, submit to the gpu, and issue draw command to underlying webgl
     */
    render() {
        const gl = this._gl;
        gl.bindBuffer(gl.ARRAY_BUFFER, this._buffer);
        this.shader.use();
        let drawCallCount = 0;
        let drawnImagesCount = 0;
        for (const batch of this._batches) {
            // Build all geometry and ship to GPU
            // interleave VBOs https://goharsha.com/lwjgl-tutorial-series/interleaving-buffer-objects/
            const vertexCount = this.buildBatchVertices(this._vertices, batch);
            gl.bufferSubData(gl.ARRAY_BUFFER, 0, this._vertices);
            this.renderBatch(gl, batch, vertexCount);
            drawnImagesCount += batch.commands.length;
            drawCallCount++;
        }
        this.commands.done();
        this._batchPool.done();
        this._batches.length = 0;
        GraphicsDiagnostics.DrawCallCount += drawCallCount;
        GraphicsDiagnostics.DrawnImagesCount += drawnImagesCount;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/line-renderer.ts






class DrawLine {
    constructor() {
        this.color = Color.Black;
        this.start = Vector.Zero;
        this.end = Vector.Zero;
    }
    dispose() {
        this.color.r = 0;
        this.color.g = 0;
        this.color.b = 0;
        this.color.a = 1;
        this.start.setTo(0, 0);
        this.end.setTo(0, 0);
        return this;
    }
}
class LineRenderer extends BatchRenderer {
    constructor(gl, _contextInfo) {
        super({ gl, command: DrawLine, verticesPerCommand: 2 });
        this._contextInfo = _contextInfo;
        this.init();
    }
    buildShader(gl) {
        const shader = new Shader(gl, line_vertex, line_fragment);
        shader.addAttribute('a_position', 2, gl.FLOAT);
        shader.addAttribute('a_color', 4, gl.FLOAT);
        shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);
        return shader;
    }
    addLine(start, end, color) {
        const cmd = this.commands.get();
        cmd.start = this._contextInfo.transform.current.multv(start);
        cmd.end = this._contextInfo.transform.current.multv(end);
        cmd.color.r = color.r;
        cmd.color.g = color.g;
        cmd.color.b = color.b;
        cmd.color.a = cmd.color.a * this._contextInfo.state.current.opacity;
        this.addCommand(cmd);
    }
    buildBatchVertices(vertexBuffer, batch) {
        let index = 0;
        for (const command of batch.commands) {
            // Start
            vertexBuffer[index++] = command.start.x;
            vertexBuffer[index++] = command.start.y;
            vertexBuffer[index++] = command.color.r / 255;
            vertexBuffer[index++] = command.color.g / 255;
            vertexBuffer[index++] = command.color.b / 255;
            vertexBuffer[index++] = command.color.a;
            // End
            vertexBuffer[index++] = command.end.x;
            vertexBuffer[index++] = command.end.y;
            vertexBuffer[index++] = command.color.r / 255;
            vertexBuffer[index++] = command.color.g / 255;
            vertexBuffer[index++] = command.color.b / 255;
            vertexBuffer[index++] = command.color.a;
        }
        return index / this.vertexSize;
    }
    renderBatch(gl, _batch, vertexCount) {
        gl.drawArrays(gl.LINES, 0, vertexCount);
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shaders/image-vertex.glsl
/* harmony default export */ const image_vertex = ("attribute vec4 a_position;\r\n\r\n// Opacity \r\nattribute float a_opacity;\r\nvarying float v_opacity;\r\n\r\nattribute vec4 a_color;\r\nvarying vec4 v_color;\r\n\r\n// UV coordinate\r\nattribute vec2 a_texcoord;\r\nvarying vec2 v_texcoord;\r\n\r\n// Texture number\r\nattribute lowp float a_textureIndex;\r\nvarying lowp float v_textureIndex;\r\n\r\nuniform mat4 u_matrix;\r\n\r\n\r\nvoid main() {\r\n   // Set the vertex position using the ortho transform matrix\r\n   gl_Position = u_matrix * a_position;\r\n\r\n   // Pass through the Opacity to the fragment shader\r\n   v_opacity = a_opacity;\r\n   // Pass through the UV coord to the fragment shader\r\n   v_texcoord = a_texcoord;\r\n   // Pass through the texture number to the fragment shader\r\n   v_textureIndex = a_textureIndex;\r\n   // Pass through the color to the fragment shader\r\n   v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/shaders/image-fragment.glsl
/* harmony default export */ const image_fragment = ("#ifdef GL_OES_standard_derivatives\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\nprecision mediump float;\r\n\r\n// UV coord\r\nvarying vec2 v_texcoord;\r\n\r\n// Texture index\r\nvarying lowp float v_textureIndex;\r\n\r\n// Color coord to blend with image\r\nvarying lowp vec4 v_color;\r\n\r\n// Opacity\r\nvarying float v_opacity;\r\n\r\nuniform sampler2D u_textures[%%count%%];\r\n\r\nfloat circle(in vec2 st, in float radius) {\r\n  vec2 dist = st - vec2(0.5);\r\n  float r = dot(dist, dist) * 4.0;\r\n  float delta = fwidth(r);\r\n  return 1.0 - smoothstep(radius - delta, radius + delta, r);\r\n}\r\n\r\nvoid main() {\r\n  float r = 0.0, delta = 0.0, alpha = 1.0;\r\n   // In order to support the most efficient sprite batching, we have multiple\r\n   // textures loaded into the gpu (usually 8) this picker logic skips over textures\r\n   // that do not apply to a particular sprite.\r\n\r\n   vec4 color;\r\n   // -1 If there is no texture to sample we are drawing a solid geometry (rectangles)\r\n   if (v_textureIndex == -1.0) {\r\n     color = v_color;\r\n     color.w = color.w * v_opacity;\r\n   // -2 If there is no texture we are drawing a circle\r\n   } else if (v_textureIndex == -2.0) {\r\n     color = v_color;\r\n     color.a = color.a * circle(v_texcoord, .95);\r\n   } else {\r\n     // GLSL is templated out to pick the right texture and set the vec4 color\r\n      %%texture_picker%%\r\n   }\r\n   color.w = color.w * v_opacity;\r\n   gl_FragColor = color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/draw-image-command.ts

var DrawCommandType;
(function (DrawCommandType) {
    DrawCommandType["Image"] = "image";
    DrawCommandType["Line"] = "line";
    DrawCommandType["Rectangle"] = "rectangle";
    DrawCommandType["Circle"] = "circle";
})(DrawCommandType || (DrawCommandType = {}));
class DrawImageCommand {
    constructor(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        this._pool = undefined;
        this.snapToPixel = true;
        this.type = DrawCommandType.Image;
        this.opacity = 1;
        this.width = 0;
        this.height = 0;
        this.dest = [0, 0]; // x, y
        this.view = [0, 0, 0, 0]; // sx, sy, sw, sh
        this._geom = [
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0],
            [0, 0]
        ];
        this.init(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
    }
    init(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        this.type = DrawCommandType.Image;
        this.image = image;
        this.width = (image === null || image === void 0 ? void 0 : image.width) || swidth || 0;
        this.height = (image === null || image === void 0 ? void 0 : image.height) || sheight || 0;
        this.view = [0, 0, swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width, sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height];
        this.dest = [sx, sy];
        // If destination is specified, update view and dest
        if (dx !== undefined && dy !== undefined && dwidth !== undefined && dheight !== undefined) {
            this.view = [sx, sy, swidth !== null && swidth !== void 0 ? swidth : image === null || image === void 0 ? void 0 : image.width, sheight !== null && sheight !== void 0 ? sheight : image === null || image === void 0 ? void 0 : image.height];
            this.dest = [dx, dy];
            this.width = dwidth;
            this.height = dheight;
        }
        let index = 0;
        this._geom[index++] = [this.dest[0], this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1] + this.height];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    initRect(color, start, width, height) {
        this.type = DrawCommandType.Rectangle;
        this.color = color;
        this.width = width;
        this.height = height;
        let index = 0;
        this._geom[index++] = [start.x, start.y];
        this._geom[index++] = [start.x, start.y + this.height];
        this._geom[index++] = [start.x + this.width, start.y];
        this._geom[index++] = [start.x + this.width, start.y];
        this._geom[index++] = [start.x, start.y + this.height];
        this._geom[index++] = [start.x + this.width, start.y + this.height];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    initLine(color, start, end, thickness) {
        this.type = DrawCommandType.Line;
        this.color = color;
        const dir = end.sub(start).normalize();
        const normal = dir.perpendicular();
        const halfThick = thickness / 2;
        const startTop = normal.scale(halfThick).add(start);
        const startBottom = normal.scale(-halfThick).add(start);
        const endTop = normal.scale(halfThick).add(end);
        const endBottom = normal.scale(-halfThick).add(end);
        /**
         *    +---------------------^----------------------+
         *    |                     | (normal)             |
         *   (startx, starty)------------------>(endx, endy)
         *    |                                            |
         *    + -------------------------------------------+
         */
        let index = 0;
        this._geom[index++] = [startTop.x, startTop.y];
        this._geom[index++] = [endTop.x, endTop.y];
        this._geom[index++] = [startBottom.x, startBottom.y];
        this._geom[index++] = [startBottom.x, startBottom.y];
        this._geom[index++] = [endTop.x, endTop.y];
        this._geom[index++] = [endBottom.x, endBottom.y];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    initCircle(pos, radius, color) {
        this.type = DrawCommandType.Circle;
        this.color = color;
        const topLeft = pos.add(vec(-radius, -radius));
        const topRight = pos.add(vec(radius, -radius));
        const bottomRight = pos.add(vec(radius, radius));
        const bottomLeft = pos.add(vec(-radius, radius));
        let index = 0;
        this._geom[index++] = [topLeft.x, topLeft.y];
        this._geom[index++] = [topRight.x, topRight.y];
        this._geom[index++] = [bottomLeft.x, bottomLeft.y];
        this._geom[index++] = [bottomLeft.x, bottomLeft.y];
        this._geom[index++] = [topRight.x, topRight.y];
        this._geom[index++] = [bottomRight.x, bottomRight.y];
        if (this.snapToPixel) {
            for (const point of this._geom) {
                point[0] = ~~point[0];
                point[1] = ~~point[1];
            }
        }
        return this;
    }
    dispose() {
        this.image = null;
        this.width = 0;
        this.height = 0;
        this.view = [0, 0, 0, 0];
        this.dest = [0, 0];
        let index = 0;
        this._geom[index++] = [this.dest[0], this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1]];
        this._geom[index++] = [this.dest[0], this.dest[1] + this.height];
        this._geom[index++] = [this.dest[0] + this.width, this.dest[1] + this.height];
        return this;
    }
    // todo weird
    applyTransform(transform, opacity) {
        if (transform) {
            for (let i = 0; i < this._geom.length; i++) {
                this._geom[i] = transform.multv(this._geom[i]);
                if (this.snapToPixel) {
                    this._geom[i] = [~~this._geom[i][0], ~~this._geom[i][1]];
                }
            }
        }
        this.opacity = opacity;
    }
    get geometry() {
        return this._geom;
    }
}
class DrawRectCommand {
    constructor(x, y, width, height) {
        this.dest = [0, 0];
        this.width = 0;
        this.height = 0;
        this.dest = [x, y];
        this.width = width;
        this.height = height;
    }
}
class DrawDebugRectCommand {
    constructor(bounds, color) {
        this.bounds = bounds;
        this.color = color;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/webgl-util.ts
/**
 * Checks if the current number is a power of two
 */
function isPowerOfTwo(x) {
    return (x & (x - 1)) === 0;
}
/**
 * Returns the next highest power of two
 */
function nextHighestPowerOfTwo(x) {
    --x;
    for (let i = 1; i < 32; i <<= 1) {
        x = x | (x >> i);
    }
    return x + 1;
}
/**
 * Returns the input number if a power of two, otherwise the next highest power of two
 */
function ensurePowerOfTwo(x) {
    if (!isPowerOfTwo(x)) {
        return nextHighestPowerOfTwo(x);
    }
    return x;
}

;// CONCATENATED MODULE: ./Graphics/Context/texture-loader.ts

/**
 * Manages loading image sources into webgl textures, a unique id is associated with all sources
 */
class TextureLoader {
    static registerContext(context) {
        TextureLoader._GL = context;
    }
    /**
     * Get the WebGL Texture from a source image
     * @param image
     */
    static get(image) {
        return TextureLoader._TEXTURE_MAP.get(image);
    }
    /**
     * Returns whether a source image has been loaded as a texture
     * @param image
     */
    static has(image) {
        return TextureLoader._TEXTURE_MAP.has(image);
    }
    /**
     * Loads a graphic into webgl and returns it's texture info, a webgl context must be previously registered
     * @param image Source graphic
     * @param forceUpdate Optionally force a texture to be reloaded, useful if the source graphic has changed
     */
    static load(image, forceUpdate = false) {
        // Ignore loading if webgl is not registered
        const gl = TextureLoader._GL;
        if (!gl) {
            return null;
        }
        let tex = null;
        // If reuse the texture if it's from the same source
        if (TextureLoader.has(image)) {
            tex = TextureLoader.get(image);
        }
        // Update existing webgl texture and return early
        if (tex) {
            if (forceUpdate) {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                const source = TextureLoader.toPowerOfTwoImage(image);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
            }
            return tex;
        }
        // No texture exists create a new one
        tex = gl.createTexture();
        const source = TextureLoader.toPowerOfTwoImage(image);
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        // NEAREST for pixels
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, source);
        TextureLoader._TEXTURE_MAP.set(image, tex);
        return tex;
    }
    /**
     * Converts source images into power of two images, WebGL only supports POT images
     * https://www.khronos.org/webgl/wiki/WebGL_and_OpenGL_Differences#Non-Power_of_Two_Texture_Support
     * @param image
     */
    static toPowerOfTwoImage(image) {
        const potCanvas = TextureLoader._POT_CANVAS;
        const potCtx = TextureLoader._POT_CTX;
        if (!isPowerOfTwo(image.width) || !isPowerOfTwo(image.height)) {
            // Scale up the texture to the next highest power of two dimensions.
            potCanvas.width = ensurePowerOfTwo(image.width);
            potCanvas.height = ensurePowerOfTwo(image.height);
            potCtx.imageSmoothingEnabled = false;
            potCtx.clearRect(0, 0, potCanvas.width, potCanvas.height);
            potCtx.drawImage(image, 0, 0, image.width, image.height);
            image = potCanvas;
        }
        return image;
    }
}
TextureLoader._POT_CANVAS = document.createElement('canvas');
TextureLoader._POT_CTX = TextureLoader._POT_CANVAS.getContext('2d');
TextureLoader._TEXTURE_MAP = new Map();

;// CONCATENATED MODULE: ./Graphics/Context/image-renderer.ts









class BatchImage extends BatchCommand {
    constructor(maxDraws, maxTextures) {
        super(maxDraws);
        this.maxDraws = maxDraws;
        this.maxTextures = maxTextures;
        this.textures = [];
        this.commands = [];
        this._graphicMap = {};
    }
    isFull() {
        if (this.commands.length >= this.maxDraws) {
            return true;
        }
        if (this.textures.length >= this.maxTextures) {
            return true;
        }
        return false;
    }
    canAdd() {
        if (this.commands.length >= this.maxDraws) {
            return false;
        }
        if (this.textures.length < this.maxTextures) {
            return true;
        }
        return false;
    }
    _isCommandFull() {
        return this.commands.length >= this.maxDraws;
    }
    _isTextureFull() {
        return this.textures.length >= this.maxTextures;
    }
    _wouldAddTexture(command) {
        return !this._graphicMap[command.image.id];
    }
    maybeAdd(command) {
        if ((this._isCommandFull() || this._isTextureFull()) && this._wouldAddTexture(command)) {
            return false;
        }
        this.add(command);
        return true;
    }
    add(command) {
        if (command.type === DrawCommandType.Image) {
            const texture = TextureLoader.load(command.image);
            if (this.textures.indexOf(texture) === -1) {
                this.textures.push(texture);
            }
        }
        this.commands.push(command);
    }
    bindTextures(gl) {
        // Bind textures in the correct order
        for (let i = 0; i < this.maxTextures; i++) {
            gl.activeTexture(gl.TEXTURE0 + i);
            gl.bindTexture(gl.TEXTURE_2D, this.textures[i] || this.textures[0]);
        }
    }
    getBatchTextureId(command) {
        if (command.image) {
            return this.textures.indexOf(TextureLoader.get(command.image));
        }
        return -1;
    }
    dispose() {
        this.clear();
        return this;
    }
    clear() {
        this.commands.length = 0;
        this.textures.length = 0;
        this._graphicMap = {};
    }
}
class ImageRenderer extends BatchRenderer {
    constructor(gl, _contextInfo) {
        super({
            gl,
            command: DrawImageCommand,
            // 6 verts per quad
            verticesPerCommand: 6,
            maxCommandsPerBatch: 2000,
            batchFactory: () => new BatchImage(2000, gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS))
        });
        this._contextInfo = _contextInfo;
        TextureLoader.registerContext(gl);
        this.init();
    }
    buildShader(gl) {
        // Initialilze default batch rendering shader
        const maxGPUTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        const shader = new Shader(gl, image_vertex, this._transformFragmentSource(image_fragment, maxGPUTextures));
        shader.addAttribute('a_position', 3, gl.FLOAT);
        shader.addAttribute('a_texcoord', 2, gl.FLOAT);
        shader.addAttribute('a_textureIndex', 1, gl.FLOAT);
        shader.addAttribute('a_opacity', 1, gl.FLOAT);
        shader.addAttribute('a_color', 4, gl.FLOAT);
        shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);
        // Initialize texture slots to [0, 1, 2, 3, 4, .... maxGPUTextures]
        shader.addUniformIntegerArray('u_textures', [...Array(maxGPUTextures)].map((_, i) => i));
        return shader;
    }
    _transformFragmentSource(source, maxTextures) {
        let newSource = source.replace('%%count%%', maxTextures.toString());
        let texturePickerBuilder = '';
        for (let i = 0; i < maxTextures; i++) {
            if (i === 0) {
                texturePickerBuilder += `if (v_textureIndex <= ${i}.5) {\n`;
            }
            else {
                texturePickerBuilder += `   else if (v_textureIndex <= ${i}.5) {\n`;
            }
            texturePickerBuilder += `      color = texture2D(u_textures[${i}], v_texcoord);\n`;
            texturePickerBuilder += `   }\n`;
        }
        newSource = newSource.replace('%%texture_picker%%', texturePickerBuilder);
        return newSource;
    }
    addCircle(pos, radius, color) {
        const command = this.commands.get().initCircle(pos, radius, color);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    addRectangle(color, pos, width, height) {
        const command = this.commands.get().initRect(color, pos, width, height);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    addLine(color, start, end, thickness = 1) {
        const command = this.commands.get().initLine(color, start, end, thickness);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    addImage(graphic, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        const command = this.commands.get().init(graphic, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
        command.applyTransform(this._contextInfo.transform.current, this._contextInfo.state.current.opacity);
        this.addCommand(command);
    }
    renderBatch(gl, batch, vertexCount) {
        // Bind textures in the correct order
        batch.bindTextures(gl);
        // draw the quads
        gl.drawArrays(gl.TRIANGLES, 0, vertexCount);
    }
    buildBatchVertices(vertexBuffer, batch) {
        var _a, _b;
        let vertIndex = 0;
        let sx = 0;
        let sy = 0;
        let sw = 0;
        let sh = 0;
        let potWidth = 1;
        let potHeight = 1;
        let textureId = 0;
        let commandColor = Color.Transparent;
        for (const command of batch.commands) {
            sx = command.view[0];
            sy = command.view[1];
            sw = command.view[2];
            sh = command.view[3];
            potWidth = ensurePowerOfTwo(((_a = command.image) === null || _a === void 0 ? void 0 : _a.width) || command.width);
            potHeight = ensurePowerOfTwo(((_b = command.image) === null || _b === void 0 ? void 0 : _b.height) || command.height);
            textureId = batch.getBatchTextureId(command);
            if (command.type === DrawCommandType.Line || command.type === DrawCommandType.Rectangle) {
                textureId = -1; // sentinel for no image rect
                commandColor = command.color;
            }
            if (command.type === DrawCommandType.Circle) {
                textureId = -2; // sentinel for circle
                commandColor = command.color;
            }
            // potential optimization when divding by 2 (bitshift)
            // Modifying the images to poweroftwo images warp the UV coordinates
            let uvx0 = sx / potWidth;
            let uvy0 = sy / potHeight;
            let uvx1 = (sx + sw) / potWidth;
            let uvy1 = (sy + sh) / potHeight;
            if (textureId === -2) {
                uvx0 = 0;
                uvy0 = 0;
                uvx1 = 1;
                uvy1 = 1;
            }
            // Quad update
            // (0, 0, z) z-index doesn't work in batch rendering between batches
            vertexBuffer[vertIndex++] = command.geometry[0][0]; // x + 0 * width;
            vertexBuffer[vertIndex++] = command.geometry[0][1]; //y + 0 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx0; // 0;
            vertexBuffer[vertIndex++] = uvy0; // 0;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (0, 1)
            vertexBuffer[vertIndex++] = command.geometry[1][0]; // x + 0 * width;
            vertexBuffer[vertIndex++] = command.geometry[1][1]; // y + 1 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx0; // 0;
            vertexBuffer[vertIndex++] = uvy1; // 1;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (1, 0)
            vertexBuffer[vertIndex++] = command.geometry[2][0]; // x + 1 * width;
            vertexBuffer[vertIndex++] = command.geometry[2][1]; // y + 0 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx1; //1;
            vertexBuffer[vertIndex++] = uvy0; //0;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (1, 0)
            vertexBuffer[vertIndex++] = command.geometry[3][0]; // x + 1 * width;
            vertexBuffer[vertIndex++] = command.geometry[3][1]; // y + 0 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx1; //1;
            vertexBuffer[vertIndex++] = uvy0; //0;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (0, 1)
            vertexBuffer[vertIndex++] = command.geometry[4][0]; // x + 0 * width;
            vertexBuffer[vertIndex++] = command.geometry[4][1]; // y + 1 * height
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx0; // 0;
            vertexBuffer[vertIndex++] = uvy1; // 1;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
            // (1, 1)
            vertexBuffer[vertIndex++] = command.geometry[5][0]; // x + 1 * width;
            vertexBuffer[vertIndex++] = command.geometry[5][1]; // y + 1 * height;
            vertexBuffer[vertIndex++] = 0;
            // UV coords
            vertexBuffer[vertIndex++] = uvx1; // 1;
            vertexBuffer[vertIndex++] = uvy1; // 1;
            // texture id
            vertexBuffer[vertIndex++] = textureId;
            // opacity
            vertexBuffer[vertIndex++] = command.opacity;
            // color
            vertexBuffer[vertIndex++] = commandColor.r / 255;
            vertexBuffer[vertIndex++] = commandColor.g / 255;
            vertexBuffer[vertIndex++] = commandColor.b / 255;
            vertexBuffer[vertIndex++] = commandColor.a;
        }
        return vertIndex / this.vertexSize;
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/shaders/point-vertex.glsl
/* harmony default export */ const point_vertex = ("attribute vec4 a_position;\r\nattribute vec4 a_color;\r\nattribute float a_size;\r\nvarying lowp vec4 v_color;\r\nuniform mat4 u_matrix;\r\n\r\nvoid main() {\r\n  gl_Position = u_matrix * a_position;\r\n  gl_PointSize = a_size * 2.0;\r\n  v_color = a_color;\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/shaders/point-fragment.glsl
/* harmony default export */ const point_fragment = ("#ifdef GL_OES_standard_derivatives\r\n#extension GL_OES_standard_derivatives : enable\r\n#endif\r\n\r\nprecision mediump float;\r\nvarying lowp vec4 v_color;\r\n\r\nvoid main() {\r\n  float r = 0.0, delta = 0.0, alpha = 1.0;\r\n  vec2 cxy = 2.0 * gl_PointCoord - 1.0;\r\n  r = dot(cxy, cxy);\r\n  \r\n#ifdef GL_OES_standard_derivatives\r\n  delta = fwidth(r);\r\n  alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, r);\r\n#else\r\n  if (r > 1.0) {\r\n    discard;\r\n  }\r\n#endif\r\n  gl_FragColor = vec4(v_color.rgb, v_color.a * alpha);\r\n}");
;// CONCATENATED MODULE: ./Graphics/Context/point-renderer.ts






// import { Random } from '../../Math/Index';
class DrawPoint {
    constructor() {
        this.point = Vector.Zero;
        this.color = Color.Black;
        this.size = 1;
    }
    dispose() {
        this.point.setTo(0, 0);
        this.color.r = 0;
        this.color.g = 0;
        this.color.b = 0;
        this.color.a = 1;
        this.size = 1;
        return this;
    }
}
class PointRenderer extends BatchRenderer {
    constructor(gl, _contextInfo) {
        super({ gl, command: DrawPoint, verticesPerCommand: 1 });
        this._contextInfo = _contextInfo;
        this.init();
    }
    buildShader(gl) {
        gl.getExtension('OES_standard_derivatives');
        const shader = new Shader(gl, point_vertex, point_fragment);
        shader.addAttribute('a_position', 2, gl.FLOAT);
        shader.addAttribute('a_color', 4, gl.FLOAT);
        shader.addAttribute('a_size', 1, gl.FLOAT);
        shader.addUniformMatrix('u_matrix', this._contextInfo.matrix.data);
        return shader;
    }
    addPoint(point, color, size) {
        const cmd = this.commands.get();
        cmd.point = this._contextInfo.transform.current.multv(point);
        cmd.color.r = color.r;
        cmd.color.g = color.g;
        cmd.color.b = color.b;
        cmd.color.a = color.a * this._contextInfo.state.current.opacity;
        cmd.size = size * Math.max(this._contextInfo.transform.current.getScaleX(), this._contextInfo.transform.current.getScaleY());
        this.addCommand(cmd);
    }
    buildBatchVertices(vertexBuffer, batch) {
        let index = 0;
        for (const command of batch.commands) {
            vertexBuffer[index++] = command.point.x;
            vertexBuffer[index++] = command.point.y;
            // normalize to [0, 1] for webgl
            vertexBuffer[index++] = command.color.r / 255;
            vertexBuffer[index++] = command.color.g / 255;
            vertexBuffer[index++] = command.color.b / 255;
            vertexBuffer[index++] = command.color.a;
            vertexBuffer[index++] = command.size;
        }
        return index / this.vertexSize;
    }
    renderBatch(gl, _batch, vertexCount) {
        gl.drawArrays(gl.POINTS, 0, vertexCount);
    }
}

;// CONCATENATED MODULE: ./Graphics/Graphic.ts


/**
 * A Graphic is the base Excalibur primitive for something that can be drawn to the [[ExcaliburGraphicsContext]].
 * [[Sprite]], [[Animation]], [[GraphicsGroup]], [[Canvas]], [[Rectangle]], [[Circle]], and [[Polygon]] all derive from the
 * [[Graphic]] abstract class.
 *
 * Implementors of a Graphic must override the abstract [[Graphic._drawImage]] method to render an image to the graphics context. Graphic
 * handles all the position, rotation, and scale transformations in [[Graphic._preDraw]] and [[Graphic._postDraw]]
 */
class Graphic {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        this.id = Graphic._ID++;
        /**
         * Gets or sets wether to show debug information about the graphic
         */
        this.showDebug = false;
        /**
         * Gets or sets the flipHorizontal, which will flip the graphic horizontally (across the y axis)
         */
        this.flipHorizontal = false;
        /**
         * Gets or sets the flipVertical, which will flip the graphic vertically (across the x axis)
         */
        this.flipVertical = false;
        /**
         * Gets or sets the rotation of the graphic
         */
        this.rotation = 0;
        /**
         * Gets or sets the opacity of the graphic, 0 is transparent, 1 is solid (opaque).
         */
        this.opacity = 1;
        /**
         * Gets or sets the scale of the graphic, this affects the width and
         */
        this.scale = Vector.One;
        /**
         * Gets or sets the origin of the graphic, if not set the center of the graphic is the origin
         */
        this.origin = null;
        this._width = 0;
        this._height = 0;
        if (options) {
            this.origin = (_a = options.origin) !== null && _a !== void 0 ? _a : this.origin;
            this.flipHorizontal = (_b = options.flipHorizontal) !== null && _b !== void 0 ? _b : this.flipHorizontal;
            this.flipVertical = (_c = options.flipVertical) !== null && _c !== void 0 ? _c : this.flipVertical;
            this.rotation = (_d = options.rotation) !== null && _d !== void 0 ? _d : this.rotation;
            this.opacity = (_e = options.opacity) !== null && _e !== void 0 ? _e : this.opacity;
            this.scale = (_f = options.scale) !== null && _f !== void 0 ? _f : this.scale;
        }
    }
    cloneGraphicOptions() {
        return {
            origin: this.origin ? this.origin.clone() : null,
            flipHorizontal: this.flipHorizontal,
            flipVertical: this.flipVertical,
            rotation: this.rotation,
            opacity: this.opacity,
            scale: this.scale ? this.scale.clone() : null
        };
    }
    /**
     * Gets or sets the width of the graphic (always positive)
     */
    get width() {
        return Math.abs(this._width * this.scale.x);
    }
    /**
     * Gets or sets the height of the graphic (always positive)
     */
    get height() {
        return Math.abs(this._height * this.scale.y);
    }
    set width(value) {
        this._width = value;
    }
    set height(value) {
        this._height = value;
    }
    /**
     * Gets a copy of the bounds in pixels occupied by the graphic on the the screen. This includes scale.
     */
    get localBounds() {
        return BoundingBox.fromDimension(this.width, this.height, Vector.Zero);
    }
    /**
     * Draw the whole graphic to the context including transform
     * @param ex The excalibur graphics context
     * @param x
     * @param y
     */
    draw(ex, x, y) {
        this._preDraw(ex, x, y);
        this._drawImage(ex, 0, 0);
        this._postDraw(ex);
    }
    /**
     * Apply affine transformations to the graphics context to manipulate the graphic before [[Graphic._drawImage]]
     * @param ex
     * @param x
     * @param y
     */
    _preDraw(ex, x, y) {
        ex.save();
        ex.translate(x, y);
        ex.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));
        this._rotate(ex);
        this._flip(ex);
        // it is important to multiply alphas so graphics respect the current context
        ex.opacity = ex.opacity * this.opacity;
    }
    _rotate(ex) {
        var _a;
        const scaleDirX = this.scale.x > 0 ? 1 : -1;
        const scaleDirY = this.scale.y > 0 ? 1 : -1;
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : vec(this.width / 2, this.height / 2);
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()
        ex.scale(scaleDirX, scaleDirY);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, this.height / this.scale.y);
            ex.scale(1, -1);
        }
    }
    /**
     * Apply any addtional work after [[Graphic._drawImage]] and restore the context state.
     * @param ex
     */
    _postDraw(ex) {
        if (this.showDebug) {
            ex.debug.drawRect(0, 0, this.width, this.height);
        }
        ex.restore();
    }
}
Graphic._ID = 0;

;// CONCATENATED MODULE: ./Util/Watch.ts
/**
 * Watch an object with a proxy, only fires if property value is different
 */
function watch(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                if (obj[prop] !== value) {
                    obj[prop] = value;
                    // Avoid watching private junk
                    if (typeof prop === 'string') {
                        if (prop[0] !== '_') {
                            change(obj);
                        }
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}
/**
 * Watch an object with a proxy, fires change on any property value change
 */
function watchAny(type, change) {
    if (!type) {
        return type;
    }
    if (type.__isProxy === undefined) {
        // expando hack to mark a proxy
        return new Proxy(type, {
            set: (obj, prop, value) => {
                // The default behavior to store the value
                obj[prop] = value;
                // Avoid watching private junk
                if (typeof prop === 'string') {
                    if (prop[0] !== '_') {
                        change(obj);
                    }
                }
                // Indicate success
                return true;
            },
            get: (obj, prop) => {
                if (prop !== '__isProxy') {
                    return obj[prop];
                }
                return true;
            }
        });
    }
    return type;
}

;// CONCATENATED MODULE: ./Graphics/Raster.ts







/**
 * A Raster is a Graphic that needs to be first painted to a HTMLCanvasElement before it can be drawn to the
 * [[ExcaliburGraphicsContext]]. This is useful for generating custom images using the 2D canvas api.
 *
 * Implementors must implemenet the [[Raster.execute]] method to rasterize their drawing.
 */
class Raster extends Graphic {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g;
        super(options);
        this._dirty = true;
        this._smoothing = false;
        this._color = watch(Color.Black, () => this.flagDirty());
        this._lineWidth = 1;
        this._lineDash = [];
        this._padding = 0;
        if (options) {
            this.color = (_a = options.color) !== null && _a !== void 0 ? _a : Color.Black;
            this.strokeColor = options === null || options === void 0 ? void 0 : options.strokeColor;
            this.smoothing = (_b = options.smoothing) !== null && _b !== void 0 ? _b : this.smoothing;
            this.lineWidth = (_c = options.lineWidth) !== null && _c !== void 0 ? _c : this.lineWidth;
            this.lineDash = (_d = options.lineDash) !== null && _d !== void 0 ? _d : this.lineDash;
            this.padding = (_e = options.padding) !== null && _e !== void 0 ? _e : this.padding;
        }
        this._bitmap = document.createElement('canvas');
        // get the default canvas width/height as a fallback
        const bitmapWidth = (_f = options === null || options === void 0 ? void 0 : options.width) !== null && _f !== void 0 ? _f : this._bitmap.width;
        const bitmapHeight = (_g = options === null || options === void 0 ? void 0 : options.height) !== null && _g !== void 0 ? _g : this._bitmap.height;
        // Rasters use power of two images as an optimization for webgl
        this.width = ensurePowerOfTwo(bitmapWidth);
        this.height = ensurePowerOfTwo(bitmapHeight);
        const maybeCtx = this._bitmap.getContext('2d');
        if (!maybeCtx) {
            /* istanbul ignore next */
            throw new Error('Browser does not support 2d canvas drawing, cannot create Raster graphic');
        }
        else {
            this._ctx = maybeCtx;
        }
    }
    cloneRasterOptions() {
        return {
            color: this.color ? this.color.clone() : null,
            strokeColor: this.strokeColor ? this.strokeColor.clone() : null,
            smoothing: this.smoothing,
            lineWidth: this.lineWidth,
            lineDash: this.lineDash,
            padding: this.padding
        };
    }
    /**
     * Gets whether the graphic is dirty, this means there are changes that haven't been re-rasterized
     */
    get dirty() {
        return this._dirty;
    }
    /**
     * Flags the graphic as dirty, meaning it must be re-rasterized before draw.
     * This should be called any time the graphics state changes such that it affects the outputed drawing
     */
    flagDirty() {
        this._dirty = true;
    }
    /**
     * Gets or sets the current width of the Raster graphic. Setting the width will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding`s set will be factored into the width
     */
    get width() {
        return this._getTotalWidth();
    }
    set width(value) {
        this._bitmap.width = value;
        this._originalWidth = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the current height of the Raster graphic. Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     *
     * Any `padding` set will be factored into the height
     */
    get height() {
        return this._getTotalHeight();
    }
    set height(value) {
        this._bitmap.height = value;
        this._originalHeight = value;
        this.flagDirty();
    }
    _getTotalWidth() {
        var _a;
        return ((_a = this._originalWidth) !== null && _a !== void 0 ? _a : this._bitmap.width) + this.padding * 2;
    }
    _getTotalHeight() {
        var _a;
        return ((_a = this._originalHeight) !== null && _a !== void 0 ? _a : this._bitmap.height) + this.padding * 2;
    }
    /**
     * Returns the local bounds of the Raster including the padding
     */
    get localBounds() {
        return BoundingBox.fromDimension(this._getTotalWidth() * this.scale.x, this._getTotalHeight() * this.scale.y, Vector.Zero);
    }
    /**
     * Gets or sets the smoothing (anti-aliasing of the graphic). Setting the height will cause the raster
     * to be flagged dirty causing a re-raster on the next draw.
     */
    get smoothing() {
        return this._smoothing;
    }
    set smoothing(value) {
        this._smoothing = value;
        this.flagDirty();
    }
    /**
     * Gets or sets the fillStyle of the Raster graphic. Setting the fillStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get color() {
        return this._color;
    }
    set color(value) {
        var _a;
        if (!((_a = this._color) === null || _a === void 0 ? void 0 : _a.equal(value))) {
            this.flagDirty();
        }
        this._color = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the strokeStyle of the Raster graphic. Setting the strokeStyle will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get strokeColor() {
        return this._strokeColor;
    }
    set strokeColor(value) {
        var _a;
        if (!((_a = this._strokeColor) === null || _a === void 0 ? void 0 : _a.equal(value))) {
            this.flagDirty();
        }
        this._strokeColor = watch(value, () => this.flagDirty());
    }
    /**
     * Gets or sets the line width of the Raster graphic. Setting the lineWidth will cause the raster to be
     * flagged dirty causing a re-raster on the next draw.
     */
    get lineWidth() {
        return this._lineWidth;
    }
    set lineWidth(value) {
        this._lineWidth = value;
        this.flagDirty();
    }
    get lineDash() {
        return this._lineDash;
    }
    set lineDash(value) {
        this._lineDash = value;
        this.flagDirty();
    }
    get padding() {
        return this._padding;
    }
    set padding(value) {
        this._padding = value;
        this.flagDirty();
    }
    /**
     * Rasterize the graphic to a bitmap making it usuable as in excalibur. Rasterize is called automatically if
     * the graphic is [[Raster.dirty]] on the next [[Graphic.draw]] call
     */
    rasterize() {
        this._dirty = false;
        this._ctx.clearRect(0, 0, this._getTotalWidth(), this._getTotalHeight());
        this._ctx.save();
        this._applyRasterProperites(this._ctx);
        this.execute(this._ctx);
        this._ctx.restore();
        // The webgl texture needs to be updated if it exists after a raster cycle
        TextureLoader.load(this._bitmap, true);
    }
    _applyRasterProperites(ctx) {
        var _a, _b, _c;
        this._bitmap.width = this._getTotalWidth();
        this._bitmap.height = this._getTotalHeight();
        ctx.translate(this.padding, this.padding);
        ctx.imageSmoothingEnabled = this.smoothing;
        ctx.lineWidth = this.lineWidth;
        ctx.setLineDash((_a = this.lineDash) !== null && _a !== void 0 ? _a : ctx.getLineDash());
        ctx.strokeStyle = (_b = this.strokeColor) === null || _b === void 0 ? void 0 : _b.toString();
        ctx.fillStyle = (_c = this.color) === null || _c === void 0 ? void 0 : _c.toString();
    }
    _drawImage(ex, x, y) {
        if (this._dirty) {
            this.rasterize();
        }
        ex.drawImage(this._bitmap, x, y);
    }
}

;// CONCATENATED MODULE: ./Graphics/Canvas.ts

/**
 * A canvas [[Graphic]] to provide an adapter between the 2D Canvas API and the [[ExcaliburGraphicsContext]].
 *
 * The [[Canvas]] works by re-rastering a draw handler to a HTMLCanvasElement for every draw which is then passed
 * to the [[ExcaliburGraphicsContext]] implementation as a rendered image.
 *
 * **Low performance API**
 */
class Canvas extends Raster {
    constructor(_options) {
        super(_options);
        this._options = _options;
    }
    /**
     * Return the 2D graphics context of this canvas
     */
    get ctx() {
        return this._ctx;
    }
    clone() {
        return new Canvas(Object.assign(Object.assign(Object.assign({}, this._options), this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        var _a, _b;
        if ((_a = this._options) === null || _a === void 0 ? void 0 : _a.draw) {
            (_b = this._options) === null || _b === void 0 ? void 0 : _b.draw(ctx);
        }
        if (!this._options.cache) {
            this.flagDirty();
        }
    }
}

;// CONCATENATED MODULE: ./Events.ts
var EventTypes;
(function (EventTypes) {
    EventTypes["Kill"] = "kill";
    EventTypes["PreKill"] = "prekill";
    EventTypes["PostKill"] = "postkill";
    EventTypes["PreDraw"] = "predraw";
    EventTypes["PostDraw"] = "postdraw";
    EventTypes["PreDebugDraw"] = "predebugdraw";
    EventTypes["PostDebugDraw"] = "postdebugdraw";
    EventTypes["PreUpdate"] = "preupdate";
    EventTypes["PostUpdate"] = "postupdate";
    EventTypes["PreFrame"] = "preframe";
    EventTypes["PostFrame"] = "postframe";
    EventTypes["PreCollision"] = "precollision";
    EventTypes["CollisionStart"] = "collisionstart";
    EventTypes["CollisionEnd"] = "collisionend";
    EventTypes["PostCollision"] = "postcollision";
    EventTypes["Initialize"] = "initialize";
    EventTypes["Activate"] = "activate";
    EventTypes["Deactivate"] = "deactivate";
    EventTypes["ExitViewport"] = "exitviewport";
    EventTypes["EnterViewport"] = "enterviewport";
    EventTypes["ExitTrigger"] = "exit";
    EventTypes["EnterTrigger"] = "enter";
    EventTypes["Connect"] = "connect";
    EventTypes["Disconnect"] = "disconnect";
    EventTypes["Button"] = "button";
    EventTypes["Axis"] = "axis";
    EventTypes["Subscribe"] = "subscribe";
    EventTypes["Unsubscribe"] = "unsubscribe";
    EventTypes["Visible"] = "visible";
    EventTypes["Hidden"] = "hidden";
    EventTypes["Start"] = "start";
    EventTypes["Stop"] = "stop";
    EventTypes["PointerUp"] = "pointerup";
    EventTypes["PointerDown"] = "pointerdown";
    EventTypes["PointerMove"] = "pointermove";
    EventTypes["PointerEnter"] = "pointerenter";
    EventTypes["PointerLeave"] = "pointerleave";
    EventTypes["PointerCancel"] = "pointercancel";
    EventTypes["PointerWheel"] = "pointerwheel";
    EventTypes["Up"] = "up";
    EventTypes["Down"] = "down";
    EventTypes["Move"] = "move";
    EventTypes["Enter"] = "enter";
    EventTypes["Leave"] = "leave";
    EventTypes["Cancel"] = "cancel";
    EventTypes["Wheel"] = "wheel";
    EventTypes["Press"] = "press";
    EventTypes["Release"] = "release";
    EventTypes["Hold"] = "hold";
    EventTypes["PointerDragStart"] = "pointerdragstart";
    EventTypes["PointerDragEnd"] = "pointerdragend";
    EventTypes["PointerDragEnter"] = "pointerdragenter";
    EventTypes["PointerDragLeave"] = "pointerdragleave";
    EventTypes["PointerDragMove"] = "pointerdragmove";
})(EventTypes || (EventTypes = {}));
/**
 * Base event type in Excalibur that all other event types derive from. Not all event types are thrown on all Excalibur game objects,
 * some events are unique to a type, others are not.
 *
 */
class GameEvent {
    constructor() {
        this._bubbles = true;
    }
    /**
     * If set to false, prevents event from propagating to other actors. If true it will be propagated
     * to all actors that apply.
     */
    get bubbles() {
        return this._bubbles;
    }
    set bubbles(value) {
        this._bubbles = value;
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        this.bubbles = false;
    }
}
/**
 * The 'kill' event is emitted on actors when it is killed. The target is the actor that was killed.
 */
class KillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'prekill' event is emitted directly before an actor is killed.
 */
class PreKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'postkill' event is emitted directly after the actor is killed.
 */
class PostKillEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'start' event is emitted on engine when has started and is ready for interaction.
 */
class GameStartEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'stop' event is emitted on engine when has been stopped and will no longer take input, update or draw.
 */
class GameStopEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * The 'predraw' event is emitted on actors, scenes, and engine before drawing starts. Actors' predraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PreDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postdraw' event is emitted on actors, scenes, and engine after drawing finishes. Actors' postdraw happens inside their graphics
 * transform so that all drawing takes place with the actor as the origin.
 *
 */
class PostDrawEvent extends GameEvent {
    constructor(ctx, delta, target) {
        super();
        this.ctx = ctx;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'predebugdraw' event is emitted on actors, scenes, and engine before debug drawing starts.
 */
class PreDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'postdebugdraw' event is emitted on actors, scenes, and engine after debug drawing starts.
 */
class PostDebugDrawEvent extends GameEvent {
    constructor(ctx, target) {
        super();
        this.ctx = ctx;
        this.target = target;
    }
}
/**
 * The 'preupdate' event is emitted on actors, scenes, camera, and engine before the update starts.
 */
class PreUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'postupdate' event is emitted on actors, scenes, camera, and engine after the update ends.
 */
class PostUpdateEvent extends GameEvent {
    constructor(engine, delta, target) {
        super();
        this.engine = engine;
        this.delta = delta;
        this.target = target;
    }
}
/**
 * The 'preframe' event is emitted on the engine, before the frame begins.
 */
class PreFrameEvent extends GameEvent {
    constructor(engine, prevStats) {
        super();
        this.engine = engine;
        this.prevStats = prevStats;
        this.target = engine;
    }
}
/**
 * The 'postframe' event is emitted on the engine, after a frame ends.
 */
class PostFrameEvent extends GameEvent {
    constructor(engine, stats) {
        super();
        this.engine = engine;
        this.stats = stats;
        this.target = engine;
    }
}
/**
 * Event received when a gamepad is connected to Excalibur. [[Gamepads]] receives this event.
 */
class GamepadConnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Event received when a gamepad is disconnected from Excalibur. [[Gamepads]] receives this event.
 */
class GamepadDisconnectEvent extends GameEvent {
    constructor(index, gamepad) {
        super();
        this.index = index;
        this.gamepad = gamepad;
        this.target = gamepad;
    }
}
/**
 * Gamepad button event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadButtonEvent extends GameEvent {
    /**
     * @param button  The Gamepad button
     * @param value   A numeric value between 0 and 1
     */
    constructor(button, value, target) {
        super();
        this.button = button;
        this.value = value;
        this.target = target;
    }
}
/**
 * Gamepad axis event. See [[Gamepads]] for information on responding to controller input. [[Gamepad]] instances receive this event;
 */
class GamepadAxisEvent extends GameEvent {
    /**
     * @param axis  The Gamepad axis
     * @param value A numeric value between -1 and 1
     */
    constructor(axis, value, target) {
        super();
        this.axis = axis;
        this.value = value;
        this.target = target;
    }
}
/**
 * Subscribe event thrown when handlers for events other than subscribe are added. Meta event that is received by
 * [[EventDispatcher|event dispatchers]].
 */
class SubscribeEvent extends GameEvent {
    constructor(topic, handler) {
        super();
        this.topic = topic;
        this.handler = handler;
    }
}
/**
 * Unsubscribe event thrown when handlers for events other than unsubscribe are removed. Meta event that is received by
 * [[EventDispatcher|event dispatchers]].
 */
class UnsubscribeEvent extends GameEvent {
    constructor(topic, handler) {
        super();
        this.topic = topic;
        this.handler = handler;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is visible on a screen.
 */
class VisibleEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event received by the [[Engine]] when the browser window is hidden from all screens.
 */
class HiddenEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision will occur this frame if it resolves
 */
class PreCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that will collided with the current actor
     * @param side          The side that will be collided with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor|actor]] when a collision has been resolved (body reacted) this frame
 */
class PostCollisionEvent extends GameEvent {
    /**
     * @param actor         The actor the event was thrown on
     * @param other         The actor that did collide with the current actor
     * @param side          The side that did collide with the current actor
     * @param intersection  Intersection vector
     */
    constructor(actor, other, side, intersection) {
        super();
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
class ContactStartEvent {
    constructor(target, other, contact) {
        this.target = target;
        this.other = other;
        this.contact = contact;
    }
}
class ContactEndEvent {
    constructor(target, other) {
        this.target = target;
        this.other = other;
    }
}
class CollisionPreSolveEvent {
    constructor(target, other, side, intersection, contact) {
        this.target = target;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
class CollisionPostSolveEvent {
    constructor(target, other, side, intersection, contact) {
        this.target = target;
        this.other = other;
        this.side = side;
        this.intersection = intersection;
        this.contact = contact;
    }
}
/**
 * Event thrown the first time an [[Actor|actor]] collides with another, after an actor is in contact normal collision events are fired.
 */
class CollisionStartEvent extends GameEvent {
    /**
     *
     * @param actor
     * @param other
     * @param contact
     */
    constructor(actor, other, contact) {
        super();
        this.other = other;
        this.contact = contact;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown when the [[Actor|actor]] is no longer colliding with another
 */
class CollisionEndEvent extends GameEvent {
    /**
     *
     */
    constructor(actor, other) {
        super();
        this.other = other;
        this.target = actor;
    }
    get actor() {
        return this.target;
    }
    set actor(actor) {
        this.target = actor;
    }
}
/**
 * Event thrown on an [[Actor]] and a [[Scene]] only once before the first update call
 */
class InitializeEvent extends GameEvent {
    /**
     * @param engine  The reference to the current engine
     */
    constructor(engine, target) {
        super();
        this.engine = engine;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on activation
 */
class ActivateEvent extends GameEvent {
    /**
     * @param oldScene  The reference to the old scene
     */
    constructor(oldScene, target) {
        super();
        this.oldScene = oldScene;
        this.target = target;
    }
}
/**
 * Event thrown on a [[Scene]] on deactivation
 */
class DeactivateEvent extends GameEvent {
    /**
     * @param newScene  The reference to the new scene
     */
    constructor(newScene, target) {
        super();
        this.newScene = newScene;
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class ExitViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
/**
 * Event thrown on an [[Actor]] when it completely leaves the screen.
 */
class EnterViewPortEvent extends GameEvent {
    constructor(target) {
        super();
        this.target = target;
    }
}
class EnterTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}
class ExitTriggerEvent extends GameEvent {
    constructor(target, actor) {
        super();
        this.target = target;
        this.actor = actor;
    }
}

;// CONCATENATED MODULE: ./EventDispatcher.ts

class EventDispatcher {
    /**
     * @param target  The object that will be the recipient of events from this event dispatcher
     */
    constructor(target) {
        this._handlers = {};
        this._wiredEventDispatchers = [];
        this._target = target;
    }
    /**
     * Clears any existing handlers or wired event dispatchers on this event dispatcher
     */
    clear() {
        this._handlers = {};
        this._wiredEventDispatchers = [];
    }
    /**
     * Emits an event for target
     * @param eventName  The name of the event to publish
     * @param event      Optionally pass an event data object to the handler
     */
    emit(eventName, event) {
        if (!eventName) {
            // key not mapped
            return;
        }
        eventName = eventName.toLowerCase();
        const target = this._target;
        if (!event) {
            event = new GameEvent();
        }
        try {
            if (!event.target) {
                event.target = target;
            }
        }
        catch (_a) {
            // pass
        }
        let i, len;
        if (this._handlers[eventName]) {
            i = 0;
            len = this._handlers[eventName].length;
            for (i; i < len; i++) {
                this._handlers[eventName][i].call(target, event);
            }
        }
        i = 0;
        len = this._wiredEventDispatchers.length;
        for (i; i < len; i++) {
            this._wiredEventDispatchers[i].emit(eventName, event);
        }
    }
    /**
     * Subscribe an event handler to a particular event name, multiple handlers per event name are allowed.
     * @param eventName  The name of the event to subscribe to
     * @param handler    The handler callback to fire on this event
     */
    on(eventName, handler) {
        eventName = eventName.toLowerCase();
        if (!this._handlers[eventName]) {
            this._handlers[eventName] = [];
        }
        this._handlers[eventName].push(handler);
        // meta event handlers
        if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
            this.emit('subscribe', new SubscribeEvent(eventName, handler));
        }
    }
    /**
     * Unsubscribe an event handler(s) from an event. If a specific handler
     * is specified for an event, only that handler will be unsubscribed.
     * Otherwise all handlers will be unsubscribed for that event.
     *
     * @param eventName  The name of the event to unsubscribe
     * @param handler    Optionally the specific handler to unsubscribe
     */
    off(eventName, handler) {
        eventName = eventName.toLowerCase();
        const eventHandlers = this._handlers[eventName];
        if (eventHandlers) {
            // if no explicit handler is give with the event name clear all handlers
            if (!handler) {
                this._handlers[eventName].length = 0;
            }
            else {
                const index = eventHandlers.indexOf(handler);
                this._handlers[eventName].splice(index, 1);
            }
        }
        // meta event handlers
        if (eventName !== 'unsubscribe' && eventName !== 'subscribe') {
            this.emit('unsubscribe', new UnsubscribeEvent(eventName, handler));
        }
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        const metaHandler = (event) => {
            const ev = event || new GameEvent();
            try {
                ev.target = ev.target || this._target;
            }
            catch (_a) {
                // pass
            }
            this.off(eventName, handler);
            handler.call(ev.target, ev);
        };
        this.on(eventName, metaHandler);
    }
    /**
     * Wires this event dispatcher to also receive events from another
     */
    wire(eventDispatcher) {
        eventDispatcher._wiredEventDispatchers.push(this);
    }
    /**
     * Unwires this event dispatcher from another
     */
    unwire(eventDispatcher) {
        const index = eventDispatcher._wiredEventDispatchers.indexOf(this);
        if (index > -1) {
            eventDispatcher._wiredEventDispatchers.splice(index, 1);
        }
    }
}

;// CONCATENATED MODULE: ./Resources/Resource.ts


/**
 * The [[Resource]] type allows games built in Excalibur to load generic resources.
 * For any type of remote resource it is recommended to use [[Resource]] for preloading.
 */
class Resource {
    /**
     * @param path          Path to the remote resource
     * @param responseType  The type to expect as a response: "" | "arraybuffer" | "blob" | "document" | "json" | "text";
     * @param bustCache     Whether or not to cache-bust requests
     */
    constructor(path, responseType, bustCache = true) {
        this.path = path;
        this.responseType = responseType;
        this.bustCache = bustCache;
        this.data = null;
        this.logger = Logger.getInstance();
        this.events = new EventDispatcher(this);
    }
    /**
     * Returns true if the Resource is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return this.data !== null;
    }
    _cacheBust(uri) {
        const query = /\?\w*=\w*/;
        if (query.test(uri)) {
            uri += '&__=' + Date.now();
        }
        else {
            uri += '?__=' + Date.now();
        }
        return uri;
    }
    /**
     * Begin loading the resource and returns a promise to be resolved on completion
     */
    load() {
        return new Promise((resolve, reject) => {
            // Exit early if we already have data
            if (this.data !== null) {
                this.logger.debug('Already have data for resource', this.path);
                this.events.emit('complete', this.data);
                resolve(this.data);
                return;
            }
            const request = new XMLHttpRequest();
            request.open('GET', this.bustCache ? this._cacheBust(this.path) : this.path, true);
            request.responseType = this.responseType;
            request.addEventListener('loadstart', (e) => this.events.emit('loadstart', e));
            request.addEventListener('progress', (e) => this.events.emit('progress', e));
            request.addEventListener('error', (e) => this.events.emit('error', e));
            request.addEventListener('load', (e) => this.events.emit('load', e));
            request.addEventListener('load', () => {
                // XHR on file:// success status is 0, such as with PhantomJS
                if (request.status !== 0 && request.status !== 200) {
                    this.logger.error('Failed to load resource ', this.path, ' server responded with error code', request.status);
                    this.events.emit('error', request.response);
                    reject(new Error(request.statusText));
                    return;
                }
                this.data = request.response;
                this.events.emit('complete', this.data);
                this.logger.debug('Completed loading resource', this.path);
                resolve(this.data);
            });
            request.send();
        });
    }
}

;// CONCATENATED MODULE: ./Drawing/SpriteEffects.ts
/**
 * @module
 * @deprecated
 * These effects can be applied to any bitmap image but are mainly used
 * for [[Sprite]] effects or [[Animation]] effects.
 */
var SpriteEffects_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
/**
 * @typedoc
 */


/**
 * Applies the "Grayscale" effect to a sprite, removing color information.
 * @deprecated [[Grayscale]] will be removed in v0.26.0
 */
let Grayscale = class Grayscale {
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const avg = (pixel[firstPixel + 0] + pixel[firstPixel + 1] + pixel[firstPixel + 2]) / 3;
        pixel[firstPixel + 0] = avg;
        pixel[firstPixel + 1] = avg;
        pixel[firstPixel + 2] = avg;
    }
};
Grayscale = SpriteEffects_decorate([
    obsolete({
        message: 'Grayscale will be removed in v0.26.0'
    })
], Grayscale);

/**
 * Applies the "Invert" effect to a sprite, inverting the pixel colors.
 * @deprecated [[Invert]] will be removed in v0.26.0
 */
let Invert = class Invert {
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        pixel[firstPixel + 0] = 255 - pixel[firstPixel + 0];
        pixel[firstPixel + 1] = 255 - pixel[firstPixel + 1];
        pixel[firstPixel + 2] = 255 - pixel[firstPixel + 2];
    }
};
Invert = SpriteEffects_decorate([
    obsolete({
        message: 'Invert will be removed in v0.26.0'
    })
], Invert);

/**
 * Applies the "Opacity" effect to a sprite, setting the alpha of all pixels to a given value.
 * @deprecated [[Opacity]] will be removed in v0.26.0
 */
let Opacity = class Opacity {
    /**
     * @param opacity  The new opacity of the sprite from 0-1.0
     */
    constructor(opacity) {
        this.opacity = opacity;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 3] = Math.round(this.opacity * pixel[firstPixel + 3]);
        }
    }
};
Opacity = SpriteEffects_decorate([
    obsolete({
        message: 'Opacity will be removed in v0.26.0'
    })
], Opacity);

/**
 * Applies the "Colorize" effect to a sprite, changing the color channels of all the pixels to an
 * average of the original color and the provided color
 * @deprecated [[Colorize]] will be removed in v0.26.0
 */
let Colorize = class Colorize {
    /**
     * @param color  The color to apply to the sprite
     */
    constructor(color) {
        this.color = color;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 0] = (pixel[firstPixel + 0] + this.color.r) / 2;
            pixel[firstPixel + 1] = (pixel[firstPixel + 1] + this.color.g) / 2;
            pixel[firstPixel + 2] = (pixel[firstPixel + 2] + this.color.b) / 2;
        }
    }
};
Colorize = SpriteEffects_decorate([
    obsolete({
        message: 'Colorize will be removed in v0.26.0'
    })
], Colorize);

/**
 * Applies the "Lighten" effect to a sprite, changes the lightness of the color according to HSL
 * @deprecated [[Lighten]] will be removed in v0.26.0
 */
let Lighten = class Lighten {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).lighten(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Lighten = SpriteEffects_decorate([
    obsolete({
        message: 'Lighten will be removed in v0.26.0'
    })
], Lighten);

/**
 * Applies the "Darken" effect to a sprite, changes the darkness of the color according to HSL
 * @deprecated [[Darken]] will be removed in v0.26.0
 */
let Darken = class Darken {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).darken(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Darken = SpriteEffects_decorate([
    obsolete({
        message: 'Darken will be removed v0.26.0'
    })
], Darken);

/**
 * Applies the "Saturate" effect to a sprite, saturates the color according to HSL
 * @deprecated [[Saturate]] will be removed in v0.26.0
 */
let Saturate = class Saturate {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).saturate(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Saturate = SpriteEffects_decorate([
    obsolete({
        message: 'Saturate will be removed in v0.26.0'
    })
], Saturate);

/**
 * Applies the "Desaturate" effect to a sprite, desaturates the color according to HSL
 * @deprecated [[Desaturate]] will be removed in v0.26.0
 */
let Desaturate = class Desaturate {
    /**
     * @param factor  The factor of the effect between 0-1
     */
    constructor(factor = 0.1) {
        this.factor = factor;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        const color = Color.fromRGB(pixel[firstPixel + 0], pixel[firstPixel + 1], pixel[firstPixel + 2], pixel[firstPixel + 3]).desaturate(this.factor);
        pixel[firstPixel + 0] = color.r;
        pixel[firstPixel + 1] = color.g;
        pixel[firstPixel + 2] = color.b;
        pixel[firstPixel + 3] = color.a;
    }
};
Desaturate = SpriteEffects_decorate([
    obsolete({
        message: 'Desaturate will be removed in v0.26.0'
    })
], Desaturate);

/**
 * Applies the "Fill" effect to a sprite, changing the color channels of all non-transparent pixels to match
 * a given color
 * @deprecated [[Fill]] will be removed in v0.26.0
 */
let Fill = class Fill {
    /**
     * @param color  The color to apply to the sprite
     */
    constructor(color) {
        this.color = color;
    }
    updatePixel(x, y, imageData) {
        const firstPixel = (x + y * imageData.width) * 4;
        const pixel = imageData.data;
        if (pixel[firstPixel + 3] !== 0) {
            pixel[firstPixel + 0] = this.color.r;
            pixel[firstPixel + 1] = this.color.g;
            pixel[firstPixel + 2] = this.color.b;
        }
    }
};
Fill = SpriteEffects_decorate([
    obsolete({
        message: 'Fill will be removed in v0.26.0'
    })
], Fill);


;// CONCATENATED MODULE: ./Drawing/Texture.ts
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


/**
 * The [[Texture]] object allows games built in Excalibur to load image resources.
 * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]
 * to pre-load before starting a level or game.
 * @deprecated
 */
class Texture {
    /**
     * @param path       Path to the image resource or a base64 string representing an image "data:image/png;base64,iVB..."
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, bustCache = true) {
        this.path = path;
        this.bustCache = bustCache;
        this._sprite = null;
        this.loaded = new Promise(resolve => {
            this._loadedResolve = resolve;
        });
        this._resource = new Resource(path, 'blob', bustCache);
        this._sprite = new Sprite_Sprite(this, 0, 0, 0, 0);
    }
    get image() {
        return this.data;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return !!this.data;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                // Load base64 or blob if needed
                let url;
                if (!this.path.includes('data:image/')) {
                    const blob = yield this._resource.load();
                    url = URL.createObjectURL(blob);
                }
                else {
                    url = this.path;
                }
                // Decode the image
                const image = new Image();
                image.src = url;
                yield image.decode();
                // Set results
                this.data = image;
                this.width = this._sprite.width = image.naturalWidth;
                this.height = this._sprite.height = image.naturalHeight;
                this._sprite = new Sprite_Sprite(this, 0, 0, this.width, this.height);
            }
            catch (_a) {
                yield Promise.reject('Error loading texture');
            }
            // todo emit complete
            this._loadedResolve(this.data);
            return this.data;
        });
    }
    asSprite() {
        return this._sprite;
    }
}

;// CONCATENATED MODULE: ./Configurable.ts
/**
 * Configurable helper extends base type and makes all properties available as option bag arguments
 * @internal
 * @param base
 */
function Configurable(base) {
    return class extends base {
        assign(props) {
            //set the value of every property that was passed in,
            //if the constructor previously set this value, it will be overridden here
            for (const k in props) {
                // eslint-disable-next-line
                if (typeof this[k] !== 'function') {
                    // eslint-disable-next-line
                    this[k] = props[k];
                }
            }
        }
        constructor(...args) {
            super(...args);
            //get the number of arguments that aren't undefined. TS passes a value to all parameters
            //of whatever ctor is the implementation, so args.length doesn't work here.
            const size = args.filter(function (value) {
                return value !== undefined;
            }).length;
            if (size === 1 && args[0] && typeof args[0] === 'object' && !(args[0] instanceof Array)) {
                this.assign(args[0]);
            }
        }
    };
}

;// CONCATENATED MODULE: ./Drawing/Sprite.ts
var Sprite_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Sprite_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








/**
 * @hidden
 * @deprecated Use [[Sprite]]
 */
class SpriteImpl {
    /**
     * @param imageOrConfig  The backing image texture to build the Sprite, or Sprite option bag
     * @param x      The x position of the sprite
     * @param y      The y position of the sprite
     * @param width  The width of the sprite in pixels
     * @param height The height of the sprite in pixels
     */
    constructor(imageOrConfig, x, y, width, height) {
        this.x = 0;
        this.y = 0;
        this.rotation = 0.0;
        this.anchor = Vector.Half;
        this.offset = Vector.Zero;
        this.scale = Vector.One;
        /**
         * Default: false, should the sprite be drawn around the anchor or from the top left.
         * Sprite rotations/scaling still happen around the anchor regardless of this setting.
         */
        this.drawAroundAnchor = false;
        this.logger = Logger.getInstance();
        /**
         * Draws the sprite flipped vertically
         */
        this.flipVertical = false;
        /**
         * Draws the sprite flipped horizontally
         */
        this.flipHorizontal = false;
        this.effects = [];
        this.width = 0;
        this.height = 0;
        this._spriteCanvas = null;
        this._spriteCtx = null;
        this._pixelData = null;
        this._pixelsLoaded = false;
        this._dirtyEffect = true;
        this._opacity = 1;
        let image = imageOrConfig;
        if (imageOrConfig && !(imageOrConfig instanceof Texture)) {
            x = imageOrConfig.x | 0;
            y = imageOrConfig.y | 0;
            width = imageOrConfig.width | 0;
            height = imageOrConfig.height | 0;
            image = imageOrConfig.image;
            if (!image) {
                const message = 'An image texture is required to construct a sprite';
                throw new Error(message);
            }
        }
        this.x = x || 0;
        this.y = y || 0;
        this.texture = image;
        this._spriteCanvas = document.createElement('canvas');
        this._spriteCanvas.width = width;
        this._spriteCanvas.height = height;
        this._spriteCtx = this._spriteCanvas.getContext('2d');
        this._initPixelsFromTexture();
        this.width = width;
        this.height = height;
    }
    get drawWidth() {
        return Math.abs(this.width * this.scale.x);
    }
    get drawHeight() {
        return Math.abs(this.height * this.scale.y);
    }
    _initPixelsFromTexture() {
        return Sprite_awaiter(this, void 0, void 0, function* () {
            try {
                const image = yield this.texture.loaded;
                this.width = this.width || image.naturalWidth;
                this.height = this.height || image.naturalHeight;
                this._spriteCanvas.width = this._spriteCanvas.width || image.naturalWidth;
                this._spriteCanvas.height = this._spriteCanvas.height || image.naturalHeight;
                this._loadPixels();
                this._dirtyEffect = true;
            }
            catch (e) {
                this.logger.error('Error loading texture ', this.texture.path, e);
            }
        });
    }
    _loadPixels() {
        if (this.texture.isLoaded() && !this._pixelsLoaded) {
            const naturalWidth = this.texture.image.naturalWidth || 0;
            const naturalHeight = this.texture.image.naturalHeight || 0;
            if (this.width > naturalWidth) {
                this.logger.warn(`The sprite width ${this.width} exceeds the width 
                              ${naturalWidth} of the backing texture ${this.texture.path}`);
            }
            if (this.width <= 0 || naturalWidth <= 0) {
                throw new Error(`The width of a sprite cannot be 0 or negative, sprite width: ${this.width}, original width: ${naturalWidth}`);
            }
            if (this.height > naturalHeight) {
                this.logger.warn(`The sprite height ${this.height} exceeds the height 
                              ${naturalHeight} of the backing texture ${this.texture.path}`);
            }
            if (this.height <= 0 || naturalHeight <= 0) {
                throw new Error(`The height of a sprite cannot be 0 or negative, sprite height: ${this.height}, original height: ${naturalHeight}`);
            }
            this._flushTexture();
            this._pixelsLoaded = true;
        }
    }
    _flushTexture() {
        const naturalWidth = this.texture.image.naturalWidth || 0;
        const naturalHeight = this.texture.image.naturalHeight || 0;
        this._spriteCtx.clearRect(0, 0, this.width, this.height);
        this._spriteCtx.drawImage(this.texture.image, clamp(this.x, 0, naturalWidth), clamp(this.y, 0, naturalHeight), clamp(this.width, 0, naturalWidth), clamp(this.height, 0, naturalHeight), 0, 0, this.width, this.height);
    }
    /**
     * Applies the [[Opacity]] effect to a sprite, setting the alpha of all pixels to a given value
     */
    opacity(value) {
        this._opacity = value;
    }
    /**
     * Applies the [[Grayscale]] effect to a sprite, removing color information.
     */
    grayscale() {
        this.addEffect(new Grayscale());
    }
    /**
     * Applies the [[Invert]] effect to a sprite, inverting the pixel colors.
     */
    invert() {
        this.addEffect(new Invert());
    }
    /**
     * Applies the [[Fill]] effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
     */
    fill(color) {
        this.addEffect(new Fill(color));
    }
    /**
     * Applies the [[Colorize]] effect to a sprite, changing the color channels of all pixels to be the average of the original color
     * and the provided color.
     */
    colorize(color) {
        this.addEffect(new Colorize(color));
    }
    /**
     * Applies the [[Lighten]] effect to a sprite, changes the lightness of the color according to HSL
     */
    lighten(factor = 0.1) {
        this.addEffect(new Lighten(factor));
    }
    /**
     * Applies the [[Darken]] effect to a sprite, changes the darkness of the color according to HSL
     */
    darken(factor = 0.1) {
        this.addEffect(new Darken(factor));
    }
    /**
     * Applies the [[Saturate]] effect to a sprite, saturates the color according to HSL
     */
    saturate(factor = 0.1) {
        this.addEffect(new Saturate(factor));
    }
    /**
     * Applies the [[Desaturate]] effect to a sprite, desaturates the color according to HSL
     */
    desaturate(factor = 0.1) {
        this.addEffect(new Desaturate(factor));
    }
    /**
     * Adds a new [[SpriteEffect]] to this drawing.
     * @param effect  Effect to add to the this drawing
     */
    addEffect(effect) {
        this.effects.push(effect);
        // We must check if the texture and the backing sprite pixels are loaded as well before
        // an effect can be applied
        if (!this.texture.isLoaded() || !this._pixelsLoaded) {
            this._dirtyEffect = true;
        }
        else {
            this._applyEffects();
        }
    }
    removeEffect(param) {
        let indexToRemove = -1;
        if (typeof param === 'number') {
            indexToRemove = param;
        }
        else {
            indexToRemove = this.effects.indexOf(param);
        }
        // bounds check
        if (indexToRemove < 0 || indexToRemove >= this.effects.length) {
            return;
        }
        this.effects.splice(indexToRemove, 1);
        // We must check if the texture and the backing sprite pixels are loaded as well before
        // an effect can be applied
        if (!this.texture.isLoaded() || !this._pixelsLoaded) {
            this._dirtyEffect = true;
        }
        else {
            this._applyEffects();
        }
    }
    _applyEffects() {
        this._flushTexture();
        if (this.effects.length > 0) {
            this._pixelData = this._spriteCtx.getImageData(0, 0, this.width, this.height);
            const len = this.effects.length;
            for (let i = 0; i < len; i++) {
                for (let y = 0; y < this.height; y++) {
                    for (let x = 0; x < this.width; x++) {
                        this.effects[i].updatePixel(x, y, this._pixelData);
                    }
                }
            }
            this._spriteCtx.clearRect(0, 0, this.width, this.height);
            this._spriteCtx.putImageData(this._pixelData, 0, 0);
        }
        this._dirtyEffect = false;
    }
    /**
     * Clears all effects from the drawing and return it to its original state.
     */
    clearEffects() {
        this.effects.length = 0;
        this._applyEffects();
    }
    /**
     * Resets the internal state of the drawing (if any)
     */
    reset() {
        // do nothing
    }
    debugDraw(ctx, x, y) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(this.rotation);
        const xpoint = this.drawWidth * this.anchor.x;
        const ypoint = this.drawHeight * this.anchor.y;
        ctx.strokeStyle = Color.Black.toString();
        ctx.strokeRect(-xpoint, -ypoint, this.drawWidth, this.drawHeight);
        ctx.restore();
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { ctx, x, y, rotation, drawWidth, drawHeight, anchor, offset, opacity, flipHorizontal, flipVertical } = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.width, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.height, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, offset: (_g = options.offset) !== null && _g !== void 0 ? _g : this.offset, opacity: ((_h = options.opacity) !== null && _h !== void 0 ? _h : 1) * ((_j = this._opacity) !== null && _j !== void 0 ? _j : 1) });
        if (this._dirtyEffect) {
            this._applyEffects();
        }
        // calculating current dimensions
        const anchorX = drawWidth * anchor.x + offset.x;
        const anchorY = drawHeight * anchor.y + offset.y;
        const scaleDirX = this.scale.x > 0 ? 1 : -1;
        const scaleDirY = this.scale.y > 0 ? 1 : -1;
        ctx.save();
        // Move the draw point of origin
        ctx.translate(x, y);
        // Rotate and scale around anchor point
        // This requires a bit of explaination, scale coordinates first positive flipping or rotating
        ctx.scale(Math.abs(this.scale.x), Math.abs(this.scale.y));
        if (this.drawAroundAnchor) {
            // In the case where you want the anchor to match with the point of draw
            // Otherwise sprites are always drawn from top-left
            ctx.translate(-anchorX, -anchorY);
        }
        ctx.translate(anchorX, anchorY);
        ctx.rotate(rotation);
        // This is for handling direction changes 1 or -1, that way we don't have mismatched translates()
        ctx.scale(scaleDirX, scaleDirY);
        ctx.translate(-anchorX, -anchorY);
        if (flipHorizontal) {
            ctx.translate(drawWidth, 0);
            ctx.scale(-1, 1);
        }
        if (flipVertical) {
            ctx.translate(0, drawHeight);
            ctx.scale(1, -1);
        }
        const oldAlpha = ctx.globalAlpha;
        ctx.globalAlpha = opacity;
        // Context is already rotated and scaled
        ctx.drawImage(this._spriteCanvas, 0, 0, this.width, this.height, // source
        0, 0, this.width, this.height); // dest
        ctx.globalAlpha = oldAlpha;
        ctx.restore();
    }
    /**
     * Produces a copy of the current sprite
     */
    clone() {
        const result = new Sprite_Sprite(this.texture, this.x, this.y, this.width, this.height);
        result.anchor = this.anchor.clone();
        result.scale = this.scale.clone();
        result.rotation = this.rotation;
        result.flipHorizontal = this.flipHorizontal;
        result.flipVertical = this.flipVertical;
        const len = this.effects.length;
        for (let i = 0; i < len; i++) {
            result.addEffect(this.effects[i]);
        }
        return result;
    }
}
/**
 * A [[LegacyDrawing.Sprite]] is one of the main drawing primitives. It is responsible for drawing
 * images or parts of images from a [[LegacyDrawing.Texture]] resource to the screen.
 * @deprecated Use [[Sprite]]
 */
let Sprite_Sprite = class Sprite extends Configurable(SpriteImpl) {
    constructor(imageOrConfig, x, y, width, height) {
        super(imageOrConfig, x, y, width, height);
    }
};
Sprite_Sprite = Sprite_decorate([
    obsolete({
        message: 'Label.clearTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Sprite_Sprite);


;// CONCATENATED MODULE: ./Graphics/Sprite.ts




class Sprite extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this.image = options.image;
        const { width, height } = options;
        this.sourceView = (_a = options.sourceView) !== null && _a !== void 0 ? _a : { x: 0, y: 0, width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this.destSize = (_b = options.destSize) !== null && _b !== void 0 ? _b : { width: width !== null && width !== void 0 ? width : 0, height: height !== null && height !== void 0 ? height : 0 };
        this._updateSpriteDimensions();
        this.image.ready.then(() => {
            this._updateSpriteDimensions();
        });
    }
    static from(image) {
        return new Sprite({
            image: image
        });
    }
    _updateSpriteDimensions() {
        var _a, _b, _c, _d, _e, _f;
        const { width: nativeWidth, height: nativeHeight } = this.image;
        // This code uses || to avoid 0's
        // If the source is not specified, use the native dimension
        this.sourceView.width = ((_a = this.sourceView) === null || _a === void 0 ? void 0 : _a.width) || nativeWidth;
        this.sourceView.height = ((_b = this.sourceView) === null || _b === void 0 ? void 0 : _b.height) || nativeHeight;
        // If the destination is not specified, use the source if specified, then native
        this.destSize.width = ((_c = this.destSize) === null || _c === void 0 ? void 0 : _c.width) || ((_d = this.sourceView) === null || _d === void 0 ? void 0 : _d.width) || nativeWidth;
        this.destSize.height = ((_e = this.destSize) === null || _e === void 0 ? void 0 : _e.height) || ((_f = this.sourceView) === null || _f === void 0 ? void 0 : _f.height) || nativeHeight;
        this.width = Math.ceil(this.destSize.width);
        this.height = Math.ceil(this.destSize.height);
    }
    _preDraw(ex, x, y) {
        if (this.image.isLoaded()) {
            this._updateSpriteDimensions();
        }
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        if (this.image.isLoaded()) {
            this._updateSpriteDimensions();
            ex.drawImage(this.image.image, this.sourceView.x, this.sourceView.y, this.sourceView.width, this.sourceView.height, x, y, this.destSize.width, this.destSize.height);
        }
    }
    /**
     * Create a ImageSource from legacy texture
     * @param sprite
     */
    static fromLegacySprite(sprite) {
        const tex = sprite.texture;
        const image = ImageSource.fromLegacyTexture(tex);
        return new Sprite({
            image,
            sourceView: {
                x: sprite.x,
                y: sprite.y,
                width: sprite.width,
                height: sprite.height
            }
        });
    }
    /**
     * Converts a sprite to a Legacy sprite
     * @deprecated
     * @param sprite
     * @returns LegacyDrawing.Sprite
     */
    static toLegacySprite(sprite) {
        const image = sprite.image;
        const tex = new Texture(image.path);
        tex.data = image.image;
        return new Sprite_Sprite(tex, sprite.sourceView.x, sprite.sourceView.y, sprite.sourceView.width, sprite.sourceView.height);
    }
    clone() {
        return new Sprite(Object.assign({ image: this.image, sourceView: Object.assign({}, this.sourceView), destSize: Object.assign({}, this.destSize) }, this.cloneGraphicOptions()));
    }
}

;// CONCATENATED MODULE: ./Graphics/ImageSource.ts
var ImageSource_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



class ImageSource {
    /**
     * The path to the image, can also be a data url like 'data:image/'
     * @param path
     */
    constructor(path, bustCache = false) {
        this.path = path;
        this._logger = Logger.getInstance();
        /**
         * Access to the underlying html image elmeent
         */
        this.data = new Image();
        this._resource = new Resource(path, 'blob', bustCache);
        if (path.endsWith('.svg') || path.endsWith('.gif')) {
            this._logger.warn(`Image type is not fully supported, you may have mixed results ${path}. Fully supported: jpg, bmp, and png`);
        }
        this.ready = new Promise((resolve) => {
            this._loadedResolve = resolve;
        });
    }
    /**
     * The original size of the source image in pixels
     */
    get width() {
        return this.image.naturalWidth;
    }
    /**
     * The original height of the source image in pixels
     */
    get height() {
        return this.image.naturalHeight;
    }
    /**
     * Returns true if the Texture is completely loaded and is ready
     * to be drawn.
     */
    isLoaded() {
        return !!this.data.src;
    }
    get image() {
        return this.data;
    }
    /**
     * Begins loading the image and returns a promise that resolves when the image is loaded
     */
    load() {
        return ImageSource_awaiter(this, void 0, void 0, function* () {
            if (this.isLoaded()) {
                return this.data;
            }
            try {
                // Load base64 or blob if needed
                let url;
                if (!this.path.includes('data:image/')) {
                    const blob = yield this._resource.load();
                    url = URL.createObjectURL(blob);
                }
                else {
                    url = this.path;
                }
                // Decode the image
                const image = new Image();
                image.src = url;
                yield image.decode();
                // Set results
                this.data = image;
            }
            catch (error) {
                throw `Error loading ImageSource from path '${this.path}' with error [${error.message}]`;
            }
            // todo emit complete
            this._loadedResolve(this.data);
            return this.data;
        });
    }
    /**
     * Build a sprite from this ImageSource
     */
    toSprite() {
        return Sprite.from(this);
    }
    /**
     * Create a ImageSource from legacy texture
     * @param tex
     */
    static fromLegacyTexture(tex) {
        const image = new ImageSource(tex.path);
        if (tex.isLoaded()) {
            image.data = tex.data;
        }
        else {
            tex.loaded.then(() => {
                image.data = tex.data;
            });
        }
        return image;
    }
    /**
     * Unload images from memory
     */
    unload() {
        this.data = new Image();
    }
}

;// CONCATENATED MODULE: ./Drawing/Animation.ts
var Animation_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






/**
 * @hidden
 * @deprecated Use [[Animation]]
 */
class AnimationImpl {
    /**
     * Typically you will use a [[SpriteSheet]] to generate an [[Animation]].
     *
     * @param engineOrConfig  Reference to the current game engine
     * @param sprites  An array of sprites to create the frames for the animation
     * @param speed   The number in milliseconds to display each frame in the animation
     * @param loop    Indicates whether the animation should loop after it is completed
     */
    constructor(engineOrConfig, sprites, speed, loop) {
        /**
         * The sprite frames to play, in order. See [[SpriteSheet.getAnimationForAll]] to quickly
         * generate an [[Animation]].
         */
        this.sprites = [];
        /**
         * Current frame index being shown
         */
        this.currentFrame = 0;
        this._timeLeftInFrame = 0;
        this._idempotencyToken = -1;
        this.anchor = Vector.Zero;
        this.rotation = 0.0;
        this.scale = Vector.One;
        /**
         * Indicates whether the animation should loop after it is completed
         */
        this.loop = true;
        /**
         * Indicates the frame index the animation should freeze on for a non-looping
         * animation. By default it is the last frame.
         */
        this.freezeFrame = -1;
        /**
         * Flip each frame vertically. Sets [[Sprite.flipVertical]].
         */
        this.flipVertical = false;
        /**
         * Flip each frame horizontally. Sets [[Sprite.flipHorizontal]].
         */
        this.flipHorizontal = false;
        this.drawWidth = 0;
        this.drawHeight = 0;
        this.width = 0;
        this.height = 0;
        this._opacity = 1;
        let engine = engineOrConfig;
        if (engineOrConfig && !(engineOrConfig instanceof Engine)) {
            const config = engineOrConfig;
            engine = config.engine;
            sprites = config.sprites;
            speed = config.speed;
            loop = config.loop;
        }
        this.sprites = sprites;
        this.speed = speed;
        this._engine = engine;
        this._timeLeftInFrame = this.speed;
        if (loop != null) {
            this.loop = loop;
        }
        if (sprites && sprites[0]) {
            this.drawHeight = sprites[0] ? sprites[0].drawHeight : 0;
            this.drawWidth = sprites[0] ? sprites[0].drawWidth : 0;
            this.width = sprites[0] ? sprites[0].width : 0;
            this.height = sprites[0] ? sprites[0].height : 0;
            this.freezeFrame = sprites.length - 1;
        }
    }
    /**
     * Applies the opacity effect to a sprite, setting the alpha of all pixels to a given value
     */
    opacity(value) {
        this._opacity = value;
    }
    /**
     * Applies the grayscale effect to a sprite, removing color information.
     */
    grayscale() {
        this.addEffect(new Grayscale());
    }
    /**
     * Applies the invert effect to a sprite, inverting the pixel colors.
     */
    invert() {
        this.addEffect(new Invert());
    }
    /**
     * Applies the fill effect to a sprite, changing the color channels of all non-transparent pixels to match a given color
     */
    fill(color) {
        this.addEffect(new Fill(color));
    }
    /**
     * Applies the colorize effect to a sprite, changing the color channels of all pixels to be the average of the original color and the
     * provided color.
     */
    colorize(color) {
        this.addEffect(new Colorize(color));
    }
    /**
     * Applies the lighten effect to a sprite, changes the lightness of the color according to hsl
     */
    lighten(factor = 0.1) {
        this.addEffect(new Lighten(factor));
    }
    /**
     * Applies the darken effect to a sprite, changes the darkness of the color according to hsl
     */
    darken(factor = 0.1) {
        this.addEffect(new Darken(factor));
    }
    /**
     * Applies the saturate effect to a sprite, saturates the color according to hsl
     */
    saturate(factor = 0.1) {
        this.addEffect(new Saturate(factor));
    }
    /**
     * Applies the desaturate effect to a sprite, desaturates the color according to hsl
     */
    desaturate(factor = 0.1) {
        this.addEffect(new Desaturate(factor));
    }
    /**
     * Add a [[SpriteEffect]] manually
     */
    addEffect(effect) {
        for (const i in this.sprites) {
            this.sprites[i].addEffect(effect);
        }
    }
    removeEffect(param) {
        for (const i in this.sprites) {
            this.sprites[i].removeEffect(param);
        }
    }
    /**
     * Clear all sprite effects
     */
    clearEffects() {
        for (const i in this.sprites) {
            this.sprites[i].clearEffects();
        }
    }
    _setAnchor(point) {
        //if (!this.anchor.equals(point)) {
        for (const i in this.sprites) {
            this.sprites[i].anchor.setTo(point.x, point.y);
        }
        //}
    }
    _setRotation(radians) {
        //if (this.rotation !== radians) {
        for (const i in this.sprites) {
            this.sprites[i].rotation = radians;
        }
        //}
    }
    _setScale(scale) {
        //if (!this.scale.equals(scale)) {
        for (const i in this.sprites) {
            this.sprites[i].scale = scale;
        }
        //}
    }
    /**
     * Resets the animation to first frame.
     */
    reset() {
        this.currentFrame = 0;
    }
    /**
     * Indicates whether the animation is complete, animations that loop are never complete.
     */
    isDone() {
        return !this.loop && this.currentFrame >= this.sprites.length;
    }
    /**
     * Not meant to be called by game developers. Ticks the animation forward internally and
     * calculates whether to change to the frame.
     * @internal
     */
    tick(elapsed, idempotencyToken) {
        if (this._idempotencyToken === idempotencyToken) {
            return;
        }
        this._idempotencyToken = idempotencyToken;
        this._timeLeftInFrame -= elapsed;
        if (this._timeLeftInFrame <= 0) {
            this.currentFrame = this.loop ? (this.currentFrame + 1) % this.sprites.length : this.currentFrame + 1;
            this._timeLeftInFrame = this.speed;
        }
        this._updateValues();
        const current = this.sprites[this.currentFrame];
        if (current) {
            this.width = current.width;
            this.height = current.height;
            this.drawWidth = current.drawWidth;
            this.drawHeight = current.drawHeight;
        }
    }
    _updateValues() {
        this._setAnchor(this.anchor);
        this._setRotation(this.rotation);
        this._setScale(this.scale);
    }
    /**
     * Skips ahead a specified number of frames in the animation
     * @param frames  Frames to skip ahead
     */
    skip(frames) {
        this.currentFrame = (this.currentFrame + frames) % this.sprites.length;
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const animOptions = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.drawWidth, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.drawHeight, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, opacity: ((_g = options.opacity) !== null && _g !== void 0 ? _g : 1) * ((_h = this._opacity) !== null && _h !== void 0 ? _h : 1) });
        this._updateValues();
        let currSprite;
        if (this.currentFrame < this.sprites.length) {
            currSprite = this.sprites[this.currentFrame];
            currSprite.draw(animOptions);
        }
        if (this.freezeFrame !== -1 && this.currentFrame >= this.sprites.length) {
            currSprite = this.sprites[clamp(this.freezeFrame, 0, this.sprites.length - 1)];
            currSprite.draw(animOptions);
        }
        // add the calculated width
        if (currSprite) {
            this.drawWidth = currSprite.drawWidth;
            this.drawHeight = currSprite.drawHeight;
        }
    }
    /**
     * Plays an animation at an arbitrary location in the game.
     * @param x  The x position in the game to play
     * @param y  The y position in the game to play
     */
    play(x, y) {
        this.reset();
        this._engine.playAnimation(this, x, y);
    }
}
/**
 * Animations allow you to display a series of images one after another,
 * creating the illusion of change. Generally these images will come from a [[SpriteSheet]] source.
 * @deprecated Use [[Animation]]
 */
let Animation_Animation = class Animation extends Configurable(AnimationImpl) {
    constructor(engineOrConfig, images, speed, loop) {
        super(engineOrConfig, images, speed, loop);
    }
};
Animation_Animation = Animation_decorate([
    obsolete({
        message: 'Animation will be removed in v0.26.0',
        alternateMethod: 'Use Graphics.Animation'
    })
], Animation_Animation);


;// CONCATENATED MODULE: ./Graphics/FontCommon.ts
/**
 * Enum representing the different font size units
 * https://developer.mozilla.org/en-US/docs/Web/CSS/font-size
 */
var FontUnit;
(function (FontUnit) {
    /**
     * Em is a scalable unit, 1 em is equal to the current font size of the current element, parent elements can effect em values
     */
    FontUnit["Em"] = "em";
    /**
     * Rem is similar to the Em, it is a scalable unit. 1 rem is equal to the font size of the root element
     */
    FontUnit["Rem"] = "rem";
    /**
     * Pixel is a unit of length in screen pixels
     */
    FontUnit["Px"] = "px";
    /**
     * Point is a physical unit length (1/72 of an inch)
     */
    FontUnit["Pt"] = "pt";
    /**
     * Percent is a scalable unit similar to Em, the only difference is the Em units scale faster when Text-Size stuff
     */
    FontUnit["Percent"] = "%";
})(FontUnit || (FontUnit = {}));
/**
 * Enum representing the different horizontal text alignments
 */
var TextAlign;
(function (TextAlign) {
    /**
     * The text is left-aligned.
     */
    TextAlign["Left"] = "left";
    /**
     * The text is right-aligned.
     */
    TextAlign["Right"] = "right";
    /**
     * The text is centered.
     */
    TextAlign["Center"] = "center";
    /**
     * The text is aligned at the normal start of the line (left-aligned for left-to-right locales,
     * right-aligned for right-to-left locales).
     */
    TextAlign["Start"] = "start";
    /**
     * The text is aligned at the normal end of the line (right-aligned for left-to-right locales,
     * left-aligned for right-to-left locales).
     */
    TextAlign["End"] = "end";
})(TextAlign || (TextAlign = {}));
/**
 * Enum representing the different baseline text alignments
 */
var BaseAlign;
(function (BaseAlign) {
    /**
     * The text baseline is the top of the em square.
     */
    BaseAlign["Top"] = "top";
    /**
     * The text baseline is the hanging baseline.  Currently unsupported; this will act like
     * alphabetic.
     */
    BaseAlign["Hanging"] = "hanging";
    /**
     * The text baseline is the middle of the em square.
     */
    BaseAlign["Middle"] = "middle";
    /**
     * The text baseline is the normal alphabetic baseline.
     */
    BaseAlign["Alphabetic"] = "alphabetic";
    /**
     * The text baseline is the ideographic baseline; this is the bottom of
     * the body of the characters, if the main body of characters protrudes
     * beneath the alphabetic baseline.  Currently unsupported; this will
     * act like alphabetic.
     */
    BaseAlign["Ideographic"] = "ideographic";
    /**
     * The text baseline is the bottom of the bounding box.  This differs
     * from the ideographic baseline in that the ideographic baseline
     * doesn't consider descenders.
     */
    BaseAlign["Bottom"] = "bottom";
})(BaseAlign || (BaseAlign = {}));
/**
 * Enum representing the different possible font styles
 */
var FontStyle;
(function (FontStyle) {
    FontStyle["Normal"] = "normal";
    FontStyle["Italic"] = "italic";
    FontStyle["Oblique"] = "oblique";
})(FontStyle || (FontStyle = {}));
var Direction;
(function (Direction) {
    Direction["LeftToRight"] = "ltr";
    Direction["RightToLeft"] = "rtl";
})(Direction || (Direction = {}));

;// CONCATENATED MODULE: ./Drawing/SpriteSheet.ts
var SpriteSheet_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};









/**
 * Sprite sheets are a useful mechanism for slicing up image resources into
 * separate sprites or for generating in game animations. [[Sprite|Sprites]] are organized
 * in row major order in the [[SpriteSheet]].
 * @deprecated Will be removed in v0.26.0
 */
class SpriteSheet_SpriteSheet {
    /**
     * @param imageOrConfigOrSprites The backing image texture to build the SpriteSheet, option bag, or sprite list
     * @param columns   The number of columns in the image texture
     * @param rows      The number of rows in the image texture
     * @param spWidth   The width of each individual sprite in pixels
     * @param spHeight  The height of each individual sprite in pixels
     * @param spacing   The spacing between every sprite in a spritesheet
     */
    constructor(imageOrConfigOrSprites, columns, rows, spWidth, spHeight, spacing) {
        this._sprites = [];
        this._image = null;
        this._columns = 0;
        this._rows = 0;
        this._spWidth = 0;
        this._spHeight = 0;
        this._spacing = 0;
        let loadFromImage = false;
        if (imageOrConfigOrSprites instanceof Array) {
            this._sprites = imageOrConfigOrSprites;
        }
        else {
            if (imageOrConfigOrSprites && !(imageOrConfigOrSprites instanceof Texture)) {
                this._columns = imageOrConfigOrSprites.columns;
                this._rows = imageOrConfigOrSprites.rows;
                this._spWidth = imageOrConfigOrSprites.spWidth;
                this._spHeight = imageOrConfigOrSprites.spHeight;
                this._image = imageOrConfigOrSprites.image;
                this._spacing = imageOrConfigOrSprites.spacing || 0;
            }
            else {
                this._image = imageOrConfigOrSprites;
                this._columns = columns;
                this._rows = rows;
                this._spWidth = spWidth;
                this._spHeight = spHeight;
                this._spacing = spacing || 0;
            }
            this._sprites = new Array(this._columns * this._rows);
            loadFromImage = true;
        }
        // Inspect actual image dimensions with preloading
        if (this.image instanceof Texture) {
            let isWidthError = false;
            let isHeightError = false;
            if (this.image.isLoaded()) {
                isWidthError = this.spWidth * this.columns > this.image.image.naturalWidth;
                isHeightError = this.spHeight * this.rows > this.image.image.naturalHeight;
                if (isWidthError) {
                    throw new RangeError(`SpriteSheet specified is wider, ` +
                        `${this.columns} cols x ${this.spWidth} pixels > ${this.image.image.naturalWidth} ` +
                        `pixels than image width`);
                }
                if (isHeightError) {
                    throw new RangeError(`SpriteSheet specified is taller, ` +
                        `${this.rows} rows x ${this.spHeight} pixels > ${this.image.image.naturalHeight} ` +
                        `pixels than image height`);
                }
            }
        }
        if (loadFromImage) {
            const spacing = this.getSpacingDimensions();
            for (let row = 0; row < this.rows; row++) {
                for (let col = 0; col < this.columns; col++) {
                    this._sprites[col + row * this.columns] = new Sprite_Sprite(this.image, col * this.spWidth + spacing.margin * col + spacing.left, row * this.spHeight + spacing.margin * row + spacing.top, this.spWidth, this.spHeight);
                }
            }
        }
    }
    /**
     * Gets the raw spacing dimensions for the sprites in the sheet, which can be a fixed number or custom dimensions.
     */
    get spacing() {
        return this._spacing;
    }
    /**
     * Get a copy of the backing sprite array
     */
    get sprites() {
        return [...this._sprites];
    }
    /**
     * The backing texture used for the sprite sheet
     */
    get image() {
        return this._image;
    }
    /**
     * The number of columns in the sheet
     */
    get columns() {
        return this._columns;
    }
    /**
     * The number of rows in the sheet
     */
    get rows() {
        return this._rows;
    }
    /**
     * The width of the individual sprites
     */
    get spWidth() {
        return this._spWidth;
    }
    /**
     * The height of the individual sprites
     */
    get spHeight() {
        return this._spHeight;
    }
    /**
     * Gets the calculated spacing dimensions based on whether spacing
     * is a fixed number or has different values for each dimension
     */
    getSpacingDimensions() {
        var _a, _b, _c;
        if (typeof this.spacing === 'number') {
            return {
                left: this.spacing,
                top: this.spacing,
                margin: this.spacing
            };
        }
        else {
            return {
                left: (_a = this.spacing.left) !== null && _a !== void 0 ? _a : 0,
                top: (_b = this.spacing.top) !== null && _b !== void 0 ? _b : 0,
                margin: (_c = this.spacing.margin) !== null && _c !== void 0 ? _c : 0
            };
        }
    }
    /**
     * Create an animation from the this SpriteSheet by listing out the
     * sprite indices. Sprites are organized in row major order in the SpriteSheet.
     * @param engine   Reference to the current game [[Engine]]
     * @param indices  An array of sprite indices to use in the animation
     * @param speed    The number in milliseconds to display each frame in the animation
     */
    getAnimationByIndices(engine, indices, speed) {
        let images = indices.map((index) => {
            return this.sprites[index];
        });
        images = images.map(function (i) {
            return i.clone();
        });
        return new Animation_Animation(engine, images, speed);
    }
    /**
     * Create an animation from the this SpriteSheet by specifying the range of
     * images with the beginning (inclusive) and ending (exclusive) index
     * For example `getAnimationBetween(engine, 0, 5, 200)` returns an animation with 5 frames.
     * @param engine      Reference to the current game Engine
     * @param beginIndex  The index to start taking frames (inclusive)
     * @param endIndex    The index to stop taking frames (exclusive)
     * @param speed       The number in milliseconds to display each frame in the animation
     */
    getAnimationBetween(engine, beginIndex, endIndex, speed) {
        let images = this.sprites.slice(beginIndex, endIndex);
        images = images.map(function (i) {
            return i.clone();
        });
        return new Animation_Animation(engine, images, speed);
    }
    /**
     * Treat the entire SpriteSheet as one animation, organizing the frames in
     * row major order.
     * @param engine  Reference to the current game [[Engine]]
     * @param speed   The number in milliseconds to display each frame the animation
     */
    getAnimationForAll(engine, speed) {
        const sprites = this.sprites.map(function (i) {
            return i.clone();
        });
        return new Animation_Animation(engine, sprites, speed);
    }
    /**
     * Retrieve a specific sprite from the SpriteSheet by its index. Sprites are organized
     * in row major order in the SpriteSheet.
     * @param index  The index of the sprite
     */
    getSprite(index) {
        if (index >= 0 && index < this.sprites.length) {
            return this.sprites[index];
        }
        else {
            throw new Error('Invalid index: ' + index);
        }
    }
    /**
     * Get an animation with bespoke sprite coordinates. This is useful if the SpriteSheet is
     * packed and not a uniform width or height. The resulting [[Animation]] will have the height and width of the
     * largest dimension (width, height) from among the sprite coordinates
     * @param engine
     * @param spriteCoordinates
     * @param speed
     */
    getAnimationByCoords(engine, spriteCoordinates, speed) {
        let maxWidth = 0;
        let maxHeight = 0;
        const sprites = new Array(spriteCoordinates.length);
        for (let i = 0; i < spriteCoordinates.length; i++) {
            const coord = spriteCoordinates[i];
            // no need to pass image again if using a spritesheet
            coord.image = coord.image || this.image;
            maxWidth = Math.max(maxWidth, coord.drawWidth);
            maxHeight = Math.max(maxHeight, coord.drawHeight);
            sprites[i] = new Sprite_Sprite(coord);
        }
        const anim = new Animation_Animation(engine, sprites, speed);
        anim.drawWidth = maxWidth;
        anim.drawHeight = maxHeight;
        return anim;
    }
}
/**
 * Sprite fonts are a used in conjunction with a [[Label]] to specify
 * a particular bitmap as a font. Note that some font features are not
 * supported by Sprite fonts.
 * @deprecated Will be removed into v0.26.0
 */
let SpriteFont = class SpriteFont extends SpriteSheet_SpriteSheet {
    /**
     * @param imageOrConfig   The backing image texture to build the SpriteFont or the sprite font option bag
     * @param alphabet        A string representing all the characters in the image, in row major order.
     * @param caseInsensitive  Indicate whether this font takes case into account
     * @param columns         The number of columns of characters in the image
     * @param rows            The number of rows of characters in the image
     * @param spWidth         The width of each character in pixels
     * @param spHeight        The height of each character in pixels
     */
    constructor(imageOrConfig, alphabet, caseInsensitive, columns, rows, spWidth, spHeight, spacing) {
        super(imageOrConfig instanceof Texture
            ? {
                image: imageOrConfig,
                spWidth: spWidth,
                spHeight: spHeight,
                rows: rows,
                columns: columns,
                spacing: spacing || 0
            }
            : imageOrConfig);
        this._currentColor = Color.Black;
        this._currentOpacity = 1.0;
        this._spriteRecord = {};
        // text shadow
        this._textShadowOn = false;
        this._textShadowDirty = true;
        this._textShadowColor = Color.Black;
        this._textShadowSprites = {};
        this._shadowOffsetX = 5;
        this._shadowOffsetY = 5;
        if (imageOrConfig && !(imageOrConfig instanceof Texture)) {
            alphabet = imageOrConfig.alphabet;
            caseInsensitive = imageOrConfig.caseInsensitive;
        }
        this.alphabet = alphabet;
        this.caseInsensitive = caseInsensitive;
        this._spriteRecord = this.getTextSprites();
    }
    /**
     * Returns a dictionary that maps each character in the alphabet to the appropriate [[Sprite]].
     */
    getTextSprites() {
        const lookup = {};
        for (let i = 0; i < this.alphabet.length; i++) {
            let char = this.alphabet[i];
            if (this.caseInsensitive) {
                char = char.toLowerCase();
            }
            lookup[char] = this.sprites[i].clone();
        }
        return lookup;
    }
    /**
     * Sets the text shadow for sprite fonts
     * @param offsetX      The x offset in pixels to place the shadow
     * @param offsetY      The y offset in pixels to place the shadow
     * @param shadowColor  The color of the text shadow
     */
    setTextShadow(offsetX, offsetY, shadowColor) {
        this._textShadowOn = true;
        this._shadowOffsetX = offsetX;
        this._shadowOffsetY = offsetY;
        this._textShadowColor = shadowColor.clone();
        this._textShadowDirty = true;
        for (const character in this._spriteRecord) {
            this._textShadowSprites[character] = this._spriteRecord[character].clone();
        }
    }
    /**
     * Toggles text shadows on or off
     */
    useTextShadow(on) {
        this._textShadowOn = on;
        if (on) {
            this.setTextShadow(5, 5, this._textShadowColor);
        }
    }
    /**
     * Draws the current sprite font
     */
    draw(ctx, text, x, y, options) {
        options = this._parseOptions(options);
        if (this._currentColor.toString() !== options.color.toString() || this._currentOpacity !== options.opacity) {
            this._currentOpacity = options.opacity;
            this._currentColor = options.color;
            for (const char in this._spriteRecord) {
                this._spriteRecord[char].clearEffects();
                this._spriteRecord[char].fill(options.color);
                this._spriteRecord[char].opacity(options.opacity);
            }
        }
        if (this._textShadowOn && this._textShadowDirty && this._textShadowColor) {
            for (const characterShadow in this._textShadowSprites) {
                this._textShadowSprites[characterShadow].clearEffects();
                this._textShadowSprites[characterShadow].addEffect(new Fill(this._textShadowColor.clone()));
            }
            this._textShadowDirty = false;
        }
        // find the current length of text in pixels
        const sprite = this.sprites[0];
        // find the current height fo the text in pixels
        const height = sprite.height;
        // calculate appropriate scale for font size
        const scale = options.fontSize / height;
        const length = text.length * sprite.width * scale + text.length * options.letterSpacing;
        let currX = x;
        if (options.textAlign === TextAlign.Left || options.textAlign === TextAlign.Start) {
            currX = x;
        }
        else if (options.textAlign === TextAlign.Right || options.textAlign === TextAlign.End) {
            currX = x - length;
        }
        else if (options.textAlign === TextAlign.Center) {
            currX = x - length / 2;
        }
        let currY = y - height * scale;
        if (options.baseAlign === BaseAlign.Top || options.baseAlign === BaseAlign.Hanging) {
            currY = y;
        }
        else if (options.baseAlign === BaseAlign.Ideographic ||
            options.baseAlign === BaseAlign.Bottom ||
            options.baseAlign === BaseAlign.Alphabetic) {
            currY = y - height * scale;
        }
        else if (options.baseAlign === BaseAlign.Middle) {
            currY = y - (height * scale) / 2;
        }
        for (let i = 0; i < text.length; i++) {
            let character = text[i];
            if (this.caseInsensitive) {
                character = character.toLowerCase();
            }
            try {
                // if text shadow
                if (this._textShadowOn) {
                    this._textShadowSprites[character].drawAroundAnchor = false;
                    this._textShadowSprites[character].scale = vec(scale, scale);
                    this._textShadowSprites[character].draw(ctx, currX + this._shadowOffsetX, currY + this._shadowOffsetY);
                }
                const charSprite = this._spriteRecord[character];
                charSprite.drawAroundAnchor = false;
                charSprite.scale = vec(scale, scale);
                charSprite.draw(ctx, currX, currY);
                currX += charSprite.drawWidth + options.letterSpacing;
            }
            catch (e) {
                Logger.getInstance().error(`SpriteFont Error drawing char ${character}`);
            }
        }
    }
    _parseOptions(options) {
        return {
            fontSize: options.fontSize || 10,
            letterSpacing: options.letterSpacing || 0,
            color: options.color || Color.Black,
            textAlign: typeof options.textAlign === undefined ? TextAlign.Left : options.textAlign,
            baseAlign: typeof options.baseAlign === undefined ? BaseAlign.Bottom : options.baseAlign,
            maxWidth: options.maxWidth || -1,
            opacity: options.opacity || 0
        };
    }
};
SpriteFont = SpriteSheet_decorate([
    obsolete({
        message: 'SpriteSheet will be removed in v0.26.0',
        alternateMethod: 'Use Graphics.SpriteSheet'
    })
], SpriteFont);


;// CONCATENATED MODULE: ./Graphics/SpriteSheet.ts



/**
 * Represents a collection of sprites from a source image with some organization in a grid
 */
class SpriteSheet {
    /**
     * Build a new sprite sheet from a list of sprites
     *
     * Use [[SpriteSheet.fromImageSource]] to create a SpriteSheet from an [[ImageSource]] organized in a grid
     * @param options
     */
    constructor(options) {
        this._logger = Logger.getInstance();
        this.sprites = [];
        const { sprites, rows, columns } = options;
        this.sprites = sprites;
        this.rows = rows !== null && rows !== void 0 ? rows : 1;
        this.columns = columns !== null && columns !== void 0 ? columns : this.sprites.length;
    }
    /**
     * Find a sprite by their x/y position in the SpriteSheet, for example `getSprite(0, 0)` is the [[Sprite]] in the top-left
     * @param x
     * @param y
     */
    getSprite(x, y) {
        if (x >= this.columns || x < 0) {
            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), x: ${x} should be between 0 and ${this.columns - 1}`);
            return null;
        }
        if (y >= this.rows || y < 0) {
            this._logger.warn(`No sprite exists in the SpriteSheet at (${x}, ${y}), y: ${y} should be between 0 and ${this.rows - 1}`);
            return null;
        }
        const spriteIndex = x + y * this.columns;
        return this.sprites[spriteIndex];
    }
    /**
     * To a graphics sprite sheet from a legacy sprite sheet
     */
    static fromLegacySpriteSheet(legacySpriteSheet) {
        const sprites = legacySpriteSheet.sprites.map(oldSprite => Sprite.fromLegacySprite(oldSprite));
        return new SpriteSheet({
            sprites
        });
    }
    /**
     * @deprecated
     * @param spriteSheet
     * @returns
     */
    static toLegacySpriteSheet(spriteSheet) {
        const sprites = spriteSheet.sprites.map(sprite => Sprite.toLegacySprite(sprite));
        return new SpriteSheet_SpriteSheet(sprites);
    }
    /**
     * Create a SpriteSheet from an [[ImageSource]] organized in a grid
     *
     * Example:
     * ```
     * const spriteSheet = SpriteSheet.fromImageSource({
     *   image: imageSource,
     *   grid: {
     *     rows: 5,
     *     columns: 2,
     *     spriteWidth: 32, // pixels
     *     spriteHeight: 32 // pixels
     *   },
     *   // Optionally specify spacing
     *   spacing: {
     *     // pixels from the top left to start the sprite parsing
     *     originOffset: {
     *       x: 5,
     *       y: 5
     *     },
     *     // pixels between each sprite while parsing
     *     margin: {
     *       x: 1,
     *       y: 1
     *     }
     *   }
     * })
     * ```
     *
     * @param options
     */
    static fromImageSource(options) {
        var _a;
        const sprites = [];
        options.spacing = (_a = options.spacing) !== null && _a !== void 0 ? _a : {};
        const { image, grid: { rows, columns: cols, spriteWidth, spriteHeight }, spacing: { originOffset, margin } } = options;
        const offsetDefaults = Object.assign({ x: 0, y: 0 }, originOffset);
        const marginDefaults = Object.assign({ x: 0, y: 0 }, margin);
        for (let x = 0; x < cols; x++) {
            for (let y = 0; y < rows; y++) {
                sprites[x + y * cols] = new Sprite({
                    image: image,
                    sourceView: {
                        x: x * spriteWidth + marginDefaults.x * x + offsetDefaults.x,
                        y: y * spriteHeight + marginDefaults.y * y + offsetDefaults.y,
                        width: spriteWidth,
                        height: spriteHeight
                    },
                    destSize: { height: spriteHeight, width: spriteWidth }
                });
            }
        }
        return new SpriteSheet({
            sprites: sprites,
            rows: rows,
            columns: cols
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/SpriteFont.ts




class SpriteFont_SpriteFont extends Graphic {
    constructor(options) {
        super(options);
        this._text = '';
        this._dirty = true;
        this.alphabet = '';
        this.shadow = null;
        this.caseInsensitive = false;
        this.spacing = 0;
        this._logger = Logger.getInstance();
        this._sprites = [];
        const { alphabet, spriteSheet, caseInsensitive, spacing, shadow } = options;
        this.alphabet = alphabet;
        this.spriteSheet = spriteSheet;
        this.caseInsensitive = caseInsensitive !== null && caseInsensitive !== void 0 ? caseInsensitive : this.caseInsensitive;
        this.spacing = spacing !== null && spacing !== void 0 ? spacing : this.spacing;
        this.shadow = shadow !== null && shadow !== void 0 ? shadow : this.shadow;
        this.spriteSheet.sprites[0].image.ready.then(() => {
            this._updateDimensions();
        });
    }
    static fromLegacySpriteFont(spriteFont) {
        const sprites = spriteFont.sprites.map(Sprite.fromLegacySprite);
        return new SpriteFont_SpriteFont({
            alphabet: spriteFont.alphabet,
            spacing: 0,
            caseInsensitive: spriteFont.caseInsensitive,
            spriteSheet: new SpriteSheet({
                sprites
            })
        });
    }
    _getCharacterSprites(text) {
        if (!this._dirty) {
            return this._sprites;
        }
        const results = [];
        // handle case insenstive
        const textToRender = this.caseInsensitive ? text.toLocaleLowerCase() : text;
        const alphabet = this.caseInsensitive ? this.alphabet.toLocaleLowerCase() : this.alphabet;
        // for each letter in text
        for (let letterIndex = 0; letterIndex < textToRender.length; letterIndex++) {
            // find the sprite index in alphabet , if there is an error pick the first
            const letter = textToRender[letterIndex];
            let spriteIndex = alphabet.indexOf(letter);
            if (spriteIndex === -1) {
                spriteIndex = 0;
                this._logger.warn(`SpriteFont - Cannot find letter '${letter}' in configured alphabet '${alphabet}'`);
            }
            const letterSprite = this.spriteSheet.sprites[spriteIndex];
            if (letterSprite) {
                results.push(letterSprite);
            }
            else {
                this._logger.warn(`SpriteFont - Cannot find sprite for '${letter}' at index '${spriteIndex}' in configured SpriteSheet`);
            }
        }
        this._dirty = false;
        return (this._sprites = results);
    }
    _updateDimensions() {
        const sprites = this._getCharacterSprites(this._text);
        let width = 0;
        let height = 0;
        for (const sprite of sprites) {
            width += sprite.width + this.spacing;
            height = Math.max(height, sprite.height);
        }
        this.width = width;
        this.height = height;
    }
    updateText(text) {
        if (this._text !== text) {
            this._dirty = true;
            this._text = text;
            this._updateDimensions();
        }
    }
    _preDraw(ex, x, y) {
        this._updateDimensions();
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        let cursor = 0;
        for (const sprite of this._getCharacterSprites(this._text)) {
            // draw it in the right spot and increase the cursor by sprite width
            sprite.draw(ex, x + cursor, y);
            cursor += sprite.width + this.spacing;
        }
    }
    render(ex, text, x, y) {
        if (this._text !== text) {
            this._dirty = true;
            this._text = text;
        }
        if (this.shadow) {
            ex.save();
            ex.translate(this.shadow.offset.x, this.shadow.offset.y);
            this.draw(ex, x, y);
            ex.restore();
        }
        this.draw(ex, x, y);
    }
    clone() {
        return new SpriteFont_SpriteFont({
            alphabet: this.alphabet,
            spriteSheet: this.spriteSheet,
            spacing: this.spacing
        });
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/debug-font.png
/* harmony default export */ const debug_font = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAAwCAYAAAD+f6R/AAAAAXNSR0IArs4c6QAABcJJREFUeJztnemu7CgMhGE07//KmT9NhrAFVzkQndQntXRP3/bCZkwCSQhCCCGEEEIIIYQQQog/TRz953Ecx/nDGIe/vdNhlc9tIz605Fk/ZmWfsO1hn9Gxuv1KHbvb3iL/VN+d1WORbyr7yR/5b9M4vjNeqko6jPJHq5wGHU151o9J2Udse9hndCxuv0rH7rY3yD/Wdyf13MrnQeDfkZIUSGKM4ff3cWN82pEZuTyQGX2IxeyR63va//8VNCYCq+1yEkLtWyagXv1P1r1H+110gP3PzT4gT8uW/mdQ8mUG8E9DqOz4MS9ICKGbXpS2BpnIrRzYeS96cll08INlCMl2/glzdcfazuuPqQO03lmqrBHsf272Q6NODXj6zzZIJd/LAHYTg3Mays5gBi7ZR27fOgs0yj8rm36DLMFiPgkAdXHKOwUQeMCQ/adSh/qBQrT/tPxbAwA9+DOZEILPAATSuHMgTv7+Auk/df2lHPCZLvMSLJe34LkEQ9PwXF1SRTllMYgvIaflqyVAjLGbsiCDcOK76jflxZ+sINPyROc5071yKWK5CJTV3dMp6+tBlyCtNlhAq/+XbWoBDcRNXYBMzD4VvQygSuPYC2jGGaSSOxXfy3dTUEsanIvNeepm38N/hssSALTPZnAXfwIYRJn2b7UBcw0FKX+nDdAMpm2j9WVnxrUa7TXaVAca/B+TgaAVh6R/rH0P/5m01dt/RLYViJn+w/bhVX2P7f/duqom5qb02pRLCLGIMgBU1wCEEN9BAUCID6MAIMSHUQAQ4sMoAAjxYRQAhPgwd1uB0fuZ7H3cnn2P+9mr/Pe4B8/eB/fwP4eRtci/0f6OfTCPt/9oHwC6G6y19RHZDumxmwzR4eE/s/2Tte/q/+XLdc9DeJ19diesQc/j7Z8fCe4tAS4CxZ7sp7eiJi7HiZmjmOTGJs+93CbS3nP0XIPH3vW8/qz6QPnX2QdsV/1uw/iZYvg8ACeHd28rpPzfNfhL+7vkw/4Ou9s+Onhbv91elpKZ48Dl6bzpwwibHigRArf+Ptk9+L3Y1Q5OB4LgCeSBw1iuB3GeJh1/HrX/zF0A9Mk+u45zMkc3r4rWPomma5+p/514LB+Zo93MErJ1JHxXPzByGa/licRYVKbpeQCoQ6Q8yxuCwJF9IPsoDkHAo/3Tx26cvA4EtJ/n04w8QOq/mrR7ddfLAC5BYFNlVI/0CnOVUflOpvJUQMx9AIMIW/nWDM67/qw0+95v9goBqD9j+72u/KD9U89IbnQbMIR2Zbneh5zUY7Hdk7XIP3UffVb+r+wDYAZLq+1n1+C7y3/ny2r7p5yeByDEh9HzAIQQJwoAQnwYBQAhPowCgBBjoNu3hNxSFACE6INuKvPajPZ4EFEAEKINcybGYzOd247WEd3TgA2jlmjEyrd+j9hvfVbD2PWQ3ZmGlu2HyO8og8eBuNUvNYWoDgMVpwHTJoLWdz1Y+ZYOy5uF7t6PPruZxANrud1lQXkP0jsGz/Yz+vGGMuygFyhSPcJnc1pMnQZElc+cRnoAlxdTvoDuK7puqF7uCQy+3fyFMiA02/vJQHh7DQDogMPTSGFNA56HTzbZ9yAfBOb1Zyo3qGM3MfMZ3f76huXf6xlmAHknMlLNXsBBBvbljIz9Uyz5Y5TzIBLR/qy/rNyrZ8+L/0BZ0m+tgXD0OK5XZxC/9P7I/g4hVFvzXf1/6i5A7+3AlijMPBLMZfCvuAp7A9rY56ApHitmLQc7c8bOv6ftAxlM9Xp35nkEK7nJetBsaMhtAAAuOLQGXwhh2dXQnn1rZ/a42BI3dL7L+jkFAbQddwdA9Ah35yMKhgEgVT46EFh5D4jz+OgavNKxeBCd1wDSJ/97oR8eoJkLi9t9/BDgDHTJ5NE7Dnzechh914OVv9M1K9PCqsfqb88XVg9qN9lm6nG176UPu+zn17GOxuO0vOWEEC/j+LFKTgghlvEfYJaLS+SA2O0AAAAASUVORK5CYII=");
;// CONCATENATED MODULE: ./Graphics/Context/debug-text.ts


/**
 * Internal debugtext helper
 */
class DebugText {
    constructor() {
        /**
         * base64 font
         */
        this.fontSheet = debug_font;
        this.size = 16;
        this.load();
    }
    load() {
        this._imageSource = new ImageSource(this.fontSheet);
        return this._imageSource.load().then(() => {
            this._spriteSheet = SpriteSheet.fromImageSource({
                image: this._imageSource,
                grid: {
                    rows: 3,
                    columns: 16,
                    spriteWidth: 16,
                    spriteHeight: 16
                }
            });
            this._spriteFont = new SpriteFont_SpriteFont({
                alphabet: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ,!\'&."?-()+ ',
                caseInsensitive: true,
                spriteSheet: this._spriteSheet,
                spacing: -6
            });
        });
    }
    /**
     * Writes debug text using the built in sprint font
     * @param ctx
     * @param text
     * @param pos
     */
    write(ctx, text, pos) {
        if (this._imageSource.isLoaded()) {
            this._spriteFont.render(ctx, text, pos.x, pos.y);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContextWebGL.ts












class ExcaliburGraphicsContextWebGLDebug {
    constructor(_webglCtx) {
        this._webglCtx = _webglCtx;
        this._debugText = new DebugText();
    }
    /**
     * Draw a debugging rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height, rectOptions = { color: Color.Black }) {
        this.drawLine(vec(x, y), vec(x + width, y), Object.assign({}, rectOptions));
        this.drawLine(vec(x + width, y), vec(x + width, y + height), Object.assign({}, rectOptions));
        this.drawLine(vec(x + width, y + height), vec(x, y + height), Object.assign({}, rectOptions));
        this.drawLine(vec(x, y + height), vec(x, y), Object.assign({}, rectOptions));
    }
    /**
     * Draw a debugging line to the context
     * @param start
     * @param end
     * @param lineOptions
     */
    drawLine(start, end, lineOptions = { color: Color.Black }) {
        this._webglCtx.__lineRenderer.addLine(start, end, lineOptions.color);
    }
    /**
     * Draw a debugging point to the context
     * @param point
     * @param pointOptions
     */
    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {
        this._webglCtx.__pointRenderer.addPoint(point, pointOptions.color, pointOptions.size);
    }
    drawText(text, pos) {
        this._debugText.write(this._webglCtx, text, pos);
    }
}
class ExcaliburGraphicsContextWebGL {
    constructor(options) {
        this._transform = new TransformStack();
        this._state = new StateStack();
        this.snapToPixel = true;
        this.smoothing = false;
        this.backgroundColor = Color.ExcaliburBlue;
        this.debug = new ExcaliburGraphicsContextWebGLDebug(this);
        const { canvasElement, enableTransparency, smoothing, snapToPixel, backgroundColor } = options;
        this.__gl = canvasElement.getContext('webgl', {
            antialias: smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing,
            premultipliedAlpha: false,
            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true,
            depth: true,
            powerPreference: 'high-performance'
        });
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this._init();
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get width() {
        return this.__gl.canvas.width;
    }
    get height() {
        return this.__gl.canvas.height;
    }
    /**
     * Checks the underlying webgl implementation if the requested internal resolution is supported
     * @param dim
     */
    checkIfResolutionSupported(dim) {
        // Slight hack based on this thread https://groups.google.com/g/webgl-dev-list/c/AHONvz3oQTo
        const gl = this.__gl;
        // If any dimension is greater than max texture size (divide by 4 bytes per pixel)
        const maxDim = gl.getParameter(gl.MAX_TEXTURE_SIZE) / 4;
        let supported = true;
        if (dim.width > maxDim || dim.height > maxDim) {
            supported = false;
        }
        return supported;
    }
    _init() {
        const gl = this.__gl;
        // Setup viewport and view matrix
        this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        // Clear background
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        gl.clear(gl.COLOR_BUFFER_BIT);
        // Enable alpha blending
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        this.__pointRenderer = new PointRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });
        this.__lineRenderer = new LineRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });
        this.__imageRenderer = new ImageRenderer(gl, { matrix: this._ortho, transform: this._transform, state: this._state });
        // 2D ctx shim
        this._canvas = new Canvas({
            width: gl.canvas.width,
            height: gl.canvas.height
        });
        this.__ctx = this._canvas.ctx;
    }
    resetTransform() {
        this._transform.current = Matrix.identity();
    }
    updateViewport() {
        const gl = this.__gl;
        this._ortho = this._ortho = Matrix.ortho(0, gl.canvas.width, gl.canvas.height, 0, 400, -400);
        this.__pointRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);
        this.__lineRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);
        this.__imageRenderer.shader.addUniformMatrix('u_matrix', this._ortho.data);
        // 2D ctx shim
        this._canvas.width = gl.canvas.width;
        this._canvas.height = gl.canvas.height;
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (image.width === 0 || image.height === 0) {
            return; // zero dimension source exit early
        }
        if (!image) {
            Logger.getInstance().warn('Cannot draw a null or undefined image');
            // tslint:disable-next-line: no-console
            if (console.trace) {
                // tslint:disable-next-line: no-console
                console.trace();
            }
            return;
        }
        this.__imageRenderer.addImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight);
    }
    drawLine(start, end, color, thickness = 1) {
        this.__imageRenderer.addLine(color, start, end, thickness);
    }
    drawRectangle(pos, width, height, color) {
        this.__imageRenderer.addRectangle(color, pos, width, height);
    }
    drawCircle(pos, radius, color) {
        this.__imageRenderer.addCircle(pos, radius, color);
    }
    save() {
        this._transform.save();
        this._state.save();
    }
    restore() {
        this._transform.restore();
        this._state.restore();
    }
    translate(x, y) {
        this._transform.translate(this.snapToPixel ? ~~x : x, this.snapToPixel ? ~~y : y);
    }
    rotate(angle) {
        this._transform.rotate(angle);
    }
    scale(x, y) {
        this._transform.scale(x, y);
    }
    transform(matrix) {
        this._transform.current = matrix;
    }
    clear() {
        const gl = this.__gl;
        gl.clearColor(this.backgroundColor.r / 255, this.backgroundColor.g / 255, this.backgroundColor.b / 255, this.backgroundColor.a);
        // Clear the context with the newly set color. This is
        // the function call that actually does the drawing.
        gl.clear(gl.COLOR_BUFFER_BIT);
        GraphicsDiagnostics.clear();
    }
    /**
     * Flushes all batched rendering to the screen
     */
    flush() {
        const gl = this.__gl;
        gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
        this.__imageRenderer.render();
        this.__lineRenderer.render();
        this.__pointRenderer.render();
    }
}

;// CONCATENATED MODULE: ./Screen.ts





/**
 * Enum representing the different display modes available to Excalibur.
 */
var DisplayMode;
(function (DisplayMode) {
    /**
     * Default, use a specified resolution for the game. Like 800x600 pixels for example.
     */
    DisplayMode["Fixed"] = "Fixed";
    /**
     * Fit to screen using as much space as possible while maintaining aspect ratio and resolution.
     * This is not the same as [[Screen.goFullScreen]] but behaves in a similar way maintaining aspect ratio.
     *
     * You may want to center your game here is an example
     * ```html
     * <!-- html -->
     * <body>
     * <main>
     *   <canvas id="game"></canvas>
     * </main>
     * </body>
     * ```
     *
     * ```css
     * // css
     * main {
     *   display: flex;
     *   align-items: center;
     *   justify-content: center;
     *   height: 100%;
     *   width: 100%;
     * }
     * ```
     *
     */
    DisplayMode["FitScreen"] = "FitScreen";
    /**
     * Fill the entire screen's css width/height for the game resolution dynamically. This means the resolution of the game will
     * change dynamically as the window is resized. This is not the same as [[Screen.goFullScreen]]
     */
    DisplayMode["FillScreen"] = "FillScreen";
    /**
     * Fit to parent element width/height using as much space as possible while maintaining aspect ratio and resolution.
     */
    DisplayMode["FitContainer"] = "FitContainer";
    /**
     * Use the parent DOM container's css width/height for the game resolution dynamically
     */
    DisplayMode["FillContainer"] = "FillContainer";
    /**
     * Allow the game to be positioned with the [[EngineOptions.position]] option
     * @deprecated Use CSS to position the game canvas, will be removed in v0.26.0
     */
    DisplayMode["Position"] = "Position";
})(DisplayMode || (DisplayMode = {}));
/**
 * Convenience class for quick resolutions
 * Mostly sourced from https://emulation.gametechwiki.com/index.php/Resolution
 */
class Resolution {
    /* istanbul ignore next */
    static get SVGA() {
        return { width: 800, height: 600 };
    }
    /* istanbul ignore next */
    static get Standard() {
        return { width: 1920, height: 1080 };
    }
    /* istanbul ignore next */
    static get Atari2600() {
        return { width: 160, height: 192 };
    }
    /* istanbul ignore next */
    static get GameBoy() {
        return { width: 160, height: 144 };
    }
    /* istanbul ignore next */
    static get GameBoyAdvance() {
        return { width: 240, height: 160 };
    }
    /* istanbul ignore next */
    static get NintendoDS() {
        return { width: 256, height: 192 };
    }
    /* istanbul ignore next */
    static get NES() {
        return { width: 256, height: 224 };
    }
    /* istanbul ignore next */
    static get SNES() {
        return { width: 256, height: 244 };
    }
}
/**
 * The Screen handles all aspects of interacting with the screen for Excalibur.
 */
class Screen {
    constructor(options) {
        var _a, _b, _c;
        this._antialiasing = true;
        this._resolutionStack = [];
        this._viewportStack = [];
        this._pixelRatioOverride = null;
        this._isFullScreen = false;
        this._isDisposed = false;
        this._logger = Logger.getInstance();
        this._fullscreenChangeHandler = () => {
            this._isFullScreen = !this._isFullScreen;
            this._logger.debug('Fullscreen Change', this._isFullScreen);
        };
        this._pixelRatioChangeHandler = () => {
            this._logger.debug('Pixel Ratio Change', window.devicePixelRatio);
            this._devicePixelRatio = this._calculateDevicePixelRatio();
            this.applyResolutionAndViewport();
        };
        this._resizeHandler = () => {
            const parent = this.parent;
            this._logger.debug('View port resized');
            this._setResolutionAndViewportByDisplayMode(parent);
            this.applyResolutionAndViewport();
        };
        // Asking the window.devicePixelRatio is expensive we do it once
        this._devicePixelRatio = this._calculateDevicePixelRatio();
        this._alreadyWarned = false;
        this.viewport = options.viewport;
        this.resolution = (_a = options.resolution) !== null && _a !== void 0 ? _a : Object.assign({}, this.viewport);
        this._displayMode = (_b = options.displayMode) !== null && _b !== void 0 ? _b : DisplayMode.Fixed;
        this._canvas = options.canvas;
        this._ctx = options.context;
        this._antialiasing = (_c = options.antialiasing) !== null && _c !== void 0 ? _c : this._antialiasing;
        this._browser = options.browser;
        this._position = options.position;
        this._pixelRatioOverride = options.pixelRatio;
        this._applyDisplayMode();
        this._mediaQueryList = this._browser.window.nativeComponent.matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
        this._mediaQueryList.addEventListener('change', this._pixelRatioChangeHandler);
        this._canvas.addEventListener('fullscreenchange', this._fullscreenChangeHandler);
        this.applyResolutionAndViewport();
    }
    dispose() {
        if (!this._isDisposed) {
            // Clean up handlers
            this._isDisposed = true;
            this._browser.window.off('resize', this._resizeHandler);
            if (this._resizeObserver) {
                this._resizeObserver.disconnect();
            }
            this.parent.removeEventListener('resize', this._resizeHandler);
            this._mediaQueryList.removeEventListener('change', this._pixelRatioChangeHandler);
            this._canvas.removeEventListener('fullscreenchange', this._fullscreenChangeHandler);
        }
    }
    _calculateDevicePixelRatio() {
        if (window.devicePixelRatio < 1) {
            return 1;
        }
        const devicePixelRatio = window.devicePixelRatio || 1;
        return devicePixelRatio;
    }
    get pixelRatio() {
        if (this._pixelRatioOverride) {
            return this._pixelRatioOverride;
        }
        return this._devicePixelRatio;
    }
    get isHiDpi() {
        return this.pixelRatio !== 1;
    }
    get displayMode() {
        return this._displayMode;
    }
    get canvas() {
        return this._canvas;
    }
    get parent() {
        return ((this.displayMode === DisplayMode.FillContainer || this.displayMode === DisplayMode.FitContainer
            ? this.canvas.parentElement || document.body
            : window));
    }
    get resolution() {
        return this._resolution;
    }
    set resolution(resolution) {
        this._resolution = resolution;
    }
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return this._resolution;
    }
    set viewport(viewport) {
        this._viewport = viewport;
    }
    get aspectRatio() {
        return this._resolution.width / this._resolution.height;
    }
    get scaledWidth() {
        return this._resolution.width * this.pixelRatio;
    }
    get scaledHeight() {
        return this._resolution.height * this.pixelRatio;
    }
    setCurrentCamera(camera) {
        this._camera = camera;
    }
    pushResolutionAndViewport() {
        this._resolutionStack.push(this.resolution);
        this._viewportStack.push(this.viewport);
        this.resolution = Object.assign({}, this.resolution);
        this.viewport = Object.assign({}, this.viewport);
    }
    peekViewport() {
        return this._viewportStack[this._viewportStack.length - 1];
    }
    peekResolution() {
        return this._resolutionStack[this._resolutionStack.length - 1];
    }
    popResolutionAndViewport() {
        this.resolution = this._resolutionStack.pop();
        this.viewport = this._viewportStack.pop();
    }
    applyResolutionAndViewport() {
        this._canvas.width = this.scaledWidth;
        this._canvas.height = this.scaledHeight;
        if (this._ctx instanceof ExcaliburGraphicsContextWebGL) {
            const supported = this._ctx.checkIfResolutionSupported({
                width: this.scaledWidth,
                height: this.scaledHeight
            });
            if (!supported && !this._alreadyWarned) {
                this._alreadyWarned = true; // warn once
                this._logger.warn(`The currently configured resolution (${this.resolution.width}x${this.resolution.height})` +
                    ' is too large for the platform WebGL implementation, this may work but cause WebGL rendering to behave oddly.' +
                    ' Try reducing the resolution or disabling Hi DPI scaling to avoid this' +
                    ' (read more here https://excaliburjs.com/docs/screens#understanding-viewport--resolution).');
            }
        }
        if (this._antialiasing) {
            this._canvas.style.imageRendering = 'auto';
        }
        else {
            this._canvas.style.imageRendering = 'pixelated';
            // Fall back to 'crisp-edges' if 'pixelated' is not supported
            // Currently for firefox https://developer.mozilla.org/en-US/docs/Web/CSS/image-rendering
            if (this._canvas.style.imageRendering === '') {
                this._canvas.style.imageRendering = 'crisp-edges';
            }
        }
        this._canvas.style.width = this.viewport.width + 'px';
        this._canvas.style.height = this.viewport.height + 'px';
        // After messing with the canvas width/height the graphics context is invalidated and needs to have some properties reset
        this._ctx.updateViewport();
        this._ctx.resetTransform();
        this._ctx.scale(this.pixelRatio, this.pixelRatio);
        this._ctx.smoothing = this._antialiasing;
    }
    get antialiasing() {
        return this._antialiasing;
    }
    set antialiasing(isSmooth) {
        this._antialiasing = isSmooth;
        this._ctx.smoothing = this._antialiasing;
    }
    /**
     * Returns true if excalibur is fullscreened using the browser fullscreen api
     */
    get isFullScreen() {
        return this._isFullScreen;
    }
    /**
     * Requests to go fullscreen using the browser fullscreen api, requires user interaction to be successful.
     * For example, wire this to a user click handler.
     */
    goFullScreen() {
        return this._canvas.requestFullscreen();
    }
    /**
     * Requests to exit fullscreen using the browser fullscreen api
     */
    exitFullScreen() {
        return document.exitFullscreen();
    }
    /**
     * Takes a coordinate in normal html page space, for example from a pointer move event, and translates it to
     * Excalibur screen space.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    pageToScreenCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        if (!this._isFullScreen) {
            newX -= getPosition(this._canvas).x;
            newY -= getPosition(this._canvas).y;
        }
        // if fullscreen api on it centers with black bars
        // we need to adjust the screen to world coordinates in this case
        if (this._isFullScreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = ((newY - screenMarginY) / screenHeight) * this.viewport.height;
                newX = (newX / window.innerWidth) * this.viewport.width;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = ((newX - screenMarginX) / screenWidth) * this.viewport.width;
                newY = (newY / window.innerHeight) * this.viewport.height;
            }
        }
        newX = (newX / this.viewport.width) * this.resolution.width;
        newY = (newY / this.viewport.height) * this.resolution.height;
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to normal html page space. For example,
     * this is where html elements might live if you want to position them relative to Excalibur.
     *
     * Excalibur screen space starts at the top left (0, 0) corner of the viewport, and extends to the
     * bottom right corner (resolutionX, resolutionY)
     * @param point
     */
    screenToPageCoordinates(point) {
        let newX = point.x;
        let newY = point.y;
        newX = (newX / this.resolution.width) * this.viewport.width;
        newY = (newY / this.resolution.height) * this.viewport.height;
        if (this._isFullScreen) {
            if (window.innerWidth / this.aspectRatio < window.innerHeight) {
                const screenHeight = window.innerWidth / this.aspectRatio;
                const screenMarginY = (window.innerHeight - screenHeight) / 2;
                newY = (newY / this.viewport.height) * screenHeight + screenMarginY;
                newX = (newX / this.viewport.width) * window.innerWidth;
            }
            else {
                const screenWidth = window.innerHeight * this.aspectRatio;
                const screenMarginX = (window.innerWidth - screenWidth) / 2;
                newX = (newX / this.viewport.width) * screenWidth + screenMarginX;
                newY = (newY / this.viewport.height) * window.innerHeight;
            }
        }
        if (!this._isFullScreen) {
            newX += getPosition(this._canvas).x;
            newY += getPosition(this._canvas).y;
        }
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur screen space, and translates it to Excalibur world space.
     *
     * World space is where [[Entity|entities]] in Excalibur live by default [[CoordPlane.World]]
     * and extends infinitely out relative from the [[Camera]].
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        var _a, _b, _c, _d;
        let newX = point.x;
        let newY = point.y;
        // transform back to world space
        newX = (newX / this.resolution.width) * this.drawWidth;
        newY = (newY / this.resolution.height) * this.drawHeight;
        // transform based on zoom
        newX = newX - this.halfDrawWidth;
        newY = newY - this.halfDrawHeight;
        // shift by camera focus
        newX += (_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
        newY += (_d = (_c = this._camera) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;
        return new Vector(newX, newY);
    }
    /**
     * Takes a coordinate in Excalibur world space, and translates it to Excalibur screen space.
     *
     * Screen space is where [[ScreenElement|screen elements]] and [[Entity|entities]] with [[CoordPlane.Screen]] live.
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        var _a, _b, _c, _d;
        let screenX = point.x;
        let screenY = point.y;
        // shift by camera focus
        screenX -= (_b = (_a = this._camera) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;
        screenY -= (_d = (_c = this._camera) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;
        // transform back on zoom
        screenX = screenX + this.halfDrawWidth;
        screenY = screenY + this.halfDrawHeight;
        // transform back to screen space
        screenX = (screenX / this.drawWidth) * this.resolution.width;
        screenY = (screenY / this.drawHeight) * this.resolution.height;
        return new Vector(screenX, screenY);
    }
    pageToWorldCoordinates(point) {
        const screen = this.pageToScreenCoordinates(point);
        return this.screenToWorldCoordinates(screen);
    }
    worldToPageCoordinates(point) {
        const screen = this.worldToScreenCoordinates(point);
        return this.screenToPageCoordinates(screen);
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     *
     * World bounds are in world coordinates, useful for culling objects offscreen
     */
    getWorldBounds() {
        const left = this.screenToWorldCoordinates(Vector.Zero).x;
        const top = this.screenToWorldCoordinates(Vector.Zero).y;
        const right = left + this.drawWidth;
        const bottom = top + this.drawHeight;
        return new BoundingBox(left, top, right, bottom);
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.canvas.width;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.canvas.width / 2;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.canvas.height;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.canvas.height / 2;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        if (this._camera) {
            return this.resolution.width / this._camera.zoom;
        }
        return this.resolution.width;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.drawWidth / 2;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        if (this._camera) {
            return this.resolution.height / this._camera.zoom;
        }
        return this.resolution.height;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.drawHeight / 2;
    }
    /**
     * Returns screen center coordinates including zoom and device pixel ratio.
     */
    get center() {
        return vec(this.halfDrawWidth, this.halfDrawHeight);
    }
    _computeFit() {
        document.body.style.margin = '0px';
        document.body.style.overflow = 'hidden';
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        if (window.innerWidth / aspect < window.innerHeight) {
            adjustedWidth = window.innerWidth;
            adjustedHeight = window.innerWidth / aspect;
        }
        else {
            adjustedWidth = window.innerHeight * aspect;
            adjustedHeight = window.innerHeight;
        }
        this.viewport = {
            width: adjustedWidth,
            height: adjustedHeight
        };
    }
    _computeFitContainer() {
        const aspect = this.aspectRatio;
        let adjustedWidth = 0;
        let adjustedHeight = 0;
        const parent = this.canvas.parentElement;
        if (parent.clientWidth / aspect < parent.clientHeight) {
            adjustedWidth = parent.clientWidth;
            adjustedHeight = parent.clientWidth / aspect;
        }
        else {
            adjustedWidth = parent.clientHeight * aspect;
            adjustedHeight = parent.clientHeight;
        }
        this.viewport = {
            width: adjustedWidth,
            height: adjustedHeight
        };
    }
    _applyDisplayMode() {
        if (this.displayMode === DisplayMode.Position) {
            this._initializeDisplayModePosition(this._position);
        }
        else {
            this._setResolutionAndViewportByDisplayMode(this.parent);
            // watch resizing
            if (this.parent instanceof Window) {
                this._browser.window.on('resize', this._resizeHandler);
            }
            else {
                this._resizeObserver = new ResizeObserver(() => {
                    this._resizeHandler();
                });
                this._resizeObserver.observe(this.parent);
            }
            this.parent.addEventListener('resize', this._resizeHandler);
        }
    }
    /**
     * Sets the resoultion and viewport based on the selected display mode.
     */
    _setResolutionAndViewportByDisplayMode(parent) {
        if (this.displayMode === DisplayMode.FillContainer) {
            this.resolution = {
                width: parent.clientWidth,
                height: parent.clientHeight
            };
            this.viewport = this.resolution;
        }
        if (this.displayMode === DisplayMode.FillScreen) {
            document.body.style.margin = '0px';
            document.body.style.overflow = 'hidden';
            this.resolution = {
                width: parent.innerWidth,
                height: parent.innerHeight
            };
            this.viewport = this.resolution;
        }
        if (this.displayMode === DisplayMode.FitScreen) {
            this._computeFit();
        }
        if (this.displayMode === DisplayMode.FitContainer) {
            this._computeFitContainer();
        }
    }
    _initializeDisplayModePosition(position) {
        if (!position) {
            throw new Error('DisplayMode of Position was selected but no position option was given');
        }
        else {
            this.canvas.style.display = 'block';
            this.canvas.style.position = 'absolute';
            if (typeof position === 'string') {
                const specifiedPosition = position.split(' ');
                switch (specifiedPosition[0]) {
                    case 'top':
                        this.canvas.style.top = '0px';
                        break;
                    case 'bottom':
                        this.canvas.style.bottom = '0px';
                        break;
                    case 'middle':
                        this.canvas.style.top = '50%';
                        const offsetY = -this.halfDrawHeight;
                        this.canvas.style.marginTop = offsetY.toString();
                        break;
                    default:
                        throw new Error('Invalid Position Given');
                }
                if (specifiedPosition[1]) {
                    switch (specifiedPosition[1]) {
                        case 'left':
                            this.canvas.style.left = '0px';
                            break;
                        case 'right':
                            this.canvas.style.right = '0px';
                            break;
                        case 'center':
                            this.canvas.style.left = '50%';
                            const offsetX = -this.halfDrawWidth;
                            this.canvas.style.marginLeft = offsetX.toString();
                            break;
                        default:
                            throw new Error('Invalid Position Given');
                    }
                }
            }
            else {
                if (position.top) {
                    typeof position.top === 'number'
                        ? (this.canvas.style.top = position.top.toString() + 'px')
                        : (this.canvas.style.top = position.top);
                }
                if (position.right) {
                    typeof position.right === 'number'
                        ? (this.canvas.style.right = position.right.toString() + 'px')
                        : (this.canvas.style.right = position.right);
                }
                if (position.bottom) {
                    typeof position.bottom === 'number'
                        ? (this.canvas.style.bottom = position.bottom.toString() + 'px')
                        : (this.canvas.style.bottom = position.bottom);
                }
                if (position.left) {
                    typeof position.left === 'number'
                        ? (this.canvas.style.left = position.left.toString() + 'px')
                        : (this.canvas.style.left = position.left);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/AudioContext.ts
/**
 * Internal class used to build instances of AudioContext
 */
/* istanbul ignore next */
class AudioContextFactory {
    static create() {
        if (!this._INSTANCE) {
            if (window.AudioContext || window.webkitAudioContext) {
                this._INSTANCE = new AudioContext();
            }
        }
        return this._INSTANCE;
    }
}
AudioContextFactory._INSTANCE = null;

;// CONCATENATED MODULE: ./Util/WebAudio.ts


/**
 * Patch for detecting legacy web audio in browsers
 * @internal
 * @param source
 */
function isLegacyWebAudioSource(source) {
    return !!source.playbackState;
}
class WebAudio {
    /**
     * Play an empty sound to unlock Safari WebAudio context. Call this function
     * right after a user interaction event.
     * @source https://paulbakaus.com/tutorials/html5/web-audio-on-ios/
     */
    static unlock() {
        const promise = new Promise((resolve, reject) => {
            if (WebAudio._UNLOCKED || !AudioContextFactory.create()) {
                return resolve(true);
            }
            const unlockTimeoutTimer = setTimeout(() => {
                Logger.getInstance().warn('Excalibur was unable to unlock the audio context, audio probably will not play in this browser.');
                resolve(false);
            }, 200);
            const audioContext = AudioContextFactory.create();
            audioContext.resume().then(() => {
                // create empty buffer and play it
                const buffer = audioContext.createBuffer(1, 1, 22050);
                const source = audioContext.createBufferSource();
                let ended = false;
                source.buffer = buffer;
                source.connect(audioContext.destination);
                source.onended = () => (ended = true);
                source.start(0);
                // by checking the play state after some time, we know if we're really unlocked
                setTimeout(() => {
                    if (isLegacyWebAudioSource(source)) {
                        if (source.playbackState === source.PLAYING_STATE || source.playbackState === source.FINISHED_STATE) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                    else {
                        if (audioContext.currentTime > 0 || ended) {
                            WebAudio._UNLOCKED = true;
                        }
                    }
                }, 0);
                clearTimeout(unlockTimeoutTimer);
                resolve(true);
            }, () => {
                reject();
            });
        });
        return promise;
    }
    static isUnlocked() {
        return this._UNLOCKED;
    }
}
WebAudio._UNLOCKED = false;

;// CONCATENATED MODULE: ./Class.ts

/**
 * Excalibur base class that provides basic functionality such as [[EventDispatcher]]
 * and extending abilities for vanilla Javascript projects
 */
class Class {
    constructor() {
        this.eventDispatcher = new EventDispatcher(this);
    }
    /**
     * Alias for `addEventListener`. You can listen for a variety of
     * events off of the engine; see the events section below for a complete list.
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    on(eventName, handler) {
        this.eventDispatcher.on(eventName, handler);
    }
    /**
     * Alias for `removeEventListener`. If only the eventName is specified
     * it will remove all handlers registered for that specific event. If the eventName
     * and the handler instance are specified only that handler will be removed.
     *
     * @param eventName  Name of the event to listen for
     * @param handler    Event handler for the thrown event
     */
    off(eventName, handler) {
        this.eventDispatcher.off(eventName, handler);
    }
    /**
     * Emits a new event
     * @param eventName   Name of the event to emit
     * @param eventObject Data associated with this event
     */
    emit(eventName, eventObject) {
        this.eventDispatcher.emit(eventName, eventObject);
    }
    /**
     * Once listens to an event one time, then unsubscribes from that event
     *
     * @param eventName The name of the event to subscribe to once
     * @param handler   The handler of the event that will be auto unsubscribed
     */
    once(eventName, handler) {
        this.eventDispatcher.once(eventName, handler);
    }
}

;// CONCATENATED MODULE: ./Util/DrawUtil.ts

/* istanbul ignore next */
/**
 * Draw a line on canvas context
 *
 * @param ctx The canvas context
 * @param color The color of the line
 * @param x1 The start x coordinate
 * @param y1 The start y coordinate
 * @param x2 The ending x coordinate
 * @param y2 The ending y coordinate
 * @param thickness The line thickness
 * @param cap The [[LineCapStyle]] (butt, round, or square)
 */
function line(ctx, color = Color.Red, x1, y1, x2, y2, thickness = 1, cap = 'butt') {
    ctx.beginPath();
    ctx.lineWidth = thickness;
    ctx.lineCap = cap;
    ctx.strokeStyle = color.toString();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.closePath();
    ctx.stroke();
}
/* istanbul ignore next */
/**
 * Draw the vector as a point onto the canvas.
 */
function point(ctx, color = Color.Red, point) {
    ctx.beginPath();
    ctx.strokeStyle = color.toString();
    ctx.arc(point.x, point.y, 5, 0, Math.PI * 2);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw the vector as a line onto the canvas starting a origin point.
 */
/* istanbul ignore next */
/**
 *
 */
function vector(ctx, color, origin, vector, scale = 1.0) {
    const c = color ? color.toString() : 'blue';
    const v = vector.scale(scale);
    ctx.beginPath();
    ctx.strokeStyle = c;
    ctx.moveTo(origin.x, origin.y);
    ctx.lineTo(origin.x + v.x, origin.y + v.y);
    ctx.closePath();
    ctx.stroke();
}
/**
 * Draw a round rectangle on a canvas context
 *
 * @param ctx The canvas context
 * @param x The top-left x coordinate
 * @param y The top-left y coordinate
 * @param width The width of the rectangle
 * @param height The height of the rectangle
 * @param radius The border radius of the rectangle
 * @param stroke The [[Color]] to stroke rectangle with
 * @param fill The [[Color]] to fill rectangle with
 */
function roundRect(ctx, x, y, width, height, radius = 5, stroke = Color.White, fill = null) {
    let br;
    if (typeof radius === 'number') {
        br = { tl: radius, tr: radius, br: radius, bl: radius };
    }
    else {
        const defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
        for (const prop in defaultRadius) {
            if (defaultRadius.hasOwnProperty(prop)) {
                const side = prop;
                br[side] = radius[side] || defaultRadius[side];
            }
        }
    }
    ctx.beginPath();
    ctx.moveTo(x + br.tl, y);
    ctx.lineTo(x + width - br.tr, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + br.tr);
    ctx.lineTo(x + width, y + height - br.br);
    ctx.quadraticCurveTo(x + width, y + height, x + width - br.br, y + height);
    ctx.lineTo(x + br.bl, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - br.bl);
    ctx.lineTo(x, y + br.tl);
    ctx.quadraticCurveTo(x, y, x + br.tl, y);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}
/**
 *
 */
function circle(ctx, x, y, radius, stroke = Color.White, fill = null) {
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, Math.PI * 2);
    ctx.closePath();
    if (fill) {
        ctx.fillStyle = fill.toString();
        ctx.fill();
    }
    if (stroke) {
        ctx.strokeStyle = stroke.toString();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Loader.logo.png
/* harmony default export */ const Loader_logo = ("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdQAAAB2CAYAAABxhGI9AAAACXBIWXMAAAsSAAALEgHS3X78AAAKnUlEQVR42u3dP2wjSx0H8N8hJIonIRmJjsq0SBR+BQ1dcqKhe0lD77SvSwpKkJKGPulpktfRIMUdEqKIqV57rpAokM4dbSiyq7ONPTP7x39ifz7SFbnEnp3xer47O7uzH15fXwMA6OYHmgAABCoACFQAEKgAgEAFAIEKAAIVAAQqACBQAUCgAoBABQCBCgAIVAAQqAAgUAFAoAIAAhUABCoACFQAEKgAgECFLbmOiNeFf2PbAyz68Pr6qhUgbRwR92v+/zwiJrYHMEKFMmcN///UtgcQqFBk1PD/97U9Qx8VCFSgu4EmAIEKAAIVAAQqACBQ4Z25jojP8eX+0WtNAgIVaOY+Im5j+eKh24h41jQgUIEyZ7F5NaPU7wCBCiwYd/w9cOB+qAlgJ3KLLow0EV198803RWvJfvfddx+0lhEqHKu5JgAjVCBvlhmFzjQRXUekHz9+TP79y8uLRjNChXfvoePvAYEKxNtj1e42/O5JoIJABcrdRMRVLM+X3kTEpaaB988cKuzWg9EobTWdMx0Oly8uN4dqhAoARqgnaN3arHfqu7OyH8ItKLVB/P+CEfMTHyGPY3npx1m8zWGDEeoBfUk/xdti57dr/r1Wv2+6EPow3tZ5rRdS72s1neuF97xvWd+XTH0/V+UMttDWqbI/r2nrxfp+jv2uSjSO7S+OXy/A/3lN+9xX5T5HxEUPZZ0tfB71+w57eJ/HFu+z+jkv1u92YX9fbI/HhX3JA9rp5MPr66tWaG9UfUGbrHIzi7cLUyYFf/tpTady03EEeL8mUJ6i7MKYNvWNqr4Pe2jradXO60LrvPAz2PQ5RPX684ah8dxD+2zantnCgVipSVV+m/tgB9W2DDq2Sx/vM95wcHhZhWVJm8yrv58cSgfTdc70+++/X/r522+/tUKSEepBqo+om4ZLPerMjUwuNnQCtx1GWJtee1FwdD5uWd86xLs8UaVt2aNEO1/saZ/Z5rYMW4zq6v34rGV9Bg3q2eZ9SkeNm9qwyUh30OPIHYFKx5FG03C7znSOqYBq+qW/zpQ3anH037TNHluG6f0WPsPhHvab4QFty7ogOeuxDYcNy2/zu2214WNYWxmBurNO8bGn97pNBOO8xy/9uCorZZ4I2r4C7aJgO7ZV9iE49Dm6NvOWx+pWE9CUq3zbdTp9doz38TbXtzqH9RT5CyWe422OaZoZGeZCabrhPQY9HjwsjpTvCg4YtlE2+Ta/j2bzn8fqrDqgm+6yUHOmAvWUjAtGhbNYvsBknDnqH1Qhc7VmxHgeb/NbudA5j/UXlYwif2p6luhAc9teu1npiHKnDs8if6tCm7JLX3NKpgttXe9ruc9mHMd7a83iwdxF5vt8tutARaCeklRnNK9C8WnNF7geJQ4T4XG3JhSnVdilQrG+yOnrlVHfsEGYzhNBn7Lu6tS7+HJafJQ4EMiNlNqWXZ9WPvVgnVYHG5M1ByDXkT6leX2EgTqJtyt45yv7S2qO3sEZjZhDLXeR+YKdJ0Zdk8QocvH9N732KrNtq+FZ/zzIHABcJrYpd+Xv14lOd5ap76SgrduW/VTQ1qcQpqnbgu4ifZvUMNpd9XuoZmvCtPaQ2Y/BCHVLgbrJTeRPDdVf6pfMKDU2fOkHmVFFfXr3MsouLsnNvV5kRoe5+s431PeuoKPqWnaurY/ZPBEeqwceN4l96iwO6H7Mjq4y7VGPVNe10VaZMzVCPVWpI/Z6FZbcv5fMqGCU+dLfFGzj58jP8+bCdJCo7yzKTwdOF0bu9Ug7V4c+yz7FJfYeGoysUss0HssIdVZwYLDujMqlESoCdTtGsZtbHnJBeNdDSJSs0jTKdMJN1HNX54Wv7bvsU9NkVJVa13dX+/wuArV0X/l5RHyo/lnfF4G6p6DrS0kHdtXhy35TGErDPYZUn2WfWqDOo/lVqdMD2O/hKJhD7S/odukymq9s02QN4EEPR/zbaOumZc+r15zK1Zqznl9jsfiemTM1QmV3HUuTkedlg9HIQzRbUD93dfC+2tpj2fIHEH2+RqCCQH13gZq7hWXTNpVu19OB1fc9nQ0AKOKUb5lU0P1kDyOneoWk0lOZ9cIP0x7qu8+2BhCoR2wYu1+e7DmaXzBSsu5vaX1ne2zrpmUPTmxf7PM1Dm4y/vC7ny7Nif7+z/9ZmtM0Z3panPLtPmra9f16bcK0Dpbnwk43Vd/RHtu6zfNQTy1QBy3aqG2g9nVmxml+BOoJyT3NpWmn9xhfFnu4bvDa+44BXhqqfdf3uUF9+yz77AT31Yue2mjecYQ62NLfgkA9ghHqLNEhNem4H1c6vdyDxhf/bpz5m4coW/c39wi6VH2bPtHlcaV9cvXts+zxCe6rTeqc2ndL7uGd93QwM9bFcAzMoZZ7SgTBbWx+asui61h/iq1+RmjqdbnQXQ3T1DNQ63V/U9ucqm/pMzPb1rePsk/1iTOjgvatR4W3Lc8ULB78pELyrnAfeTcj1NU509/86mfJ33/8+Mf00a05UyPUEw7UVCeWG/WNEiExyHRMt5ltW30izUPk18ytt7lNfc8i//DvtvXto+ySA5BjljsLUF8lPkqMPEtW1JomDsiGBZ9Byb4NAvUITSN9GuwsIj6t6UTOqk7jJREkmzqli8xIs96udSO20sX0H1vW92IL9e1a9rgqVyf91gbPsTy9UD9n9lOkT8k+RfkFR5PMNqxOcdSf32PBvg3vilO+zdxE+okx9Wm0ph36XYsRZCpMF993GOk5qvqB3Dct6jvssb67KvuUNJ3frw92bhr8/STSF0JdRPMLpUCgnsgo9S76PZ246ZFk1wWvK5m3vVoYvW1Sz7nN91jfXbQ1ZQc7TW6HeaoOalypG/8/p/rP1aNAc6ZHzSnfdqPUPhdy2PQw6Nz9gSVhuhiqueUHR3uu7y7K3rdDX4u46ZrPbUa0IFBZ0seKQ3XQTRt2vm3W/a2DbNKys++rvm3ep6+y1x2UdP3bWU9lzra47U1GmlctX/sQ23t+aOlByLTh/4NAPaCRxtcdO5HLSJ/6vNtCwGx67VPmPbvWd1q9frKHtp4kAqRJ2HR9j762JfX3bZ//elPtj13PPDx1+D5tqk/Xi6NO8SHz7MmH19dXrdBNfVFP6T2PT1UHNit87/t4m5+aRH+nQBdvqyhZDKJLfZs8h7XPsqdV2ZOV+tanKB8aln0dyxdAXbV4j4gvt4oMOrbP6vbU73NW7TMlbdTnPrWpfqXfh9HKZ9vke7KuTeZRNtXRSe6+1FV//ce/ln5eXfsXgcqXzr6+9261M3moOoa7E6nvTZTfy7iNsmfb7kjfgXGsvxe0vihsEts9HTquPpt1q1vtahu2TqAiUAEEKj0zhwoARqgAu/OnX/442WH+9xc/Wvr58re/Tr7f41/+ZsRqhAoACFQAEKgAcHjMoQJskJsz/eqrr5Z+vvr7v5fmQFevAl5lztQIFQAQqAAgUAHgIJlDBdhgdQ41N2eKESoAIFABQKACwFEwhwoARqgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAEKgAgUAFAoAKAQAUAgQoACFQAEKgAIFABQKACAAIVAAQqAAhUABCoAIBABQCBCgACFQAQqAAgUAFAoAKAQAUAlvwPcFDns1DsH4sAAAAASUVORK5CYII=");
// EXTERNAL MODULE: ./Loader.css
var Loader_0 = __nested_webpack_require_51441__(1388);
;// CONCATENATED MODULE: ./Loader.ts
var Loader_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








/**
 * Pre-loading assets
 *
 * The loader provides a mechanism to preload multiple resources at
 * one time. The loader must be passed to the engine in order to
 * trigger the loading progress bar.
 *
 * The [[Loader]] itself implements [[Loadable]] so you can load loaders.
 *
 * ## Example: Pre-loading resources for a game
 *
 * ```js
 * // create a loader
 * var loader = new ex.Loader();
 *
 * // create a resource dictionary (best practice is to keep a separate file)
 * var resources = {
 *   TextureGround: new ex.Texture("/images/textures/ground.png"),
 *   SoundDeath: new ex.Sound("/sound/death.wav", "/sound/death.mp3")
 * };
 *
 * // loop through dictionary and add to loader
 * for (var loadable in resources) {
 *   if (resources.hasOwnProperty(loadable)) {
 *     loader.addResource(resources[loadable]);
 *   }
 * }
 *
 * // start game
 * game.start(loader).then(function () {
 *   console.log("Game started!");
 * });
 * ```
 *
 * ## Customize the Loader
 *
 * The loader can be customized to show different, text, logo, background color, and button.
 *
 * ```typescript
 * const loader = new ex.Loader([playerTexture]);
 *
 * // The loaders button text can simply modified using this
 * loader.playButtonText = 'Start the best game ever';
 *
 * // The logo can be changed by inserting a base64 image string here
 *
 * loader.logo = 'data:image/png;base64,iVBORw...';
 * loader.logoWidth = 15;
 * loader.logoHeight = 14;
 *
 * // The background color can be changed like so by supplying a valid CSS color string
 *
 * loader.backgroundColor = 'red'
 * loader.backgroundColor = '#176BAA'
 *
 * // To build a completely new button
 * loader.startButtonFactory = () => {
 *     let myButton = document.createElement('button');
 *     myButton.textContent = 'The best button';
 *     return myButton;
 * };
 *
 * engine.start(loader).then(() => {});
 * ```
 */
class Loader extends Class {
    /**
     * @param loadables  Optionally provide the list of resources you want to load at constructor time
     */
    constructor(loadables) {
        super();
        this.canvas = new Canvas({
            smoothing: true,
            draw: this.draw.bind(this)
        });
        this._resourceList = [];
        this._index = 0;
        this._playButtonShown = false;
        this._resourceCount = 0;
        this._numLoaded = 0;
        this._progressCounts = {};
        this._totalCounts = {};
        // logo drawing stuff
        // base64 string encoding of the excalibur logo (logo-white.png)
        this.logo = Loader_logo;
        this.logoWidth = 468;
        this.logoHeight = 118;
        /**
         * Gets or sets the color of the loading bar, default is [[Color.White]]
         */
        this.loadingBarColor = Color.White;
        /**
         * Gets or sets the background color of the loader as a hex string
         */
        this.backgroundColor = '#176BAA';
        this.suppressPlayButton = false;
        /** Loads the css from Loader.css */
        this._playButtonStyles = Loader_0/* default.toString */.Z.toString();
        /**
         * Get/set play button text
         */
        this.playButtonText = 'Play game';
        /**
         * Return a html button element for excalibur to use as a play button
         */
        this.startButtonFactory = () => {
            let buttonElement = document.getElementById('excalibur-play');
            if (!buttonElement) {
                buttonElement = document.createElement('button');
            }
            buttonElement.id = 'excalibur-play';
            buttonElement.textContent = this.playButtonText;
            buttonElement.style.display = 'none';
            return buttonElement;
        };
        if (loadables) {
            this.addResources(loadables);
        }
    }
    get _image() {
        if (!this._imageElement) {
            this._imageElement = new Image();
            this._imageElement.src = this.logo;
        }
        return this._imageElement;
    }
    get playButtonRootElement() {
        return this._playButtonRootElement;
    }
    get playButtonElement() {
        return this._playButtonElement;
    }
    get _playButton() {
        const existingRoot = document.getElementById('excalibur-play-root');
        if (existingRoot) {
            this._playButtonRootElement = existingRoot;
        }
        if (!this._playButtonRootElement) {
            this._playButtonRootElement = document.createElement('div');
            this._playButtonRootElement.id = 'excalibur-play-root';
            this._playButtonRootElement.style.position = 'absolute';
            document.body.appendChild(this._playButtonRootElement);
        }
        if (!this._styleBlock) {
            this._styleBlock = document.createElement('style');
            this._styleBlock.textContent = this._playButtonStyles;
            document.head.appendChild(this._styleBlock);
        }
        if (!this._playButtonElement) {
            this._playButtonElement = this.startButtonFactory();
            this._playButtonRootElement.appendChild(this._playButtonElement);
        }
        return this._playButtonElement;
    }
    wireEngine(engine) {
        this._engine = engine;
        this.canvas.width = this._engine.canvas.width;
        this.canvas.height = this._engine.canvas.height;
    }
    /**
     * Add a resource to the loader to load
     * @param loadable  Resource to add
     */
    addResource(loadable) {
        const key = this._index++;
        this._resourceList.push(loadable);
        this._progressCounts[key] = 0;
        this._totalCounts[key] = 1;
        this._resourceCount++;
    }
    /**
     * Add a list of resources to the loader to load
     * @param loadables  The list of resources to load
     */
    addResources(loadables) {
        let i = 0;
        const len = loadables.length;
        for (i; i < len; i++) {
            this.addResource(loadables[i]);
        }
    }
    /**
     * Returns true if the loader has completely loaded all resources
     */
    isLoaded() {
        return this._numLoaded === this._resourceCount;
    }
    /**
     * Shows the play button and returns a promise that resolves when clicked
     */
    showPlayButton() {
        var _a;
        if (this.suppressPlayButton) {
            this.hidePlayButton();
            return Promise.resolve();
        }
        else {
            const resizeHandler = () => {
                this._positionPlayButton();
            };
            if ((_a = this._engine) === null || _a === void 0 ? void 0 : _a.browser) {
                this._engine.browser.window.on('resize', resizeHandler);
            }
            this._playButtonShown = true;
            this._playButton.style.display = 'block';
            document.body.addEventListener('keyup', (evt) => {
                if (evt.key === 'Enter') {
                    this._playButton.click();
                }
            });
            const promise = new Promise((resolve) => {
                const startButtonHandler = (e) => {
                    var _a;
                    // We want to stop propogation to keep bubbling to the engine pointer handlers
                    e.stopPropagation();
                    // Hide Button after click
                    this.hidePlayButton();
                    if ((_a = this._engine) === null || _a === void 0 ? void 0 : _a.browser) {
                        this._engine.browser.window.off('resize', resizeHandler);
                    }
                    resolve();
                };
                this._playButton.addEventListener('click', startButtonHandler);
                this._playButton.addEventListener('touchend', startButtonHandler);
                this._playButton.addEventListener('pointerup', startButtonHandler);
            });
            return promise;
        }
    }
    hidePlayButton() {
        this._playButtonShown = false;
        this._playButton.style.display = 'none';
    }
    /**
     * Clean up generated elements for the loader
     */
    dispose() {
        if (this._playButtonRootElement.parentElement) {
            this._playButtonRootElement.removeChild(this._playButtonElement);
            document.body.removeChild(this._playButtonRootElement);
            document.head.removeChild(this._styleBlock);
            this._playButtonRootElement = null;
            this._playButtonElement = null;
            this._styleBlock = null;
        }
    }
    update(_engine, _delta) {
        // override me
    }
    /**
     * Begin loading all of the supplied resources, returning a promise
     * that resolves when loading of all is complete
     */
    load() {
        return Loader_awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this._resourceList.map((r) => r.load().finally(() => {
                // capture progress
                this._numLoaded++;
            })));
            // short delay in showing the button for aesthetics
            yield delay(200);
            yield this.showPlayButton();
            // Unlock browser AudioContext in after user gesture
            // See: https://github.com/excaliburjs/Excalibur/issues/262
            // See: https://github.com/excaliburjs/Excalibur/issues/1031
            yield WebAudio.unlock();
            return (this.data = this._resourceList);
        });
    }
    markResourceComplete() {
        this._numLoaded++;
    }
    /**
     * Returns the progess of the loader as a number between [0, 1] inclusive.
     */
    get progress() {
        return this._resourceCount > 0 ? clamp(this._numLoaded, 0, this._resourceCount) / this._resourceCount : 1;
    }
    _positionPlayButton() {
        const screenHeight = this._engine.screen.viewport.height;
        const screenWidth = this._engine.screen.viewport.width;
        if (this._playButtonRootElement) {
            const left = this._engine.canvas.offsetLeft;
            const top = this._engine.canvas.offsetTop;
            const buttonWidth = this._playButton.clientWidth;
            const buttonHeight = this._playButton.clientHeight;
            if (this.playButtonPosition) {
                this._playButtonRootElement.style.left = `${this.playButtonPosition.x}px`;
                this._playButtonRootElement.style.top = `${this.playButtonPosition.y}px`;
            }
            else {
                this._playButtonRootElement.style.left = `${left + screenWidth / 2 - buttonWidth / 2}px`;
                this._playButtonRootElement.style.top = `${top + screenHeight / 2 - buttonHeight / 2 + 100}px`;
            }
        }
    }
    /**
     * Loader draw function. Draws the default Excalibur loading screen.
     * Override `logo`, `logoWidth`, `logoHeight` and `backgroundColor` properties
     * to customize the drawing, or just override entire method.
     */
    draw(ctx) {
        const canvasHeight = this._engine.canvasHeight / this._engine.pixelRatio;
        const canvasWidth = this._engine.canvasWidth / this._engine.pixelRatio;
        this._positionPlayButton();
        ctx.fillStyle = this.backgroundColor;
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        let logoY = canvasHeight / 2;
        const width = Math.min(this.logoWidth, canvasWidth * 0.75);
        let logoX = canvasWidth / 2 - width / 2;
        if (this.logoPosition) {
            logoX = this.logoPosition.x;
            logoY = this.logoPosition.y;
        }
        const imageHeight = Math.floor(width * (this.logoHeight / this.logoWidth)); // OG height/width factor
        const oldAntialias = this._engine.getAntialiasing();
        this._engine.setAntialiasing(true);
        if (!this.logoPosition) {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY - imageHeight - 20, width, imageHeight);
        }
        else {
            ctx.drawImage(this._image, 0, 0, this.logoWidth, this.logoHeight, logoX, logoY, width, imageHeight);
        }
        // loading box
        if (!this.suppressPlayButton && this._playButtonShown) {
            this._engine.setAntialiasing(oldAntialias);
            return;
        }
        let loadingX = logoX;
        let loadingY = logoY;
        if (this.loadingBarPosition) {
            loadingX = this.loadingBarPosition.x;
            loadingY = this.loadingBarPosition.y;
        }
        ctx.lineWidth = 2;
        roundRect(ctx, loadingX, loadingY, width, 20, 10, this.loadingBarColor);
        const progress = width * this.progress;
        const margin = 5;
        const progressWidth = progress - margin * 2;
        const height = 20 - margin * 2;
        roundRect(ctx, loadingX + margin, loadingY + margin, progressWidth > 10 ? progressWidth : 10, height, 5, null, this.loadingBarColor);
        this._engine.setAntialiasing(oldAntialias);
    }
}

;// CONCATENATED MODULE: ./Util/Detector.ts

/**
 * This is the list of features that will be used to log the supported
 * features to the console when Detector.logBrowserFeatures() is called.
 */
const REPORTED_FEATURES = {
    webgl: 'WebGL',
    webaudio: 'WebAudio',
    gamepadapi: 'Gamepad API'
};
/**
 * Excalibur internal feature detection helper class
 */
class Detector {
    constructor() {
        this._features = null;
        this.failedTests = [];
        // critical browser features required for ex to run
        this._criticalTests = {
            // Test canvas/2d context support
            canvasSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('2d'));
            },
            // Test array buffer support ex uses for downloading binary data
            arrayBufferSupport: function () {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', '/');
                try {
                    xhr.responseType = 'arraybuffer';
                }
                catch (e) {
                    return false;
                }
                return xhr.responseType === 'arraybuffer';
            },
            // Test data urls ex uses for sprites
            dataUrlSupport: function () {
                const canvas = document.createElement('canvas');
                return canvas.toDataURL('image/png').indexOf('data:image/png') === 0;
            },
            // Test object url support for loading
            objectUrlSupport: function () {
                return 'URL' in window && 'revokeObjectURL' in URL && 'createObjectURL' in URL;
            },
            // RGBA support for colors
            rgbaSupport: function () {
                const style = document.createElement('a').style;
                style.cssText = 'background-color:rgba(150,255,150,.5)';
                return ('' + style.backgroundColor).indexOf('rgba') > -1;
            }
        };
        // warnings excalibur performance will be degraded
        this._warningTest = {
            webAudioSupport: function () {
                return !!(window.AudioContext ||
                    window.webkitAudioContext ||
                    window.mozAudioContext ||
                    window.msAudioContext ||
                    window.oAudioContext);
            },
            webglSupport: function () {
                const elem = document.createElement('canvas');
                return !!(elem.getContext && elem.getContext('webgl'));
            }
        };
        this._features = this._loadBrowserFeatures();
    }
    /**
     * Returns a map of currently supported browser features. This method
     * treats the features as a singleton and will only calculate feature
     * support if it has not previously been done.
     */
    getBrowserFeatures() {
        if (this._features === null) {
            this._features = this._loadBrowserFeatures();
        }
        return this._features;
    }
    /**
     * Report on non-critical browser support for debugging purposes.
     * Use native browser console colors for visibility.
     */
    logBrowserFeatures() {
        let msg = '%cSUPPORTED BROWSER FEATURES\n==========================%c\n';
        const args = ['font-weight: bold; color: navy', 'font-weight: normal; color: inherit'];
        const supported = this.getBrowserFeatures();
        for (const feature of Object.keys(REPORTED_FEATURES)) {
            if (supported[feature]) {
                msg += '(%c\u2713%c)'; // ()
                args.push('font-weight: bold; color: green');
                args.push('font-weight: normal; color: inherit');
            }
            else {
                msg += '(%c\u2717%c)'; // ()
                args.push('font-weight: bold; color: red');
                args.push('font-weight: normal; color: inherit');
            }
            msg += ' ' + REPORTED_FEATURES[feature] + '\n';
        }
        args.unshift(msg);
        // eslint-disable-next-line no-console
        console.log.apply(console, args);
    }
    /**
     * Executes several IIFE's to get a constant reference to supported
     * features within the current execution context.
     */
    _loadBrowserFeatures() {
        return {
            // IIFE to check canvas support
            canvas: (() => {
                return this._criticalTests.canvasSupport();
            })(),
            // IIFE to check arraybuffer support
            arraybuffer: (() => {
                return this._criticalTests.arrayBufferSupport();
            })(),
            // IIFE to check dataurl support
            dataurl: (() => {
                return this._criticalTests.dataUrlSupport();
            })(),
            // IIFE to check objecturl support
            objecturl: (() => {
                return this._criticalTests.objectUrlSupport();
            })(),
            // IIFE to check rgba support
            rgba: (() => {
                return this._criticalTests.rgbaSupport();
            })(),
            // IIFE to check webaudio support
            webaudio: (() => {
                return this._warningTest.webAudioSupport();
            })(),
            // IIFE to check webgl support
            webgl: (() => {
                return this._warningTest.webglSupport();
            })(),
            // IIFE to check gamepadapi support
            gamepadapi: (() => {
                return !!navigator.getGamepads;
            })()
        };
    }
    test() {
        // Critical test will for ex not to run
        let failedCritical = false;
        for (const test in this._criticalTests) {
            if (!this._criticalTests[test].call(this)) {
                this.failedTests.push(test);
                Logger.getInstance().error('Critical browser feature missing, Excalibur requires:', test);
                failedCritical = true;
            }
        }
        if (failedCritical) {
            return false;
        }
        // Warning tests do not for ex to return false to compatibility
        for (const warning in this._warningTest) {
            if (!this._warningTest[warning]()) {
                Logger.getInstance().warn('Warning browser feature missing, Excalibur will have reduced performance:', warning);
            }
        }
        return true;
    }
}

;// CONCATENATED MODULE: ./Collision/CollisionType.ts
/**
 * An enum that describes the types of collisions bodies can participate in
 */
var CollisionType;
(function (CollisionType) {
    /**
     * Bodies with the `PreventCollision` setting do not participate in any
     * collisions and do not raise collision events.
     */
    CollisionType["PreventCollision"] = "PreventCollision";
    /**
     * Bodies with the `Passive` setting only raise collision events, but are not
     * influenced or moved by other bodies and do not influence or move other bodies.
     * This is useful for use in trigger type behavior.
     */
    CollisionType["Passive"] = "Passive";
    /**
     * Bodies with the `Active` setting raise collision events and participate
     * in collisions with other bodies and will be push or moved by bodies sharing
     * the `Active` or `Fixed` setting.
     */
    CollisionType["Active"] = "Active";
    /**
     * Bodies with the `Fixed` setting raise collision events and participate in
     * collisions with other bodies. Actors with the `Fixed` setting will not be
     * pushed or moved by other bodies sharing the `Fixed`. Think of Fixed
     * bodies as "immovable/unstoppable" objects. If two `Fixed` bodies meet they will
     * not be pushed or moved by each other, they will not interact except to throw
     * collision events.
     */
    CollisionType["Fixed"] = "Fixed";
})(CollisionType || (CollisionType = {}));

;// CONCATENATED MODULE: ./Collision/Physics.ts
var Physics_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Possible collision resolution strategies
 *
 * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics. This is useful for things
 * like platformers or top down games.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated
 * simulated physical interactions.
 */
var CollisionResolutionStrategy;
(function (CollisionResolutionStrategy) {
    CollisionResolutionStrategy["Arcade"] = "arcade";
    CollisionResolutionStrategy["Realistic"] = "realistic";
})(CollisionResolutionStrategy || (CollisionResolutionStrategy = {}));
/**
 * Possible broadphase collision pair identification strategies
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster.
 */
var BroadphaseStrategy;
(function (BroadphaseStrategy) {
    BroadphaseStrategy[BroadphaseStrategy["DynamicAABBTree"] = 0] = "DynamicAABBTree";
})(BroadphaseStrategy || (BroadphaseStrategy = {}));
/**
 * Possible numerical integrators for position and velocity
 */
var Integrator;
(function (Integrator) {
    Integrator[Integrator["Euler"] = 0] = "Euler";
})(Integrator || (Integrator = {}));
/**
 * The [[Physics]] object is the global configuration object for all Excalibur physics.
 */
/* istanbul ignore next */
class Physics {
    static get gravity() {
        return Physics.acc;
    }
    static set gravity(v) {
        Physics.acc = v;
    }
    /**
     * Configures Excalibur to use "arcade" physics. Arcade physics which performs simple axis aligned arcade style physics.
     */
    static useArcadePhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
    }
    /**
     * Configures Excalibur to use rigid body physics. Rigid body physics allows for complicated
     * simulated physical interactions.
     */
    static useRealisticPhysics() {
        Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Realistic;
    }
    static get dynamicTreeVelocityMultiplyer() {
        return Physics.dynamicTreeVelocityMultiplier;
    }
    static set dynamicTreeVelocityMultiplyer(value) {
        Physics.dynamicTreeVelocityMultiplier = value;
    }
}
/**
 * Global acceleration that is applied to all vanilla actors that have a [[CollisionType.Active|active]] collision type.
 * Global acceleration won't effect [[Label|labels]], [[ScreenElement|ui actors]], or [[Trigger|triggers]] in Excalibur.
 *
 * This is a great way to globally simulate effects like gravity.
 */
Physics.acc = new Vector(0, 0);
/**
 * Globally switches all Excalibur physics behavior on or off.
 */
Physics.enabled = true;
/**
 * Gets or sets the broadphase pair identification strategy.
 *
 * The default strategy is [[BroadphaseStrategy.DynamicAABBTree]] which uses a binary tree of axis-aligned bounding boxes to identify
 * potential collision pairs which is O(nlog(n)) faster.
 */
Physics.broadphaseStrategy = BroadphaseStrategy.DynamicAABBTree;
/**
 * Gets or sets the global collision resolution strategy (narrowphase).
 *
 * The default is [[CollisionResolutionStrategy.Arcade]] which performs simple axis aligned arcade style physics.
 *
 * More advanced rigid body physics are enabled by setting [[CollisionResolutionStrategy.Realistic]] which allows for complicated
 * simulated physical interactions.
 */
Physics.collisionResolutionStrategy = CollisionResolutionStrategy.Arcade;
/**
 * The default mass to use if none is specified
 */
Physics.defaultMass = 10;
/**
 * Gets or sets the position and velocity positional integrator, currently only Euler is supported.
 */
Physics.integrator = Integrator.Euler;
/**
 * Factor to add to the RigidBody BoundingBox, bounding box (dimensions += vel * dynamicTreeVelocityMultiplier);
 */
Physics.dynamicTreeVelocityMultiplier = 2;
/**
 * Pad RigidBody BoundingBox by a constant amount
 */
Physics.boundsPadding = 5;
/**
 * Number of position iterations (overlap) to run in the solver
 */
Physics.positionIterations = 3;
/**
 * Number of velocity iteration (response) to run in the solver
 */
Physics.velocityIterations = 8;
/**
 * Amount of overlap to tolerate in pixels
 */
Physics.slop = 1;
/**
 * Amount of positional overlap correction to apply each position iteration of the solver
 * O - meaning no correction, 1 - meaning correct all overlap
 */
Physics.steeringFactor = 0.2;
/**
 * Warm start set to true re-uses impulses from previous frames back in the solver
 */
Physics.warmStart = true;
/**
 * By default bodies do not sleep
 */
Physics.bodiesCanSleepByDefault = false;
/**
 * Surface epsilon is used to help deal with surface penetration
 */
Physics.surfaceEpsilon = 0.1;
Physics.sleepEpsilon = 0.07;
Physics.wakeThreshold = Physics.sleepEpsilon * 3;
Physics.sleepBias = 0.9;
/**
 * Enable fast moving body checking, this enables checking for collision pairs via raycast for fast moving objects to prevent
 * bodies from tunneling through one another.
 */
Physics.checkForFastBodies = true;
/**
 * Disable minimum fast moving body raycast, by default if ex.Physics.checkForFastBodies = true Excalibur will only check if the
 * body is moving at least half of its minimum dimension in an update. If ex.Physics.disableMinimumSpeedForFastBody is set to true,
 * Excalibur will always perform the fast body raycast regardless of speed.
 */
Physics.disableMinimumSpeedForFastBody = false;
Physics_decorate([
    obsolete({
        message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',
        alternateMethod: 'dynamicTreeVelocityMultiplier'
    })
], Physics, "dynamicTreeVelocityMultiplyer", null);

;// CONCATENATED MODULE: ./Math/vector-view.ts

class VectorView extends Vector {
    constructor(options) {
        super(0, 0);
        this._getX = options.getX;
        this._getY = options.getY;
        this._setX = options.setX;
        this._setY = options.setY;
    }
    get x() {
        return (this._x = this._getX());
    }
    set x(val) {
        this._setX(val);
        this._x = val;
    }
    get y() {
        return (this._y = this._getY());
    }
    set y(val) {
        this._setY(val);
        this._y = val;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Component.ts
/**
 * Type guard to check if a component implements clone
 * @param x
 */
function hasClone(x) {
    return !!(x === null || x === void 0 ? void 0 : x.clone);
}
/**
 * Components are containers for state in Excalibur, the are meant to convey capabilities that an Entity posesses
 *
 * Implementations of Component must have a zero-arg constructor to support dependecies
 *
 * ```typescript
 * class MyComponent extends ex.Component<'my'> {
 *   public readonly type = 'my';
 *   // zero arg support required if you want to use component dependencies
 *   constructor(public optionalPos?: ex.Vector) {}
 * }
 * ```
 */
class Component {
    constructor() {
        /**
         * Current owning [[Entity]], if any, of this component. Null if not added to any [[Entity]]
         */
        this.owner = null;
    }
    /**
     * Clones any properties on this component, if that property value has a `clone()` method it will be called
     */
    clone() {
        const newComponent = new this.constructor();
        for (const prop in this) {
            if (this.hasOwnProperty(prop)) {
                const val = this[prop];
                if (hasClone(val) && prop !== 'owner' && prop !== 'clone') {
                    newComponent[prop] = val.clone();
                }
                else {
                    newComponent[prop] = val;
                }
            }
        }
        return newComponent;
    }
}
/**
 * Tag components are a way of tagging a component with label and a simple value
 *
 * For example:
 *
 * ```typescript
 * const isOffscreen = new TagComponent('offscreen');
 * entity.addComponent(isOffscreen);
 * entity.tags.includes
 * ```
 */
class TagComponent extends Component {
    constructor(type, value) {
        super();
        this.type = type;
        this.value = value;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Components/TransformComponent.ts




const createPosView = (matrix) => {
    const source = matrix;
    return new VectorView({
        setX: (x) => {
            source.data[MatrixLocations.X] = x;
        },
        setY: (y) => {
            source.data[MatrixLocations.Y] = y;
        },
        getX: () => {
            return source.data[MatrixLocations.X];
        },
        getY: () => {
            return source.data[MatrixLocations.Y];
        }
    });
};
const createScaleView = (matrix) => {
    const source = matrix;
    return new VectorView({
        setX: (x) => {
            source.setScaleX(x);
        },
        setY: (y) => {
            source.setScaleY(y);
        },
        getX: () => {
            return source.getScaleX();
        },
        getY: () => {
            return source.getScaleY();
        }
    });
};
/**
 * Enum representing the coordinate plane for the position 2D vector in the [[TransformComponent]]
 */
var CoordPlane;
(function (CoordPlane) {
    /**
     * The world coordinate plane (default) represents world space, any entities drawn with world
     * space move when the camera moves.
     */
    CoordPlane["World"] = "world";
    /**
     * The screen coordinate plane represents screen space, entities drawn in screen space are pinned
     * to screen coordinates ignoring the camera.
     */
    CoordPlane["Screen"] = "screen";
})(CoordPlane || (CoordPlane = {}));
class TransformComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.transform';
        this._dirty = false;
        this.matrix = Matrix.identity().translate(0, 0).rotate(0).scale(1, 1);
        this._position = createPosView(this.matrix);
        this._rotation = 0;
        this._scale = createScaleView(this.matrix);
        /**
         * The [[CoordPlane|coordinate plane|]] for this transform for the entity.
         */
        this.coordPlane = CoordPlane.World;
        /**
         * The z-index ordering of the entity, a higher values are drawn on top of lower values.
         * For example z=99 would be drawn on top of z=0.
         */
        this.z = 0;
    }
    _recalculate() {
        this._rotation = this.matrix.getRotation();
        this._dirty = false;
    }
    getGlobalMatrix() {
        if (!this.parent) {
            return this.matrix;
        }
        else {
            return this.parent.getGlobalMatrix().multm(this.matrix);
        }
    }
    getGlobalTransform() {
        return {
            pos: this.globalPos,
            scale: this.globalScale,
            rotation: this.globalRotation,
            z: this.z,
            coordPlane: this.coordPlane
        };
    }
    get parent() {
        var _a, _b;
        return (_b = (_a = this === null || this === void 0 ? void 0 : this.owner) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.get(TransformComponent);
    }
    /**
     * The current position of the entity in world space or in screen space depending on the the [[CoordPlane|coordinate plane]].
     *
     * If a parent entity exists coordinates are local to the parent.
     */
    get pos() {
        if (this._dirty) {
            this._recalculate();
        }
        return this._position;
    }
    set pos(val) {
        this.matrix.setPosition(val.x, val.y);
        this._dirty = true;
    }
    // Dirty flag check up the chain
    get dirty() {
        var _a;
        if ((_a = this === null || this === void 0 ? void 0 : this.owner) === null || _a === void 0 ? void 0 : _a.parent) {
            const parent = this.parent;
            return parent.dirty || this._dirty;
        }
        return this._dirty;
    }
    /**
     * The current world position calculated
     */
    get globalPos() {
        const source = this.getGlobalMatrix();
        return new VectorView({
            getX: () => source.data[MatrixLocations.X],
            getY: () => source.data[MatrixLocations.Y],
            setX: (x) => {
                var _a;
                if (this.parent) {
                    const [newX] = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getGlobalMatrix().getAffineInverse().multv([x, source.data[MatrixLocations.Y]]);
                    this.matrix.data[MatrixLocations.X] = newX;
                }
                else {
                    this.matrix.data[MatrixLocations.X] = x;
                }
            },
            setY: (y) => {
                var _a;
                if (this.parent) {
                    const [, newY] = (_a = this.parent) === null || _a === void 0 ? void 0 : _a.getGlobalMatrix().getAffineInverse().multv([source.data[MatrixLocations.X], y]);
                    this.matrix.data[MatrixLocations.Y] = newY;
                }
                else {
                    this.matrix.data[MatrixLocations.Y] = y;
                }
            }
        });
    }
    set globalPos(val) {
        const parentTransform = this.parent;
        if (!parentTransform) {
            this.pos = val;
        }
        else {
            this.pos = parentTransform.getGlobalMatrix().getAffineInverse().multv(val);
        }
    }
    /**
     * The rotation of the entity in radians. For example `Math.PI` radians is the same as 180 degrees.
     */
    get rotation() {
        if (this._dirty) {
            this._recalculate();
        }
        return this._rotation;
    }
    set rotation(val) {
        this.matrix.setRotation(val);
        this._dirty = true;
    }
    get globalRotation() {
        return this.getGlobalMatrix().getRotation();
    }
    set globalRotation(val) {
        const parentTransform = this.parent;
        if (!parentTransform) {
            this.rotation = val;
        }
        else {
            this.rotation = val - parentTransform.globalRotation;
        }
    }
    /**
     * The scale of the entity.
     */
    get scale() {
        if (this._dirty) {
            this._recalculate();
        }
        return this._scale;
    }
    set scale(val) {
        this.matrix.setScale(val);
        this._dirty = true;
    }
    get globalScale() {
        const source = this.getGlobalMatrix();
        return new VectorView({
            getX: () => source.getScaleX(),
            getY: () => source.getScaleY(),
            setX: (x) => {
                if (this.parent) {
                    const globalScaleX = this.parent.globalScale.x;
                    this.matrix.setScaleX(x / globalScaleX);
                }
                else {
                    this.matrix.setScaleX(x);
                }
            },
            setY: (y) => {
                if (this.parent) {
                    const globalScaleY = this.parent.globalScale.y;
                    this.matrix.setScaleY(y / globalScaleY);
                }
                else {
                    this.matrix.setScaleY(y);
                }
            }
        });
    }
    set globalScale(val) {
        const parentTransform = this.parent;
        if (!parentTransform) {
            this.scale = val;
        }
        else {
            this.scale = vec(val.x / parentTransform.globalScale.x, val.y / parentTransform.globalScale.y);
        }
    }
    /**
     * Apply the transform to a point
     * @param point
     */
    apply(point) {
        return this.matrix.multv(point);
    }
    /**
     * Apply the inverse transform to a point
     * @param point
     */
    applyInverse(point) {
        return this.matrix.getAffineInverse().multv(point);
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Components/MotionComponent.ts


class MotionComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.motion';
        /**
         * The velocity of an entity in pixels per second
         */
        this.vel = Vector.Zero;
        /**
         * The acceleration of entity in pixels per second^2
         */
        this.acc = Vector.Zero;
        /**
         * The scale rate of change in scale units per second
         */
        this.scaleFactor = Vector.Zero;
        /**
         * The angular velocity which is how quickly the entity is rotating in radians per second
         */
        this.angularVelocity = 0;
        /**
         * The amount of torque applied to the entity, angular acceleration is torque * inertia
         */
        this.torque = 0;
        /**
         * Inerita can be thought of as the resistance to motion
         */
        this.inertia = 1;
    }
}

;// CONCATENATED MODULE: ./Collision/Group/CollisionGroup.ts
/**
 * CollisionGroups indicate like members that do not collide with each other. Use [[CollisionGroupManager]] to create [[CollisionGroup]]s
 *
 * For example:
 *
 * Players have collision group "player"
 *
 * ![Player Collision Group](/assets/images/docs/CollisionGroupsPlayer.png)
 *
 * Enemies have collision group "enemy"
 *
 * ![Enemy Collision Group](/assets/images/docs/CollisionGroupsEnemy.png)
 *
 * Blocks have collision group "ground"
 *
 * ![Ground collision group](/assets/images/docs/CollisionGroupsGround.png)
 *
 * Players don't collide with each other, but enemies and blocks. Likewise, enemies don't collide with each other but collide
 * with players and blocks.
 *
 * This is done with bitmasking, see the following pseudo-code
 *
 * PlayerGroup = `0b001`
 * PlayerGroupMask = `0b110`
 *
 * EnemyGroup = `0b010`
 * EnemyGroupMask = `0b101`
 *
 * BlockGroup = `0b100`
 * BlockGroupMask = `0b011`
 *
 * Should Players collide? No because the bitwise mask evaluates to 0
 * `(player1.group & player2.mask) === 0`
 * `(0b001 & 0b110) === 0`
 *
 * Should Players and Enemies collide? Yes because the bitwise mask is non-zero
 * `(player1.group & enemy1.mask) === 1`
 * `(0b001 & 0b101) === 1`
 *
 * Should Players and Blocks collide? Yes because the bitwise mask is non-zero
 * `(player1.group & blocks1.mask) === 1`
 * `(0b001 & 0b011) === 1`
 */
class CollisionGroup {
    /**
     * STOP!!** It is preferred that [[CollisionGroupManager.create]] is used to create collision groups
     *  unless you know how to construct the proper bitmasks. See https://github.com/excaliburjs/Excalibur/issues/1091 for more info.
     * @param name Name of the collision group
     * @param category 32 bit category for the group, should be a unique power of 2. For example `0b001` or `0b010`
     * @param mask 32 bit mask of category, or `~category` generally. For a category of `0b001`, the mask would be `0b110`
     */
    constructor(name, category, mask) {
        this._name = name;
        this._category = category;
        this._mask = mask;
    }
    /**
     * Get the name of the collision group
     */
    get name() {
        return this._name;
    }
    /**
     * Get the category of the collision group, a 32 bit number which should be a unique power of 2
     */
    get category() {
        return this._category;
    }
    /**
     * Get the mask for this collision group
     */
    get mask() {
        return this._mask;
    }
    /**
     * Evaluates whether 2 collision groups can collide
     * @param other  CollisionGroup
     */
    canCollide(other) {
        return (this.category & other.mask) !== 0 && (other.category & this.mask) !== 0;
    }
    /**
     * Inverts the collision group. For example, if before the group specified "players",
     * inverting would specify all groups except players
     * @returns CollisionGroup
     */
    invert() {
        return new CollisionGroup('~(' + this.name + ')', ~this.category, ~this.mask);
    }
    /**
     * Combine collision groups with each other. The new group includes all of the previous groups.
     *
     * @param collisionGroups
     * @returns
     */
    static combine(collisionGroups) {
        const combinedName = collisionGroups.map((c) => c.name).join('+');
        const combinedCategory = collisionGroups.reduce((current, g) => g.category | current, 0b0);
        const combinedMask = ~combinedCategory;
        return new CollisionGroup(combinedName, combinedCategory, combinedMask);
    }
    /**
     * Creates a collision group that collides with the listed groups
     * @param collisionGroups
     */
    static collidesWith(collisionGroups) {
        return CollisionGroup.combine(collisionGroups).invert();
    }
}
/**
 * The `All` [[CollisionGroup]] is a special group that collides with all other groups including itself,
 * it is the default collision group on colliders.
 */
CollisionGroup.All = new CollisionGroup('Collide with all groups', -1, -1);

;// CONCATENATED MODULE: ./Util/Observable.ts
/**
 * Simple Observable implemenation
 * @template T is the typescript Type that defines the data being observed
 */
class Observable {
    constructor() {
        this.observers = [];
        this.subscriptions = [];
    }
    /**
     * Register an observer to listen to this observable
     * @param observer
     */
    register(observer) {
        this.observers.push(observer);
    }
    /**
     * Register a callback to listen to this observable
     * @param func
     */
    subscribe(func) {
        this.subscriptions.push(func);
    }
    /**
     * Remove an observer from the observable
     * @param observer
     */
    unregister(observer) {
        const i = this.observers.indexOf(observer);
        if (i !== -1) {
            this.observers.splice(i, 1);
        }
    }
    /**
     * Remove a callback that is listening to this observable
     * @param func
     */
    unsubscribe(func) {
        const i = this.subscriptions.indexOf(func);
        if (i !== -1) {
            this.subscriptions.splice(i, 1);
        }
    }
    /**
     * Broadcasts a message to all observers and callbacks
     * @param message
     */
    notifyAll(message) {
        this.observers.forEach((o) => o.notify(message));
        this.subscriptions.forEach(cb => cb(message));
    }
    /**
     * Removes all observers and callbacks
     */
    clear() {
        this.observers.length = 0;
        this.subscriptions.length = 0;
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/Pair.ts


/**
 * Models a potential collision between 2 colliders
 */
class Pair {
    constructor(colliderA, colliderB) {
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.id = null;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
    }
    static canCollide(colliderA, colliderB) {
        var _a, _b;
        const bodyA = (_a = colliderA === null || colliderA === void 0 ? void 0 : colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = colliderB === null || colliderB === void 0 ? void 0 : colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        // Body's needed for collision in the current state
        // TODO can we collide without a body?
        if (!bodyA || !bodyB) {
            return false;
        }
        // If both are in the same collision group short circuit
        if (!bodyA.group.canCollide(bodyB.group)) {
            return false;
        }
        // if both are fixed short circuit
        if (bodyA.collisionType === CollisionType.Fixed && bodyB.collisionType === CollisionType.Fixed) {
            return false;
        }
        // if the either is prevent collision short circuit
        if (bodyB.collisionType === CollisionType.PreventCollision || bodyA.collisionType === CollisionType.PreventCollision) {
            return false;
        }
        // if either is dead short circuit
        if (!bodyA.active || !bodyB.active) {
            return false;
        }
        return true;
    }
    /**
     * Returns whether or not it is possible for the pairs to collide
     */
    get canCollide() {
        const colliderA = this.colliderA;
        const colliderB = this.colliderB;
        return Pair.canCollide(colliderA, colliderB);
    }
    /**
     * Runs the collision intersection logic on the members of this pair
     */
    collide() {
        return this.colliderA.collide(this.colliderB);
    }
    /**
     * Check if the collider is part of the pair
     * @param collider
     * @returns
     */
    hasCollider(collider) {
        return collider === this.colliderA || collider === this.colliderB;
    }
    /**
     * Calculates the unique pair hash id for this collision pair (owning id)
     */
    static calculatePairHash(idA, idB) {
        if (idA.value < idB.value) {
            return `#${idA.value}+${idB.value}`;
        }
        else {
            return `#${idB.value}+${idA.value}`;
        }
    }
}

;// CONCATENATED MODULE: ./Math/projection.ts
/**
 * A 1 dimensional projection on an axis, used to test overlaps
 */
class Projection {
    constructor(min, max) {
        this.min = min;
        this.max = max;
    }
    overlaps(projection) {
        return this.max > projection.min && projection.max > this.min;
    }
    getOverlap(projection) {
        if (this.overlaps(projection)) {
            if (this.max > projection.max) {
                return projection.max - this.min;
            }
            else {
                return this.max - projection.min;
            }
        }
        return 0;
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/DynamicTree.ts





/**
 * Dynamic Tree Node used for tracking bounds within the tree
 */
class TreeNode {
    constructor(parent) {
        this.parent = parent;
        this.parent = parent || null;
        this.data = null;
        this.bounds = new BoundingBox();
        this.left = null;
        this.right = null;
        this.height = 0;
    }
    isLeaf() {
        return !this.left && !this.right;
    }
}
/**
 * The DynamicTrees provides a spatial partitioning data structure for quickly querying for overlapping bounding boxes for
 * all tracked bodies. The worst case performance of this is O(n*log(n)) where n is the number of bodies in the tree.
 *
 * Internally the bounding boxes are organized as a balanced binary tree of bounding boxes, where the leaf nodes are tracked bodies.
 * Every non-leaf node is a bounding box that contains child bounding boxes.
 */
class DynamicTree {
    constructor(worldBounds = new BoundingBox(-Number.MAX_VALUE, -Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE)) {
        this.worldBounds = worldBounds;
        this.root = null;
        this.nodes = {};
    }
    /**
     * Inserts a node into the dynamic tree
     */
    _insert(leaf) {
        // If there are no nodes in the tree, make this the root leaf
        if (this.root === null) {
            this.root = leaf;
            this.root.parent = null;
            return;
        }
        // Search the tree for a node that is not a leaf and find the best place to insert
        const leafAABB = leaf.bounds;
        let currentRoot = this.root;
        while (!currentRoot.isLeaf()) {
            const left = currentRoot.left;
            const right = currentRoot.right;
            const area = currentRoot.bounds.getPerimeter();
            const combinedAABB = currentRoot.bounds.combine(leafAABB);
            const combinedArea = combinedAABB.getPerimeter();
            // Calculate cost heuristic for creating a new parent and leaf
            const cost = 2 * combinedArea;
            // Minimum cost of pushing the leaf down the tree
            const inheritanceCost = 2 * (combinedArea - area);
            // Cost of descending
            let leftCost = 0;
            const leftCombined = leafAABB.combine(left.bounds);
            let newArea;
            let oldArea;
            if (left.isLeaf()) {
                leftCost = leftCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = left.bounds.getPerimeter();
                newArea = leftCombined.getPerimeter();
                leftCost = newArea - oldArea + inheritanceCost;
            }
            let rightCost = 0;
            const rightCombined = leafAABB.combine(right.bounds);
            if (right.isLeaf()) {
                rightCost = rightCombined.getPerimeter() + inheritanceCost;
            }
            else {
                oldArea = right.bounds.getPerimeter();
                newArea = rightCombined.getPerimeter();
                rightCost = newArea - oldArea + inheritanceCost;
            }
            // cost is acceptable
            if (cost < leftCost && cost < rightCost) {
                break;
            }
            // Descend to the depths
            if (leftCost < rightCost) {
                currentRoot = left;
            }
            else {
                currentRoot = right;
            }
        }
        // Create the new parent node and insert into the tree
        const oldParent = currentRoot.parent;
        const newParent = new TreeNode(oldParent);
        newParent.bounds = leafAABB.combine(currentRoot.bounds);
        newParent.height = currentRoot.height + 1;
        if (oldParent !== null) {
            // The sibling node was not the root
            if (oldParent.left === currentRoot) {
                oldParent.left = newParent;
            }
            else {
                oldParent.right = newParent;
            }
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
        }
        else {
            // The sibling node was the root
            newParent.left = currentRoot;
            newParent.right = leaf;
            currentRoot.parent = newParent;
            leaf.parent = newParent;
            this.root = newParent;
        }
        // Walk up the tree fixing heights and AABBs
        let currentNode = leaf.parent;
        while (currentNode) {
            currentNode = this._balance(currentNode);
            if (!currentNode.left) {
                throw new Error('Parent of current leaf cannot have a null left child' + currentNode);
            }
            if (!currentNode.right) {
                throw new Error('Parent of current leaf cannot have a null right child' + currentNode);
            }
            currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
            currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
            currentNode = currentNode.parent;
        }
    }
    /**
     * Removes a node from the dynamic tree
     */
    _remove(leaf) {
        if (leaf === this.root) {
            this.root = null;
            return;
        }
        const parent = leaf.parent;
        const grandParent = parent.parent;
        let sibling;
        if (parent.left === leaf) {
            sibling = parent.right;
        }
        else {
            sibling = parent.left;
        }
        if (grandParent) {
            if (grandParent.left === parent) {
                grandParent.left = sibling;
            }
            else {
                grandParent.right = sibling;
            }
            sibling.parent = grandParent;
            let currentNode = grandParent;
            while (currentNode) {
                currentNode = this._balance(currentNode);
                currentNode.bounds = currentNode.left.bounds.combine(currentNode.right.bounds);
                currentNode.height = 1 + Math.max(currentNode.left.height, currentNode.right.height);
                currentNode = currentNode.parent;
            }
        }
        else {
            this.root = sibling;
            sibling.parent = null;
        }
    }
    /**
     * Tracks a body in the dynamic tree
     */
    trackCollider(collider) {
        const node = new TreeNode();
        node.data = collider;
        node.bounds = collider.bounds;
        node.bounds.left -= 2;
        node.bounds.top -= 2;
        node.bounds.right += 2;
        node.bounds.bottom += 2;
        this.nodes[collider.id.value] = node;
        this._insert(node);
    }
    /**
     * Updates the dynamic tree given the current bounds of each body being tracked
     */
    updateCollider(collider) {
        var _a;
        const node = this.nodes[collider.id.value];
        if (!node) {
            return false;
        }
        const b = collider.bounds;
        // if the body is outside the world no longer update it
        if (!this.worldBounds.contains(b)) {
            Logger.getInstance().warn('Collider with id ' + collider.id.value + ' is outside the world bounds and will no longer be tracked for physics');
            this.untrackCollider(collider);
            return false;
        }
        if (node.bounds.contains(b)) {
            return false;
        }
        this._remove(node);
        b.left -= Physics.boundsPadding;
        b.top -= Physics.boundsPadding;
        b.right += Physics.boundsPadding;
        b.bottom += Physics.boundsPadding;
        // THIS IS CAUSING UNECESSARY CHECKS
        if (collider.owner) {
            const body = (_a = collider.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            if (body) {
                const multdx = ((body.vel.x * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;
                const multdy = ((body.vel.y * 32) / 1000) * Physics.dynamicTreeVelocityMultiplier;
                if (multdx < 0) {
                    b.left += multdx;
                }
                else {
                    b.right += multdx;
                }
                if (multdy < 0) {
                    b.top += multdy;
                }
                else {
                    b.bottom += multdy;
                }
            }
        }
        node.bounds = b;
        this._insert(node);
        return true;
    }
    /**
     * Untracks a body from the dynamic tree
     */
    untrackCollider(collider) {
        const node = this.nodes[collider.id.value];
        if (!node) {
            return;
        }
        this._remove(node);
        this.nodes[collider.id.value] = null;
        delete this.nodes[collider.id.value];
    }
    /**
     * Balances the tree about a node
     */
    _balance(node) {
        if (node === null) {
            throw new Error('Cannot balance at null node');
        }
        if (node.isLeaf() || node.height < 2) {
            return node;
        }
        const left = node.left;
        const right = node.right;
        const a = node;
        const b = left;
        const c = right;
        const d = left.left;
        const e = left.right;
        const f = right.left;
        const g = right.right;
        const balance = c.height - b.height;
        // Rotate c node up
        if (balance > 1) {
            // Swap the right node with it's parent
            c.left = a;
            c.parent = a.parent;
            a.parent = c;
            // The original node's old parent should point to the right node
            // this is mega confusing
            if (c.parent) {
                if (c.parent.left === a) {
                    c.parent.left = c;
                }
                else {
                    c.parent.right = c;
                }
            }
            else {
                this.root = c;
            }
            // Rotate
            if (f.height > g.height) {
                c.right = f;
                a.right = g;
                g.parent = a;
                a.bounds = b.bounds.combine(g.bounds);
                c.bounds = a.bounds.combine(f.bounds);
                a.height = 1 + Math.max(b.height, g.height);
                c.height = 1 + Math.max(a.height, f.height);
            }
            else {
                c.right = g;
                a.right = f;
                f.parent = a;
                a.bounds = b.bounds.combine(f.bounds);
                c.bounds = a.bounds.combine(g.bounds);
                a.height = 1 + Math.max(b.height, f.height);
                c.height = 1 + Math.max(a.height, g.height);
            }
            return c;
        }
        // Rotate left node up
        if (balance < -1) {
            // swap
            b.left = a;
            b.parent = a.parent;
            a.parent = b;
            // node's old parent should point to b
            if (b.parent) {
                if (b.parent.left === a) {
                    b.parent.left = b;
                }
                else {
                    if (b.parent.right !== a) {
                        throw 'Error rotating Dynamic Tree';
                    }
                    b.parent.right = b;
                }
            }
            else {
                this.root = b;
            }
            // rotate
            if (d.height > e.height) {
                b.right = d;
                a.left = e;
                e.parent = a;
                a.bounds = c.bounds.combine(e.bounds);
                b.bounds = a.bounds.combine(d.bounds);
                a.height = 1 + Math.max(c.height, e.height);
                b.height = 1 + Math.max(a.height, d.height);
            }
            else {
                b.right = e;
                a.left = d;
                d.parent = a;
                a.bounds = c.bounds.combine(d.bounds);
                b.bounds = a.bounds.combine(e.bounds);
                a.height = 1 + Math.max(c.height, d.height);
                b.height = 1 + Math.max(a.height, e.height);
            }
            return b;
        }
        return node;
    }
    /**
     * Returns the internal height of the tree, shorter trees are better. Performance drops as the tree grows
     */
    getHeight() {
        if (this.root === null) {
            return 0;
        }
        return this.root.height;
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be colliding with the provided body.
     *
     * In the query callback, it will be passed a potential collider. Returning true from this callback indicates
     * that you are complete with your query and you do not want to continue. Returning false will continue searching
     * the tree until all possible colliders have been returned.
     */
    query(collider, callback) {
        const bounds = collider.bounds;
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.intersect(bounds)) {
                if (currentNode.isLeaf() && currentNode.data !== collider) {
                    if (callback.call(collider, currentNode.data)) {
                        return true;
                    }
                }
                else {
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false;
        };
        helper(this.root);
    }
    /**
     * Queries the Dynamic Axis Aligned Tree for bodies that could be intersecting. By default the raycast query uses an infinitely
     * long ray to test the tree specified by `max`.
     *
     * In the query callback, it will be passed a potential body that intersects with the raycast. Returning true from this
     * callback indicates that your are complete with your query and do not want to continue. Return false will continue searching
     * the tree until all possible bodies that would intersect with the ray have been returned.
     */
    rayCastQuery(ray, max = Infinity, callback) {
        const helper = (currentNode) => {
            if (currentNode && currentNode.bounds.rayCast(ray, max)) {
                if (currentNode.isLeaf()) {
                    if (callback.call(ray, currentNode.data)) {
                        // ray hit a leaf! return the body
                        return true;
                    }
                }
                else {
                    // ray hit but not at a leaf, recurse deeper
                    return helper(currentNode.left) || helper(currentNode.right);
                }
            }
            return false; // ray missed
        };
        helper(this.root);
    }
    getNodes() {
        const helper = (currentNode) => {
            if (currentNode) {
                return [currentNode].concat(helper(currentNode.left), helper(currentNode.right));
            }
            else {
                return [];
            }
        };
        return helper(this.root);
    }
    debug(ex) {
        // draw all the nodes in the Dynamic Tree
        const helper = (currentNode) => {
            if (currentNode) {
                if (currentNode.isLeaf()) {
                    currentNode.bounds.draw(ex, Color.Green);
                }
                else {
                    currentNode.bounds.draw(ex, Color.White);
                }
                if (currentNode.left) {
                    helper(currentNode.left);
                }
                if (currentNode.right) {
                    helper(currentNode.right);
                }
            }
        };
        helper(this.root);
    }
}

;// CONCATENATED MODULE: ./Math/ray.ts
/**
 * A 2D ray that can be cast into the scene to do collision detection
 */
class Ray {
    /**
     * @param pos The starting position for the ray
     * @param dir The vector indicating the direction of the ray
     */
    constructor(pos, dir) {
        this.pos = pos;
        this.dir = dir.normalize();
    }
    /**
     * Tests a whether this ray intersects with a line segment. Returns a number greater than or equal to 0 on success.
     * This number indicates the mathematical intersection time.
     * @param line  The line to test
     */
    intersect(line) {
        const numerator = line.begin.sub(this.pos);
        // Test is line and ray are parallel and non intersecting
        if (this.dir.cross(line.getSlope()) === 0 && numerator.cross(this.dir) !== 0) {
            return -1;
        }
        // Lines are parallel
        const divisor = this.dir.cross(line.getSlope());
        if (divisor === 0) {
            return -1;
        }
        const t = numerator.cross(line.getSlope()) / divisor;
        if (t >= 0) {
            const u = numerator.cross(this.dir) / divisor / line.getLength();
            if (u >= 0 && u <= 1) {
                return t;
            }
        }
        return -1;
    }
    intersectPoint(line) {
        const time = this.intersect(line);
        if (time < 0) {
            return null;
        }
        return this.getPoint(time);
    }
    /**
     * Returns the point of intersection given the intersection time
     */
    getPoint(time) {
        return this.pos.add(this.dir.scale(time));
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/DynamicTreeCollisionProcessor.ts









/**
 * Responsible for performing the collision broadphase (locating potential colllisions) and
 * the narrowphase (actual collision contacts)
 */
class DynamicTreeCollisionProcessor {
    constructor() {
        this._dynamicCollisionTree = new DynamicTree();
        this._collisions = new Set();
        this._collisionPairCache = [];
        this._colliders = [];
    }
    getColliders() {
        return this._colliders;
    }
    /**
     * Tracks a physics body for collisions
     */
    track(target) {
        if (!target) {
            Logger.getInstance().warn('Cannot track null collider');
            return;
        }
        if (target instanceof CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                c.owner = target.owner;
                this._colliders.push(c);
                this._dynamicCollisionTree.trackCollider(c);
            }
        }
        else {
            this._colliders.push(target);
            this._dynamicCollisionTree.trackCollider(target);
        }
    }
    /**
     * Untracks a physics body
     */
    untrack(target) {
        if (!target) {
            Logger.getInstance().warn('Cannot untrack a null collider');
            return;
        }
        if (target instanceof CompositeCollider) {
            const colliders = target.getColliders();
            for (const c of colliders) {
                const index = this._colliders.indexOf(c);
                if (index !== -1) {
                    this._colliders.splice(index, 1);
                }
                this._dynamicCollisionTree.untrackCollider(c);
            }
        }
        else {
            const index = this._colliders.indexOf(target);
            if (index !== -1) {
                this._colliders.splice(index, 1);
            }
            this._dynamicCollisionTree.untrackCollider(target);
        }
    }
    _shouldGenerateCollisionPair(colliderA, colliderB) {
        // if the collision pair must be 2 separate colliders
        // Also separate owners for composite colliders
        if ((colliderA.id !== null &&
            colliderB.id !== null &&
            colliderA.id === colliderB.id) ||
            (colliderA.owner !== null &&
                colliderB.owner !== null &&
                colliderA.owner === colliderB.owner)) {
            return false;
        }
        // if the collision pair has been calculated already short circuit
        const hash = Pair.calculatePairHash(colliderA.id, colliderB.id);
        if (this._collisions.has(hash)) {
            return false; // pair exists easy exit return false
        }
        // if the pair has a member with zero dimension
        if (colliderA.localBounds.hasZeroDimensions() || colliderB.localBounds.hasZeroDimensions()) {
            return false;
        }
        return Pair.canCollide(colliderA, colliderB);
    }
    /**
     * Detects potential collision pairs in a broadphase approach with the dynamic aabb tree strategy
     */
    broadphase(targets, delta, stats) {
        const seconds = delta / 1000;
        // Retrieve the list of potential colliders, exclude killed, prevented, and self
        const potentialColliders = targets.filter((other) => {
            var _a, _b;
            const body = (_a = other.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            return ((_b = other.owner) === null || _b === void 0 ? void 0 : _b.active) && body.collisionType !== CollisionType.PreventCollision;
        });
        // clear old list of collision pairs
        this._collisionPairCache = [];
        this._collisions.clear();
        // check for normal collision pairs
        let collider;
        for (let j = 0, l = potentialColliders.length; j < l; j++) {
            collider = potentialColliders[j];
            // Query the collision tree for potential colliders
            this._dynamicCollisionTree.query(collider, (other) => {
                if (this._shouldGenerateCollisionPair(collider, other)) {
                    const pair = new Pair(collider, other);
                    this._collisions.add(pair.id);
                    this._collisionPairCache.push(pair);
                }
                // Always return false, to query whole tree. Returning true in the query method stops searching
                return false;
            });
        }
        if (stats) {
            stats.physics.pairs = this._collisionPairCache.length;
        }
        // Check dynamic tree for fast moving objects
        // Fast moving objects are those moving at least there smallest bound per frame
        if (Physics.checkForFastBodies) {
            for (const collider of potentialColliders) {
                const body = collider.owner.get(BodyComponent);
                // Skip non-active objects. Does not make sense on other collision types
                if (body.collisionType !== CollisionType.Active) {
                    continue;
                }
                // Maximum travel distance next frame
                const updateDistance = body.vel.size * seconds + // velocity term
                    body.acc.size * 0.5 * seconds * seconds; // acc term
                // Find the minimum dimension
                const minDimension = Math.min(collider.bounds.height, collider.bounds.width);
                if (Physics.disableMinimumSpeedForFastBody || updateDistance > minDimension / 2) {
                    if (stats) {
                        stats.physics.fastBodies++;
                    }
                    // start with the oldPos because the integration for actors has already happened
                    // objects resting on a surface may be slightly penetrating in the current position
                    const updateVec = body.pos.sub(body.oldPos);
                    const centerPoint = collider.center;
                    const furthestPoint = collider.getFurthestPoint(body.vel);
                    const origin = furthestPoint.sub(updateVec);
                    const ray = new Ray(origin, body.vel);
                    // back the ray up by -2x surfaceEpsilon to account for fast moving objects starting on the surface
                    ray.pos = ray.pos.add(ray.dir.scale(-2 * Physics.surfaceEpsilon));
                    let minCollider;
                    let minTranslate = new Vector(Infinity, Infinity);
                    this._dynamicCollisionTree.rayCastQuery(ray, updateDistance + Physics.surfaceEpsilon * 2, (other) => {
                        if (collider !== other && Pair.canCollide(collider, other)) {
                            const hitPoint = other.rayCast(ray, updateDistance + Physics.surfaceEpsilon * 10);
                            if (hitPoint) {
                                const translate = hitPoint.sub(origin);
                                if (translate.size < minTranslate.size) {
                                    minTranslate = translate;
                                    minCollider = other;
                                }
                            }
                        }
                        return false;
                    });
                    if (minCollider && Vector.isValid(minTranslate)) {
                        const pair = new Pair(collider, minCollider);
                        if (!this._collisions.has(pair.id)) {
                            this._collisions.add(pair.id);
                            this._collisionPairCache.push(pair);
                        }
                        // move the fast moving object to the other body
                        // need to push into the surface by ex.Physics.surfaceEpsilon
                        const shift = centerPoint.sub(furthestPoint);
                        body.pos = origin
                            .add(shift)
                            .add(minTranslate)
                            .add(ray.dir.scale(10 * Physics.surfaceEpsilon)); // needed to push the shape slightly into contact
                        collider.update(body.transform);
                        if (stats) {
                            stats.physics.fastBodyCollisions++;
                        }
                    }
                }
            }
        }
        // return cache
        return this._collisionPairCache;
    }
    /**
     * Applies narrow phase on collision pairs to find actual area intersections
     * Adds actual colliding pairs to stats' Frame data
     */
    narrowphase(pairs, stats) {
        let contacts = [];
        for (let i = 0; i < pairs.length; i++) {
            const newContacts = pairs[i].collide();
            contacts = contacts.concat(newContacts);
            if (stats && newContacts.length > 0) {
                for (const c of newContacts) {
                    stats.physics.contacts.set(c.id, c);
                }
            }
        }
        if (stats) {
            stats.physics.collisions += contacts.length;
        }
        return contacts;
    }
    /**
     * Update the dynamic tree positions
     */
    update(targets) {
        let updated = 0;
        const len = targets.length;
        for (let i = 0; i < len; i++) {
            if (this._dynamicCollisionTree.updateCollider(targets[i])) {
                updated++;
            }
        }
        return updated;
    }
    debug(ex) {
        this._dynamicCollisionTree.debug(ex);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/Collider.ts


/**
 * A collision collider specifies the geometry that can detect when other collision colliders intersect
 * for the purposes of colliding 2 objects in excalibur.
 */
class Collider {
    constructor() {
        this.id = createId('collider', Collider._ID++);
        this.events = new EventDispatcher(this);
    }
    /**
     * Returns a boolean indicating whether this body collided with
     * or was in stationary contact with
     * the body of the other [[Collider]]
     */
    touching(other) {
        const contact = this.collide(other);
        if (contact) {
            return true;
        }
        return false;
    }
}
Collider._ID = 0;

;// CONCATENATED MODULE: ./Collision/Colliders/CompositeCollider.ts








class CompositeCollider extends Collider {
    constructor(colliders) {
        super();
        this._collisionProcessor = new DynamicTreeCollisionProcessor();
        this._dynamicAABBTree = new DynamicTree();
        this._colliders = [];
        for (const c of colliders) {
            this.addCollider(c);
        }
    }
    clearColliders() {
        this._colliders = [];
    }
    addCollider(collider) {
        this.events.wire(collider.events);
        this._colliders.push(collider);
        this._collisionProcessor.track(collider);
        this._dynamicAABBTree.trackCollider(collider);
    }
    removeCollider(collider) {
        this.events.unwire(collider.events);
        removeItemFromArray(collider, this._colliders);
        this._collisionProcessor.untrack(collider);
        this._dynamicAABBTree.untrackCollider(collider);
    }
    getColliders() {
        return this._colliders;
    }
    get worldPos() {
        var _a, _b;
        // TODO transform component world pos
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get center() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero;
    }
    get bounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.bounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox().translate(this.worldPos));
        return results;
    }
    get localBounds() {
        var _a, _b;
        // TODO cache this
        const colliders = this.getColliders();
        const results = colliders.reduce((acc, collider) => acc.combine(collider.localBounds), (_b = (_a = colliders[0]) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox());
        return results;
    }
    get axes() {
        // TODO cache this
        const colliders = this.getColliders();
        let axes = [];
        for (const collider of colliders) {
            axes = axes.concat(collider.axes);
        }
        return axes;
    }
    getFurthestPoint(direction) {
        const colliders = this.getColliders();
        const furthestPoints = [];
        for (const collider of colliders) {
            furthestPoints.push(collider.getFurthestPoint(direction));
        }
        // Pick best point from all colliders
        let bestPoint = furthestPoints[0];
        let maxDistance = -Number.MAX_VALUE;
        for (const point of furthestPoints) {
            const distance = point.dot(direction);
            if (distance > maxDistance) {
                bestPoint = point;
                maxDistance = distance;
            }
        }
        return bestPoint;
    }
    getInertia(mass) {
        const colliders = this.getColliders();
        let totalInertia = 0;
        for (const collider of colliders) {
            totalInertia += collider.getInertia(mass);
        }
        return totalInertia;
    }
    collide(other) {
        let otherColliders = [other];
        if (other instanceof CompositeCollider) {
            otherColliders = other.getColliders();
        }
        const pairs = [];
        for (const c of otherColliders) {
            this._dynamicAABBTree.query(c, (potentialCollider) => {
                pairs.push(new Pair(c, potentialCollider));
                return false;
            });
        }
        let contacts = [];
        for (const p of pairs) {
            contacts = contacts.concat(p.collide());
        }
        return contacts;
    }
    getClosestLineBetween(other) {
        const colliders = this.getColliders();
        const lines = [];
        if (other instanceof CompositeCollider) {
            const otherColliders = other.getColliders();
            for (const colliderA of colliders) {
                for (const colliderB of otherColliders) {
                    const maybeLine = colliderA.getClosestLineBetween(colliderB);
                    if (maybeLine) {
                        lines.push(maybeLine);
                    }
                }
            }
        }
        else {
            for (const collider of colliders) {
                const maybeLine = other.getClosestLineBetween(collider);
                if (maybeLine) {
                    lines.push(maybeLine);
                }
            }
        }
        if (lines.length) {
            let minLength = lines[0].getLength();
            let minLine = lines[0];
            for (const line of lines) {
                const length = line.getLength();
                if (length < minLength) {
                    minLength = length;
                    minLine = line;
                }
            }
            return minLine;
        }
        return null;
    }
    contains(point) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            if (collider.contains(point)) {
                return true;
            }
        }
        return false;
    }
    rayCast(ray, max) {
        const colliders = this.getColliders();
        const points = [];
        for (const collider of colliders) {
            const vec = collider.rayCast(ray, max);
            if (vec) {
                points.push(vec);
            }
        }
        if (points.length) {
            let minPoint = points[0];
            let minDistance = minPoint.dot(ray.dir);
            for (const point of points) {
                const distance = ray.dir.dot(point);
                if (distance < minDistance) {
                    minPoint = point;
                    minDistance = distance;
                }
            }
            return minPoint;
        }
        return null;
    }
    project(axis) {
        const colliders = this.getColliders();
        const projs = [];
        for (const collider of colliders) {
            const proj = collider.project(axis);
            if (proj) {
                projs.push(proj);
            }
        }
        // Merge all proj's on the same axis
        if (projs.length) {
            const newProjection = new Projection(projs[0].min, projs[0].max);
            for (const proj of projs) {
                newProjection.min = Math.min(proj.min, newProjection.min);
                newProjection.max = Math.max(proj.max, newProjection.max);
            }
            return newProjection;
        }
        return null;
    }
    update(transform) {
        if (transform) {
            const colliders = this.getColliders();
            for (const collider of colliders) {
                collider.owner = this.owner;
                collider.update(transform);
            }
        }
    }
    draw(ctx, color, pos) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            collider.draw(ctx, color, pos);
        }
    }
    debug(ex, color) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            collider.debug(ex, color);
        }
    }
    debugDraw(ctx, color) {
        const colliders = this.getColliders();
        for (const collider of colliders) {
            collider.draw(ctx, color);
        }
    }
    clone() {
        return new CompositeCollider(this._colliders.map((c) => c.clone()));
    }
}

;// CONCATENATED MODULE: ./Math/line.ts

/**
 * A 2D line segment
 */
class Line {
    /**
     * @param begin  The starting point of the line segment
     * @param end  The ending point of the line segment
     */
    constructor(begin, end) {
        this.begin = begin;
        this.end = end;
    }
    /**
     * Gets the raw slope (m) of the line. Will return (+/-)Infinity for vertical lines.
     */
    get slope() {
        return (this.end.y - this.begin.y) / (this.end.x - this.begin.x);
    }
    /**
     * Gets the Y-intercept (b) of the line. Will return (+/-)Infinity if there is no intercept.
     */
    get intercept() {
        return this.begin.y - this.slope * this.begin.x;
    }
    /**
     * Gets the normal of the line
     */
    normal() {
        return this.end.sub(this.begin).normal();
    }
    dir() {
        return this.end.sub(this.begin);
    }
    getPoints() {
        return [this.begin, this.end];
    }
    /**
     * Returns the slope of the line in the form of a vector of length 1
     */
    getSlope() {
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the edge of the line as vector, the length of the vector is the length of the edge
     */
    getEdge() {
        const begin = this.begin;
        const end = this.end;
        return end.sub(begin);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this.begin;
        const end = this.end;
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Returns the midpoint of the edge
     */
    get midpoint() {
        return this.begin.add(this.end).scale(0.5);
    }
    /**
     * Flips the direction of the line segment
     */
    flip() {
        return new Line(this.end, this.begin);
    }
    /**
     * Tests if a given point is below the line, points in the normal direction above the line are considered above.
     * @param point
     */
    below(point) {
        const above2 = (this.end.x - this.begin.x) * (point.y - this.begin.y) - (this.end.y - this.begin.y) * (point.x - this.begin.x);
        return above2 >= 0;
    }
    /**
     * Returns the clip point
     * @param sideVector Vector that traces the line
     * @param length Length to clip along side
     */
    clip(sideVector, length) {
        let dir = sideVector;
        dir = dir.normalize();
        const near = dir.dot(this.begin) - length;
        const far = dir.dot(this.end) - length;
        const results = [];
        if (near <= 0) {
            results.push(this.begin);
        }
        if (far <= 0) {
            results.push(this.end);
        }
        if (near * far < 0) {
            const clipTime = near / (near - far);
            results.push(this.begin.add(this.end.sub(this.begin).scale(clipTime)));
        }
        if (results.length !== 2) {
            return null;
        }
        return new Line(results[0], results[1]);
    }
    /**
     * Find the perpendicular distance from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * @param point
     */
    distanceToPoint(point, signed = false) {
        const x0 = point.x;
        const y0 = point.y;
        const l = this.getLength();
        const dy = this.end.y - this.begin.y;
        const dx = this.end.x - this.begin.x;
        const distance = (dy * x0 - dx * y0 + this.end.x * this.begin.y - this.end.y * this.begin.x) / l;
        return signed ? distance : Math.abs(distance);
    }
    /**
     * Find the perpendicular line from the line to a point
     * https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line
     * (a - p) - ((a - p) * n)n
     * a is a point on the line
     * p is the arbitrary point above the line
     * n is a unit vector in direction of the line
     * @param point
     */
    findVectorToPoint(point) {
        const aMinusP = this.begin.sub(point);
        const n = this.getSlope();
        return aMinusP.sub(n.scale(aMinusP.dot(n)));
    }
    /**
     * Finds a point on the line given only an X or a Y value. Given an X value, the function returns
     * a new point with the calculated Y value and vice-versa.
     *
     * @param x The known X value of the target point
     * @param y The known Y value of the target point
     * @returns A new point with the other calculated axis value
     */
    findPoint(x = null, y = null) {
        const m = this.slope;
        const b = this.intercept;
        if (x !== null) {
            return new Vector(x, m * x + b);
        }
        else if (y !== null) {
            return new Vector((y - b) / m, y);
        }
        else {
            throw new Error('You must provide an X or a Y value');
        }
    }
    /**
     * @see http://stackoverflow.com/a/11908158/109458
     */
    hasPoint() {
        let currPoint;
        let threshold = 0;
        if (typeof arguments[0] === 'number' && typeof arguments[1] === 'number') {
            currPoint = new Vector(arguments[0], arguments[1]);
            threshold = arguments[2] || 0;
        }
        else if (arguments[0] instanceof Vector) {
            currPoint = arguments[0];
            threshold = arguments[1] || 0;
        }
        else {
            throw 'Could not determine the arguments for Vector.hasPoint';
        }
        const dxc = currPoint.x - this.begin.x;
        const dyc = currPoint.y - this.begin.y;
        const dx1 = this.end.x - this.begin.x;
        const dy1 = this.end.y - this.begin.y;
        const cross = dxc * dy1 - dyc * dx1;
        // check whether point lines on the line
        if (Math.abs(cross) > threshold) {
            return false;
        }
        // check whether point lies in-between start and end
        if (Math.abs(dx1) >= Math.abs(dy1)) {
            return dx1 > 0 ? this.begin.x <= currPoint.x && currPoint.x <= this.end.x : this.end.x <= currPoint.x && currPoint.x <= this.begin.x;
        }
        else {
            return dy1 > 0 ? this.begin.y <= currPoint.y && currPoint.y <= this.end.y : this.end.y <= currPoint.y && currPoint.y <= this.begin.y;
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/ClosestLineJumpTable.ts



/**
 * Finds the closes line between 2 line segments, were the magnitude of u, v are the lengths of each segment
 * L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
 * L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
 * @param p0 Point where L1 begins
 * @param u Direction and length of L1
 * @param q0 Point were L2 begins
 * @param v Direction and length of L2
 */
function ClosestLine(p0, u, q0, v) {
    // Distance between 2 lines http://geomalgorithms.com/a07-_distance.html
    // w(s, t) = P(s) - Q(t)
    // The w(s, t) that has the minimum distance we will say is w(sClosest, tClosest) = wClosest
    //
    // wClosest is the vector that is uniquely perpendicular to the 2 line directions u & v.
    // wClosest = w0 + sClosest * u - tClosest * v, where w0 is p0 - q0
    //
    // The closest point between 2 lines then satisfies this pair of equations
    // 1: u * wClosest = 0
    // 2: v * wClosest = 0
    //
    // Substituting wClosest into the equations we get
    //
    // 1: (u * u) * sClosest - (u * v) tClosest = -u * w0
    // 2: (v * u) * sClosest - (v * v) tClosest = -v * w0
    // simplify w0
    const w0 = p0.sub(q0);
    // simplify (u * u);
    const a = u.dot(u);
    // simplify (u * v);
    const b = u.dot(v);
    // simplify (v * v)
    const c = v.dot(v);
    // simplify (u * w0)
    const d = u.dot(w0);
    // simplify (v * w0)
    const e = v.dot(w0);
    // denominator ac - b^2
    const denom = a * c - b * b;
    let sDenom = denom;
    let tDenom = denom;
    // if denom is 0 they are parallel, use any point from either as the start in this case p0
    if (denom === 0 || denom <= 0.01) {
        const tClosestParallel = d / b;
        return new Line(p0, q0.add(v.scale(tClosestParallel)));
    }
    // Solve for sClosest for infinite line
    let sClosest = b * e - c * d; // / denom;
    // Solve for tClosest for infinite line
    let tClosest = a * e - b * d; // / denom;
    // Solve for segments candidate edges, if sClosest and tClosest are outside their segments
    if (sClosest < 0) {
        sClosest = 0;
        tClosest = e;
        tDenom = c;
    }
    else if (sClosest > sDenom) {
        sClosest = sDenom;
        tClosest = e + b;
        tDenom = c;
    }
    if (tClosest < 0) {
        tClosest = 0;
        if (-d < 0) {
            sClosest = 0;
        }
        else if (-d > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d;
            sDenom = a;
        }
    }
    else if (tClosest > tDenom) {
        tClosest = tDenom;
        if (-d + b < 0) {
            sClosest = 0;
        }
        else if (-d + b > a) {
            sClosest = sDenom;
        }
        else {
            sClosest = -d + b;
            sDenom = a;
        }
    }
    sClosest = Math.abs(sClosest) < 0.001 ? 0 : sClosest / sDenom;
    tClosest = Math.abs(tClosest) < 0.001 ? 0 : tClosest / tDenom;
    return new Line(p0.add(u.scale(sClosest)), q0.add(v.scale(tClosest)));
}
const ClosestLineJumpTable = {
    PolygonPolygonClosestLine(polygonA, polygonB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = polygonB.worldPos;
        const otherDirection = otherWorldPos.sub(polygonA.worldPos);
        const thisDirection = otherDirection.negate();
        const rayTowardsOther = new Ray(polygonA.worldPos, otherDirection);
        const rayTowardsThis = new Ray(otherWorldPos, thisDirection);
        const thisPoint = polygonA.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const otherPoint = polygonB.rayCast(rayTowardsThis).add(rayTowardsThis.dir.scale(0.1));
        const thisFace = polygonA.getClosestFace(thisPoint);
        const otherFace = polygonB.getClosestFace(otherPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const q0 = otherFace.face.begin;
        const v = otherFace.face.getEdge();
        return ClosestLine(p0, u, q0, v);
    },
    PolygonEdgeClosestLine(polygon, edge) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = edge.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection);
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const q0 = edgeStart;
        const v = edgeVector;
        return ClosestLine(p0, u, q0, v);
    },
    PolygonCircleClosestLine(polygon, circle) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circle.worldPos;
        const otherDirection = otherWorldPos.sub(polygon.worldPos);
        const rayTowardsOther = new Ray(polygon.worldPos, otherDirection.normalize());
        const thisPoint = polygon.rayCast(rayTowardsOther).add(rayTowardsOther.dir.scale(0.1));
        const thisFace = polygon.getClosestFace(thisPoint);
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const p0 = thisFace.face.begin;
        const u = thisFace.face.getEdge();
        // Time of minimum distance
        let t = (u.x * (otherWorldPos.x - p0.x) + u.y * (otherWorldPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - otherWorldPos.x, 2) + Math.pow(p0.y + u.y * t - otherWorldPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - otherWorldPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - otherWorldPos.y) * circle.radius) / (circle.radius + d);
        return new Line(u.scale(t).add(p0), new Vector(otherWorldPos.x + circlex, otherWorldPos.y + circley));
    },
    CircleCircleClosestLine(circleA, circleB) {
        // Find the 2 closest faces on each polygon
        const otherWorldPos = circleB.worldPos;
        const otherDirection = otherWorldPos.sub(circleA.worldPos);
        const thisWorldPos = circleA.worldPos;
        const thisDirection = thisWorldPos.sub(circleB.worldPos);
        const rayTowardsOther = new Ray(circleA.worldPos, otherDirection);
        const rayTowardsThis = new Ray(circleB.worldPos, thisDirection);
        const thisPoint = circleA.rayCast(rayTowardsOther);
        const otherPoint = circleB.rayCast(rayTowardsThis);
        return new Line(thisPoint, otherPoint);
    },
    CircleEdgeClosestLine(circle, edge) {
        // https://math.stackexchange.com/questions/1919177/how-to-find-point-on-line-closest-to-sphere
        const circleWorlPos = circle.worldPos;
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLine = edge.asLine();
        const edgeStart = edgeLine.begin;
        const edgeVector = edgeLine.getEdge();
        const p0 = edgeStart;
        const u = edgeVector;
        // Time of minimum distance
        let t = (u.x * (circleWorlPos.x - p0.x) + u.y * (circleWorlPos.y - p0.y)) / (u.x * u.x + u.y * u.y);
        // If time of minimum is past the edge clamp to edge
        if (t > 1) {
            t = 1;
        }
        else if (t < 0) {
            t = 0;
        }
        // Minimum distance
        const d = Math.sqrt(Math.pow(p0.x + u.x * t - circleWorlPos.x, 2) + Math.pow(p0.y + u.y * t - circleWorlPos.y, 2)) - circle.radius;
        const circlex = ((p0.x + u.x * t - circleWorlPos.x) * circle.radius) / (circle.radius + d);
        const circley = ((p0.y + u.y * t - circleWorlPos.y) * circle.radius) / (circle.radius + d);
        return new Line(u.scale(t).add(p0), new Vector(circleWorlPos.x + circlex, circleWorlPos.y + circley));
    },
    EdgeEdgeClosestLine(edgeA, edgeB) {
        // L1 = P(s) = p0 + s * u, where s is time and p0 is the start of the line
        const edgeLineA = edgeA.asLine();
        const edgeStartA = edgeLineA.begin;
        const edgeVectorA = edgeLineA.getEdge();
        const p0 = edgeStartA;
        const u = edgeVectorA;
        // L2 = Q(t) = q0 + t * v, where t is time and q0 is the start of the line
        const edgeLineB = edgeB.asLine();
        const edgeStartB = edgeLineB.begin;
        const edgeVectorB = edgeLineB.getEdge();
        const q0 = edgeStartB;
        const v = edgeVectorB;
        return ClosestLine(p0, u, q0, v);
    }
};

;// CONCATENATED MODULE: ./Collision/Colliders/CircleCollider.ts









/**
 * This is a circle collider for the excalibur rigid body physics simulation
 */
class CircleCollider extends Collider {
    constructor(options) {
        super();
        /**
         * Position of the circle relative to the collider, by default (0, 0).
         */
        this.offset = Vector.Zero;
        this.offset = options.offset || Vector.Zero;
        this.radius = options.radius || 0;
    }
    get worldPos() {
        var _a, _b;
        return this.offset.add((_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero);
    }
    /**
     * Returns a clone of this shape, not associated with any collider
     */
    clone() {
        return new CircleCollider({
            offset: this.offset.clone(),
            radius: this.radius
        });
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        var _a, _b;
        return this.offset.add((_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : Vector.Zero);
    }
    /**
     * Tests if a point is contained in this collider
     */
    contains(point) {
        var _a, _b;
        const pos = (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) !== null && _b !== void 0 ? _b : this.offset;
        const distance = pos.distance(point);
        if (distance <= this.radius) {
            return true;
        }
        return false;
    }
    /**
     * Casts a ray at the Circle collider and returns the nearest point of collision
     * @param ray
     */
    rayCast(ray, max = Infinity) {
        //https://en.wikipedia.org/wiki/Line%E2%80%93sphere_intersection
        const c = this.center;
        const dir = ray.dir;
        const orig = ray.pos;
        const discriminant = Math.sqrt(Math.pow(dir.dot(orig.sub(c)), 2) - Math.pow(orig.sub(c).distance(), 2) + Math.pow(this.radius, 2));
        if (discriminant < 0) {
            // no intersection
            return null;
        }
        else {
            let toi = 0;
            if (discriminant === 0) {
                toi = -dir.dot(orig.sub(c));
                if (toi > 0 && toi < max) {
                    return ray.getPoint(toi);
                }
                return null;
            }
            else {
                const toi1 = -dir.dot(orig.sub(c)) + discriminant;
                const toi2 = -dir.dot(orig.sub(c)) - discriminant;
                const positiveToi = [];
                if (toi1 >= 0) {
                    positiveToi.push(toi1);
                }
                if (toi2 >= 0) {
                    positiveToi.push(toi2);
                }
                const mintoi = Math.min(...positiveToi);
                if (mintoi <= max) {
                    return ray.getPoint(mintoi);
                }
                return null;
            }
        }
    }
    getClosestLineBetween(shape) {
        if (shape instanceof CircleCollider) {
            return ClosestLineJumpTable.CircleCircleClosestLine(this, shape);
        }
        else if (shape instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonCircleClosestLine(shape, this).flip();
        }
        else if (shape instanceof EdgeCollider) {
            return ClosestLineJumpTable.CircleEdgeClosestLine(this, shape).flip();
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(collider) {
        if (collider instanceof CircleCollider) {
            return CollisionJumpTable.CollideCircleCircle(this, collider);
        }
        else if (collider instanceof PolygonCollider) {
            return CollisionJumpTable.CollideCirclePolygon(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return CollisionJumpTable.CollideCircleEdge(this, collider);
        }
        else {
            throw new Error(`Circle could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        return this.center.add(direction.normalize().scale(this.radius));
    }
    /**
     * Find the local point on the shape in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const dir = direction.normalize();
        return dir.scale(this.radius);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in world coordinates
     */
    get bounds() {
        var _a;
        const tx = this._transform;
        const bodyPos = (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _a !== void 0 ? _a : Vector.Zero;
        return new BoundingBox(this.offset.x + bodyPos.x - this.radius, this.offset.y + bodyPos.y - this.radius, this.offset.x + bodyPos.x + this.radius, this.offset.y + bodyPos.y + this.radius);
    }
    /**
     * Get the axis aligned bounding box for the circle collider in local coordinates
     */
    get localBounds() {
        return new BoundingBox(this.offset.x - this.radius, this.offset.y - this.radius, this.offset.x + this.radius, this.offset.y + this.radius);
    }
    /**
     * Get axis not implemented on circles, since there are infinite axis in a circle
     */
    get axes() {
        return [];
    }
    /**
     * Returns the moment of inertia of a circle given it's mass
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        return (mass * this.radius * this.radius) / 2;
    }
    /* istanbul ignore next */
    update(transform) {
        this._transform = transform;
    }
    /**
     * Project the circle along a specified axis
     */
    project(axis) {
        const scalars = [];
        const point = this.center;
        const dotProduct = point.dot(axis);
        scalars.push(dotProduct);
        scalars.push(dotProduct + this.radius);
        scalars.push(dotProduct - this.radius);
        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    draw(ctx, color = Color.Green, pos = Vector.Zero) {
        const newPos = pos.add(this.offset);
        ctx.beginPath();
        ctx.fillStyle = color.toString();
        ctx.arc(newPos.x, newPos.y, this.radius, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
    }
    debug(ex, color) {
        const tx = this._transform;
        const pos = (tx === null || tx === void 0 ? void 0 : tx.globalPos) ? tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset) : this.offset;
        ex.drawCircle(pos, this.radius, color);
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Green) {
        const transform = this._transform;
        const pos = transform ? transform.pos.add(this.offset) : this.offset;
        const rotation = transform ? transform.rotation : 0;
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        ctx.arc(pos.x, pos.y, this.radius, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        ctx.lineTo(Math.cos(rotation) * this.radius + pos.x, Math.sin(rotation) * this.radius + pos.y);
        ctx.closePath();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Collision/Detection/CollisionContact.ts




/**
 * Collision contacts are used internally by Excalibur to resolve collision between colliders. This
 * Pair prevents collisions from being evaluated more than one time
 */
class CollisionContact {
    constructor(colliderA, colliderB, mtv, normal, tangent, points, localPoints, info) {
        this._canceled = false;
        this.colliderA = colliderA;
        this.colliderB = colliderB;
        this.mtv = mtv;
        this.normal = normal;
        this.tangent = tangent;
        this.points = points;
        this.localPoints = localPoints;
        this.info = info;
        this.id = Pair.calculatePairHash(colliderA.id, colliderB.id);
    }
    /**
     * Match contact awake state, except if body's are Fixed
     */
    matchAwake() {
        const bodyA = this.colliderA.owner.get(BodyComponent);
        const bodyB = this.colliderB.owner.get(BodyComponent);
        if (bodyA && bodyB) {
            if (bodyA.sleeping !== bodyB.sleeping) {
                if (bodyA.sleeping && bodyA.collisionType !== CollisionType.Fixed && bodyB.sleepMotion >= Physics.wakeThreshold) {
                    bodyA.setSleeping(false);
                }
                if (bodyB.sleeping && bodyB.collisionType !== CollisionType.Fixed && bodyA.sleepMotion >= Physics.wakeThreshold) {
                    bodyB.setSleeping(false);
                }
            }
        }
    }
    isCanceled() {
        return this._canceled;
    }
    cancel() {
        this._canceled = true;
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/SeparatingAxis.ts
class SeparatingAxis {
    static findPolygonPolygonSeparation(polyA, polyB) {
        let bestSeparation = -Number.MAX_VALUE;
        let bestSide = null;
        let bestAxis = null;
        let bestSideIndex = -1;
        let bestOtherPoint = null;
        const sides = polyA.getSides();
        const localSides = polyA.getLocalSides();
        for (let i = 0; i < sides.length; i++) {
            const side = sides[i];
            const axis = side.normal();
            const vertB = polyB.getFurthestPoint(axis.negate());
            // Separation on side i's axis
            // We are looking for the largest separation between poly A's sides
            const vertSeparation = side.distanceToPoint(vertB, true);
            if (vertSeparation > bestSeparation) {
                bestSeparation = vertSeparation;
                bestSide = side;
                bestAxis = axis;
                bestSideIndex = i;
                bestOtherPoint = vertB;
            }
        }
        return {
            collider: polyA,
            separation: bestAxis ? bestSeparation : 99,
            axis: bestAxis,
            side: bestSide,
            localSide: localSides[bestSideIndex],
            sideId: bestSideIndex,
            point: bestOtherPoint,
            localPoint: bestAxis ? polyB.getFurthestLocalPoint(bestAxis.negate()) : null
        };
    }
    static findCirclePolygonSeparation(circle, polygon) {
        const axes = polygon.axes;
        const pc = polygon.center;
        // Special SAT with circles
        const polyDir = pc.sub(circle.worldPos);
        const closestPointOnPoly = polygon.getFurthestPoint(polyDir.negate());
        axes.push(closestPointOnPoly.sub(circle.worldPos).normalize());
        let minOverlap = Number.MAX_VALUE;
        let minAxis = null;
        let minIndex = -1;
        for (let i = 0; i < axes.length; i++) {
            const proj1 = polygon.project(axes[i]);
            const proj2 = circle.project(axes[i]);
            const overlap = proj1.getOverlap(proj2);
            if (overlap <= 0) {
                return null;
            }
            else {
                if (overlap < minOverlap) {
                    minOverlap = overlap;
                    minAxis = axes[i];
                    minIndex = i;
                }
            }
        }
        if (minIndex < 0) {
            return null;
        }
        return minAxis.normalize().scale(minOverlap);
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/CollisionJumpTable.ts








const CollisionJumpTable = {
    CollideCircleCircle(circleA, circleB) {
        const circleAPos = circleA.worldPos;
        const circleBPos = circleB.worldPos;
        const combinedRadius = circleA.radius + circleB.radius;
        const distance = circleAPos.distance(circleBPos);
        if (distance > combinedRadius) {
            return [];
        }
        // negative means overlap
        const separation = combinedRadius - distance;
        // Normal points from A -> B
        const normal = circleBPos.sub(circleAPos).normalize();
        const tangent = normal.perpendicular();
        const mvt = normal.scale(separation);
        const point = circleA.getFurthestPoint(normal);
        const local = circleA.getFurthestLocalPoint(normal);
        const info = {
            collider: circleA,
            separation,
            axis: normal,
            point: point
        };
        return [new CollisionContact(circleA, circleB, mvt, normal, tangent, [point], [local], info)];
    },
    CollideCirclePolygon(circle, polygon) {
        var _a, _b;
        let minAxis = SeparatingAxis.findCirclePolygonSeparation(circle, polygon);
        if (!minAxis) {
            return [];
        }
        // make sure that the minAxis is pointing away from circle
        const samedir = minAxis.dot(polygon.center.sub(circle.center));
        minAxis = samedir < 0 ? minAxis.negate() : minAxis;
        const point = circle.getFurthestPoint(minAxis);
        const xf = (_b = (_a = circle.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
        const local = xf.applyInverse(point);
        const normal = minAxis.normalize();
        const info = {
            collider: circle,
            separation: -minAxis.size,
            axis: normal,
            point: point,
            localPoint: local,
            side: polygon.findSide(normal.negate()),
            localSide: polygon.findLocalSide(normal.negate())
        };
        return [new CollisionContact(circle, polygon, minAxis, normal, normal.perpendicular(), [point], [local], info)];
    },
    CollideCircleEdge(circle, edge) {
        // TODO not sure this actually abides by local/world collisions
        // Are edge.begin and edge.end local space or world space? I think they should be local
        // center of the circle in world pos
        const cc = circle.center;
        // vector in the direction of the edge
        const edgeWorld = edge.asLine();
        const e = edgeWorld.end.sub(edgeWorld.begin);
        // amount of overlap with the circle's center along the edge direction
        const u = e.dot(edgeWorld.end.sub(cc));
        const v = e.dot(cc.sub(edgeWorld.begin));
        const side = edge.asLine();
        const localSide = edge.asLocalLine();
        // Potential region A collision (circle is on the left side of the edge, before the beginning)
        if (v <= 0) {
            const da = edgeWorld.begin.sub(cc);
            const dda = da.dot(da); // quick and dirty way of calc'n distance in r^2 terms saves some sqrts
            // save some sqrts
            if (dda > circle.radius * circle.radius) {
                return []; // no collision
            }
            const normal = da.normalize();
            const separation = circle.radius - Math.sqrt(dda);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.begin,
                side: side,
                localSide: localSide
            };
            return [
                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.begin], [localSide.begin], info)
            ];
        }
        // Potential region B collision (circle is on the right side of the edge, after the end)
        if (u <= 0) {
            const db = edgeWorld.end.sub(cc);
            const ddb = db.dot(db);
            if (ddb > circle.radius * circle.radius) {
                return [];
            }
            const normal = db.normalize();
            const separation = circle.radius - Math.sqrt(ddb);
            const info = {
                collider: circle,
                separation: separation,
                axis: normal,
                point: side.end,
                side: side,
                localSide: localSide
            };
            return [
                new CollisionContact(circle, edge, normal.scale(separation), normal, normal.perpendicular(), [side.end], [localSide.end], info)
            ];
        }
        // Otherwise potential region AB collision (circle is in the middle of the edge between the beginning and end)
        const den = e.dot(e);
        const pointOnEdge = edgeWorld.begin
            .scale(u)
            .add(edgeWorld.end.scale(v))
            .scale(1 / den);
        const d = cc.sub(pointOnEdge);
        const dd = d.dot(d);
        if (dd > circle.radius * circle.radius) {
            return []; // no collision
        }
        let normal = e.perpendicular();
        // flip correct direction
        if (normal.dot(cc.sub(edgeWorld.begin)) < 0) {
            normal.x = -normal.x;
            normal.y = -normal.y;
        }
        normal = normal.normalize();
        const separation = circle.radius - Math.sqrt(dd);
        const mvt = normal.scale(separation);
        const info = {
            collider: circle,
            separation: separation,
            axis: normal,
            point: pointOnEdge,
            side: side,
            localSide: localSide
        };
        return [
            new CollisionContact(circle, edge, mvt, normal.negate(), normal.negate().perpendicular(), [pointOnEdge], [pointOnEdge.sub(edge.worldPos)], info)
        ];
    },
    CollideEdgeEdge() {
        // Edge-edge collision doesn't make sense
        return [];
    },
    CollidePolygonEdge(polygon, edge) {
        var _a;
        const pc = polygon.center;
        const ec = edge.center;
        const dir = ec.sub(pc).normalize();
        // build a temporary polygon from the edge to use SAT
        const linePoly = new PolygonCollider({
            points: [edge.begin, edge.end, edge.end.add(dir.scale(100)), edge.begin.add(dir.scale(100))],
            offset: edge.offset
        });
        linePoly.owner = edge.owner;
        const tx = (_a = edge.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
        if (tx) {
            linePoly.update(edge.owner.get(TransformComponent));
        }
        // Gross hack but poly-poly works well
        const contact = this.CollidePolygonPolygon(polygon, linePoly);
        if (contact.length) {
            // Fudge the contact back to edge
            contact[0].colliderB = edge;
            contact[0].id = Pair.calculatePairHash(polygon.id, edge.id);
            // contact[0].info.collider
        }
        return contact;
    },
    CollidePolygonPolygon(polyA, polyB) {
        var _a, _b, _c, _d;
        // Multi contact from SAT
        // https://gamedev.stackexchange.com/questions/111390/multiple-contacts-for-sat-collision-detection
        // do a SAT test to find a min axis if it exists
        const separationA = SeparatingAxis.findPolygonPolygonSeparation(polyA, polyB);
        // If there is no overlap from boxA's perspective we can end early
        if (separationA.separation > 0) {
            return [];
        }
        const separationB = SeparatingAxis.findPolygonPolygonSeparation(polyB, polyA);
        // If there is no overlap from boxB's perspective exit now
        if (separationB.separation > 0) {
            return [];
        }
        // Separations are both negative, we want to pick the least negative (minimal movement)
        const separation = separationA.separation > separationB.separation ? separationA : separationB;
        // The incident side is the most opposite from the axes of collision on the other collider
        const other = separation.collider === polyA ? polyB : polyA;
        const incident = other.findSide(separation.axis.negate());
        // Clip incident side by the perpendicular lines at each end of the reference side
        // https://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman_algorithm
        const reference = separation.side;
        const refDir = reference.dir().normalize();
        // Find our contact points by clipping the incident by the collision side
        const clipRight = incident.clip(refDir.negate(), -refDir.dot(reference.begin));
        let clipLeft = null;
        if (clipRight) {
            clipLeft = clipRight.clip(refDir, refDir.dot(reference.end));
        }
        // If there is no left there is no collision
        if (clipLeft) {
            // We only want clip points below the reference edge, discard the others
            const points = clipLeft.getPoints().filter((p) => {
                return reference.below(p);
            });
            let normal = separation.axis;
            let tangent = normal.perpendicular();
            // Point Contact A -> B
            if (polyB.worldPos.sub(polyA.worldPos).dot(normal) < 0) {
                normal = normal.negate();
                tangent = normal.perpendicular();
            }
            // Points are clipped from incident which is the other collider
            // Store those as locals
            let localPoints = [];
            if (separation.collider === polyA) {
                const xf = (_b = (_a = polyB.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
                localPoints = points.map((p) => xf.applyInverse(p));
            }
            else {
                const xf = (_d = (_c = polyA.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
                localPoints = points.map((p) => xf.applyInverse(p));
            }
            return [new CollisionContact(polyA, polyB, normal.scale(-separation.separation), normal, tangent, points, localPoints, separation)];
        }
        return [];
    },
    FindContactSeparation(contact, localPoint) {
        var _a, _b, _c, _d;
        const shapeA = contact.colliderA;
        const txA = (_b = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent)) !== null && _b !== void 0 ? _b : new TransformComponent();
        const shapeB = contact.colliderB;
        const txB = (_d = (_c = contact.colliderB.owner) === null || _c === void 0 ? void 0 : _c.get(TransformComponent)) !== null && _d !== void 0 ? _d : new TransformComponent();
        // both are circles
        if (shapeA instanceof CircleCollider && shapeB instanceof CircleCollider) {
            const combinedRadius = shapeA.radius + shapeB.radius;
            const distance = txA.pos.distance(txB.pos);
            const separation = combinedRadius - distance;
            return -separation;
        }
        // both are polygons
        if (shapeA instanceof PolygonCollider && shapeB instanceof PolygonCollider) {
            if (contact.info.localSide) {
                let side;
                let worldPoint;
                if (contact.info.collider === shapeA) {
                    side = new Line(txA.apply(contact.info.localSide.begin), txA.apply(contact.info.localSide.end));
                    worldPoint = txB.apply(localPoint);
                }
                else {
                    side = new Line(txB.apply(contact.info.localSide.begin), txB.apply(contact.info.localSide.end));
                    worldPoint = txA.apply(localPoint);
                }
                return side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v circle
        if ((shapeA instanceof PolygonCollider && shapeB instanceof CircleCollider) ||
            (shapeB instanceof PolygonCollider && shapeA instanceof CircleCollider)) {
            const worldPoint = txA.apply(localPoint);
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // polygon v edge
        if ((shapeA instanceof EdgeCollider && shapeB instanceof PolygonCollider) ||
            (shapeB instanceof EdgeCollider && shapeA instanceof PolygonCollider)) {
            let worldPoint;
            if (contact.info.collider === shapeA) {
                worldPoint = txB.apply(localPoint);
            }
            else {
                worldPoint = txA.apply(localPoint);
            }
            if (contact.info.side) {
                return contact.info.side.distanceToPoint(worldPoint, true);
            }
        }
        // circle v edge
        if ((shapeA instanceof CircleCollider && shapeB instanceof EdgeCollider) ||
            (shapeB instanceof CircleCollider && shapeA instanceof EdgeCollider)) {
            // Local point is always on the edge which is always shapeB
            const worldPoint = txB.apply(localPoint);
            let circlePoint;
            if (shapeA instanceof CircleCollider) {
                circlePoint = shapeA.getFurthestPoint(contact.normal);
            }
            const dist = worldPoint.distance(circlePoint);
            if (contact.info.side) {
                return dist > 0 ? -dist : 0;
            }
        }
        return 0;
    }
};

;// CONCATENATED MODULE: ./Collision/Colliders/EdgeCollider.ts










/**
 * Edge is a single line collider to create collisions with a single line.
 */
class EdgeCollider extends Collider {
    constructor(options) {
        var _a;
        super();
        this.begin = options.begin || Vector.Zero;
        this.end = options.end || Vector.Zero;
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    /**
     * Returns a clone of this Edge, not associated with any collider
     */
    clone() {
        return new EdgeCollider({
            begin: this.begin.clone(),
            end: this.end.clone()
        });
    }
    get worldPos() {
        var _a;
        const tx = this._transform;
        return (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos.add(this.offset)) !== null && _a !== void 0 ? _a : this.offset;
    }
    /**
     * Get the center of the collision area in world coordinates
     */
    get center() {
        const pos = this.begin.average(this.end).add(this._getBodyPos());
        return pos;
    }
    _getBodyPos() {
        var _a;
        const tx = this._transform;
        const bodyPos = (_a = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _a !== void 0 ? _a : Vector.Zero;
        return bodyPos;
    }
    _getTransformedBegin() {
        const tx = this._transform;
        const angle = tx ? tx.globalRotation : 0;
        return this.begin.rotate(angle).add(this._getBodyPos());
    }
    _getTransformedEnd() {
        const tx = this._transform;
        const angle = tx ? tx.globalRotation : 0;
        return this.end.rotate(angle).add(this._getBodyPos());
    }
    /**
     * Returns the slope of the line in the form of a vector
     */
    getSlope() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return end.sub(begin).scale(1 / distance);
    }
    /**
     * Returns the length of the line segment in pixels
     */
    getLength() {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        const distance = begin.distance(end);
        return distance;
    }
    /**
     * Tests if a point is contained in this collision area
     */
    contains() {
        return false;
    }
    /**
     * @inheritdoc
     */
    rayCast(ray, max = Infinity) {
        const numerator = this._getTransformedBegin().sub(ray.pos);
        // Test is line and ray are parallel and non intersecting
        if (ray.dir.cross(this.getSlope()) === 0 && numerator.cross(ray.dir) !== 0) {
            return null;
        }
        // Lines are parallel
        const divisor = ray.dir.cross(this.getSlope());
        if (divisor === 0) {
            return null;
        }
        const t = numerator.cross(this.getSlope()) / divisor;
        if (t >= 0 && t <= max) {
            const u = numerator.cross(ray.dir) / divisor / this.getLength();
            if (u >= 0 && u <= 1) {
                return ray.getPoint(t);
            }
        }
        return null;
    }
    /**
     * Returns the closes line between this and another collider, from this -> collider
     * @param shape
     */
    getClosestLineBetween(shape) {
        if (shape instanceof CircleCollider) {
            return ClosestLineJumpTable.CircleEdgeClosestLine(shape, this);
        }
        else if (shape instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonEdgeClosestLine(shape, this).flip();
        }
        else if (shape instanceof EdgeCollider) {
            return ClosestLineJumpTable.EdgeEdgeClosestLine(this, shape);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * @inheritdoc
     */
    collide(shape) {
        if (shape instanceof CircleCollider) {
            return CollisionJumpTable.CollideCircleEdge(shape, this);
        }
        else if (shape instanceof PolygonCollider) {
            return CollisionJumpTable.CollidePolygonEdge(shape, this);
        }
        else if (shape instanceof EdgeCollider) {
            return CollisionJumpTable.CollideEdgeEdge();
        }
        else {
            throw new Error(`Edge could not collide with unknown CollisionShape ${typeof shape}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        if (direction.dot(transformedBegin) > 0) {
            return transformedBegin;
        }
        else {
            return transformedEnd;
        }
    }
    _boundsFromBeginEnd(begin, end, padding = 10) {
        // A perfectly vertical or horizontal edge would have a bounds 0 width or height
        // this causes problems for the collision system so we give them some padding
        return new BoundingBox(Math.min(begin.x, end.x) - padding, Math.min(begin.y, end.y) - padding, Math.max(begin.x, end.x) + padding, Math.max(begin.y, end.y) + padding);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in world space
     */
    get bounds() {
        const transformedBegin = this._getTransformedBegin();
        const transformedEnd = this._getTransformedEnd();
        return this._boundsFromBeginEnd(transformedBegin, transformedEnd);
    }
    /**
     * Get the axis aligned bounding box for the edge collider in local space
     */
    get localBounds() {
        return this._boundsFromBeginEnd(this.begin, this.end);
    }
    /**
     * Returns this edge represented as a line in world coordinates
     */
    asLine() {
        return new Line(this._getTransformedBegin(), this._getTransformedEnd());
    }
    /**
     * Return this edge as a line in local line coordinates (relative to the position)
     */
    asLocalLine() {
        return new Line(this.begin, this.end);
    }
    /**
     * Get the axis associated with the edge
     */
    get axes() {
        const e = this._getTransformedEnd().sub(this._getTransformedBegin());
        const edgeNormal = e.normal();
        const axes = [];
        axes.push(edgeNormal);
        axes.push(edgeNormal.negate());
        axes.push(edgeNormal.normal());
        axes.push(edgeNormal.normal().negate());
        return axes;
    }
    /**
     * Get the moment of inertia for an edge
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        const length = this.end.sub(this.begin).distance() / 2;
        return mass * length * length;
    }
    /**
     * @inheritdoc
     */
    update(transform) {
        this._transform = transform;
    }
    /**
     * Project the edge along a specified axis
     */
    project(axis) {
        const scalars = [];
        const points = [this._getTransformedBegin(), this._getTransformedEnd()];
        const len = points.length;
        for (let i = 0; i < len; i++) {
            scalars.push(points[i].dot(axis));
        }
        return new Projection(Math.min.apply(Math, scalars), Math.max.apply(Math, scalars));
    }
    draw(ctx, color = Color.Green, pos = Vector.Zero) {
        const begin = this.begin.add(pos);
        const end = this.end.add(pos);
        ctx.strokeStyle = color.toString();
        ctx.beginPath();
        ctx.moveTo(begin.x, begin.y);
        ctx.lineTo(end.x, end.y);
        ctx.closePath();
        ctx.stroke();
    }
    debug(ex, color) {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        ex.drawLine(begin, end, color, 2);
        ex.drawCircle(begin, 2, color);
        ex.drawCircle(end, 2, color);
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Red) {
        const begin = this._getTransformedBegin();
        const end = this._getTransformedEnd();
        ctx.strokeStyle = color.toString();
        ctx.beginPath();
        ctx.moveTo(begin.x, begin.y);
        ctx.lineTo(end.x, end.y);
        ctx.closePath();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/PolygonCollider.ts











/**
 * Polygon collider for detecting collisions
 */
class PolygonCollider extends Collider {
    constructor(options) {
        var _a;
        super();
        this._transformedPoints = [];
        this._axes = [];
        this._sides = [];
        this._localSides = [];
        this.offset = (_a = options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
        const winding = !!options.clockwiseWinding;
        this.points = (winding ? options.points.reverse() : options.points) || [];
        // calculate initial transformation
        this._calculateTransformation();
    }
    /**
     * Returns a clone of this ConvexPolygon, not associated with any collider
     */
    clone() {
        return new PolygonCollider({
            offset: this.offset.clone(),
            points: this.points.map((p) => p.clone())
        });
    }
    /**
     * Returns the world position of the collider, which is the current body transform plus any defined offset
     */
    get worldPos() {
        if (this._transform) {
            return this._transform.pos.add(this.offset);
        }
        return this.offset;
    }
    /**
     * Get the center of the collider in world coordinates
     */
    get center() {
        return this.bounds.center;
    }
    /**
     * Calculates the underlying transformation from the body relative space to world space
     */
    _calculateTransformation() {
        const transform = this._transform;
        const pos = transform ? transform.globalPos.add(this.offset) : this.offset;
        const angle = transform ? transform.globalRotation : 0;
        const scale = transform ? transform.globalScale : Vector.One;
        const len = this.points.length;
        this._transformedPoints.length = 0; // clear out old transform
        for (let i = 0; i < len; i++) {
            this._transformedPoints[i] = this.points[i].scale(scale).rotate(angle).add(pos);
        }
    }
    /**
     * Gets the points that make up the polygon in world space, from actor relative space (if specified)
     */
    getTransformedPoints() {
        this._calculateTransformation();
        return this._transformedPoints;
    }
    /**
     * Gets the sides of the polygon in world space
     */
    getSides() {
        if (this._sides.length) {
            return this._sides;
        }
        const lines = [];
        const points = this.getTransformedPoints();
        const len = points.length;
        for (let i = 0; i < len; i++) {
            // This winding is important
            lines.push(new Line(points[i], points[(i + 1) % len]));
        }
        this._sides = lines;
        return this._sides;
    }
    /**
     * Returns the local coordinate space sides
     */
    getLocalSides() {
        if (this._localSides.length) {
            return this._localSides;
        }
        const lines = [];
        const points = this.points;
        const len = points.length;
        for (let i = 0; i < len; i++) {
            // This winding is important
            lines.push(new Line(points[i], points[(i + 1) % len]));
        }
        this._localSides = lines;
        return this._localSides;
    }
    /**
     * Given a direction vector find the world space side that is most in that direction
     * @param direction
     */
    findSide(direction) {
        const sides = this.getSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Given a direction vector find the local space side that is most in that direction
     * @param direction
     */
    findLocalSide(direction) {
        const sides = this.getLocalSides();
        let bestSide = sides[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let side = 0; side < sides.length; side++) {
            const currentSide = sides[side];
            const sideNormal = currentSide.normal();
            const mostDirection = sideNormal.dot(direction);
            if (mostDirection > maxDistance) {
                bestSide = currentSide;
                maxDistance = mostDirection;
            }
        }
        return bestSide;
    }
    /**
     * Get the axis associated with the convex polygon
     */
    get axes() {
        if (this._axes.length) {
            return this._axes;
        }
        const axes = this.getSides().map((s) => s.normal());
        this._axes = axes;
        return this._axes;
    }
    update(transform) {
        this._transform = transform;
        this._sides.length = 0;
        this._localSides.length = 0;
        this._axes.length = 0;
        this._transformedPoints.length = 0;
        this.getTransformedPoints();
        this.getSides();
        this.getLocalSides();
    }
    /**
     * Tests if a point is contained in this collider in world space
     */
    contains(point) {
        // Always cast to the right, as long as we cast in a consistent fixed direction we
        // will be fine
        const testRay = new Ray(point, new Vector(1, 0));
        const intersectCount = this.getSides().reduce(function (accum, side) {
            if (testRay.intersect(side) >= 0) {
                return accum + 1;
            }
            return accum;
        }, 0);
        if (intersectCount % 2 === 0) {
            return false;
        }
        return true;
    }
    getClosestLineBetween(collider) {
        if (collider instanceof CircleCollider) {
            return ClosestLineJumpTable.PolygonCircleClosestLine(this, collider);
        }
        else if (collider instanceof PolygonCollider) {
            return ClosestLineJumpTable.PolygonPolygonClosestLine(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return ClosestLineJumpTable.PolygonEdgeClosestLine(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Returns a collision contact if the 2 colliders collide, otherwise collide will
     * return null.
     * @param collider
     */
    collide(collider) {
        if (collider instanceof CircleCollider) {
            return CollisionJumpTable.CollideCirclePolygon(collider, this);
        }
        else if (collider instanceof PolygonCollider) {
            return CollisionJumpTable.CollidePolygonPolygon(this, collider);
        }
        else if (collider instanceof EdgeCollider) {
            return CollisionJumpTable.CollidePolygonEdge(this, collider);
        }
        else {
            throw new Error(`Polygon could not collide with unknown CollisionShape ${typeof collider}`);
        }
    }
    /**
     * Find the point on the collider furthest in the direction specified
     */
    getFurthestPoint(direction) {
        const pts = this.getTransformedPoints();
        let furthestPoint = null;
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Find the local point on the collider furthest in the direction specified
     * @param direction
     */
    getFurthestLocalPoint(direction) {
        const pts = this.points;
        let furthestPoint = pts[0];
        let maxDistance = -Number.MAX_VALUE;
        for (let i = 0; i < pts.length; i++) {
            const distance = direction.dot(pts[i]);
            if (distance > maxDistance) {
                maxDistance = distance;
                furthestPoint = pts[i];
            }
        }
        return furthestPoint;
    }
    /**
     * Finds the closes face to the point using perpendicular distance
     * @param point point to test against polygon
     */
    getClosestFace(point) {
        const sides = this.getSides();
        let min = Number.POSITIVE_INFINITY;
        let faceIndex = -1;
        let distance = -1;
        for (let i = 0; i < sides.length; i++) {
            const dist = sides[i].distanceToPoint(point);
            if (dist < min) {
                min = dist;
                faceIndex = i;
                distance = dist;
            }
        }
        if (faceIndex !== -1) {
            return {
                distance: sides[faceIndex].normal().scale(distance),
                face: sides[faceIndex]
            };
        }
        return null;
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in world coordinates
     */
    get bounds() {
        var _a, _b, _c;
        const tx = this._transform;
        const scale = (_a = tx === null || tx === void 0 ? void 0 : tx.globalScale) !== null && _a !== void 0 ? _a : Vector.One;
        const rotation = (_b = tx === null || tx === void 0 ? void 0 : tx.globalRotation) !== null && _b !== void 0 ? _b : 0;
        const pos = ((_c = tx === null || tx === void 0 ? void 0 : tx.globalPos) !== null && _c !== void 0 ? _c : Vector.Zero).add(this.offset);
        return this.localBounds.scale(scale).rotate(rotation).translate(pos);
    }
    /**
     * Get the axis aligned bounding box for the polygon collider in local coordinates
     */
    get localBounds() {
        return BoundingBox.fromPoints(this.points);
    }
    /**
     * Get the moment of inertia for an arbitrary polygon
     * https://en.wikipedia.org/wiki/List_of_moments_of_inertia
     */
    getInertia(mass) {
        let numerator = 0;
        let denominator = 0;
        for (let i = 0; i < this.points.length; i++) {
            const iplusone = (i + 1) % this.points.length;
            const crossTerm = this.points[iplusone].cross(this.points[i]);
            numerator +=
                crossTerm *
                    (this.points[i].dot(this.points[i]) + this.points[i].dot(this.points[iplusone]) + this.points[iplusone].dot(this.points[iplusone]));
            denominator += crossTerm;
        }
        return (mass / 6) * (numerator / denominator);
    }
    /**
     * Casts a ray into the polygon and returns a vector representing the point of contact (in world space) or null if no collision.
     */
    rayCast(ray, max = Infinity) {
        // find the minimum contact time greater than 0
        // contact times less than 0 are behind the ray and we don't want those
        const sides = this.getSides();
        const len = sides.length;
        let minContactTime = Number.MAX_VALUE;
        let contactIndex = -1;
        for (let i = 0; i < len; i++) {
            const contactTime = ray.intersect(sides[i]);
            if (contactTime >= 0 && contactTime < minContactTime && contactTime <= max) {
                minContactTime = contactTime;
                contactIndex = i;
            }
        }
        // contact was found
        if (contactIndex >= 0) {
            return ray.getPoint(minContactTime);
        }
        // no contact found
        return null;
    }
    /**
     * Project the edges of the polygon along a specified axis
     */
    project(axis) {
        const points = this.getTransformedPoints();
        const len = points.length;
        let min = Number.MAX_VALUE;
        let max = -Number.MAX_VALUE;
        for (let i = 0; i < len; i++) {
            const scalar = points[i].dot(axis);
            min = Math.min(min, scalar);
            max = Math.max(max, scalar);
        }
        return new Projection(min, max);
    }
    draw(ctx, color = Color.Green, pos = Vector.Zero) {
        const effectiveOffset = pos.add(this.offset);
        ctx.beginPath();
        ctx.fillStyle = color.toString();
        const firstPoint = this.points[0].add(effectiveOffset);
        ctx.moveTo(firstPoint.x, firstPoint.y);
        // Points are relative
        this.points
            .map((p) => p.add(effectiveOffset))
            .forEach(function (point) {
            ctx.lineTo(point.x, point.y);
        });
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        ctx.fill();
    }
    debug(ex, color) {
        const firstPoint = this.getTransformedPoints()[0];
        const points = [firstPoint, ...this.getTransformedPoints(), firstPoint];
        for (let i = 0; i < points.length - 1; i++) {
            ex.drawLine(points[i], points[i + 1], color, 2);
            ex.drawCircle(points[i], 2, color);
            ex.drawCircle(points[i + 1], 2, color);
        }
    }
    /* istanbul ignore next */
    debugDraw(ctx, color = Color.Red) {
        ctx.beginPath();
        ctx.strokeStyle = color.toString();
        // Iterate through the supplied points and construct a 'polygon'
        const firstPoint = this.getTransformedPoints()[0];
        ctx.moveTo(firstPoint.x, firstPoint.y);
        this.getTransformedPoints().forEach(function (point) {
            ctx.lineTo(point.x, point.y);
        });
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        ctx.stroke();
    }
}

;// CONCATENATED MODULE: ./Collision/Colliders/Shape.ts







/**
 * Excalibur helper for defining colliders quickly
 */
class Shape {
    /**
     * Creates a box collider, under the hood defines a [[PolygonCollider]] collider
     * @param width Width of the box
     * @param height Height of the box
     * @param anchor Anchor of the box (default (.5, .5)) which positions the box relative to the center of the collider's position
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Box(width, height, anchor = Vector.Half, offset = Vector.Zero) {
        return new PolygonCollider({
            points: new BoundingBox(-width * anchor.x, -height * anchor.y, width - width * anchor.x, height - height * anchor.y).getPoints(),
            offset: offset
        });
    }
    /**
     * Creates a new [[PolygonCollider|arbitrary polygon]] collider
     *
     * PolygonColliders are useful for creating convex polygon shapes
     * @param points Points specified in counter clockwise
     * @param clockwiseWinding Optionally changed the winding of points, by default false meaning counter-clockwise winding.
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Polygon(points, clockwiseWinding = false, offset = Vector.Zero) {
        return new PolygonCollider({
            points: points,
            offset: offset,
            clockwiseWinding: clockwiseWinding
        });
    }
    /**
     * Creates a new [[CircleCollider|circle]] collider
     *
     * Circle colliders are useful for balls, or to make collisions more forgiving on sharp edges
     * @param radius Radius of the circle collider
     * @param offset Optional offset relative to the collider in local coordinates
     */
    static Circle(radius, offset = Vector.Zero) {
        return new CircleCollider({
            radius: radius,
            offset: offset
        });
    }
    /**
     * Creates a new [[EdgeCollider|edge]] collider
     *
     * Edge colliders are useful for  floors, walls, and other barriers
     * @param begin Beginning of the edge in local coordinates to the collider
     * @param end Ending of the edge in local coordinates to the collider
     */
    static Edge(begin, end) {
        return new EdgeCollider({
            begin: begin,
            end: end
        });
    }
    /**
     * Creates a new capsule shaped [[CompositeCollider]] using 2 circles and a box
     *
     * Capsule colliders are useful for platformers with incline or jagged floors to have a smooth
     * player experience.
     *
     * @param width
     * @param height
     * @param offset Optional offset
     */
    static Capsule(width, height, offset = Vector.Zero) {
        const logger = Logger.getInstance();
        if (width === height) {
            logger.warn('A capsule collider with equal width and height is a circle, consider using a ex.Shape.Circle or ex.CircleCollider');
        }
        const vertical = height >= width;
        if (vertical) {
            // height > width, if equal maybe use a circle
            const capsule = new CompositeCollider([
                Shape.Circle(width / 2, vec(0, -height / 2 + width / 2).add(offset)),
                Shape.Box(width, height - width, Vector.Half, offset),
                Shape.Circle(width / 2, vec(0, height / 2 - width / 2).add(offset))
            ]);
            return capsule;
        }
        else {
            // width > height, if equal maybe use a circle
            const capsule = new CompositeCollider([
                Shape.Circle(height / 2, vec(-width / 2 + height / 2, 0).add(offset)),
                Shape.Box(width - height, height, Vector.Half, offset),
                Shape.Circle(height / 2, vec(width / 2 - height / 2, 0).add(offset))
            ]);
            return capsule;
        }
    }
}

;// CONCATENATED MODULE: ./Collision/ColliderComponent.ts









class ColliderComponent extends Component {
    constructor(collider) {
        super();
        this.type = 'ex.collider';
        this.events = new EventDispatcher(this);
        /**
         * Observable that notifies when a collider is added to the body
         */
        this.$colliderAdded = new Observable();
        /**
         * Observable that notifies when a collider is removed from the body
         */
        this.$colliderRemoved = new Observable();
        this.set(collider);
    }
    /**
     * Get the current collider geometry
     * @returns
     */
    get() {
        return this._collider;
    }
    /**
     * Set the collider geometry
     * @param collider
     * @returns the collider you set
     */
    set(collider) {
        this.clear();
        if (collider) {
            this._collider = collider;
            this._collider.owner = this.owner;
            this.events.wire(collider.events);
            this.$colliderAdded.notifyAll(collider);
            this.update();
        }
        return collider;
    }
    /**
     * Remove collider geometry from collider component
     */
    clear() {
        if (this._collider) {
            this.events.unwire(this._collider.events);
            this.$colliderRemoved.notifyAll(this._collider);
            this._collider.owner = null;
            this._collider = null;
        }
    }
    /**
     * Return world space bounds
     */
    get bounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.bounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Return local space bounds
     */
    get localBounds() {
        var _a, _b;
        return (_b = (_a = this._collider) === null || _a === void 0 ? void 0 : _a.localBounds) !== null && _b !== void 0 ? _b : new BoundingBox();
    }
    /**
     * Update the collider's transformed geometry
     */
    update() {
        var _a;
        const tx = (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
        if (this._collider) {
            this._collider.owner = this.owner;
            if (tx) {
                this._collider.update(tx);
            }
        }
    }
    /**
     * Collide component with another
     * @param other
     * @returns
     */
    collide(other) {
        let colliderA = this._collider;
        let colliderB = other._collider;
        if (!colliderA || !colliderB) {
            return [];
        }
        // If we have a composite lefthand side :(
        // Might bite us, but to avoid updating all the handlers make composite always left side
        let flipped = false;
        if (colliderB instanceof CompositeCollider) {
            colliderA = colliderB;
            colliderB = this._collider;
            flipped = true;
        }
        if (this._collider) {
            const contacts = colliderA.collide(colliderB);
            if (contacts) {
                if (flipped) {
                    contacts.forEach((contact) => {
                        contact.mtv = contact.mtv.negate();
                        contact.normal = contact.normal.negate();
                        contact.tangent = contact.normal.perpendicular();
                        contact.colliderA = this._collider;
                        contact.colliderB = other._collider;
                    });
                }
                return contacts;
            }
            return [];
        }
        return [];
    }
    onAdd(entity) {
        if (this._collider) {
            this.update();
        }
        // Wire up the collider events to the owning entity
        this.events.on('precollision', (evt) => {
            const precollision = evt;
            entity.events.emit('precollision', new PreCollisionEvent(precollision.target.owner, precollision.other.owner, precollision.side, precollision.intersection));
        });
        this.events.on('postcollision', (evt) => {
            const postcollision = evt;
            entity.events.emit('postcollision', new PostCollisionEvent(postcollision.target.owner, postcollision.other.owner, postcollision.side, postcollision.intersection));
        });
        this.events.on('collisionstart', (evt) => {
            const start = evt;
            entity.events.emit('collisionstart', new CollisionStartEvent(start.target.owner, start.other.owner, start.contact));
        });
        this.events.on('collisionend', (evt) => {
            const end = evt;
            entity.events.emit('collisionend', new CollisionEndEvent(end.target.owner, end.other.owner));
        });
    }
    onRemove() {
        this.events.clear();
        this.$colliderRemoved.notifyAll(this._collider);
    }
    /**
     * Sets up a box geometry based on the current bounds of the associated actor of this physics body.
     *
     * If no width/height are specified the body will attempt to use the associated actor's width/height.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useBoxCollider(width, height, anchor = Vector.Half, center = Vector.Zero) {
        const collider = Shape.Box(width, height, anchor, center);
        return (this.set(collider));
    }
    /**
     * Sets up a [[PolygonCollider|polygon]] collision geometry based on a list of of points relative
     *  to the anchor of the associated actor
     * of this physics body.
     *
     * Only [convex polygon](https://en.wikipedia.org/wiki/Convex_polygon) definitions are supported.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    usePolygonCollider(points, center = Vector.Zero) {
        const poly = Shape.Polygon(points, false, center);
        return (this.set(poly));
    }
    /**
     * Sets up a [[Circle|circle collision geometry]] as the only collider with a specified radius in pixels.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useCircleCollider(radius, center = Vector.Zero) {
        const collider = Shape.Circle(radius, center);
        return (this.set(collider));
    }
    /**
     * Sets up an [[Edge|edge collision geometry]] with a start point and an end point relative to the anchor of the associated actor
     * of this physics body.
     *
     * By default, the box is center is at (0, 0) which means it is centered around the actors anchor.
     */
    useEdgeCollider(begin, end) {
        const collider = Shape.Edge(begin, end);
        return (this.set(collider));
    }
    /**
     * Setups up a [[CompositeCollider]] which can define any arbitrary set of excalibur colliders
     * @param colliders
     * @returns
     */
    useCompositeCollider(colliders) {
        return (this.set(new CompositeCollider(colliders)));
    }
}

;// CONCATENATED MODULE: ./Collision/BodyComponent.ts











var DegreeOfFreedom;
(function (DegreeOfFreedom) {
    DegreeOfFreedom["Rotation"] = "rotation";
    DegreeOfFreedom["X"] = "x";
    DegreeOfFreedom["Y"] = "y";
})(DegreeOfFreedom || (DegreeOfFreedom = {}));
/**
 * Body describes all the physical properties pos, vel, acc, rotation, angular velocity for the purpose of
 * of physics simulation.
 */
class BodyComponent extends Component {
    constructor(options) {
        var _a, _b, _c;
        super();
        this.type = 'ex.body';
        this.dependencies = [TransformComponent, MotionComponent];
        this.id = createId('body', BodyComponent._ID++);
        this.events = new EventDispatcher(this);
        /**
         * Collision type for the rigidbody physics simulation, by default [[CollisionType.PreventCollision]]
         */
        this.collisionType = CollisionType.PreventCollision;
        /**
         * The collision group for the body's colliders, by default body colliders collide with everything
         */
        this.group = CollisionGroup.All;
        /**
         * The amount of mass the body has
         */
        this.mass = Physics.defaultMass;
        /**
         * Amount of "motion" the body has before sleeping. If below [[Physics.sleepEpsilon]] it goes to "sleep"
         */
        this.sleepMotion = Physics.sleepEpsilon * 5;
        /**
         * Can this body sleep, by default bodies do not sleep
         */
        this.canSleep = Physics.bodiesCanSleepByDefault;
        this._sleeping = false;
        /**
         * The also known as coefficient of restitution of this actor, represents the amount of energy preserved after collision or the
         * bounciness. If 1, it is 100% bouncy, 0 it completely absorbs.
         */
        this.bounciness = 0.2;
        /**
         * The coefficient of friction on this actor
         */
        this.friction = 0.99;
        /**
         * Should use global gravity [[Physics.gravity]] in it's physics simulation, default is true
         */
        this.useGravity = true;
        /**
         * Degrees of freedom to limit
         */
        this.limitDegreeOfFreedom = [];
        /**
         * The position of the actor last frame (x, y) in pixels
         */
        this.oldPos = new Vector(0, 0);
        /**
         * The velocity of the actor last frame (vx, vy) in pixels/second
         */
        this.oldVel = new Vector(0, 0);
        /**
         * Gets/sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
         */
        this.oldAcc = Vector.Zero;
        /**
         * Gets/sets the rotation of the body from the last frame.
         */
        this.oldRotation = 0; // radians
        /**
         * The scale of the actor last frame
         * @deprecated ex.Body.scale will be removed in v0.25.0
         */
        this.oldScale = Vector.One;
        if (options) {
            this.collisionType = (_a = options.type) !== null && _a !== void 0 ? _a : this.collisionType;
            this.group = (_b = options.group) !== null && _b !== void 0 ? _b : this.group;
            this.useGravity = (_c = options.useGravity) !== null && _c !== void 0 ? _c : this.useGravity;
        }
    }
    /**
     * The inverse mass (1/mass) of the body. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseMass() {
        return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.mass;
    }
    /**
     * Whether this body is sleeping or not
     */
    get sleeping() {
        return this._sleeping;
    }
    /**
     * Set the sleep state of the body
     * @param sleeping
     */
    setSleeping(sleeping) {
        this._sleeping = sleeping;
        if (!sleeping) {
            // Give it a kick to keep it from falling asleep immediately
            this.sleepMotion = Physics.sleepEpsilon * 5;
        }
        else {
            this.vel = Vector.Zero;
            this.acc = Vector.Zero;
            this.angularVelocity = 0;
            this.sleepMotion = 0;
        }
    }
    /**
     * Update body's [[BodyComponent.sleepMotion]] for the purpose of sleeping
     */
    updateMotion() {
        if (this._sleeping) {
            this.setSleeping(true);
        }
        const currentMotion = this.vel.size * this.vel.size + Math.abs(this.angularVelocity * this.angularVelocity);
        const bias = Physics.sleepBias;
        this.sleepMotion = bias * this.sleepMotion + (1 - bias) * currentMotion;
        this.sleepMotion = clamp(this.sleepMotion, 0, 10 * Physics.sleepEpsilon);
        if (this.canSleep && this.sleepMotion < Physics.sleepEpsilon) {
            this.setSleeping(true);
        }
    }
    /**
     * Get the moment of inertia from the [[ColliderComponent]]
     */
    get inertia() {
        // Inertia is a property of the geometry, so this is a little goofy but seems to be okay?
        const collider = this.owner.get(ColliderComponent);
        if (collider === null || collider === void 0 ? void 0 : collider.get()) {
            return collider.get().getInertia(this.mass);
        }
        return 0;
    }
    /**
     * Get the inverse moment of inertial from the [[ColliderComponent]]. If [[CollisionType.Fixed]] this is 0, meaning "infinite" mass
     */
    get inverseInertia() {
        return this.collisionType === CollisionType.Fixed ? 0 : 1 / this.inertia;
    }
    /**
     * Returns if the owner is active
     */
    get active() {
        var _a;
        return !!((_a = this.owner) === null || _a === void 0 ? void 0 : _a.active);
    }
    get center() {
        return this.pos;
    }
    get transform() {
        var _a;
        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(TransformComponent);
    }
    get motion() {
        var _a;
        return (_a = this.owner) === null || _a === void 0 ? void 0 : _a.get(MotionComponent);
    }
    /**
     * The (x, y) position of the actor this will be in the middle of the actor if the
     * [[Actor.anchor]] is set to (0.5, 0.5) which is default.
     * If you want the (x, y) position to be the top left of the actor specify an anchor of (0, 0).
     */
    get pos() {
        return this.transform.globalPos;
    }
    set pos(val) {
        this.transform.globalPos = val;
    }
    /**
     * The current velocity vector (vx, vy) of the actor in pixels/second
     */
    get vel() {
        return this.motion.vel;
    }
    set vel(val) {
        this.motion.vel = val;
    }
    /**
     * The current acceleration vector (ax, ay) of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may
     * be useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    set acc(val) {
        this.motion.acc = val;
    }
    /**
     * The current torque applied to the actor
     */
    get torque() {
        return this.motion.torque;
    }
    set torque(val) {
        this.motion.torque = val;
    }
    /**
     * The rotation of the body in radians
     */
    get rotation() {
        return this.transform.globalRotation;
    }
    set rotation(val) {
        this.transform.globalRotation = val;
    }
    /**
     * The scale vector of the actor
     * @deprecated ex.Body.scale will be removed in v0.25.0, Use ex.Transform.scale
     */
    get scale() {
        return this.transform.globalScale;
    }
    set scale(val) {
        this.transform.globalScale = val;
    }
    /**
     * The x scalar velocity of the actor in scale/second
     * @deprecated ex.Body.scale will be removed in v0.25.0
     */
    get sx() {
        return this.motion.scaleFactor.x;
    }
    set sx(xFactor) {
        this.motion.scaleFactor.x = xFactor;
    }
    /**
     * The y scalar velocity of the actor in scale/second
     * @deprecated ex.Body.scale will be removed in v0.25.0
     */
    get sy() {
        return this.motion.scaleFactor.y;
    }
    set sy(yFactor) {
        this.motion.scaleFactor.y = yFactor;
    }
    /**
     * The rotational velocity of the actor in radians/second
     * @deprecated
     */
    get rx() {
        return this.motion.angularVelocity;
    }
    /**
     * The rotational velocity of the actor in radians/second
     * @deprecated
     */
    set rx(value) {
        this.motion.angularVelocity = value;
    }
    /**
     * Get the angular velocity in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Set the angular velocity in radians/second
     */
    set angularVelocity(value) {
        this.motion.angularVelocity = value;
    }
    /**
     * Apply a specific impulse to the body
     * @param point
     * @param impulse
     */
    applyImpulse(point, impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass);
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
            finalImpulse.y = 0;
        }
        this.vel.addEqual(finalImpulse);
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.pos);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Apply only linear impulse to the body
     * @param impulse
     */
    applyLinearImpulse(impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        const finalImpulse = impulse.scale(this.inverseMass);
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.X)) {
            finalImpulse.x = 0;
        }
        if (this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Y)) {
            finalImpulse.y = 0;
        }
        this.vel = this.vel.add(finalImpulse);
    }
    /**
     * Apply only angular impuse to the body
     * @param point
     * @param impulse
     */
    applyAngularImpulse(point, impulse) {
        if (this.collisionType !== CollisionType.Active) {
            return; // only active objects participate in the simulation
        }
        if (!this.limitDegreeOfFreedom.includes(DegreeOfFreedom.Rotation)) {
            const distanceFromCenter = point.sub(this.pos);
            this.angularVelocity += this.inverseInertia * distanceFromCenter.cross(impulse);
        }
    }
    /**
     * Sets the old versions of pos, vel, acc, and scale.
     */
    captureOldTransform() {
        // Capture old values before integration step updates them
        this.oldVel.setTo(this.vel.x, this.vel.y);
        this.oldPos.setTo(this.pos.x, this.pos.y);
        this.oldAcc.setTo(this.acc.x, this.acc.y);
        this.oldScale.setTo(this.scale.x, this.scale.y);
        this.oldRotation = this.rotation;
    }
    debugDraw(_ctx) {
        // pass
    }
}
BodyComponent._ID = 0;

;// CONCATENATED MODULE: ./Util/CullingBox.ts


/**
 * @deprecated Will be removed in 0.26.0
 */
class CullingBox {
    constructor() {
        this._topLeft = new Vector(0, 0);
        this._topRight = new Vector(0, 0);
        this._bottomLeft = new Vector(0, 0);
        this._bottomRight = new Vector(0, 0);
    }
    isSpriteOffScreen(actor, engine) {
        const drawingWidth = actor.currentDrawing.drawWidth;
        const drawingHeight = actor.currentDrawing.drawHeight;
        const rotation = actor.rotation;
        const anchor = actor.center;
        const worldPos = actor.getGlobalPos();
        this._topLeft = vec(worldPos.x - drawingWidth / 2, worldPos.y - drawingHeight / 2);
        this._topLeft = this._topLeft.rotate(rotation, anchor);
        this._topRight = vec(worldPos.x + drawingWidth / 2, worldPos.y - drawingHeight / 2);
        this._topRight = this._topRight.rotate(rotation, anchor);
        this._bottomLeft = vec(worldPos.x - drawingWidth / 2, worldPos.y + drawingHeight / 2);
        this._bottomLeft = this._bottomLeft.rotate(rotation, anchor);
        this._bottomRight = vec(worldPos.x + drawingWidth / 2, worldPos.y + drawingHeight / 2);
        this._bottomRight = this._bottomRight.rotate(rotation, anchor);
        const topLeftScreen = engine.worldToScreenCoordinates(this._topLeft);
        const topRightScreen = engine.worldToScreenCoordinates(this._topRight);
        const bottomLeftScreen = engine.worldToScreenCoordinates(this._bottomLeft);
        const bottomRightScreen = engine.worldToScreenCoordinates(this._bottomRight);
        this._xCoords = [];
        this._yCoords = [];
        this._xCoords.push(topLeftScreen.x, topRightScreen.x, bottomLeftScreen.x, bottomRightScreen.x);
        this._yCoords.push(topLeftScreen.y, topRightScreen.y, bottomLeftScreen.y, bottomRightScreen.y);
        this._xMin = Math.min.apply(null, this._xCoords);
        this._yMin = Math.min.apply(null, this._yCoords);
        this._xMax = Math.max.apply(null, this._xCoords);
        this._yMax = Math.max.apply(null, this._yCoords);
        const minWorld = engine.screenToWorldCoordinates(new Vector(this._xMin, this._yMin));
        const maxWorld = engine.screenToWorldCoordinates(new Vector(this._xMax, this._yMax));
        this._xMinWorld = minWorld.x;
        this._yMinWorld = minWorld.y;
        this._xMaxWorld = maxWorld.x;
        this._yMaxWorld = maxWorld.y;
        const boundingPoints = [
            new Vector(this._xMin, this._yMin),
            new Vector(this._xMax, this._yMin),
            new Vector(this._xMin, this._yMax),
            new Vector(this._xMax, this._yMax) // bottom right
        ];
        // sprite can be wider than canvas screen (and still visible within canvas)
        // top or bottom of sprite must be within canvas
        if (boundingPoints[0].x < 0 &&
            boundingPoints[1].x > engine.canvas.clientWidth &&
            (boundingPoints[0].y > 0 || boundingPoints[2].y < engine.canvas.clientHeight)) {
            return false;
        }
        // sprite can be taller than canvas screen (and still visible within canvas)
        // left or right of sprite must be within canvas
        if (boundingPoints[0].y < 0 &&
            boundingPoints[2].y > engine.canvas.clientHeight &&
            (boundingPoints[1].x > 0 || boundingPoints[0].x < engine.canvas.clientWidth)) {
            return false;
        }
        // otherwise if any corner is visible, we're not offscreen
        for (let i = 0; i < boundingPoints.length; i++) {
            if (boundingPoints[i].x > 0 &&
                boundingPoints[i].y > 0 &&
                boundingPoints[i].x < engine.canvas.clientWidth &&
                boundingPoints[i].y < engine.canvas.clientHeight) {
                return false;
            }
        }
        return true;
    }
    debugDraw(ctx) {
        // bounding rectangle
        ctx.beginPath();
        ctx.strokeStyle = Color.White.toString();
        ctx.rect(this._xMinWorld, this._yMinWorld, this._xMaxWorld - this._xMinWorld, this._yMaxWorld - this._yMinWorld);
        ctx.stroke();
        ctx.fillStyle = Color.Red.toString();
        ctx.beginPath();
        ctx.arc(this._topLeft.x, this._topLeft.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = Color.Green.toString();
        ctx.beginPath();
        ctx.arc(this._topRight.x, this._topRight.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = Color.Blue.toString();
        ctx.beginPath();
        ctx.arc(this._bottomLeft.x, this._bottomLeft.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = Color.Magenta.toString();
        ctx.beginPath();
        ctx.arc(this._bottomRight.x, this._bottomRight.y, 5, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
    }
}

;// CONCATENATED MODULE: ./Traits/OffscreenCulling.ts



/**
 * @deprecated will be removed in 0.26.0
 */
class OffscreenCulling {
    constructor() {
        this.cullingBox = new CullingBox();
    }
    update(actor, engine) {
        const events = actor.eventDispatcher;
        let isSpriteOffScreen = true;
        if (actor.currentDrawing != null) {
            isSpriteOffScreen = this.cullingBox.isSpriteOffScreen(actor, engine);
        }
        let actorBoundsOffscreen = false;
        if (engine && engine.currentScene && engine.currentScene.camera && engine.currentScene.camera.viewport && !actor.parent) {
            actorBoundsOffscreen = !engine.currentScene.camera.viewport.intersect(actor.collider.bounds);
        }
        if (!actor.isOffScreen) {
            if (actorBoundsOffscreen && isSpriteOffScreen) {
                events.emit('exitviewport', new ExitViewPortEvent(actor));
                actor.addComponent(new TagComponent('offscreen'));
            }
        }
        else {
            if (!actorBoundsOffscreen || !isSpriteOffScreen) {
                events.emit('enterviewport', new EnterViewPortEvent(actor));
                actor.removeComponent('offscreen');
            }
        }
    }
}

;// CONCATENATED MODULE: ./Traits/CapturePointer.ts
/**
 * Revises pointer events path accordingly to the actor
 * @deprecated Will be removed in 0.26.0
 */
class CapturePointer {
    update(actor, engine) {
        if (!actor.enableCapturePointer) {
            return;
        }
        if (actor.isKilled()) {
            return;
        }
        engine.input.pointers.checkAndUpdateActorUnderPointer(actor);
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Entity.ts





/**
 * AddedComponent message
 */
class AddedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Added';
    }
}
/**
 * Type guard to know if message is f an Added Component
 */
function isAddedComponent(x) {
    return !!x && x.type === 'Component Added';
}
/**
 * RemovedComponent message
 */
class RemovedComponent {
    constructor(data) {
        this.data = data;
        this.type = 'Component Removed';
    }
}
/**
 * Type guard to know if message is for a Removed Component
 */
function isRemovedComponent(x) {
    return !!x && x.type === 'Component Removed';
}
/**
 * An Entity is the base type of anything that can have behavior in Excalibur, they are part of the built in entity component system
 *
 * Entities can be strongly typed with the components they contain
 *
 * ```typescript
 * const entity = new Entity<ComponentA | ComponentB>();
 * entity.components.a; // Type ComponentA
 * entity.components.b; // Type ComponentB
 * ```
 */
class Entity extends Class {
    constructor(components, name) {
        super();
        /**
         * The unique identifier for the entity
         */
        this.id = Entity._ID++;
        this._name = 'anonymous';
        /**
         * Whether this entity is active, if set to false it will be reclaimed
         */
        this.active = true;
        /**
         * Bucket to hold on to deferred removals
         */
        this._componentsToRemove = [];
        this._componentTypeToInstance = new Map();
        this._componentStringToInstance = new Map();
        this._tagsMemo = [];
        this._typesMemo = [];
        /**
         * Observable that keeps track of component add or remove changes on the entity
         */
        this.componentAdded$ = new Observable();
        this.componentRemoved$ = new Observable();
        this._parent = null;
        this.childrenAdded$ = new Observable();
        this.childrenRemoved$ = new Observable();
        this._children = [];
        this._isInitialized = false;
        this._setName(name);
        if (components) {
            for (const component of components) {
                this.addComponent(component);
            }
        }
    }
    _setName(name) {
        if (name) {
            this._name = name;
        }
    }
    get name() {
        return this._name;
    }
    get events() {
        return this.eventDispatcher;
    }
    /**
     * Kill the entity, means it will no longer be updated. Kills are deferred to the end of the update.
     */
    kill() {
        this.active = false;
    }
    isKilled() {
        return !this.active;
    }
    /**
     * Specifically get the tags on the entity from [[TagComponent]]
     */
    get tags() {
        return this._tagsMemo;
    }
    /**
     * Check if a tag exists on the entity
     * @param tag name to check for
     */
    hasTag(tag) {
        return this.tags.includes(tag);
    }
    /**
     * Adds a tag to an entity
     * @param tag
     * @returns Entity
     */
    addTag(tag) {
        return this.addComponent(new TagComponent(tag));
    }
    /**
     * Removes a tag on the entity
     *
     * Removals are deferred until the end of update
     * @param tag
     * @param force Remove component immediately, no deferred
     */
    removeTag(tag, force = false) {
        return this.removeComponent(tag, force);
    }
    /**
     * The types of the components on the Entity
     */
    get types() {
        return this._typesMemo;
    }
    _rebuildMemos() {
        this._tagsMemo = Array.from(this._componentStringToInstance.values())
            .filter((c) => c instanceof TagComponent)
            .map((c) => c.type);
        this._typesMemo = Array.from(this._componentStringToInstance.keys());
    }
    getComponents() {
        return Array.from(this._componentStringToInstance.values());
    }
    _notifyAddComponent(component) {
        this._rebuildMemos();
        const added = new AddedComponent({
            component,
            entity: this
        });
        this.componentAdded$.notifyAll(added);
    }
    _notifyRemoveComponent(component) {
        const removed = new RemovedComponent({
            component,
            entity: this
        });
        this.componentRemoved$.notifyAll(removed);
        this._rebuildMemos();
    }
    get parent() {
        return this._parent;
    }
    /**
     * Get the direct children of this entity
     */
    get children() {
        return this._children;
    }
    /**
     * Unparents this entity, if there is a parent. Otherwise it does nothing.
     */
    unparent() {
        if (this._parent) {
            this._parent.removeChild(this);
            this._parent = null;
        }
    }
    /**
     * Adds an entity to be a child of this entity
     * @param entity
     */
    addChild(entity) {
        if (entity.parent === null) {
            if (this.getAncestors().includes(entity)) {
                throw new Error('Cycle detected, cannot add entity');
            }
            this._children.push(entity);
            entity._parent = this;
            this.childrenAdded$.notifyAll(entity);
        }
        else {
            throw new Error('Entity already has a parent, cannot add without unparenting');
        }
        return this;
    }
    /**
     * Remove an entity from children if it exists
     * @param entity
     */
    removeChild(entity) {
        if (entity.parent === this) {
            removeItemFromArray(entity, this._children);
            entity._parent = null;
            this.childrenRemoved$.notifyAll(entity);
        }
        return this;
    }
    /**
     * Removes all children from this entity
     */
    removeAllChildren() {
        this.children.forEach((c) => {
            this.removeChild(c);
        });
        return this;
    }
    /**
     * Returns a list of parent entities starting with the topmost parent. Includes the current entity.
     */
    getAncestors() {
        const result = [this];
        let current = this.parent;
        while (current) {
            result.push(current);
            current = current.parent;
        }
        return result.reverse();
    }
    /**
     * Returns a list of all the entities that descend from this entity. Includes the current entity.
     */
    getDescendants() {
        let result = [this];
        let queue = [this];
        while (queue.length > 0) {
            const curr = queue.pop();
            queue = queue.concat(curr.children);
            result = result.concat(curr.children);
        }
        return result;
    }
    /**
     * Creates a deep copy of the entity and a copy of all its components
     */
    clone() {
        const newEntity = new Entity();
        for (const c of this.types) {
            newEntity.addComponent(this.get(c).clone());
        }
        for (const child of this.children) {
            newEntity.addChild(child.clone());
        }
        return newEntity;
    }
    /**
     * Adds a copy of all the components from another template entity as a "prefab"
     * @param templateEntity Entity to use as a template
     * @param force Force component replacement if it aleady exists on the target entity
     */
    addTemplate(templateEntity, force = false) {
        for (const c of templateEntity.getComponents()) {
            this.addComponent(c.clone(), force);
        }
        for (const child of templateEntity.children) {
            this.addChild(child.clone().addTemplate(child));
        }
        return this;
    }
    /**
     * Adds a component to the entity
     * @param component Component or Entity to add copy of components from
     * @param force Optionally overwrite any existing components of the same type
     */
    addComponent(component, force = false) {
        // if component already exists, skip if not forced
        if (this.has(component.type)) {
            if (force) {
                // Remove existing component type if exists when forced
                this.removeComponent(component);
            }
            else {
                // early exit component exiss
                return this;
            }
        }
        // TODO circular dependencies will be a problem
        if (component.dependencies && component.dependencies.length) {
            for (const ctor of component.dependencies) {
                this.addComponent(new ctor());
            }
        }
        component.owner = this;
        const constuctorType = component.constructor;
        this._componentTypeToInstance.set(constuctorType, component);
        this._componentStringToInstance.set(component.type, component);
        if (component.onAdd) {
            component.onAdd(this);
        }
        this._notifyAddComponent(component);
        return this;
    }
    /**
     * Removes a component from the entity, by default removals are deferred to the end of entity update to avoid consistency issues
     *
     * Components can be force removed with the `force` flag, the removal is not deferred and happens immediately
     * @param componentOrType
     * @param force
     */
    removeComponent(componentOrType, force = false) {
        if (force) {
            if (typeof componentOrType === 'string') {
                this._removeComponentByType(componentOrType);
            }
            else if (componentOrType instanceof Component) {
                this._removeComponentByType(componentOrType.type);
            }
        }
        else {
            this._componentsToRemove.push(componentOrType);
        }
        return this;
    }
    _removeComponentByType(type) {
        if (this.has(type)) {
            const component = this.get(type);
            component.owner = null;
            if (component.onRemove) {
                component.onRemove(this);
            }
            const ctor = component.constructor;
            this._componentTypeToInstance.delete(ctor);
            this._componentStringToInstance.delete(component.type);
            this._notifyRemoveComponent(component);
        }
    }
    /**
     * @hidden
     * @internal
     */
    processComponentRemoval() {
        for (const componentOrType of this._componentsToRemove) {
            const type = typeof componentOrType === 'string' ? componentOrType : componentOrType.type;
            this._removeComponentByType(type);
        }
        this._componentsToRemove.length = 0;
    }
    has(type) {
        if (typeof type === 'string') {
            return this._componentStringToInstance.has(type);
        }
        else {
            return this._componentTypeToInstance.has(type);
        }
    }
    get(type) {
        if (typeof type === 'string') {
            return this._componentStringToInstance.get(type);
        }
        else {
            return this._componentTypeToInstance.get(type);
        }
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * Initializes this entity, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overriden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * `onInitialize` is called before the first update of the entity. This method is meant to be
     * overridden.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an entity is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an entity is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     *
     * Entity update lifecycle, called internally
     *
     * @internal
     * @param engine
     * @param delta
     */
    update(engine, delta) {
        this._initialize(engine);
        this._preupdate(engine, delta);
        for (const child of this.children) {
            child.update(engine, delta);
        }
        this._postupdate(engine, delta);
    }
}
Entity._ID = 0;

;// CONCATENATED MODULE: ./Drawing/CanvasDrawComponent.ts

/**
 * Shim to draw to the canvas when in LegacyDrawing mode
 * @deprecated
 */
class CanvasDrawComponent extends Component {
    constructor(draw) {
        var _a;
        super();
        this.draw = draw;
        this.type = 'ex.canvas';
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        this.draw = (_a = this.draw) !== null && _a !== void 0 ? _a : (() => { });
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsComponent.ts





/**
 * Type guard for checking if a Graphic HasTick (used for graphics that change over time like animations)
 * @param graphic
 */
function hasGraphicsTick(graphic) {
    return !!graphic.tick;
}
class GraphicsLayer {
    constructor(_options, _graphics) {
        this._options = _options;
        this._graphics = _graphics;
        this.graphics = [];
    }
    get name() {
        return this._options.name;
    }
    hide(nameOrGraphic) {
        if (!nameOrGraphic) {
            this.graphics.length = 0;
        }
        else {
            let gfx = null;
            if (nameOrGraphic instanceof Graphic) {
                gfx = nameOrGraphic;
            }
            else {
                gfx = this._graphics.getGraphic(nameOrGraphic);
            }
            this.graphics = this.graphics.filter((g) => g.graphic !== gfx);
        }
    }
    /**
     * Show a graphic by name or instance at an offset, graphics are shown in the order in which `show()` is called.
     *
     * If `show()` is called multiple times for the same graphic it will be shown multiple times.
     * @param nameOrGraphic
     * @param options
     */
    show(nameOrGraphic, options) {
        options = Object.assign({}, options);
        let gfx;
        if (nameOrGraphic instanceof Graphic) {
            gfx = this._graphics.copyGraphics ? nameOrGraphic.clone() : nameOrGraphic;
        }
        else {
            gfx = this._graphics.getGraphic(nameOrGraphic);
            if (!gfx) {
                Logger.getInstance().error(`No such graphic added to component named ${nameOrGraphic}. These named graphics are available: `, this._graphics.getNames());
            }
        }
        if (gfx) {
            this.graphics.push({ graphic: gfx, options });
            return gfx;
        }
        else {
            return null;
        }
    }
    /**
     * Use a specific graphic, swap out any current graphics being shown
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        options = Object.assign({}, options);
        this.hide();
        return this.show(nameOrGraphic, options);
    }
    /**
     * Current order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    get order() {
        return this._options.order;
    }
    /**
     * Set the order of the layer, higher numbers are on top, lower numbers are on the bottom.
     *
     * For example a layer with `order = -1` would be under a layer of `order = 1`
     */
    set order(order) {
        this._options.order = order;
    }
    /**
     * Get or set the pixel offset from the layer anchor for all graphics in the layer
     */
    get offset() {
        var _a;
        return (_a = this._options.offset) !== null && _a !== void 0 ? _a : Vector.Zero;
    }
    set offset(value) {
        this._options.offset = value;
    }
    get currentKeys() {
        var _a;
        return (_a = this.name) !== null && _a !== void 0 ? _a : 'anonymous';
    }
}
class GraphicsLayers {
    constructor(_component) {
        this._component = _component;
        this._layers = [];
        this._layerMap = {};
        this.default = new GraphicsLayer({ name: 'default', order: 0 }, _component);
        this._maybeAddLayer(this.default);
    }
    create(options) {
        const layer = new GraphicsLayer(options, this._component);
        return this._maybeAddLayer(layer);
    }
    get(name) {
        if (name) {
            return this._getLayer(name);
        }
        return this._layers;
    }
    currentKeys() {
        const graphicsLayerKeys = [];
        for (const layer of this._layers) {
            graphicsLayerKeys.push(layer.currentKeys);
        }
        return graphicsLayerKeys;
    }
    has(name) {
        return name in this._layerMap;
    }
    _maybeAddLayer(layer) {
        if (this._layerMap[layer.name]) {
            // todo log warning
            return this._layerMap[layer.name];
        }
        this._layerMap[layer.name] = layer;
        this._layers.push(layer);
        this._layers.sort((a, b) => a.order - b.order);
        return layer;
    }
    _getLayer(name) {
        return this._layerMap[name];
    }
}
/**
 * Component to manage drawings, using with the position component
 */
class GraphicsComponent extends Component {
    constructor(options) {
        super();
        this.type = 'ex.graphics';
        this._graphics = {};
        /**
         * Sets or gets wether any drawing should be visible in this component
         */
        this.visible = true;
        /**
         * Sets or gets wither all drawings should have an opacity applied
         */
        this.opacity = 1;
        /**
         * Offset to apply to graphics by default
         */
        this.offset = Vector.Zero;
        /**
         * Anchor to apply to graphics by default
         */
        this.anchor = Vector.Half;
        /**
         * If set to true graphics added to the component will be copied. This can affect performance
         */
        this.copyGraphics = false;
        this._bounds = null;
        // Defaults
        options = Object.assign({ visible: this.visible }, options);
        const { current, anchor, opacity, visible, graphics, offset, copyGraphics, onPreDraw, onPostDraw } = options;
        this._graphics = graphics || {};
        this.offset = offset !== null && offset !== void 0 ? offset : this.offset;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : this.anchor;
        this.copyGraphics = copyGraphics !== null && copyGraphics !== void 0 ? copyGraphics : this.copyGraphics;
        this.onPreDraw = onPreDraw !== null && onPreDraw !== void 0 ? onPreDraw : this.onPreDraw;
        this.onPostDraw = onPostDraw !== null && onPostDraw !== void 0 ? onPostDraw : this.onPostDraw;
        this.visible = !!visible;
        this.layers = new GraphicsLayers(this);
        if (current && this._graphics[current]) {
            this.show(this._graphics[current]);
        }
    }
    getGraphic(name) {
        return this._graphics[name];
    }
    /**
     * Get registered graphics names
     */
    getNames() {
        return Object.keys(this._graphics);
    }
    /**
     * Returns the currently displayed graphics and their offsets, empty array if hidden
     */
    get current() {
        return this.layers.default.graphics;
    }
    /**
     * Returns all graphics associated with this component
     */
    get graphics() {
        return this._graphics;
    }
    add(nameOrGraphic, graphic) {
        let name = 'default';
        let graphicToSet = null;
        if (typeof nameOrGraphic === 'string') {
            name = nameOrGraphic;
            graphicToSet = graphic;
        }
        else {
            graphicToSet = nameOrGraphic;
        }
        this._graphics[name] = this.copyGraphics ? graphicToSet.clone() : graphicToSet;
        if (name === 'default') {
            this.show('default');
        }
        return graphicToSet;
    }
    /**
     * Show a graphic by name on the **default** layer, returns the new [[Graphic]]
     */
    show(nameOrGraphic, options) {
        return this.layers.default.show(nameOrGraphic, options);
    }
    /**
     * Use a graphic only, swap out any graphics on the **default** layer, returns the new [[Graphic]]
     * @param nameOrGraphic
     * @param options
     */
    use(nameOrGraphic, options) {
        return this.layers.default.use(nameOrGraphic, options);
    }
    hide(nameOrGraphic) {
        this.layers.default.hide(nameOrGraphic);
    }
    set localBounds(bounds) {
        this._bounds = bounds;
    }
    get localBounds() {
        if (this._bounds) {
            return this._bounds;
        }
        let bb = new BoundingBox();
        for (const layer of this.layers.get()) {
            for (const { graphic, options } of layer.graphics) {
                let anchor = this.anchor;
                let offset = this.offset;
                if (options === null || options === void 0 ? void 0 : options.anchor) {
                    anchor = options.anchor;
                }
                if (options === null || options === void 0 ? void 0 : options.offset) {
                    offset = options.offset;
                }
                const bounds = graphic.localBounds;
                const offsetX = -bounds.width * graphic.scale.x * anchor.x + offset.x;
                const offsetY = -bounds.height * graphic.scale.y * anchor.y + offset.y;
                bb = graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(vec(offsetX + layer.offset.x, offsetY + layer.offset.y)).combine(bb);
            }
        }
        return bb;
    }
    /**
     * Update underlying graphics if necesary, called internally
     * @param elapsed
     * @internal
     */
    update(elapsed, idempotencyToken = 0) {
        for (const layer of this.layers.get()) {
            for (const { graphic } of layer.graphics) {
                if (hasGraphicsTick(graphic)) {
                    graphic === null || graphic === void 0 ? void 0 : graphic.tick(elapsed, idempotencyToken);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Rectangle.ts

/**
 * A Rectangle [[Graphic]] for drawing rectangles to the [[ExcaliburGraphicsContext]]
 */
class Rectangle extends Raster {
    constructor(options) {
        super(options);
        this.width = options.width;
        this.height = options.height;
        this.rasterize();
    }
    clone() {
        return new Rectangle(Object.assign(Object.assign({ width: this.width, height: this.height }, this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        if (this.color) {
            ctx.fillRect(0, 0, this.width, this.height);
        }
        if (this.strokeColor) {
            ctx.strokeRect(0, 0, this.width, this.height);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Circle.ts

/**
 * A circle [[Graphic]] for drawing circles to the [[ExcaliburGraphicsContext]]
 */
class Circle extends Raster {
    constructor(options) {
        var _a;
        super(options);
        this._radius = 0;
        this.padding = (_a = options.padding) !== null && _a !== void 0 ? _a : 2; // default 2 padding for circles looks nice
        this.radius = options.radius;
        this.rasterize();
    }
    get radius() {
        return this._radius;
    }
    set radius(value) {
        this._radius = value;
        this.width = this._radius * 2;
        this.height = this._radius * 2;
        this.flagDirty();
    }
    clone() {
        return new Circle(Object.assign(Object.assign({ radius: this.radius }, this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        if (this.radius > 0) {
            ctx.beginPath();
            ctx.arc(this.radius, this.radius, this.radius, 0, Math.PI * 2);
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}

;// CONCATENATED MODULE: ./Util/EasingFunctions.ts
var EasingFunctions_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Standard easing functions for motion in Excalibur, defined on a domain of [0, duration] and a range from [+startValue,+endValue]
 * Given a time, the function will return a value from positive startValue to positive endValue.
 *
 * ```js
 * function Linear (t) {
 *    return t * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInQuad (t) {
 *    return t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutQuad (t) {
 *    return t * (2 - t);
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutQuad (t) {
 *    return t < .5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
 * }
 *
 * // accelerating from zero velocity
 * function EaseInCubic (t) {
 *    return t * t * t;
 * }
 *
 * // decelerating to zero velocity
 * function EaseOutCubic (t) {
 *    return (--t) * t * t + 1;
 * }
 *
 * // acceleration until halfway, then deceleration
 * function EaseInOutCubic (t) {
 *    return t < .5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
 * }
 * ```
 */
class EasingFunctions {
    static CreateReversibleEasingFunction(easing) {
        return (time, start, end, duration) => {
            if (end < start) {
                return start - (easing(time, end, start, duration) - end);
            }
            else {
                return easing(time, start, end, duration);
            }
        };
    }
    static CreateReversableEasingFunction(easing) {
        return EasingFunctions.CreateReversibleEasingFunction(easing);
    }
    static CreateVectorEasingFunction(easing) {
        return (time, start, end, duration) => {
            return new Vector(easing(time, start.x, end.x, duration), easing(time, start.y, end.y, duration));
        };
    }
}
EasingFunctions.Linear = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    return (endValue * currentTime) / duration + startValue;
});
EasingFunctions.EaseInQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return -endValue * currentTime * (currentTime - 2) + startValue;
});
EasingFunctions.EaseInOutQuad = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime + startValue;
    }
    currentTime--;
    return (-endValue / 2) * (currentTime * (currentTime - 2) - 1) + startValue;
});
EasingFunctions.EaseInCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    return endValue * currentTime * currentTime * currentTime + startValue;
});
EasingFunctions.EaseOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration;
    currentTime--;
    return endValue * (currentTime * currentTime * currentTime + 1) + startValue;
});
EasingFunctions.EaseInOutCubic = EasingFunctions.CreateReversibleEasingFunction((currentTime, startValue, endValue, duration) => {
    endValue = endValue - startValue;
    currentTime /= duration / 2;
    if (currentTime < 1) {
        return (endValue / 2) * currentTime * currentTime * currentTime + startValue;
    }
    currentTime -= 2;
    return (endValue / 2) * (currentTime * currentTime * currentTime + 2) + startValue;
});
EasingFunctions_decorate([
    obsolete({
        message: 'Alias for incorrect spelling used in older versions, will be removed in v0.25.0',
        alternateMethod: 'CreateReversibleEasingFunction'
    })
], EasingFunctions, "CreateReversableEasingFunction", null);

;// CONCATENATED MODULE: ./Actions/ActionQueue.ts
/**
 * Action Queues represent an ordered sequence of actions
 *
 * Action queues are part of the [[ActionContext|Action API]] and
 * store the list of actions to be executed for an [[Actor]].
 *
 * Actors implement [[Actor.actions]] which can be manipulated by
 * advanced users to adjust the actions currently being executed in the
 * queue.
 */
class ActionQueue {
    constructor(entity) {
        this._actions = [];
        this._completedActions = [];
        this._entity = entity;
    }
    /**
     * Add an action to the sequence
     * @param action
     */
    add(action) {
        this._actions.push(action);
    }
    /**
     * Remove an action by reference from the sequence
     * @param action
     */
    remove(action) {
        const index = this._actions.indexOf(action);
        this._actions.splice(index, 1);
    }
    /**
     * Removes all actions from this sequence
     */
    clearActions() {
        this._actions.length = 0;
        this._completedActions.length = 0;
        if (this._currentAction) {
            this._currentAction.stop();
        }
    }
    /**
     *
     * @returns The total list of actions in this sequence complete or not
     */
    getActions() {
        return this._actions.concat(this._completedActions);
    }
    /**
     *
     * @returns `true` if there are more actions to process in the sequence
     */
    hasNext() {
        return this._actions.length > 0;
    }
    /**
     * @returns `true` if the current sequence of actions is done
     */
    isComplete() {
        return this._actions.length === 0;
    }
    /**
     * Resets the sequence of actions, this is used to restart a sequence from the beginning
     */
    reset() {
        this._actions = this.getActions();
        const len = this._actions.length;
        for (let i = 0; i < len; i++) {
            this._actions[i].reset();
        }
        this._completedActions = [];
    }
    /**
     * Update the queue which updates actions and handles completing actions
     * @param elapsedMs
     */
    update(elapsedMs) {
        if (this._actions.length > 0) {
            this._currentAction = this._actions[0];
            this._currentAction.update(elapsedMs);
            if (this._currentAction.isComplete(this._entity)) {
                this._completedActions.push(this._actions.shift());
            }
        }
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Repeat.ts

class Repeat {
    constructor(entity, repeatBuilder, repeat) {
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeat = repeat;
        this._originalRepeat = repeat;
        this._repeatBuilder(this._repeatContext);
        this._repeat--; // current execution is the first repeat
    }
    update(delta) {
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
            this._repeat--;
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped || (this._repeat <= 0 && this._actionQueue.isComplete());
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._repeat = this._originalRepeat;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/RepeatForever.ts

/**
 * RepeatForever Action implementation, it is recommended you use the fluent action
 * context API.
 *
 *
 */
class RepeatForever {
    constructor(entity, repeatBuilder) {
        this._stopped = false;
        this._repeatBuilder = repeatBuilder;
        this._repeatContext = new ActionContext(entity);
        this._actionQueue = this._repeatContext.getQueue();
        this._repeatBuilder(this._repeatContext);
    }
    update(delta) {
        if (this._stopped) {
            return;
        }
        if (this._actionQueue.isComplete()) {
            this._actionQueue.clearActions();
            this._repeatBuilder(this._repeatContext);
        }
        this._actionQueue.update(delta);
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        this._stopped = true;
        this._actionQueue.clearActions();
    }
    reset() {
        return;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/MoveBy.ts




class MoveBy {
    constructor(entity, offsetX, offsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._entity = entity;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._speed = speed;
        this._offset = new Vector(offsetX, offsetY);
        if (speed <= 0) {
            Logger.getInstance().error('Attempted to moveBy with speed less than or equal to zero : ' + speed);
            throw new Error('Speed must be greater than 0 pixels per second');
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
            this._end = this._start.add(this._offset);
            this._distance = this._offset.size;
            this._dir = this._end.sub(this._start).normalize();
        }
        if (this.isComplete(this._entity)) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
        else {
            this._motion.vel = this._dir.scale(this._speed);
        }
    }
    isComplete(entity) {
        const tx = entity.get(TransformComponent);
        return this._stopped || tx.pos.distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/MoveTo.ts



class MoveTo {
    constructor(entity, destx, desty, speed) {
        this.entity = entity;
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._end = new Vector(destx, desty);
        this._speed = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = new Vector(this._tx.pos.x, this._tx.pos.y);
            this._distance = this._start.distance(this._end);
            this._dir = this._end.sub(this._start).normalize();
        }
        const m = this._dir.scale(this._speed);
        this._motion.vel = vec(m.x, m.y);
        if (this.isComplete(this.entity)) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    isComplete(entity) {
        const tx = entity.get(TransformComponent);
        return this._stopped || new Vector(tx.pos.x, tx.pos.y).distance(this._start) >= this._distance;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/RotationType.ts
/**
 * An enum that describes the strategies that rotation actions can use
 */
var RotationType;
(function (RotationType) {
    /**
     * Rotation via `ShortestPath` will use the smallest angle
     * between the starting and ending points. This strategy is the default behavior.
     */
    RotationType[RotationType["ShortestPath"] = 0] = "ShortestPath";
    /**
     * Rotation via `LongestPath` will use the largest angle
     * between the starting and ending points.
     */
    RotationType[RotationType["LongestPath"] = 1] = "LongestPath";
    /**
     * Rotation via `Clockwise` will travel in a clockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["Clockwise"] = 2] = "Clockwise";
    /**
     * Rotation via `CounterClockwise` will travel in a counterclockwise direction,
     * regardless of the starting and ending points.
     */
    RotationType[RotationType["CounterClockwise"] = 3] = "CounterClockwise";
})(RotationType || (RotationType = {}));

;// CONCATENATED MODULE: ./Actions/Action/RotateTo.ts




class RotateTo {
    constructor(entity, angleRadians, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._end = angleRadians;
        this._speed = speed;
        this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
            switch (this._rotationType) {
                case RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case RotationType.CounterClockwise:
                    this._direction = -1;
                    if (!this._shortestPathIsPositive) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTravelled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTravelled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/RotateBy.ts




class RotateBy {
    constructor(entity, angleRadiansOffset, speed, rotationType) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._speed = speed;
        this._offset = angleRadiansOffset;
        this._rotationType = rotationType || RotationType.ShortestPath;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._start = this._tx.rotation;
            this._currentNonCannonAngle = this._tx.rotation;
            this._end = this._start + this._offset;
            const distance1 = Math.abs(this._end - this._start);
            const distance2 = TwoPI - distance1;
            if (distance1 > distance2) {
                this._shortDistance = distance2;
                this._longDistance = distance1;
            }
            else {
                this._shortDistance = distance1;
                this._longDistance = distance2;
            }
            this._shortestPathIsPositive = (this._start - this._end + TwoPI) % TwoPI >= Math.PI;
            switch (this._rotationType) {
                case RotationType.ShortestPath:
                    this._distance = this._shortDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = 1;
                    }
                    else {
                        this._direction = -1;
                    }
                    break;
                case RotationType.LongestPath:
                    this._distance = this._longDistance;
                    if (this._shortestPathIsPositive) {
                        this._direction = -1;
                    }
                    else {
                        this._direction = 1;
                    }
                    break;
                case RotationType.Clockwise:
                    this._direction = 1;
                    if (this._shortDistance >= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
                case RotationType.CounterClockwise:
                    this._direction = -1;
                    if (this._shortDistance <= 0) {
                        this._distance = this._shortDistance;
                    }
                    else {
                        this._distance = this._longDistance;
                    }
                    break;
            }
        }
        this._motion.angularVelocity = this._direction * this._speed;
        this._currentNonCannonAngle += this._direction * this._speed * (_delta / 1000);
        if (this.isComplete()) {
            this._tx.rotation = this._end;
            this._motion.angularVelocity = 0;
            this._stopped = true;
        }
    }
    isComplete() {
        const distanceTravelled = Math.abs(this._currentNonCannonAngle - this._start);
        return this._stopped || distanceTravelled >= Math.abs(this._distance);
    }
    stop() {
        this._motion.angularVelocity = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ScaleTo.ts



class ScaleTo {
    constructor(entity, scaleX, scaleY, speedX, speedY) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._endX = scaleX;
        this._endY = scaleY;
        this._speedX = speedX;
        this._speedY = speedY;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startX = this._tx.scale.x;
            this._startY = this._tx.scale.y;
            this._distanceX = Math.abs(this._endX - this._startX);
            this._distanceY = Math.abs(this._endY - this._startY);
        }
        if (!(Math.abs(this._tx.scale.x - this._startX) >= this._distanceX)) {
            const directionX = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.x = this._speedX * directionX;
        }
        else {
            this._motion.scaleFactor.x = 0;
        }
        if (!(Math.abs(this._tx.scale.y - this._startY) >= this._distanceY)) {
            const directionY = this._endY < this._startY ? -1 : 1;
            this._motion.scaleFactor.y = this._speedY * directionY;
        }
        else {
            this._motion.scaleFactor.y = 0;
        }
        if (this.isComplete()) {
            this._tx.scale = vec(this._endX, this._endY);
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.y - this._startX) >= this._distanceX && Math.abs(this._tx.scale.y - this._startY) >= this._distanceY));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/ScaleBy.ts



class ScaleBy {
    constructor(entity, scaleOffsetX, scaleOffsetY, speed) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._offset = new Vector(scaleOffsetX, scaleOffsetY);
        this._speedX = this._speedY = speed;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._startScale = this._tx.scale.clone();
            this._endScale = this._startScale.add(this._offset);
            this._distanceX = Math.abs(this._endScale.x - this._startScale.x);
            this._distanceY = Math.abs(this._endScale.y - this._startScale.y);
            this._directionX = this._endScale.x < this._startScale.x ? -1 : 1;
            this._directionY = this._endScale.y < this._startScale.y ? -1 : 1;
        }
        this._motion.scaleFactor.x = this._speedX * this._directionX;
        this._motion.scaleFactor.y = this._speedY * this._directionY;
        if (this.isComplete()) {
            this._tx.scale = this._endScale;
            this._motion.scaleFactor.x = 0;
            this._motion.scaleFactor.y = 0;
        }
    }
    isComplete() {
        return (this._stopped ||
            (Math.abs(this._tx.scale.x - this._startScale.x) >= this._distanceX &&
                Math.abs(this._tx.scale.y - this._startScale.y) >= this._distanceY));
    }
    stop() {
        this._motion.scaleFactor.x = 0;
        this._motion.scaleFactor.y = 0;
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/CallMethod.ts
class CallMethod {
    constructor(method) {
        this._method = null;
        this._hasBeenCalled = false;
        this._method = method;
    }
    update(_delta) {
        this._method();
        this._hasBeenCalled = true;
    }
    isComplete() {
        return this._hasBeenCalled;
    }
    reset() {
        this._hasBeenCalled = false;
    }
    stop() {
        this._hasBeenCalled = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/EaseTo.ts



class EaseTo {
    constructor(entity, x, y, duration, easingFcn) {
        this.easingFcn = easingFcn;
        this._currentLerpTime = 0;
        this._lerpDuration = 1 * 1000; // 1 second
        this._lerpStart = new Vector(0, 0);
        this._lerpEnd = new Vector(0, 0);
        this._initialized = false;
        this._stopped = false;
        this._distance = 0;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._lerpDuration = duration;
        this._lerpEnd = new Vector(x, y);
    }
    _initialize() {
        this._lerpStart = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._currentLerpTime = 0;
        this._distance = this._lerpStart.distance(this._lerpEnd);
    }
    update(delta) {
        if (!this._initialized) {
            this._initialize();
            this._initialized = true;
        }
        // Need to update lerp time first, otherwise the first update will always be zero
        this._currentLerpTime += delta;
        let newX = this._tx.pos.x;
        let newY = this._tx.pos.y;
        if (this._currentLerpTime < this._lerpDuration) {
            if (this._lerpEnd.x < this._lerpStart.x) {
                newX =
                    this._lerpStart.x -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.x, this._lerpStart.x, this._lerpDuration) - this._lerpEnd.x);
            }
            else {
                newX = this.easingFcn(this._currentLerpTime, this._lerpStart.x, this._lerpEnd.x, this._lerpDuration);
            }
            if (this._lerpEnd.y < this._lerpStart.y) {
                newY =
                    this._lerpStart.y -
                        (this.easingFcn(this._currentLerpTime, this._lerpEnd.y, this._lerpStart.y, this._lerpDuration) - this._lerpEnd.y);
            }
            else {
                newY = this.easingFcn(this._currentLerpTime, this._lerpStart.y, this._lerpEnd.y, this._lerpDuration);
            }
            // Given the lerp position figure out the velocity in pixels per second
            this._motion.vel = vec((newX - this._tx.pos.x) / (delta / 1000), (newY - this._tx.pos.y) / (delta / 1000));
        }
        else {
            this._tx.pos = vec(this._lerpEnd.x, this._lerpEnd.y);
            this._motion.vel = Vector.Zero;
        }
    }
    isComplete(actor) {
        return this._stopped || new Vector(actor.pos.x, actor.pos.y).distance(this._lerpStart) >= this._distance;
    }
    reset() {
        this._initialized = false;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Blink.ts

class Blink {
    constructor(entity, timeVisible, timeNotVisible, numBlinks = 1) {
        this._timeVisible = 0;
        this._timeNotVisible = 0;
        this._elapsedTime = 0;
        this._totalTime = 0;
        this._stopped = false;
        this._started = false;
        this._graphics = entity.get(GraphicsComponent);
        this._timeVisible = timeVisible;
        this._timeNotVisible = timeNotVisible;
        this._duration = (timeVisible + timeNotVisible) * numBlinks;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
        }
        if (!this._graphics) {
            return;
        }
        this._elapsedTime += delta;
        this._totalTime += delta;
        if (this._graphics.visible && this._elapsedTime >= this._timeVisible) {
            this._graphics.visible = false;
            this._elapsedTime = 0;
        }
        if (!this._graphics.visible && this._elapsedTime >= this._timeNotVisible) {
            this._graphics.visible = true;
            this._elapsedTime = 0;
        }
        if (this.isComplete()) {
            this._graphics.visible = true;
        }
    }
    isComplete() {
        return this._stopped || this._totalTime >= this._duration;
    }
    stop() {
        if (this._graphics) {
            this._graphics.visible = true;
        }
        this._stopped = true;
    }
    reset() {
        this._started = false;
        this._elapsedTime = 0;
        this._totalTime = 0;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Fade.ts


class Fade {
    constructor(entity, endOpacity, speed) {
        this._multiplier = 1;
        this._started = false;
        this._stopped = false;
        this._graphics = entity.get(GraphicsComponent);
        this._endOpacity = endOpacity;
        this._speed = speed;
    }
    update(delta) {
        if (!this._graphics) {
            return;
        }
        if (!this._started) {
            this._started = true;
            // determine direction when we start
            if (this._endOpacity < this._graphics.opacity) {
                this._multiplier = -1;
            }
            else {
                this._multiplier = 1;
            }
        }
        if (this._speed > 0) {
            this._graphics.opacity += (this._multiplier *
                (Math.abs(this._graphics.opacity - this._endOpacity) * delta)) / this._speed;
        }
        this._speed -= delta;
        if (this.isComplete()) {
            this._graphics.opacity = this._endOpacity;
        }
        Logger.getInstance().debug('[Action fade] Actor opacity:', this._graphics.opacity);
    }
    isComplete() {
        return this._stopped || Math.abs(this._graphics.opacity - this._endOpacity) < 0.05;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Delay.ts
class Delay {
    constructor(delay) {
        this._elapsedTime = 0;
        this._started = false;
        this._stopped = false;
        this._delay = delay;
    }
    update(delta) {
        if (!this._started) {
            this._started = true;
        }
        this._elapsedTime += delta;
    }
    isComplete() {
        return this._stopped || this._elapsedTime >= this._delay;
    }
    stop() {
        this._stopped = true;
    }
    reset() {
        this._elapsedTime = 0;
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Die.ts

class Die {
    constructor(entity) {
        this._stopped = false;
        this._entity = entity;
    }
    update(_delta) {
        this._entity.get(ActionsComponent).clearActions();
        this._entity.kill();
        this._stopped = true;
    }
    isComplete() {
        return this._stopped;
    }
    stop() {
        return;
    }
    reset() {
        return;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Follow.ts



class Follow {
    constructor(entity, entityToFollow, followDistance) {
        this._started = false;
        this._stopped = false;
        this._tx = entity.get(TransformComponent);
        this._motion = entity.get(MotionComponent);
        this._followTx = entityToFollow.get(TransformComponent);
        this._followMotion = entityToFollow.get(MotionComponent);
        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new Vector(this._followTx.pos.x, this._followTx.pos.y);
        this._maximumDistance = followDistance !== undefined ? followDistance : this._current.distance(this._end);
        this._speed = 0;
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToFollowSpeed = Math.sqrt(Math.pow(this._followMotion.vel.x, 2) + Math.pow(this._followMotion.vel.y, 2));
        if (actorToFollowSpeed !== 0) {
            this._speed = actorToFollowSpeed;
        }
        this._current = vec(this._tx.pos.x, this._tx.pos.y);
        this._end = vec(this._followTx.pos.x, this._followTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        if (this._distanceBetween >= this._maximumDistance) {
            const m = this._dir.scale(this._speed);
            this._motion.vel = vec(m.x, m.y);
        }
        else {
            this._motion.vel = vec(0, 0);
        }
        if (this.isComplete()) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    isComplete() {
        // the actor following should never stop unless specified to do so
        return this._stopped;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/Action/Meet.ts



class Meet {
    constructor(actor, actorToMeet, speed) {
        this._started = false;
        this._stopped = false;
        this._speedWasSpecified = false;
        this._tx = actor.get(TransformComponent);
        this._motion = actor.get(MotionComponent);
        this._meetTx = actorToMeet.get(TransformComponent);
        this._meetMotion = actorToMeet.get(MotionComponent);
        this._current = new Vector(this._tx.pos.x, this._tx.pos.y);
        this._end = new Vector(this._meetTx.pos.x, this._meetTx.pos.y);
        this._speed = speed || 0;
        if (speed !== undefined) {
            this._speedWasSpecified = true;
        }
    }
    update(_delta) {
        if (!this._started) {
            this._started = true;
            this._distanceBetween = this._current.distance(this._end);
            this._dir = this._end.sub(this._current).normalize();
        }
        const actorToMeetSpeed = Math.sqrt(Math.pow(this._meetMotion.vel.x, 2) + Math.pow(this._meetMotion.vel.y, 2));
        if (actorToMeetSpeed !== 0 && !this._speedWasSpecified) {
            this._speed = actorToMeetSpeed;
        }
        this._current = vec(this._tx.pos.x, this._tx.pos.y);
        this._end = vec(this._meetTx.pos.x, this._meetTx.pos.y);
        this._distanceBetween = this._current.distance(this._end);
        this._dir = this._end.sub(this._current).normalize();
        const m = this._dir.scale(this._speed);
        this._motion.vel = vec(m.x, m.y);
        if (this.isComplete()) {
            this._tx.pos = vec(this._end.x, this._end.y);
            this._motion.vel = vec(0, 0);
        }
    }
    isComplete() {
        return this._stopped || this._distanceBetween <= 1;
    }
    stop() {
        this._motion.vel = vec(0, 0);
        this._stopped = true;
    }
    reset() {
        this._started = false;
    }
}

;// CONCATENATED MODULE: ./Actions/ActionContext.ts



















/**
 * The fluent Action API allows you to perform "actions" on
 * [[Actor|Actors]] such as following, moving, rotating, and
 * more. You can implement your own actions by implementing
 * the [[Action]] interface.
 */
class ActionContext {
    constructor(entity) {
        this._entity = entity;
        this._queue = new ActionQueue(entity);
    }
    getQueue() {
        return this._queue;
    }
    update(elapsedMs) {
        this._queue.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        this._queue.clearActions();
    }
    easeTo(...args) {
        var _a, _b;
        let x = 0;
        let y = 0;
        let duration = 0;
        let easingFcn = EasingFunctions.Linear;
        if (args[0] instanceof Vector) {
            x = args[0].x;
            y = args[0].y;
            duration = args[1];
            easingFcn = (_a = args[2]) !== null && _a !== void 0 ? _a : easingFcn;
        }
        else {
            x = args[0];
            y = args[1];
            duration = args[2];
            easingFcn = (_b = args[3]) !== null && _b !== void 0 ? _b : easingFcn;
        }
        this._queue.add(new EaseTo(this._entity, x, y, duration, easingFcn));
        return this;
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
        let x = 0;
        let y = 0;
        let speed = 0;
        if (xOrPos instanceof Vector) {
            x = xOrPos.x;
            y = xOrPos.y;
            speed = yOrSpeed;
        }
        else {
            x = xOrPos;
            y = yOrSpeed;
            speed = speedOrUndefined;
        }
        this._queue.add(new MoveTo(this._entity, x, y, speed));
        return this;
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
        let xOffset = 0;
        let yOffset = 0;
        let speed = 0;
        if (xOffsetOrVector instanceof Vector) {
            xOffset = xOffsetOrVector.x;
            yOffset = xOffsetOrVector.y;
            speed = yOffsetOrSpeed;
        }
        else {
            xOffset = xOffsetOrVector;
            yOffset = yOffsetOrSpeed;
            speed = speedOrUndefined;
        }
        this._queue.add(new MoveBy(this._entity, xOffset, yOffset, speed));
        return this;
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
        this._queue.add(new RotateTo(this._entity, angleRadians, speed, rotationType));
        return this;
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
        this._queue.add(new RotateBy(this._entity, angleRadiansOffset, speed, rotationType));
        return this;
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        let sizeX = 1;
        let sizeY = 1;
        let speedX = 0;
        let speedY = 0;
        if (sizeXOrVector instanceof Vector && sizeYOrSpeed instanceof Vector) {
            sizeX = sizeXOrVector.x;
            sizeY = sizeXOrVector.y;
            speedX = sizeYOrSpeed.x;
            speedY = sizeYOrSpeed.y;
        }
        if (typeof sizeXOrVector === 'number' && typeof sizeYOrSpeed === 'number') {
            sizeX = sizeXOrVector;
            sizeY = sizeYOrSpeed;
            speedX = speedXOrUndefined;
            speedY = speedYOrUndefined;
        }
        this._queue.add(new ScaleTo(this._entity, sizeX, sizeY, speedX, speedY));
        return this;
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
        let sizeOffsetX = 1;
        let sizeOffsetY = 1;
        if (sizeOffsetXOrVector instanceof Vector) {
            sizeOffsetX = sizeOffsetXOrVector.x;
            sizeOffsetY = sizeOffsetXOrVector.y;
            speed = sizeOffsetYOrSpeed;
        }
        if (typeof sizeOffsetXOrVector === 'number' && typeof sizeOffsetYOrSpeed === 'number') {
            sizeOffsetX = sizeOffsetXOrVector;
            sizeOffsetY = sizeOffsetYOrSpeed;
        }
        this._queue.add(new ScaleBy(this._entity, sizeOffsetX, sizeOffsetY, speed));
        return this;
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks = 1) {
        this._queue.add(new Blink(this._entity, timeVisible, timeNotVisible, numBlinks));
        return this;
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
        this._queue.add(new Fade(this._entity, opacity, time));
        return this;
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
        this._queue.add(new Delay(time));
        return this;
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        this._queue.add(new Die(this._entity));
        return this;
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        this._queue.add(new CallMethod(method));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        if (!times) {
            this.repeatForever(repeatBuilder);
            return this;
        }
        this._queue.add(new Repeat(this._entity, repeatBuilder, times));
        return this;
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        this._queue.add(new RepeatForever(this._entity, repeatBuilder));
        return this;
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        if (followDistance === undefined) {
            this._queue.add(new Follow(this._entity, entity));
        }
        else {
            this._queue.add(new Follow(this._entity, entity, followDistance));
        }
        return this;
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        if (speed === undefined) {
            this._queue.add(new Meet(this._entity, entity));
        }
        else {
            this._queue.add(new Meet(this._entity, entity, speed));
        }
        return this;
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     * @deprecated Use `toPromise()` will be removed in v0.26.0
     */
    asPromise() {
        return this.toPromise();
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        const temp = new Promise((resolve) => {
            this._queue.add(new CallMethod(() => {
                resolve();
            }));
        });
        return temp;
    }
}

;// CONCATENATED MODULE: ./Actions/ActionsComponent.ts




;
class ActionsComponent extends Component {
    constructor() {
        super(...arguments);
        this.type = 'ex.actions';
        this.dependencies = [TransformComponent, MotionComponent];
    }
    onAdd(entity) {
        this._ctx = new ActionContext(entity);
    }
    onRemove() {
        this._ctx = null;
    }
    /**
     * Returns the internal action queue
     * @returns action queu
     */
    getQueue() {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.getQueue();
    }
    /**
     * Updates the internal action context, performing action and moving through the internal queue
     * @param elapsedMs
     */
    update(elapsedMs) {
        var _a;
        return (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.update(elapsedMs);
    }
    /**
     * Clears all queued actions from the Actor
     */
    clearActions() {
        var _a;
        (_a = this._ctx) === null || _a === void 0 ? void 0 : _a.clearActions();
    }
    easeTo(...args) {
        return this._ctx.easeTo.apply(this._ctx, args);
    }
    moveTo(xOrPos, yOrSpeed, speedOrUndefined) {
        return this._ctx.moveTo.apply(this._ctx, [xOrPos, yOrSpeed, speedOrUndefined]);
    }
    moveBy(xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined) {
        return this._ctx.moveBy.apply(this._ctx, [xOffsetOrVector, yOffsetOrSpeed, speedOrUndefined]);
    }
    /**
     * This method will rotate an actor to the specified angle at the speed
     * specified (in radians per second) and return back the actor. This
     * method is part of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadians  The angle to rotate to in radians
     * @param speed         The angular velocity of the rotation specified in radians per second
     * @param rotationType  The [[RotationType]] to use for this rotation
     */
    rotateTo(angleRadians, speed, rotationType) {
        return this._ctx.rotateTo(angleRadians, speed, rotationType);
    }
    /**
     * This method will rotate an actor by the specified angle offset, from it's current rotation given a certain speed
     * in radians/sec and return back the actor. This method is part
     * of the actor 'Action' fluent API allowing action chaining.
     * @param angleRadiansOffset  The angle to rotate to in radians relative to the current rotation
     * @param speed          The speed in radians/sec the actor should rotate at
     * @param rotationType  The [[RotationType]] to use for this rotation, default is shortest path
     */
    rotateBy(angleRadiansOffset, speed, rotationType) {
        return this._ctx.rotateBy(angleRadiansOffset, speed, rotationType);
    }
    scaleTo(sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined) {
        return this._ctx.scaleTo.apply(this._ctx, [sizeXOrVector, sizeYOrSpeed, speedXOrUndefined, speedYOrUndefined]);
    }
    scaleBy(sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed) {
        return this._ctx.scaleBy.apply(this._ctx, [sizeOffsetXOrVector, sizeOffsetYOrSpeed, speed]);
    }
    /**
     * This method will cause an actor to blink (become visible and not
     * visible). Optionally, you may specify the number of blinks. Specify the amount of time
     * the actor should be visible per blink, and the amount of time not visible.
     * This method is part of the actor 'Action' fluent API allowing action chaining.
     * @param timeVisible     The amount of time to stay visible per blink in milliseconds
     * @param timeNotVisible  The amount of time to stay not visible per blink in milliseconds
     * @param numBlinks       The number of times to blink
     */
    blink(timeVisible, timeNotVisible, numBlinks) {
        return this._ctx.blink(timeVisible, timeNotVisible, numBlinks);
    }
    /**
     * This method will cause an actor's opacity to change from its current value
     * to the provided value by a specified time (in milliseconds). This method is
     * part of the actor 'Action' fluent API allowing action chaining.
     * @param opacity  The ending opacity
     * @param time     The time it should take to fade the actor (in milliseconds)
     */
    fade(opacity, time) {
        return this._ctx.fade(opacity, time);
    }
    /**
     * This method will delay the next action from executing for a certain
     * amount of time (in milliseconds). This method is part of the actor
     * 'Action' fluent API allowing action chaining.
     * @param time  The amount of time to delay the next action in the queue from executing in milliseconds
     */
    delay(time) {
        return this._ctx.delay(time);
    }
    /**
     * This method will add an action to the queue that will remove the actor from the
     * scene once it has completed its previous  Any actions on the
     * action queue after this action will not be executed.
     */
    die() {
        return this._ctx.die();
    }
    /**
     * This method allows you to call an arbitrary method as the next action in the
     * action queue. This is useful if you want to execute code in after a specific
     * action, i.e An actor arrives at a destination after traversing a path
     */
    callMethod(method) {
        return this._ctx.callMethod(method);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     * @param times  The number of times to repeat all the previous actions in the action queue. If nothing is specified the actions
     * will repeat forever
     */
    repeat(repeatBuilder, times) {
        return this._ctx.repeat(repeatBuilder, times);
    }
    /**
     * This method will cause the actor to repeat all of the actions built in
     * the `repeatBuilder` callback. If the number of repeats
     * is not specified it will repeat forever. This method is part of
     * the actor 'Action' fluent API allowing action chaining
     *
     * ```typescript
     * // Move up in a zig-zag by repeated moveBy's
     * actor.actions.repeat(repeatCtx => {
     *  repeatCtx.moveBy(10, 0, 10);
     *  repeatCtx.moveBy(0, 10, 10);
     * }, 5);
     * ```
     *
     * @param repeatBuilder The builder to specify the repeatable list of actions
     */
    repeatForever(repeatBuilder) {
        return this._ctx.repeatForever(repeatBuilder);
    }
    /**
     * This method will cause the entity to follow another at a specified distance
     * @param entity           The entity to follow
     * @param followDistance  The distance to maintain when following, if not specified the actor will follow at the current distance.
     */
    follow(entity, followDistance) {
        return this._ctx.follow(entity, followDistance);
    }
    /**
     * This method will cause the entity to move towards another until they
     * collide "meet" at a specified speed.
     * @param entity  The entity to meet
     * @param speed  The speed in pixels per second to move, if not specified it will match the speed of the other actor
     */
    meet(entity, speed) {
        return this._ctx.meet(entity, speed);
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     * @deprecated Use `toPromise()` will be removed in v0.26.0
     */
    asPromise() {
        return this.toPromise();
    }
    /**
     * Returns a promise that resolves when the current action queue up to now
     * is finished.
     */
    toPromise() {
        return this._ctx.toPromise();
    }
}

;// CONCATENATED MODULE: ./Actor.ts
var Actor_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






















/**
 * Type guard for checking if something is an Actor
 * @param x
 */
function isActor(x) {
    return x instanceof Actor;
}
/**
 * The most important primitive in Excalibur is an `Actor`. Anything that
 * can move on the screen, collide with another `Actor`, respond to events,
 * or interact with the current scene, must be an actor. An `Actor` **must**
 * be part of a [[Scene]] for it to be drawn to the screen.
 */
class Actor extends Entity {
    // #endregion
    /**
     *
     * @param config
     */
    constructor(config) {
        super();
        /**
         * The anchor to apply all actor related transformations like rotation,
         * translation, and scaling. By default the anchor is in the center of
         * the actor. By default it is set to the center of the actor (.5, .5)
         *
         * An anchor of (.5, .5) will ensure that drawings are centered.
         *
         * Use `anchor.setTo` to set the anchor to a different point using
         * values between 0 and 1. For example, anchoring to the top-left would be
         * `Actor.anchor.setTo(0, 0)` and top-right would be `Actor.anchor.setTo(0, 1)`.
         */
        this._anchor = watch(Vector.Half, (v) => this._handleAnchorChange(v));
        /**
         * Convenience reference to the global logger
         */
        this.logger = Logger.getInstance();
        /**
         * The scene that the actor is in
         */
        this.scene = null;
        this.frames = {};
        /**
         * Access to the current drawing for the actor, this can be
         * an [[Animation]], [[Sprite]], or [[Polygon]].
         * Set drawings with [[setDrawing]].
         * @deprecated
         */
        this.currentDrawing = null;
        /**
         * Draggable helper
         */
        this._draggable = false;
        this._dragging = false;
        this._pointerDragStartHandler = () => {
            this._dragging = true;
        };
        this._pointerDragEndHandler = () => {
            this._dragging = false;
        };
        this._pointerDragMoveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.pointer.lastWorldPos;
            }
        };
        this._pointerDragLeaveHandler = (pe) => {
            if (this._dragging) {
                this.pos = pe.pointer.lastWorldPos;
            }
        };
        /**
         * Modify the current actor update pipeline.
         */
        this.traits = [];
        /**
         * Whether or not to enable the [[Traits.CapturePointer]] trait that propagates
         * pointer events to this actor
         */
        this.enableCapturePointer = false;
        /**
         * Configuration for [[Traits.CapturePointer]] trait
         */
        this.capturePointer = {
            captureMoveEvents: false,
            captureDragEvents: false
        };
        // #region Events
        this._capturePointerEvents = [
            'pointerup',
            'pointerdown',
            'pointermove',
            'pointerenter',
            'pointerleave',
            'pointerdragstart',
            'pointerdragend',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        this._captureMoveEvents = [
            'pointermove',
            'pointerenter',
            'pointerleave',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        this._captureDragEvents = [
            'pointerdragstart',
            'pointerdragend',
            'pointerdragmove',
            'pointerdragenter',
            'pointerdragleave'
        ];
        const { name, x, y, pos, scale, width, height, radius, collider, vel, acc, rotation, angularVelocity, z, color, visible, anchor, collisionType, collisionGroup } = Object.assign({}, config);
        this._setName(name);
        this.anchor = anchor !== null && anchor !== void 0 ? anchor : Actor.defaults.anchor.clone();
        this.addComponent(new TransformComponent());
        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.rotation = rotation !== null && rotation !== void 0 ? rotation : 0;
        this.scale = scale !== null && scale !== void 0 ? scale : vec(1, 1);
        this.z = z !== null && z !== void 0 ? z : 0;
        this.addComponent(new GraphicsComponent());
        this.addComponent(new CanvasDrawComponent((ctx, delta) => this.draw(ctx, delta)));
        this.addComponent(new MotionComponent());
        this.vel = vel !== null && vel !== void 0 ? vel : Vector.Zero;
        this.acc = acc !== null && acc !== void 0 ? acc : Vector.Zero;
        this.angularVelocity = angularVelocity !== null && angularVelocity !== void 0 ? angularVelocity : 0;
        this.addComponent(new ActionsComponent());
        this.addComponent(new BodyComponent());
        this.body.collisionType = collisionType !== null && collisionType !== void 0 ? collisionType : CollisionType.Passive;
        if (collisionGroup) {
            this.body.group = collisionGroup;
        }
        if (collider) {
            this.addComponent(new ColliderComponent(collider));
        }
        else if (radius) {
            this.addComponent(new ColliderComponent(Shape.Circle(radius, this.anchor)));
        }
        else {
            if (width > 0 && height > 0) {
                this.addComponent(new ColliderComponent(Shape.Box(width, height, this.anchor)));
            }
            else {
                this.addComponent(new ColliderComponent()); // no collider
            }
        }
        this.graphics.visible = visible !== null && visible !== void 0 ? visible : true;
        if (color) {
            this.color = color;
            if (width && height) {
                this.graphics.add(new Rectangle({
                    color: color,
                    width,
                    height
                }));
            }
            else if (radius) {
                this.graphics.add(new Circle({
                    color: color,
                    radius
                }));
            }
        }
        // Build default pipeline
        if (Flags.isEnabled(Legacy.LegacyDrawing)) {
            // TODO remove offscreen trait after legacy drawing removed
            this.traits.push(new OffscreenCulling());
        }
        this.traits.push(new CapturePointer());
    }
    /**
     * The physics body the is associated with this actor. The body is the container for all physical properties, like position, velocity,
     * acceleration, mass, inertia, etc.
     */
    get body() {
        return this.get(BodyComponent);
    }
    /**
     * Access the Actor's built in [[TransformComponent]]
     */
    get transform() {
        return this.get(TransformComponent);
    }
    /**
     * Access the Actor's built in [[MotionComponent]]
     */
    get motion() {
        return this.get(MotionComponent);
    }
    /**
     * Access to the Actor's built in [[GraphicsComponent]]
     */
    get graphics() {
        return this.get(GraphicsComponent);
    }
    /**
     * Access to the Actor's built in [[ColliderComponent]]
     */
    get collider() {
        return this.get(ColliderComponent);
    }
    /**
     * Useful for quickly scripting actor behavior, like moving to a place, patroling back and forth, blinking, etc.
     *
     *  Access to the Actor's built in [[ActionsComponent]] which forwards to the
     * [[ActionContext|Action context]] of the actor.
     */
    get actions() {
        return this.get(ActionsComponent);
    }
    /**
     * Gets the position vector of the actor in pixels
     */
    get pos() {
        return this.transform.pos;
    }
    /**
     * Sets the position vector of the actor in pixels
     */
    set pos(thePos) {
        this.transform.pos = thePos.clone();
    }
    /**
     * Gets the position vector of the actor from the last frame
     */
    get oldPos() {
        return this.body.oldPos;
    }
    /**
     * Sets the position vector of the actor in the last frame
     */
    set oldPos(thePos) {
        this.body.oldPos.setTo(thePos.x, thePos.y);
    }
    /**
     * Gets the velocity vector of the actor in pixels/sec
     */
    get vel() {
        return this.motion.vel;
    }
    /**
     * Sets the velocity vector of the actor in pixels/sec
     */
    set vel(theVel) {
        this.motion.vel = theVel.clone();
    }
    /**
     * Gets the velocity vector of the actor from the last frame
     */
    get oldVel() {
        return this.body.oldVel;
    }
    /**
     * Sets the velocity vector of the actor from the last frame
     */
    set oldVel(theVel) {
        this.body.oldVel.setTo(theVel.x, theVel.y);
    }
    /**
     * Gets the acceleration vector of the actor in pixels/second/second. An acceleration pointing down such as (0, 100) may be
     * useful to simulate a gravitational effect.
     */
    get acc() {
        return this.motion.acc;
    }
    /**
     * Sets the acceleration vector of teh actor in pixels/second/second
     */
    set acc(theAcc) {
        this.motion.acc = theAcc.clone();
    }
    /**
     * Sets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    set oldAcc(theAcc) {
        this.body.oldAcc.setTo(theAcc.x, theAcc.y);
    }
    /**
     * Gets the acceleration of the actor from the last frame. This does not include the global acc [[Physics.acc]].
     */
    get oldAcc() {
        return this.body.oldAcc;
    }
    /**
     * Gets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    get rotation() {
        return this.transform.rotation;
    }
    /**
     * Sets the rotation of the actor in radians. 1 radian = 180/PI Degrees.
     */
    set rotation(theAngle) {
        this.transform.rotation = theAngle;
    }
    /**
     * Gets the rotational velocity of the actor in radians/second
     */
    get angularVelocity() {
        return this.motion.angularVelocity;
    }
    /**
     * Sets the rotational velocity of the actor in radians/sec
     */
    set angularVelocity(angularVelocity) {
        this.motion.angularVelocity = angularVelocity;
    }
    get scale() {
        return this.get(TransformComponent).scale;
    }
    set scale(scale) {
        this.get(TransformComponent).scale = scale;
    }
    get anchor() {
        return this._anchor;
    }
    set anchor(vec) {
        this._anchor = watch(vec, (v) => this._handleAnchorChange(v));
        this._handleAnchorChange(vec);
    }
    _handleAnchorChange(v) {
        if (this.graphics) {
            this.graphics.anchor = v;
        }
    }
    /**
     * Indicates whether the actor is physically in the viewport
     */
    get isOffScreen() {
        return this.hasTag('offscreen');
    }
    /**
     * The visibility of an actor
     * @deprecated Use [[GraphicsComponent.visible|Actor.graphics.visible]], will be removed in v0.26.0
     */
    get visible() {
        return this.graphics.visible;
    }
    set visible(isVisible) {
        this.graphics.visible = isVisible;
    }
    /**
     * The opacity of an actor.
     *
     * @deprecated Actor.opacity will be removed in v0.26.0, use [[GraphicsComponent.opacity|Actor.graphics.opacity]].
     */
    get opacity() {
        return this.graphics.opacity;
    }
    set opacity(opacity) {
        this.graphics.opacity = opacity;
    }
    get draggable() {
        return this._draggable;
    }
    set draggable(isDraggable) {
        if (isDraggable) {
            if (isDraggable && !this._draggable) {
                this.on('pointerdragstart', this._pointerDragStartHandler);
                this.on('pointerdragend', this._pointerDragEndHandler);
                this.on('pointerdragmove', this._pointerDragMoveHandler);
                this.on('pointerdragleave', this._pointerDragLeaveHandler);
            }
            else if (!isDraggable && this._draggable) {
                this.off('pointerdragstart', this._pointerDragStartHandler);
                this.off('pointerdragend', this._pointerDragEndHandler);
                this.off('pointerdragmove', this._pointerDragMoveHandler);
                this.off('pointerdragleave', this._pointerDragLeaveHandler);
            }
            this._draggable = isDraggable;
        }
    }
    /**
     * Sets the color of the actor. A rectangle of this color will be
     * drawn if no [[Drawable]] is specified as the actors drawing.
     *
     * The default is `null` which prevents a rectangle from being drawn.
     */
    get color() {
        return this._color;
    }
    set color(v) {
        this._color = v.clone();
    }
    /**
     * `onInitialize` is called before the first update of the actor. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     *
     * Synonymous with the event handler `.on('initialize', (evt) => {...})`
     */
    onInitialize(_engine) {
        // Override me
    }
    /**
     * Initializes this actor and all it's child actors, meant to be called by the Scene before first update not by users of Excalibur.
     *
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * @internal
     */
    _initialize(engine) {
        super._initialize(engine);
        for (const child of this.children) {
            child._initialize(engine);
        }
    }
    _checkForPointerOptIn(eventName) {
        if (eventName) {
            const normalized = eventName.toLowerCase();
            if (this._capturePointerEvents.indexOf(normalized) !== -1) {
                this.enableCapturePointer = true;
                if (this._captureMoveEvents.indexOf(normalized) !== -1) {
                    this.capturePointer.captureMoveEvents = true;
                }
                if (this._captureDragEvents.indexOf(normalized) !== -1) {
                    this.capturePointer.captureDragEvents = true;
                }
            }
        }
    }
    on(eventName, handler) {
        this._checkForPointerOptIn(eventName);
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        this._checkForPointerOptIn(eventName);
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    // #endregion
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPreKill]] lifecycle event
     * @internal
     */
    _prekill(_scene) {
        super.emit('prekill', new PreKillEvent(this));
        this.onPreKill(_scene);
    }
    /**
     * Safe to override onPreKill lifecycle event handler. Synonymous with `.on('prekill', (evt) =>{...})`
     *
     * `onPreKill` is called directly before an actor is killed and removed from its current [[Scene]].
     */
    onPreKill(_scene) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _prekill handler for [[onPostKill]] lifecycle event
     * @internal
     */
    _postkill(_scene) {
        super.emit('postkill', new PostKillEvent(this));
        this.onPostKill(_scene);
    }
    /**
     * Safe to override onPostKill lifecycle event handler. Synonymous with `.on('postkill', (evt) => {...})`
     *
     * `onPostKill` is called directly after an actor is killed and remove from its current [[Scene]].
     */
    onPostKill(_scene) {
        // Override me
    }
    /**
     * If the current actor is a member of the scene, this will remove
     * it from the scene graph. It will no longer be drawn or updated.
     */
    kill() {
        if (this.scene) {
            this._prekill(this.scene);
            this.emit('kill', new KillEvent(this));
            super.kill();
            this._postkill(this.scene);
        }
        else {
            this.logger.warn('Cannot kill actor, it was never added to the Scene');
        }
    }
    /**
     * If the current actor is killed, it will now not be killed.
     */
    unkill() {
        this.active = true;
    }
    /**
     * Indicates wether the actor has been killed.
     */
    isKilled() {
        return !this.active;
    }
    setDrawing(key) {
        key = key.toString();
        if (this.currentDrawing !== this.frames[key]) {
            if (this.frames[key] != null) {
                this.frames[key].reset();
                this.currentDrawing = this.frames[key];
            }
            else {
                Logger.getInstance().error(`the specified drawing key ${key} does not exist`);
            }
        }
        if (this.currentDrawing && this.currentDrawing instanceof Animation_Animation) {
            this.currentDrawing.tick(0);
        }
    }
    addDrawing() {
        if (arguments.length === 2) {
            this.frames[arguments[0]] = arguments[1];
            if (!this.currentDrawing) {
                this.currentDrawing = arguments[1];
            }
        }
        else {
            if (arguments[0] instanceof Sprite_Sprite) {
                this.addDrawing('default', arguments[0]);
            }
            if (arguments[0] instanceof Texture) {
                this.addDrawing('default', arguments[0].asSprite());
            }
        }
    }
    /**
     * Gets the z-index of an actor. The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     */
    get z() {
        return this.get(TransformComponent).z;
    }
    /**
     * @deprecated Use [[Actor.z]]
     */
    getZIndex() {
        return this.get(TransformComponent).z;
    }
    /**
     * Sets the z-index of an actor and updates it in the drawing list for the scene.
     * The z-index determines the relative order an actor is drawn in.
     * Actors with a higher z-index are drawn on top of actors with a lower z-index
     * @param newZ new z-index to assign
     */
    set z(newZ) {
        this.get(TransformComponent).z = newZ;
    }
    /**
     * @param newIndex new z-index to assign
     * @deprecated Use [[Actor.z]]
     */
    setZIndex(newIndex) {
        this.get(TransformComponent).z = newIndex;
    }
    /**
     * Get the center point of an actor
     */
    get center() {
        return new Vector(this.pos.x + this.width / 2 - this.anchor.x * this.width, this.pos.y + this.height / 2 - this.anchor.y * this.height);
    }
    get width() {
        return this.collider.localBounds.width * this.getGlobalScale().x;
    }
    get height() {
        return this.collider.localBounds.height * this.getGlobalScale().y;
    }
    /**
     * Gets this actor's rotation taking into account any parent relationships
     *
     * @returns Rotation angle in radians
     */
    getGlobalRotation() {
        return this.get(TransformComponent).globalRotation;
    }
    /**
     * Gets an actor's world position taking into account parent relationships, scaling, rotation, and translation
     *
     * @returns Position in world coordinates
     */
    getGlobalPos() {
        return this.get(TransformComponent).globalPos;
    }
    /**
     * Gets the global scale of the Actor
     */
    getGlobalScale() {
        return this.get(TransformComponent).globalScale;
    }
    // #region Collision
    /**
     * Tests whether the x/y specified are contained in the actor
     * @param x  X coordinate to test (in world coordinates)
     * @param y  Y coordinate to test (in world coordinates)
     * @param recurse checks whether the x/y are contained in any child actors (if they exist).
     */
    contains(x, y, recurse = false) {
        const point = vec(x, y);
        const collider = this.get(ColliderComponent);
        collider.update();
        const geom = collider.get();
        if (!geom) {
            return false;
        }
        const containment = geom.contains(point);
        if (recurse) {
            return (containment ||
                this.children.some((child) => {
                    return child.contains(x, y, true);
                }));
        }
        return containment;
    }
    /**
     * Returns true if the two actor.collider's surfaces are less than or equal to the distance specified from each other
     * @param actor     Actor to test
     * @param distance  Distance in pixels to test
     */
    within(actor, distance) {
        const collider = this.get(ColliderComponent);
        const otherCollider = actor.get(ColliderComponent);
        const me = collider.get();
        const other = otherCollider.get();
        if (me && other) {
            return me.getClosestLineBetween(other).getLength() <= distance;
        }
        return false;
    }
    // #endregion
    // #region Update
    /**
     * Called by the Engine, updates the state of the actor
     * @internal
     * @param engine The reference to the current game engine
     * @param delta  The time elapsed since the last update in milliseconds
     */
    update(engine, delta) {
        this._initialize(engine);
        this._preupdate(engine, delta);
        // Tick animations
        const drawing = this.currentDrawing;
        if (drawing && drawing instanceof Animation_Animation) {
            drawing.tick(delta, engine.stats.currFrame.id);
        }
        // Update actor pipeline (movement, collision detection, event propagation, offscreen culling)
        for (const trait of this.traits) {
            trait.update(this, engine, delta);
        }
        this._postupdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before an actor is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('postupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after an actor is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PreUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    // endregion
    // #region Drawing
    /**
     * Called by the Engine, draws the actor to the screen
     * @param ctx   The rendering context
     * @param delta The time since the last draw in milliseconds
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics, will be removed in v0.26.0
     */
    draw(ctx, delta) {
        var _a;
        // translate canvas by anchor offset
        ctx.save();
        if (this.currentDrawing) {
            ctx.translate(-(this.width * this.anchor.x), -(this.height * this.anchor.y));
            this._predraw(ctx, delta);
            const drawing = this.currentDrawing;
            // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula
            const offsetX = (this.width - drawing.width * drawing.scale.x) * this.anchor.x;
            const offsetY = (this.height - drawing.height * drawing.scale.y) * this.anchor.y;
            this.currentDrawing.draw({ ctx, x: offsetX, y: offsetY, opacity: this.graphics.opacity });
        }
        else {
            this._predraw(ctx, delta);
            if (this.color && this.collider) {
                // update collider geometry based on transform
                const collider = this.get(ColliderComponent);
                collider.update();
                if (collider && !collider.bounds.hasZeroDimensions()) {
                    // Colliders are already shifted by anchor, unshift
                    ctx.globalAlpha = this.graphics.opacity;
                    (_a = collider.get()) === null || _a === void 0 ? void 0 : _a.draw(ctx, this.color, vec(0, 0));
                }
            }
        }
        ctx.restore();
        this._postdraw(ctx, delta);
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('predraw', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before an actor is drawn, but after local transforms are made.
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     */
    onPreDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('postdraw', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after an actor is drawn, and before local transforms are removed.
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     */
    onPostDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for [[onPreDraw]] lifecycle event
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPreDraw, will be removed in v0.26.0
     * @internal
     */
    _predraw(ctx, delta) {
        this.emit('predraw', new PreDrawEvent(ctx, delta, this));
        this.onPreDraw(ctx, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for [[onPostDraw]] lifecycle event
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     * @internal
     */
    _postdraw(ctx, delta) {
        this.emit('postdraw', new PreDrawEvent(ctx, delta, this));
        this.onPostDraw(ctx, delta);
    }
    /**
     * Called by the Engine, draws the actors debugging to the screen
     * @param ctx The rendering context
     *
     *
     * **Warning** only works with Flags.useLegacyDrawing() enabled
     * @deprecated Use Actor.graphics.onPostDraw, will be removed in v0.26.0
     * @internal
     */
    /* istanbul ignore next */
    debugDraw(_ctx) {
        // pass
    }
}
// #region Properties
/**
 * Set defaults for all Actors
 */
Actor.defaults = {
    anchor: Vector.Half
};
Actor_decorate([
    obsolete({ message: 'Actor.visible will be removed in v0.26.0', alternateMethod: 'Use Actor.graphics.visible' })
], Actor.prototype, "visible", null);
Actor_decorate([
    obsolete({
        message: 'Actor.opacity will be removed in v0.26.0',
        alternateMethod: 'Use Actor.graphics.opacity'
    })
], Actor.prototype, "opacity", null);
Actor_decorate([
    obsolete({
        message: 'Actor.setDrawing will be removed in v0.26.0',
        alternateMethod: 'Use Actor.graphics.show() or Actor.graphics.use()'
    })
], Actor.prototype, "setDrawing", null);
Actor_decorate([
    obsolete({
        message: 'Actor.addDrawing will be removed in v0.26.0',
        alternateMethod: 'Use Actor.graphics.add()'
    })
], Actor.prototype, "addDrawing", null);
Actor_decorate([
    obsolete({
        message: 'Actor.getZIndex will be removed in v0.26.0',
        alternateMethod: 'Use Actor.transform.z or Actor.z'
    })
], Actor.prototype, "getZIndex", null);
Actor_decorate([
    obsolete({
        message: 'Actor.setZIndex will be removed in v0.26.0',
        alternateMethod: 'Use Actor.transform.z or Actor.z'
    })
], Actor.prototype, "setZIndex", null);

;// CONCATENATED MODULE: ./ScreenElement.ts





/**
 * Helper [[Actor]] primitive for drawing UI's, optimized for UI drawing. Does
 * not participate in collisions. Drawn on top of all other actors.
 */
class ScreenElement_ScreenElement extends Actor {
    constructor(config) {
        super(Object.assign({}, config));
        this.get(TransformComponent).coordPlane = CoordPlane.Screen;
        this.traits = [];
        this.traits.push(new CapturePointer());
        this.anchor = vec(0, 0);
        this.body.collisionType = CollisionType.PreventCollision;
        this.collider.useBoxCollider(this.width, this.height, this.anchor);
        this.enableCapturePointer = true;
    }
    _initialize(engine) {
        this._engine = engine;
        super._initialize(engine);
    }
    contains(x, y, useWorld = true) {
        if (useWorld) {
            return super.contains(x, y);
        }
        const coords = this._engine.worldToScreenCoordinates(new Vector(x, y));
        return super.contains(coords.x, coords.y);
    }
}

;// CONCATENATED MODULE: ./Timer.ts
var Timer_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * The Excalibur timer hooks into the internal timer and fires callbacks,
 * after a certain interval, optionally repeating.
 */
class Timer {
    constructor(fcn, interval, repeats, numberOfRepeats) {
        this._logger = Logger.getInstance();
        this.id = 0;
        this._elapsedTime = 0;
        this._totalTimeAlive = 0;
        this._running = false;
        this._numberOfTicks = 0;
        this.interval = 10;
        this.repeats = false;
        this.maxNumberOfRepeats = -1;
        this._complete = false;
        this.scene = null;
        if (typeof fcn !== 'function') {
            const options = fcn;
            fcn = options.fcn;
            interval = options.interval;
            repeats = options.repeats;
            numberOfRepeats = options.numberOfRepeats;
        }
        if (!!numberOfRepeats && numberOfRepeats >= 0) {
            this.maxNumberOfRepeats = numberOfRepeats;
            if (!repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this.id = Timer._MAX_ID++;
        this.interval = interval || this.interval;
        this.repeats = repeats || this.repeats;
        this._callbacks = [];
        if (fcn) {
            this.on(fcn);
        }
    }
    get complete() {
        return this._complete;
    }
    /**
     * Adds a new callback to be fired after the interval is complete
     * @param fcn The callback to be added to the callback list, to be fired after the interval is complete.
     */
    on(fcn) {
        this._callbacks.push(fcn);
    }
    /**
     * Removes a callback from the callback list to be fired after the interval is complete.
     * @param fcn The callback to be removed from the callback list, to be fired after the interval is complete.
     */
    off(fcn) {
        const index = this._callbacks.indexOf(fcn);
        this._callbacks.splice(index, 1);
    }
    /**
     * Updates the timer after a certain number of milliseconds have elapsed. This is used internally by the engine.
     * @param delta  Number of elapsed milliseconds since the last update.
     */
    update(delta) {
        if (this._running) {
            this._totalTimeAlive += delta;
            this._elapsedTime += delta;
            if (this.maxNumberOfRepeats > -1 && this._numberOfTicks >= this.maxNumberOfRepeats) {
                this._complete = true;
                this._running = false;
                this._elapsedTime = 0;
            }
            if (!this.complete && this._elapsedTime >= this.interval) {
                this._callbacks.forEach((c) => {
                    c.call(this);
                });
                this._numberOfTicks++;
                if (this.repeats) {
                    this._elapsedTime = 0;
                }
                else {
                    this._complete = true;
                    this._running = false;
                    this._elapsedTime = 0;
                }
            }
        }
    }
    /**
     * Resets the timer so that it can be reused, and optionally reconfigure the timers interval.
     *
     * Warning** you may need to call `timer.start()` again if the timer had completed
     * @param newInterval If specified, sets a new non-negative interval in milliseconds to refire the callback
     * @param newNumberOfRepeats If specified, sets a new non-negative upper limit to the number of time this timer executes
     */
    reset(newInterval, newNumberOfRepeats) {
        if (!!newInterval && newInterval >= 0) {
            this.interval = newInterval;
        }
        if (!!this.maxNumberOfRepeats && this.maxNumberOfRepeats >= 0) {
            this.maxNumberOfRepeats = newNumberOfRepeats;
            if (!this.repeats) {
                throw new Error('repeats must be set to true if numberOfRepeats is set');
            }
        }
        this._complete = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
    }
    get timesRepeated() {
        return this._numberOfTicks;
    }
    getTimeRunning() {
        return this._totalTimeAlive;
    }
    /**
     * @returns milliseconds until the next action callback, if complete will return 0
     */
    get timeToNextAction() {
        if (this.complete) {
            return 0;
        }
        return this.interval - this._elapsedTime;
    }
    /**
     * @returns milliseconds elapsed toward the next action
     */
    get timeElapsedTowardNextAction() {
        return this._elapsedTime;
    }
    get isRunning() {
        return this._running;
    }
    /**
     * Pauses the timer, time will no longer increment towards the next call
     */
    pause() {
        this._running = false;
        return this;
    }
    /**
     * Unpauses the timer. Time will now increment towards the next call
     * @deprecated Will be removed in v0.26.0
     */
    unpause() {
        this._running = true;
    }
    /**
     * Resumes the timer, time will now increment towards the next call.
     */
    resume() {
        this._running = true;
        return this;
    }
    /**
     * Starts the timer, if the timer was complete it will restart the timer and reset the elapsed time counter
     */
    start() {
        if (!this.scene) {
            this._logger.warn('Cannot start a timer not part of a scene, timer wont start until added');
        }
        this._running = true;
        if (this.complete) {
            this._complete = false;
            this._elapsedTime = 0;
            this._numberOfTicks = 0;
        }
        return this;
    }
    /**
     * Stops the timer and resets the elapsed time counter towards the next action invocation
     */
    stop() {
        this._running = false;
        this._elapsedTime = 0;
        this._numberOfTicks = 0;
        return this;
    }
    /**
     * Cancels the timer, preventing any further executions.
     */
    cancel() {
        this.pause();
        if (this.scene) {
            this.scene.cancelTimer(this);
        }
    }
}
Timer._MAX_ID = 0;
Timer_decorate([
    obsolete({ message: 'Will be removed in v0.26.0', alternateMethod: 'Use Timer.resume()' })
], Timer.prototype, "unpause", null);

;// CONCATENATED MODULE: ./TileMap.ts
var TileMap_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


















/**
 * @hidden
 */
class TileMapImpl extends Entity {
    /**
     * @param xOrConfig     The x coordinate to anchor the TileMap's upper left corner (should not be changed once set) or TileMap option bag
     * @param y             The y coordinate to anchor the TileMap's upper left corner (should not be changed once set)
     * @param cellWidth     The individual width of each cell (in pixels) (should not be changed once set)
     * @param cellHeight    The individual height of each cell (in pixels) (should not be changed once set)
     * @param rows          The number of rows in the TileMap (should not be changed once set)
     * @param cols          The number of cols in the TileMap (should not be changed once set)
     */
    constructor(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
        super();
        this._token = 0;
        this._onScreenXStart = 0;
        this._onScreenXEnd = 9999;
        this._onScreenYStart = 0;
        this._onScreenYEnd = 9999;
        this._spriteSheets = {};
        this._legacySpriteMap = new Map();
        this.logger = Logger.getInstance();
        this.data = [];
        this._rows = [];
        this._cols = [];
        this.visible = true;
        this.isOffscreen = false;
        this._dirty = true;
        if (xOrConfig && typeof xOrConfig === 'object') {
            const config = xOrConfig;
            xOrConfig = config.x;
            y = config.y;
            cellWidth = config.cellWidth;
            cellHeight = config.cellHeight;
            rows = config.rows;
            cols = config.cols;
        }
        this.addComponent(new TransformComponent());
        this.addComponent(new MotionComponent());
        this.addComponent(new BodyComponent({
            type: CollisionType.Fixed
        }));
        this.addComponent(new CanvasDrawComponent((ctx, delta) => this.draw(ctx, delta)));
        this.addComponent(new GraphicsComponent({
            onPostDraw: (ctx, delta) => this.draw(ctx, delta)
        }));
        this.addComponent(new ColliderComponent());
        this._transform = this.get(TransformComponent);
        this._motion = this.get(MotionComponent);
        this._collider = this.get(ColliderComponent);
        this._composite = this._collider.useCompositeCollider([]);
        this.x = xOrConfig;
        this.y = y;
        this.cellWidth = cellWidth;
        this.cellHeight = cellHeight;
        this.rows = rows;
        this.cols = cols;
        this.data = new Array(rows * cols);
        this._rows = new Array(rows);
        this._cols = new Array(cols);
        let currentCol = [];
        for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
                const cd = new Cell(i * cellWidth + xOrConfig, j * cellHeight + y, cellWidth, cellHeight, i + j * cols);
                cd.map = this;
                this.data[i + j * cols] = cd;
                currentCol.push(cd);
                if (!this._rows[j]) {
                    this._rows[j] = [];
                }
                this._rows[j].push(cd);
            }
            this._cols[i] = currentCol;
            currentCol = [];
        }
        this.get(GraphicsComponent).localBounds = new BoundingBox({
            left: 0,
            top: 0,
            right: this.cols * this.cellWidth,
            bottom: this.rows * this.cellHeight
        });
    }
    flagDirty() {
        this._dirty = true;
    }
    get x() {
        var _a;
        return (_a = this._transform.pos.x) !== null && _a !== void 0 ? _a : 0;
    }
    set x(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this.get(TransformComponent).pos = vec(val, this.y);
        }
    }
    get y() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos.y) !== null && _b !== void 0 ? _b : 0;
    }
    set y(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.pos) {
            this._transform.pos = vec(this.x, val);
        }
    }
    get z() {
        var _a;
        return (_a = this._transform.z) !== null && _a !== void 0 ? _a : 0;
    }
    set z(val) {
        if (this._transform) {
            this._transform.z = val;
        }
    }
    get rotation() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : 0;
    }
    set rotation(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.rotation) {
            this._transform.rotation = val;
        }
    }
    get scale() {
        var _a, _b;
        return (_b = (_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) !== null && _b !== void 0 ? _b : Vector.One;
    }
    set scale(val) {
        var _a;
        if ((_a = this._transform) === null || _a === void 0 ? void 0 : _a.scale) {
            this._transform.scale = val;
        }
    }
    get pos() {
        return this._transform.pos;
    }
    set pos(val) {
        this._transform.pos = val;
    }
    get vel() {
        return this._motion.vel;
    }
    set vel(val) {
        this._motion.vel = val;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    registerSpriteSheet(key, spriteSheet) {
        if (spriteSheet instanceof SpriteSheet) {
            this._spriteSheets[key] = spriteSheet;
        }
        else {
            this._spriteSheets[key] = SpriteSheet.fromLegacySpriteSheet(spriteSheet);
        }
    }
    /**
     * Tiles colliders based on the solid tiles in the tilemap.
     */
    _updateColliders() {
        this._composite.clearColliders();
        const colliders = [];
        let current;
        // Bad square tessalation algo
        for (let i = 0; i < this.cols; i++) {
            // Scan column for colliders
            for (let j = 0; j < this.rows; j++) {
                // Columns start with a new collider
                if (j === 0) {
                    current = null;
                }
                const tile = this.data[i + j * this.cols];
                // Current tile in column is solid build up current collider
                if (tile.solid) {
                    if (!current) {
                        current = tile.bounds;
                    }
                    else {
                        current = current.combine(tile.bounds);
                    }
                }
                else {
                    // Not solid skip and cut off the current collider
                    if (current) {
                        colliders.push(current);
                    }
                    current = null;
                }
            }
            // After a column is complete check to see if it can be merged into the last one
            if (current) {
                // if previous is the same combine it
                const prev = colliders[colliders.length - 1];
                if (prev && prev.top === current.top && prev.bottom === current.bottom) {
                    colliders[colliders.length - 1] = prev.combine(current);
                }
                else {
                    // else new collider
                    colliders.push(current);
                }
            }
        }
        this._composite = this._collider.useCompositeCollider([]);
        for (const c of colliders) {
            const collider = Shape.Box(c.width, c.height, Vector.Zero, vec(c.left - this.pos.x, c.top - this.pos.y));
            collider.owner = this;
            this._composite.addCollider(collider);
        }
        this._collider.update();
    }
    /**
     * Returns the [[Cell]] by index (row major order)
     */
    getCellByIndex(index) {
        return this.data[index];
    }
    /**
     * Returns the [[Cell]] by its x and y coordinates
     */
    getCell(x, y) {
        if (x < 0 || y < 0 || x >= this.cols || y >= this.rows) {
            return null;
        }
        return this.data[x + y * this.cols];
    }
    /**
     * Returns the [[Cell]] by testing a point in global coordinates,
     * returns `null` if no cell was found.
     */
    getCellByPoint(x, y) {
        x = Math.floor((x - this.pos.x) / this.cellWidth);
        y = Math.floor((y - this.pos.y) / this.cellHeight);
        const cell = this.getCell(x, y);
        if (x >= 0 && y >= 0 && x < this.cols && y < this.rows && cell) {
            return cell;
        }
        return null;
    }
    getRows() {
        return this._rows;
    }
    getColumns() {
        return this._cols;
    }
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    update(engine, delta) {
        this.onPreUpdate(engine, delta);
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        if (this._dirty) {
            this._dirty = false;
            this._updateColliders();
        }
        this._token++;
        const worldBounds = engine.getWorldBounds();
        const worldCoordsUpperLeft = vec(worldBounds.left, worldBounds.top);
        const worldCoordsLowerRight = vec(worldBounds.right, worldBounds.bottom);
        this._onScreenXStart = Math.max(Math.floor((worldCoordsUpperLeft.x - this.x) / this.cellWidth) - 2, 0);
        this._onScreenYStart = Math.max(Math.floor((worldCoordsUpperLeft.y - this.y) / this.cellHeight) - 2, 0);
        this._onScreenXEnd = Math.max(Math.floor((worldCoordsLowerRight.x - this.x) / this.cellWidth) + 2, 0);
        this._onScreenYEnd = Math.max(Math.floor((worldCoordsLowerRight.y - this.y) / this.cellHeight) + 2, 0);
        this._transform.pos = vec(this.x, this.y);
        this.onPostUpdate(engine, delta);
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
    }
    /**
     * Draws the tile map to the screen. Called by the [[Scene]].
     * @param ctx CanvasRenderingContext2D or ExcaliburGraphicsContext
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        this.emit('predraw', new PreDrawEvent(ctx, delta, this)); // TODO fix event
        let x = this._onScreenXStart;
        const xEnd = Math.min(this._onScreenXEnd, this.cols);
        let y = this._onScreenYStart;
        const yEnd = Math.min(this._onScreenYEnd, this.rows);
        let graphics, graphicsIndex, graphicsLen;
        for (x; x < xEnd; x++) {
            for (y; y < yEnd; y++) {
                // get non-negative tile sprites
                graphics = this.getCell(x, y).graphics;
                for (graphicsIndex = 0, graphicsLen = graphics.length; graphicsIndex < graphicsLen; graphicsIndex++) {
                    // draw sprite, warning if sprite doesn't exist
                    const graphic = graphics[graphicsIndex];
                    if (graphic) {
                        if (!(ctx instanceof CanvasRenderingContext2D)) {
                            if (hasGraphicsTick(graphic)) {
                                graphic === null || graphic === void 0 ? void 0 : graphic.tick(delta, this._token);
                            }
                            graphic.draw(ctx, x * this.cellWidth, y * this.cellHeight);
                        }
                        else if (graphic instanceof Sprite) {
                            // TODO legacy drawing mode
                            if (!this._legacySpriteMap.has(graphic)) {
                                this._legacySpriteMap.set(graphic, Sprite.toLegacySprite(graphic));
                            }
                            this._legacySpriteMap.get(graphic).draw(ctx, x * this.cellWidth, y * this.cellHeight);
                        }
                    }
                }
            }
            y = this._onScreenYStart;
        }
        this.emit('postdraw', new PostDrawEvent(ctx, delta, this));
    }
}
TileMap_decorate([
    obsolete({ message: 'No longer used, will be removed in v0.26.0' })
], TileMapImpl.prototype, "registerSpriteSheet", null);
/**
 * The [[TileMap]] class provides a lightweight way to do large complex scenes with collision
 * without the overhead of actors.
 */
class TileMap extends Configurable(TileMapImpl) {
    constructor(xOrConfig, y, cellWidth, cellHeight, rows, cols) {
        super(xOrConfig, y, cellWidth, cellHeight, rows, cols);
    }
}
/**
 * @hidden
 */
class CellImpl extends Entity {
    /**
     * @param xOrConfig Gets or sets x coordinate of the cell in world coordinates or cell option bag
     * @param y       Gets or sets y coordinate of the cell in world coordinates
     * @param width   Gets or sets the width of the cell
     * @param height  Gets or sets the height of the cell
     * @param index   The index of the cell in row major order
     * @param solid   Gets or sets whether this cell is solid
     * @param graphics The list of tile graphics to use to draw in this cell (in order)
     */
    constructor(xOrConfig, y, width, height, index, solid = false, graphics = []) {
        super();
        this._solid = false;
        /**
         * Current list of graphics for this cell
         */
        this.graphics = [];
        /**
         * Abitrary data storage per cell, useful for any game specific data
         */
        this.data = new Map();
        if (xOrConfig && typeof xOrConfig === 'object') {
            const config = xOrConfig;
            xOrConfig = config.x;
            y = config.y;
            width = config.width;
            height = config.height;
            index = config.index;
            solid = config.solid;
            graphics = config.sprites;
        }
        this.x = xOrConfig;
        this.y = y;
        this.width = width;
        this.height = height;
        this.index = index;
        this.solid = solid;
        this.graphics = graphics;
        this._bounds = new BoundingBox(this.x, this.y, this.x + this.width, this.y + this.height);
    }
    /**
     * Wether this cell should be treated as solid by the tilemap
     */
    get solid() {
        return this._solid;
    }
    /**
     * Wether this cell should be treated as solid by the tilemap
     */
    set solid(val) {
        var _a;
        (_a = this.map) === null || _a === void 0 ? void 0 : _a.flagDirty();
        this._solid = val;
    }
    get bounds() {
        return this._bounds;
    }
    get center() {
        return new Vector(this.x + this.width / 2, this.y + this.height / 2);
    }
    /**
     * Add another [[Sprite]] to this cell
     * @deprecated Use addSprite, will be removed in v0.26.0
     */
    pushSprite(sprite) {
        this.addGraphic(sprite);
    }
    /**
     * Add another [[Graphic]] to this TileMap cell
     * @param graphic
     */
    addGraphic(graphic) {
        if (graphic instanceof Sprite_Sprite) {
            this.graphics.push(Sprite.fromLegacySprite(graphic));
        }
        else {
            this.graphics.push(graphic);
        }
    }
    /**
     * Remove an instance of a [[Graphic]] from this cell
     */
    removeGraphic(graphic) {
        removeItemFromArray(graphic, this.graphics);
    }
    /**
     * Clear all graphis from this cell
     */
    clearGraphics() {
        this.graphics.length = 0;
    }
}
TileMap_decorate([
    obsolete({ message: 'Will be removed in v0.26.0', alternateMethod: 'addSprite' })
], CellImpl.prototype, "pushSprite", null);
/**
 * TileMap Cell
 *
 * A light-weight object that occupies a space in a collision map. Generally
 * created by a [[TileMap]].
 *
 * Cells can draw multiple sprites. Note that the order of drawing is the order
 * of the sprites in the array so the last one will be drawn on top. You can
 * use transparency to create layers this way.
 */
class Cell extends Configurable(CellImpl) {
    constructor(xOrConfig, y, width, height, index, solid, sprites) {
        super(xOrConfig, y, width, height, index, solid, sprites);
    }
}

;// CONCATENATED MODULE: ./Camera.ts








/**
 * Container to house convenience strategy methods
 * @internal
 */
class StrategyContainer {
    constructor(camera) {
        this.camera = camera;
    }
    /**
     * Creates and adds the [[LockCameraToActorStrategy]] on the current camera.
     * @param actor The actor to lock the camera to
     */
    lockToActor(actor) {
        this.camera.addStrategy(new LockCameraToActorStrategy(actor));
    }
    /**
     * Creates and adds the [[LockCameraToActorAxisStrategy]] on the current camera
     * @param actor The actor to lock the camera to
     * @param axis The axis to follow the actor on
     */
    lockToActorAxis(actor, axis) {
        this.camera.addStrategy(new LockCameraToActorAxisStrategy(actor, axis));
    }
    /**
     * Creates and adds the [[ElasticToActorStrategy]] on the current camera
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param actor Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    elasticToActor(actor, cameraElasticity, cameraFriction) {
        this.camera.addStrategy(new ElasticToActorStrategy(actor, cameraElasticity, cameraFriction));
    }
    /**
     * Creates and adds the [[RadiusAroundActorStrategy]] on the current camera
     * @param actor Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    radiusAroundActor(actor, radius) {
        this.camera.addStrategy(new RadiusAroundActorStrategy(actor, radius));
    }
    /**
     * Creates and adds the [[LimitCameraBoundsStrategy]] on the current camera
     * @param box The bounding box to limit the camera to.
     */
    limitCameraBounds(box) {
        this.camera.addStrategy(new LimitCameraBoundsStrategy(box));
    }
}
/**
 * Camera axis enum
 */
var Axis;
(function (Axis) {
    Axis[Axis["X"] = 0] = "X";
    Axis[Axis["Y"] = 1] = "Y";
})(Axis || (Axis = {}));
/**
 * Lock a camera to the exact x/y position of an actor.
 */
class LockCameraToActorStrategy {
    constructor(target) {
        this.target = target;
        this.action = (target, _cam, _eng, _delta) => {
            const center = target.center;
            return center;
        };
    }
}
/**
 * Lock a camera to a specific axis around an actor.
 */
class LockCameraToActorAxisStrategy {
    constructor(target, axis) {
        this.target = target;
        this.axis = axis;
        this.action = (target, cam, _eng, _delta) => {
            const center = target.center;
            const currentFocus = cam.getFocus();
            if (this.axis === Axis.X) {
                return new Vector(center.x, currentFocus.y);
            }
            else {
                return new Vector(currentFocus.x, center.y);
            }
        };
    }
}
/**
 * Using [Hook's law](https://en.wikipedia.org/wiki/Hooke's_law), elastically move the camera towards the target actor.
 */
class ElasticToActorStrategy {
    /**
     * If cameraElasticity < cameraFriction < 1.0, the behavior will be a dampened spring that will slowly end at the target without bouncing
     * If cameraFriction < cameraElasticity < 1.0, the behavior will be an oscillating spring that will over
     * correct and bounce around the target
     *
     * @param target Target actor to elastically follow
     * @param cameraElasticity [0 - 1.0] The higher the elasticity the more force that will drive the camera towards the target
     * @param cameraFriction [0 - 1.0] The higher the friction the more that the camera will resist motion towards the target
     */
    constructor(target, cameraElasticity, cameraFriction) {
        this.target = target;
        this.cameraElasticity = cameraElasticity;
        this.cameraFriction = cameraFriction;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            let focus = cam.getFocus();
            let cameraVel = cam.vel.clone();
            // Calculate the stretch vector, using the spring equation
            // F = kX
            // https://en.wikipedia.org/wiki/Hooke's_law
            // Apply to the current camera velocity
            const stretch = position.sub(focus).scale(this.cameraElasticity); // stretch is X
            cameraVel = cameraVel.add(stretch);
            // Calculate the friction (-1 to apply a force in the opposition of motion)
            // Apply to the current camera velocity
            const friction = cameraVel.scale(-1).scale(this.cameraFriction);
            cameraVel = cameraVel.add(friction);
            // Update position by velocity deltas
            focus = focus.add(cameraVel);
            return focus;
        };
    }
}
class RadiusAroundActorStrategy {
    /**
     *
     * @param target Target actor to follow when it is "radius" pixels away
     * @param radius Number of pixels away before the camera will follow
     */
    constructor(target, radius) {
        this.target = target;
        this.radius = radius;
        this.action = (target, cam, _eng, _delta) => {
            const position = target.center;
            const focus = cam.getFocus();
            const direction = position.sub(focus);
            const distance = direction.size;
            if (distance >= this.radius) {
                const offset = distance - this.radius;
                return focus.add(direction.normalize().scale(offset));
            }
            return focus;
        };
    }
}
/**
 * Prevent a camera from going beyond the given camera dimensions.
 */
class LimitCameraBoundsStrategy {
    constructor(target) {
        this.target = target;
        /**
         * Useful for limiting the camera to a [[TileMap]]'s dimensions, or a specific area inside the map.
         *
         * Note that this strategy does not perform any movement by itself.
         * It only sets the camera position to within the given bounds when the camera has gone beyond them.
         * Thus, it is a good idea to combine it with other camera strategies and set this strategy as the last one.
         *
         * Make sure that the camera bounds are at least as large as the viewport size.
         *
         * @param target The bounding box to limit the camera to
         */
        this.boundSizeChecked = false; // Check and warn only once
        this.action = (target, cam, _eng, _delta) => {
            const focus = cam.getFocus();
            if (!this.boundSizeChecked) {
                if (target.bottom - target.top < _eng.drawHeight || target.right - target.left < _eng.drawWidth) {
                    Logger.getInstance().warn('Camera bounds should not be smaller than the engine viewport');
                }
                this.boundSizeChecked = true;
            }
            let focusX = focus.x;
            let focusY = focus.y;
            if (focus.x < target.left + _eng.halfDrawWidth) {
                focusX = target.left + _eng.halfDrawWidth;
            }
            else if (focus.x > target.right - _eng.halfDrawWidth) {
                focusX = target.right - _eng.halfDrawWidth;
            }
            if (focus.y < target.top + _eng.halfDrawHeight) {
                focusY = target.top + _eng.halfDrawHeight;
            }
            else if (focus.y > target.bottom - _eng.halfDrawHeight) {
                focusY = target.bottom - _eng.halfDrawHeight;
            }
            return vec(focusX, focusY);
        };
    }
}
/**
 * Cameras
 *
 * [[Camera]] is the base class for all Excalibur cameras. Cameras are used
 * to move around your game and set focus. They are used to determine
 * what is "off screen" and can be used to scale the game.
 *
 */
class Camera extends Class {
    constructor() {
        super(...arguments);
        this._cameraStrategies = [];
        this.strategy = new StrategyContainer(this);
        /**
         * Get or set current zoom of the camera, defaults to 1
         */
        this._z = 1;
        /**
         * Get or set rate of change in zoom, defaults to 0
         */
        this.dz = 0;
        /**
         * Get or set zoom acceleration
         */
        this.az = 0;
        /**
         * Current rotation of the camera
         */
        this.rotation = 0;
        /**
         * Current angular velocity
         */
        this.rx = 0;
        /**
         * Get or set the camera's position
         */
        this._posChanged = false;
        this._pos = watchAny(Vector.Zero, () => (this._posChanged = true));
        /**
         * Get or set the camera's velocity
         */
        this.vel = Vector.Zero;
        /**
         * GEt or set the camera's acceleration
         */
        this.acc = Vector.Zero;
        this._cameraMoving = false;
        this._currentLerpTime = 0;
        this._lerpDuration = 1000; // 1 second
        this._lerpStart = null;
        this._lerpEnd = null;
        //camera effects
        this._isShaking = false;
        this._shakeMagnitudeX = 0;
        this._shakeMagnitudeY = 0;
        this._shakeDuration = 0;
        this._elapsedShakeTime = 0;
        this._xShake = 0;
        this._yShake = 0;
        this._isZooming = false;
        this._zoomStart = 1;
        this._zoomEnd = 1;
        this._currentZoomTime = 0;
        this._zoomDuration = 0;
        this._zoomEasing = EasingFunctions.EaseInOutCubic;
        this._easing = EasingFunctions.EaseInOutCubic;
        this._halfWidth = 0;
        this._halfHeight = 0;
        this._viewport = null;
        this._isInitialized = false;
    }
    get zoom() {
        return this._z;
    }
    set zoom(val) {
        this._z = val;
        if (this._engine) {
            this._halfWidth = this._engine.halfDrawWidth;
            this._halfHeight = this._engine.halfDrawHeight;
        }
    }
    /**
     * Get or set the camera's angular velocity
     */
    get angularVelocity() {
        return this.rx;
    }
    set angularVelocity(value) {
        this.rx = value;
    }
    get pos() {
        return this._pos;
    }
    set pos(vec) {
        this._pos = watchAny(vec, () => (this._posChanged = true));
        this._posChanged = true;
    }
    /**
     * Get the camera's x position
     */
    get x() {
        return this.pos.x;
    }
    /**
     * Set the camera's x position (cannot be set when following an [[Actor]] or when moving)
     */
    set x(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = vec(value, this.pos.y);
        }
    }
    /**
     * Get the camera's y position
     */
    get y() {
        return this.pos.y;
    }
    /**
     * Set the camera's y position (cannot be set when following an [[Actor]] or when moving)
     */
    set y(value) {
        if (!this._follow && !this._cameraMoving) {
            this.pos = vec(this.pos.x, value);
        }
    }
    /**
     * Get or set the camera's x velocity
     */
    get dx() {
        return this.vel.x;
    }
    set dx(value) {
        this.vel = vec(value, this.vel.y);
    }
    /**
     * Get or set the camera's y velocity
     */
    get dy() {
        return this.vel.y;
    }
    set dy(value) {
        this.vel = vec(this.vel.x, value);
    }
    /**
     * Get or set the camera's x acceleration
     */
    get ax() {
        return this.acc.x;
    }
    set ax(value) {
        this.acc = vec(value, this.acc.y);
    }
    /**
     * Get or set the camera's y acceleration
     */
    get ay() {
        return this.acc.y;
    }
    set ay(value) {
        this.acc = vec(this.acc.x, value);
    }
    /**
     * Returns the focal point of the camera, a new point giving the x and y position of the camera
     */
    getFocus() {
        return this.pos;
    }
    /**
     * This moves the camera focal point to the specified position using specified easing function. Cannot move when following an Actor.
     *
     * @param pos The target position to move to
     * @param duration The duration in milliseconds the move should last
     * @param [easingFn] An optional easing function ([[ex.EasingFunctions.EaseInOutCubic]] by default)
     * @returns A [[Promise]] that resolves when movement is finished, including if it's interrupted.
     *          The [[Promise]] value is the [[Vector]] of the target position. It will be rejected if a move cannot be made.
     */
    move(pos, duration, easingFn = EasingFunctions.EaseInOutCubic) {
        if (typeof easingFn !== 'function') {
            throw 'Please specify an EasingFunction';
        }
        // cannot move when following an actor
        if (this._follow) {
            return Promise.reject(pos);
        }
        // resolve existing promise, if any
        if (this._lerpPromise && this._lerpResolve) {
            this._lerpResolve(pos);
        }
        this._lerpPromise = new Promise((resolve) => {
            this._lerpResolve = resolve;
        });
        this._lerpStart = this.getFocus().clone();
        this._lerpDuration = duration;
        this._lerpEnd = pos;
        this._currentLerpTime = 0;
        this._cameraMoving = true;
        this._easing = easingFn;
        return this._lerpPromise;
    }
    /**
     * Sets the camera to shake at the specified magnitudes for the specified duration
     * @param magnitudeX  The x magnitude of the shake
     * @param magnitudeY  The y magnitude of the shake
     * @param duration    The duration of the shake in milliseconds
     */
    shake(magnitudeX, magnitudeY, duration) {
        this._isShaking = true;
        this._shakeMagnitudeX = magnitudeX;
        this._shakeMagnitudeY = magnitudeY;
        this._shakeDuration = duration;
    }
    /**
     * Zooms the camera in or out by the specified scale over the specified duration.
     * If no duration is specified, it take effect immediately.
     * @param scale    The scale of the zoom
     * @param duration The duration of the zoom in milliseconds
     */
    zoomOverTime(scale, duration = 0, easingFn = EasingFunctions.EaseInOutCubic) {
        this._zoomPromise = new Promise((resolve) => {
            this._zoomResolve = resolve;
        });
        if (duration) {
            this._isZooming = true;
            this._zoomEasing = easingFn;
            this._currentZoomTime = 0;
            this._zoomDuration = duration;
            this._zoomStart = this.zoom;
            this._zoomEnd = scale;
        }
        else {
            this._isZooming = false;
            this.zoom = scale;
            return Promise.resolve(true);
        }
        return this._zoomPromise;
    }
    /**
     * Gets the bounding box of the viewport of this camera in world coordinates
     */
    get viewport() {
        if (this._viewport) {
            return this._viewport;
        }
        return new BoundingBox(0, 0, 0, 0);
    }
    /**
     * Adds a new camera strategy to this camera
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    addStrategy(cameraStrategy) {
        this._cameraStrategies.push(cameraStrategy);
    }
    /**
     * Removes a camera strategy by reference
     * @param cameraStrategy Instance of an [[CameraStrategy]]
     */
    removeStrategy(cameraStrategy) {
        removeItemFromArray(cameraStrategy, this._cameraStrategies);
    }
    /**
     * Clears all camera strategies from the camera
     */
    clearAllStrategies() {
        this._cameraStrategies.length = 0;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(engine, delta, this));
        this.onPreUpdate(engine, delta);
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // Overridable
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(engine, delta, this));
        this.onPostUpdate(engine, delta);
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // Overridable
    }
    get isInitialized() {
        return this._isInitialized;
    }
    _initialize(_engine) {
        if (!this.isInitialized) {
            this._engine = _engine;
            const currentRes = this._engine.screen.resolution;
            let center = vec(currentRes.width / 2, currentRes.height / 2);
            if (!this._engine.loadingComplete) {
                // If there was a loading screen, we peek the configured resolution
                const res = this._engine.screen.peekResolution();
                if (res) {
                    center = vec(res.width / 2, res.height / 2);
                }
            }
            this._halfWidth = center.x;
            this._halfHeight = center.x;
            // If the user has not set the camera pos, apply default center screen position
            if (!this._posChanged) {
                this.pos = center;
            }
            this.onInitialize(_engine);
            super.emit('initialize', new InitializeEvent(_engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onInitialize(_engine) {
        // Overridable
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    update(_engine, delta) {
        this._initialize(_engine);
        this._preupdate(_engine, delta);
        // Update placements based on linear algebra
        this.pos = this.pos.add(this.vel.scale(delta / 1000));
        this.zoom += (this.dz * delta) / 1000;
        this.vel = this.vel.add(this.acc.scale(delta / 1000));
        this.dz += (this.az * delta) / 1000;
        this.rotation += (this.angularVelocity * delta) / 1000;
        if (this._isZooming) {
            if (this._currentZoomTime < this._zoomDuration) {
                const zoomEasing = this._zoomEasing;
                const newZoom = zoomEasing(this._currentZoomTime, this._zoomStart, this._zoomEnd, this._zoomDuration);
                this.zoom = newZoom;
                this._currentZoomTime += delta;
            }
            else {
                this._isZooming = false;
                this.zoom = this._zoomEnd;
                this._currentZoomTime = 0;
                this._zoomResolve(true);
            }
        }
        if (this._cameraMoving) {
            if (this._currentLerpTime < this._lerpDuration) {
                const moveEasing = EasingFunctions.CreateVectorEasingFunction(this._easing);
                const lerpPoint = moveEasing(this._currentLerpTime, this._lerpStart, this._lerpEnd, this._lerpDuration);
                this.pos = lerpPoint;
                this._currentLerpTime += delta;
            }
            else {
                this.pos = this._lerpEnd;
                const end = this._lerpEnd.clone();
                this._lerpStart = null;
                this._lerpEnd = null;
                this._currentLerpTime = 0;
                this._cameraMoving = false;
                // Order matters here, resolve should be last so any chain promises have a clean slate
                this._lerpResolve(end);
            }
        }
        if (this._isDoneShaking()) {
            this._isShaking = false;
            this._elapsedShakeTime = 0;
            this._shakeMagnitudeX = 0;
            this._shakeMagnitudeY = 0;
            this._shakeDuration = 0;
            this._xShake = 0;
            this._yShake = 0;
        }
        else {
            this._elapsedShakeTime += delta;
            this._xShake = ((Math.random() * this._shakeMagnitudeX) | 0) + 1;
            this._yShake = ((Math.random() * this._shakeMagnitudeY) | 0) + 1;
        }
        for (const s of this._cameraStrategies) {
            this.pos = s.action.call(s, s.target, this, _engine, delta);
        }
        this._viewport = new BoundingBox(this.x - this._halfWidth, this.y - this._halfHeight, this.x + this._halfWidth, this.y + this._halfHeight);
        this._postupdate(_engine, delta);
    }
    draw(ctx) {
        let canvasWidth = 0;
        let canvasHeight = 0;
        if (ctx instanceof CanvasRenderingContext2D) {
            canvasWidth = ctx.canvas.width;
            canvasHeight = ctx.canvas.height;
        }
        else {
            canvasWidth = ctx.width;
            canvasHeight = ctx.height;
        }
        const focus = this.getFocus();
        const pixelRatio = this._engine ? this._engine.pixelRatio : 1;
        const zoom = this.zoom;
        const newCanvasWidth = canvasWidth / zoom / pixelRatio;
        const newCanvasHeight = canvasHeight / zoom / pixelRatio;
        ctx.scale(zoom, zoom);
        ctx.translate(-focus.x + newCanvasWidth / 2 + this._xShake, -focus.y + newCanvasHeight / 2 + this._yShake);
    }
    /* istanbul ignore next */
    debugDraw(_ctx) {
        // pass
    }
    _isDoneShaking() {
        return !this._isShaking || this._elapsedShakeTime >= this._shakeDuration;
    }
}

;// CONCATENATED MODULE: ./Util/Actors.ts



/**
 * Type guard to detect if something is an actor
 * @deprecated Will be removed in v0.26.0
 * @param actor
 */
function isVanillaActor(actor) {
    return !(actor instanceof ScreenElement) && !(actor instanceof Trigger) && !(actor instanceof Label);
}
/**
 * Type guard to detect a screen element
 * @todo move to ScreenElement
 */
function isScreenElement(actor) {
    return actor instanceof ScreenElement_ScreenElement;
}

;// CONCATENATED MODULE: ./Trigger.ts







const triggerDefaults = {
    pos: Vector.Zero,
    width: 10,
    height: 10,
    visible: false,
    action: () => {
        return;
    },
    filter: () => true,
    repeat: -1
};
/**
 * Triggers are a method of firing arbitrary code on collision. These are useful
 * as 'buttons', 'switches', or to trigger effects in a game. By default triggers
 * are invisible, and can only be seen when [[Trigger.visible]] is set to `true`.
 */
class Trigger_Trigger extends Actor {
    /**
     *
     * @param opts Trigger options
     */
    constructor(opts) {
        super({ x: opts.pos.x, y: opts.pos.y, width: opts.width, height: opts.height });
        /**
         * Action to fire when triggered by collision
         */
        this.action = () => {
            return;
        };
        /**
         * Filter to add additional granularity to action dispatch, if a filter is specified the action will only fire when
         * filter return true for the collided actor.
         */
        this.filter = () => true;
        /**
         * Number of times to repeat before killing the trigger,
         */
        this.repeat = -1;
        opts = extend({}, triggerDefaults, opts);
        this.filter = opts.filter || this.filter;
        this.repeat = opts.repeat || this.repeat;
        this.action = opts.action || this.action;
        if (opts.target) {
            this.target = opts.target;
        }
        this.graphics.visible = opts.visible;
        this.body.collisionType = CollisionType.Passive;
        this.eventDispatcher = new EventDispatcher(this);
        this.events.on('collisionstart', (evt) => {
            if (this.filter(evt.other)) {
                this.emit('enter', new EnterTriggerEvent(this, evt.other));
                this._dispatchAction();
                // remove trigger if its done, -1 repeat forever
                if (this.repeat === 0) {
                    this.kill();
                }
            }
        });
        this.events.on('collisionend', (evt) => {
            if (this.filter(evt.other)) {
                this.emit('exit', new ExitTriggerEvent(this, evt.other));
            }
        });
    }
    set target(target) {
        this._target = target;
        this.filter = (actor) => actor === target;
    }
    get target() {
        return this._target;
    }
    _initialize(engine) {
        super._initialize(engine);
    }
    _dispatchAction() {
        if (this.repeat !== 0) {
            this.action.call(this);
            this.repeat--;
        }
    }
    /* istanbul ignore next */
    debugDraw(ctx) {
        super.debugDraw(ctx);
        // Meant to draw debug information about actors
        ctx.save();
        ctx.translate(this.pos.x, this.pos.y);
        const bb = this.collider.bounds;
        const wp = this.getGlobalPos();
        bb.left = bb.left - wp.x;
        bb.right = bb.right - wp.x;
        bb.top = bb.top - wp.y;
        bb.bottom = bb.bottom - wp.y;
        ctx.fillStyle = Color.Violet.toString();
        ctx.strokeStyle = Color.Violet.toString();
        ctx.fillText('Trigger', 10, 10);
        bb.debugDraw(ctx);
        ctx.restore();
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/System.ts
/**
 * Enum that determines whether to run the system in the update or draw phase
 */
var SystemType;
(function (SystemType) {
    SystemType["Update"] = "update";
    SystemType["Draw"] = "draw";
})(SystemType || (SystemType = {}));
/**
 * An Excalibur [[System]] that updates entities of certain types.
 * Systems are scene specific
 *
 * Excalibur Systems currently require at least 1 Component type to operated
 *
 * Multiple types are declared as a type union
 * For example:
 *
 * ```typescript
 * class MySystem extends System<ComponentA | ComponentB> {
 *   public readonly types = ['a', 'b'] as const;
 *   public readonly systemType = SystemType.Update;
 *   public update(entities: Entity<ComponentA | ComponentB>) {
 *      ...
 *   }
 * }
 * ```
 */
class System {
    constructor() {
        /**
         * System can execute in priority order, by default all systems are priority 0. Lower values indicated higher priority.
         * For a system to execute before all other a lower priority value (-1 for example) must be set.
         * For a system to exectue after all other a higher priority value (10 for example) must be set.
         */
        this.priority = 0;
    }
    /**
     * Systems observe when entities match their types or no longer match their types, override
     * @param _entityAddedOrRemoved
     */
    notify(_entityAddedOrRemoved) {
        // Override me
    }
}
/**
 * An [[Entity]] with [[Component]] types that matches a [[System]] types exists in the current scene.
 */
class AddedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Added';
    }
}
/**
 * Type guard to check for AddedEntity messages
 * @param x
 */
function isAddedSystemEntity(x) {
    return !!x && x.type === 'Entity Added';
}
/**
 * An [[Entity]] with [[Component]] types that no longer matches a [[System]] types exists in the current scene.
 */
class RemovedEntity {
    constructor(data) {
        this.data = data;
        this.type = 'Entity Removed';
    }
}
/**
 * type guard to check for the RemovedEntity message
 */
function isRemoveSystemEntity(x) {
    return !!x && x.type === 'Entity Removed';
}

;// CONCATENATED MODULE: ./EntityComponentSystem/EntityManager.ts


// Add/Remove entitys and components
class EntityManager {
    constructor(_world) {
        this._world = _world;
        this.entities = [];
        this._entityIndex = {};
        this._entitiesToRemove = [];
    }
    /**
     * Runs the entity lifecycle
     * @param _context
     */
    updateEntities(_context, elapsed) {
        for (const entity of this.entities) {
            // TODO is this right?
            entity.update(_context.engine, elapsed);
            if (!entity.active) {
                this.removeEntity(entity);
            }
        }
    }
    findEntitiesForRemoval() {
        for (const entity of this.entities) {
            if (!entity.active) {
                this.removeEntity(entity);
            }
        }
    }
    /**
     * EntityManager observes changes on entities
     * @param message
     */
    notify(message) {
        if (isAddedComponent(message)) {
            // we don't need the component, it's already on the entity
            this._world.queryManager.addEntity(message.data.entity);
        }
        if (isRemovedComponent(message)) {
            this._world.queryManager.removeComponent(message.data.entity, message.data.component);
        }
    }
    /**
     * Adds an entity to be tracked by the EntityManager
     * @param entity
     */
    addEntity(entity) {
        entity.active = true;
        if (entity && !this._entityIndex[entity.id]) {
            this._entityIndex[entity.id] = entity;
            this.entities.push(entity);
            this._world.queryManager.addEntity(entity);
            entity.componentAdded$.register(this);
            entity.componentRemoved$.register(this);
            // if entity has children
            entity.children.forEach((c) => this.addEntity(c));
            entity.childrenAdded$.register({
                notify: (e) => {
                    this.addEntity(e);
                }
            });
            entity.childrenRemoved$.register({
                notify: (e) => {
                    this.removeEntity(e, false);
                }
            });
        }
    }
    removeEntity(idOrEntity, deferred = true) {
        var _a;
        let id = 0;
        if (idOrEntity instanceof Entity) {
            id = idOrEntity.id;
        }
        else {
            id = idOrEntity;
        }
        const entity = this._entityIndex[id];
        if (entity && entity.active) {
            entity.kill();
        }
        if (entity && deferred) {
            this._entitiesToRemove.push(entity);
            return;
        }
        delete this._entityIndex[id];
        if (entity) {
            removeItemFromArray(entity, this.entities);
            this._world.queryManager.removeEntity(entity);
            entity.componentAdded$.unregister(this);
            entity.componentRemoved$.unregister(this);
            // if entity has children
            entity.children.forEach((c) => this.removeEntity(c, deferred));
            entity.childrenAdded$.clear();
            entity.childrenRemoved$.clear();
            // stats
            if ((_a = this._world.context) === null || _a === void 0 ? void 0 : _a.engine) {
                this._world.context.engine.stats.currFrame.actors.killed++;
            }
        }
    }
    processEntityRemovals() {
        for (const entity of this._entitiesToRemove) {
            if (entity.active) {
                continue;
            }
            this.removeEntity(entity, false);
        }
    }
    processComponentRemovals() {
        for (const entity of this.entities) {
            entity.processComponentRemoval();
        }
    }
    getById(id) {
        return this._entityIndex[id];
    }
    getByName(name) {
        return this.entities.filter(e => e.name === name);
    }
    clear() {
        for (const entity of this.entities) {
            this.removeEntity(entity);
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/Util.ts
const buildTypeKey = (types) => {
    const key = [...types].sort((a, b) => a.localeCompare(b)).join('+');
    return key;
};

;// CONCATENATED MODULE: ./EntityComponentSystem/Query.ts





/**
 * Represents query for entities that match a list of types that is cached and observable
 *
 * Queries can be strongly typed by supplying a type union in the optional type parameter
 * ```typescript
 * const queryAB = new ex.Query<ComponentTypeA | ComponentTypeB>(['A', 'B']);
 * ```
 */
class Query extends Observable {
    constructor(types) {
        super();
        this._entities = [];
        if (types[0] instanceof Function) {
            this.types = types.map(T => (new T).type);
        }
        else {
            this.types = types;
        }
    }
    get key() {
        if (this._key) {
            return this._key;
        }
        return (this._key = buildTypeKey(this.types));
    }
    /**
     * Returns a list of entities that match the query
     *
     * @param sort Optional sorting function to sort entities returned from the query
     */
    getEntities(sort) {
        if (sort) {
            this._entities.sort(sort);
        }
        return this._entities;
    }
    /**
     * Add an entity to the query, will only be added if the entity matches the query types
     * @param entity
     */
    addEntity(entity) {
        if (!contains(this._entities, entity) && this.matches(entity)) {
            this._entities.push(entity);
            this.notifyAll(new AddedEntity(entity));
        }
    }
    /**
     * If the entity is part of the query it will be removed regardless of types
     * @param entity
     */
    removeEntity(entity) {
        if (removeItemFromArray(entity, this._entities)) {
            this.notifyAll(new RemovedEntity(entity));
        }
    }
    /**
     * Removes all entities and observers from the query
     */
    clear() {
        this._entities.length = 0;
        for (const observer of this.observers) {
            this.unregister(observer);
        }
    }
    matches(typesOrEntity) {
        let types = [];
        if (typesOrEntity instanceof Entity) {
            types = typesOrEntity.types;
        }
        else {
            types = typesOrEntity;
        }
        let matches = true;
        for (const type of this.types) {
            matches = matches && types.indexOf(type) > -1;
            if (!matches) {
                return false;
            }
        }
        return matches;
    }
    contain(type) {
        return this.types.indexOf(type) > -1;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/QueryManager.ts


/**
 * The query manager is responsible for updating all queries when entities/components change
 */
class QueryManager {
    constructor(_world) {
        this._world = _world;
        this._queries = {};
    }
    /**
     * Adds a query to the manager and populates with any entities that match
     * @param query
     */
    _addQuery(query) {
        this._queries[buildTypeKey(query.types)] = query;
        for (const entity of this._world.entityManager.entities) {
            query.addEntity(entity);
        }
    }
    /**
     * Removes the query if there are no observers left
     * @param query
     */
    maybeRemoveQuery(query) {
        if (query.observers.length === 0) {
            query.clear();
            delete this._queries[buildTypeKey(query.types)];
        }
    }
    /**
     * Adds the entity to any matching query in the query manage
     * @param entity
     */
    addEntity(entity) {
        for (const queryType in this._queries) {
            if (this._queries[queryType]) {
                this._queries[queryType].addEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from queries if the removed component disqualifies it
     * @param entity
     * @param component
     */
    removeComponent(entity, component) {
        for (const queryType in this._queries) {
            // If the component being removed from an entity is a part of a query,
            // it is now disqualified from that query, remove it
            if (this._queries[queryType].contain(component.type)) {
                this._queries[queryType].removeEntity(entity);
            }
        }
    }
    /**
     * Removes an entity from all queries it is currently a part of
     * @param entity
     */
    removeEntity(entity) {
        for (const queryType in this._queries) {
            this._queries[queryType].removeEntity(entity);
        }
    }
    /**
     * Creates a populated query and returns, if the query already exists that will be returned instead of a new instance
     * @param types
     */
    createQuery(types) {
        const maybeExistingQuery = this.getQuery(types);
        if (maybeExistingQuery) {
            return maybeExistingQuery;
        }
        const query = new Query(types);
        this._addQuery(query);
        return query;
    }
    /**
     * Retrieves an existing query by types if it exists otherwise returns null
     * @param types
     */
    getQuery(types) {
        const key = buildTypeKey(types);
        if (this._queries[key]) {
            return this._queries[key];
        }
        return null;
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/SystemManager.ts

/**
 * The SystemManager is responsible for keeping track of all systems in a scene.
 * Systems are scene specific
 */
class SystemManager {
    constructor(_world) {
        this._world = _world;
        /**
         * List of systems, to add a new system call [[SystemManager.addSystem]]
         */
        this.systems = [];
        this.initialized = false;
    }
    /**
     * Get a system registered in the manager by type
     * @param systemType
     * @returns
     */
    get(systemType) {
        return this.systems.find((s) => s instanceof systemType);
    }
    /**
     * Adds a system to the manager, it will now be updated every frame
     * @param system
     */
    addSystem(system) {
        // validate system has types
        if (!system.types || system.types.length === 0) {
            throw new Error(`Attempted to add a System without any types`);
        }
        const query = this._world.queryManager.createQuery(system.types);
        this.systems.push(system);
        this.systems.sort((a, b) => a.priority - b.priority);
        query.register(system);
        if (this.initialized && system.initialize) {
            system.initialize(this._world.context);
        }
    }
    /**
     * Removes a system from the manager, it will no longer be updated
     * @param system
     */
    removeSystem(system) {
        removeItemFromArray(system, this.systems);
        const query = this._world.queryManager.getQuery(system.types);
        if (query) {
            query.unregister(system);
            this._world.queryManager.maybeRemoveQuery(query);
        }
    }
    /**
     * Updates all systems
     * @param type whether this is an update or draw system
     * @param context context reference
     * @param delta time in milliseconds
     */
    updateSystems(type, context, delta) {
        if (!this.initialized) {
            this.initialized = true;
            for (const s of this.systems) {
                if (s.initialize) {
                    s.initialize(this._world.context);
                }
            }
        }
        const systems = this.systems.filter((s) => s.systemType === type);
        for (const s of systems) {
            if (s.preupdate) {
                s.preupdate(context, delta);
            }
        }
        for (const s of systems) {
            // Get entities that match the system types, pre-sort
            const entities = this._world.queryManager.getQuery(s.types).getEntities(s.sort);
            // Initialize entities if needed
            if (context instanceof Scene) {
                for (const entity of entities) {
                    entity._initialize(context === null || context === void 0 ? void 0 : context.engine);
                }
            }
            s.update(entities, delta);
        }
        for (const s of systems) {
            if (s.postupdate) {
                s.postupdate(context, delta);
            }
        }
    }
    clear() {
        for (const system of this.systems) {
            this.removeSystem(system);
        }
    }
}

;// CONCATENATED MODULE: ./EntityComponentSystem/World.ts





/**
 * The World is a self-contained entity component system for a particular context.
 */
class World {
    /**
     * The context type is passed to the system updates
     * @param context
     */
    constructor(context) {
        this.context = context;
        this.queryManager = new QueryManager(this);
        this.entityManager = new EntityManager(this);
        this.systemManager = new SystemManager(this);
    }
    /**
     * Update systems by type and time elapsed in milliseconds
     */
    update(type, delta) {
        if (type === SystemType.Update) {
            this.entityManager.updateEntities(this.context, delta);
        }
        this.systemManager.updateSystems(type, this.context, delta);
        this.entityManager.findEntitiesForRemoval();
        this.entityManager.processComponentRemovals();
        this.entityManager.processEntityRemovals();
    }
    add(entityOrSystem) {
        if (entityOrSystem instanceof Entity) {
            this.entityManager.addEntity(entityOrSystem);
        }
        if (entityOrSystem instanceof System) {
            this.systemManager.addSystem(entityOrSystem);
        }
    }
    remove(entityOrSystem, deferred = true) {
        if (entityOrSystem instanceof Entity) {
            this.entityManager.removeEntity(entityOrSystem, deferred);
        }
        if (entityOrSystem instanceof System) {
            this.systemManager.removeSystem(entityOrSystem);
        }
    }
    clearEntities() {
        this.entityManager.clear();
    }
    clearSystems() {
        this.systemManager.clear();
    }
}

;// CONCATENATED MODULE: ./Collision/Integrator.ts
class EulerIntegrator {
    static integrate(transform, motion, totalAcc, elapsedMs) {
        const seconds = elapsedMs / 1000;
        motion.vel.addEqual(totalAcc.scale(seconds));
        transform.pos.addEqual(motion.vel.scale(seconds)).addEqual(totalAcc.scale(0.5 * seconds * seconds));
        motion.angularVelocity += motion.torque * (1.0 / motion.inertia) * seconds;
        transform.rotation += motion.angularVelocity * seconds;
        transform.scale.addEqual(motion.scaleFactor.scale(seconds));
    }
}

;// CONCATENATED MODULE: ./Collision/MotionSystem.ts







class MotionSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.motion'];
        this.systemType = SystemType.Update;
        this.priority = -1;
    }
    update(_entities, elapsedMs) {
        let transform;
        let motion;
        for (const entity of _entities) {
            transform = entity.get(TransformComponent);
            motion = entity.get(MotionComponent);
            const optionalBody = entity.get(BodyComponent);
            if (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.sleeping) {
                continue;
            }
            const totalAcc = motion.acc.clone();
            if ((optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.collisionType) === CollisionType.Active && (optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.useGravity)) {
                totalAcc.addEqual(Physics.gravity);
            }
            optionalBody === null || optionalBody === void 0 ? void 0 : optionalBody.captureOldTransform();
            // Update transform and motion based on Euler linear algebra
            EulerIntegrator.integrate(transform, motion, totalAcc, elapsedMs);
        }
    }
    debugDraw(_ctx) {
        // pass
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/Solver.ts
/**
 * A collision solver figures out how to position colliders such that they are no longer overlapping
 *
 * Solvers are executed in the order
 *
 * 1. preSolve
 * 2. solveVelocity
 * 3. solvePosition
 * 4. postSolve
 * @inheritdoc
 */
class CollisionSolver {
    /**
     * Solves overlapping contact in
     *
     * Solvers are executed in the order
     * 1. preSolve
     * 2. solveVelocity
     * 3. solvePosition
     * 4. postSolve
     * @param contacts
     */
    solve(contacts) {
        // Events and init
        this.preSolve(contacts);
        // Remove any canceled contacts
        contacts = contacts.filter(c => !c.isCanceled());
        // Solve velocity first
        this.solveVelocity(contacts);
        // Solve position last because non-overlap is the most important
        this.solvePosition(contacts);
        // Events and any contact house-keeping the solver needs
        this.postSolve(contacts);
        return contacts;
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/ArcadeSolver.ts





/**
 * ArcadeSolver is the default in Excalibur. It solves collisions so that there is no overlap between contacts,
 * and negates velocity along the collision normal.
 *
 * This is usually the type of collisions used for 2D games that don't need a more realistic collision simulation.
 *
 */
class ArcadeSolver extends CollisionSolver {
    preSolve(contacts) {
        for (const contact of contacts) {
            const side = Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            // Publish collision events on both participants
            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
        }
    }
    postSolve(contacts) {
        var _a, _b;
        for (const contact of contacts) {
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
            }
            const side = Side.fromDirection(contact.mtv);
            const mtv = contact.mtv.negate();
            // Publish collision events on both participants
            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, mtv));
            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), mtv.negate()));
        }
    }
    solvePosition(contacts) {
        var _a, _b;
        for (const contact of contacts) {
            let mtv = contact.mtv;
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
                if (bodyA.collisionType === CollisionType.Active && bodyB.collisionType === CollisionType.Active) {
                    // split overlaps if both are Active
                    mtv = mtv.scale(0.5);
                }
                // Resolve overlaps
                if (bodyA.collisionType === CollisionType.Active) {
                    bodyA.pos.x -= mtv.x;
                    bodyA.pos.y -= mtv.y;
                }
                if (bodyB.collisionType === CollisionType.Active) {
                    bodyB.pos.x += mtv.x;
                    bodyB.pos.y += mtv.y;
                }
            }
        }
    }
    solveVelocity(contacts) {
        var _a, _b;
        for (const contact of contacts) {
            const colliderA = contact.colliderA;
            const colliderB = contact.colliderB;
            const bodyA = (_a = colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
                const normal = contact.normal;
                const opposite = normal.negate();
                // Cancel out velocity opposite direction of collision normal
                if (bodyA.collisionType === CollisionType.Active) {
                    const velAdj = normal.scale(normal.dot(bodyA.vel.negate()));
                    bodyA.vel = bodyA.vel.add(velAdj);
                }
                if (bodyB.collisionType === CollisionType.Active) {
                    const velAdj = opposite.scale(opposite.dot(bodyB.vel.negate()));
                    bodyB.vel = bodyB.vel.add(velAdj);
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/ContactConstraintPoint.ts


/**
 * Holds information about contact points, meant to be reused over multiple frames of contact
 */
class ContactConstraintPoint {
    constructor(point, local, contact) {
        this.point = point;
        this.local = local;
        this.contact = contact;
        /**
         * Impulse accumulated over time in normal direction
         */
        this.normalImpulse = 0;
        /**
         * Impulse accumulated over time in the tangent direction
         */
        this.tangentImpulse = 0;
        /**
         * Effective mass seen in the normal direction
         */
        this.normalMass = 0;
        /**
         * Effective mass seen in the tangent direction
         */
        this.tangentMass = 0;
        /**
         * Direction from center of mass of bodyA to contact point
         */
        this.aToContact = new Vector(0, 0);
        /**
         * Direction from center of mass of bodyB to contact point
         */
        this.bToContact = new Vector(0, 0);
        this.update();
    }
    /**
     * Updates the contact information
     */
    update() {
        var _a, _b;
        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            const normal = this.contact.normal;
            const tangent = this.contact.tangent;
            this.aToContact = this.point.sub(bodyA.pos);
            this.bToContact = this.point.sub(bodyB.pos);
            const aToContactNormal = this.aToContact.cross(normal);
            const bToContactNormal = this.bToContact.cross(normal);
            this.normalMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                    bodyB.inverseInertia * bToContactNormal * bToContactNormal;
            const aToContactTangent = this.aToContact.cross(tangent);
            const bToContactTangent = this.bToContact.cross(tangent);
            this.tangentMass =
                bodyA.inverseMass +
                    bodyB.inverseMass +
                    bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                    bodyB.inverseInertia * bToContactTangent * bToContactTangent;
        }
        return this;
    }
    /**
     * Returns the relative velocity betwen bodyA and bodyB
     */
    getRelativeVelocity() {
        var _a, _b;
        const bodyA = (_a = this.contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
        const bodyB = (_b = this.contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
        if (bodyA && bodyB) {
            // Relative velocity in linear terms
            // Angular to linear velocity formula -> omega = velocity/radius so omega x radius = velocity
            const velA = bodyA.vel.add(Vector.cross(bodyA.angularVelocity, this.aToContact));
            const velB = bodyB.vel.add(Vector.cross(bodyB.angularVelocity, this.bToContact));
            return velB.sub(velA);
        }
        return Vector.Zero;
    }
}

;// CONCATENATED MODULE: ./Collision/Solver/RealisticSolver.ts









class RealisticSolver extends CollisionSolver {
    constructor() {
        super(...arguments);
        this.lastFrameContacts = new Map();
        // map contact id to contact points
        this.idToContactConstraint = new Map();
    }
    getContactConstraints(id) {
        var _a;
        return (_a = this.idToContactConstraint.get(id)) !== null && _a !== void 0 ? _a : [];
    }
    preSolve(contacts) {
        var _a, _b, _c;
        for (const contact of contacts) {
            // Publish collision events on both participants
            const side = Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('precollision', new PreCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
            contact.colliderA.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('precollision', new PreCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
            contact.colliderB.events.emit('beforecollisionresolve', new CollisionPreSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
            // Match awake state for sleeping
            contact.matchAwake();
        }
        // Keep track of contacts that done
        const finishedContactIds = Array.from(this.idToContactConstraint.keys());
        for (const contact of contacts) {
            // Remove all current contacts that are not done
            const index = finishedContactIds.indexOf(contact.id);
            if (index > -1) {
                finishedContactIds.splice(index, 1);
            }
            const contactPoints = (_a = this.idToContactConstraint.get(contact.id)) !== null && _a !== void 0 ? _a : [];
            let pointIndex = 0;
            const bodyA = contact.colliderA.owner.get(BodyComponent);
            const bodyB = contact.colliderB.owner.get(BodyComponent);
            if (bodyA && bodyB) {
                for (const point of contact.points) {
                    const normal = contact.normal;
                    const tangent = contact.tangent;
                    const aToContact = point.sub(bodyA.pos);
                    const bToContact = point.sub(bodyB.pos);
                    const aToContactNormal = aToContact.cross(normal);
                    const bToContactNormal = bToContact.cross(normal);
                    const normalMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactNormal * aToContactNormal +
                        bodyB.inverseInertia * bToContactNormal * bToContactNormal;
                    const aToContactTangent = aToContact.cross(tangent);
                    const bToContactTangent = bToContact.cross(tangent);
                    const tangentMass = bodyA.inverseMass +
                        bodyB.inverseMass +
                        bodyA.inverseInertia * aToContactTangent * aToContactTangent +
                        bodyB.inverseInertia * bToContactTangent * bToContactTangent;
                    // Preserve normal/tangent impulse by re-using the contact point if it's close
                    if (contactPoints[pointIndex] && ((_c = (_b = contactPoints[pointIndex]) === null || _b === void 0 ? void 0 : _b.point) === null || _c === void 0 ? void 0 : _c.squareDistance(point)) < 4) {
                        contactPoints[pointIndex].point = point;
                        contactPoints[pointIndex].local = contact.localPoints[pointIndex];
                    }
                    else {
                        // new contact if it's not close or doesn't exist
                        contactPoints[pointIndex] = new ContactConstraintPoint(point, contact.localPoints[pointIndex], contact);
                    }
                    // Update contact point calculations
                    contactPoints[pointIndex].aToContact = aToContact;
                    contactPoints[pointIndex].bToContact = bToContact;
                    contactPoints[pointIndex].normalMass = normalMass;
                    contactPoints[pointIndex].tangentMass = tangentMass;
                    pointIndex++;
                }
            }
            this.idToContactConstraint.set(contact.id, contactPoints);
        }
        // Clean up any contacts that did not occur last frame
        for (const id of finishedContactIds) {
            this.idToContactConstraint.delete(id);
        }
        // Warm contacts with accumulated impulse
        // Useful for tall stacks
        if (Physics.warmStart) {
            this.warmStart(contacts);
        }
        else {
            for (const contact of contacts) {
                const contactPoints = this.getContactConstraints(contact.id);
                for (const point of contactPoints) {
                    point.normalImpulse = 0;
                    point.tangentImpulse = 0;
                }
            }
        }
    }
    postSolve(contacts) {
        for (const contact of contacts) {
            const bodyA = contact.colliderA.owner.get(BodyComponent);
            const bodyB = contact.colliderB.owner.get(BodyComponent);
            if (bodyA && bodyB) {
                // Skip post solve for active+passive collisions
                if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                    continue;
                }
                // Update motion values for sleeping
                bodyA.updateMotion();
                bodyB.updateMotion();
            }
            // Publish collision events on both participants
            const side = Side.fromDirection(contact.mtv);
            contact.colliderA.events.emit('postcollision', new PostCollisionEvent(contact.colliderA, contact.colliderB, side, contact.mtv));
            contact.colliderA.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderA, contact.colliderB, side, contact.mtv, contact));
            contact.colliderB.events.emit('postcollision', new PostCollisionEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate()));
            contact.colliderB.events.emit('aftercollisionresolve', new CollisionPostSolveEvent(contact.colliderB, contact.colliderA, Side.getOpposite(side), contact.mtv.negate(), contact));
        }
        // Store contacts
        this.lastFrameContacts.clear();
        for (const c of contacts) {
            this.lastFrameContacts.set(c.id, c);
        }
    }
    /**
     * Warm up body's based on previous frame contact points
     * @param contacts
     */
    warmStart(contacts) {
        var _a, _b, _c;
        for (const contact of contacts) {
            const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
            const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
            if (bodyA && bodyB) {
                const contactPoints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                for (const point of contactPoints) {
                    if (Physics.warmStart) {
                        const normalImpulse = contact.normal.scale(point.normalImpulse);
                        const tangentImpulse = contact.tangent.scale(point.tangentImpulse);
                        const impulse = normalImpulse.add(tangentImpulse);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    else {
                        point.normalImpulse = 0;
                        point.tangentImpulse = 0;
                    }
                }
            }
        }
    }
    /**
     * Iteratively solve the position overlap constraint
     * @param contacts
     */
    solvePosition(contacts) {
        var _a, _b, _c;
        for (let i = 0; i < Physics.positionIterations; i++) {
            for (const contact of contacts) {
                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                        continue;
                    }
                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                    for (const point of constraints) {
                        const normal = contact.normal;
                        const separation = CollisionJumpTable.FindContactSeparation(contact, point.local);
                        const steeringConstant = Physics.steeringFactor; //0.2;
                        const maxCorrection = -5;
                        const slop = Physics.slop; //1;
                        // Clamp to avoid over-correction
                        // Remember that we are shooting for 0 overlap in the end
                        const steeringForce = clamp(steeringConstant * (separation + slop), maxCorrection, 0);
                        const impulse = normal.scale(-steeringForce / point.normalMass);
                        // This is a pseudo impulse, meaning we aren't doing a real impulse calculation
                        // We adjust position and rotation instead of doing the velocity
                        if (bodyA.collisionType === CollisionType.Active) {
                            bodyA.pos = bodyA.pos.add(impulse.negate().scale(bodyA.inverseMass));
                            bodyA.rotation -= point.aToContact.cross(impulse) * bodyA.inverseInertia;
                        }
                        if (bodyB.collisionType === CollisionType.Active) {
                            bodyB.pos = bodyB.pos.add(impulse.scale(bodyB.inverseMass));
                            bodyB.rotation += point.bToContact.cross(impulse) * bodyB.inverseInertia;
                        }
                    }
                }
            }
        }
    }
    solveVelocity(contacts) {
        var _a, _b, _c;
        for (let i = 0; i < Physics.velocityIterations; i++) {
            for (const contact of contacts) {
                const bodyA = (_a = contact.colliderA.owner) === null || _a === void 0 ? void 0 : _a.get(BodyComponent);
                const bodyB = (_b = contact.colliderB.owner) === null || _b === void 0 ? void 0 : _b.get(BodyComponent);
                if (bodyA && bodyB) {
                    // Skip solving active+passive
                    if (bodyA.collisionType === CollisionType.Passive || bodyB.collisionType === CollisionType.Passive) {
                        continue;
                    }
                    const restitution = bodyA.bounciness * bodyB.bounciness;
                    const friction = Math.min(bodyA.friction, bodyB.friction);
                    const constraints = (_c = this.idToContactConstraint.get(contact.id)) !== null && _c !== void 0 ? _c : [];
                    for (const point of constraints) {
                        const relativeVelocity = point.getRelativeVelocity();
                        // Negate velocity in tangent direction to simulate friction
                        const tangentVelocity = -relativeVelocity.dot(contact.tangent);
                        let impulseDelta = tangentVelocity / point.tangentMass;
                        // Clamping based in Erin Catto's GDC 2006 talk
                        // Correct clamping https://github.com/erincatto/box2d-lite/blob/master/docs/GDC2006_Catto_Erin_PhysicsTutorial.pdf
                        // Accumulated fiction impulse is always between -uMaxFriction < dT < uMaxFriction
                        // But deltas can vary
                        const maxFriction = friction * point.normalImpulse;
                        const newImpulse = clamp(point.tangentImpulse + impulseDelta, -maxFriction, maxFriction);
                        impulseDelta = newImpulse - point.tangentImpulse;
                        point.tangentImpulse = newImpulse;
                        const impulse = contact.tangent.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                    for (const point of constraints) {
                        // Need to recalc relative velocity because the previous step could have changed vel
                        const relativeVelocity = point.getRelativeVelocity();
                        // Compute impulse in normal direction
                        const normalVelocity = relativeVelocity.dot(contact.normal);
                        // See https://en.wikipedia.org/wiki/Collision_response
                        let impulseDelta = (-(1 + restitution) * normalVelocity) / point.normalMass;
                        // Clamping based in Erin Catto's GDC 2014 talk
                        // Accumulated impulse stored in the contact is always positive (dV > 0)
                        // But deltas can be negative
                        const newImpulse = Math.max(point.normalImpulse + impulseDelta, 0);
                        impulseDelta = newImpulse - point.normalImpulse;
                        point.normalImpulse = newImpulse;
                        const impulse = contact.normal.scale(impulseDelta);
                        bodyA.applyImpulse(point.point, impulse.negate());
                        bodyB.applyImpulse(point.point, impulse);
                    }
                }
            }
        }
    }
}

;// CONCATENATED MODULE: ./Collision/CollisionSystem.ts








class CollisionSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.motion', 'ex.collider'];
        this.systemType = SystemType.Update;
        this.priority = -1;
        this._realisticSolver = new RealisticSolver();
        this._arcadeSolver = new ArcadeSolver();
        this._processor = new DynamicTreeCollisionProcessor();
        this._lastFrameContacts = new Map();
        this._currentFrameContacts = new Map();
        this._trackCollider = (c) => this._processor.track(c);
        this._untrackCollider = (c) => this._processor.untrack(c);
    }
    notify(message) {
        if (isAddedSystemEntity(message)) {
            const colliderComponent = message.data.get(ColliderComponent);
            colliderComponent.$colliderAdded.subscribe(this._trackCollider);
            colliderComponent.$colliderRemoved.subscribe(this._untrackCollider);
            const collider = colliderComponent.get();
            if (collider) {
                this._processor.track(collider);
            }
        }
        else {
            const colliderComponent = message.data.get(ColliderComponent);
            const collider = colliderComponent.get();
            if (colliderComponent && collider) {
                this._processor.untrack(collider);
            }
        }
    }
    initialize(scene) {
        this._engine = scene.engine;
    }
    update(_entities, elapsedMs) {
        var _a;
        if (!Physics.enabled) {
            return;
        }
        // Collect up all the colliders
        let colliders = [];
        for (const entity of _entities) {
            const colliderComp = entity.get(ColliderComponent);
            const collider = colliderComp === null || colliderComp === void 0 ? void 0 : colliderComp.get();
            if (colliderComp && ((_a = colliderComp.owner) === null || _a === void 0 ? void 0 : _a.active) && collider) {
                colliderComp.update();
                if (collider instanceof CompositeCollider) {
                    colliders = colliders.concat(collider.getColliders());
                }
                else {
                    colliders.push(collider);
                }
            }
        }
        // Update the spatial partitioning data structures
        // TODO if collider invalid it will break the processor
        // TODO rename "update" to something more specific
        this._processor.update(colliders);
        // Run broadphase on all colliders and locates potential collisions
        const pairs = this._processor.broadphase(colliders, elapsedMs);
        this._currentFrameContacts.clear();
        // Given possible pairs find actual contacts
        let contacts = this._processor.narrowphase(pairs, this._engine.debug.stats.currFrame);
        const solver = this.getSolver();
        // Solve, this resolves the position/velocity so entities arent overlapping
        contacts = solver.solve(contacts);
        // Record contacts
        contacts.forEach((c) => this._currentFrameContacts.set(c.id, c));
        // Emit contact start/end events
        this.runContactStartEnd();
        // reset the last frame cache
        this._lastFrameContacts.clear();
        // Keep track of collisions contacts that have started or ended
        this._lastFrameContacts = new Map(this._currentFrameContacts);
    }
    getSolver() {
        return Physics.collisionResolutionStrategy === CollisionResolutionStrategy.Realistic ? this._realisticSolver : this._arcadeSolver;
    }
    debug(ex) {
        this._processor.debug(ex);
    }
    runContactStartEnd() {
        for (const [id, c] of this._currentFrameContacts) {
            // find all new contacts
            if (!this._lastFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                colliderA.events.emit('collisionstart', new CollisionStartEvent(colliderA, colliderB, c));
                colliderA.events.emit('contactstart', new ContactStartEvent(colliderA, colliderB, c));
                colliderB.events.emit('collisionstart', new CollisionStartEvent(colliderB, colliderA, c));
                colliderB.events.emit('contactstart', new ContactStartEvent(colliderB, colliderA, c));
            }
        }
        // find all contacts taht have ceased
        for (const [id, c] of this._lastFrameContacts) {
            if (!this._currentFrameContacts.has(id)) {
                const colliderA = c.colliderA;
                const colliderB = c.colliderB;
                colliderA.events.emit('collisionend', new CollisionEndEvent(colliderA, colliderB));
                colliderA.events.emit('contactend', new ContactEndEvent(colliderA, colliderB));
                colliderB.events.emit('collisionend', new CollisionEndEvent(colliderB, colliderA));
                colliderB.events.emit('contactend', new ContactEndEvent(colliderB, colliderA));
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/Animation.ts






var AnimationDirection;
(function (AnimationDirection) {
    /**
     * Animation is playing forwards
     */
    AnimationDirection["Forward"] = "forward";
    /**
     * Animation is play backwards
     */
    AnimationDirection["Backward"] = "backward";
})(AnimationDirection || (AnimationDirection = {}));
var AnimationStrategy;
(function (AnimationStrategy) {
    /**
     * Animation ends without displaying anything
     */
    AnimationStrategy["End"] = "end";
    /**
     * Animation loops to the first frame after the last frame
     */
    AnimationStrategy["Loop"] = "loop";
    /**
     * Animation plays to the last frame, then backwards to the first frame, then repeats
     */
    AnimationStrategy["PingPong"] = "pingpong";
    /**
     * Animation ends stopping on the last frame
     */
    AnimationStrategy["Freeze"] = "freeze";
})(AnimationStrategy || (AnimationStrategy = {}));
/**
 * Create an Animation given a list of [[Frame|frames]] in [[AnimationOptions]]
 *
 * To create an Animation from a [[SpriteSheet]], use [[Animation.fromSpriteSheet]]
 */
class Animation extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this.events = new EventDispatcher(this); // TODO replace with new Emitter
        this.frames = [];
        this.strategy = AnimationStrategy.Loop;
        this.frameDuration = 100;
        this.timeScale = 1;
        this._idempotencyToken = -1;
        this._firstTick = true;
        this._currentFrame = 0;
        this._timeLeftInFrame = 0;
        this._direction = 1; // TODO only used in ping-pong
        this._done = false;
        this._playing = true;
        this._reversed = false;
        this.frames = options.frames;
        this.strategy = (_a = options.strategy) !== null && _a !== void 0 ? _a : this.strategy;
        this.frameDuration = options.totalDuration ? options.totalDuration / this.frames.length : (_b = options.frameDuration) !== null && _b !== void 0 ? _b : this.frameDuration;
        if (options.reverse) {
            this.reverse();
        }
        this.goToFrame(0);
    }
    clone() {
        return new Animation(Object.assign({ frames: this.frames.map((f) => (Object.assign({}, f))), frameDuration: this.frameDuration, reverse: this._reversed, strategy: this.strategy }, this.cloneGraphicOptions()));
    }
    /**
     * Create an Animation from a [[SpriteSheet]], a list of indices into the sprite sheet, a duration per frame
     * and optional [[AnimationStrategy]]
     *
     * Example:
     * ```typescript
     * const spriteSheet = SpriteSheet.fromImageSource({...});
     *
     * const anim = Animation.fromSpriteSheet(spriteSheet, range(0, 5), 200, AnimationStrategy.Loop);
     * ```
     *
     * @param spriteSheet
     * @param frameIndices
     * @param durationPerFrameMs
     * @param strategy
     */
    static fromSpriteSheet(spriteSheet, frameIndices, durationPerFrameMs, strategy = AnimationStrategy.Loop) {
        const maxIndex = spriteSheet.sprites.length - 1;
        const invalidIndices = frameIndices.filter((index) => index < 0 || index > maxIndex);
        if (invalidIndices.length) {
            Animation._LOGGER.warn(`Indices into SpriteSheet were provided that don\'t exist: ${invalidIndices.join(',')} no frame will be shown`);
        }
        return new Animation({
            frames: spriteSheet.sprites
                .filter((_, index) => frameIndices.indexOf(index) > -1)
                .map((f) => ({
                graphic: f,
                duration: durationPerFrameMs
            })),
            strategy: strategy
        });
    }
    /**
     * Converts an animation to a legacy animation
     * @deprecated
     * @param engine
     * @param animation
     * @returns LegacyDrawing.Animation
     */
    static toLegacyAnimation(engine, animation) {
        const legacySprites = animation.frames.map(f => Sprite.toLegacySprite(f.graphic));
        return new Animation_Animation({
            sprites: legacySprites,
            loop: animation.strategy === AnimationStrategy.Loop,
            freezeFrame: animation.strategy === AnimationStrategy.Freeze ? legacySprites.length - 1 : undefined,
            speed: animation.frameDuration,
            engine: engine
        });
    }
    /**
     * Returns the current Frame of the animation
     */
    get currentFrame() {
        if (this._currentFrame >= 0 && this._currentFrame < this.frames.length) {
            return this.frames[this._currentFrame];
        }
        return null;
    }
    /**
     * Returns the current frame index of the animation
     */
    get currentFrameIndex() {
        return this._currentFrame;
    }
    /**
     * Returns `true` if the animation is playing
     */
    get isPlaying() {
        return this._playing;
    }
    /**
     * Reverses the play direction of the Animation, this preserves the current frame
     */
    reverse() {
        // Don't mutate with the original frame list, create a copy
        this.frames = this.frames.slice().reverse();
        this._reversed = !this._reversed;
    }
    /**
     * Returns the current play direction of the animation
     */
    get direction() {
        // Keep logically consistent with ping-pong direction
        // If ping-pong is forward = 1 and reversed is true then we are logically reversed
        const reversed = (this._reversed && this._direction === 1) ? true : false;
        return reversed ? AnimationDirection.Backward : AnimationDirection.Forward;
    }
    /**
     * Plays or resumes the animation from the current frame
     */
    play() {
        this._playing = true;
    }
    /**
     * Pauses the animation on the current frame
     */
    pause() {
        this._playing = false;
        this._firstTick = true; // firstTick must be set to emit the proper frame event
    }
    /**
     * Reset the animation back to the beginning, including if the animation were done
     */
    reset() {
        this._done = false;
        this._firstTick = true;
        this._currentFrame = 0;
    }
    /**
     * Returns `true` if the animation can end
     */
    get canFinish() {
        switch (this.strategy) {
            case AnimationStrategy.End:
            case AnimationStrategy.Freeze: {
                return true;
            }
            default: {
                return false;
            }
        }
    }
    /**
     * Returns `true` if the animation is done, for looping type animations
     * `ex.AnimationStrategy.PingPong` and `ex.AnimationStrategy.Loop` this will always return `false`
     *
     * See the `ex.Animation.canFinish()` method to know if an animation type can end
     */
    get done() {
        return this._done;
    }
    /**
     * Jump the animation immediately to a specific frame if it exists
     * @param frameNumber
     */
    goToFrame(frameNumber) {
        var _a, _b;
        this._currentFrame = frameNumber;
        this._timeLeftInFrame = this.frameDuration;
        const maybeFrame = this.frames[this._currentFrame];
        if (maybeFrame && !this._done) {
            this._timeLeftInFrame = (maybeFrame === null || maybeFrame === void 0 ? void 0 : maybeFrame.duration) || this.frameDuration;
            this.width = (_a = maybeFrame.graphic) === null || _a === void 0 ? void 0 : _a.width;
            this.height = (_b = maybeFrame.graphic) === null || _b === void 0 ? void 0 : _b.height;
            this.events.emit('frame', maybeFrame);
        }
    }
    _nextFrame() {
        const currentFrame = this._currentFrame;
        if (this._done) {
            return currentFrame;
        }
        let next = -1;
        switch (this.strategy) {
            case AnimationStrategy.Loop: {
                next = (currentFrame + 1) % this.frames.length;
                if (next === 0) {
                    this.events.emit('loop', this);
                }
                break;
            }
            case AnimationStrategy.End: {
                next = currentFrame + 1;
                if (next >= this.frames.length) {
                    this._done = true;
                    this._currentFrame = this.frames.length;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.Freeze: {
                next = clamp(currentFrame + 1, 0, this.frames.length - 1);
                if (next >= this.frames.length - 1) {
                    this._done = true;
                    this.events.emit('end', this);
                }
                break;
            }
            case AnimationStrategy.PingPong: {
                if (currentFrame + this._direction >= this.frames.length) {
                    this._direction = -1;
                    this.events.emit('loop', this);
                }
                if (currentFrame + this._direction < 0) {
                    this._direction = 1;
                    this.events.emit('loop', this);
                }
                next = currentFrame + (this._direction % this.frames.length);
                break;
            }
        }
        return next;
    }
    /**
     * Called internally by Excalibur to update the state of the animation potential update the current frame
     * @param elapsedMilliseconds Milliseconds elapsed
     * @param idempotencyToken Prevents double ticking in a frame by passing a unique token to the frame
     */
    tick(elapsedMilliseconds, idempotencyToken = 0) {
        if (this._idempotencyToken === idempotencyToken) {
            return;
        }
        this._idempotencyToken = idempotencyToken;
        if (!this._playing) {
            return;
        }
        // if it's the first frame emit frame event
        if (this._firstTick) {
            this._firstTick = false;
            this.events.emit('frame', this.currentFrame);
        }
        this._timeLeftInFrame -= elapsedMilliseconds * this.timeScale;
        if (this._timeLeftInFrame <= 0) {
            this.goToFrame(this._nextFrame());
        }
        this._updateDimensions();
    }
    _updateDimensions() {
        var _a, _b;
        if (this.currentFrame) {
            this.width = (_a = this.currentFrame.graphic) === null || _a === void 0 ? void 0 : _a.width;
            this.height = (_b = this.currentFrame.graphic) === null || _b === void 0 ? void 0 : _b.height;
        }
    }
    _drawImage(ctx, x, y) {
        if (this.currentFrame) {
            this.currentFrame.graphic.draw(ctx, x, y);
        }
    }
}
Animation._LOGGER = Logger.getInstance();

;// CONCATENATED MODULE: ./Graphics/GraphicsGroup.ts



class GraphicsGroup extends Graphic {
    constructor(options) {
        super(options);
        this.members = [];
        this.members = options.members;
        this._updateDimensions();
    }
    clone() {
        return new GraphicsGroup(Object.assign({ members: [...this.members] }, this.cloneGraphicOptions()));
    }
    _updateDimensions() {
        let bb = new BoundingBox();
        for (const { graphic, pos } of this.members) {
            bb = graphic.localBounds.translate(pos).combine(bb);
        }
        this.width = bb.width;
        this.height = bb.height;
        return bb;
    }
    get localBounds() {
        let bb = new BoundingBox();
        for (const { graphic, pos } of this.members) {
            bb = graphic.localBounds.translate(pos).combine(bb);
        }
        return bb;
    }
    _isAnimationOrGroup(graphic) {
        return graphic instanceof Animation || graphic instanceof GraphicsGroup;
    }
    tick(elapsedMilliseconds, idempotencyToken) {
        for (const member of this.members) {
            const maybeAnimation = member.graphic;
            if (this._isAnimationOrGroup(maybeAnimation)) {
                maybeAnimation.tick(elapsedMilliseconds, idempotencyToken);
            }
        }
    }
    reset() {
        for (const member of this.members) {
            const maybeAnimation = member.graphic;
            if (this._isAnimationOrGroup(maybeAnimation)) {
                maybeAnimation.reset();
            }
        }
    }
    _preDraw(ex, x, y) {
        this._updateDimensions();
        super._preDraw(ex, x, y);
    }
    _drawImage(ex, x, y) {
        for (const member of this.members) {
            ex.save();
            ex.translate(x, y);
            member.graphic.draw(ex, member.pos.x, member.pos.y);
            if (this.showDebug) {
                /* istanbul ignore next */
                ex.debug.drawRect(0, 0, this.width, this.height);
            }
            ex.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Particles.ts














/**
 * An enum that represents the types of emitter nozzles
 */
var EmitterType;
(function (EmitterType) {
    /**
     * Constant for the circular emitter type
     */
    EmitterType[EmitterType["Circle"] = 0] = "Circle";
    /**
     * Constant for the rectangular emitter type
     */
    EmitterType[EmitterType["Rectangle"] = 1] = "Rectangle";
})(EmitterType || (EmitterType = {}));
/**
 * @hidden
 */
class ParticleImpl extends Entity {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        super();
        this.position = new Vector(0, 0);
        this.velocity = new Vector(0, 0);
        this.acceleration = new Vector(0, 0);
        this.particleRotationalVelocity = 0;
        this.currentRotation = 0;
        this.focus = null;
        this.focusAccel = 0;
        this.opacity = 1;
        this.beginColor = Color.White;
        this.endColor = Color.White;
        // Life is counted in ms
        this.life = 300;
        this.fadeFlag = false;
        // Color transitions
        this._rRate = 1;
        this._gRate = 1;
        this._bRate = 1;
        this._aRate = 0;
        this._currentColor = Color.White;
        this.emitter = null;
        this.particleSize = 5;
        this.particleSprite = null;
        this.sizeRate = 0;
        this.elapsedMultiplier = 0;
        this.visible = true;
        this.isOffscreen = false;
        let emitter = emitterOrConfig;
        if (emitter && !(emitterOrConfig instanceof ParticleEmitter)) {
            const config = emitterOrConfig;
            emitter = config.emitter;
            life = config.life;
            opacity = config.opacity;
            endColor = config.endColor;
            beginColor = config.beginColor;
            position = config.position;
            velocity = config.velocity;
            acceleration = config.acceleration;
            startSize = config.startSize;
            endSize = config.endSize;
        }
        this.emitter = emitter;
        this.life = life || this.life;
        this.opacity = opacity || this.opacity;
        this.endColor = endColor || this.endColor.clone();
        this.beginColor = beginColor || this.beginColor.clone();
        this._currentColor = this.beginColor.clone();
        this.position = (position || this.position).add(this.emitter.pos);
        this.velocity = velocity || this.velocity;
        this.acceleration = acceleration || this.acceleration;
        this._rRate = (this.endColor.r - this.beginColor.r) / this.life;
        this._gRate = (this.endColor.g - this.beginColor.g) / this.life;
        this._bRate = (this.endColor.b - this.beginColor.b) / this.life;
        this._aRate = this.opacity / this.life;
        this.startSize = startSize || 0;
        this.endSize = endSize || 0;
        if (this.endSize > 0 && this.startSize > 0) {
            this.sizeRate = (this.endSize - this.startSize) / this.life;
            this.particleSize = this.startSize;
        }
        this.addComponent((this.transform = new TransformComponent()));
        this.addComponent(new CanvasDrawComponent((ctx) => this.draw(ctx)));
        this.addComponent((this.graphics = new GraphicsComponent()));
        this.transform.pos = this.position;
        this.transform.rotation = this.currentRotation;
        this.transform.scale = vec(1, 1); // TODO wut
        if (this.particleSprite) {
            this.graphics.opacity = this.opacity;
            this.graphics.use(Sprite.fromLegacySprite(this.particleSprite));
        }
        else {
            this.graphics.onPostDraw = (ctx) => {
                ctx.save();
                this.graphics.opacity = this.opacity;
                const tmpColor = this._currentColor.clone();
                tmpColor.a = 1;
                ctx.debug.drawPoint(vec(0, 0), { color: tmpColor, size: this.particleSize });
                ctx.restore();
            };
        }
    }
    kill() {
        this.emitter.removeParticle(this);
    }
    update(_engine, delta) {
        this.life = this.life - delta;
        this.elapsedMultiplier = this.elapsedMultiplier + delta;
        if (this.life < 0) {
            this.kill();
        }
        if (this.fadeFlag) {
            this.opacity = clamp(this._aRate * this.life, 0.0001, 1);
        }
        if (this.startSize > 0 && this.endSize > 0) {
            this.particleSize = clamp(this.sizeRate * delta + this.particleSize, Math.min(this.startSize, this.endSize), Math.max(this.startSize, this.endSize));
        }
        this._currentColor.r = clamp(this._currentColor.r + this._rRate * delta, 0, 255);
        this._currentColor.g = clamp(this._currentColor.g + this._gRate * delta, 0, 255);
        this._currentColor.b = clamp(this._currentColor.b + this._bRate * delta, 0, 255);
        this._currentColor.a = clamp(this.opacity, 0.0001, 1);
        if (this.focus) {
            const accel = this.focus
                .sub(this.position)
                .normalize()
                .scale(this.focusAccel)
                .scale(delta / 1000);
            this.velocity = this.velocity.add(accel);
        }
        else {
            this.velocity = this.velocity.add(this.acceleration.scale(delta / 1000));
        }
        this.position = this.position.add(this.velocity.scale(delta / 1000));
        if (this.particleRotationalVelocity) {
            this.currentRotation = (this.currentRotation + (this.particleRotationalVelocity * delta) / 1000) % (2 * Math.PI);
        }
        this.transform.pos = this.position;
        this.transform.rotation = this.currentRotation;
        this.transform.scale = vec(1, 1); // todo wut
        this.graphics.opacity = this.opacity;
    }
    draw(ctx) {
        if (this.particleSprite) {
            this.particleSprite.opacity(this.opacity);
            this.particleSprite.draw(ctx, 0, 0);
            return;
        }
        ctx.save();
        this._currentColor.a = clamp(this.opacity, 0.0001, 1);
        ctx.fillStyle = this._currentColor.toString();
        ctx.beginPath();
        ctx.arc(0, 0, this.particleSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
        ctx.restore();
    }
}
/**
 * Particle is used in a [[ParticleEmitter]]
 */
class Particle extends Configurable(ParticleImpl) {
    constructor(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize) {
        super(emitterOrConfig, life, opacity, beginColor, endColor, position, velocity, acceleration, startSize, endSize);
    }
}
/**
 * Using a particle emitter is a great way to create interesting effects
 * in your game, like smoke, fire, water, explosions, etc. `ParticleEmitter`
 * extend [[Actor]] allowing you to use all of the features that come with.
 */
class ParticleEmitter extends Actor {
    /**
     * @param config particle emitter options bag
     */
    constructor(config) {
        var _a, _b;
        super({ width: (_a = config.width) !== null && _a !== void 0 ? _a : 0, height: (_b = config.height) !== null && _b !== void 0 ? _b : 0 });
        this._particlesToEmit = 0;
        this.numParticles = 0;
        /**
         * Gets or sets the isEmitting flag
         */
        this.isEmitting = true;
        /**
         * Gets or sets the backing particle collection
         */
        this.particles = [];
        /**
         * Gets or sets the backing deadParticle collection
         */
        this.deadParticles = [];
        /**
         * Gets or sets the minimum particle velocity
         */
        this.minVel = 0;
        /**
         * Gets or sets the maximum particle velocity
         */
        this.maxVel = 0;
        /**
         * Gets or sets the acceleration vector for all particles
         */
        this.acceleration = new Vector(0, 0);
        /**
         * Gets or sets the minimum angle in radians
         */
        this.minAngle = 0;
        /**
         * Gets or sets the maximum angle in radians
         */
        this.maxAngle = 0;
        /**
         * Gets or sets the emission rate for particles (particles/sec)
         */
        this.emitRate = 1; //particles/sec
        /**
         * Gets or sets the life of each particle in milliseconds
         */
        this.particleLife = 2000;
        /**
         * Gets or sets the fade flag which causes particles to gradually fade out over the course of their life.
         */
        this.fadeFlag = false;
        /**
         * Gets or sets the optional focus where all particles should accelerate towards
         */
        this.focus = null;
        /**
         * Gets or sets the acceleration for focusing particles if a focus has been specified
         */
        this.focusAccel = null;
        /**
         * Gets or sets the optional starting size for the particles
         */
        this.startSize = null;
        /**
         * Gets or sets the optional ending size for the particles
         */
        this.endSize = null;
        /**
         * Gets or sets the minimum size of all particles
         */
        this.minSize = 5;
        /**
         * Gets or sets the maximum size of all particles
         */
        this.maxSize = 5;
        /**
         * Gets or sets the beginning color of all particles
         */
        this.beginColor = Color.White;
        /**
         * Gets or sets the ending color of all particles
         */
        this.endColor = Color.White;
        this._og = null;
        this._sprite = null;
        /**
         * Gets or sets the emitter type for the particle emitter
         */
        this.emitterType = EmitterType.Rectangle;
        /**
         * Gets or sets the emitter radius, only takes effect when the [[emitterType]] is [[EmitterType.Circle]]
         */
        this.radius = 0;
        /**
         * Gets or sets the particle rotational speed velocity
         */
        this.particleRotationalVelocity = 0;
        /**
         * Indicates whether particles should start with a random rotation
         */
        this.randomRotation = false;
        const { x, y, pos, isEmitting, minVel, maxVel, acceleration, minAngle, maxAngle, emitRate, particleLife, opacity, fadeFlag, focus, focusAccel, startSize, endSize, minSize, maxSize, beginColor, endColor, particleSprite, emitterType, radius, particleRotationalVelocity, randomRotation, random } = Object.assign({}, config);
        this.pos = pos !== null && pos !== void 0 ? pos : vec(x !== null && x !== void 0 ? x : 0, y !== null && y !== void 0 ? y : 0);
        this.isEmitting = isEmitting !== null && isEmitting !== void 0 ? isEmitting : this.isEmitting;
        this.minVel = minVel !== null && minVel !== void 0 ? minVel : this.minVel;
        this.maxVel = maxVel !== null && maxVel !== void 0 ? maxVel : this.maxVel;
        this.acceleration = acceleration !== null && acceleration !== void 0 ? acceleration : this.acceleration;
        this.minAngle = minAngle !== null && minAngle !== void 0 ? minAngle : this.minAngle;
        this.maxAngle = maxAngle !== null && maxAngle !== void 0 ? maxAngle : this.maxAngle;
        this.emitRate = emitRate !== null && emitRate !== void 0 ? emitRate : this.emitRate;
        this.particleLife = particleLife !== null && particleLife !== void 0 ? particleLife : this.particleLife;
        this.opacity = opacity !== null && opacity !== void 0 ? opacity : this.opacity;
        this.fadeFlag = fadeFlag !== null && fadeFlag !== void 0 ? fadeFlag : this.fadeFlag;
        this.focus = focus !== null && focus !== void 0 ? focus : this.focus;
        this.focusAccel = focusAccel !== null && focusAccel !== void 0 ? focusAccel : this.focusAccel;
        this.startSize = startSize !== null && startSize !== void 0 ? startSize : this.startSize;
        this.endSize = endSize !== null && endSize !== void 0 ? endSize : this.endSize;
        this.minSize = minSize !== null && minSize !== void 0 ? minSize : this.minSize;
        this.maxSize = maxSize !== null && maxSize !== void 0 ? maxSize : this.maxSize;
        this.beginColor = beginColor !== null && beginColor !== void 0 ? beginColor : this.beginColor;
        this.endColor = endColor !== null && endColor !== void 0 ? endColor : this.endColor;
        this.particleSprite = particleSprite !== null && particleSprite !== void 0 ? particleSprite : this.particleSprite;
        this.emitterType = emitterType !== null && emitterType !== void 0 ? emitterType : this.emitterType;
        this.radius = radius !== null && radius !== void 0 ? radius : this.radius;
        this.particleRotationalVelocity = particleRotationalVelocity !== null && particleRotationalVelocity !== void 0 ? particleRotationalVelocity : this.particleRotationalVelocity;
        this.randomRotation = randomRotation !== null && randomRotation !== void 0 ? randomRotation : this.randomRotation;
        this.body.collisionType = CollisionType.PreventCollision;
        this.random = random !== null && random !== void 0 ? random : new Random();
        // Remove offscreen culling from particle emitters
        for (let i = 0; i < this.traits.length; i++) {
            if (this.traits[i] instanceof OffscreenCulling) {
                this.traits.splice(i, 1);
            }
        }
    }
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    get opacity() {
        return super.graphics.opacity;
    }
    /**
     * Gets the opacity of each particle from 0 to 1.0
     */
    set opacity(opacity) {
        super.graphics.opacity = opacity;
    }
    /**
     * Gets or sets the sprite that a particle should use
     */
    get particleSprite() {
        return this._og;
    }
    set particleSprite(val) {
        this._og = val;
        if (val) {
            this._sprite = Sprite.fromLegacySprite(val);
        }
    }
    removeParticle(particle) {
        this.deadParticles.push(particle);
    }
    /**
     * Causes the emitter to emit particles
     * @param particleCount  Number of particles to emit right now
     */
    emitParticles(particleCount) {
        var _a;
        for (let i = 0; i < particleCount; i++) {
            const p = this._createParticle();
            this.particles.push(p);
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                this.scene.world.add(p);
            }
        }
    }
    clearParticles() {
        this.particles.length = 0;
    }
    // Creates a new particle given the constraints of the emitter
    _createParticle() {
        // todo implement emitter constraints;
        let ranX = 0;
        let ranY = 0;
        const angle = randomInRange(this.minAngle, this.maxAngle, this.random);
        const vel = randomInRange(this.minVel, this.maxVel, this.random);
        const size = this.startSize || randomInRange(this.minSize, this.maxSize, this.random);
        const dx = vel * Math.cos(angle);
        const dy = vel * Math.sin(angle);
        if (this.emitterType === EmitterType.Rectangle) {
            ranX = randomInRange(0, this.width, this.random);
            ranY = randomInRange(0, this.height, this.random);
        }
        else if (this.emitterType === EmitterType.Circle) {
            const radius = randomInRange(0, this.radius, this.random);
            ranX = radius * Math.cos(angle);
            ranY = radius * Math.sin(angle);
        }
        const p = new Particle(this, this.particleLife, this.opacity, this.beginColor, this.endColor, new Vector(ranX, ranY), new Vector(dx, dy), this.acceleration, this.startSize, this.endSize);
        p.fadeFlag = this.fadeFlag;
        p.particleSize = size;
        if (this.particleSprite) {
            p.particleSprite = this.particleSprite;
            p.graphics.opacity = this.opacity;
            p.graphics.use(this._sprite);
        }
        p.particleRotationalVelocity = this.particleRotationalVelocity;
        if (this.randomRotation) {
            p.currentRotation = randomInRange(0, Math.PI * 2, this.random);
        }
        if (this.focus) {
            p.focus = this.focus.add(new Vector(this.pos.x, this.pos.y));
            p.focusAccel = this.focusAccel;
        }
        return p;
    }
    update(engine, delta) {
        var _a;
        super.update(engine, delta);
        if (this.isEmitting) {
            this._particlesToEmit += this.emitRate * (delta / 1000);
            if (this._particlesToEmit > 1.0) {
                this.emitParticles(Math.floor(this._particlesToEmit));
                this._particlesToEmit = this._particlesToEmit - Math.floor(this._particlesToEmit);
            }
        }
        // deferred removal
        for (let i = 0; i < this.deadParticles.length; i++) {
            removeItemFromArray(this.deadParticles[i], this.particles);
            if ((_a = this === null || this === void 0 ? void 0 : this.scene) === null || _a === void 0 ? void 0 : _a.world) {
                this.scene.world.remove(this.deadParticles[i], false);
            }
        }
        this.deadParticles.length = 0;
    }
    draw(ctx) {
        // todo is there a more efficient to draw
        // possibly use a webgl offscreen canvas and shaders to do particles?
        this.particles.forEach((p) => p.draw(ctx));
    }
    debugDraw(ctx) {
        super.debugDraw(ctx);
        ctx.fillStyle = Color.Black.toString();
        ctx.fillText('Particles: ' + this.particles.length, this.pos.x, this.pos.y + 20);
        if (this.focus) {
            ctx.fillRect(this.focus.x + this.pos.x, this.focus.y + this.pos.y, 3, 3);
            line(ctx, Color.Yellow, this.focus.x + this.pos.x, this.focus.y + this.pos.y, this.center.x, this.center.y);
            ctx.fillText('Focus', this.focus.x + this.pos.x, this.focus.y + this.pos.y);
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/GraphicsSystem.ts








class GraphicsSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.graphics'];
        this.systemType = SystemType.Draw;
        this.priority = 0;
        this._token = 0;
    }
    initialize(scene) {
        this._graphicsContext = scene.engine.graphicsContext;
        this._camera = scene.camera;
        this._engine = scene.engine;
    }
    sort(a, b) {
        return a.get(TransformComponent).z - b.get(TransformComponent).z;
    }
    update(entities, delta) {
        this._clearScreen();
        this._token++;
        let transform;
        let graphics;
        for (const entity of entities) {
            transform = entity.get(TransformComponent);
            graphics = entity.get(GraphicsComponent);
            // Figure out if entities are offscreen
            const entityOffscreen = this._isOffscreen(transform, graphics);
            if (entityOffscreen && !entity.hasTag('offscreen')) {
                entity.eventDispatcher.emit('exitviewport', new ExitViewPortEvent(entity));
                entity.addComponent(new TagComponent('offscreen'));
            }
            if (!entityOffscreen && entity.hasTag('offscreen')) {
                entity.eventDispatcher.emit('enterviewport', new EnterViewPortEvent(entity));
                entity.removeComponent('offscreen');
            }
            // Skip entities that have graphics offscreen
            if (entityOffscreen) {
                continue;
            }
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            this._pushCameraTransform(transform);
            this._graphicsContext.save();
            // Tick any graphics state (but only once) for animations and graphics groups
            graphics.update(delta, this._token);
            // Position the entity
            this._applyTransform(entity);
            // Optionally run the onPreDraw graphics lifecycle draw
            if (graphics.onPreDraw) {
                graphics.onPreDraw(this._graphicsContext, delta);
            }
            // TODO remove this hack on the particle redo
            const particleOpacity = (entity instanceof Particle) ? entity.opacity : 1;
            this._graphicsContext.opacity = graphics.opacity * particleOpacity;
            // Draw the graphics component
            this._drawGraphicsComponent(graphics);
            // Optionally run the onPostDraw graphics lifecycle draw
            if (graphics.onPostDraw) {
                graphics.onPostDraw(this._graphicsContext, delta);
            }
            this._graphicsContext.restore();
            // Reset the transform back to the original
            this._popCameraTransform(transform);
        }
        this._graphicsContext.flush();
        this._engine.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;
        this._engine.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;
    }
    _clearScreen() {
        this._graphicsContext.clear();
    }
    _isOffscreen(transform, graphics) {
        if (transform.coordPlane === CoordPlane.World) {
            const graphicsOffscreen = !this._camera.viewport.intersect(graphics.localBounds.transform(transform.getGlobalMatrix()));
            return graphicsOffscreen;
        }
        else {
            // TODO sceen coordinates
            return false;
        }
    }
    _drawGraphicsComponent(graphicsComponent) {
        var _a, _b;
        if (graphicsComponent.visible) {
            // this should be moved to the graphics system
            for (const layer of graphicsComponent.layers.get()) {
                for (const { graphic, options } of layer.graphics) {
                    let anchor = graphicsComponent.anchor;
                    let offset = graphicsComponent.offset;
                    if (options === null || options === void 0 ? void 0 : options.anchor) {
                        anchor = options.anchor;
                    }
                    if (options === null || options === void 0 ? void 0 : options.offset) {
                        offset = options.offset;
                    }
                    // See https://github.com/excaliburjs/Excalibur/pull/619 for discussion on this formula
                    const offsetX = -graphic.width * anchor.x + offset.x;
                    const offsetY = -graphic.height * anchor.y + offset.y;
                    graphic === null || graphic === void 0 ? void 0 : graphic.draw(this._graphicsContext, offsetX + layer.offset.x, offsetY + layer.offset.y);
                    if (((_a = this._engine) === null || _a === void 0 ? void 0 : _a.isDebug) && this._engine.debug.graphics.showBounds) {
                        const offset = vec(offsetX + layer.offset.x, offsetY + layer.offset.y);
                        if (graphic instanceof GraphicsGroup) {
                            for (const g of graphic.members) {
                                (_b = g.graphic) === null || _b === void 0 ? void 0 : _b.localBounds.translate(offset.add(g.pos)).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                            }
                        }
                        else {
                            /* istanbul ignore next */
                            graphic === null || graphic === void 0 ? void 0 : graphic.localBounds.translate(offset).draw(this._graphicsContext, this._engine.debug.graphics.boundsColor);
                        }
                    }
                }
            }
        }
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            if (transform) {
                this._graphicsContext.translate(transform.pos.x, transform.pos.y);
                this._graphicsContext.scale(transform.scale.x, transform.scale.y);
                this._graphicsContext.rotate(transform.rotation);
            }
        }
    }
    /**
     * Applies the current camera transform if in world coordinates
     * @param transform
     */
    _pushCameraTransform(transform) {
        // Establish camera offset per entity
        if (transform.coordPlane === CoordPlane.World) {
            this._graphicsContext.save();
            if (this._camera) {
                this._camera.draw(this._graphicsContext);
            }
        }
    }
    /**
     * Resets the current camera transform if in world coordinates
     * @param transform
     */
    _popCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Apply camera world offset
            this._graphicsContext.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Drawing/CanvasDrawingSystem.ts




/**
 * Draws anything with a transform and a "draw" method
 * @deprecated Shim for canvas drawing, will be removed v0.26.0
 */
class CanvasDrawingSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform', 'ex.canvas'];
        this.systemType = SystemType.Draw;
        this.priority = -1;
    }
    initialize(scene) {
        this._ctx = scene.engine.ctx;
        this._engine = scene.engine;
        this._camera = scene.camera;
    }
    sort(a, b) {
        return a.get(TransformComponent).z - b.get(TransformComponent).z;
    }
    update(entities, delta) {
        var _a, _b, _c;
        this._clearScreen();
        let transform;
        let canvasdraw;
        const length = entities.length;
        for (let i = 0; i < length; i++) {
            const visible = (_c = (_b = (_a = entities[i]) === null || _a === void 0 ? void 0 : _a.graphics) === null || _b === void 0 ? void 0 : _b.visible) !== null && _c !== void 0 ? _c : true;
            const offscreen = entities[i].isOffScreen;
            if (visible && !offscreen) {
                transform = entities[i].get(TransformComponent);
                canvasdraw = entities[i].get(CanvasDrawComponent);
                this._ctx.save();
                this._pushCameraTransform(transform);
                this._ctx.save();
                this._applyTransform(entities[i]);
                canvasdraw.draw(this._ctx, delta);
                this._ctx.restore();
                this._popCameraTransform(transform);
                this._ctx.restore();
            }
            if (this._engine.isDebug) {
                this._ctx.save();
                this._pushCameraTransform(transform);
                this._ctx.strokeStyle = 'yellow';
                entities[i].debugDraw(this._ctx);
                this._popCameraTransform(transform);
                this._ctx.restore();
            }
        }
        if (this._engine.isDebug) {
            this._ctx.save();
            this._camera.draw(this._ctx);
            this._camera.debugDraw(this._ctx);
            this._ctx.restore();
        }
        this._engine.stats.currFrame.graphics.drawnImages = GraphicsDiagnostics.DrawnImagesCount;
        this._engine.stats.currFrame.graphics.drawCalls = GraphicsDiagnostics.DrawCallCount;
    }
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            if (transform) {
                this._ctx.translate(transform.pos.x, transform.pos.y);
                this._ctx.rotate(transform.rotation);
                this._ctx.scale(transform.scale.x, transform.scale.y);
            }
        }
    }
    _clearScreen() {
        this._ctx.clearRect(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);
        this._ctx.fillStyle = this._engine.backgroundColor.toString();
        this._ctx.fillRect(0, 0, this._ctx.canvas.width, this._ctx.canvas.height);
    }
    _pushCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Apply camera transform to place entity in world space
            this._ctx.save();
            if (this._camera) {
                this._camera.draw(this._ctx);
            }
        }
    }
    _popCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Restore back to screen space from world space if we were drawing an entity there
            this._ctx.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Debug/DebugSystem.ts






class DebugSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.transform'];
        this.systemType = SystemType.Draw;
        this.priority = 999; // lowest priority
    }
    initialize(scene) {
        this._graphicsContext = scene.engine.graphicsContext;
        this._camera = scene.camera;
        this._engine = scene.engine;
        this._collisionSystem = scene.world.systemManager.get(CollisionSystem);
    }
    update(entities, _delta) {
        var _a, _b;
        if (!this._engine.isDebug) {
            return;
        }
        const filterSettings = this._engine.debug.filter;
        let id;
        let name;
        const entitySettings = this._engine.debug.entity;
        let tx;
        const txSettings = this._engine.debug.transform;
        let motion;
        const motionSettings = this._engine.debug.motion;
        let colliderComp;
        const colliderSettings = this._engine.debug.collider;
        const physicsSettings = this._engine.debug.physics;
        let graphics;
        const graphicsSettings = this._engine.debug.graphics;
        let body;
        const bodySettings = this._engine.debug.body;
        const cameraSettings = this._engine.debug.camera;
        for (const entity of entities) {
            if (entity.hasTag('offscreen')) {
                // skip offscreen entities
                continue;
            }
            if (entity instanceof Particle) {
                // Particles crush the renderer :(
                continue;
            }
            if (filterSettings.useFilter) {
                const allIds = filterSettings.ids.length === 0;
                const idMatch = allIds || filterSettings.ids.includes(entity.id);
                if (!idMatch) {
                    continue;
                }
                const allNames = filterSettings.nameQuery === '';
                const nameMatch = allNames || entity.name.includes(filterSettings.nameQuery);
                if (!nameMatch) {
                    continue;
                }
            }
            let cursor = Vector.Zero;
            const lineHeight = vec(0, 16);
            id = entity.id;
            name = entity.name;
            tx = entity.get(TransformComponent);
            // This optionally sets our camera based on the entity coord plan (world vs. screen)
            this._pushCameraTransform(tx);
            this._graphicsContext.save();
            this._applyTransform(entity);
            if (tx) {
                if (txSettings.showAll || txSettings.showPosition) {
                    this._graphicsContext.debug.drawPoint(Vector.Zero, { size: 2, color: txSettings.positionColor });
                    this._graphicsContext.debug.drawText(`pos${tx.pos.toString(2)}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showId) {
                    this._graphicsContext.debug.drawText(`id(${id}) ${tx.parent ? 'child of id(' + ((_b = (_a = tx.parent) === null || _a === void 0 ? void 0 : _a.owner) === null || _b === void 0 ? void 0 : _b.id) + ')' : ''}`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (entitySettings.showAll || entitySettings.showName) {
                    this._graphicsContext.debug.drawText(`name(${name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showRotation) {
                    this._graphicsContext.drawLine(Vector.Zero, Vector.fromAngle(tx.rotation).scale(50).add(Vector.Zero), txSettings.rotationColor, 2);
                    this._graphicsContext.debug.drawText(`rot deg(${toDegrees(tx.rotation).toFixed(2)})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (txSettings.showAll || txSettings.showScale) {
                    this._graphicsContext.drawLine(Vector.Zero, tx.scale.add(Vector.Zero), txSettings.scaleColor, 2);
                }
            }
            graphics = entity.get(GraphicsComponent);
            if (graphics) {
                if (graphicsSettings.showAll || graphicsSettings.showBounds) {
                    const bounds = graphics.localBounds;
                    bounds.draw(this._graphicsContext, graphicsSettings.boundsColor);
                }
            }
            body = entity.get(BodyComponent);
            if (body) {
                if (bodySettings.showAll || bodySettings.showCollisionGroup) {
                    this._graphicsContext.debug.drawText(`collision group(${body.group.name})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showCollisionType) {
                    this._graphicsContext.debug.drawText(`collision type(${body.collisionType})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMass) {
                    this._graphicsContext.debug.drawText(`mass(${body.mass})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showMotion) {
                    this._graphicsContext.debug.drawText(`motion(${body.sleepMotion})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
                if (bodySettings.showAll || bodySettings.showSleeping) {
                    this._graphicsContext.debug.drawText(`sleeping(${body.canSleep ? body.sleeping : 'cant sleep'})`, cursor);
                    cursor = cursor.add(lineHeight);
                }
            }
            this._graphicsContext.restore();
            motion = entity.get(MotionComponent);
            if (motion) {
                if (motionSettings.showAll || motionSettings.showVelocity) {
                    this._graphicsContext.debug.drawText(`vel${motion.vel.toString(2)}`, cursor.add(tx.globalPos));
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.vel), motionSettings.velocityColor, 2);
                    cursor = cursor.add(lineHeight);
                }
                if (motionSettings.showAll || motionSettings.showAcceleration) {
                    this._graphicsContext.drawLine(tx.globalPos, tx.globalPos.add(motion.acc), motionSettings.accelerationColor, 2);
                }
            }
            // Colliders live in world space already so after the restore()
            colliderComp = entity.get(ColliderComponent);
            if (colliderComp) {
                const collider = colliderComp.get();
                if ((colliderSettings.showAll || colliderSettings.showGeometry) && collider) {
                    collider.debug(this._graphicsContext, colliderSettings.geometryColor);
                }
                if (colliderSettings.showAll || colliderSettings.showBounds) {
                    if (collider instanceof CompositeCollider) {
                        const colliders = collider.getColliders();
                        for (const collider of colliders) {
                            const bounds = collider.bounds;
                            const pos = vec(bounds.left, bounds.top);
                            this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                            if (colliderSettings.showAll || colliderSettings.showOwner) {
                                this._graphicsContext.debug.drawText(`owner id(${collider.owner.id})`, pos);
                            }
                        }
                        colliderComp.bounds.draw(this._graphicsContext, colliderSettings.boundsColor);
                    }
                    else if (collider) {
                        const bounds = colliderComp.bounds;
                        const pos = vec(bounds.left, bounds.top);
                        this._graphicsContext.debug.drawRect(pos.x, pos.y, bounds.width, bounds.height, { color: colliderSettings.boundsColor });
                        if (colliderSettings.showAll || colliderSettings.showOwner) {
                            this._graphicsContext.debug.drawText(`owner id(${colliderComp.owner.id})`, pos);
                        }
                    }
                }
            }
            this._popCameraTransform(tx);
        }
        this._graphicsContext.save();
        this._camera.draw(this._graphicsContext);
        if (physicsSettings.showAll || physicsSettings.showBroadphaseSpacePartitionDebug) {
            this._collisionSystem.debug(this._graphicsContext);
        }
        if (physicsSettings.showAll || physicsSettings.showCollisionContacts || physicsSettings.showCollisionNormals) {
            for (const [_, contact] of this._engine.debug.stats.currFrame.physics.contacts) {
                if (physicsSettings.showAll || physicsSettings.showCollisionContacts) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawPoint(point, { size: 5, color: physicsSettings.collisionContactColor });
                    }
                }
                if (physicsSettings.showAll || physicsSettings.showCollisionNormals) {
                    for (const point of contact.points) {
                        this._graphicsContext.debug.drawLine(point, contact.normal.scale(30).add(point), {
                            color: physicsSettings.collisionNormalColor
                        });
                    }
                }
            }
        }
        this._graphicsContext.restore();
        if (cameraSettings) {
            this._graphicsContext.save();
            this._camera.draw(this._graphicsContext);
            if (cameraSettings.showAll || cameraSettings.showFocus) {
                this._graphicsContext.drawCircle(this._camera.pos, 4, cameraSettings.focusColor);
            }
            if (cameraSettings.showAll || cameraSettings.showZoom) {
                this._graphicsContext.debug.drawText(`zoom(${this._camera.zoom})`, this._camera.pos);
            }
            this._graphicsContext.restore();
        }
        this._graphicsContext.flush();
    }
    /**
     * This applies the current entity transform to the graphics context
     * @param entity
     */
    _applyTransform(entity) {
        const ancestors = entity.getAncestors();
        for (const ancestor of ancestors) {
            const transform = ancestor === null || ancestor === void 0 ? void 0 : ancestor.get(TransformComponent);
            if (transform) {
                this._graphicsContext.translate(transform.pos.x, transform.pos.y);
                this._graphicsContext.scale(transform.scale.x, transform.scale.y);
                this._graphicsContext.rotate(transform.rotation);
            }
        }
    }
    /**
     * Applies the current camera transform if in world coordinates
     * @param transform
     */
    _pushCameraTransform(transform) {
        // Establish camera offset per entity
        if (transform.coordPlane === CoordPlane.World) {
            this._graphicsContext.save();
            if (this._camera) {
                this._camera.draw(this._graphicsContext);
            }
        }
    }
    /**
     * Resets the current camera transform if in world coordinates
     * @param transform
     */
    _popCameraTransform(transform) {
        if (transform.coordPlane === CoordPlane.World) {
            // Apply camera world offset
            this._graphicsContext.restore();
        }
    }
}

;// CONCATENATED MODULE: ./Actions/ActionsSystem.ts


class ActionsSystem extends System {
    constructor() {
        super(...arguments);
        this.types = ['ex.actions'];
        this.systemType = SystemType.Update;
        this.priority = -1;
    }
    update(entities, delta) {
        let actions;
        for (const entity of entities) {
            actions = entity.get(ActionsComponent);
            actions.update(delta);
        }
    }
}

;// CONCATENATED MODULE: ./Scene.ts
var Scene_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};






















/**
 * [[Actor|Actors]] are composed together into groupings called Scenes in
 * Excalibur. The metaphor models the same idea behind real world
 * actors in a scene. Only actors in scenes will be updated and drawn.
 *
 * Typical usages of a scene include: levels, menus, loading screens, etc.
 */
class Scene extends Class {
    constructor() {
        super();
        this._logger = Logger.getInstance();
        /**
         * Gets or sets the current camera for the scene
         */
        this.camera = new Camera();
        /**
         * The ECS world for the scene
         */
        this.world = new World(this);
        this._isInitialized = false;
        this._timers = [];
        this._cancelQueue = [];
        // TODO how to people do there own systems
        // Initialize systems
        this.world.add(new ActionsSystem());
        this.world.add(new MotionSystem());
        this.world.add(new CollisionSystem());
        if (Flags.isEnabled(Legacy.LegacyDrawing)) {
            this.world.add(new CanvasDrawingSystem());
        }
        else {
            this.world.add(new GraphicsSystem());
        }
        this.world.add(new DebugSystem());
    }
    /**
     * The actors in the current scene
     */
    get actors() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof Actor;
        });
    }
    /**
     * The entities in the current scene
     */
    get entities() {
        return this.world.entityManager.entities;
    }
    /**
     * The triggers in the current scene
     */
    get triggers() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof Trigger_Trigger;
        });
    }
    /**
     * The [[TileMap]]s in the scene, if any
     */
    get tileMaps() {
        return this.world.entityManager.entities.filter((e) => {
            return e instanceof TileMap;
        });
    }
    /**
     * The [[ScreenElement]]s in a scene, if any; these are drawn last
     * @deprecated Use [[Scene.actors]]
     */
    get screenElements() {
        return this.actors.filter((a) => a instanceof ScreenElement_ScreenElement);
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    /**
     * This is called before the first update of the [[Scene]]. Initializes scene members like the camera. This method is meant to be
     * overridden. This is where initialization of child actors should take place.
     */
    onInitialize(_engine) {
        // will be overridden
    }
    /**
     * This is called when the scene is made active and started. It is meant to be overridden,
     * this is where you should setup any DOM UI or event handlers needed for the scene.
     */
    onActivate(_oldScene, _newScene) {
        // will be overridden
    }
    /**
     * This is called when the scene is made transitioned away from and stopped. It is meant to be overridden,
     * this is where you should cleanup any DOM UI or event handlers needed for the scene.
     */
    onDeactivate(_oldScene, _newScene) {
        // will be overridden
    }
    /**
     * Safe to override onPreUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreUpdate` is called directly before a scene is updated.
     */
    onPreUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostUpdate lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostUpdate` is called directly after a scene is updated.
     */
    onPostUpdate(_engine, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPreDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPreDraw` is called directly before a scene is drawn.
     */
    onPreDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Safe to override onPostDraw lifecycle event handler. Synonymous with `.on('preupdate', (evt) =>{...})`
     *
     * `onPostDraw` is called directly after a scene is drawn.
     */
    onPostDraw(_ctx, _delta) {
        // will be overridden
    }
    /**
     * Initializes actors in the scene
     */
    _initializeChildren() {
        for (const child of this.entities) {
            child._initialize(this.engine);
        }
    }
    /**
     * Gets whether or not the [[Scene]] has been initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Initializes the scene before the first update, meant to be called by engine not by users of
     * Excalibur
     * @internal
     */
    _initialize(engine) {
        if (!this.isInitialized) {
            this.engine = engine;
            // Initialize camera first
            this.camera._initialize(engine);
            // This order is important! we want to be sure any custom init that add actors
            // fire before the actor init
            this.onInitialize.call(this, engine);
            this._initializeChildren();
            this._logger.debug('Scene.onInitialize', this, engine);
            this.eventDispatcher.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
        }
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Activates the scene with the base behavior, then calls the overridable `onActivate` implementation.
     * @internal
     */
    _activate(oldScene, newScene) {
        this._logger.debug('Scene.onActivate', this);
        this.onActivate(oldScene, newScene);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Deactivates the scene with the base behavior, then calls the overridable `onDeactivate` implementation.
     * @internal
     */
    _deactivate(oldScene, newScene) {
        this._logger.debug('Scene.onDeactivate', this);
        this.onDeactivate(oldScene, newScene);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPreUpdate]] lifecycle event
     * @internal
     */
    _preupdate(_engine, delta) {
        this.emit('preupdate', new PreUpdateEvent(_engine, delta, this));
        this.onPreUpdate(_engine, delta);
    }
    /**
     *  It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _preupdate handler for [[onPostUpdate]] lifecycle event
     * @internal
     */
    _postupdate(_engine, delta) {
        this.emit('postupdate', new PostUpdateEvent(_engine, delta, this));
        this.onPostUpdate(_engine, delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _predraw handler for [[onPreDraw]] lifecycle event
     *
     * @internal
     */
    _predraw(_ctx, _delta) {
        this.emit('predraw', new PreDrawEvent(_ctx, _delta, this));
        this.onPreDraw(_ctx, _delta);
    }
    /**
     * It is not recommended that internal excalibur methods be overridden, do so at your own risk.
     *
     * Internal _postdraw handler for [[onPostDraw]] lifecycle event
     *
     * @internal
     */
    _postdraw(_ctx, _delta) {
        this.emit('postdraw', new PostDrawEvent(_ctx, _delta, this));
        this.onPostDraw(_ctx, _delta);
    }
    /**
     * Updates all the actors and timers in the scene. Called by the [[Engine]].
     * @param engine  Reference to the current Engine
     * @param delta   The number of milliseconds since the last update
     */
    update(engine, delta) {
        this._preupdate(engine, delta);
        if (this.camera) {
            this.camera.update(engine, delta);
        }
        // TODO differed entity removal for timers
        let i, len;
        // Remove timers in the cancel queue before updating them
        for (i = 0, len = this._cancelQueue.length; i < len; i++) {
            this.removeTimer(this._cancelQueue[i]);
        }
        this._cancelQueue.length = 0;
        // Cycle through timers updating timers
        for (const timer of this._timers) {
            timer.update(delta);
        }
        this.world.update(SystemType.Update, delta);
        this._collectActorStats(engine);
        engine.input.pointers.dispatchPointerEvents();
        this._postupdate(engine, delta);
    }
    /**
     * Draws all the actors in the Scene. Called by the [[Engine]].
     * @param ctx    The current rendering context
     * @param delta  The number of milliseconds since the last draw
     */
    draw(ctx, delta) {
        var _a;
        this._predraw(ctx, delta);
        this.world.update(SystemType.Draw, delta);
        if ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.isDebug) {
            this.debugDraw(ctx);
        }
        this._postdraw(ctx, delta);
    }
    /**
     * Draws all the actors' debug information in the Scene. Called by the [[Engine]].
     * @param ctx  The current rendering context
     * @deprecated
     */
    /* istanbul ignore next */
    debugDraw(ctx) {
        this.emit('predebugdraw', new PreDebugDrawEvent(ctx, this));
        // pass
        this.emit('postdebugdraw', new PostDebugDrawEvent(ctx, this));
    }
    /**
     * Checks whether an actor is contained in this scene or not
     */
    contains(actor) {
        return this.actors.indexOf(actor) > -1;
    }
    add(entity) {
        this.emit('entityadded', { target: entity });
        this.world.add(entity);
        entity.scene = this;
        if (entity instanceof Timer) {
            if (!contains(this._timers, entity)) {
                this.addTimer(entity);
            }
            return;
        }
    }
    remove(entity) {
        if (entity instanceof Entity) {
            this.emit('entityremoved', { target: entity });
            this.world.remove(entity);
        }
        if (entity instanceof Timer) {
            this.removeTimer(entity);
        }
    }
    /**
     * Adds (any) actor to act as a piece of UI, meaning it is always positioned
     * in screen coordinates. UI actors do not participate in collisions.
     * @todo Should this be `ScreenElement` only?
     * @deprecated Use [[Scene.add]]
     */
    addScreenElement(actor) {
        this.add(actor);
    }
    /**
     * Removes an actor as a piece of UI
     * @deprecated Use [[Scene.remove]]
     */
    removeScreenElement(actor) {
        this.remove(actor);
    }
    /**
     * Adds a [[TileMap]] to the scene, once this is done the TileMap will be drawn and updated.
     * @deprecated Use [[Scene.add]]
     */
    addTileMap(tileMap) {
        this.world.add(tileMap);
    }
    /**
     * Removes a [[TileMap]] from the scene, it will no longer be drawn or updated.
     * @deprecated Use [[Scene.remove]]
     */
    removeTileMap(tileMap) {
        this.world.remove(tileMap);
    }
    /**
     * Adds a [[Timer]] to the scene
     * @param timer  The timer to add
     */
    addTimer(timer) {
        this._timers.push(timer);
        timer.scene = this;
        return timer;
    }
    /**
     * Removes a [[Timer]] from the scene.
     * @warning Can be dangerous, use [[cancelTimer]] instead
     * @param timer  The timer to remove
     */
    removeTimer(timer) {
        const i = this._timers.indexOf(timer);
        if (i !== -1) {
            this._timers.splice(i, 1);
        }
        return timer;
    }
    /**
     * Cancels a [[Timer]], removing it from the scene nicely
     * @param timer  The timer to cancel
     */
    cancelTimer(timer) {
        this._cancelQueue.push(timer);
        return timer;
    }
    /**
     * Tests whether a [[Timer]] is active in the scene
     */
    isTimerActive(timer) {
        return this._timers.indexOf(timer) > -1 && !timer.complete;
    }
    isCurrentScene() {
        if (this.engine) {
            return this.engine.currentScene === this;
        }
        return false;
    }
    _collectActorStats(engine) {
        const screenElements = this.actors.filter((a) => a instanceof ScreenElement_ScreenElement);
        for (const _ui of screenElements) {
            engine.stats.currFrame.actors.ui++;
        }
        for (const actor of this.actors) {
            engine.stats.currFrame.actors.alive++;
            for (const child of actor.children) {
                if (isScreenElement(child)) {
                    // TODO not true
                    engine.stats.currFrame.actors.ui++;
                }
                else {
                    engine.stats.currFrame.actors.alive++;
                }
            }
        }
    }
}
Scene_decorate([
    obsolete({
        message: 'Will be removed in excalibur v0.26.0',
        alternateMethod: 'ScreenElements now are normal actors with a Transform Coordinate Plane of Screen'
    })
], Scene.prototype, "screenElements", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.add' })
], Scene.prototype, "addScreenElement", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.remove' })
], Scene.prototype, "removeScreenElement", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.add' })
], Scene.prototype, "addTileMap", null);
Scene_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Scene.remove' })
], Scene.prototype, "removeTileMap", null);

;// CONCATENATED MODULE: ./PostProcessing/ColorBlindCorrector.ts

var ColorBlindness;
(function (ColorBlindness) {
    ColorBlindness[ColorBlindness["Protanope"] = 0] = "Protanope";
    ColorBlindness[ColorBlindness["Deuteranope"] = 1] = "Deuteranope";
    ColorBlindness[ColorBlindness["Tritanope"] = 2] = "Tritanope";
})(ColorBlindness || (ColorBlindness = {}));
/**
 * This post processor can correct colors and simulate color blindness.
 * It is possible to use this on every game, but the game's performance
 * will suffer measurably. It's better to use it as a helpful tool while developing your game.
 * Remember, the best practice is to design with color blindness in mind.
 */
class ColorBlindCorrector {
    constructor(engine, simulate = false, colorMode = ColorBlindness.Protanope) {
        this.engine = engine;
        this.simulate = simulate;
        this.colorMode = colorMode;
        /*eslint-disable */
        this._vertexShader = '' +
            'attribute vec2 a_position;' +
            'attribute vec2 a_texCoord;' +
            'uniform vec2 u_resolution;' +
            'varying vec2 v_texCoord;' +
            'void main() {' +
            // convert the rectangle from pixels to 0.0 to 1.0
            'vec2 zeroToOne = a_position / u_resolution;' +
            // convert from 0->1 to 0->2
            'vec2 zeroToTwo = zeroToOne * 2.0;' +
            // convert from 0->2 to -1->+1 (clipspace)
            'vec2 clipSpace = zeroToTwo - 1.0;' +
            'gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);' +
            // pass the texCoord to the fragment shader
            // The GPU will interpolate this value between points.
            'v_texCoord = a_texCoord;' +
            '}';
        this._fragmentShader = 'precision mediump float;' +
            // our texture
            'uniform sampler2D u_image;' +
            // the texCoords passed in from the vertex shader.
            'varying vec2 v_texCoord;' +
            // Color blind conversions
            /*'mat3 m[9] =' +
           '{' +
              'mat3(1.0, 0.0, 0.0,  0.0, 1.0, 0.0,  0.0, 0.0, 1.0  ),' + // normal
              'mat3(0.567, 0.433, 0.0,  0.558, 0.442, 0.0,  0.0, 0.242, 0.758),' + // protanopia
              'mat3(0.817, 0.183, 0.0,  0.333, 0.667, 0.0,  0.0, 0.125,0.875),' + // protanomaly
              'mat3(0.625, 0.375, 0.0,  0.7, 0.3, 0.0,  0.0, 0.3,0.7  ),' + // deuteranopia
              'mat3(0.8, 0.2, 0.0,  0.258, 0.742, 0.0,  0.0, 0.142,0.858),' + // deuteranomaly
              'mat3(0.95, 0.05, 0.0,  0.0, 0.433, 0.567,  0.0, 0.475,0.525),' + // tritanopia
              'mat3(0.967, 0.033, 0.0,  0.0, 0.733, 0.267,  0.0, 0.183,0.817),' + // tritanomaly
              'mat3(0.299, 0.587, 0.114,  0.299, 0.587, 0.114,  0.299, 0.587,0.114),' + // achromatopsia
              'mat3(0.618, 0.320, 0.062,  0.163, 0.775, 0.062,  0.163, 0.320,0.516)' +  // achromatomaly
           '};' +*/
            'void main() {' +
            'vec4 o =  texture2D(u_image, v_texCoord);' +
            // RGB to LMS matrix conversion
            'float L = (17.8824 * o.r) + (43.5161 * o.g) + (4.11935 * o.b);' +
            'float M = (3.45565 * o.r) + (27.1554 * o.g) + (3.86714 * o.b);' +
            'float S = (0.0299566 * o.r) + (0.184309 * o.g) + (1.46709 * o.b);' +
            // Simulate color blindness
            '//MODE CODE//' +
            /* Deuteranope for testing
              'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;' +*/
            // LMS to RGB matrix conversion
            'vec4 error;' +
            'error.r = (0.0809444479 * l) + (-0.130504409 * m) + (0.116721066 * s);' +
            'error.g = (-0.0102485335 * l) + (0.0540193266 * m) + (-0.113614708 * s);' +
            'error.b = (-0.000365296938 * l) + (-0.00412161469 * m) + (0.693511405 * s);' +
            'error.a = 1.0;' +
            'vec4 diff = o - error;' +
            'vec4 correction;' +
            'correction.r = 0.0;' +
            'correction.g =  (diff.r * 0.7) + (diff.g * 1.0);' +
            'correction.b =  (diff.r * 0.7) + (diff.b * 1.0);' +
            'correction = o + correction;' +
            'correction.a = o.a;' +
            '//SIMULATE//' +
            '}';
        this._internalCanvas = document.createElement('canvas');
        this._internalCanvas.width = engine.drawWidth;
        this._internalCanvas.height = engine.drawHeight;
        // eslint-disable-next-line
        this._gl = this._internalCanvas.getContext('webgl', { preserveDrawingBuffer: true });
        this._program = this._gl.createProgram();
        const fragmentShader = this._getShader('Fragment', this._getFragmentShaderByMode(colorMode));
        const vertextShader = this._getShader('Vertex', this._vertexShader);
        this._gl.attachShader(this._program, vertextShader);
        this._gl.attachShader(this._program, fragmentShader);
        this._gl.linkProgram(this._program);
        if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS)) {
            Logger.getInstance().error('Unable to link shader program!');
        }
        this._gl.useProgram(this._program);
    }
    _getFragmentShaderByMode(colorMode) {
        let code = '';
        if (colorMode === ColorBlindness.Protanope) {
            code =
                'float l = 0.0 * L + 2.02344 * M + -2.52581 * S;' +
                    'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
        }
        else if (colorMode === ColorBlindness.Deuteranope) {
            code =
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.494207 * L + 0.0 * M + 1.24827 * S;' +
                    'float s = 0.0 * L + 0.0 * M + 1.0 * S;';
        }
        else if (colorMode === ColorBlindness.Tritanope) {
            code =
                'float l = 1.0 * L + 0.0 * M + 0.0 * S;' +
                    'float m = 0.0 * L + 1.0 * M + 0.0 * S;' +
                    'float s = -0.395913 * L + 0.801109 * M + 0.0 * S;';
        }
        if (this.simulate) {
            this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = error.rgba;');
        }
        else {
            this._fragmentShader = this._fragmentShader.replace('//SIMULATE//', 'gl_FragColor = correction.rgba;');
        }
        return this._fragmentShader.replace('//MODE CODE//', code);
    }
    _setRectangle(x, y, width, height) {
        const x1 = x;
        const x2 = x + width;
        const y1 = y;
        const y2 = y + height;
        this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([x1, y1, x2, y1, x1, y2, x1, y2, x2, y1, x2, y2]), this._gl.STATIC_DRAW);
    }
    _getShader(type, program) {
        let shader;
        if (type === 'Fragment') {
            shader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
        }
        else if (type === 'Vertex') {
            shader = this._gl.createShader(this._gl.VERTEX_SHADER);
        }
        else {
            Logger.getInstance().error('Error unknown shader type', type);
        }
        this._gl.shaderSource(shader, program);
        this._gl.compileShader(shader);
        if (!this._gl.getShaderParameter(shader, this._gl.COMPILE_STATUS)) {
            Logger.getInstance().error('Unable to compile shader!', this._gl.getShaderInfoLog(shader));
            return null;
        }
        return shader;
    }
    process(image, out) {
        // look up where the vertex data needs to go.
        const positionLocation = this._gl.getAttribLocation(this._program, 'a_position');
        const texCoordLocation = this._gl.getAttribLocation(this._program, 'a_texCoord');
        const texCoordBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, texCoordBuffer);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), this._gl.STATIC_DRAW);
        this._gl.enableVertexAttribArray(texCoordLocation);
        this._gl.vertexAttribPointer(texCoordLocation, 2, this._gl.FLOAT, false, 0, 0);
        // Create a texture.
        const texture = this._gl.createTexture();
        this._gl.bindTexture(this._gl.TEXTURE_2D, texture);
        // Set the parameters so we can render any size image.
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.NEAREST);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.NEAREST);
        // Flip the texture when unpacking into the gl context, gl reads textures in the opposite order as everything else :/
        this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, 1);
        // Upload the image into the texture.
        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, image);
        // lookup uniforms
        const resolutionLocation = this._gl.getUniformLocation(this._program, 'u_resolution');
        // set the resolution
        this._gl.uniform2f(resolutionLocation, this._internalCanvas.width, this._internalCanvas.height);
        // Create a buffer for the position of the rectangle corners.
        const positionBuffer = this._gl.createBuffer();
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, positionBuffer);
        this._gl.enableVertexAttribArray(positionLocation);
        this._gl.vertexAttribPointer(positionLocation, 2, this._gl.FLOAT, false, 0, 0);
        // Set a rectangle the same size as the image.
        this._setRectangle(0, 0, image.width, image.height);
        // Draw the rectangle.
        this._gl.drawArrays(this._gl.TRIANGLES, 0, 6);
        // Grab transformed image from internal canvas
        const pixelData = new Uint8Array(image.width * image.height * 4);
        this._gl.readPixels(0, 0, image.width, image.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixelData);
        image.data.set(pixelData);
        out.putImageData(image, 0, 0);
    }
}

;// CONCATENATED MODULE: ./Debug/DebugFlags.ts

class ColorBlindFlags {
    constructor(engine) {
        this._engine = engine;
    }
    correct(colorBlindness) {
        this._engine.postProcessors.push(new ColorBlindCorrector(this._engine, false, colorBlindness));
    }
    simulate(colorBlindness) {
        this._engine.postProcessors.push(new ColorBlindCorrector(this._engine, true, colorBlindness));
    }
}

;// CONCATENATED MODULE: ./Debug/Debug.ts


/**
 * Debug statistics and flags for Excalibur. If polling these values, it would be
 * best to do so on the `postupdate` event for [[Engine]], after all values have been
 * updated during a frame.
 */
class Debug {
    constructor(engine) {
        /**
         * Performance statistics
         */
        this.stats = {
            /**
             * Current frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[postframe]] event. See [[FrameStats]]
             */
            currFrame: new FrameStats(),
            /**
             * Previous frame statistics. Engine reuses this instance, use [[FrameStats.clone]] to copy frame stats.
             * Best accessed on [[preframe]] event. Best inspected on engine event `preframe`. See [[FrameStats]]
             */
            prevFrame: new FrameStats()
        };
        /**
         * Filter debug context to named entities or entity ids
         */
        this.filter = {
            /**
             * Toggle filter on or off (default off) must be on for DebugDraw to use filters
             */
            useFilter: false,
            /**
             * Query for entities by name, if the entity name contains `nameQuery` it will be included
             */
            nameQuery: '',
            /**
             * Query for Entity ids, if the id matches it will be included
             */
            ids: []
        };
        /**
         * Entity debug settings
         */
        this.entity = {
            showAll: false,
            showId: true,
            showName: false
        };
        /**
         * Transform component debug settings
         */
        this.transform = {
            showAll: false,
            showPosition: false,
            positionColor: Color.Yellow,
            showScale: false,
            scaleColor: Color.Green,
            showRotation: false,
            rotationColor: Color.Blue
        };
        /**
         * Graphics component debug settings
         */
        this.graphics = {
            showAll: false,
            showBounds: true,
            boundsColor: Color.Yellow
        };
        /**
         * Collider component debug settings
         */
        this.collider = {
            showAll: false,
            showBounds: true,
            boundsColor: Color.Blue,
            showOwner: false,
            showGeometry: true,
            geometryColor: Color.Green
        };
        /**
         * Physics simulation debug settings
         */
        this.physics = {
            showAll: false,
            showBroadphaseSpacePartitionDebug: false,
            showCollisionNormals: false,
            collisionNormalColor: Color.Cyan,
            showCollisionContacts: true,
            collisionContactColor: Color.Red
        };
        /**
         * Motion component debug settings
         */
        this.motion = {
            showAll: false,
            showVelocity: false,
            velocityColor: Color.Yellow,
            showAcceleration: false,
            accelerationColor: Color.Red
        };
        /**
         * Body component debug settings
         */
        this.body = {
            showAll: false,
            showCollisionGroup: false,
            showCollisionType: false,
            showSleeping: false,
            showMotion: false,
            showMass: false
        };
        /**
         * Camera debug settings
         */
        this.camera = {
            showAll: false,
            showFocus: false,
            focusColor: Color.Red,
            showZoom: false
        };
        this._engine = engine;
        this.colorBlindMode = new ColorBlindFlags(this._engine);
    }
}
/**
 * Implementation of a frame's stats. Meant to have values copied via [[FrameStats.reset]], avoid
 * creating instances of this every frame.
 */
class FrameStats {
    constructor() {
        this._id = 0;
        this._delta = 0;
        this._fps = 0;
        this._actorStats = {
            alive: 0,
            killed: 0,
            ui: 0,
            get remaining() {
                return this.alive - this.killed;
            },
            get total() {
                return this.remaining + this.ui;
            }
        };
        this._durationStats = {
            update: 0,
            draw: 0,
            get total() {
                return this.update + this.draw;
            }
        };
        this._physicsStats = new PhysicsStats();
        this._graphicsStats = {
            drawCalls: 0,
            drawnImages: 0
        };
    }
    /**
     * Zero out values or clone other IFrameStat stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.id = otherStats.id;
            this.delta = otherStats.delta;
            this.fps = otherStats.fps;
            this.actors.alive = otherStats.actors.alive;
            this.actors.killed = otherStats.actors.killed;
            this.actors.ui = otherStats.actors.ui;
            this.duration.update = otherStats.duration.update;
            this.duration.draw = otherStats.duration.draw;
            this._physicsStats.reset(otherStats.physics);
            this.graphics.drawCalls = otherStats.graphics.drawCalls;
            this.graphics.drawnImages = otherStats.graphics.drawnImages;
        }
        else {
            this.id = this.delta = this.fps = 0;
            this.actors.alive = this.actors.killed = this.actors.ui = 0;
            this.duration.update = this.duration.draw = 0;
            this._physicsStats.reset();
            this.graphics.drawnImages = this.graphics.drawCalls = 0;
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const fs = new FrameStats();
        fs.reset(this);
        return fs;
    }
    /**
     * Gets the frame's id
     */
    get id() {
        return this._id;
    }
    /**
     * Sets the frame's id
     */
    set id(value) {
        this._id = value;
    }
    /**
     * Gets the frame's delta (time since last frame)
     */
    get delta() {
        return this._delta;
    }
    /**
     * Sets the frame's delta (time since last frame). Internal use only.
     * @internal
     */
    set delta(value) {
        this._delta = value;
    }
    /**
     * Gets the frame's frames-per-second (FPS)
     */
    get fps() {
        return this._fps;
    }
    /**
     * Sets the frame's frames-per-second (FPS). Internal use only.
     * @internal
     */
    set fps(value) {
        this._fps = value;
    }
    /**
     * Gets the frame's actor statistics
     */
    get actors() {
        return this._actorStats;
    }
    /**
     * Gets the frame's duration statistics
     */
    get duration() {
        return this._durationStats;
    }
    /**
     * Gets the frame's physics statistics
     */
    get physics() {
        return this._physicsStats;
    }
    /**
     * Gets the frame's graphics statistics
     */
    get graphics() {
        return this._graphicsStats;
    }
}
class PhysicsStats {
    constructor() {
        this._pairs = 0;
        this._collisions = 0;
        this._contacts = new Map();
        this._fastBodies = 0;
        this._fastBodyCollisions = 0;
        this._broadphase = 0;
        this._narrowphase = 0;
    }
    /**
     * Zero out values or clone other IPhysicsStats stats. Allows instance reuse.
     *
     * @param [otherStats] Optional stats to clone
     */
    reset(otherStats) {
        if (otherStats) {
            this.pairs = otherStats.pairs;
            this.collisions = otherStats.collisions;
            this.contacts = otherStats.contacts;
            this.fastBodies = otherStats.fastBodies;
            this.fastBodyCollisions = otherStats.fastBodyCollisions;
            this.broadphase = otherStats.broadphase;
            this.narrowphase = otherStats.narrowphase;
        }
        else {
            this.pairs = this.collisions = this.fastBodies = 0;
            this.fastBodyCollisions = this.broadphase = this.narrowphase = 0;
            this.contacts.clear();
        }
    }
    /**
     * Provides a clone of this instance.
     */
    clone() {
        const ps = new PhysicsStats();
        ps.reset(this);
        return ps;
    }
    get pairs() {
        return this._pairs;
    }
    set pairs(value) {
        this._pairs = value;
    }
    get collisions() {
        return this._collisions;
    }
    set collisions(value) {
        this._collisions = value;
    }
    get contacts() {
        return this._contacts;
    }
    set contacts(contacts) {
        this._contacts = contacts;
    }
    get fastBodies() {
        return this._fastBodies;
    }
    set fastBodies(value) {
        this._fastBodies = value;
    }
    get fastBodyCollisions() {
        return this._fastBodyCollisions;
    }
    set fastBodyCollisions(value) {
        this._fastBodyCollisions = value;
    }
    get broadphase() {
        return this._broadphase;
    }
    set broadphase(value) {
        this._broadphase = value;
    }
    get narrowphase() {
        return this._narrowphase;
    }
    set narrowphase(value) {
        this._narrowphase = value;
    }
}

;// CONCATENATED MODULE: ./Input/Keyboard.ts



/**
 * Enum representing physical input key codes
 */
var Keys;
(function (Keys) {
    // NUMPAD
    Keys["Num0"] = "Numpad0";
    Keys["Num1"] = "Numpad1";
    Keys["Num2"] = "Numpad2";
    Keys["Num3"] = "Numpad3";
    Keys["Num4"] = "Numpad4";
    Keys["Num5"] = "Numpad5";
    Keys["Num6"] = "Numpad6";
    Keys["Num7"] = "Numpad7";
    Keys["Num8"] = "Numpad8";
    Keys["Num9"] = "Numpad9";
    Keys["NumAdd"] = "NumpadAdd";
    Keys["NumSubtract"] = "NumpadSubtract";
    Keys["NumMultiply"] = "NumpadMultiply";
    Keys["NumDivide"] = "NumpadDivide";
    // NumComma = 'NumpadComma', // not x-browser
    Keys["NumDecimal"] = "NumpadDecimal";
    Keys["Numpad0"] = "Numpad0";
    Keys["Numpad1"] = "Numpad1";
    Keys["Numpad2"] = "Numpad2";
    Keys["Numpad3"] = "Numpad3";
    Keys["Numpad4"] = "Numpad4";
    Keys["Numpad5"] = "Numpad5";
    Keys["Numpad6"] = "Numpad6";
    Keys["Numpad7"] = "Numpad7";
    Keys["Numpad8"] = "Numpad8";
    Keys["Numpad9"] = "Numpad9";
    Keys["NumpadAdd"] = "NumpadAdd";
    Keys["NumpadSubtract"] = "NumpadSubtract";
    Keys["NumpadMultiply"] = "NumpadMultiply";
    Keys["NumpadDivide"] = "NumpadDivide";
    // NumpadComma = 'NumpadComma', // not x-browser
    Keys["NumpadDecimal"] = "NumpadDecimal";
    // MODIFIERS
    Keys["NumLock"] = "NumLock";
    Keys["ShiftLeft"] = "ShiftLeft";
    Keys["ShiftRight"] = "ShiftRight";
    Keys["AltLeft"] = "AltLeft";
    Keys["AltRight"] = "AltRight";
    // NUMBERS
    Keys["Key0"] = "Digit0";
    Keys["Key1"] = "Digit1";
    Keys["Key2"] = "Digit2";
    Keys["Key3"] = "Digit3";
    Keys["Key4"] = "Digit4";
    Keys["Key5"] = "Digit5";
    Keys["Key6"] = "Digit6";
    Keys["Key7"] = "Digit7";
    Keys["Key8"] = "Digit8";
    Keys["Key9"] = "Digit9";
    Keys["Digit0"] = "Digit0";
    Keys["Digit1"] = "Digit1";
    Keys["Digit2"] = "Digit2";
    Keys["Digit3"] = "Digit3";
    Keys["Digit4"] = "Digit4";
    Keys["Digit5"] = "Digit5";
    Keys["Digit6"] = "Digit6";
    Keys["Digit7"] = "Digit7";
    Keys["Digit8"] = "Digit8";
    Keys["Digit9"] = "Digit9";
    // LETTERS
    Keys["A"] = "KeyA";
    Keys["B"] = "KeyB";
    Keys["C"] = "KeyC";
    Keys["D"] = "KeyD";
    Keys["E"] = "KeyE";
    Keys["F"] = "KeyF";
    Keys["G"] = "KeyG";
    Keys["H"] = "KeyH";
    Keys["I"] = "KeyI";
    Keys["J"] = "KeyJ";
    Keys["K"] = "KeyK";
    Keys["L"] = "KeyL";
    Keys["M"] = "KeyM";
    Keys["N"] = "KeyN";
    Keys["O"] = "KeyO";
    Keys["P"] = "KeyP";
    Keys["Q"] = "KeyQ";
    Keys["R"] = "KeyR";
    Keys["S"] = "KeyS";
    Keys["T"] = "KeyT";
    Keys["U"] = "KeyU";
    Keys["V"] = "KeyV";
    Keys["W"] = "KeyW";
    Keys["X"] = "KeyX";
    Keys["Y"] = "KeyY";
    Keys["Z"] = "KeyZ";
    Keys["KeyA"] = "KeyA";
    Keys["KeyB"] = "KeyB";
    Keys["KeyC"] = "KeyC";
    Keys["KeyD"] = "KeyD";
    Keys["KeyE"] = "KeyE";
    Keys["KeyF"] = "KeyF";
    Keys["KeyG"] = "KeyG";
    Keys["KeyH"] = "KeyH";
    Keys["KeyI"] = "KeyI";
    Keys["KeyJ"] = "KeyJ";
    Keys["KeyK"] = "KeyK";
    Keys["KeyL"] = "KeyL";
    Keys["KeyM"] = "KeyM";
    Keys["KeyN"] = "KeyN";
    Keys["KeyO"] = "KeyO";
    Keys["KeyP"] = "KeyP";
    Keys["KeyQ"] = "KeyQ";
    Keys["KeyR"] = "KeyR";
    Keys["KeyS"] = "KeyS";
    Keys["KeyT"] = "KeyT";
    Keys["KeyU"] = "KeyU";
    Keys["KeyV"] = "KeyV";
    Keys["KeyW"] = "KeyW";
    Keys["KeyX"] = "KeyX";
    Keys["KeyY"] = "KeyY";
    Keys["KeyZ"] = "KeyZ";
    // SYMBOLS
    Keys["Semicolon"] = "Semicolon";
    Keys["Quote"] = "Quote";
    Keys["Comma"] = "Comma";
    Keys["Minus"] = "Minus";
    Keys["Period"] = "Period";
    Keys["Slash"] = "Slash";
    Keys["Equal"] = "Equal";
    Keys["BracketLeft"] = "BracketLeft";
    Keys["Backslash"] = "Backslash";
    Keys["BracketRight"] = "BracketRight";
    Keys["Backquote"] = "Backquote";
    // DIRECTIONS
    Keys["Up"] = "ArrowUp";
    Keys["Down"] = "ArrowDown";
    Keys["Left"] = "ArrowLeft";
    Keys["Right"] = "ArrowRight";
    Keys["ArrowUp"] = "ArrowUp";
    Keys["ArrowDown"] = "ArrowDown";
    Keys["ArrowLeft"] = "ArrowLeft";
    Keys["ArrowRight"] = "ArrowRight";
    // OTHER
    Keys["Space"] = "Space";
    Keys["Esc"] = "Escape";
    Keys["Escape"] = "Escape";
})(Keys || (Keys = {}));
/**
 * Event thrown on a game object for a key event
 */
class KeyEvent extends GameEvent {
    /**
     * @param key  The key responsible for throwing the event
     * @param value The key's typed value the browser detected
     * @param originalEvent The original keyboard event that Excalibur handled
     */
    constructor(key, value, originalEvent) {
        super();
        this.key = key;
        this.value = value;
        this.originalEvent = originalEvent;
    }
}
/**
 * Provides keyboard support for Excalibur.
 */
class Keyboard extends Class {
    constructor() {
        super();
        this._keys = [];
        this._keysUp = [];
        this._keysDown = [];
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    /**
     * Initialize Keyboard event listeners
     */
    init(global) {
        if (!global) {
            try {
                // Try and listen to events on top window frame if within an iframe.
                //
                // See https://github.com/excaliburjs/Excalibur/issues/1294
                //
                // Attempt to add an event listener, which triggers a DOMException on
                // cross-origin iframes
                const noop = () => {
                    return;
                };
                window.top.addEventListener('blur', noop);
                window.top.removeEventListener('blur', noop);
                // this will be the same as window if not embedded within an iframe
                global = window.top;
            }
            catch (_a) {
                // fallback to current frame
                global = window;
                Logger.getInstance().warn('Failed to bind to keyboard events to top frame. ' +
                    'If you are trying to embed Excalibur in a cross-origin iframe, keyboard events will not fire.');
            }
        }
        global.addEventListener('blur', () => {
            this._keys.length = 0; // empties array efficiently
        });
        // key up is on window because canvas cannot have focus
        global.addEventListener('keyup', (ev) => {
            const code = ev.code;
            const key = this._keys.indexOf(code);
            this._keys.splice(key, 1);
            this._keysUp.push(code);
            const keyEvent = new KeyEvent(code, ev.key, ev);
            // alias the old api, we may want to deprecate this in the future
            this.eventDispatcher.emit('up', keyEvent);
            this.eventDispatcher.emit('release', keyEvent);
        });
        // key down is on window because canvas cannot have focus
        global.addEventListener('keydown', (ev) => {
            const code = ev.code;
            if (this._keys.indexOf(code) === -1) {
                this._keys.push(code);
                this._keysDown.push(code);
                const keyEvent = new KeyEvent(code, ev.key, ev);
                this.eventDispatcher.emit('down', keyEvent);
                this.eventDispatcher.emit('press', keyEvent);
            }
        });
    }
    update() {
        // Reset keysDown and keysUp after update is complete
        this._keysDown.length = 0;
        this._keysUp.length = 0;
        // Emit synthetic "hold" event
        for (let i = 0; i < this._keys.length; i++) {
            this.eventDispatcher.emit('hold', new KeyEvent(this._keys[i]));
        }
    }
    /**
     * Gets list of keys being pressed down
     */
    getKeys() {
        return this._keys;
    }
    /**
     * Tests if a certain key was just pressed this frame. This is cleared at the end of the update frame.
     * @param key Test whether a key was just pressed
     */
    wasPressed(key) {
        return this._keysDown.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key is held down. This is persisted between frames.
     * @param key  Test whether a key is held down
     */
    isHeld(key) {
        return this._keys.indexOf(key) > -1;
    }
    /**
     * Tests if a certain key was just released this frame. This is cleared at the end of the update frame.
     * @param key  Test whether a key was just released
     */
    wasReleased(key) {
        return this._keysUp.indexOf(key) > -1;
    }
}

;// CONCATENATED MODULE: ./Input/Pointer.ts




/**
 * The type of pointer for a [[PointerEvent]].
 */
var PointerType;
(function (PointerType) {
    PointerType["Touch"] = "Touch";
    PointerType["Mouse"] = "Mouse";
    PointerType["Pen"] = "Pen";
    PointerType["Unknown"] = "Unknown";
})(PointerType || (PointerType = {}));
/**
 * Determines the scope of handling mouse/touch events. See [[Pointers]] for more information.
 */
var PointerScope;
(function (PointerScope) {
    /**
     * Handle events on the `canvas` element only. Events originating outside the
     * `canvas` will not be handled.
     */
    PointerScope["Canvas"] = "Canvas";
    /**
     * Handles events on the entire document. All events will be handled by Excalibur.
     */
    PointerScope["Document"] = "Document";
})(PointerScope || (PointerScope = {}));
/**
 * Captures and dispatches PointerEvents
 */
class Pointer extends Class {
    constructor() {
        super();
        this.id = Pointer._MAX_ID++;
        this._isDown = false;
        this._wasDown = false;
        this._actorsUnderPointer = { length: 0 };
        this._actors = [];
        this._actorsLastFrame = [];
        this._actorsNoLongerUnderPointer = [];
        this._actorSortingFcn = (a, b) => {
            if (a.z === b.z) {
                return b.id - a.id;
            }
            return b.z - a.z;
        };
        /**
         * The last position on the document this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastPagePos = null;
        /**
         * The last position on the screen this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastScreenPos = null;
        /**
         * The last position in the game world coordinates this pointer was at. Can be `null` if pointer was never active.
         */
        this.lastWorldPos = null;
        /**
         * Returns the currently dragging target or null if it isn't exist
         */
        this.dragTarget = null;
        this.on('move', this._onPointerMove);
        this.on('down', this._onPointerDown);
        this.on('up', this._onPointerUp);
    }
    /**
     * Whether the Pointer is currently dragging.
     */
    get isDragging() {
        return this._isDown;
    }
    /**
     * Whether the Pointer just started dragging.
     */
    get isDragStart() {
        return !this._wasDown && this._isDown;
    }
    /**
     * Whether the Pointer just ended dragging.
     */
    get isDragEnd() {
        return this._wasDown && !this._isDown;
    }
    /**
     * Returns true if pointer has any actors under
     */
    get hasActorsUnderPointer() {
        return !!this._actorsUnderPointer.length;
    }
    on(event, handler) {
        super.on(event, handler);
    }
    once(event, handler) {
        super.once(event, handler);
    }
    off(event, handler) {
        super.off(event, handler);
    }
    /**
     * Update the state of current pointer, meant to be called a the end of frame
     */
    update() {
        if (this._wasDown && !this._isDown) {
            this._wasDown = false;
        }
        else if (!this._wasDown && this._isDown) {
            this._wasDown = true;
        }
        this._actorsLastFrame = [...this._actors];
        this._actorsNoLongerUnderPointer = [];
    }
    /**
     * Adds an Actor to actorsUnderPointer object.
     * @param actor An Actor to be added;
     */
    addActorUnderPointer(actor) {
        if (!this.isActorAliveUnderPointer(actor)) {
            this._actorsUnderPointer[actor.id] = actor;
            this._actorsUnderPointer.length += 1;
            this._actors.push(actor);
        }
        // Actors are processed in z-order highest z to lowest
        // ties are broken by id highest id (newest) to lowest id (oldest)
        this._actors.sort(this._actorSortingFcn);
    }
    /**
     * Removes an Actor from actorsUnderPointer object.
     * @param actor An Actor to be removed;
     */
    removeActorUnderPointer(actor) {
        if (this.isActorAliveUnderPointer(actor)) {
            delete this._actorsUnderPointer[actor.id];
            this._actorsUnderPointer.length -= 1;
            removeItemFromArray(actor, this._actors);
            this._actorsNoLongerUnderPointer.push(actor);
        }
    }
    /**
     * Returns all actors under this pointer this frame
     */
    getActorsUnderPointer() {
        return this._actors;
    }
    /**
     * Returns all actors that are no longer under the pointer this frame
     */
    getActorsUnderPointerLastFrame() {
        return this._actorsLastFrame;
    }
    /**
     * Returns all actors relevant for events to pointer this frame
     */
    getActorsForEvents() {
        return this._actors
            .concat(this._actorsLastFrame)
            .filter((actor, i, self) => {
            return self.indexOf(actor) === i; // de-dup
        })
            .sort(this._actorSortingFcn); // sort by z
    }
    /**
     * Checks if Pointer location has a specific Actor bounds contained underneath.
     * @param actor An Actor for check;
     */
    checkActorUnderPointer(actor) {
        if (this.lastWorldPos) {
            return actor.contains(this.lastWorldPos.x, this.lastWorldPos.y, !isScreenElement(actor));
        }
        return false;
    }
    /**
     * Checks if an actor was under the pointer last frame
     * @param actor
     */
    wasActorUnderPointer(actor) {
        return this._actorsLastFrame.indexOf(actor) > -1;
    }
    /**
     * Checks if Pointer has a specific Actor in ActorsUnderPointer list.
     * @param actor An Actor for check;
     */
    isActorAliveUnderPointer(actor) {
        return !!(!actor.isKilled() && actor.scene && this._actorsUnderPointer.hasOwnProperty(actor.id.toString()));
    }
    _onPointerMove(ev) {
        this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
        this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
        this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
    }
    _onPointerDown(ev) {
        this.lastPagePos = new Vector(ev.pagePos.x, ev.pagePos.y);
        this.lastScreenPos = new Vector(ev.screenPos.x, ev.screenPos.y);
        this.lastWorldPos = new Vector(ev.worldPos.x, ev.worldPos.y);
        this._isDown = true;
    }
    _onPointerUp(_ev) {
        this._isDown = false;
        this.dragTarget = null;
    }
}
Pointer._MAX_ID = 0;

;// CONCATENATED MODULE: ./Input/PointerEvents.ts

/**
 * Native browser button enumeration
 */
var NativePointerButton;
(function (NativePointerButton) {
    NativePointerButton[NativePointerButton["NoButton"] = -1] = "NoButton";
    NativePointerButton[NativePointerButton["Left"] = 0] = "Left";
    NativePointerButton[NativePointerButton["Middle"] = 1] = "Middle";
    NativePointerButton[NativePointerButton["Right"] = 2] = "Right";
    NativePointerButton[NativePointerButton["Unknown"] = 3] = "Unknown";
})(NativePointerButton || (NativePointerButton = {}));
/**
 * The mouse button being pressed.
 */
var PointerButton;
(function (PointerButton) {
    PointerButton["Left"] = "Left";
    PointerButton["Middle"] = "Middle";
    PointerButton["Right"] = "Right";
    PointerButton["Unknown"] = "Unknown";
    PointerButton["NoButton"] = "NoButton";
})(PointerButton || (PointerButton = {}));
var WheelDeltaMode;
(function (WheelDeltaMode) {
    WheelDeltaMode["Pixel"] = "Pixel";
    WheelDeltaMode["Line"] = "Line";
    WheelDeltaMode["Page"] = "Page";
})(WheelDeltaMode || (WheelDeltaMode = {}));
/**
 * Pointer events
 *
 * Represents a mouse, touch, or stylus event. See [[Pointers]] for more information on
 * handling pointer input.
 *
 * For mouse-based events, you can inspect [[PointerEvent.button]] to see what button was pressed.
 */
class PointerEvent extends GameEvent {
    /**
     * @param coordinates         The [[GlobalCoordinates]] of the event
     * @param pointer             The [[Pointer]] of the event
     * @param index               The index of the pointer (zero-based)
     * @param pointerType         The type of pointer
     * @param button              The button pressed (if [[PointerType.Mouse]])
     * @param ev                  The raw DOM event being handled
     */
    constructor(coordinates, pointer, index, pointerType, button, ev) {
        super();
        this.coordinates = coordinates;
        this.pointer = pointer;
        this.index = index;
        this.pointerType = pointerType;
        this.button = button;
        this.ev = ev;
        this._canceled = false;
    }
    get name() {
        return this._name;
    }
    /** The world coordinates of the event. */
    get worldPos() {
        return this.coordinates.worldPos.clone();
    }
    /** The page coordinates of the event. */
    get pagePos() {
        return this.coordinates.pagePos.clone();
    }
    /** The screen coordinates of the event. */
    get screenPos() {
        return this.coordinates.screenPos.clone();
    }
    get pos() {
        return this.coordinates.worldPos.clone();
    }
    /**
     * Cancels pointer event propogation, event will not be transmitted to any other actors
     */
    cancel() {
        this._canceled = true;
    }
    /**
     *
     * @returns If the event is canceled it will no longer be transmitted to any other actors
     */
    isCanceled() {
        return this._canceled;
    }
    propagate(actor) {
        this.doAction(actor);
        if (this.bubbles && !this.isCanceled() && actor.parent) {
            this.propagate(actor.parent); // TODO not true
        }
    }
    /**
     * Action, that calls when event happens
     */
    doAction(actor) {
        if (actor) {
            this._onActionStart(actor);
            actor.emit(this._name, this);
            this._onActionEnd(actor);
        }
    }
    _onActionStart(_actor) {
        // to be rewritten
    }
    _onActionEnd(_actor) {
        // to be rewritten
    }
}
class PointerEventFactory {
    constructor(_pointerEventType) {
        this._pointerEventType = _pointerEventType;
    }
    /**
     * Create specific PointerEvent
     */
    create(coordinates, pointer, index, pointerType, button, ev) {
        return new this._pointerEventType(coordinates, pointer, index, pointerType, button, ev);
    }
}
class PointerDragEvent extends PointerEvent {
}
class PointerUpEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerup';
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragEnd && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragend', this);
        }
    }
}
class PointerDownEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerdown';
    }
    _onActionEnd(actor) {
        if (this.pointer.isDragStart && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragstart', this);
        }
    }
}
class PointerMoveEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointermove';
        // private _onActorEnter(actor: Actor) {
        //   const pe = createPointerEventByName('enter', this.coordinates, this.pointer, this.index, this.pointerType, this.button, this.ev);
        //   pe.propagate(actor);
        //   this.pointer.addActorUnderPointer(actor);
        //   if (this.pointer.isDragging) {
        //     this.pointer.dragTarget = actor;
        //   }
        // }
        // private _onActorLeave(actor: Actor) {
        //   const pe = createPointerEventByName('leave', this.coordinates, this.pointer, this.index, this.pointerType, this.button, this.ev);
        //   pe.propagate(actor);
        //   this.pointer.removeActorUnderPointer(actor);
        // }
    }
    propagate(actor) {
        // If the actor was under the pointer last frame, but not this one it left
        // if (this.pointer.wasActorUnderPointer(actor) && !this.pointer.isActorUnderPointer(actor)) {
        //   this._onActorLeave(actor);
        //   return;
        // }
        if (this.pointer.isActorAliveUnderPointer(actor)) {
            this.doAction(actor);
            if (this.bubbles && !this.isCanceled() && actor.parent) {
                this.propagate(actor.parent); // TODO not true
            }
        }
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
        // In the case this is new
        // if (this.pointer.checkActorUnderPointer(actor) && !this.pointer.wasActorUnderPointer(actor)) {
        //   this._onActorEnter(actor);
        // }
        if (this.pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragmove', this);
        }
    }
}
class PointerEnterEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerenter';
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragenter', this);
        }
    }
}
class PointerLeaveEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointerleave';
    }
    _onActionStart(actor) {
        if (!actor.capturePointer.captureMoveEvents) {
            return;
        }
    }
    _onActionEnd(actor) {
        const pointer = this.pointer;
        if (pointer.isDragging && actor.capturePointer.captureDragEvents) {
            actor.eventDispatcher.emit('pointerdragleave', this);
        }
    }
}
class PointerCancelEvent extends PointerEvent {
    constructor() {
        super(...arguments);
        this._name = 'pointercancel';
    }
}
/**
 * Wheel Events
 *
 * Represents a mouse wheel event. See [[Pointers]] for more information on
 * handling point input.
 */
class WheelEvent extends GameEvent {
    /**
     * @param x            The `x` coordinate of the event (in world coordinates)
     * @param y            The `y` coordinate of the event (in world coordinates)
     * @param pageX        The `x` coordinate of the event (in document coordinates)
     * @param pageY        The `y` coordinate of the event (in document coordinates)
     * @param screenX      The `x` coordinate of the event (in screen coordinates)
     * @param screenY      The `y` coordinate of the event (in screen coordinates)
     * @param index        The index of the pointer (zero-based)
     * @param deltaX       The type of pointer
     * @param deltaY       The type of pointer
     * @param deltaZ       The type of pointer
     * @param deltaMode    The type of movement [[WheelDeltaMode]]
     * @param ev           The raw DOM event being handled
     */
    constructor(x, y, pageX, pageY, screenX, screenY, index, deltaX, deltaY, deltaZ, deltaMode, ev) {
        super();
        this.x = x;
        this.y = y;
        this.pageX = pageX;
        this.pageY = pageY;
        this.screenX = screenX;
        this.screenY = screenY;
        this.index = index;
        this.deltaX = deltaX;
        this.deltaY = deltaY;
        this.deltaZ = deltaZ;
        this.deltaMode = deltaMode;
        this.ev = ev;
        this._isCanceled = false;
    }
    /**
     * Cancels pointer event propogation, event will not be transmitted to any other actors
     */
    cancel() {
        this._isCanceled = true;
    }
    /**
     *
     * @returns If the event is canceled it will no longer be transmitted to any other actors
     */
    isCanceled() {
        return this._isCanceled;
    }
}
/**
 *
 */
function createPointerEventByName(eventName, coordinates, pointer, index, pointerType, button, ev) {
    let factory;
    switch (eventName) {
        case 'up':
            factory = new PointerEventFactory(PointerUpEvent);
            break;
        case 'down':
            factory = new PointerEventFactory(PointerDownEvent);
            break;
        case 'move':
            factory = new PointerEventFactory(PointerMoveEvent);
            break;
        case 'cancel':
            factory = new PointerEventFactory(PointerCancelEvent);
            break;
        case 'enter':
            factory = new PointerEventFactory(PointerEnterEvent);
            break;
        case 'leave':
            factory = new PointerEventFactory(PointerLeaveEvent);
            break;
    }
    return factory.create(coordinates, pointer, index, pointerType, button, ev);
}

;// CONCATENATED MODULE: ./Math/global-coordinates.ts

class GlobalCoordinates {
    constructor(worldPos, pagePos, screenPos) {
        this.worldPos = worldPos;
        this.pagePos = pagePos;
        this.screenPos = screenPos;
    }
    static fromPagePosition(xOrPos, yOrEngine, engineOrUndefined) {
        let pageX;
        let pageY;
        let pagePos;
        let engine;
        if (arguments.length === 3) {
            pageX = xOrPos;
            pageY = yOrEngine;
            pagePos = new Vector(pageX, pageY);
            engine = engineOrUndefined;
        }
        else {
            pagePos = xOrPos;
            pageX = pagePos.x;
            pageY = pagePos.y;
            engine = yOrEngine;
        }
        const screenPos = engine.screen.pageToScreenCoordinates(pagePos);
        const worldPos = engine.screen.screenToWorldCoordinates(screenPos);
        return new GlobalCoordinates(worldPos, pagePos, screenPos);
    }
}

;// CONCATENATED MODULE: ./Input/Pointers.ts








/**
 * A constant used to normalize wheel events across different browsers
 *
 * This normalization factor is pulled from https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Listening_to_this_event_across_browser
 */
const ScrollWheelNormalizationFactor = -1 / 40;
/**
 * Handles pointer events (mouse, touch, stylus, etc.) and normalizes to
 * [W3C Pointer Events](http://www.w3.org/TR/pointerevents/).
 */
class Pointers extends Class {
    constructor(engine) {
        super();
        this._pointerDown = [];
        this._pointerUp = [];
        this._pointerMove = [];
        this._pointerCancel = [];
        this._wheel = [];
        this._pointers = [];
        this._activePointers = [];
        this._engine = engine;
        this._pointers.push(new Pointer());
        this._activePointers = [-1];
        this.primary = this._pointers[0];
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    /**
     * Initializes pointer event listeners
     */
    init(target) {
        target = target || this._engine.canvas;
        // Touch Events
        target.addEventListener('touchstart', this._handleTouchEvent('down', this._pointerDown));
        target.addEventListener('touchend', this._handleTouchEvent('up', this._pointerUp));
        target.addEventListener('touchmove', this._handleTouchEvent('move', this._pointerMove));
        target.addEventListener('touchcancel', this._handleTouchEvent('cancel', this._pointerCancel));
        // W3C Pointer Events
        // Current: IE11, IE10
        if (window.PointerEvent) {
            // IE11
            this._engine.canvas.style.touchAction = 'none';
            target.addEventListener('pointerdown', this._handlePointerEvent('down', this._pointerDown));
            target.addEventListener('pointerup', this._handlePointerEvent('up', this._pointerUp));
            target.addEventListener('pointermove', this._handlePointerEvent('move', this._pointerMove));
            target.addEventListener('pointercancel', this._handlePointerEvent('cancel', this._pointerCancel));
        }
        else if (window.MSPointerEvent) {
            // IE10
            this._engine.canvas.style.msTouchAction = 'none';
            target.addEventListener('MSPointerDown', this._handlePointerEvent('down', this._pointerDown));
            target.addEventListener('MSPointerUp', this._handlePointerEvent('up', this._pointerUp));
            target.addEventListener('MSPointerMove', this._handlePointerEvent('move', this._pointerMove));
            target.addEventListener('MSPointerCancel', this._handlePointerEvent('cancel', this._pointerCancel));
        }
        else {
            // Mouse Events
            target.addEventListener('mousedown', this._handleMouseEvent('down', this._pointerDown));
            target.addEventListener('mouseup', this._handleMouseEvent('up', this._pointerUp));
            target.addEventListener('mousemove', this._handleMouseEvent('move', this._pointerMove));
        }
        // MDN MouseWheelEvent
        const wheelOptions = {
            passive: !(this._engine.pageScrollPreventionMode === ScrollPreventionMode.All ||
                this._engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas)
        };
        if ('onwheel' in document.createElement('div')) {
            // Modern Browsers
            target.addEventListener('wheel', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
        else if (document.onmousewheel !== undefined) {
            // Webkit and IE
            target.addEventListener('mousewheel', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
        else {
            // Remaining browser and older Firefox
            target.addEventListener('MozMousePixelScroll', this._handleWheelEvent('wheel', this._wheel), wheelOptions);
        }
    }
    /**
     * Synthesize a pointer event that looks like a real browser event to excalibur
     * @param eventName
     * @param pos
     */
    triggerEvent(eventName, pos, button = NativePointerButton.Left, pointerType = 'mouse', pointerId = 0) {
        let x = 0;
        let y = 0;
        let coords;
        if (pos instanceof GlobalCoordinates) {
            x = pos.pagePos.x;
            y = pos.pagePos.y;
            coords = pos;
        }
        else {
            x = pos.x;
            y = pos.y;
            coords = new GlobalCoordinates(pos.clone(), pos.clone(), pos.clone());
        }
        const eventish = {
            pageX: x,
            pageY: y,
            pointerId: pointerId,
            pointerType: pointerType,
            button: button,
            preventDefault: () => {
                /* do nothing */
            }
        };
        switch (eventName) {
            case 'move':
                this._handlePointerEvent(eventName, this._pointerMove, coords)(eventish);
                break;
            case 'down':
                this._handlePointerEvent(eventName, this._pointerDown, coords)(eventish);
                break;
            case 'up':
                this._handlePointerEvent(eventName, this._pointerUp, coords)(eventish);
                break;
            case 'cancel':
                this._handlePointerEvent(eventName, this._pointerCancel, coords)(eventish);
                break;
        }
        for (const actor of this._engine.currentScene.actors) {
            const capturePointer = actor.traits.filter((t) => t instanceof CapturePointer)[0];
            if (capturePointer) {
                capturePointer.update(actor, this._engine, 1);
            }
        }
        this.dispatchPointerEvents();
        this.update();
    }
    /**
     * Update all pointer events and pointers, meant to be called at the end of frame
     */
    update() {
        this._pointerUp.length = 0;
        this._pointerDown.length = 0;
        this._pointerMove.length = 0;
        this._pointerCancel.length = 0;
        this._wheel.length = 0;
        for (let i = 0; i < this._pointers.length; i++) {
            this._pointers[i].update();
        }
    }
    /**
     * Safely gets a Pointer at a specific index and initializes one if it doesn't yet exist
     * @param index  The pointer index to retrieve
     */
    at(index) {
        if (index >= this._pointers.length) {
            // Ensure there is a pointer to retrieve
            for (let i = this._pointers.length - 1, max = index; i < max; i++) {
                this._pointers.push(new Pointer());
                this._activePointers.push(-1);
            }
        }
        return this._pointers[index];
    }
    /**
     * Get number of pointers being watched
     */
    count() {
        return this._pointers.length;
    }
    checkAndUpdateActorUnderPointer(actor) {
        for (const pointer of this._pointers) {
            if (pointer.checkActorUnderPointer(actor)) {
                pointer.addActorUnderPointer(actor);
            }
            else {
                pointer.removeActorUnderPointer(actor);
            }
        }
    }
    _dispatchWithBubble(events) {
        for (const evt of events) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                if (!evt.isCanceled()) {
                    evt.propagate(actor);
                }
                if (!evt.bubbles || evt.isCanceled()) {
                    // if the event stops bubbling part way stop processing
                    break;
                }
            }
        }
    }
    _dispatchPointerLeaveEvents() {
        const lastMoveEventPerPointerPerActor = {};
        const pointerLeave = [];
        for (const evt of this._pointerMove) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                // If the actor was under the pointer last frame, but not this this frame, pointer left
                if (!lastMoveEventPerPointerPerActor[evt.pointer.id + '+' + actor.id] &&
                    evt.pointer.wasActorUnderPointer(actor) &&
                    !evt.pointer.isActorAliveUnderPointer(actor) &&
                    !evt.isCanceled()) {
                    lastMoveEventPerPointerPerActor[evt.pointer.id + '+' + actor.id] = evt;
                    const pe = createPointerEventByName('leave', new GlobalCoordinates(evt.worldPos, evt.pagePos, evt.screenPos), evt.pointer, evt.index, evt.pointerType, evt.button, evt.ev);
                    pe.propagate(actor);
                    pointerLeave.push(pe);
                }
            }
        }
        return pointerLeave;
    }
    _dispatchPointerEnterEvents() {
        const lastMoveEventPerPointer = {};
        const pointerEnter = [];
        for (const evt of this._pointerMove) {
            for (const actor of evt.pointer.getActorsForEvents()) {
                // If the actor was not under the pointer last frame, but it is this frame, pointer entered
                if (!lastMoveEventPerPointer[evt.pointer.id] &&
                    !evt.pointer.wasActorUnderPointer(actor) &&
                    evt.pointer.isActorAliveUnderPointer(actor) &&
                    !evt.isCanceled()) {
                    lastMoveEventPerPointer[evt.pointer.id] = evt;
                    const pe = createPointerEventByName('enter', new GlobalCoordinates(evt.worldPos, evt.pagePos, evt.screenPos), evt.pointer, evt.index, evt.pointerType, evt.button, evt.ev);
                    pe.propagate(actor);
                    pointerEnter.push(pe);
                    // if pointer is dragging set the drag target
                    if (evt.pointer.isDragging) {
                        evt.pointer.dragTarget = actor;
                    }
                }
            }
        }
        return pointerEnter;
    }
    dispatchPointerEvents() {
        this._dispatchWithBubble(this._pointerDown);
        this._dispatchWithBubble(this._pointerUp);
        this._dispatchWithBubble(this._pointerMove);
        this._dispatchPointerLeaveEvents();
        this._dispatchPointerEnterEvents();
        this._dispatchWithBubble(this._pointerCancel);
        // TODO some duplication here
        for (const evt of this._wheel) {
            for (const actor of this._pointers[evt.index].getActorsUnderPointer()) {
                this._propagateWheelPointerEvent(actor, evt);
                if (!evt.bubbles || evt.isCanceled()) {
                    // if the event stops bubbling part way stop processing
                    break;
                }
            }
        }
    }
    _propagateWheelPointerEvent(actor, wheelEvent) {
        actor.emit('pointerwheel', wheelEvent);
        // Recurse and propagate
        if (wheelEvent.bubbles && !wheelEvent.isCanceled() && actor.parent) {
            this._propagateWheelPointerEvent(actor.parent, wheelEvent); // TODO not true
        }
    }
    _handleMouseEvent(eventName, eventArr) {
        return (e) => {
            e.preventDefault();
            const pointer = this.at(0);
            const coordinates = GlobalCoordinates.fromPagePosition(e.pageX, e.pageY, this._engine);
            const pe = createPointerEventByName(eventName, coordinates, pointer, 0, PointerType.Mouse, this._nativeButtonToPointerButton(e.button), e);
            eventArr.push(pe);
            pointer.eventDispatcher.emit(eventName, pe);
        };
    }
    _handleTouchEvent(eventName, eventArr) {
        return (e) => {
            e.preventDefault();
            for (let i = 0, len = e.changedTouches.length; i < len; i++) {
                const index = this._pointers.length > 1 ? this._getPointerIndex(e.changedTouches[i].identifier) : 0;
                if (index === -1) {
                    continue;
                }
                const pointer = this.at(index);
                const coordinates = GlobalCoordinates.fromPagePosition(e.changedTouches[i].pageX, e.changedTouches[i].pageY, this._engine);
                const pe = createPointerEventByName(eventName, coordinates, pointer, index, PointerType.Touch, PointerButton.Unknown, e);
                eventArr.push(pe);
                pointer.eventDispatcher.emit(eventName, pe);
                this.emit(eventName, pe);
                // only with multi-pointer
                if (this._pointers.length > 1) {
                    if (eventName === 'up') {
                        // remove pointer ID from pool when pointer is lifted
                        this._activePointers[index] = -1;
                    }
                    else if (eventName === 'down') {
                        // set pointer ID to given index
                        this._activePointers[index] = e.changedTouches[i].identifier;
                    }
                }
            }
        };
    }
    _handlePointerEvent(eventName, eventArr, coords) {
        return (e) => {
            e.preventDefault();
            // get the index for this pointer ID if multi-pointer is asked for
            const index = this._pointers.length > 1 ? this._getPointerIndex(e.pointerId) : 0;
            if (index === -1) {
                return;
            }
            const pointer = this.at(index);
            const coordinates = coords || GlobalCoordinates.fromPagePosition(e.pageX, e.pageY, this._engine);
            const pe = createPointerEventByName(eventName, coordinates, pointer, index, this._stringToPointerType(e.pointerType), this._nativeButtonToPointerButton(e.button), e);
            eventArr.push(pe);
            pointer.eventDispatcher.emit(eventName, pe);
            this.emit(eventName, pe);
            // only with multi-pointer
            if (this._pointers.length > 1) {
                if (eventName === 'up') {
                    // remove pointer ID from pool when pointer is lifted
                    this._activePointers[index] = -1;
                }
                else if (eventName === 'down') {
                    // set pointer ID to given index
                    this._activePointers[index] = e.pointerId;
                }
            }
        };
    }
    _handleWheelEvent(eventName, eventArr) {
        return (e) => {
            // Should we prevent page scroll because of this event
            if (this._engine.pageScrollPreventionMode === ScrollPreventionMode.All ||
                (this._engine.pageScrollPreventionMode === ScrollPreventionMode.Canvas && e.target === this._engine.canvas)) {
                e.preventDefault();
            }
            const screen = this._engine.screen.pageToScreenCoordinates(vec(e.pageX, e.pageY));
            const world = this._engine.screen.screenToWorldCoordinates(screen);
            // deltaX, deltaY, and deltaZ are the standard modern properties
            // wheelDeltaX, wheelDeltaY, are legacy properties in webkit browsers and older IE
            // e.detail is only used in opera
            const deltaX = e.deltaX || e.wheelDeltaX * ScrollWheelNormalizationFactor || 0;
            const deltaY = e.deltaY || e.wheelDeltaY * ScrollWheelNormalizationFactor || e.wheelDelta * ScrollWheelNormalizationFactor || e.detail || 0;
            const deltaZ = e.deltaZ || 0;
            let deltaMode = WheelDeltaMode.Pixel;
            if (e.deltaMode) {
                if (e.deltaMode === 1) {
                    deltaMode = WheelDeltaMode.Line;
                }
                else if (e.deltaMode === 2) {
                    deltaMode = WheelDeltaMode.Page;
                }
            }
            const we = new WheelEvent(world.x, world.y, e.pageX, e.pageY, screen.x, screen.y, 0, deltaX, deltaY, deltaZ, deltaMode, e);
            eventArr.push(we);
            this.at(0).eventDispatcher.emit(eventName, we);
            this.emit(eventName, we);
        };
    }
    /**
     * Gets the index of the pointer specified for the given pointer ID or finds the next empty pointer slot available.
     * This is required because IE10/11 uses incrementing pointer IDs so we need to store a mapping of ID => idx
     */
    _getPointerIndex(pointerId) {
        let idx;
        if ((idx = this._activePointers.indexOf(pointerId)) > -1) {
            return idx;
        }
        for (let i = 0; i < this._activePointers.length; i++) {
            if (this._activePointers[i] === -1) {
                return i;
            }
        }
        // ignore pointer because game isn't watching
        return -1;
    }
    _nativeButtonToPointerButton(s) {
        switch (s) {
            case NativePointerButton.NoButton:
                return PointerButton.NoButton;
            case NativePointerButton.Left:
                return PointerButton.Left;
            case NativePointerButton.Middle:
                return PointerButton.Middle;
            case NativePointerButton.Right:
                return PointerButton.Right;
            case NativePointerButton.Unknown:
                return PointerButton.Unknown;
            default:
                return fail(s);
        }
    }
    _stringToPointerType(s) {
        switch (s) {
            case 'touch':
                return PointerType.Touch;
            case 'mouse':
                return PointerType.Mouse;
            case 'pen':
                return PointerType.Pen;
            default:
                return PointerType.Unknown;
        }
    }
}

;// CONCATENATED MODULE: ./Input/Gamepad.ts


/**
 * Excalibur leverages the HTML5 Gamepad API [where it is supported](http://caniuse.com/#feat=gamepad)
 * to provide controller support for your games.
 */
class Gamepads extends Class {
    constructor() {
        super();
        /**
         * Whether or not to poll for Gamepad input (default: `false`)
         */
        this.enabled = false;
        /**
         * Whether or not Gamepad API is supported
         */
        this.supported = !!navigator.getGamepads;
        this._gamePadTimeStamps = [0, 0, 0, 0];
        this._oldPads = [];
        this._pads = [];
        this._initSuccess = false;
        this._navigator = navigator;
        this._minimumConfiguration = null;
    }
    init() {
        if (!this.supported) {
            return;
        }
        if (this._initSuccess) {
            return;
        }
        // In Chrome, this will return 4 undefined items until a button is pressed
        // In FF, this will not return any items until a button is pressed
        this._oldPads = this._clonePads(this._navigator.getGamepads());
        if (this._oldPads.length && this._oldPads[0]) {
            this._initSuccess = true;
        }
    }
    /**
     * Sets the minimum gamepad configuration, for example {axis: 4, buttons: 4} means
     * this game requires at minimum 4 axis inputs and 4 buttons, this is not restrictive
     * all other controllers with more axis or buttons are valid as well. If no minimum
     * configuration is set all pads are valid.
     */
    setMinimumGamepadConfiguration(config) {
        this._enableAndUpdate(); // if config is used, implicitly enable
        this._minimumConfiguration = config;
    }
    /**
     * When implicitly enabled, set the enabled flag and run an update so information is updated
     */
    _enableAndUpdate() {
        if (!this.enabled) {
            this.enabled = true;
            this.update();
        }
    }
    /**
     * Checks a navigator gamepad against the minimum configuration if present.
     */
    _isGamepadValid(pad) {
        if (!this._minimumConfiguration) {
            return true;
        }
        if (!pad) {
            return false;
        }
        const axesLength = pad.axes.filter((value) => {
            return typeof value !== undefined;
        }).length;
        const buttonLength = pad.buttons.filter((value) => {
            return typeof value !== undefined;
        }).length;
        return axesLength >= this._minimumConfiguration.axis && buttonLength >= this._minimumConfiguration.buttons && pad.connected;
    }
    on(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.on(eventName, handler);
    }
    off(eventName, handler) {
        this._enableAndUpdate(); // implicitly enable
        super.off(eventName, handler);
    }
    /**
     * Updates Gamepad state and publishes Gamepad events
     */
    update() {
        if (!this.enabled || !this.supported) {
            return;
        }
        this.init();
        const gamepads = this._navigator.getGamepads();
        for (let i = 0; i < gamepads.length; i++) {
            if (!gamepads[i]) {
                const gamepad = this.at(i);
                // If was connected, but now isn't emit the disconnect event
                if (gamepad.connected) {
                    this.eventDispatcher.emit('disconnect', new GamepadDisconnectEvent(i, gamepad));
                }
                // Reset connection status
                gamepad.connected = false;
                continue;
            }
            else {
                if (!this.at(i).connected && this._isGamepadValid(gamepads[i])) {
                    this.eventDispatcher.emit('connect', new GamepadConnectEvent(i, this.at(i)));
                }
                // Set connection status
                this.at(i).connected = true;
            }
            // Only supported in Chrome
            if (gamepads[i].timestamp && gamepads[i].timestamp === this._gamePadTimeStamps[i]) {
                continue;
            }
            this._gamePadTimeStamps[i] = gamepads[i].timestamp;
            // Add reference to navigator gamepad
            this.at(i).navigatorGamepad = gamepads[i];
            // Buttons
            let b, bi, a, ai, value;
            for (b in Buttons) {
                bi = Buttons[b];
                if (typeof bi === 'number') {
                    if (gamepads[i].buttons[bi]) {
                        value = gamepads[i].buttons[bi].value;
                        if (value !== this._oldPads[i].getButton(bi)) {
                            if (gamepads[i].buttons[bi].pressed) {
                                this.at(i).updateButton(bi, value);
                                this.at(i).eventDispatcher.emit('button', new GamepadButtonEvent(bi, value, this.at(i)));
                            }
                            else {
                                this.at(i).updateButton(bi, 0);
                            }
                        }
                    }
                }
            }
            // Axes
            for (a in Axes) {
                ai = Axes[a];
                if (typeof ai === 'number') {
                    value = gamepads[i].axes[ai];
                    if (value !== this._oldPads[i].getAxes(ai)) {
                        this.at(i).updateAxes(ai, value);
                        this.at(i).eventDispatcher.emit('axis', new GamepadAxisEvent(ai, value, this.at(i)));
                    }
                }
            }
            this._oldPads[i] = this._clonePad(gamepads[i]);
        }
    }
    /**
     * Safely retrieves a Gamepad at a specific index and creates one if it doesn't yet exist
     */
    at(index) {
        this._enableAndUpdate(); // implicitly enable gamepads when at() is called
        if (index >= this._pads.length) {
            // Ensure there is a pad to retrieve
            for (let i = this._pads.length - 1, max = index; i < max; i++) {
                this._pads.push(new Gamepad());
                this._oldPads.push(new Gamepad());
            }
        }
        return this._pads[index];
    }
    /**
     * Returns a list of all valid gamepads that meet the minimum configuration requirement.
     */
    getValidGamepads() {
        this._enableAndUpdate();
        const result = [];
        for (let i = 0; i < this._pads.length; i++) {
            if (this._isGamepadValid(this.at(i).navigatorGamepad) && this.at(i).connected) {
                result.push(this.at(i));
            }
        }
        return result;
    }
    /**
     * Gets the number of connected gamepads
     */
    count() {
        return this._pads.filter((p) => p.connected).length;
    }
    _clonePads(pads) {
        const arr = [];
        for (let i = 0, len = pads.length; i < len; i++) {
            arr.push(this._clonePad(pads[i]));
        }
        return arr;
    }
    /**
     * Fastest way to clone a known object is to do it yourself
     */
    _clonePad(pad) {
        let i, len;
        const clonedPad = new Gamepad();
        if (!pad) {
            return clonedPad;
        }
        for (i = 0, len = pad.buttons.length; i < len; i++) {
            if (pad.buttons[i]) {
                clonedPad.updateButton(i, pad.buttons[i].value);
            }
        }
        for (i = 0, len = pad.axes.length; i < len; i++) {
            clonedPad.updateAxes(i, pad.axes[i]);
        }
        return clonedPad;
    }
}
/**
 * The minimum value an axis has to move before considering it a change
 */
Gamepads.MinAxisMoveThreshold = 0.05;
/**
 * Gamepad holds state information for a connected controller. See [[Gamepads]]
 * for more information on handling controller input.
 */
class Gamepad extends Class {
    constructor() {
        super();
        this.connected = false;
        this._buttons = new Array(16);
        this._axes = new Array(4);
        for (let i = 0; i < this._buttons.length; i++) {
            this._buttons[i] = 0;
        }
        for (let i = 0; i < this._axes.length; i++) {
            this._axes[i] = 0;
        }
    }
    /**
     * Whether or not the given button is pressed
     * @param button     The button to query
     * @param threshold  The threshold over which the button is considered to be pressed
     */
    isButtonPressed(button, threshold = 1) {
        return this._buttons[button] >= threshold;
    }
    /**
     * Gets the given button value between 0 and 1
     */
    getButton(button) {
        return this._buttons[button];
    }
    /**
     * Gets the given axis value between -1 and 1. Values below
     * [[MinAxisMoveThreshold]] are considered 0.
     */
    getAxes(axes) {
        const value = this._axes[axes];
        if (Math.abs(value) < Gamepads.MinAxisMoveThreshold) {
            return 0;
        }
        else {
            return value;
        }
    }
    updateButton(buttonIndex, value) {
        this._buttons[buttonIndex] = value;
    }
    updateAxes(axesIndex, value) {
        this._axes[axesIndex] = value;
    }
}
/**
 * Gamepad Buttons enumeration
 */
var Buttons;
(function (Buttons) {
    /**
     * Face 1 button (e.g. A)
     */
    Buttons[Buttons["Face1"] = 0] = "Face1";
    /**
     * Face 2 button (e.g. B)
     */
    Buttons[Buttons["Face2"] = 1] = "Face2";
    /**
     * Face 3 button (e.g. X)
     */
    Buttons[Buttons["Face3"] = 2] = "Face3";
    /**
     * Face 4 button (e.g. Y)
     */
    Buttons[Buttons["Face4"] = 3] = "Face4";
    /**
     * Left bumper button
     */
    Buttons[Buttons["LeftBumper"] = 4] = "LeftBumper";
    /**
     * Right bumper button
     */
    Buttons[Buttons["RightBumper"] = 5] = "RightBumper";
    /**
     * Left trigger button
     */
    Buttons[Buttons["LeftTrigger"] = 6] = "LeftTrigger";
    /**
     * Right trigger button
     */
    Buttons[Buttons["RightTrigger"] = 7] = "RightTrigger";
    /**
     * Select button
     */
    Buttons[Buttons["Select"] = 8] = "Select";
    /**
     * Start button
     */
    Buttons[Buttons["Start"] = 9] = "Start";
    /**
     * Left analog stick press (e.g. L3)
     */
    Buttons[Buttons["LeftStick"] = 10] = "LeftStick";
    /**
     * Right analog stick press (e.g. R3)
     */
    Buttons[Buttons["RightStick"] = 11] = "RightStick";
    /**
     * D-pad up
     */
    Buttons[Buttons["DpadUp"] = 12] = "DpadUp";
    /**
     * D-pad down
     */
    Buttons[Buttons["DpadDown"] = 13] = "DpadDown";
    /**
     * D-pad left
     */
    Buttons[Buttons["DpadLeft"] = 14] = "DpadLeft";
    /**
     * D-pad right
     */
    Buttons[Buttons["DpadRight"] = 15] = "DpadRight";
})(Buttons || (Buttons = {}));
/**
 * Gamepad Axes enumeration
 */
var Axes;
(function (Axes) {
    /**
     * Left analogue stick X direction
     */
    Axes[Axes["LeftStickX"] = 0] = "LeftStickX";
    /**
     * Left analogue stick Y direction
     */
    Axes[Axes["LeftStickY"] = 1] = "LeftStickY";
    /**
     * Right analogue stick X direction
     */
    Axes[Axes["RightStickX"] = 2] = "RightStickX";
    /**
     * Right analogue stick Y direction
     */
    Axes[Axes["RightStickY"] = 3] = "RightStickY";
})(Axes || (Axes = {}));

;// CONCATENATED MODULE: ./Util/Browser.ts
class BrowserComponent {
    constructor(nativeComponent) {
        this.nativeComponent = nativeComponent;
        this._paused = false;
        this._nativeHandlers = {};
    }
    on(eventName, handler) {
        if (this._nativeHandlers[eventName]) {
            this.off(eventName, this._nativeHandlers[eventName]);
        }
        this._nativeHandlers[eventName] = this._decorate(handler);
        this.nativeComponent.addEventListener(eventName, this._nativeHandlers[eventName]);
    }
    off(eventName, handler) {
        if (!handler) {
            handler = this._nativeHandlers[eventName];
        }
        this.nativeComponent.removeEventListener(eventName, handler);
        this._nativeHandlers[eventName] = null;
    }
    _decorate(handler) {
        return (evt) => {
            if (!this._paused) {
                handler(evt);
            }
        };
    }
    pause() {
        this._paused = true;
    }
    resume() {
        this._paused = false;
    }
    clear() {
        for (const event in this._nativeHandlers) {
            this.off(event);
        }
    }
}
class BrowserEvents {
    constructor(_windowGlobal, _documentGlobal) {
        this._windowGlobal = _windowGlobal;
        this._documentGlobal = _documentGlobal;
        this._windowComponent = new BrowserComponent(this._windowGlobal);
        this._documentComponent = new BrowserComponent(this._documentGlobal);
    }
    get window() {
        return this._windowComponent;
    }
    get document() {
        return this._documentComponent;
    }
    pause() {
        this.window.pause();
        this.document.pause();
    }
    resume() {
        this.window.resume();
        this.document.resume();
    }
    clear() {
        this.window.clear();
        this.document.clear();
    }
}

;// CONCATENATED MODULE: ./Graphics/Context/ExcaliburGraphicsContext2DCanvas.ts




class ExcaliburGraphicsContext2DCanvasDebug {
    constructor(_ex) {
        this._ex = _ex;
        this._debugText = new DebugText();
    }
    /**
     * Draw a debug rectangle to the context
     * @param x
     * @param y
     * @param width
     * @param height
     */
    drawRect(x, y, width, height) {
        this._ex.__ctx.save();
        this._ex.__ctx.strokeStyle = 'red';
        this._ex.__ctx.strokeRect(this._ex.snapToPixel ? ~~x : x, this._ex.snapToPixel ? ~~y : y, this._ex.snapToPixel ? ~~width : width, this._ex.snapToPixel ? ~~height : height);
        this._ex.__ctx.restore();
    }
    drawLine(start, end, lineOptions = { color: Color.Black }) {
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.strokeStyle = lineOptions.color.toString();
        this._ex.__ctx.moveTo(this._ex.snapToPixel ? ~~start.x : start.x, this._ex.snapToPixel ? ~~start.y : start.y);
        this._ex.__ctx.lineTo(this._ex.snapToPixel ? ~~end.x : end.x, this._ex.snapToPixel ? ~~end.y : end.y);
        this._ex.__ctx.lineWidth = 2;
        this._ex.__ctx.stroke();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawPoint(point, pointOptions = { color: Color.Black, size: 5 }) {
        this._ex.__ctx.save();
        this._ex.__ctx.beginPath();
        this._ex.__ctx.fillStyle = pointOptions.color.toString();
        this._ex.__ctx.arc(this._ex.snapToPixel ? ~~point.x : point.x, this._ex.snapToPixel ? ~~point.y : point.y, pointOptions.size, 0, Math.PI * 2);
        this._ex.__ctx.fill();
        this._ex.__ctx.closePath();
        this._ex.__ctx.restore();
    }
    drawText(text, pos) {
        this._debugText.write(this._ex, text, pos);
    }
}
class ExcaliburGraphicsContext2DCanvas {
    constructor(options) {
        this.backgroundColor = Color.ExcaliburBlue;
        this._state = new StateStack();
        this.snapToPixel = true;
        this.debug = new ExcaliburGraphicsContext2DCanvasDebug(this);
        const { canvasElement, enableTransparency, snapToPixel, smoothing, backgroundColor } = options;
        this.__ctx = canvasElement.getContext('2d', {
            alpha: enableTransparency !== null && enableTransparency !== void 0 ? enableTransparency : true
        });
        this.backgroundColor = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : this.backgroundColor;
        this.snapToPixel = snapToPixel !== null && snapToPixel !== void 0 ? snapToPixel : this.snapToPixel;
        this.smoothing = smoothing !== null && smoothing !== void 0 ? smoothing : this.smoothing;
    }
    get width() {
        return this.__ctx.canvas.width;
    }
    get height() {
        return this.__ctx.canvas.height;
    }
    get opacity() {
        return this._state.current.opacity;
    }
    set opacity(value) {
        this._state.current.opacity = value;
    }
    get smoothing() {
        return this.__ctx.imageSmoothingEnabled;
    }
    set smoothing(value) {
        this.__ctx.imageSmoothingEnabled = value;
    }
    resetTransform() {
        this.__ctx.resetTransform();
    }
    updateViewport() {
        // pass
    }
    drawImage(image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight) {
        if (swidth === 0 || sheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (dwidth === 0 || dheight === 0) {
            return; // zero dimension dest exit early
        }
        else if (image.width === 0 || image.height === 0) {
            return; // zero dimension source exit early
        }
        this.__ctx.globalAlpha = this.opacity;
        const args = [image, sx, sy, swidth, sheight, dx, dy, dwidth, dheight]
            .filter((a) => a !== undefined)
            .map((a) => (typeof a === 'number' && this.snapToPixel ? ~~a : a));
        this.__ctx.drawImage.apply(this.__ctx, args);
        GraphicsDiagnostics.DrawCallCount++;
        GraphicsDiagnostics.DrawnImagesCount = 1;
    }
    drawLine(start, end, color, thickness = 1) {
        this.__ctx.save();
        this.__ctx.beginPath();
        this.__ctx.strokeStyle = color.toString();
        this.__ctx.moveTo(this.snapToPixel ? ~~start.x : start.x, this.snapToPixel ? ~~start.y : start.y);
        this.__ctx.lineTo(this.snapToPixel ? ~~end.x : end.x, this.snapToPixel ? ~~end.y : end.y);
        this.__ctx.lineWidth = thickness;
        this.__ctx.stroke();
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    drawRectangle(pos, width, height, color) {
        this.__ctx.save();
        this.__ctx.fillStyle = color.toString();
        this.__ctx.fillRect(this.snapToPixel ? ~~pos.x : pos.x, this.snapToPixel ? ~~pos.y : pos.y, this.snapToPixel ? ~~width : width, this.snapToPixel ? ~~height : height);
        this.__ctx.restore();
    }
    drawCircle(pos, radius, color) {
        this.__ctx.save();
        this.__ctx.beginPath();
        this.__ctx.fillStyle = color.toString();
        this.__ctx.arc(this.snapToPixel ? ~~pos.x : pos.x, this.snapToPixel ? ~~pos.y : pos.y, radius, 0, Math.PI * 2);
        this.__ctx.fill();
        this.__ctx.closePath();
        this.__ctx.restore();
    }
    /**
     * Save the current state of the canvas to the stack (transforms and opacity)
     */
    save() {
        this.__ctx.save();
    }
    /**
     * Restore the state of the canvas from the stack
     */
    restore() {
        this.__ctx.restore();
    }
    /**
     * Translate the origin of the context by an x and y
     * @param x
     * @param y
     */
    translate(x, y) {
        this.__ctx.translate(this.snapToPixel ? ~~x : x, this.snapToPixel ? ~~y : y);
    }
    /**
     * Rotate the context about the current origin
     */
    rotate(angle) {
        this.__ctx.rotate(angle);
    }
    /**
     * Scale the context by an x and y factor
     * @param x
     * @param y
     */
    scale(x, y) {
        this.__ctx.scale(x, y);
    }
    clear() {
        // Clear frame
        this.__ctx.clearRect(0, 0, this.width, this.height);
        this.__ctx.fillStyle = this.backgroundColor.toString();
        this.__ctx.fillRect(0, 0, this.width, this.height);
        GraphicsDiagnostics.clear();
    }
    /**
     * Flushes the batched draw calls to the screen
     */
    flush() {
        // pass
    }
}

;// CONCATENATED MODULE: ./Engine.ts
var Engine_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};



polyfill();














/**
 * Enum representing the different mousewheel event bubble prevention
 */
var ScrollPreventionMode;
(function (ScrollPreventionMode) {
    /**
     * Do not prevent any page scrolling
     */
    ScrollPreventionMode[ScrollPreventionMode["None"] = 0] = "None";
    /**
     * Prevent page scroll if mouse is over the game canvas
     */
    ScrollPreventionMode[ScrollPreventionMode["Canvas"] = 1] = "Canvas";
    /**
     * Prevent all page scrolling via mouse wheel
     */
    ScrollPreventionMode[ScrollPreventionMode["All"] = 2] = "All";
})(ScrollPreventionMode || (ScrollPreventionMode = {}));
/**
 * The Excalibur Engine
 *
 * The [[Engine]] is the main driver for a game. It is responsible for
 * starting/stopping the game, maintaining state, transmitting events,
 * loading resources, and managing the scene.
 */
class Engine extends Class {
    /**
     * Creates a new game using the given [[EngineOptions]]. By default, if no options are provided,
     * the game will be rendered full screen (taking up all available browser window space).
     * You can customize the game rendering through [[EngineOptions]].
     *
     * Example:
     *
     * ```js
     * var game = new ex.Engine({
     *   width: 0, // the width of the canvas
     *   height: 0, // the height of the canvas
     *   enableCanvasTransparency: true, // the transparencySection of the canvas
     *   canvasElementId: '', // the DOM canvas element ID, if you are providing your own
     *   displayMode: ex.DisplayMode.FullScreen, // the display mode
     *   pointerScope: ex.Input.PointerScope.Document, // the scope of capturing pointer (mouse/touch) events
     *   backgroundColor: ex.Color.fromHex('#2185d0') // background color of the engine
     * });
     *
     * // call game.start, which is a Promise
     * game.start().then(function () {
     *   // ready, set, go!
     * });
     * ```
     */
    constructor(options) {
        var _a, _b, _c;
        super();
        this._hasStarted = false;
        /**
         * Gets or sets the list of post processors to apply at the end of drawing a frame (such as [[ColorBlindCorrector]])
         */
        this.postProcessors = [];
        /**
         * Contains all the scenes currently registered with Excalibur
         */
        this.scenes = {};
        /**
         * @hidden
         * @deprecated
         */
        this._animations = [];
        this._suppressPlayButton = false;
        /**
         * Indicates whether audio should be paused when the game is no longer visible.
         */
        this.pauseAudioWhenHidden = true;
        /**
         * Indicates whether the engine should draw with debug information
         */
        this._isDebug = false;
        this.debugColor = new Color(255, 255, 255);
        /**
         * Sets the Transparency for the engine.
         */
        this.enableCanvasTransparency = true;
        /**
         * The action to take when a fatal exception is thrown
         */
        this.onFatalException = (e) => {
            Logger.getInstance().fatal(e);
        };
        this._timescale = 1.0;
        this._isLoading = false;
        this._isInitialized = false;
        this._deferredGoTo = null;
        this._loadingComplete = false;
        options = Object.assign(Object.assign({}, Engine._DEFAULT_ENGINE_OPTIONS), options);
        Flags.freeze();
        // Initialize browser events facade
        this.browser = new BrowserEvents(window, document);
        // Check compatibility
        const detector = new Detector();
        if (!options.suppressMinimumBrowserFeatureDetection && !(this._compatible = detector.test())) {
            const message = document.createElement('div');
            message.innerText = 'Sorry, your browser does not support all the features needed for Excalibur';
            document.body.appendChild(message);
            detector.failedTests.forEach(function (test) {
                const testMessage = document.createElement('div');
                testMessage.innerText = 'Browser feature missing ' + test;
                document.body.appendChild(testMessage);
            });
            if (options.canvasElementId) {
                const canvas = document.getElementById(options.canvasElementId);
                if (canvas) {
                    canvas.parentElement.removeChild(canvas);
                }
            }
            return;
        }
        else {
            this._compatible = true;
        }
        // Use native console API for color fun
        // eslint-disable-next-line no-console
        if (console.log && !options.suppressConsoleBootMessage) {
            // eslint-disable-next-line no-console
            console.log(`%cPowered by Excalibur.js (v${EX_VERSION})`, 'background: #176BAA; color: white; border-radius: 5px; padding: 15px; font-size: 1.5em; line-height: 80px;');
            // eslint-disable-next-line no-console
            console.log('\n\
      /| ________________\n\
O|===|* >________________>\n\
      \\|');
            // eslint-disable-next-line no-console
            console.log('Visit', 'http://excaliburjs.com', 'for more information');
        }
        // Suppress play button
        if (options.suppressPlayButton) {
            this._suppressPlayButton = true;
        }
        this._logger = Logger.getInstance();
        // If debug is enabled, let's log browser features to the console.
        if (this._logger.defaultLevel === LogLevel.Debug) {
            detector.logBrowserFeatures();
        }
        this._logger.debug('Building engine...');
        this.canvasElementId = options.canvasElementId;
        if (options.canvasElementId) {
            this._logger.debug('Using Canvas element specified: ' + options.canvasElementId);
            this.canvas = document.getElementById(options.canvasElementId);
        }
        else if (options.canvasElement) {
            this._logger.debug('Using Canvas element specified:', options.canvasElement);
            this.canvas = options.canvasElement;
        }
        else {
            this._logger.debug('Using generated canvas element');
            this.canvas = document.createElement('canvas');
        }
        let displayMode = (_a = options.displayMode) !== null && _a !== void 0 ? _a : DisplayMode.Fixed;
        if ((options.width && options.height) || options.viewport) {
            if (options.displayMode === undefined) {
                displayMode = DisplayMode.Fixed;
            }
            this._logger.debug('Engine viewport is size ' + options.width + ' x ' + options.height);
        }
        else if (!options.displayMode) {
            this._logger.debug('Engine viewport is fit');
            displayMode = DisplayMode.FitScreen;
        }
        if (Flags.isEnabled(Legacy.Canvas)) {
            const ex2dCtx = new ExcaliburGraphicsContext2DCanvas({
                canvasElement: this.canvas,
                enableTransparency: this.enableCanvasTransparency,
                smoothing: options.antialiasing,
                backgroundColor: options.backgroundColor,
                snapToPixel: options.snapToPixel
            });
            this.graphicsContext = ex2dCtx;
            this.ctx = ex2dCtx.__ctx;
        }
        else {
            const exWebglCtx = new ExcaliburGraphicsContextWebGL({
                canvasElement: this.canvas,
                enableTransparency: this.enableCanvasTransparency,
                smoothing: options.antialiasing,
                backgroundColor: options.backgroundColor,
                snapToPixel: options.snapToPixel
            });
            this.graphicsContext = exWebglCtx;
            this.ctx = exWebglCtx.__ctx;
        }
        this.screen = new Screen({
            canvas: this.canvas,
            context: this.graphicsContext,
            antialiasing: (_b = options.antialiasing) !== null && _b !== void 0 ? _b : true,
            browser: this.browser,
            viewport: (_c = options.viewport) !== null && _c !== void 0 ? _c : (options.width && options.height ? { width: options.width, height: options.height } : Resolution.SVGA),
            resolution: options.resolution,
            displayMode,
            position: options.position,
            pixelRatio: options.suppressHiDPIScaling ? 1 : null
        });
        if (options.backgroundColor) {
            this.backgroundColor = options.backgroundColor.clone();
        }
        this.enableCanvasTransparency = options.enableCanvasTransparency;
        this._loader = new Loader();
        this.debug = new Debug(this);
        this._initialize(options);
        this.rootScene = this.currentScene = new Scene();
        this.addScene('root', this.rootScene);
    }
    /**
     * The width of the game canvas in pixels (physical width component of the
     * resolution of the canvas element)
     */
    get canvasWidth() {
        return this.screen.canvasWidth;
    }
    /**
     * Returns half width of the game canvas in pixels (half physical width component)
     */
    get halfCanvasWidth() {
        return this.screen.halfCanvasWidth;
    }
    /**
     * The height of the game canvas in pixels, (physical height component of
     * the resolution of the canvas element)
     */
    get canvasHeight() {
        return this.screen.canvasHeight;
    }
    /**
     * Returns half height of the game canvas in pixels (half physical height component)
     */
    get halfCanvasHeight() {
        return this.screen.halfCanvasHeight;
    }
    /**
     * Returns the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawWidth() {
        return this.screen.drawWidth;
    }
    /**
     * Returns half the width of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawWidth() {
        return this.screen.halfDrawWidth;
    }
    /**
     * Returns the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get drawHeight() {
        return this.screen.drawHeight;
    }
    /**
     * Returns half the height of the engine's visible drawing surface in pixels including zoom and device pixel ratio.
     */
    get halfDrawHeight() {
        return this.screen.halfDrawHeight;
    }
    /**
     * Returns whether excalibur detects the current screen to be HiDPI
     */
    get isHiDpi() {
        return this.screen.isHiDpi;
    }
    /**
     * Access [[stats]] that holds frame statistics.
     */
    get stats() {
        return this.debug.stats;
    }
    /**
     * Indicates whether the engine is set to fullscreen or not
     */
    get isFullscreen() {
        return this.screen.isFullScreen;
    }
    /**
     * Indicates the current [[DisplayMode]] of the engine.
     */
    get displayMode() {
        return this.screen.displayMode;
    }
    /**
     * Returns the calculated pixel ration for use in rendering
     */
    get pixelRatio() {
        return this.screen.pixelRatio;
    }
    get isDebug() {
        return this._isDebug;
    }
    on(eventName, handler) {
        super.on(eventName, handler);
    }
    once(eventName, handler) {
        super.once(eventName, handler);
    }
    off(eventName, handler) {
        super.off(eventName, handler);
    }
    /**
     * Returns a BoundingBox of the top left corner of the screen
     * and the bottom right corner of the screen.
     */
    getWorldBounds() {
        return this.screen.getWorldBounds();
    }
    /**
     * Gets the current engine timescale factor (default is 1.0 which is 1:1 time)
     */
    get timescale() {
        return this._timescale;
    }
    /**
     * Sets the current engine timescale factor. Useful for creating slow-motion effects or fast-forward effects
     * when using time-based movement.
     */
    set timescale(value) {
        if (value <= 0) {
            Logger.getInstance().error('Cannot set engine.timescale to a value of 0 or less than 0.');
            return;
        }
        this._timescale = value;
    }
    /**
     * Plays a sprite animation on the screen at the specified `x` and `y`
     * (in game coordinates, not screen pixels). These animations play
     * independent of actors, and will be cleaned up internally as soon
     * as they are complete. Note animations that loop will never be
     * cleaned up.
     *
     * @param animation  Animation to play
     * @param x          x game coordinate to play the animation
     * @param y          y game coordinate to play the animation
     * @deprecated
     */
    playAnimation(animation, x, y) {
        this._animations.push(new AnimationNode(animation, x, y));
    }
    /**
     * Adds a [[TileMap]] to the [[currentScene]], once this is done the TileMap
     * will be drawn and updated.
     */
    addTileMap(tileMap) {
        this.currentScene.addTileMap(tileMap);
    }
    /**
     * Removes a [[TileMap]] from the [[currentScene]], it will no longer be drawn or updated.
     */
    removeTileMap(tileMap) {
        this.currentScene.removeTileMap(tileMap);
    }
    /**
     * Adds a [[Timer]] to the [[currentScene]].
     * @param timer  The timer to add to the [[currentScene]].
     */
    addTimer(timer) {
        return this.currentScene.addTimer(timer);
    }
    /**
     * Removes a [[Timer]] from the [[currentScene]].
     * @param timer  The timer to remove to the [[currentScene]].
     */
    removeTimer(timer) {
        return this.currentScene.removeTimer(timer);
    }
    /**
     * Adds a [[Scene]] to the engine, think of scenes in Excalibur as you
     * would levels or menus.
     *
     * @param key  The name of the scene, must be unique
     * @param scene The scene to add to the engine
     */
    addScene(key, scene) {
        if (this.scenes[key]) {
            this._logger.warn('Scene', key, 'already exists overwriting');
        }
        this.scenes[key] = scene;
    }
    /**
     * @internal
     */
    removeScene(entity) {
        if (entity instanceof Scene) {
            // remove scene
            for (const key in this.scenes) {
                if (this.scenes.hasOwnProperty(key)) {
                    if (this.scenes[key] === entity) {
                        delete this.scenes[key];
                    }
                }
            }
        }
        if (typeof entity === 'string') {
            // remove scene
            delete this.scenes[entity];
        }
    }
    add(entity) {
        if (arguments.length === 2) {
            this.addScene(arguments[0], arguments[1]);
            return;
        }
        if (this._deferredGoTo && this.scenes[this._deferredGoTo]) {
            this.scenes[this._deferredGoTo].add(entity);
        }
        else {
            this.currentScene.add(entity);
        }
    }
    remove(entity) {
        if (entity instanceof Entity) {
            this.currentScene.remove(entity);
        }
        if (entity instanceof Scene) {
            this.removeScene(entity);
        }
        if (typeof entity === 'string') {
            this.removeScene(entity);
        }
    }
    /**
     * Changes the currently updating and drawing scene to a different,
     * named scene. Calls the [[Scene]] lifecycle events.
     * @param key  The key of the scene to transition to.
     */
    goToScene(key) {
        // if not yet initialized defer goToScene
        if (!this.isInitialized) {
            this._deferredGoTo = key;
            return;
        }
        if (this.scenes[key]) {
            const oldScene = this.currentScene;
            const newScene = this.scenes[key];
            this._logger.debug('Going to scene:', key);
            // only deactivate when initialized
            if (this.currentScene.isInitialized) {
                this.currentScene._deactivate.apply(this.currentScene, [oldScene, newScene]);
                this.currentScene.eventDispatcher.emit('deactivate', new DeactivateEvent(newScene, this.currentScene));
            }
            // set current scene to new one
            this.currentScene = newScene;
            this.screen.setCurrentCamera(newScene.camera);
            // initialize the current scene if has not been already
            this.currentScene._initialize(this);
            this.currentScene._activate.apply(this.currentScene, [oldScene, newScene]);
            this.currentScene.eventDispatcher.emit('activate', new ActivateEvent(oldScene, this.currentScene));
        }
        else {
            this._logger.error('Scene', key, 'does not exist!');
        }
    }
    /**
     * Transforms the current x, y from screen coordinates to world coordinates
     * @param point  Screen coordinate to convert
     */
    screenToWorldCoordinates(point) {
        return this.screen.screenToWorldCoordinates(point);
    }
    /**
     * Transforms a world coordinate, to a screen coordinate
     * @param point  World coordinate to convert
     */
    worldToScreenCoordinates(point) {
        return this.screen.worldToScreenCoordinates(point);
    }
    /**
     * Initializes the internal canvas, rendering context, display mode, and native event listeners
     */
    _initialize(options) {
        this.pageScrollPreventionMode = options.scrollPreventionMode;
        // initialize inputs
        this.input = {
            keyboard: new Keyboard(),
            pointers: new Pointers(this),
            gamepads: new Gamepads()
        };
        this.input.keyboard.init();
        this.input.pointers.init(options && options.pointerScope === PointerScope.Document ? document : this.canvas);
        this.input.gamepads.init();
        // Issue #385 make use of the visibility api
        // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API
        let hidden, visibilityChange;
        if (typeof document.hidden !== 'undefined') {
            // Opera 12.10 and Firefox 18 and later support
            hidden = 'hidden';
            visibilityChange = 'visibilitychange';
        }
        else if ('msHidden' in document) {
            hidden = 'msHidden';
            visibilityChange = 'msvisibilitychange';
        }
        else if ('webkitHidden' in document) {
            hidden = 'webkitHidden';
            visibilityChange = 'webkitvisibilitychange';
        }
        this.browser.document.on(visibilityChange, () => {
            if (document[hidden]) {
                this.eventDispatcher.emit('hidden', new HiddenEvent(this));
                this._logger.debug('Window hidden');
            }
            else {
                this.eventDispatcher.emit('visible', new VisibleEvent(this));
                this._logger.debug('Window visible');
            }
        });
        if (!this.canvasElementId && !options.canvasElement) {
            document.body.appendChild(this.canvas);
        }
    }
    onInitialize(_engine) {
        // Override me
    }
    /**
     * If supported by the browser, this will set the antialiasing flag on the
     * canvas. Set this to `false` if you want a 'jagged' pixel art look to your
     * image resources.
     * @param isSmooth  Set smoothing to true or false
     */
    setAntialiasing(isSmooth) {
        this.screen.antialiasing = isSmooth;
    }
    /**
     * Return the current smoothing status of the canvas
     */
    getAntialiasing() {
        return this.screen.antialiasing;
    }
    /**
     * Gets whether the actor is Initialized
     */
    get isInitialized() {
        return this._isInitialized;
    }
    _overrideInitialize(engine) {
        if (!this.isInitialized) {
            this.onInitialize(engine);
            super.emit('initialize', new InitializeEvent(engine, this));
            this._isInitialized = true;
            if (this._deferredGoTo) {
                this.goToScene(this._deferredGoTo);
            }
            else {
                this.goToScene('root');
            }
        }
    }
    /**
     * Updates the entire state of the game
     * @param delta  Number of milliseconds elapsed since the last update.
     */
    _update(delta) {
        if (this._isLoading) {
            // suspend updates until loading is finished
            this._loader.update(this, delta);
            // Update input listeners
            this.input.keyboard.update();
            this.input.pointers.update();
            this.input.gamepads.update();
            return;
        }
        this._overrideInitialize(this);
        // Publish preupdate events
        this._preupdate(delta);
        // process engine level events
        this.currentScene.update(this, delta);
        // update animations
        // TODO remove
        this._animations = this._animations.filter(function (a) {
            return !a.animation.isDone();
        });
        // Update input listeners
        this.input.keyboard.update();
        this.input.pointers.update();
        this.input.gamepads.update();
        // Publish update event
        this._postupdate(delta);
    }
    /**
     * @internal
     */
    _preupdate(delta) {
        this.emit('preupdate', new PreUpdateEvent(this, delta, this));
        this.onPreUpdate(this, delta);
    }
    onPreUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postupdate(delta) {
        this.emit('postupdate', new PostUpdateEvent(this, delta, this));
        this.onPostUpdate(this, delta);
    }
    onPostUpdate(_engine, _delta) {
        // Override me
    }
    /**
     * Draws the entire game
     * @param delta  Number of milliseconds elapsed since the last draw.
     */
    _draw(delta) {
        const ctx = this.ctx;
        this._predraw(ctx, delta);
        if (this._isLoading) {
            this._loader.canvas.draw(this.graphicsContext, 0, 0);
            this.graphicsContext.flush();
            // Drawing nothing else while loading
            return;
        }
        // TODO move to graphics systems?
        this.graphicsContext.backgroundColor = this.backgroundColor;
        this.currentScene.draw(this.ctx, delta);
        // todo needs to be a better way of doing this
        let a = 0;
        const len = this._animations.length;
        for (a; a < len; a++) {
            this._animations[a].animation.draw(ctx, this._animations[a].x, this._animations[a].y);
        }
        // Draw debug information
        // TODO don't access ctx directly
        if (this.isDebug) {
            this.ctx.font = 'Consolas';
            this.ctx.fillStyle = this.debugColor.toString();
            const keys = this.input.keyboard.getKeys();
            for (let j = 0; j < keys.length; j++) {
                this.ctx.fillText(keys[j].toString() + ' : ' + (Keys[keys[j]] ? Keys[keys[j]] : 'Not Mapped'), 100, 10 * j + 10);
            }
            this.ctx.fillText('FPS:' + this.stats.currFrame.fps.toFixed(2).toString(), 10, 10);
        }
        // Post processing
        for (let i = 0; i < this.postProcessors.length; i++) {
            this.postProcessors[i].process(this.ctx.getImageData(0, 0, this.canvasWidth, this.canvasHeight), this.ctx);
        }
        this._postdraw(ctx, delta);
    }
    /**
     * @internal
     */
    _predraw(_ctx, delta) {
        this.emit('predraw', new PreDrawEvent(_ctx, delta, this));
        this.onPreDraw(_ctx, delta);
    }
    onPreDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * @internal
     */
    _postdraw(_ctx, delta) {
        this.emit('postdraw', new PostDrawEvent(_ctx, delta, this));
        this.onPostDraw(_ctx, delta);
    }
    onPostDraw(_ctx, _delta) {
        // Override me
    }
    /**
     * Enable or disable Excalibur debugging functionality.
     * @param toggle a value that debug drawing will be changed to
     */
    showDebug(toggle) {
        this._isDebug = toggle;
    }
    /**
     * Toggle Excalibur debugging functionality.
     */
    toggleDebug() {
        this._isDebug = !this._isDebug;
        return this._isDebug;
    }
    /**
     * Returns true when loading is totally complete and the player has clicked start
     */
    get loadingComplete() {
        return this._loadingComplete;
    }
    /**
     * Starts the internal game loop for Excalibur after loading
     * any provided assets.
     * @param loader  Optional [[Loader]] to use to load resources. The default loader is [[Loader]], override to provide your own
     * custom loader.
     */
    start(loader) {
        if (!this._compatible) {
            return Promise.reject('Excalibur is incompatible with your browser');
        }
        let loadingComplete;
        // Push the current user entered resolution/viewport
        this.screen.pushResolutionAndViewport();
        // Configure resolution for loader
        this.screen.resolution = this.screen.viewport;
        this.screen.applyResolutionAndViewport();
        this.graphicsContext.updateViewport();
        if (loader) {
            this._loader = loader;
            this._loader.suppressPlayButton = this._suppressPlayButton || this._loader.suppressPlayButton;
            this._loader.wireEngine(this);
            loadingComplete = this.load(this._loader);
        }
        else {
            loadingComplete = Promise.resolve();
        }
        loadingComplete.then(() => {
            this.screen.popResolutionAndViewport();
            this.screen.applyResolutionAndViewport();
            this.graphicsContext.updateViewport();
            this.emit('start', new GameStartEvent(this));
            this._loadingComplete = true;
        });
        if (!this._hasStarted) {
            // has started is a slight misnomer, it's really mainloop started
            this._hasStarted = true;
            this._logger.debug('Starting game...');
            this.browser.resume();
            Engine.createMainLoop(this, window.requestAnimationFrame, Date.now)();
            this._logger.debug('Game started');
        }
        else {
            // Game already started;
        }
        return loadingComplete;
    }
    static createMainLoop(game, raf, nowFn) {
        let lastTime = nowFn();
        return function mainloop() {
            if (!game._hasStarted) {
                return;
            }
            try {
                game._requestId = raf(mainloop);
                game.emit('preframe', new PreFrameEvent(game, game.stats.prevFrame));
                // Get the time to calculate time-elapsed
                const now = nowFn();
                let elapsed = Math.floor(now - lastTime) || 1;
                // Resolves issue #138 if the game has been paused, or blurred for
                // more than a 200 milliseconds, reset elapsed time to 1. This improves reliability
                // and provides more expected behavior when the engine comes back
                // into focus
                if (elapsed > 200) {
                    elapsed = 1;
                }
                const delta = elapsed * game.timescale;
                // reset frame stats (reuse existing instances)
                const frameId = game.stats.prevFrame.id + 1;
                game.stats.currFrame.reset();
                game.stats.currFrame.id = frameId;
                game.stats.currFrame.delta = delta;
                game.stats.currFrame.fps = 1.0 / (delta / 1000);
                const beforeUpdate = nowFn();
                game._update(delta);
                const afterUpdate = nowFn();
                game._draw(delta);
                const afterDraw = nowFn();
                game.stats.currFrame.duration.update = afterUpdate - beforeUpdate;
                game.stats.currFrame.duration.draw = afterDraw - afterUpdate;
                lastTime = now;
                game.emit('postframe', new PostFrameEvent(game, game.stats.currFrame));
                game.stats.prevFrame.reset(game.stats.currFrame);
            }
            catch (e) {
                window.cancelAnimationFrame(game._requestId);
                game.stop();
                game.onFatalException(e);
            }
        };
    }
    /**
     * Stops Excalibur's main loop, useful for pausing the game.
     */
    stop() {
        if (this._hasStarted) {
            this.emit('stop', new GameStopEvent(this));
            this.browser.pause();
            this._hasStarted = false;
            this._logger.debug('Game stopped');
        }
    }
    /**
     * Returns the Engine's Running status, Useful for checking whether engine is running or paused.
     */
    isPaused() {
        return !this._hasStarted;
    }
    /**
     * Takes a screen shot of the current viewport and returns it as an
     * HTML Image Element.
     */
    screenshot() {
        const result = new Image();
        const raw = this.canvas.toDataURL('image/png');
        result.src = raw;
        return result;
    }
    /**
     * Another option available to you to load resources into the game.
     * Immediately after calling this the game will pause and the loading screen
     * will appear.
     * @param loader  Some [[Loadable]] such as a [[Loader]] collection, [[Sound]], or [[Texture]].
     */
    load(loader) {
        const complete = new Promise((resolve) => {
            this._isLoading = true;
            loader.load().then(() => {
                if (this._suppressPlayButton) {
                    setTimeout(() => {
                        this._isLoading = false;
                        resolve();
                        // Delay is to give the logo a chance to show, otherwise don't delay
                    }, 500);
                }
                else {
                    this._isLoading = false;
                    resolve();
                }
            });
        });
        return complete;
    }
}
/**
 * Default [[EngineOptions]]
 */
Engine._DEFAULT_ENGINE_OPTIONS = {
    width: 0,
    height: 0,
    enableCanvasTransparency: true,
    canvasElementId: '',
    canvasElement: undefined,
    snapToPixel: false,
    pointerScope: PointerScope.Canvas,
    suppressConsoleBootMessage: null,
    suppressMinimumBrowserFeatureDetection: null,
    suppressHiDPIScaling: null,
    suppressPlayButton: null,
    scrollPreventionMode: ScrollPreventionMode.Canvas,
    backgroundColor: Color.fromHex('#2185d0') // Excalibur blue
};
Engine_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use Actor.graphics' })
], Engine.prototype, "playAnimation", null);
/**
 * @internal
 * @deprecated
 */
let AnimationNode = class AnimationNode {
    constructor(animation, x, y) {
        this.animation = animation;
        this.x = x;
        this.y = y;
    }
};
AnimationNode = Engine_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0' })
], AnimationNode);

;// CONCATENATED MODULE: ./Math/Index.ts









;// CONCATENATED MODULE: ./Debug/index.ts




;// CONCATENATED MODULE: ./Events/MediaEvents.ts

class MediaEvent extends GameEvent {
    constructor(target, _name = 'MediaEvent') {
        super();
        this.target = target;
        this._name = _name;
    }
    /**
     * Media event cannot bubble
     */
    set bubbles(_value) {
        // stubbed
    }
    /**
     * Media event cannot bubble
     */
    get bubbles() {
        return false;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    get _path() {
        return null;
    }
    /**
     * Media event cannot bubble, so they have no path
     */
    set _path(_val) {
        // stubbed
    }
    /**
     * Prevents event from bubbling
     */
    stopPropagation() {
        /**
         * Stub
         */
    }
    /**
     * Action, that calls when event happens
     */
    action() {
        /**
         * Stub
         */
    }
    /**
     * Propagate event further through event path
     */
    propagate() {
        /**
         * Stub
         */
    }
    layPath(_actor) {
        /**
         * Stub
         */
    }
}
class NativeSoundEvent extends MediaEvent {
    constructor(target, track) {
        super(target, 'NativeSoundEvent');
        this.track = track;
    }
}
class NativeSoundProcessedEvent extends MediaEvent {
    constructor(target, _processedData) {
        super(target, 'NativeSoundProcessedEvent');
        this._processedData = _processedData;
        this.data = this._processedData;
    }
}

;// CONCATENATED MODULE: ./Graphics/Font.ts





class Font extends Raster {
    constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        super(options);
        /**
         * Font quality determines the size of the underlying rastered text, higher quality means less jagged edges.
         * If quality is set to 1, then just enough raster bitmap is generated to render the text.
         *
         * You can think of quality as how zoomed in to the text you can get before seeing jagged edges.
         *
         * (Default 4)
         */
        this.quality = 2;
        this.family = 'sans-serif';
        this.style = FontStyle.Normal;
        this.bold = false;
        this.unit = FontUnit.Px;
        this.textAlign = TextAlign.Left;
        this.baseAlign = BaseAlign.Alphabetic;
        this.direction = Direction.LeftToRight;
        this.size = 10;
        this.shadow = null;
        this._textBounds = new BoundingBox();
        this._textWidth = 0;
        this._textHeight = 0;
        this.family = (_a = options === null || options === void 0 ? void 0 : options.family) !== null && _a !== void 0 ? _a : this.family;
        this.style = (_b = options === null || options === void 0 ? void 0 : options.style) !== null && _b !== void 0 ? _b : this.style;
        this.bold = (_c = options === null || options === void 0 ? void 0 : options.bold) !== null && _c !== void 0 ? _c : this.bold;
        this.size = (_d = options === null || options === void 0 ? void 0 : options.size) !== null && _d !== void 0 ? _d : this.size;
        this.unit = (_e = options === null || options === void 0 ? void 0 : options.unit) !== null && _e !== void 0 ? _e : this.unit;
        this.textAlign = (_f = options === null || options === void 0 ? void 0 : options.textAlign) !== null && _f !== void 0 ? _f : this.textAlign;
        this.baseAlign = (_g = options === null || options === void 0 ? void 0 : options.baseAlign) !== null && _g !== void 0 ? _g : this.baseAlign;
        this.direction = (_h = options === null || options === void 0 ? void 0 : options.direction) !== null && _h !== void 0 ? _h : this.direction;
        this.quality = (_j = options === null || options === void 0 ? void 0 : options.quality) !== null && _j !== void 0 ? _j : this.quality;
        if (options === null || options === void 0 ? void 0 : options.shadow) {
            this.shadow = {};
            this.shadow.blur = (_k = options.shadow.blur) !== null && _k !== void 0 ? _k : this.shadow.blur;
            this.shadow.offset = (_l = options.shadow.offset) !== null && _l !== void 0 ? _l : this.shadow.offset;
            this.shadow.color = (_m = options.shadow.color) !== null && _m !== void 0 ? _m : this.shadow.color;
        }
        this.flagDirty();
    }
    clone() {
        return new Font(Object.assign(Object.assign(Object.assign({}, this.cloneGraphicOptions()), this.cloneRasterOptions()), { size: this.size, unit: this.unit, family: this.family, style: this.style, bold: this.bold, textAlign: this.textAlign, baseAlign: this.baseAlign, direction: this.direction, shadow: this.shadow
                ? {
                    blur: this.shadow.blur,
                    offset: this.shadow.offset,
                    color: this.shadow.color
                }
                : null }));
    }
    get fontString() {
        return `${this.style} ${this.bold ? 'bold' : ''} ${this.size}${this.unit} ${this.family}`;
    }
    get width() {
        return this._textWidth;
    }
    set width(value) {
        this._textWidth = value;
    }
    get height() {
        var _a, _b;
        const numLines = (_b = (_a = this._lines) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 1;
        return this._textHeight * numLines;
    }
    set height(value) {
        var _a, _b;
        const numLines = (_b = (_a = this._lines) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 1;
        this._textHeight = value / numLines;
    }
    get _rasterWidth() {
        return this._bitmap.width;
    }
    get _rasterHeight() {
        return this._bitmap.height;
    }
    get _halfRasterWidth() {
        return Math.floor(this._bitmap.width / 2);
    }
    get _halfRasterHeight() {
        return Math.floor(this._bitmap.height / 2);
    }
    get localBounds() {
        return this._textBounds;
    }
    _drawImage(ex, x, y) {
        if (this.dirty) {
            this.rasterize();
        }
        ex.drawImage(this._bitmap, 0, 0, this._rasterWidth, this._rasterHeight, x - this._rasterWidth / this.quality / 2, y - this._rasterHeight / this.quality / 2, this._rasterWidth / this.quality, this._rasterHeight / this.quality);
    }
    _rotate(ex) {
        var _a;
        // TODO this needs to change depending on the bounding box...
        const origin = (_a = this.origin) !== null && _a !== void 0 ? _a : this._textBounds.center;
        ex.translate(origin.x, origin.y);
        ex.rotate(this.rotation);
        ex.translate(-origin.x, -origin.y);
    }
    _flip(ex) {
        if (this.flipHorizontal) {
            ex.translate(this._textBounds.width / this.scale.x, 0);
            ex.scale(-1, 1);
        }
        if (this.flipVertical) {
            ex.translate(0, -this._textBounds.height / 2 / this.scale.y);
            ex.scale(1, -1);
        }
    }
    updateText(text) {
        if (this._text !== text) {
            this._text = text;
            this._lines = this._text.split('\n');
            this._updateDimensions();
            this.flagDirty();
        }
    }
    _updateDimensions() {
        if (this._text) {
            this._applyFont(this._ctx);
            const maxWidthLine = this._lines.reduce((a, b) => {
                return a.length > b.length ? a : b;
            });
            const metrics = this._ctx.measureText(maxWidthLine);
            this._textWidth = Math.abs(metrics.actualBoundingBoxLeft) + Math.abs(metrics.actualBoundingBoxRight);
            this._textHeight = Math.abs(metrics.actualBoundingBoxAscent) + Math.abs(metrics.actualBoundingBoxDescent);
            // TODO lineheight makes the text bounds wonky
            const lineAdjustedHeight = this._textHeight * this._lines.length;
            // this._textHeight = lineAdjustedHeight;
            // Changing the width and height clears the context properties
            // We double the bitmap width to account for alignment
            // We scale by "quality" so we render text without jaggies
            this._bitmap.width = (this._textWidth + this.padding * 2) * 2 * this.quality;
            this._bitmap.height = (lineAdjustedHeight + this.padding * 2) * 2 * this.quality;
            // These bounds exist in raster bitmap space where the top left corner is the corder of the bitmap
            const x = 0;
            const y = 0;
            const bottomBounds = lineAdjustedHeight - Math.abs(metrics.actualBoundingBoxAscent);
            this._textBounds = new BoundingBox({
                left: x - Math.abs(metrics.actualBoundingBoxLeft) - this.padding,
                top: y - Math.abs(metrics.actualBoundingBoxAscent) - this.padding,
                bottom: y + bottomBounds + this.padding,
                right: x + Math.abs(metrics.actualBoundingBoxRight) + this.padding
            });
        }
    }
    _preDraw(ex, x, y) {
        if (this.dirty) {
            this._updateDimensions();
        }
        super._preDraw(ex, x, y);
    }
    _postDraw(ex) {
        if (this.showDebug) {
            /* istanbul ignore next */
            ex.debug.drawRect(-this._halfRasterWidth, -this._halfRasterHeight, this._rasterWidth, this._rasterHeight);
        }
        ex.restore();
    }
    _applyFont(ctx) {
        ctx.translate(this.padding + this._halfRasterWidth, this.padding + this._halfRasterHeight);
        ctx.scale(this.quality, this.quality);
        ctx.textAlign = this.textAlign;
        ctx.textBaseline = this.baseAlign;
        ctx.font = this.fontString;
        ctx.direction = this.direction;
        if (this.shadow) {
            ctx.shadowColor = this.shadow.color.toString();
            ctx.shadowBlur = this.shadow.blur;
            ctx.shadowOffsetX = this.shadow.offset.x;
            ctx.shadowOffsetY = this.shadow.offset.y;
        }
    }
    execute(ctx) {
        if (this._text) {
            // The reason we need to re-apply the font is setting raster properties (like width/height) can reset the context props
            this._applyRasterProperites(ctx);
            this._applyFont(ctx);
            const lineHeight = this._textHeight; // TODO user specified line height
            for (let i = 0; i < this._lines.length; i++) {
                const line = this._lines[i];
                if (this.color) {
                    ctx.fillText(line, 0, i * lineHeight);
                }
                if (this.strokeColor) {
                    ctx.strokeText(line, 0, i * lineHeight);
                }
            }
            if (this.showDebug) {
                // Horizontal line
                /* istanbul ignore next */
                line(ctx, Color.Red, -this._halfRasterWidth, 0, this._halfRasterWidth, 0, 2);
                // Vertical line
                /* istanbul ignore next */
                line(ctx, Color.Red, 0, -this._halfRasterHeight, 0, this._halfRasterHeight, 2);
            }
        }
    }
    render(ex, text, x, y) {
        this.updateText(text);
        this.draw(ex, x, y);
    }
}

;// CONCATENATED MODULE: ./Graphics/Text.ts




class Text extends Graphic {
    constructor(options) {
        var _a, _b;
        super(options);
        this._text = '';
        // This order is important font, color, then text
        this.font = (_a = options.font) !== null && _a !== void 0 ? _a : new Font();
        this.color = (_b = options.color) !== null && _b !== void 0 ? _b : this.color;
        this.text = options.text;
    }
    clone() {
        return new Text({
            text: this.text.slice(),
            color: this.color.clone(),
            font: this.font.clone()
        });
    }
    get text() {
        return this._text;
    }
    set text(value) {
        this._text = value;
        this.font.updateText(value);
    }
    // TODO SpriteFont doesn't support a color yet :(
    get color() {
        if (this.font instanceof Font) {
            return this.font.color;
        }
        return Color.Black;
    }
    set color(color) {
        if (this.font instanceof Font) {
            this.font.color = color;
        }
    }
    get font() {
        return this._font;
    }
    set font(font) {
        if (font instanceof Font) {
            this._font = watch(font, (font) => font.flagDirty());
        }
        else {
            this._font = font;
        }
    }
    get width() {
        return this.font.width;
    }
    get height() {
        return this.font.height;
    }
    get localBounds() {
        return this.font.localBounds;
    }
    _rotate(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _flip(_ex) {
        // None this is delegated to font
        // This override erases the default behavior
    }
    _drawImage(ex, x, y) {
        if (this.font instanceof Font) {
            this.font.color = this.color;
        }
        this.font.flipHorizontal = this.flipHorizontal;
        this.font.flipVertical = this.flipVertical;
        this.font.scale = this.scale;
        this.font.rotation = this.rotation;
        this.font.origin = this.origin;
        this.font.opacity = this.opacity;
        this.font.render(ex, this._text, x, y);
    }
}

;// CONCATENATED MODULE: ./Label.ts
var Label_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};







/**
 * Labels are the way to draw small amounts of text to the screen. They are
 * actors and inherit all of the benefits and capabilities.
 */
class Label_Label extends Actor {
    /**
     * Build a new label
     * @param options
     */
    constructor(options) {
        super(options);
        this.font = new Font();
        this._text = new Text({ text: '', font: this.font });
        /**
         * Gets or sets the letter spacing on a Label. Only supported with Sprite Fonts.
         * @deprecated Use [[SpriteFont.spacing]]
         */
        this.letterSpacing = 0; //px
        /**
         * Whether or not the [[SpriteFont]] will be case-sensitive when matching characters.
         * @deprecated Use Graphics.SpriteFont.caseInsensitve
         */
        this.caseInsensitive = true;
        const { text, pos, x, y, spriteFont, font, color } = options;
        this.pos = pos !== null && pos !== void 0 ? pos : (x && y ? vec(x, y) : this.pos);
        this.text = text !== null && text !== void 0 ? text : this.text;
        this.spriteFont = spriteFont !== null && spriteFont !== void 0 ? spriteFont : this.spriteFont;
        this.font = font !== null && font !== void 0 ? font : this.font;
        this.color = color !== null && color !== void 0 ? color : this.color;
        const gfx = this.get(GraphicsComponent);
        gfx.anchor = Vector.Zero;
        gfx.use(this._text);
    }
    /**
     * The text to draw.
     */
    get text() {
        return this._text.text;
    }
    set text(text) {
        this._text.text = text;
    }
    get color() {
        return this._text.color;
    }
    set color(color) {
        this._text.color = color;
    }
    get opacity() {
        return this._text.opacity;
    }
    set opacity(opacity) {
        this._text.opacity = opacity;
    }
    /**
     * Sets or gets the bold property of the label's text, by default it's false
     * @deprecated Use [[Font.bold|Label.font.bold]]
     */
    get bold() {
        return this.font.bold;
    }
    set bold(isBold) {
        this.font.bold = isBold;
    }
    /**
     * The CSS font family string (e.g. `sans-serif`, `Droid Sans Pro`). Web fonts
     * are supported, same as in CSS.
     * @deprecated Use [[Font.family|Label.font.family]]
     */
    get fontFamily() {
        return this.font.family;
    }
    set fontFamily(family) {
        this.font.family = family;
    }
    /**
     * The font size in the selected units, default is 10 (default units is pixel)
     * @deprecated Use [[Font.size|Label.font.size]]
     */
    get fontSize() {
        return this.font.size;
    }
    set fontSize(sizeInUnit) {
        this.font.size = sizeInUnit;
    }
    /**
     * The font style for this label, the default is [[FontStyle.Normal]]
     * @deprecated Use [[Font.style|Label.font.style]]
     */
    get fontStyle() {
        return this.font.style;
    }
    set fontStyle(style) {
        this.font.style = style;
    }
    /**
     * The css units for a font size such as px, pt, em (SpriteFont only support px), by default is 'px';
     * @deprecated Use [[Font.unit|Label.font.unit]]
     */
    get fontUnit() {
        return this.font.unit;
    }
    set fontUnit(unit) {
        this.font.unit = unit;
    }
    /**
     * Gets or sets the horizontal text alignment property for the label.
     * @deprecated Use [[Font.textAlign|Label.font.textAlign]]
     */
    get textAlign() {
        return this.font.textAlign;
    }
    set textAlign(align) {
        this.font.textAlign = align;
    }
    /**
     * Gets or sets the baseline alignment property for the label.
     * @deprecated Use [[Font.baseAlign|Label.font.baseAlign]]
     */
    get baseAlign() {
        return this.font.baseAlign;
    }
    set baseAlign(align) {
        this.font.baseAlign = align;
    }
    /**
     * The [[LegacyDrawing.SpriteFont]] to use, if any. Overrides [[fontFamily]] if present.
     * @deprecated Use [[SpriteFont]]
     */
    get spriteFont() {
        return this._legacySpriteFont;
    }
    set spriteFont(sf) {
        if (sf) {
            if (sf instanceof SpriteFont) {
                this._legacySpriteFont = sf;
                this._spriteFont = SpriteFont_SpriteFont.fromLegacySpriteFont(sf);
                this._text.font = this._spriteFont;
                return;
            }
            this._spriteFont = sf;
            this._text.font = this._spriteFont;
        }
    }
    _initialize(engine) {
        super._initialize(engine);
        this._graphicsContext = engine.graphicsContext;
    }
    /**
     * Returns the width of the text in the label (in pixels);
     */
    getTextWidth() {
        return this._text.width;
    }
    /**
     * Sets the text shadow for sprite fonts
     * @param offsetX      The x offset in pixels to place the shadow
     * @param offsetY      The y offset in pixels to place the shadow
     * @param shadowColor  The color of the text shadow
     * @deprecated Use [[Font.shadow|Label.font.shadow]]
     */
    setTextShadow(offsetX, offsetY, shadowColor) {
        this.font.shadow = { offset: vec(offsetX, offsetY), blur: 2, color: shadowColor };
    }
    /**
     * Toggles text shadows on or off, only applies when using sprite fonts
     * @deprecated Use [[Font.shadow|Label.font.shadow]]
     */
    useTextShadow(on) {
        if (this.spriteFont) {
            this.spriteFont.useTextShadow(on);
        }
    }
    /**
     * Clears the current text shadow
     * @deprecated Use [[Font.shadow|Label.font.shadow]]
     */
    clearTextShadow() {
        this.font.shadow = null;
    }
    draw(_ctx, _delta) {
        const exctx = this._graphicsContext;
        this._text.draw(exctx, 0, 0);
    }
}
Label_decorate([
    obsolete({
        message: 'Label.bold will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.bold'
    })
], Label_Label.prototype, "bold", null);
Label_decorate([
    obsolete({
        message: 'Label.fontFamily will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.family'
    })
], Label_Label.prototype, "fontFamily", null);
Label_decorate([
    obsolete({
        message: 'Label.fontSize will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.size'
    })
], Label_Label.prototype, "fontSize", null);
Label_decorate([
    obsolete({
        message: 'Label.fontStyle will be removed in v0.26.0',
        alternateMethod: 'Use Lable.font.style'
    })
], Label_Label.prototype, "fontStyle", null);
Label_decorate([
    obsolete({
        message: 'Label.fontUnit will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.unit'
    })
], Label_Label.prototype, "fontUnit", null);
Label_decorate([
    obsolete({
        message: 'Label.textAlign will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.textAlign'
    })
], Label_Label.prototype, "textAlign", null);
Label_decorate([
    obsolete({
        message: 'Label.baseAlign will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.baseAlign'
    })
], Label_Label.prototype, "baseAlign", null);
Label_decorate([
    obsolete()
], Label_Label.prototype, "spriteFont", null);
Label_decorate([
    obsolete({
        message: 'Label.setTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Label_Label.prototype, "setTextShadow", null);
Label_decorate([
    obsolete({
        message: 'Label.useTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Label_Label.prototype, "useTextShadow", null);
Label_decorate([
    obsolete({
        message: 'Label.clearTextShadow will be removed in v0.26.0',
        alternateMethod: 'Use Label.font.shadow'
    })
], Label_Label.prototype, "clearTextShadow", null);

;// CONCATENATED MODULE: ./Actions/Index.ts






















;// CONCATENATED MODULE: ./Collision/Group/CollisionGroupManager.ts

/**
 * Static class for managing collision groups in excalibur, there is a maximum of 32 collision groups possible in excalibur
 */
class CollisionGroupManager {
    /**
     * Create a new named collision group up to a max of 32.
     * @param name Name for the collision group
     * @param mask Optionally provide your own 32-bit mask, if none is provide the manager will generate one
     */
    static create(name, mask) {
        if (this._CURRENT_GROUP > this._MAX_GROUPS) {
            throw new Error(`Cannot have more than ${this._MAX_GROUPS} collision groups`);
        }
        if (this._GROUPS.get(name)) {
            throw new Error(`Collision group ${name} already exists`);
        }
        const group = new CollisionGroup(name, this._CURRENT_BIT, mask !== undefined ? mask : ~this._CURRENT_BIT);
        this._CURRENT_BIT = (this._CURRENT_BIT << 1) | 0;
        this._CURRENT_GROUP++;
        this._GROUPS.set(name, group);
        return group;
    }
    /**
     * Get all collision groups currently tracked by excalibur
     */
    static get groups() {
        return Array.from(this._GROUPS.values());
    }
    /**
     * Get a collision group by it's name
     * @param name
     */
    static groupByName(name) {
        return this._GROUPS.get(name);
    }
    /**
     * Resets the managers internal group management state
     */
    static reset() {
        this._GROUPS = new Map();
        this._CURRENT_BIT = this._STARTING_BIT;
        this._CURRENT_GROUP = 1;
    }
}
// using bitmasking the maximum number of groups is 32, because that is the highest 32bit integer that JS can present.
CollisionGroupManager._STARTING_BIT = 0b1 | 0;
CollisionGroupManager._MAX_GROUPS = 32;
CollisionGroupManager._CURRENT_GROUP = 1;
CollisionGroupManager._CURRENT_BIT = CollisionGroupManager._STARTING_BIT;
CollisionGroupManager._GROUPS = new Map();

;// CONCATENATED MODULE: ./Collision/Index.ts





























;// CONCATENATED MODULE: ./Drawing/Polygon.ts
var Polygon_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};


/**
 * Creates a closed polygon drawing given a list of [[Vector]]s.
 *
 * @deprecated Use [[Polygon]]
 * @warning Use sparingly as Polygons are performance intensive
 */
let Polygon = class Polygon {
    /**
     * @param points  The vectors to use to build the polygon in order
     */
    constructor(points) {
        /**
         * The width of the lines of the polygon
         */
        this.lineWidth = 5;
        /**
         * Indicates whether the polygon is filled or not.
         */
        this.filled = false;
        this._points = [];
        this.anchor = Vector.Zero;
        this.offset = Vector.Zero;
        this.rotation = 0;
        this.scale = Vector.One;
        this.opacity = 1;
        this._points = points;
        const minX = this._points.reduce((prev, curr) => {
            return Math.min(prev, curr.x);
        }, 0);
        const maxX = this._points.reduce((prev, curr) => {
            return Math.max(prev, curr.x);
        }, 0);
        this.drawWidth = maxX - minX;
        const minY = this._points.reduce((prev, curr) => {
            return Math.min(prev, curr.y);
        }, 0);
        const maxY = this._points.reduce((prev, curr) => {
            return Math.max(prev, curr.y);
        }, 0);
        this.drawHeight = maxY - minY;
        this.height = this.drawHeight;
        this.width = this.drawWidth;
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    addEffect() {
        // not supported on polygons
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    removeEffect() {
        // not supported on polygons
    }
    /**
     * @notimplemented Effects are not supported on `Polygon`
     */
    clearEffects() {
        // not supported on polygons
    }
    reset() {
        //pass
    }
    draw(ctxOrOptions, x, y) {
        if (ctxOrOptions instanceof CanvasRenderingContext2D) {
            this._drawWithOptions({ ctx: ctxOrOptions, x, y });
        }
        else {
            this._drawWithOptions(ctxOrOptions);
        }
    }
    _drawWithOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { ctx, x, y, rotation, drawWidth, drawHeight, anchor, offset, opacity, flipHorizontal, flipVertical } = Object.assign(Object.assign({}, options), { rotation: (_a = options.rotation) !== null && _a !== void 0 ? _a : this.rotation, drawWidth: (_b = options.drawWidth) !== null && _b !== void 0 ? _b : this.drawWidth, drawHeight: (_c = options.drawHeight) !== null && _c !== void 0 ? _c : this.drawHeight, flipHorizontal: (_d = options.flipHorizontal) !== null && _d !== void 0 ? _d : this.flipHorizontal, flipVertical: (_e = options.flipVertical) !== null && _e !== void 0 ? _e : this.flipVertical, anchor: (_f = options.anchor) !== null && _f !== void 0 ? _f : this.anchor, offset: (_g = options.offset) !== null && _g !== void 0 ? _g : this.offset, opacity: ((_h = options.opacity) !== null && _h !== void 0 ? _h : 1) * ((_j = this.opacity) !== null && _j !== void 0 ? _j : 1) });
        const xpoint = drawWidth * anchor.x + offset.x + x;
        const ypoint = drawHeight * anchor.y + offset.y + y;
        ctx.save();
        ctx.translate(xpoint, ypoint);
        ctx.scale(this.scale.x, this.scale.y);
        ctx.rotate(rotation);
        ctx.beginPath();
        ctx.lineWidth = this.lineWidth;
        // Iterate through the supplied points and construct a 'polygon'
        const firstPoint = this._points[0];
        ctx.moveTo(firstPoint.x, firstPoint.y);
        let i = 0;
        const len = this._points.length;
        for (i; i < len; i++) {
            ctx.lineTo(this._points[i].x, this._points[i].y);
        }
        ctx.lineTo(firstPoint.x, firstPoint.y);
        ctx.closePath();
        if (this.filled) {
            ctx.fillStyle = this.fillColor.toString();
            ctx.fill();
        }
        ctx.strokeStyle = this.lineColor.toString();
        if (flipHorizontal) {
            ctx.translate(drawWidth, 0);
            ctx.scale(-1, 1);
        }
        if (flipVertical) {
            ctx.translate(0, drawHeight);
            ctx.scale(1, -1);
        }
        const oldAlpha = ctx.globalAlpha;
        ctx.globalAlpha = opacity;
        ctx.stroke();
        ctx.globalAlpha = oldAlpha;
        ctx.restore();
    }
};
Polygon = Polygon_decorate([
    obsolete({
        message: 'Polygon will be removed in v0.26.0',
        alternateMethod: 'Use Graphics.Polygon'
    })
], Polygon);


;// CONCATENATED MODULE: ./Drawing/Index.ts










;// CONCATENATED MODULE: ./Interfaces/AudioImplementation.ts
class ExResponse {
}
ExResponse.type = {
    any: '',
    blob: 'blob',
    json: 'json',
    text: 'text',
    document: 'document',
    arraybuffer: 'arraybuffer'
};

;// CONCATENATED MODULE: ./Interfaces/LifecycleEvents.ts
/**
 * Type guard checking for internal initialize method
 * @internal
 * @param a
 */
function has_initialize(a) {
    return !!a._initialize;
}
/**
 *
 */
function hasOnInitialize(a) {
    return !!a.onInitialize;
}
/**
 *
 */
function has_preupdate(a) {
    return !!a._preupdate;
}
/**
 *
 */
function hasOnPreUpdate(a) {
    return !!a.onPreUpdate;
}
/**
 *
 */
function has_postupdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasOnPostUpdate(a) {
    return !!a.onPostUpdate;
}
/**
 *
 */
function hasPreDraw(a) {
    return !!a.onPreDraw;
}
/**
 *
 */
function hasPostDraw(a) {
    return !!a.onPostDraw;
}

;// CONCATENATED MODULE: ./Interfaces/Index.ts










;// CONCATENATED MODULE: ./PostProcessing/Index.ts



;// CONCATENATED MODULE: ./Resources/Sound/WebAudioInstance.ts


/**
 * Internal class representing a Web Audio AudioBufferSourceNode instance
 * @see https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API
 */
class WebAudioInstance {
    constructor(_src) {
        this._src = _src;
        this._volume = 1;
        this._duration = undefined;
        this._loop = false;
        this._isPlaying = false;
        this._isPaused = false;
        this._audioContext = AudioContextFactory.create();
        this._volumeNode = this._audioContext.createGain();
        /**
         * Current playback offset (in seconds)
         */
        this._currentOffset = 0;
        this._createNewBufferSource();
    }
    set loop(value) {
        this._loop = value;
        if (this._instance) {
            this._instance.loop = value;
            this._wireUpOnEnded();
        }
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        value = clamp(value, 0, 1.0);
        this._volume = value;
        if (this._isPlaying && this._volumeNode.gain.setTargetAtTime) {
            // https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime
            // After each .1 seconds timestep, the target value will ~63.2% closer to the target value.
            // This exponential ramp provides a more pleasant transition in gain
            this._volumeNode.gain.setTargetAtTime(value, this._audioContext.currentTime, 0.1);
        }
        else {
            this._volumeNode.gain.value = value;
        }
    }
    get volume() {
        return this._volume;
    }
    set duration(value) {
        this._duration = value;
    }
    /**
     * Duration of the sound, in seconds.
     */
    get duration() {
        return this._duration;
    }
    get _playbackRate() {
        return this._instance ? 1 / (this._instance.playbackRate.value || 1.0) : null;
    }
    isPlaying() {
        return this._isPlaying;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    play(playStarted = () => { }) {
        if (this._isPaused) {
            this._resumePlayBack();
            playStarted();
        }
        if (!this._isPlaying) {
            this._startPlayBack();
            playStarted();
        }
        return this._playingPromise;
    }
    pause() {
        if (!this._isPlaying) {
            return;
        }
        this._isPaused = true;
        this._isPlaying = false;
        this._instance.stop(0);
        // Playback rate will be a scale factor of how fast/slow the audio is being played
        // default is 1.0
        // we need to invert it to get the time scale
        this._setPauseOffset();
    }
    stop() {
        if (!this._isPlaying) {
            return;
        }
        this._isPlaying = false;
        this._isPaused = false;
        this._currentOffset = 0;
        this._instance.stop(0);
        // handler will not be wired up if we were looping
        if (!this._instance.onended) {
            this._handleOnEnded();
        }
    }
    _startPlayBack() {
        this._isPlaying = true;
        this._isPaused = false;
        this._playingPromise = new Promise((resolve) => {
            this._playingResolve = resolve;
        });
        if (!this._instance) {
            this._createNewBufferSource();
        }
        this._rememberStartTime();
        this._volumeNode.connect(this._audioContext.destination);
        this._instance.start(0, 0);
        this._currentOffset = 0;
        this._wireUpOnEnded();
    }
    _resumePlayBack() {
        if (!this._isPaused) {
            return;
        }
        this._isPaused = false;
        this._isPlaying = true;
        // a buffer source can only be started once
        // so we need to dispose of the previous instance before
        // "resuming" the next one
        this._instance.onended = null; // dispose of any previous event handler
        this._createNewBufferSource();
        const duration = this._playbackRate * this._src.duration;
        const restartTime = this._currentOffset % duration;
        this._rememberStartTime(restartTime * -1000);
        this._instance.start(0, restartTime);
        this._wireUpOnEnded();
    }
    _wireUpOnEnded() {
        if (!this.loop) {
            this._instance.onended = () => this._handleOnEnded();
        }
    }
    _handleOnEnded() {
        // pausing calls stop(0) which triggers onended event
        // so we don't "resolve" yet (when we resume we'll try again)
        if (!this._isPaused) {
            this._isPlaying = false;
            this._playingResolve(true);
        }
    }
    _rememberStartTime(amend) {
        this._startTime = new Date().getTime() + (amend | 0);
    }
    _setPauseOffset() {
        this._currentOffset = ((new Date().getTime() - this._startTime) * this._playbackRate) / 1000; // in seconds
    }
    _createNewBufferSource() {
        this._instance = this._audioContext.createBufferSource();
        this._instance.buffer = this._src;
        this._instance.loop = this.loop;
        this._instance.playbackRate.setValueAtTime(1.0, 0);
        this._instance.connect(this._volumeNode);
    }
}

;// CONCATENATED MODULE: ./Util/Sound.ts

/**
 * Whether or not the browser can play this file as HTML5 Audio
 */
function canPlayFile(file) {
    try {
        const a = new Audio();
        const filetype = /.*\.([A-Za-z0-9]+)$/;
        const type = file.match(filetype)[1];
        if (a.canPlayType('audio/' + type)) {
            return true;
        }
        else {
            return false;
        }
    }
    catch (e) {
        Logger.getInstance().warn('Cannot determine audio support, assuming no support for the Audio Tag', e);
        return false;
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/Sound.ts
var Sound_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};








/**
 * The [[Sound]] object allows games built in Excalibur to load audio
 * components, from soundtracks to sound effects. [[Sound]] is an [[Loadable]]
 * which means it can be passed to a [[Loader]] to pre-load before a game or level.
 */
class Sound extends Class {
    /**
     * @param paths A list of audio sources (clip.wav, clip.mp3, clip.ogg) for this audio clip. This is done for browser compatibility.
     */
    constructor(...paths) {
        super();
        this.logger = Logger.getInstance();
        this._loop = false;
        this._volume = 1;
        this._duration = undefined;
        this._isStopped = false;
        this._isPaused = false;
        this._tracks = [];
        this._wasPlayingOnHidden = false;
        this._audioContext = AudioContextFactory.create();
        this._resource = new Resource('', ExResponse.type.arraybuffer);
        /**
         * Chrome : MP3, WAV, Ogg
         * Firefox : WAV, Ogg,
         * IE : MP3, WAV coming soon
         * Safari MP3, WAV, Ogg
         */
        for (const path of paths) {
            if (canPlayFile(path)) {
                this.path = path;
                break;
            }
        }
        if (!this.path) {
            this.logger.warn('This browser does not support any of the audio files specified:', paths.join(', '));
            this.logger.warn('Attempting to use', paths[0]);
            this.path = paths[0]; // select the first specified
        }
    }
    /**
     * Indicates whether the clip should loop when complete
     * @param value  Set the looping flag
     */
    set loop(value) {
        this._loop = value;
        for (const track of this._tracks) {
            track.loop = this._loop;
        }
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._loop);
    }
    get loop() {
        return this._loop;
    }
    set volume(value) {
        this._volume = value;
        for (const track of this._tracks) {
            track.volume = this._volume;
        }
        this.emit('volumechange', new NativeSoundEvent(this));
        this.logger.debug('Set loop for all instances of sound', this.path, 'to', this._volume);
    }
    get volume() {
        return this._volume;
    }
    get duration() {
        return this._duration;
    }
    /**
     * Return array of Current AudioInstances playing or being paused
     */
    get instances() {
        return this._tracks;
    }
    get path() {
        return this._resource.path;
    }
    set path(val) {
        this._resource.path = val;
    }
    isLoaded() {
        return !!this.data;
    }
    load() {
        return Sound_awaiter(this, void 0, void 0, function* () {
            if (this.data) {
                return this.data;
            }
            const arraybuffer = yield this._resource.load();
            const audiobuffer = yield this.decodeAudio(arraybuffer.slice(0));
            this._duration = typeof audiobuffer === 'object' ? audiobuffer.duration : undefined;
            this.emit('processed', new NativeSoundProcessedEvent(this, audiobuffer));
            return this.data = audiobuffer;
        });
    }
    decodeAudio(data) {
        return Sound_awaiter(this, void 0, void 0, function* () {
            try {
                return yield this._audioContext.decodeAudioData(data.slice(0));
            }
            catch (e) {
                this.logger.error('Unable to decode ' +
                    ' this browser may not fully support this format, or the file may be corrupt, ' +
                    'if this is an mp3 try removing id3 tags and album art from the file.');
                return yield Promise.reject();
            }
        });
    }
    wireEngine(engine) {
        if (engine) {
            this._engine = engine;
            this._engine.on('hidden', () => {
                if (engine.pauseAudioWhenHidden && this.isPlaying()) {
                    this._wasPlayingOnHidden = true;
                    this.pause();
                }
            });
            this._engine.on('visible', () => {
                if (engine.pauseAudioWhenHidden && this._wasPlayingOnHidden) {
                    this.play();
                    this._wasPlayingOnHidden = false;
                }
            });
            this._engine.on('start', () => {
                this._isStopped = false;
            });
            this._engine.on('stop', () => {
                this.stop();
                this._isStopped = true;
            });
        }
    }
    /**
     * Returns how many instances of the sound are currently playing
     */
    instanceCount() {
        return this._tracks.length;
    }
    /**
     * Whether or not the sound is playing right now
     */
    isPlaying() {
        return this._tracks.some((t) => t.isPlaying());
    }
    /**
     * Play the sound, returns a promise that resolves when the sound is done playing
     * An optional volume argument can be passed in to play the sound. Max volume is 1.0
     */
    play(volume) {
        if (!this.isLoaded()) {
            this.logger.warn('Cannot start playing. Resource', this.path, 'is not loaded yet');
            return Promise.resolve(true);
        }
        if (this._isStopped) {
            this.logger.warn('Cannot start playing. Engine is in a stopped state.');
            return Promise.resolve(false);
        }
        this.volume = volume || this.volume;
        if (this._isPaused) {
            return this._resumePlayback();
        }
        else {
            return this._startPlayback();
        }
    }
    /**
     * Stop the sound, and do not rewind
     */
    pause() {
        if (!this.isPlaying()) {
            return;
        }
        for (const track of this._tracks) {
            track.pause();
        }
        this._isPaused = true;
        this.emit('pause', new NativeSoundEvent(this));
        this.logger.debug('Paused all instances of sound', this.path);
    }
    /**
     * Stop the sound if it is currently playing and rewind the track. If the sound is not playing, rewinds the track.
     */
    stop() {
        for (const track of this._tracks) {
            track.stop();
        }
        this.emit('stop', new NativeSoundEvent(this));
        this._isPaused = false;
        this._tracks.length = 0;
        this.logger.debug('Stopped all instances of sound', this.path);
    }
    /**
     * Get Id of provided AudioInstance in current trackList
     * @param track [[Audio]] which Id is to be given
     */
    getTrackId(track) {
        return this._tracks.indexOf(track);
    }
    _resumePlayback() {
        return Sound_awaiter(this, void 0, void 0, function* () {
            if (this._isPaused) {
                const resumed = [];
                // ensure we resume *current* tracks (if paused)
                for (const track of this._tracks) {
                    resumed.push(track.play());
                }
                this._isPaused = false;
                this.emit('resume', new NativeSoundEvent(this));
                this.logger.debug('Resuming paused instances for sound', this.path, this._tracks);
                // resolve when resumed tracks are done
                yield Promise.all(resumed);
            }
            return true;
        });
    }
    /**
     * Starts playback, returns a promise that resolves when playback is complete
     */
    _startPlayback() {
        return Sound_awaiter(this, void 0, void 0, function* () {
            const track = yield this._getTrackInstance(this.data);
            const complete = yield track.play(() => {
                this.emit('playbackstart', new NativeSoundEvent(this, track));
                this.logger.debug('Playing new instance for sound', this.path);
            });
            // when done, remove track
            this.emit('playbackend', new NativeSoundEvent(this, track));
            this._tracks.splice(this.getTrackId(track), 1);
            return complete;
        });
    }
    _getTrackInstance(data) {
        const newTrack = new WebAudioInstance(data);
        newTrack.loop = this.loop;
        newTrack.volume = this.volume;
        newTrack.duration = this.duration;
        this._tracks.push(newTrack);
        return newTrack;
    }
}

;// CONCATENATED MODULE: ./Resources/Sound/Index.ts




;// CONCATENATED MODULE: ./Resources/Gif.ts
var Gif_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







/**
 * The [[Texture]] object allows games built in Excalibur to load image resources.
 * [[Texture]] is an [[Loadable]] which means it can be passed to a [[Loader]]
 * to pre-load before starting a level or game.
 */
class Gif {
    /**
     * @param path       Path to the image resource
     * @param color      Optionally set the color to treat as transparent the gif, by default [[Color.Magenta]]
     * @param bustCache  Optionally load texture with cache busting
     */
    constructor(path, color = Color.Magenta, bustCache = true) {
        this.path = path;
        this.color = color;
        this.bustCache = bustCache;
        this._stream = null;
        this._gif = null;
        this._textures = [];
        this._animation = null;
        this._transparentColor = null;
        this._resource = new Resource(path, 'arraybuffer', bustCache);
        this._transparentColor = color;
    }
    /**
     * Begins loading the texture and returns a promise to be resolved on completion
     */
    load() {
        return Gif_awaiter(this, void 0, void 0, function* () {
            const arraybuffer = yield this._resource.load();
            this._stream = new Stream(arraybuffer);
            this._gif = new ParseGif(this._stream, this._transparentColor);
            const images = this._gif.images.map(i => new ImageSource(i.src, false));
            // Load all textures
            yield Promise.all(images.map(t => t.load()));
            return this.data = this._textures = images;
        });
    }
    isLoaded() {
        return !!this.data;
    }
    /**
     * Return a frame of the gif as a legacy sprite by index
     * @deprecated
     */
    toLegacySprite(id = 0) {
        return Sprite.toLegacySprite(this.toSprite(id));
    }
    /**
     * Return the gif as a legacy spritesheet
     * @deprecated
     * @returns
     */
    toLegacySpriteSheet() {
        return SpriteSheet.toLegacySpriteSheet(this.toSpriteSheet());
    }
    /**
     * Return the gif as a legacy animation
     * @deprecated
     * @param speed
     */
    toLegacyAnimation(engine, speed) {
        return Animation.toLegacyAnimation(engine, this.toAnimation(speed));
    }
    /**
     * Return a frame of the gif as a sprite by id
     * @param id
     */
    toSprite(id = 0) {
        const sprite = this._textures[id].toSprite();
        return sprite;
    }
    /**
     * Return the gif as a spritesheet
     */
    toSpriteSheet() {
        const sprites = this._textures.map((image) => {
            return image.toSprite();
        });
        return new SpriteSheet({ sprites });
    }
    /**
     * Transform the GIF into an animation with duration per frame
     */
    toAnimation(durationPerFrameMs) {
        const spriteSheet = this.toSpriteSheet();
        const length = spriteSheet.sprites.length;
        this._animation = Animation.fromSpriteSheet(spriteSheet, range(0, length), durationPerFrameMs);
        return this._animation;
    }
    get readCheckBytes() {
        return this._gif.checkBytes;
    }
}
const bitsToNum = (ba) => {
    return ba.reduce(function (s, n) {
        return s * 2 + n;
    }, 0);
};
const byteToBitArr = (bite) => {
    const a = [];
    for (let i = 7; i >= 0; i--) {
        a.push(!!(bite & (1 << i)));
    }
    return a;
};
class Stream {
    constructor(dataArray) {
        this.data = null;
        this.len = 0;
        this.position = 0;
        this.readByte = () => {
            if (this.position >= this.data.byteLength) {
                throw new Error('Attempted to read past end of stream.');
            }
            return this.data[this.position++];
        };
        this.readBytes = (n) => {
            const bytes = [];
            for (let i = 0; i < n; i++) {
                bytes.push(this.readByte());
            }
            return bytes;
        };
        this.read = (n) => {
            let s = '';
            for (let i = 0; i < n; i++) {
                s += String.fromCharCode(this.readByte());
            }
            return s;
        };
        this.readUnsigned = () => {
            // Little-endian.
            const a = this.readBytes(2);
            return (a[1] << 8) + a[0];
        };
        this.data = new Uint8Array(dataArray);
        this.len = this.data.byteLength;
        if (this.len === 0) {
            throw new Error('No data loaded from file');
        }
    }
}
const lzwDecode = function (minCodeSize, data) {
    // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?
    let pos = 0; // Maybe this streaming thing should be merged with the Stream?
    const readCode = function (size) {
        let code = 0;
        for (let i = 0; i < size; i++) {
            if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {
                code |= 1 << i;
            }
            pos++;
        }
        return code;
    };
    const output = [];
    const clearCode = 1 << minCodeSize;
    const eoiCode = clearCode + 1;
    let codeSize = minCodeSize + 1;
    let dict = [];
    const clear = function () {
        dict = [];
        codeSize = minCodeSize + 1;
        for (let i = 0; i < clearCode; i++) {
            dict[i] = [i];
        }
        dict[clearCode] = [];
        dict[eoiCode] = null;
    };
    let code;
    let last;
    while (true) {
        last = code;
        code = readCode(codeSize);
        if (code === clearCode) {
            clear();
            continue;
        }
        if (code === eoiCode) {
            break;
        }
        if (code < dict.length) {
            if (last !== clearCode) {
                dict.push(dict[last].concat(dict[code][0]));
            }
        }
        else {
            if (code !== dict.length) {
                throw new Error('Invalid LZW code.');
            }
            dict.push(dict[last].concat(dict[last][0]));
        }
        output.push.apply(output, dict[code]);
        if (dict.length === 1 << codeSize && codeSize < 12) {
            // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.
            codeSize++;
        }
    }
    // I don't know if this is technically an error, but some GIFs do it.
    //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');
    return output;
};
// The actual parsing; returns an object with properties.
class ParseGif {
    constructor(stream, color = Color.Magenta) {
        this._st = null;
        this._handler = {};
        this._transparentColor = null;
        this.frames = [];
        this.images = [];
        this.globalColorTable = [];
        this.checkBytes = [];
        // LZW (GIF-specific)
        this.parseColorTable = (entries) => {
            // Each entry is 3 bytes, for RGB.
            const ct = [];
            for (let i = 0; i < entries; i++) {
                const rgb = this._st.readBytes(3);
                const rgba = '#' +
                    rgb
                        .map((x) => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    })
                        .join('');
                ct.push(rgba);
            }
            return ct;
        };
        this.readSubBlocks = () => {
            let size, data;
            data = '';
            do {
                size = this._st.readByte();
                data += this._st.read(size);
            } while (size !== 0);
            return data;
        };
        this.parseHeader = () => {
            const hdr = {
                sig: null,
                ver: null,
                width: null,
                height: null,
                colorRes: null,
                globalColorTableSize: null,
                gctFlag: null,
                sorted: null,
                globalColorTable: [],
                bgColor: null,
                pixelAspectRatio: null // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            };
            hdr.sig = this._st.read(3);
            hdr.ver = this._st.read(3);
            if (hdr.sig !== 'GIF') {
                throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.
            }
            hdr.width = this._st.readUnsigned();
            hdr.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            hdr.gctFlag = bits.shift();
            hdr.colorRes = bitsToNum(bits.splice(0, 3));
            hdr.sorted = bits.shift();
            hdr.globalColorTableSize = bitsToNum(bits.splice(0, 3));
            hdr.bgColor = this._st.readByte();
            hdr.pixelAspectRatio = this._st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64
            if (hdr.gctFlag) {
                hdr.globalColorTable = this.parseColorTable(1 << (hdr.globalColorTableSize + 1));
                this.globalColorTable = hdr.globalColorTable;
            }
            if (this._handler.hdr && this._handler.hdr(hdr)) {
                this.checkBytes.push(this._handler.hdr);
            }
        };
        this.parseExt = (block) => {
            const parseGCExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 4
                const bits = byteToBitArr(this._st.readByte());
                block.reserved = bits.splice(0, 3); // Reserved; should be 000.
                block.disposalMethod = bitsToNum(bits.splice(0, 3));
                block.userInput = bits.shift();
                block.transparencyGiven = bits.shift();
                block.delayTime = this._st.readUnsigned();
                block.transparencyIndex = this._st.readByte();
                block.terminator = this._st.readByte();
                if (this._handler.gce && this._handler.gce(block)) {
                    this.checkBytes.push(this._handler.gce);
                }
            };
            const parseComExt = (block) => {
                block.comment = this.readSubBlocks();
                if (this._handler.com && this._handler.com(block)) {
                    this.checkBytes.push(this._handler.com);
                }
            };
            const parsePTExt = (block) => {
                this.checkBytes.push(this._st.readByte()); // Always 12
                block.ptHeader = this._st.readBytes(12);
                block.ptData = this.readSubBlocks();
                if (this._handler.pte && this._handler.pte(block)) {
                    this.checkBytes.push(this._handler.pte);
                }
            };
            const parseAppExt = (block) => {
                const parseNetscapeExt = (block) => {
                    this.checkBytes.push(this._st.readByte()); // Always 3
                    block.unknown = this._st.readByte(); // Q: Always 1? What is this?
                    block.iterations = this._st.readUnsigned();
                    block.terminator = this._st.readByte();
                    if (this._handler.app && this._handler.app.NETSCAPE && this._handler.app.NETSCAPE(block)) {
                        this.checkBytes.push(this._handler.app);
                    }
                };
                const parseUnknownAppExt = (block) => {
                    block.appData = this.readSubBlocks();
                    // FIXME: This won't work if a handler wants to match on any identifier.
                    if (this._handler.app && this._handler.app[block.identifier] && this._handler.app[block.identifier](block)) {
                        this.checkBytes.push(this._handler.app[block.identifier]);
                    }
                };
                this.checkBytes.push(this._st.readByte()); // Always 11
                block.identifier = this._st.read(8);
                block.authCode = this._st.read(3);
                switch (block.identifier) {
                    case 'NETSCAPE':
                        parseNetscapeExt(block);
                        break;
                    default:
                        parseUnknownAppExt(block);
                        break;
                }
            };
            const parseUnknownExt = (block) => {
                block.data = this.readSubBlocks();
                if (this._handler.unknown && this._handler.unknown(block)) {
                    this.checkBytes.push(this._handler.unknown);
                }
            };
            block.label = this._st.readByte();
            switch (block.label) {
                case 0xf9:
                    block.extType = 'gce';
                    parseGCExt(block);
                    break;
                case 0xfe:
                    block.extType = 'com';
                    parseComExt(block);
                    break;
                case 0x01:
                    block.extType = 'pte';
                    parsePTExt(block);
                    break;
                case 0xff:
                    block.extType = 'app';
                    parseAppExt(block);
                    break;
                default:
                    block.extType = 'unknown';
                    parseUnknownExt(block);
                    break;
            }
        };
        this.parseImg = (img) => {
            const deinterlace = (pixels, width) => {
                // Of course this defeats the purpose of interlacing. And it's *probably*
                // the least efficient way it's ever been implemented. But nevertheless...
                const newPixels = new Array(pixels.length);
                const rows = pixels.length / width;
                const cpRow = (toRow, fromRow) => {
                    const fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
                    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
                };
                const offsets = [0, 4, 2, 1];
                const steps = [8, 8, 4, 2];
                let fromRow = 0;
                for (let pass = 0; pass < 4; pass++) {
                    for (let toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
                        cpRow(toRow, fromRow);
                        fromRow++;
                    }
                }
                return newPixels;
            };
            img.leftPos = this._st.readUnsigned();
            img.topPos = this._st.readUnsigned();
            img.width = this._st.readUnsigned();
            img.height = this._st.readUnsigned();
            const bits = byteToBitArr(this._st.readByte());
            img.lctFlag = bits.shift();
            img.interlaced = bits.shift();
            img.sorted = bits.shift();
            img.reserved = bits.splice(0, 2);
            img.lctSize = bitsToNum(bits.splice(0, 3));
            if (img.lctFlag) {
                img.lct = this.parseColorTable(1 << (img.lctSize + 1));
            }
            img.lzwMinCodeSize = this._st.readByte();
            const lzwData = this.readSubBlocks();
            img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);
            if (img.interlaced) {
                // Move
                img.pixels = deinterlace(img.pixels, img.width);
            }
            this.frames.push(img);
            this.arrayToImage(img);
            if (this._handler.img && this._handler.img(img)) {
                this.checkBytes.push(this._handler);
            }
        };
        this.parseBlock = () => {
            const block = {
                sentinel: this._st.readByte(),
                type: ''
            };
            const blockChar = String.fromCharCode(block.sentinel);
            switch (blockChar) {
                case '!':
                    block.type = 'ext';
                    this.parseExt(block);
                    break;
                case ',':
                    block.type = 'img';
                    this.parseImg(block);
                    break;
                case ';':
                    block.type = 'eof';
                    if (this._handler.eof && this._handler.eof(block)) {
                        this.checkBytes.push(this._handler.eof);
                    }
                    break;
                default:
                    throw new Error('Unknown block: 0x' + block.sentinel.toString(16));
            }
            if (block.type !== 'eof') {
                this.parseBlock();
            }
        };
        this.arrayToImage = (frame) => {
            let count = 0;
            const c = document.createElement('canvas');
            c.id = count.toString();
            c.width = frame.width;
            c.height = frame.height;
            count++;
            const context = c.getContext('2d');
            const pixSize = 1;
            let y = 0;
            let x = 0;
            for (let i = 0; i < frame.pixels.length; i++) {
                if (x % frame.width === 0) {
                    y++;
                    x = 0;
                }
                if (this.globalColorTable[frame.pixels[i]] === this._transparentColor.toHex()) {
                    context.fillStyle = `rgba(0, 0, 0, 0)`;
                }
                else {
                    context.fillStyle = this.globalColorTable[frame.pixels[i]];
                }
                context.fillRect(x, y, pixSize, pixSize);
                x++;
            }
            const img = new Image();
            img.src = c.toDataURL();
            this.images.push(img);
        };
        this._st = stream;
        this._handler = {};
        this._transparentColor = color;
        this.parseHeader();
        this.parseBlock();
    }
}

;// CONCATENATED MODULE: ./Resources/Index.ts




;// CONCATENATED MODULE: ./EntityComponentSystem/index.ts











;// CONCATENATED MODULE: ./Graphics/Polygon.ts


/**
 * A polygon [[Graphic]] for drawing arbitrary polygons to the [[ExcaliburGraphicsContext]]
 */
class Polygon_Polygon extends Raster {
    constructor(options) {
        super(options);
        this.points = options.points;
        this.rasterize();
    }
    get points() {
        return this._points;
    }
    set points(points) {
        this._points = points;
        const min = this.minPoint;
        this.width = this._points.reduce((max, p) => Math.max(p.x, max), 0) - min.x;
        this.height = this._points.reduce((max, p) => Math.max(p.y, max), 0) - min.y;
        this.flagDirty();
    }
    get minPoint() {
        const minX = this._points.reduce((min, p) => Math.min(p.x, min), Infinity);
        const minY = this._points.reduce((min, p) => Math.min(p.y, min), Infinity);
        return vec(minX, minY);
    }
    clone() {
        return new Polygon_Polygon(Object.assign(Object.assign({ points: this.points.map((p) => p.clone()) }, this.cloneGraphicOptions()), this.cloneRasterOptions()));
    }
    execute(ctx) {
        if (this.points && this.points.length) {
            ctx.beginPath();
            // Iterate through the supplied points and construct a 'polygon'
            const min = this.minPoint.negate();
            const firstPoint = this.points[0].add(min);
            ctx.moveTo(firstPoint.x, firstPoint.y);
            this.points.forEach((point) => {
                ctx.lineTo(point.x + min.x, point.y + min.y);
            });
            ctx.lineTo(firstPoint.x, firstPoint.y);
            ctx.closePath();
            if (this.color) {
                ctx.fill();
            }
            if (this.strokeColor) {
                ctx.stroke();
            }
        }
    }
}

;// CONCATENATED MODULE: ./Graphics/index.ts
// Graphics






// Graphics ECS


// Raster graphics














;// CONCATENATED MODULE: ./Input/Index.ts
/**
 * @module
 * Provides support for mice, keyboards, and controllers.
 */
/**
 * @typedoc
 */








;// CONCATENATED MODULE: ./Traits/Index.ts
/**
 * @module
 */



;// CONCATENATED MODULE: ./Util/Index.ts







;// CONCATENATED MODULE: ./Util/SortedList.ts
var SortedList_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

/**
 * A sorted list implementation. NOTE: this implementation is not self-balancing
 * @deprecated WIll be removed in v0.26.0 Use built in JS array.sort
 */
let SortedList = class SortedList {
    constructor(getComparable) {
        this._getComparable = getComparable;
    }
    find(element) {
        return this._find(this._root, element);
    }
    _find(node, element) {
        if (node == null) {
            return false;
        }
        else if (this._getComparable(element) === node.getKey()) {
            if (node.getData().indexOf(element) > -1) {
                return true;
            }
            else {
                return false;
            }
        }
        else if (this._getComparable(element) < node.getKey()) {
            return this._find(node.getLeft(), element);
        }
        else {
            return this._find(node.getRight(), element);
        }
    }
    // returns the array of elements at a specific key value
    get(key) {
        return this._get(this._root, key);
    }
    _get(node, key) {
        if (node == null) {
            return [];
        }
        else if (key === node.getKey()) {
            return node.getData();
        }
        else if (key < node.getKey()) {
            return this._get(node.getLeft(), key);
        }
        else {
            return this._get(node.getRight(), key);
        }
    }
    add(element) {
        if (this._root == null) {
            this._root = new BinaryTreeNode(this._getComparable(element), [element], null, null);
            return true;
        }
        else {
            return this._insert(this._root, element);
        }
    }
    _insert(node, element) {
        if (node != null) {
            if (this._getComparable(element) === node.getKey()) {
                if (node.getData().indexOf(element) > -1) {
                    return false; // the element we're trying to insert already exists
                }
                else {
                    node.getData().push(element);
                    return true;
                }
            }
            else if (this._getComparable(element) < node.getKey()) {
                if (node.getLeft() == null) {
                    node.setLeft(new BinaryTreeNode(this._getComparable(element), [element], null, null));
                    return true;
                }
                else {
                    return this._insert(node.getLeft(), element);
                }
            }
            else {
                if (node.getRight() == null) {
                    node.setRight(new BinaryTreeNode(this._getComparable(element), [element], null, null));
                    return true;
                }
                else {
                    return this._insert(node.getRight(), element);
                }
            }
        }
        return false;
    }
    removeByComparable(element) {
        this._root = this._remove(this._root, element);
    }
    _remove(node, element) {
        if (node == null) {
            return null;
        }
        else if (this._getComparable(element) === node.getKey()) {
            const elementIndex = node.getData().indexOf(element);
            // if the node contains the element, remove the element
            if (elementIndex > -1) {
                node.getData().splice(elementIndex, 1);
                // if we have removed the last element at this node, remove the node
                if (node.getData().length === 0) {
                    // if the node is a leaf
                    if (node.getLeft() == null && node.getRight() == null) {
                        return null;
                    }
                    else if (node.getLeft() == null) {
                        return node.getRight();
                    }
                    else if (node.getRight() == null) {
                        return node.getLeft();
                    }
                    // if node has 2 children
                    const temp = this._findMinNode(node.getRight());
                    node.setKey(temp.getKey());
                    node.setData(temp.getData());
                    node.setRight(this._cleanup(node.getRight(), temp)); //"cleanup nodes" (move them up recursively)
                    return node;
                }
                else {
                    // this prevents the node from being removed since it still contains elements
                    return node;
                }
            }
        }
        else if (this._getComparable(element) < node.getKey()) {
            node.setLeft(this._remove(node.getLeft(), element));
            return node;
        }
        else {
            node.setRight(this._remove(node.getRight(), element));
            return node;
        }
        return null;
    }
    // called once we have successfully removed the element we wanted, recursively corrects the part of the tree below the removed node
    _cleanup(node, element) {
        const comparable = element.getKey();
        if (node == null) {
            return null;
        }
        else if (comparable === node.getKey()) {
            // if the node is a leaf
            if (node.getLeft() == null && node.getRight() == null) {
                return null;
            }
            else if (node.getLeft() == null) {
                return node.getRight();
            }
            else if (node.getRight() == null) {
                return node.getLeft();
            }
            // if node has 2 children
            const temp = this._findMinNode(node.getRight());
            node.setKey(temp.getKey());
            node.setData(temp.getData());
            node.setRight(this._cleanup(node.getRight(), temp));
            return node;
        }
        else if (element.getKey() < node.getKey()) {
            node.setLeft(this._cleanup(node.getLeft(), element));
            return node;
        }
        else {
            node.setRight(this._cleanup(node.getRight(), element));
            return node;
        }
    }
    _findMinNode(node) {
        let current = node;
        while (current.getLeft() != null) {
            current = current.getLeft();
        }
        return current;
    }
    list() {
        const results = new Array();
        this._list(this._root, results);
        return results;
    }
    _list(treeNode, results) {
        if (treeNode != null) {
            this._list(treeNode.getLeft(), results);
            treeNode.getData().forEach((element) => {
                results.push(element);
            });
            this._list(treeNode.getRight(), results);
        }
    }
};
SortedList = SortedList_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0', alternateMethod: 'Use built in JS array.sort' })
], SortedList);

/**
 * A tree node part of [[SortedList]]
 * @deprecated Will be removed in v0.26.0
 */
let BinaryTreeNode = class BinaryTreeNode {
    constructor(key, data, left, right) {
        this._key = key;
        this._data = data;
        this._left = left;
        this._right = right;
    }
    getKey() {
        return this._key;
    }
    setKey(key) {
        this._key = key;
    }
    getData() {
        return this._data;
    }
    setData(data) {
        this._data = data;
    }
    getLeft() {
        return this._left;
    }
    setLeft(left) {
        this._left = left;
    }
    getRight() {
        return this._right;
    }
    setRight(right) {
        this._right = right;
    }
};
BinaryTreeNode = SortedList_decorate([
    obsolete({ message: 'Will be removed in excalibur v0.26.0' })
], BinaryTreeNode);

/**
 * Mock element for testing
 *
 * @internal
 * @deprecated Will be removed in v0.26.0
 */
class MockedElement {
    constructor(key) {
        this._key = 0;
        this._key = key;
    }
    getTheKey() {
        return this._key;
    }
    setKey(key) {
        this._key = key;
    }
}

;// CONCATENATED MODULE: ./Promises.ts
// Promises/A+ Spec http://promises-aplus.github.io/promises-spec/
var Promises_decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var Promise_1;

/**
 * Valid states for a promise to be in
 * @deprecated Will be removed in v0.26.0
 */
var PromiseState;
(function (PromiseState) {
    PromiseState[PromiseState["Resolved"] = 0] = "Resolved";
    PromiseState[PromiseState["Rejected"] = 1] = "Rejected";
    PromiseState[PromiseState["Pending"] = 2] = "Pending";
})(PromiseState || (PromiseState = {}));
/**
 * Promises are used to do asynchronous work and they are useful for
 * creating a chain of actions. In Excalibur they are used for loading,
 * sounds, animation, actions, and more.
 * @deprecated Will be removed in v0.26.0
 */
let Promises_Promise = Promise_1 = class Promise {
    constructor() {
        this._state = PromiseState.Pending;
        this._successCallbacks = [];
        this._rejectCallback = () => {
            return;
        };
    }
    /**
     * Create and resolve a Promise with an optional value
     * @param value  An optional value to wrap in a resolved promise
     * @deprecated Use browser native promises
     */
    static resolve(value) {
        const promise = new Promise_1().resolve(value);
        return promise;
    }
    /**
     * Create and reject a Promise with an optional value
     * @param value  An optional value to wrap in a rejected promise
     * @deprecated Use browser native promises
     */
    static reject(value) {
        const promise = new Promise_1().reject(value);
        return promise;
    }
    static join() {
        let promises = [];
        if (arguments.length > 0 && !Array.isArray(arguments[0])) {
            for (let _i = 0; _i < arguments.length; _i++) {
                promises[_i - 0] = arguments[_i];
            }
        }
        else if (arguments.length === 1 && Array.isArray(arguments[0])) {
            promises = arguments[0];
        }
        const joinedPromise = new Promise_1();
        if (!promises || !promises.length) {
            return joinedPromise.resolve();
        }
        const total = promises.length;
        let successes = 0;
        let rejects = 0;
        const errors = [];
        promises.forEach((p) => {
            p.then(() => {
                successes += 1;
                if (successes === total) {
                    joinedPromise.resolve();
                }
                else if (successes + rejects + errors.length === total) {
                    joinedPromise.reject(errors);
                }
            }, () => {
                rejects += 1;
                if (successes + rejects + errors.length === total) {
                    joinedPromise.reject(errors);
                }
            }).error((e) => {
                errors.push(e);
                if (errors.length + successes + rejects === total) {
                    joinedPromise.reject(errors);
                }
            });
        });
        return joinedPromise;
    }
    /**
     * Chain success and reject callbacks after the promise is resolved
     * @param successCallback  Call on resolution of promise
     * @param rejectCallback   Call on rejection of promise
     * @deprecated Use browser native promises
     */
    then(successCallback, rejectCallback) {
        if (successCallback) {
            this._successCallbacks.push(successCallback);
            // If the promise is already resolved call immediately
            if (this.state() === PromiseState.Resolved) {
                try {
                    successCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
        }
        if (rejectCallback) {
            this._rejectCallback = rejectCallback;
            // If the promise is already rejected call immediately
            if (this.state() === PromiseState.Rejected) {
                try {
                    rejectCallback.call(this, this._value);
                }
                catch (e) {
                    this._handleError(e);
                }
            }
        }
        return this;
    }
    /**
     * Add an error callback to the promise
     * @param errorCallback  Call if there was an error in a callback
     * @deprecated Use browser native promises
     */
    error(errorCallback) {
        if (errorCallback) {
            this._errorCallback = errorCallback;
        }
        return this;
    }
    /**
     * Resolve the promise and pass an option value to the success callbacks
     * @param value  Value to pass to the success callbacks
     * @deprecated Use browser native promises
     */
    resolve(value) {
        if (this._state === PromiseState.Pending) {
            this._value = value;
            try {
                this._state = PromiseState.Resolved;
                this._successCallbacks.forEach((cb) => {
                    cb.call(this, this._value);
                });
            }
            catch (e) {
                this._handleError(e);
            }
        }
        else {
            throw new Error('Cannot resolve a promise that is not in a pending state!');
        }
        return this;
    }
    /**
     * Reject the promise and pass an option value to the reject callbacks
     * @param value  Value to pass to the reject callbacks
     * @deprecated Use browser native promises
     */
    reject(value) {
        if (this._state === PromiseState.Pending) {
            this._value = value;
            try {
                this._state = PromiseState.Rejected;
                this._rejectCallback.call(this, this._value);
            }
            catch (e) {
                this._handleError(e);
            }
        }
        else {
            throw new Error('Cannot reject a promise that is not in a pending state!');
        }
        return this;
    }
    /**
     * Inspect the current state of a promise
     * @deprecated Use browser native promises
     */
    state() {
        return this._state;
    }
    _handleError(e) {
        if (this._errorCallback) {
            this._errorCallback.call(this, e);
        }
        else {
            // rethrow error
            throw e;
        }
    }
};
Promises_Promise = Promise_1 = Promises_decorate([
    obsolete({
        message: 'ex.Promises are being replaced by native browser promises in v0.26.0',
        alternateMethod: 'Use browser native promises'
    })
], Promises_Promise);


;// CONCATENATED MODULE: ./index.ts
/**
 * The current Excalibur version string
 * @description `process.env.__EX_VERSION` gets replaced by Webpack on build
 */
const EX_VERSION = "0.25.1";

polyfill();
// This file is used as the bundle entry point and exports everything
// that will be exposed as the `ex` global variable.

























// ex.LegacyDrawing namespace








// ex.Events namespace


// ex.Input namespace


// ex.Traits namespace


// ex.Util namespaces












// ex.Deprecated

// import * as deprecated from './Deprecated';
// export { deprecated as Deprecated };
// export * from './Deprecated';

})();

var __webpack_exports__ActionContext = __webpack_exports__.fWn;
var __webpack_exports__ActionQueue = __webpack_exports__.Ia8;
var __webpack_exports__ActionsComponent = __webpack_exports__.hLI;
var __webpack_exports__ActionsSystem = __webpack_exports__.yyv;
var __webpack_exports__ActivateEvent = __webpack_exports__.tX5;
var __webpack_exports__Actor = __webpack_exports__.vtX;
var __webpack_exports__AddedComponent = __webpack_exports__.r7K;
var __webpack_exports__AddedEntity = __webpack_exports__.lCh;
var __webpack_exports__Animation = __webpack_exports__.fwF;
var __webpack_exports__AnimationDirection = __webpack_exports__.sce;
var __webpack_exports__AnimationStrategy = __webpack_exports__._c7;
var __webpack_exports__ArcadeSolver = __webpack_exports__.KUs;
var __webpack_exports__AudioContextFactory = __webpack_exports__.Ajp;
var __webpack_exports__Axis = __webpack_exports__.RDh;
var __webpack_exports__BaseAlign = __webpack_exports__._H9;
var __webpack_exports__BinaryTreeNode = __webpack_exports__.Ulf;
var __webpack_exports__Blink = __webpack_exports__.mxs;
var __webpack_exports__BodyComponent = __webpack_exports__.OmD;
var __webpack_exports__BoundingBox = __webpack_exports__.kBf;
var __webpack_exports__BroadphaseStrategy = __webpack_exports__.C4F;
var __webpack_exports__BrowserComponent = __webpack_exports__.NQt;
var __webpack_exports__BrowserEvents = __webpack_exports__.JjN;
var __webpack_exports__Camera = __webpack_exports__.V1s;
var __webpack_exports__Canvas = __webpack_exports__.Xz7;
var __webpack_exports__Cell = __webpack_exports__.bLd;
var __webpack_exports__Circle = __webpack_exports__.Cdc;
var __webpack_exports__CircleCollider = __webpack_exports__.FKn;
var __webpack_exports__Class = __webpack_exports__.wTW;
var __webpack_exports__ClosestLine = __webpack_exports__.ab2;
var __webpack_exports__ClosestLineJumpTable = __webpack_exports__.GfZ;
var __webpack_exports__Collider = __webpack_exports__.YMS;
var __webpack_exports__ColliderComponent = __webpack_exports__.oyv;
var __webpack_exports__CollisionContact = __webpack_exports__.aUb;
var __webpack_exports__CollisionEndEvent = __webpack_exports__.SdD;
var __webpack_exports__CollisionGroup = __webpack_exports__.JUv;
var __webpack_exports__CollisionGroupManager = __webpack_exports__.jEj;
var __webpack_exports__CollisionJumpTable = __webpack_exports__.TFq;
var __webpack_exports__CollisionPostSolveEvent = __webpack_exports__.HDU;
var __webpack_exports__CollisionPreSolveEvent = __webpack_exports__.R_y;
var __webpack_exports__CollisionResolutionStrategy = __webpack_exports__.ydN;
var __webpack_exports__CollisionSolver = __webpack_exports__._N2;
var __webpack_exports__CollisionStartEvent = __webpack_exports__.t50;
var __webpack_exports__CollisionSystem = __webpack_exports__.s$$;
var __webpack_exports__CollisionType = __webpack_exports__.v2G;
var __webpack_exports__Color = __webpack_exports__.Ilk;
var __webpack_exports__ColorBlindCorrector = __webpack_exports__.H_9;
var __webpack_exports__ColorBlindFlags = __webpack_exports__.s9i;
var __webpack_exports__ColorBlindness = __webpack_exports__.ksl;
var __webpack_exports__Component = __webpack_exports__.wA2;
var __webpack_exports__CompositeCollider = __webpack_exports__.R_p;
var __webpack_exports__Configurable = __webpack_exports__.IQ$;
var __webpack_exports__ConsoleAppender = __webpack_exports__.I5F;
var __webpack_exports__ContactConstraintPoint = __webpack_exports__.X8$;
var __webpack_exports__ContactEndEvent = __webpack_exports__.FR6;
var __webpack_exports__ContactStartEvent = __webpack_exports__.U8o;
var __webpack_exports__CoordPlane = __webpack_exports__.kbG;
var __webpack_exports__CullingBox = __webpack_exports__.oeJ;
var __webpack_exports__DeactivateEvent = __webpack_exports__.iS_;
var __webpack_exports__Debug = __webpack_exports__.cGG;
var __webpack_exports__DebugSystem = __webpack_exports__.skb;
var __webpack_exports__DebugText = __webpack_exports__.SLU;
var __webpack_exports__DegreeOfFreedom = __webpack_exports__.RdJ;
var __webpack_exports__Detector = __webpack_exports__.gU7;
var __webpack_exports__Die = __webpack_exports__.LSk;
var __webpack_exports__Direction = __webpack_exports__.Nmp;
var __webpack_exports__DisplayMode = __webpack_exports__.d1Y;
var __webpack_exports__DynamicTree = __webpack_exports__.xrL;
var __webpack_exports__DynamicTreeCollisionProcessor = __webpack_exports__.sRW;
var __webpack_exports__EX_VERSION = __webpack_exports__.cmV;
var __webpack_exports__EaseTo = __webpack_exports__.N0Q;
var __webpack_exports__EasingFunctions = __webpack_exports__.q8b;
var __webpack_exports__EdgeCollider = __webpack_exports__.ynB;
var __webpack_exports__ElasticToActorStrategy = __webpack_exports__.jT9;
var __webpack_exports__EmitterType = __webpack_exports__.wAz;
var __webpack_exports__Engine = __webpack_exports__.D4V;
var __webpack_exports__EnterTriggerEvent = __webpack_exports__.N6H;
var __webpack_exports__EnterViewPortEvent = __webpack_exports__.W1A;
var __webpack_exports__Entity = __webpack_exports__.JHW;
var __webpack_exports__EntityManager = __webpack_exports__.v2K;
var __webpack_exports__EventDispatcher = __webpack_exports__.pBf;
var __webpack_exports__EventTypes = __webpack_exports__.GMl;
var __webpack_exports__Events = __webpack_exports__.zW2;
var __webpack_exports__ExResponse = __webpack_exports__.B0K;
var __webpack_exports__ExcaliburGraphicsContext2DCanvas = __webpack_exports__.Nv7;
var __webpack_exports__ExcaliburGraphicsContextWebGL = __webpack_exports__.C_p;
var __webpack_exports__ExitTriggerEvent = __webpack_exports__.MUA;
var __webpack_exports__ExitViewPortEvent = __webpack_exports__.xqU;
var __webpack_exports__Experiments = __webpack_exports__.peG;
var __webpack_exports__Fade = __webpack_exports__.pTp;
var __webpack_exports__Flags = __webpack_exports__.vUK;
var __webpack_exports__Follow = __webpack_exports__.j9l;
var __webpack_exports__Font = __webpack_exports__.Zxw;
var __webpack_exports__FontStyle = __webpack_exports__.Hdx;
var __webpack_exports__FontUnit = __webpack_exports__.Z$d;
var __webpack_exports__FrameStats = __webpack_exports__.o$7;
var __webpack_exports__GameEvent = __webpack_exports__.Zm$;
var __webpack_exports__GameStartEvent = __webpack_exports__.$QH;
var __webpack_exports__GameStopEvent = __webpack_exports__.i78;
var __webpack_exports__GamepadAxisEvent = __webpack_exports__.h6u;
var __webpack_exports__GamepadButtonEvent = __webpack_exports__.hts;
var __webpack_exports__GamepadConnectEvent = __webpack_exports__.j88;
var __webpack_exports__GamepadDisconnectEvent = __webpack_exports__.VME;
var __webpack_exports__Gif = __webpack_exports__.nt;
var __webpack_exports__GlobalCoordinates = __webpack_exports__.Ukr;
var __webpack_exports__Graphic = __webpack_exports__.zsu;
var __webpack_exports__GraphicsComponent = __webpack_exports__.oA6;
var __webpack_exports__GraphicsGroup = __webpack_exports__.TVh;
var __webpack_exports__GraphicsLayer = __webpack_exports__.TwZ;
var __webpack_exports__GraphicsLayers = __webpack_exports__.GTT;
var __webpack_exports__GraphicsSystem = __webpack_exports__.xxj;
var __webpack_exports__HiddenEvent = __webpack_exports__.XdK;
var __webpack_exports__ImageSource = __webpack_exports__.cXo;
var __webpack_exports__InitializeEvent = __webpack_exports__.Dm5;
var __webpack_exports__Input = __webpack_exports__.IIB;
var __webpack_exports__Integrator = __webpack_exports__.zI0;
var __webpack_exports__KillEvent = __webpack_exports__.SKZ;
var __webpack_exports__Label = __webpack_exports__.__J;
var __webpack_exports__Legacy = __webpack_exports__.Dvr;
var __webpack_exports__LegacyDrawing = __webpack_exports__.Tf9;
var __webpack_exports__LimitCameraBoundsStrategy = __webpack_exports__.RI$;
var __webpack_exports__Line = __webpack_exports__.x12;
var __webpack_exports__Loader = __webpack_exports__.aNw;
var __webpack_exports__LockCameraToActorAxisStrategy = __webpack_exports__.xwn;
var __webpack_exports__LockCameraToActorStrategy = __webpack_exports__.dNK;
var __webpack_exports__LogLevel = __webpack_exports__.ini;
var __webpack_exports__Logger = __webpack_exports__.YdH;
var __webpack_exports__Matrix = __webpack_exports__.y3G;
var __webpack_exports__MatrixLocations = __webpack_exports__.l57;
var __webpack_exports__MediaEvent = __webpack_exports__.xn0;
var __webpack_exports__Meet = __webpack_exports__.t2V;
var __webpack_exports__MockedElement = __webpack_exports__.ZyS;
var __webpack_exports__MotionComponent = __webpack_exports__.uxB;
var __webpack_exports__MotionSystem = __webpack_exports__.cpd;
var __webpack_exports__MoveBy = __webpack_exports__.fiy;
var __webpack_exports__MoveTo = __webpack_exports__.$XZ;
var __webpack_exports__NativeSoundEvent = __webpack_exports__.uqK;
var __webpack_exports__NativeSoundProcessedEvent = __webpack_exports__.STE;
var __webpack_exports__Observable = __webpack_exports__.y$z;
var __webpack_exports__Pair = __webpack_exports__.sOq;
var __webpack_exports__ParseGif = __webpack_exports__.Sqs;
var __webpack_exports__Particle = __webpack_exports__.hpZ;
var __webpack_exports__ParticleEmitter = __webpack_exports__.Vol;
var __webpack_exports__Physics = __webpack_exports__.wIZ;
var __webpack_exports__PhysicsStats = __webpack_exports__.cBi;
var __webpack_exports__Polygon = __webpack_exports__.mgq;
var __webpack_exports__PolygonCollider = __webpack_exports__.YVA;
var __webpack_exports__Pool = __webpack_exports__.Kgp;
var __webpack_exports__PostCollisionEvent = __webpack_exports__.HH$;
var __webpack_exports__PostDebugDrawEvent = __webpack_exports__.M_d;
var __webpack_exports__PostDrawEvent = __webpack_exports__.rgh;
var __webpack_exports__PostFrameEvent = __webpack_exports__.Ra6;
var __webpack_exports__PostKillEvent = __webpack_exports__.KhR;
var __webpack_exports__PostUpdateEvent = __webpack_exports__.BS5;
var __webpack_exports__PreCollisionEvent = __webpack_exports__.xhz;
var __webpack_exports__PreDebugDrawEvent = __webpack_exports__.xOq;
var __webpack_exports__PreDrawEvent = __webpack_exports__.a9j;
var __webpack_exports__PreFrameEvent = __webpack_exports__.bHk;
var __webpack_exports__PreKillEvent = __webpack_exports__.CgK;
var __webpack_exports__PreUpdateEvent = __webpack_exports__.cuY;
var __webpack_exports__Projection = __webpack_exports__.kvE;
var __webpack_exports__Promise = __webpack_exports__.JDb;
var __webpack_exports__PromiseState = __webpack_exports__.Cbi;
var __webpack_exports__Query = __webpack_exports__.AE_;
var __webpack_exports__QueryManager = __webpack_exports__.ctO;
var __webpack_exports__RadiusAroundActorStrategy = __webpack_exports__.OLH;
var __webpack_exports__Random = __webpack_exports__.kky;
var __webpack_exports__Raster = __webpack_exports__.nSF;
var __webpack_exports__Ray = __webpack_exports__.zHn;
var __webpack_exports__RealisticSolver = __webpack_exports__.zwx;
var __webpack_exports__Rectangle = __webpack_exports__.AeJ;
var __webpack_exports__RemovedComponent = __webpack_exports__.hLz;
var __webpack_exports__RemovedEntity = __webpack_exports__.D9g;
var __webpack_exports__Repeat = __webpack_exports__.wA;
var __webpack_exports__RepeatForever = __webpack_exports__.jhr;
var __webpack_exports__Resolution = __webpack_exports__.GVs;
var __webpack_exports__Resource = __webpack_exports__._zO;
var __webpack_exports__RotateBy = __webpack_exports__.w6$;
var __webpack_exports__RotateTo = __webpack_exports__.mhV;
var __webpack_exports__RotationType = __webpack_exports__.MOD;
var __webpack_exports__ScaleBy = __webpack_exports__.kwd;
var __webpack_exports__ScaleTo = __webpack_exports__.Lmr;
var __webpack_exports__Scene = __webpack_exports__.xsS;
var __webpack_exports__Screen = __webpack_exports__.lLr;
var __webpack_exports__ScreenAppender = __webpack_exports__.Z$r;
var __webpack_exports__ScreenElement = __webpack_exports__.IXb;
var __webpack_exports__ScrollPreventionMode = __webpack_exports__.SMj;
var __webpack_exports__Shape = __webpack_exports__.bnF;
var __webpack_exports__Side = __webpack_exports__.MFA;
var __webpack_exports__SortedList = __webpack_exports__.$XC;
var __webpack_exports__Sound = __webpack_exports__.$uU;
var __webpack_exports__Sprite = __webpack_exports__.jyi;
var __webpack_exports__SpriteFont = __webpack_exports__.E03;
var __webpack_exports__SpriteSheet = __webpack_exports__.V6q;
var __webpack_exports__StrategyContainer = __webpack_exports__.nVo;
var __webpack_exports__Stream = __webpack_exports__.F6N;
var __webpack_exports__SubscribeEvent = __webpack_exports__.ad3;
var __webpack_exports__System = __webpack_exports__.xP7;
var __webpack_exports__SystemManager = __webpack_exports__.Odq;
var __webpack_exports__SystemType = __webpack_exports__.Zif;
var __webpack_exports__TagComponent = __webpack_exports__.ZGJ;
var __webpack_exports__Text = __webpack_exports__.xvT;
var __webpack_exports__TextAlign = __webpack_exports__.PHM;
var __webpack_exports__TileMap = __webpack_exports__.KwO;
var __webpack_exports__Timer = __webpack_exports__.B7y;
var __webpack_exports__Traits = __webpack_exports__.SFp;
var __webpack_exports__TransformComponent = __webpack_exports__.Uvn;
var __webpack_exports__TreeNode = __webpack_exports__.OFT;
var __webpack_exports__Trigger = __webpack_exports__.xzN;
var __webpack_exports__UnsubscribeEvent = __webpack_exports__.H6j;
var __webpack_exports__Util = __webpack_exports__.ZrN;
var __webpack_exports__Vector = __webpack_exports__.OWs;
var __webpack_exports__VectorView = __webpack_exports__.dF9;
var __webpack_exports__VisibleEvent = __webpack_exports__.VHo;
var __webpack_exports__WebAudioInstance = __webpack_exports__.R$E;
var __webpack_exports__World = __webpack_exports__.q3I;
var __webpack_exports__canonicalizeAngle = __webpack_exports__.Pab;
var __webpack_exports__clamp = __webpack_exports__.uZ5;
var __webpack_exports__createId = __webpack_exports__.McK;
var __webpack_exports__hasGraphicsTick = __webpack_exports__.k0b;
var __webpack_exports__hasOnInitialize = __webpack_exports__.hnT;
var __webpack_exports__hasOnPostUpdate = __webpack_exports__.RSJ;
var __webpack_exports__hasOnPreUpdate = __webpack_exports__.Mku;
var __webpack_exports__hasPostDraw = __webpack_exports__.h90;
var __webpack_exports__hasPreDraw = __webpack_exports__.rms;
var __webpack_exports__has_initialize = __webpack_exports__.ErP;
var __webpack_exports__has_postupdate = __webpack_exports__.aVg;
var __webpack_exports__has_preupdate = __webpack_exports__.lPc;
var __webpack_exports__isAddedComponent = __webpack_exports__.Z8E;
var __webpack_exports__isAddedSystemEntity = __webpack_exports__.NNA;
var __webpack_exports__isRemoveSystemEntity = __webpack_exports__.yFn;
var __webpack_exports__isRemovedComponent = __webpack_exports__.lNv;
var __webpack_exports__maxMessages = __webpack_exports__.MZQ;
var __webpack_exports__obsolete = __webpack_exports__.FUM;
var __webpack_exports__randomInRange = __webpack_exports__.vdf;
var __webpack_exports__randomIntInRange = __webpack_exports__.iaL;
var __webpack_exports__range = __webpack_exports__.w6H;
var __webpack_exports__resetObsoleteCounter = __webpack_exports__.Q4c;
var __webpack_exports__toDegrees = __webpack_exports__.Uxb;
var __webpack_exports__toRadians = __webpack_exports__.Yr5;
var __webpack_exports__vec = __webpack_exports__.Bhw;


//# sourceMappingURL=excalibur.js.map

/***/ }),

/***/ "./src/actors/player.ts":
/*!******************************!*\
  !*** ./src/actors/player.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Player)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.js");
/* harmony import */ var _resources__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resources */ "./src/resources.ts");


class Player extends excalibur__WEBPACK_IMPORTED_MODULE_1__.Actor {
    constructor() {
        super({ x: 64, y: 64, width: 64, height: 32 });
    }
    onInitialize(_engine) {
        this.graphics.use(_resources__WEBPACK_IMPORTED_MODULE_0__.SpriteSheets.player_idle.sprites[0]);
    }
    onPostUpdate(_engine, _delta) { }
}


/***/ }),

/***/ "./src/resources.ts":
/*!**************************!*\
  !*** ./src/resources.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loader": () => (/* binding */ loader),
/* harmony export */   "SpriteSheets": () => (/* binding */ SpriteSheets)
/* harmony export */ });
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.js");
/* harmony import */ var _assets_images_player_idle_png__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assets/images/player_idle.png */ "./assets/images/player_idle.png");


const Images = {
    playerIdle: new excalibur__WEBPACK_IMPORTED_MODULE_1__.ImageSource(_assets_images_player_idle_png__WEBPACK_IMPORTED_MODULE_0__),
};
const SpriteSheets = {
    player_idle: excalibur__WEBPACK_IMPORTED_MODULE_1__.SpriteSheet.fromImageSource({
        image: Images.playerIdle,
        grid: {
            columns: 1,
            rows: 1,
            spriteWidth: 64,
            spriteHeight: 32,
        },
    }),
};
const loader = new excalibur__WEBPACK_IMPORTED_MODULE_1__.Loader();
for (const image in Images) {
    loader.addResource(Images[image]);
}



/***/ }),

/***/ "./assets/images/player_idle.png":
/*!***************************************!*\
  !*** ./assets/images/player_idle.png ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "44939fa033dcd2f84299.png";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var excalibur__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! excalibur */ "./node_modules/excalibur/build/esm/excalibur.js");
/* harmony import */ var _actors_player__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./actors/player */ "./src/actors/player.ts");
/* harmony import */ var _resources__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resources */ "./src/resources.ts");



const game = new excalibur__WEBPACK_IMPORTED_MODULE_2__.Engine({
    width: 800,
    height: 600,
});
game.start(_resources__WEBPACK_IMPORTED_MODULE_1__.loader);
const player = new _actors_player__WEBPACK_IMPORTED_MODULE_0__["default"]();
game.add(player);

})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyw4QkFBbUI7O0FBRTdELDhCQUFtQjtBQUNuQixrQkFBa0IsOEJBQW1COztBQUVyQzs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyw4QkFBbUI7O0FBRTdELDhCQUFtQjtBQUNuQixXQUFXLDhCQUFtQjs7QUFFOUI7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsOEJBQW1COztBQUU3RCxpQkFBaUIsOEJBQW1CO0FBQ3BDLGtCQUFrQiw4QkFBbUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxlQUFlLCtCQUFtQjs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELHNCQUFzQiwrQkFBbUI7QUFDekMsZUFBZSwrQkFBbUI7QUFDbEMsc0JBQXNCLCtCQUFtQjs7QUFFekMsc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sV0FBVyxnQkFBZ0I7QUFDakM7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7O0FBRzdELFlBQVksK0JBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFELEdBQUc7QUFDSDs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0QsNEJBQTRCLCtCQUFtQjtBQUMvQyxpQkFBaUIsK0JBQW1CO0FBQ3BDLGlCQUFpQiwrQkFBbUI7QUFDcEMsc0JBQXNCLCtCQUFtQjs7QUFFekM7QUFDQTtBQUNBLGlEQUFpRCxtQkFBbUI7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxnQkFBZ0I7QUFDcEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELFVBQVUsK0JBQW1CO0FBQzdCLGNBQWMsK0JBQW1CO0FBQ2pDLHFDQUFxQywrQkFBbUI7QUFDeEQsMkJBQTJCLCtCQUFtQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0Qsa0JBQWtCLCtCQUFtQjtBQUNyQywyQkFBMkIsK0JBQW1CO0FBQzlDLCtCQUErQiwrQkFBbUI7O0FBRWxEO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELFlBQVksK0JBQW1COztBQUUvQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxtQkFBbUIsYUFBYTtBQUN4RSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0QsYUFBYSwrQkFBbUI7QUFDaEMsZUFBZSwrQkFBbUI7O0FBRWxDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxnQkFBZ0IsK0JBQW1COztBQUVuQzs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELFNBQVMsK0JBQW1COztBQUU1Qjs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQywrQkFBbUI7O0FBRTdELGlCQUFpQiwrQkFBbUI7O0FBRXBDOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0QsYUFBYSwrQkFBbUI7QUFDaEMsZ0JBQWdCLCtCQUFtQjs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLCtCQUFtQjs7QUFFN0QsZ0JBQWdCLCtCQUFtQjs7QUFFbkM7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxhQUFhLCtCQUFtQjtBQUNoQyxXQUFXLCtCQUFtQjs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsK0JBQW1COztBQUU3RCxhQUFhLCtCQUFtQjtBQUNoQywrQkFBK0IsK0JBQW1CO0FBQ2xELGtDQUFrQywrQkFBbUI7QUFDckQsZUFBZSwrQkFBbUI7QUFDbEMsZ0JBQWdCLCtCQUFtQjtBQUNuQyxnQ0FBZ0MsK0JBQW1CO0FBQ25ELGVBQWUsK0JBQW1COztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtREFBbUQ7QUFDbkQsSUFBSTtBQUNKLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxnQkFBZ0IsZ0NBQW1COztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGtCQUFrQixnQ0FBbUI7QUFDckMsVUFBVSxnQ0FBbUI7O0FBRTdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLGFBQWE7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGFBQWEsZ0NBQW1CO0FBQ2hDLGlCQUFpQixnQ0FBbUI7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxnQkFBZ0IsZ0NBQW1COztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdDQUFtQixrQkFBa0IsZ0NBQW1CO0FBQ3ZFO0FBQ0EsaUJBQWlCLGNBQWM7OztBQUcvQixPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsZUFBZSxnQ0FBbUI7O0FBRWxDLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxrQkFBa0IsZ0NBQW1CO0FBQ3JDLFlBQVksZ0NBQW1CO0FBQy9CLG9CQUFvQixnQ0FBbUI7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLEdBQUc7QUFDSCxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsWUFBWSxnQ0FBbUI7QUFDL0IsY0FBYyxnQ0FBbUI7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxFQUFFOzs7QUFHRixPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsaUJBQWlCLGdDQUFtQjtBQUNwQyxZQUFZLGdDQUFtQjs7QUFFL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0Qsc0JBQXNCLGdDQUFtQjtBQUN6QyxhQUFhLGdDQUFtQjtBQUNoQyxlQUFlLGdDQUFtQjtBQUNsQyxrQ0FBa0MsZ0NBQW1CO0FBQ3JELGdCQUFnQixnQ0FBbUI7QUFDbkMsYUFBYSxnQ0FBbUI7QUFDaEMsZ0JBQWdCLGdDQUFtQjtBQUNuQyxpQkFBaUIsZ0NBQW1COztBQUVwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUM7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELFlBQVksZ0NBQW1CO0FBQy9CLGlCQUFpQixnQ0FBbUI7O0FBRXBDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxpQkFBaUIsZ0NBQW1COztBQUVwQztBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGlCQUFpQixnQ0FBbUI7QUFDcEMsaUJBQWlCLGdDQUFtQjtBQUNwQyx3QkFBd0IsZ0NBQW1COztBQUUzQztBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdEO0FBQ0EsaUJBQWlCLGdDQUFtQjtBQUNwQyxZQUFZLGdDQUFtQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdELE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxhQUFhLGdDQUFtQjtBQUNoQyxpQkFBaUIsZ0NBQW1CO0FBQ3BDLG9CQUFvQixnQ0FBbUI7O0FBRXZDOztBQUVBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0Qsa0JBQWtCLGdDQUFtQjtBQUNyQyxxQkFBcUIsZ0NBQW1CO0FBQ3hDLGVBQWUsZ0NBQW1CO0FBQ2xDLG9CQUFvQixnQ0FBbUI7O0FBRXZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0Qsa0JBQWtCLGdDQUFtQjtBQUNyQyxpQ0FBaUMsZ0NBQW1CO0FBQ3BELCtCQUErQixnQ0FBbUI7QUFDbEQsc0JBQXNCLGdDQUFtQjtBQUN6QyxvQkFBb0IsZ0NBQW1CO0FBQ3ZDLFVBQVUsZ0NBQW1CO0FBQzdCLHFCQUFxQixnQ0FBbUI7O0FBRXhDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQjtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QseUJBQXlCLGdDQUFtQjtBQUM1QyxrQkFBa0IsZ0NBQW1COztBQUVyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsVUFBVSxnQ0FBbUI7QUFDN0Isc0JBQXNCLGdDQUFtQjtBQUN6QyxjQUFjLGdDQUFtQjtBQUNqQyxpQkFBaUIsZ0NBQW1COztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCx5QkFBeUIsZ0NBQW1CO0FBQzVDLGtCQUFrQixnQ0FBbUI7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOzs7QUFHQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxNQUFNOztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0YsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGlCQUFpQixnQ0FBbUI7QUFDcEMsZUFBZSxnQ0FBbUI7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGlCQUFpQixnQ0FBbUI7QUFDcEMsZ0NBQWdDLGdDQUFtQjtBQUNuRCxrQ0FBa0MsZ0NBQW1CO0FBQ3JELGVBQWUsZ0NBQW1COztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxhQUFhLGdDQUFtQjs7QUFFaEM7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxhQUFhLGdDQUFtQjtBQUNoQyxpQkFBaUIsZ0NBQW1CO0FBQ3BDLFVBQVUsZ0NBQW1CO0FBQzdCLGtDQUFrQyxnQ0FBbUI7QUFDckQsZ0JBQWdCLGdDQUFtQjtBQUNuQyxvQkFBb0IsZ0NBQW1CO0FBQ3ZDLDBCQUEwQixnQ0FBbUI7QUFDN0MsaUNBQWlDLGdDQUFtQjs7QUFFcEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsYUFBYSxnQ0FBbUI7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrREFBa0Q7QUFDM0YsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsYUFBYSxnQ0FBbUI7QUFDaEMsVUFBVSxnQ0FBbUI7O0FBRTdCOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGFBQWEsZ0NBQW1CO0FBQ2hDLGdCQUFnQixnQ0FBbUI7O0FBRW5DO0FBQ0Esa0RBQWtEOztBQUVsRDs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGNBQWMsZ0NBQW1CO0FBQ2pDLFlBQVksZ0NBQW1COztBQUUvQjtBQUNBLHFFQUFxRTtBQUNyRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGdCQUFnQixnQ0FBbUI7O0FBRW5DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdEO0FBQ0Esb0JBQW9CLGdDQUFtQjtBQUN2Qyw2QkFBNkIsZ0NBQW1COztBQUVoRDtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxnQkFBZ0IsZ0NBQW1COztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCw2QkFBNkIsZ0NBQW1COztBQUVoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0EsMENBQTBDLGdDQUFtQjs7QUFFN0QsZUFBZSxnQ0FBbUI7QUFDbEMsZUFBZSxnQ0FBbUI7QUFDbEMsZ0JBQWdCLGdDQUFtQjtBQUNuQywwQkFBMEIsZ0NBQW1CO0FBQzdDLHNCQUFzQixnQ0FBbUI7O0FBRXpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGtCQUFrQixnQ0FBbUI7QUFDckMsZUFBZSxnQ0FBbUI7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELHNCQUFzQixnQ0FBbUI7O0FBRXpDO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RCxjQUFjLGdDQUFtQjs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwwQ0FBMEMsZ0NBQW1COztBQUU3RDtBQUNBLG9CQUFvQixnQ0FBbUI7O0FBRXZDO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBLDBDQUEwQyxnQ0FBbUI7O0FBRTdELGFBQWEsZ0NBQW1CO0FBQ2hDLGFBQWEsZ0NBQW1CO0FBQ2hDLFVBQVUsZ0NBQW1CO0FBQzdCLFVBQVUsZ0NBQW1CO0FBQzdCLG9CQUFvQixnQ0FBbUI7QUFDdkMsd0JBQXdCLGdDQUFtQjs7QUFFM0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBLE9BQU87O0FBRVA7QUFDQSwyREFBMkQsZ0NBQW1COzs7QUFHOUUsUUFBUSxnQ0FBbUI7QUFDM0IsZ0JBQWdCLGdDQUFtQjtBQUNuQyxlQUFlLGdDQUFtQjtBQUNsQyxlQUFlLGdDQUFtQjtBQUNsQyxlQUFlLGdDQUFtQjtBQUNsQyxZQUFZLGdDQUFtQjtBQUMvQixtQkFBbUIsZ0NBQW1CO0FBQ3RDLDBCQUEwQixnQ0FBbUI7QUFDN0MsU0FBUyxnQ0FBbUI7QUFDNUIsaUJBQWlCLGdDQUFtQjtBQUNwQyxTQUFTLGdDQUFtQjtBQUM1QixhQUFhLGdDQUFtQjs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsV0FBVztBQUM3Qjs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRCxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQSxvQkFBb0IsWUFBWTtBQUNoQyxrQkFBa0IsMEJBQTBCO0FBQzVDO0FBQ0E7O0FBRUEsOEJBQThCLG1CQUFtQjs7QUFFakQsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksOENBQThDO0FBQ2xEO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0QsT0FBTzs7QUFFUDtBQUNBLDJEQUEyRCxnQ0FBbUI7O0FBRTlFLFFBQVEsZ0NBQW1CO0FBQzNCLGVBQWUsZ0NBQW1CO0FBQ2xDLGlCQUFpQixnQ0FBbUI7QUFDcEMsWUFBWSxnQ0FBbUI7O0FBRS9CLDhDQUE4QyxnQkFBZ0I7O0FBRTlEO0FBQ0E7QUFDQSxJQUFJLDJEQUEyRDtBQUMvRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRCxPQUFPOztBQUVQO0FBQ0EscUNBQXFDLGdDQUFtQjs7QUFFeEQscUJBQXFCLGdDQUFtQjtBQUN4QztBQUNBLHNCQUFzQjtBQUN0Qiw0R0FBNEcsZ0NBQW1CO0FBQy9ILGlJQUFpSSxnQ0FBbUI7QUFDcEoscUdBQXFHLGdDQUFtQjtBQUN4SCwwSEFBMEgsZ0NBQW1CO0FBQzdJOzs7QUFHQTtBQUNBO0FBQ0EsbUdBQW1HLDRCQUE0Qix5QkFBeUIsbUJBQW1CLHlCQUF5QixtQkFBbUIsMEJBQTBCLDRCQUE0QixrQ0FBa0MsdUNBQXVDLGdCQUFnQiw0QkFBNEIsMEJBQTBCLHFCQUFxQiw4QkFBOEIsc0JBQXNCLDBCQUEwQixxQkFBcUIsc0JBQXNCLHlCQUF5QixxRUFBcUUsK0JBQStCLDRCQUE0Qiw0REFBNEQsMEZBQTBGLHNFQUFzRSwwRUFBMEUsaUVBQWlFLEtBQUsscUNBQXFDLG9CQUFvQixLQUFLLHVDQUF1Qyx5QkFBeUIsa0JBQWtCLHdCQUF3Qiw4REFBOEQsaUJBQWlCLGdCQUFnQixlQUFlLGdCQUFnQixLQUFLLHNDQUFzQyx5QkFBeUIsa0JBQWtCLHdCQUF3QixpQkFBaUIsZ0JBQWdCLDBCQUEwQixrQkFBa0IsbUJBQW1CLEtBQUsscUVBQXFFLDBCQUEwQixLQUFLLHFDQUFxQyw4QkFBOEIsMkJBQTJCLEtBQUssc0NBQXNDLDZCQUE2QixLQUFLLDRDQUE0QyxZQUFZLG1CQUFtQixPQUFPLFVBQVUsbUJBQW1CLE9BQU8sS0FBSyx1RUFBdUUsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUssNkZBQTZGLFlBQVksbUJBQW1CLE9BQU8sVUFBVSxtQkFBbUIsT0FBTyxLQUFLLDJFQUEyRSxZQUFZLG1CQUFtQixPQUFPLFVBQVUsbUJBQW1CLE9BQU8sS0FBSyxxRUFBcUUsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUssV0FBVyxxRkFBcUYsTUFBTSxZQUFZLGFBQWEsV0FBVyxZQUFZLFdBQVcsTUFBTSxPQUFPLGFBQWEsV0FBVyxZQUFZLGFBQWEsV0FBVyxZQUFZLFdBQVcsWUFBWSxXQUFXLFVBQVUsWUFBWSxhQUFhLGFBQWEsY0FBYyx5QkFBeUIseUJBQXlCLHlCQUF5Qix5QkFBeUIsYUFBYSxPQUFPLE9BQU8sTUFBTSxLQUFLLFlBQVksV0FBVyxZQUFZLGFBQWEsV0FBVyxVQUFVLFVBQVUsVUFBVSxNQUFNLEtBQUssWUFBWSxXQUFXLFlBQVksV0FBVyxVQUFVLFlBQVksV0FBVyxVQUFVLE1BQU0sTUFBTSxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFlBQVksT0FBTyxLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU0sWUFBWSxNQUFNLEtBQUssVUFBVSxLQUFLLEtBQUssVUFBVSxLQUFLLGtGQUFrRiw0QkFBNEIseUJBQXlCLG1CQUFtQix5QkFBeUIsbUJBQW1CLDBCQUEwQiw0QkFBNEIsa0NBQWtDLHVDQUF1QyxnQkFBZ0IsNEJBQTRCLDBCQUEwQixxQkFBcUIsOEJBQThCLHNCQUFzQiwwQkFBMEIscUJBQXFCLHNCQUFzQix5QkFBeUIscUVBQXFFLCtCQUErQiw0QkFBNEIsNERBQTRELDBGQUEwRixzRUFBc0UsMEVBQTBFLGlFQUFpRSxLQUFLLHFDQUFxQyxvQkFBb0IsS0FBSyx1Q0FBdUMseUJBQXlCLGtCQUFrQix3QkFBd0IsOERBQThELGlCQUFpQixnQkFBZ0IsZUFBZSxnQkFBZ0IsS0FBSyxzQ0FBc0MseUJBQXlCLGtCQUFrQix3QkFBd0IsaUJBQWlCLGdCQUFnQiwwQkFBMEIsa0JBQWtCLG1CQUFtQixLQUFLLHFFQUFxRSwwQkFBMEIsS0FBSyxxQ0FBcUMsOEJBQThCLDJCQUEyQixLQUFLLHNDQUFzQyw2QkFBNkIsS0FBSyw0Q0FBNEMsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUssdUVBQXVFLFlBQVksbUJBQW1CLE9BQU8sVUFBVSxtQkFBbUIsT0FBTyxLQUFLLDZGQUE2RixZQUFZLG1CQUFtQixPQUFPLFVBQVUsbUJBQW1CLE9BQU8sS0FBSywyRUFBMkUsWUFBWSxtQkFBbUIsT0FBTyxVQUFVLG1CQUFtQixPQUFPLEtBQUsscUVBQXFFLFlBQVksbUJBQW1CLE9BQU8sVUFBVSxtQkFBbUIsT0FBTyxLQUFLLHVCQUF1QjtBQUNobk07QUFDQTs7O0FBR0EsT0FBTzs7QUFFUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxREFBcUQ7QUFDckQ7O0FBRUE7QUFDQSxnREFBZ0Q7QUFDaEQ7O0FBRUE7QUFDQSxxRkFBcUY7QUFDckY7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsS0FBSzs7O0FBR0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsa0JBQWtCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLHNCQUFzQjtBQUM1Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNGQUFzRixxQkFBcUI7QUFDM0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixpREFBaUQscUJBQXFCO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0RBQXNELHFCQUFxQjtBQUMzRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELGNBQWM7QUFDckU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPOztBQUVQLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdDQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxnQ0FBbUI7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQ0FBbUIsYUFBYSxXQUFXO0FBQ3REO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdDQUFtQjtBQUM3QjtBQUNBLGVBQWUsZ0NBQW1CLHdCQUF3QixnQ0FBbUI7QUFDN0UsbURBQW1ELHdDQUF3QztBQUMzRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQ0FBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQW1CO0FBQzdCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsZ0NBQW1CO0FBQzdCO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBLDBEQUEwRCxhQUFhO0FBQ3ZFO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsZ0NBQW1CO0FBQ25CLGdDQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsZ0NBQW1CO0FBQ25CLGdDQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxnQ0FBbUI7QUFDbkIsZ0NBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxnQ0FBbUI7QUFDbkIsZ0NBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLGdDQUFtQjtBQUNuQixnQ0FBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxnQ0FBbUI7QUFDbkIsZ0NBQW1CO0FBQ25CO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxnQ0FBbUI7QUFDbkIsZ0NBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQSxXQUFXLGdDQUFtQjtBQUM5QjtBQUNBLFdBQVcsZ0NBQW1CO0FBQzlCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1QkFBdUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBCQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFckIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFdBQVc7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsV0FBVztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsV0FBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGtCQUFrQixFQUFFLG1DQUFtQyxFQUFFLHlCQUF5QjtBQUNySCwyQkFBMkIsaUJBQWlCLHNCQUFzQixnQkFBZ0I7QUFDbEYsK0NBQStDLHlCQUF5QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCLElBQUksc0JBQXNCO0FBQ3ZFO0FBQ0EsbUJBQW1CLE9BQU8sSUFBSSxPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUVBQW1FO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0hBQWtIO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUU7QUFDM0M7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLE9BQU87QUFDakY7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjO0FBQ2pFLEdBQUcsY0FBYyxFQUFFLGNBQWMsRUFBRSxjQUFjLEVBQUUsY0FBYztBQUNqRSxHQUFHLGNBQWMsRUFBRSxjQUFjLEVBQUUsZUFBZSxFQUFFLGNBQWM7QUFDbEUsR0FBRyxjQUFjLEVBQUUsY0FBYyxFQUFFLGVBQWUsRUFBRSxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0QkFBNEI7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0QsNkVBQTZFLDJCQUEyQixrQ0FBa0MsOEJBQThCLHlCQUF5Qiw2R0FBNkcsNERBQTRELEtBQUs7QUFDL1csQ0FBQztBQUNELDZFQUE2RSw4Q0FBOEMseUJBQXlCLDZCQUE2QixLQUFLO0FBQ3RMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOENBQThDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELDhFQUE4RSxpREFBaUQsNEJBQTRCLCtCQUErQix5QkFBeUIsc0RBQXNELDRCQUE0QixpRUFBaUUsc0NBQXNDLDhCQUE4Qix5QkFBeUIsNkdBQTZHLDBGQUEwRix5RkFBeUYsdUdBQXVHLGdGQUFnRixLQUFLO0FBQy81QixDQUFDO0FBQ0QsaUxBQWlMLCtDQUErQyw4REFBOEQsd0VBQXdFLDhDQUE4QyxnREFBZ0QsbURBQW1ELGlDQUFpQyxzQ0FBc0MsOEJBQThCLGlFQUFpRSxLQUFLLHFCQUFxQiw4Q0FBOEMsbVBBQW1QLDhIQUE4SCx5QkFBeUIsdUNBQXVDLG9FQUFvRSxrQ0FBa0MseUJBQXlCLHFEQUFxRCxTQUFTLE1BQU0sc0hBQXNILHFDQUFxQyw0QkFBNEIsS0FBSztBQUNyaEQsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQSxpRUFBaUUsRUFBRSxLQUFLO0FBQ3hFO0FBQ0E7QUFDQSx5RUFBeUUsRUFBRSxLQUFLO0FBQ2hGO0FBQ0EsMEVBQTBFLEVBQUUsZUFBZTtBQUMzRix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEUsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qyw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELDhFQUE4RSwyQkFBMkIsMkJBQTJCLDhCQUE4QiwwQkFBMEIscUJBQXFCLDBDQUEwQyxrQ0FBa0Msd0JBQXdCLEtBQUs7QUFDMVQsQ0FBQztBQUNELHFMQUFxTCw4QkFBOEIscUJBQXFCLDhDQUE4QywyQ0FBMkMsd0JBQXdCLG9FQUFvRSw0REFBNEQsNkJBQTZCLGdCQUFnQixPQUFPLG9FQUFvRSxLQUFLO0FBQ3RsQixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQ0FBK0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RztBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVk7QUFDakUsZ0NBQWdDLGNBQWMseUJBQXlCLGtCQUFrQjtBQUN6RjtBQUNBO0FBQ0EsZ0dBQWdHLFdBQVcsb0JBQW9CLGFBQWE7QUFDNUk7QUFDQTtBQUNBLHNEQUFzRCxhQUFhO0FBQ25FLGdDQUFnQyxlQUFlLHlCQUF5QixrQkFBa0I7QUFDMUY7QUFDQTtBQUNBLGtHQUFrRyxZQUFZLHFCQUFxQixjQUFjO0FBQ2pKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixTQUFTO0FBQ3JDLGdDQUFnQyxpQkFBaUI7QUFDakQsb0NBQW9DLGdCQUFnQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0dBQW9HLGdDQUFnQyxjQUFjLG10QkFBbXRCO0FBQ3IzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEMsdUZBQXVGO0FBQ3ZGLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJDQUEyQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtDQUErQyw4Q0FBOEMsa0JBQWtCO0FBQ3pKO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGLEtBQUs7QUFDcEc7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELFVBQVUsZ0JBQWdCLGNBQWM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsY0FBYywrb0JBQStvQjtBQUN2dEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNEJBQTRCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOEJBQThCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw4QkFBOEI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4Qjs7QUFFL0IsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGNBQWMsU0FBUyxjQUFjLFdBQVcsK0JBQStCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFdBQVcsU0FBUyxlQUFlLFdBQVcsZ0NBQWdDO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0Msa0NBQWtDLG9CQUFvQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOEJBQThCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFVBQVU7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsRUFBRSxJQUFJLEVBQUUsUUFBUSxHQUFHLDBCQUEwQixpQkFBaUI7QUFDdkk7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLEVBQUUsSUFBSSxFQUFFLFFBQVEsR0FBRywwQkFBMEIsY0FBYztBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWUsZ0RBQWdELGFBQWEseUJBQXlCO0FBQ3JILCtDQUErQyxZQUFZO0FBQzNELCtDQUErQyxZQUFZO0FBQzNELHdCQUF3QixVQUFVO0FBQ2xDLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGdDQUFnQztBQUNoQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwwREFBMEQ7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQ0FBbUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxPQUFPLDRCQUE0QixTQUFTO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxPQUFPLGNBQWMsWUFBWTtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsQ0FBQztBQUNELGlFQUFpRTtBQUNqRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvQkFBb0I7QUFDdEUsb0VBQW9FO0FBQ3BFLHFGQUFxRjtBQUNyRixzRkFBc0Y7QUFDdEYscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2QkFBNkI7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2RUFBNkU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHFFQUFxRTtBQUM1SCxxREFBcUQscUVBQXFFO0FBQzFILHVEQUF1RCxxRUFBcUU7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Ysd0JBQXdCO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDRDQUE0QztBQUM1QywwRUFBMEUsc0JBQXNCLEdBQUcsdUJBQXVCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNELGtFQUFrRTtBQUNsRTtBQUNBLGVBQWUsZ0NBQW1CO0FBQ2xDLENBQUM7QUFDRDtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwQkFBMEI7QUFDdEYsMkRBQTJELDBCQUEwQjtBQUNyRjtBQUNBO0FBQ0EsNERBQTRELHlDQUF5QztBQUNyRywyREFBMkQsZ0RBQWdEO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0NBQW9DO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2Qyw4Q0FBOEM7QUFDOUMsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsOENBQThDO0FBQzlDLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDOztBQUV2QyxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0VBQWtFO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVSxHQUFHLFVBQVU7QUFDOUM7QUFDQTtBQUNBLHVCQUF1QixVQUFVLEdBQUcsVUFBVTtBQUM5QztBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixnQkFBZ0I7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRixhQUFhO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUMsd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixxQkFBcUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHFCQUFxQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixnQkFBZ0I7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLGdCQUFnQjtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0JBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwyQkFBMkI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qix3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSxJQUFJO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyxJQUFJO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RkFBdUYsY0FBYztBQUNyRztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdUJBQXVCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUI7QUFDekQsZ0JBQWdCLDJGQUEyRjtBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsd0NBQXdDO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QscUJBQXFCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckMsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUpBQXlKLGtCQUFrQjtBQUMzTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLElBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxJQUFJO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsS0FBSztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RyxJQUFJO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLElBQUk7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw2REFBNkQ7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0dBQW9HLElBQUk7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0csSUFBSTtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9HQUFvRztBQUNuSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4RUFBOEU7QUFDN0Y7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQyw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0EsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0EsdUVBQXVFLDZCQUE2QjtBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdURBQXVEO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxxRUFBcUU7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLElBQUk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLElBQUk7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNFQUFzRTtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdDQUFnQztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsZ0RBQWdELDZGQUE2RjtBQUMxTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxJQUFJO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLDBCQUEwQjtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw0QkFBNEI7QUFDN0U7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixlQUFlO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtDQUFrQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCwwQ0FBMEM7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0lBQWdJO0FBQ2hKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDZSQUE2UixrQkFBa0I7QUFDL1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwrQkFBK0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsMENBQTBDO0FBQ25ILCtEQUErRCxtQkFBbUI7QUFDbEY7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEdBQUcsSUFBSSwySkFBMko7QUFDak87QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEtBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0Usa0NBQWtDO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGdCQUFnQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsbUJBQW1CO0FBQzlGO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRSxpQkFBaUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLDZDQUE2QztBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCx1QkFBdUI7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhHQUE4RyxxQ0FBcUM7QUFDbko7QUFDQSxpRkFBaUYsa0JBQWtCO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLHFDQUFxQztBQUMvSTtBQUNBLDZFQUE2RSxzQkFBc0I7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLHVEQUF1RDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGtCQUFrQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0dBQXdHLElBQUk7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsSUFBSTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRyxJQUFJO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHLElBQUk7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxTQUFTO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlLG1GQUFtRjtBQUNsRztBQUNBO0FBQ0EsZUFBZSxzRkFBc0Y7QUFDckc7QUFDQTtBQUNBLGVBQWUsbUZBQW1GO0FBQ2xHO0FBQ0E7QUFDQSxlQUFlLHNGQUFzRjtBQUNyRzs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx3Q0FBd0M7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsdUNBQXVDO0FBQ3ZDLHVDQUF1QztBQUN2QyxxQ0FBcUM7QUFDckMsMEJBQTBCO0FBQzFCO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsOENBQThDO0FBQzlDLCtEQUErRDtBQUMvRDtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLGNBQWM7QUFDZCx3REFBd0Q7QUFDeEQ7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsMEJBQTBCO0FBQzFCLHNEQUFzRDtBQUN0RDtBQUNBLDJFQUEyRTtBQUMzRSwyRUFBMkU7QUFDM0UsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxvRUFBb0U7QUFDcEUsMkRBQTJEO0FBQzNEO0FBQ0Esd0JBQXdCO0FBQ3hCLG1GQUFtRjtBQUNuRixxRkFBcUY7QUFDckYsd0ZBQXdGO0FBQ3hGLDJCQUEyQjtBQUMzQixtQ0FBbUM7QUFDbkMsNkJBQTZCO0FBQzdCLGdDQUFnQztBQUNoQyw2REFBNkQ7QUFDN0QsNkRBQTZEO0FBQzdELHlDQUF5QztBQUN6QyxnQ0FBZ0M7QUFDaEM7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsNkJBQTZCO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSwyREFBMkQ7QUFDM0QsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCxvRUFBb0U7QUFDcEUsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RCwyREFBMkQ7QUFDM0Qsc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQSwyR0FBMkc7QUFDM0c7QUFDQTtBQUNBLGdIQUFnSDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0NBQW9DO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsU0FBUztBQUNULDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDJCQUEyQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxTQUFTO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUNBQWlDO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELHFCQUFxQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw2REFBNkQsU0FBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxTQUFTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQSx3QkFBd0IsdUJBQXVCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0I7O0FBRXJCLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxvQkFBb0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2RUFBNkU7QUFDN0Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvREFBb0Q7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELFdBQVcsMEJBQTBCLGNBQWMsb0JBQW9CLGVBQWUsa0JBQWtCLGtCQUFrQjtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILCtDQUErQztBQUNuSztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx3RkFBd0Y7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlEQUFpRDtBQUNoRTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSw2REFBNkQ7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0Esa0JBQWtCLFlBQVksRUFBRSx5QkFBeUIsRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLFlBQVk7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsNEJBQTRCLHdCQUF3QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJCQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJDQUEyQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsa0JBQWtCO0FBQ3ZFO0FBQ0E7QUFDQSwrQ0FBK0MsTUFBTTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0dBQW9HLGdDQUFnQyxjQUFjLDB0QkFBMHRCO0FBQzUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULGlDQUFpQyxTQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRCx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0Msb0RBQW9ELGNBQWM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwyQ0FBMkM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0dBQWdHO0FBQy9HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQWlEO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaOztBQUVBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzArVzs7QUFFMStXOzs7Ozs7Ozs7Ozs7Ozs7O0FDenM0QjBDO0FBQ0U7QUFFN0IsTUFBTSxNQUFPLFNBQVEsNENBQUs7SUFDdkM7UUFDRSxLQUFLLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNqRCxDQUFDO0lBRU0sWUFBWSxDQUFDLE9BQWU7UUFDakMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsMkVBQW1DLENBQUMsQ0FBQztJQUN6RCxDQUFDO0lBRU0sWUFBWSxDQUFDLE9BQWUsRUFBRSxNQUFjLElBQUcsQ0FBQztDQUN4RDs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDYjREO0FBQ0M7QUFFOUQsTUFBTSxNQUFNLEdBQW1DO0lBQzdDLFVBQVUsRUFBRSxJQUFJLGtEQUFXLENBQUMsMkRBQWMsQ0FBQztDQUM1QyxDQUFDO0FBRUYsTUFBTSxZQUFZLEdBQW1DO0lBQ25ELFdBQVcsRUFBRSxrRUFBMkIsQ0FBQztRQUN2QyxLQUFLLEVBQUUsTUFBTSxDQUFDLFVBQVU7UUFDeEIsSUFBSSxFQUFFO1lBQ0osT0FBTyxFQUFFLENBQUM7WUFDVixJQUFJLEVBQUUsQ0FBQztZQUNQLFdBQVcsRUFBRSxFQUFFO1lBQ2YsWUFBWSxFQUFFLEVBQUU7U0FDakI7S0FDRixDQUFDO0NBQ0gsQ0FBQztBQUVGLE1BQU0sTUFBTSxHQUFHLElBQUksNkNBQU0sRUFBRSxDQUFDO0FBQzVCLEtBQUssTUFBTSxLQUFLLElBQUksTUFBTSxFQUFFO0lBQzFCLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7Q0FDbkM7QUFFK0I7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDeEJoQztVQUNBOztVQUVBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBOztVQUVBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBOzs7OztXQ3RCQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLHlDQUF5Qyx3Q0FBd0M7V0FDakY7V0FDQTtXQUNBOzs7OztXQ1BBO1dBQ0E7V0FDQTtXQUNBO1dBQ0EsR0FBRztXQUNIO1dBQ0E7V0FDQSxDQUFDOzs7OztXQ1BEOzs7OztXQ0FBO1dBQ0E7V0FDQTtXQUNBLHVEQUF1RCxpQkFBaUI7V0FDeEU7V0FDQSxnREFBZ0QsYUFBYTtXQUM3RDs7Ozs7V0NOQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7Ozs7Ozs7Ozs7Ozs7QUNmbUM7QUFDRTtBQUNBO0FBRXJDLE1BQU0sSUFBSSxHQUFHLElBQUksNkNBQU0sQ0FBQztJQUN0QixLQUFLLEVBQUUsR0FBRztJQUNWLE1BQU0sRUFBRSxHQUFHO0NBQ1osQ0FBQyxDQUFDO0FBRUgsSUFBSSxDQUFDLEtBQUssQ0FBQyw4Q0FBTSxDQUFDLENBQUM7QUFFbkIsTUFBTSxNQUFNLEdBQUcsSUFBSSxzREFBTSxFQUFFLENBQUM7QUFDNUIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2ZyYW5raWUvLi9ub2RlX21vZHVsZXMvZXhjYWxpYnVyL2J1aWxkL2VzbS9leGNhbGlidXIuanMiLCJ3ZWJwYWNrOi8vZnJhbmtpZS8uL3NyYy9hY3RvcnMvcGxheWVyLnRzIiwid2VicGFjazovL2ZyYW5raWUvLi9zcmMvcmVzb3VyY2VzLnRzIiwid2VicGFjazovL2ZyYW5raWUvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vZnJhbmtpZS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vZnJhbmtpZS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL2ZyYW5raWUvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9mcmFua2llL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vZnJhbmtpZS93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly9mcmFua2llLy4vc3JjL2luZGV4LnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogZXhjYWxpYnVyIC0gMC4yNS4xIC0gMjAyMS0xMS01XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyXG4gKiBDb3B5cmlnaHQgKGMpIDIwMjEgRXhjYWxpYnVyLmpzIDxodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyL2dyYXBocy9jb250cmlidXRvcnM+XG4gKiBMaWNlbnNlZCBCU0QtMi1DbGF1c2VcbiAqIEBwcmVzZXJ2ZVxuICovXG4vKioqKioqLyB2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIDQ2NjI6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMzQzMCk7XG52YXIgZW50cnlVbmJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDg3OTEpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVudHJ5VW5iaW5kKCdBcnJheScsICdzb3J0Jyk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDgzNDM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbl9fd2VicGFja19yZXF1aXJlX18oNDc2OSk7XG52YXIgcGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oOTI3Nik7XG5cbm1vZHVsZS5leHBvcnRzID0gcGF0aC5PYmplY3Qua2V5cztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzExMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MzMpO1xudmFyIHRyeVRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODIxKTtcblxuLy8gYEFzc2VydDogSXNDYWxsYWJsZShhcmd1bWVudCkgaXMgdHJ1ZWBcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIGlmIChpc0NhbGxhYmxlKGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgYSBmdW5jdGlvbicpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTE3Njpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGlzT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MDUyKTtcblxuLy8gYEFzc2VydDogVHlwZShhcmd1bWVudCkgaXMgT2JqZWN0YFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGlzT2JqZWN0KGFyZ3VtZW50KSkgcmV0dXJuIGFyZ3VtZW50O1xuICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTU0MDpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTA1KTtcbnZhciB0b0xlbmd0aCA9IF9fd2VicGFja19yZXF1aXJlX18oNDIzNyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMjMxKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IGluZGV4T2YsIGluY2x1ZGVzIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfSU5DTFVERVMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcywgZWwsIGZyb21JbmRleCkge1xuICAgIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KCR0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gICAgdmFyIHZhbHVlO1xuICAgIC8vIEFycmF5I2luY2x1ZGVzIHVzZXMgU2FtZVZhbHVlWmVybyBlcXVhbGl0eSBhbGdvcml0aG1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlIC0tIE5hTiBjaGVja1xuICAgICAgaWYgKHZhbHVlICE9IHZhbHVlKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBBcnJheSNpbmRleE9mIGlnbm9yZXMgaG9sZXMsIEFycmF5I2luY2x1ZGVzIC0gbm90XG4gICAgfSBlbHNlIGZvciAoO2xlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbCkgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICAgfSByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUuaW5jbHVkZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmRleG9mXG4gIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYwMzg6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGZhaWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MjI5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUsIGFyZ3VtZW50KSB7XG4gIHZhciBtZXRob2QgPSBbXVtNRVRIT0RfTkFNRV07XG4gIHJldHVybiAhIW1ldGhvZCAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVzZWxlc3MtY2FsbCxuby10aHJvdy1saXRlcmFsIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gICAgbWV0aG9kLmNhbGwobnVsbCwgYXJndW1lbnQgfHwgZnVuY3Rpb24gKCkgeyB0aHJvdyAxOyB9LCAxKTtcbiAgfSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzODY3OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuLy8gVE9ETzogdXNlIHNvbWV0aGluZyBtb3JlIGNvbXBsZXggbGlrZSB0aW1zb3J0P1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxudmFyIG1lcmdlU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcbiAgcmV0dXJuIGxlbmd0aCA8IDggPyBpbnNlcnRpb25Tb3J0KGFycmF5LCBjb21wYXJlZm4pIDogbWVyZ2UoXG4gICAgbWVyZ2VTb3J0KGFycmF5LnNsaWNlKDAsIG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgbWVyZ2VTb3J0KGFycmF5LnNsaWNlKG1pZGRsZSksIGNvbXBhcmVmbiksXG4gICAgY29tcGFyZWZuXG4gICk7XG59O1xuXG52YXIgaW5zZXJ0aW9uU29ydCA9IGZ1bmN0aW9uIChhcnJheSwgY29tcGFyZWZuKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHZhciBpID0gMTtcbiAgdmFyIGVsZW1lbnQsIGo7XG5cbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgICBqID0gaTtcbiAgICBlbGVtZW50ID0gYXJyYXlbaV07XG4gICAgd2hpbGUgKGogJiYgY29tcGFyZWZuKGFycmF5W2ogLSAxXSwgZWxlbWVudCkgPiAwKSB7XG4gICAgICBhcnJheVtqXSA9IGFycmF5Wy0tal07XG4gICAgfVxuICAgIGlmIChqICE9PSBpKyspIGFycmF5W2pdID0gZWxlbWVudDtcbiAgfSByZXR1cm4gYXJyYXk7XG59O1xuXG52YXIgbWVyZ2UgPSBmdW5jdGlvbiAobGVmdCwgcmlnaHQsIGNvbXBhcmVmbikge1xuICB2YXIgbGxlbmd0aCA9IGxlZnQubGVuZ3RoO1xuICB2YXIgcmxlbmd0aCA9IHJpZ2h0Lmxlbmd0aDtcbiAgdmFyIGxpbmRleCA9IDA7XG4gIHZhciByaW5kZXggPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgd2hpbGUgKGxpbmRleCA8IGxsZW5ndGggfHwgcmluZGV4IDwgcmxlbmd0aCkge1xuICAgIGlmIChsaW5kZXggPCBsbGVuZ3RoICYmIHJpbmRleCA8IHJsZW5ndGgpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNvbXBhcmVmbihsZWZ0W2xpbmRleF0sIHJpZ2h0W3JpbmRleF0pIDw9IDAgPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wdXNoKGxpbmRleCA8IGxsZW5ndGggPyBsZWZ0W2xpbmRleCsrXSA6IHJpZ2h0W3JpbmRleCsrXSk7XG4gICAgfVxuICB9IHJldHVybiByZXN1bHQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlU29ydDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNzA3OTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTU4OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd2VicGFja19yZXF1aXJlX18oMTYwMSk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjczMyk7XG52YXIgY2xhc3NvZlJhdyA9IF9fd2VicGFja19yZXF1aXJlX18oNzA3OSk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgdGFnLCByZXN1bHQ7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gJ1VuZGVmaW5lZCcgOiBpdCA9PT0gbnVsbCA/ICdOdWxsJ1xuICAgIC8vIEBAdG9TdHJpbmdUYWcgY2FzZVxuICAgIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRPX1NUUklOR19UQUcpKSA9PSAnc3RyaW5nJyA/IHRhZ1xuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3MDgxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTYpO1xudmFyIG93bktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4MjYpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzkzMyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3ODcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuICB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiAgdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiAgdmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAoIWhhcyh0YXJnZXQsIGtleSkpIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTc2Mjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDAwKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTc4Nyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzU4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBrZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDUzNTg6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgICBjb25maWd1cmFibGU6ICEoYml0bWFwICYgMiksXG4gICAgd3JpdGFibGU6ICEoYml0bWFwICYgNCksXG4gICAgdmFsdWU6IHZhbHVlXG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA3NDAwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xuXG4vLyBEZXRlY3QgSUU4J3MgaW5jb21wbGV0ZSBkZWZpbmVQcm9wZXJ0eSBpbXBsZW1lbnRhdGlvblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pWzFdICE9IDc7XG59KTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjYzNTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTg1OSk7XG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwNTIpO1xuXG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBFWElTVFMgPSBpc09iamVjdChkb2N1bWVudCkgJiYgaXNPYmplY3QoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBFWElTVFMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGl0KSA6IHt9O1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjY3MTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oNTk4KTtcblxudmFyIGZpcmVmb3ggPSB1c2VyQWdlbnQubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvaSk7XG5cbm1vZHVsZS5leHBvcnRzID0gISFmaXJlZm94ICYmICtmaXJlZm94WzFdO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NTA2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgVUEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5OCk7XG5cbm1vZHVsZS5leHBvcnRzID0gL01TSUV8VHJpZGVudC8udGVzdChVQSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDU5ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMzMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjM1ODpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTg1OSk7XG52YXIgdXNlckFnZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OTgpO1xuXG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIERlbm8gPSBnbG9iYWwuRGVubztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucyB8fCBEZW5vICYmIERlbm8udmVyc2lvbjtcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuXG5pZiAodjgpIHtcbiAgbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuICB2ZXJzaW9uID0gbWF0Y2hbMF0gPCA0ID8gMSA6IG1hdGNoWzBdICsgbWF0Y2hbMV07XG59IGVsc2UgaWYgKHVzZXJBZ2VudCkge1xuICBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuICBpZiAoIW1hdGNoIHx8IG1hdGNoWzFdID49IDc0KSB7XG4gICAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICAgIGlmIChtYXRjaCkgdmVyc2lvbiA9IG1hdGNoWzFdO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdmVyc2lvbiAmJiArdmVyc2lvbjtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTgxMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHVzZXJBZ2VudCA9IF9fd2VicGFja19yZXF1aXJlX18oNTk4KTtcblxudmFyIHdlYmtpdCA9IHVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC8oXFxkKylcXC4vKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhIXdlYmtpdCAmJiArd2Via2l0WzFdO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4NzkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NjM2KTtcblxudmFyIGNhbGwgPSBGdW5jdGlvbi5jYWxsO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUiwgTUVUSE9ELCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJpbmQoY2FsbCwgZ2xvYmFsW0NPTlNUUlVDVE9SXS5wcm90b3R5cGVbTUVUSE9EXSwgbGVuZ3RoKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM4Mzc6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vLyBJRTgtIGRvbid0IGVudW0gYnVnIGtleXNcbm1vZHVsZS5leHBvcnRzID0gW1xuICAnY29uc3RydWN0b3InLFxuICAnaGFzT3duUHJvcGVydHknLFxuICAnaXNQcm90b3R5cGVPZicsXG4gICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsXG4gICd0b0xvY2FsZVN0cmluZycsXG4gICd0b1N0cmluZycsXG4gICd2YWx1ZU9mJ1xuXTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzEwMzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTg1OSk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3OTMzKS5mO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oNTc2Mik7XG52YXIgcmVkZWZpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0ODcpO1xudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA3OSk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IF9fd2VicGFja19yZXF1aXJlX18oNzA4MSk7XG52YXIgaXNGb3JjZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1NDEpO1xuXG4vKlxuICBvcHRpb25zLnRhcmdldCAgICAgIC0gbmFtZSBvZiB0aGUgdGFyZ2V0IG9iamVjdFxuICBvcHRpb25zLmdsb2JhbCAgICAgIC0gdGFyZ2V0IGlzIHRoZSBnbG9iYWwgb2JqZWN0XG4gIG9wdGlvbnMuc3RhdCAgICAgICAgLSBleHBvcnQgYXMgc3RhdGljIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucHJvdG8gICAgICAgLSBleHBvcnQgYXMgcHJvdG90eXBlIG1ldGhvZHMgb2YgdGFyZ2V0XG4gIG9wdGlvbnMucmVhbCAgICAgICAgLSByZWFsIHByb3RvdHlwZSBtZXRob2QgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLmZvcmNlZCAgICAgIC0gZXhwb3J0IGV2ZW4gaWYgdGhlIG5hdGl2ZSBmZWF0dXJlIGlzIGF2YWlsYWJsZVxuICBvcHRpb25zLmJpbmQgICAgICAgIC0gYmluZCBtZXRob2RzIHRvIHRoZSB0YXJnZXQsIHJlcXVpcmVkIGZvciB0aGUgYHB1cmVgIHZlcnNpb25cbiAgb3B0aW9ucy53cmFwICAgICAgICAtIHdyYXAgY29uc3RydWN0b3JzIHRvIHByZXZlbnRpbmcgZ2xvYmFsIHBvbGx1dGlvbiwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLnVuc2FmZSAgICAgIC0gdXNlIHRoZSBzaW1wbGUgYXNzaWdubWVudCBvZiBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGRlbGV0ZSArIGRlZmluZVByb3BlcnR5XG4gIG9wdGlvbnMuc2hhbSAgICAgICAgLSBhZGQgYSBmbGFnIHRvIG5vdCBjb21wbGV0ZWx5IGZ1bGwgcG9seWZpbGxzXG4gIG9wdGlvbnMuZW51bWVyYWJsZSAgLSBleHBvcnQgYXMgZW51bWVyYWJsZSBwcm9wZXJ0eVxuICBvcHRpb25zLm5vVGFyZ2V0R2V0IC0gcHJldmVudCBjYWxsaW5nIGEgZ2V0dGVyIG9uIHRhcmdldFxuICBvcHRpb25zLm5hbWUgICAgICAgIC0gdGhlIC5uYW1lIG9mIHRoZSBmdW5jdGlvbiBpZiBpdCBkb2VzIG5vdCBtYXRjaCB0aGUga2V5XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHNvdXJjZVByb3BlcnR5LCAnc2hhbScsIHRydWUpO1xuICAgIH1cbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgcmVkZWZpbmUodGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDIyOTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gISFleGVjKCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc2MzY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBhQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcxMTEpO1xuXG4vLyBvcHRpb25hbCAvIHNpbXBsZSBjb250ZXh0IGJpbmRpbmdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZuLCB0aGF0LCBsZW5ndGgpIHtcbiAgYUNhbGxhYmxlKGZuKTtcbiAgaWYgKHRoYXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZuO1xuICBzd2l0Y2ggKGxlbmd0aCkge1xuICAgIGNhc2UgMDogcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQpO1xuICAgIH07XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxODA1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0MDApO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oODE2KTtcblxudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuXG52YXIgRVhJU1RTID0gaGFzKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xuLy8gYWRkaXRpb25hbCBwcm90ZWN0aW9uIGZyb20gbWluaWZpZWQgLyBtYW5nbGVkIC8gZHJvcHBlZCBmdW5jdGlvbiBuYW1lc1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiAoZnVuY3Rpb24gc29tZXRoaW5nKCkgeyAvKiBlbXB0eSAqLyB9KS5uYW1lID09PSAnc29tZXRoaW5nJztcbnZhciBDT05GSUdVUkFCTEUgPSBFWElTVFMgJiYgKCFERVNDUklQVE9SUyB8fCAoREVTQ1JJUFRPUlMgJiYgZ2V0RGVzY3JpcHRvcihGdW5jdGlvblByb3RvdHlwZSwgJ25hbWUnKS5jb25maWd1cmFibGUpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVYSVNUUzogRVhJU1RTLFxuICBQUk9QRVI6IFBST1BFUixcbiAgQ09ORklHVVJBQkxFOiBDT05GSUdVUkFCTEVcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDEzMzM6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MzMpO1xuXG52YXIgYUZ1bmN0aW9uID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc0NhbGxhYmxlKGFyZ3VtZW50KSA/IGFyZ3VtZW50IDogdW5kZWZpbmVkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZXNwYWNlLCBtZXRob2QpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKGdsb2JhbFtuYW1lc3BhY2VdKSA6IGdsb2JhbFtuYW1lc3BhY2VdICYmIGdsb2JhbFtuYW1lc3BhY2VdW21ldGhvZF07XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MzAwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MTExKTtcblxuLy8gYEdldE1ldGhvZGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWdldG1ldGhvZFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoViwgUCkge1xuICB2YXIgZnVuYyA9IFZbUF07XG4gIHJldHVybiBmdW5jID09IG51bGwgPyB1bmRlZmluZWQgOiBhQ2FsbGFibGUoZnVuYyk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5ODU5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1nbG9iYWwtdGhpcyAtLSBzYWZlXG4gIGNoZWNrKHR5cGVvZiBnbG9iYWxUaGlzID09ICdvYmplY3QnICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93KSB8fFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1nbG9iYWxzIC0tIHNhZmVcbiAgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18uZyA9PSAnb2JqZWN0JyAmJiBfX3dlYnBhY2tfcmVxdWlyZV9fLmcpIHx8XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuYyAtLSBmYWxsYmFja1xuICAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKSB8fCBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MTY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjk5MSk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwodG9PYmplY3QoaXQpLCBrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTk3Nzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQzOTQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQwMCk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xudmFyIGNyZWF0ZUVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2MzUpO1xuXG4vLyBUaGFuaydzIElFOCBmb3IgaGlzIGZ1bm55IGRlZmluZVByb3BlcnR5XG5tb2R1bGUuZXhwb3J0cyA9ICFERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHJlcXVpZWQgZm9yIHRlc3RpbmdcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjcmVhdGVFbGVtZW50KCdkaXYnKSwgJ2EnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9XG4gIH0pLmEgIT0gNztcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MzM3OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xudmFyIGNsYXNzb2YgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwNzkpO1xuXG52YXIgc3BsaXQgPSAnJy5zcGxpdDtcblxuLy8gZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBhbmQgbm9uLWVudW1lcmFibGUgb2xkIFY4IHN0cmluZ3Ncbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyB0aHJvd3MgYW4gZXJyb3IgaW4gcmhpbm8sIHNlZSBodHRwczovL2dpdGh1Yi5jb20vbW96aWxsYS9yaGluby9pc3N1ZXMvMzQ2XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnMgLS0gc2FmZVxuICByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGNsYXNzb2YoaXQpID09ICdTdHJpbmcnID8gc3BsaXQuY2FsbChpdCwgJycpIDogT2JqZWN0KGl0KTtcbn0gOiBPYmplY3Q7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg1MTE6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcbnZhciBzdG9yZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTM1Myk7XG5cbnZhciBmdW5jdGlvblRvU3RyaW5nID0gRnVuY3Rpb24udG9TdHJpbmc7XG5cbi8vIHRoaXMgaGVscGVyIGJyb2tlbiBpbiBgY29yZS1qc0AzLjQuMS0zLjQuNGAsIHNvIHdlIGNhbid0IHVzZSBgc2hhcmVkYCBoZWxwZXJcbmlmICghaXNDYWxsYWJsZShzdG9yZS5pbnNwZWN0U291cmNlKSkge1xuICBzdG9yZS5pbnNwZWN0U291cmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjQwNzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIE5BVElWRV9XRUFLX01BUCA9IF9fd2VicGFja19yZXF1aXJlX18oODY5NCk7XG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTA1Mik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NzYyKTtcbnZhciBvYmplY3RIYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNik7XG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1MzUzKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzOTkpO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NzcpO1xuXG52YXIgT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQgPSAnT2JqZWN0IGFscmVhZHkgaW5pdGlhbGl6ZWQnO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbnZhciBzZXQsIGdldCwgaGFzO1xuXG52YXIgZW5mb3JjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaGFzKGl0KSA/IGdldChpdCkgOiBzZXQoaXQsIHt9KTtcbn07XG5cbnZhciBnZXR0ZXJGb3IgPSBmdW5jdGlvbiAoVFlQRSkge1xuICByZXR1cm4gZnVuY3Rpb24gKGl0KSB7XG4gICAgdmFyIHN0YXRlO1xuICAgIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgICB9IHJldHVybiBzdGF0ZTtcbiAgfTtcbn07XG5cbmlmIChOQVRJVkVfV0VBS19NQVAgfHwgc2hhcmVkLnN0YXRlKSB7XG4gIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gIHZhciB3bWdldCA9IHN0b3JlLmdldDtcbiAgdmFyIHdtaGFzID0gc3RvcmUuaGFzO1xuICB2YXIgd21zZXQgPSBzdG9yZS5zZXQ7XG4gIHNldCA9IGZ1bmN0aW9uIChpdCwgbWV0YWRhdGEpIHtcbiAgICBpZiAod21oYXMuY2FsbChzdG9yZSwgaXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICB3bXNldC5jYWxsKHN0b3JlLCBpdCwgbWV0YWRhdGEpO1xuICAgIHJldHVybiBtZXRhZGF0YTtcbiAgfTtcbiAgZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtZ2V0LmNhbGwoc3RvcmUsIGl0KSB8fCB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIHdtaGFzLmNhbGwoc3RvcmUsIGl0KTtcbiAgfTtcbn0gZWxzZSB7XG4gIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcbiAgaGlkZGVuS2V5c1tTVEFURV0gPSB0cnVlO1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgaWYgKG9iamVjdEhhcyhpdCwgU1RBVEUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKE9CSkVDVF9BTFJFQURZX0lOSVRJQUxJWkVEKTtcbiAgICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDY3MzM6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vLyBgSXNDYWxsYWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWlzY2FsbGFibGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgYXJndW1lbnQgPT09ICdmdW5jdGlvbic7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NTQxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MzMpO1xuXG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xuXG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiAgcmV0dXJuIHZhbHVlID09IFBPTFlGSUxMID8gdHJ1ZVxuICAgIDogdmFsdWUgPT0gTkFUSVZFID8gZmFsc2VcbiAgICA6IGlzQ2FsbGFibGUoZGV0ZWN0aW9uKSA/IGZhaWxzKGRldGVjdGlvbilcbiAgICA6ICEhZGV0ZWN0aW9uO1xufTtcblxudmFyIG5vcm1hbGl6ZSA9IGlzRm9yY2VkLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgcmV0dXJuIFN0cmluZyhzdHJpbmcpLnJlcGxhY2UocmVwbGFjZW1lbnQsICcuJykudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZhciBkYXRhID0gaXNGb3JjZWQuZGF0YSA9IHt9O1xudmFyIE5BVElWRSA9IGlzRm9yY2VkLk5BVElWRSA9ICdOJztcbnZhciBQT0xZRklMTCA9IGlzRm9yY2VkLlBPTFlGSUxMID0gJ1AnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1MDUyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjczMyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiBpc0NhbGxhYmxlKGl0KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDQyMzE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5Mzk1OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaXNDYWxsYWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjczMyk7XG52YXIgZ2V0QnVpbHRJbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTMzMyk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NjkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVTRV9TWU1CT0xfQVNfVUlEID8gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJyk7XG4gIHJldHVybiBpc0NhbGxhYmxlKCRTeW1ib2wpICYmIE9iamVjdChpdCkgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMzgzOTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgVjhfVkVSU0lPTiA9IF9fd2VicGFja19yZXF1aXJlX18oNjM1OCk7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWdldG93bnByb3BlcnR5c3ltYm9scyAtLSByZXF1aXJlZCBmb3IgdGVzdGluZ1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBgZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzYCBwb2x5ZmlsbCBzeW1ib2xzIGNvbnZlcnRlZCB0byBvYmplY3QgYXJlIG5vdCBTeW1ib2wgaW5zdGFuY2VzXG4gIHJldHVybiAhU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHxcbiAgICAvLyBDaHJvbWUgMzgtNDAgc3ltYm9scyBhcmUgbm90IGluaGVyaXRlZCBmcm9tIERPTSBjb2xsZWN0aW9ucyBwcm90b3R5cGVzIHRvIGluc3RhbmNlc1xuICAgICFTeW1ib2wuc2hhbSAmJiBWOF9WRVJTSU9OICYmIFY4X1ZFUlNJT04gPCA0MTtcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4Njk0OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcbnZhciBpbnNwZWN0U291cmNlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4NTExKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0NhbGxhYmxlKFdlYWtNYXApICYmIC9uYXRpdmUgY29kZS8udGVzdChpbnNwZWN0U291cmNlKFdlYWtNYXApKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTc4Nzpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIERFU0NSSVBUT1JTID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NDAwKTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM5NCk7XG52YXIgYW5PYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNzYpO1xudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMTApO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXMvbm8tb2JqZWN0LWRlZmluZXByb3BlcnR5IC0tIHNhZmVcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydHlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydHlcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gJGRlZmluZVByb3BlcnR5IDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBhbk9iamVjdChPKTtcbiAgUCA9IHRvUHJvcGVydHlLZXkoUCk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuICRkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoJ2dldCcgaW4gQXR0cmlidXRlcyB8fCAnc2V0JyBpbiBBdHRyaWJ1dGVzKSB0aHJvdyBUeXBlRXJyb3IoJ0FjY2Vzc29ycyBub3Qgc3VwcG9ydGVkJyk7XG4gIGlmICgndmFsdWUnIGluIEF0dHJpYnV0ZXMpIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICByZXR1cm4gTztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc5MzM6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd2VicGFja19yZXF1aXJlX18oNzQwMCk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkxOTUpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd2VicGFja19yZXF1aXJlX18oNTM1OCk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5MDUpO1xudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzMTApO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oODE2KTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd2VicGFja19yZXF1aXJlX18oNDM5NCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yIC0tIHNhZmVcbnZhciAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG5leHBvcnRzLmYgPSBERVNDUklQVE9SUyA/ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTywgUCkge1xuICBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuICBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiAgaWYgKElFOF9ET01fREVGSU5FKSB0cnkge1xuICAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIGlmIChoYXMoTywgUCkpIHJldHVybiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoIXByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmYuY2FsbChPLCBQKSwgT1tQXSk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA4MTUxOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODM3KTtcblxudmFyIGhpZGRlbktleXMgPSBlbnVtQnVnS2V5cy5jb25jYXQoJ2xlbmd0aCcsICdwcm90b3R5cGUnKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZ2V0b3ducHJvcGVydHluYW1lcyAtLSBzYWZlXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg5NDpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eXN5bWJvbHMgLS0gc2FmZVxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTQwOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTYpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTA1KTtcbnZhciBpbmRleE9mID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NTQwKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5NzcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gIHZhciBpID0gMDtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIga2V5O1xuICBmb3IgKGtleSBpbiBPKSAhaGFzKGhpZGRlbktleXMsIGtleSkgJiYgaGFzKE8sIGtleSkgJiYgcmVzdWx0LnB1c2goa2V5KTtcbiAgLy8gRG9uJ3QgZW51bSBidWcgJiBoaWRkZW4ga2V5c1xuICB3aGlsZSAobmFtZXMubGVuZ3RoID4gaSkgaWYgKGhhcyhPLCBrZXkgPSBuYW1lc1tpKytdKSkge1xuICAgIH5pbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1NjMyOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNDApO1xudmFyIGVudW1CdWdLZXlzID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODM3KTtcblxuLy8gYE9iamVjdC5rZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LmtleXNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3Qta2V5cyAtLSBzYWZlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMoTykge1xuICByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkxOTU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVzL25vLW9iamVjdC1nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3IgLS0gc2FmZVxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIE5hc2hvcm4gfiBKREs4IGJ1Z1xudmFyIE5BU0hPUk5fQlVHID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yICYmICEkcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eWlzZW51bWVyYWJsZVxuZXhwb3J0cy5mID0gTkFTSE9STl9CVUcgPyBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuICByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiAkcHJvcGVydHlJc0VudW1lcmFibGU7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDI5MTQ6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBpc0NhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NzMzKTtcbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTA1Mik7XG5cbi8vIGBPcmRpbmFyeVRvUHJpbWl0aXZlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtb3JkaW5hcnl0b3ByaW1pdGl2ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIHByZWYpIHtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChwcmVmID09PSAnc3RyaW5nJyAmJiBpc0NhbGxhYmxlKGZuID0gaW5wdXQudG9TdHJpbmcpICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmIChpc0NhbGxhYmxlKGZuID0gaW5wdXQudmFsdWVPZikgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKHByZWYgIT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSkgcmV0dXJuIHZhbDtcbiAgdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDgyNjpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGdldEJ1aWx0SW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMzMpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxNTEpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODk0KTtcbnZhciBhbk9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE3Nik7XG5cbi8vIGFsbCBvYmplY3Qga2V5cywgaW5jbHVkZXMgbm9uLWVudW1lcmFibGUgYW5kIHN5bWJvbHNcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdvd25LZXlzJykgfHwgZnVuY3Rpb24gb3duS2V5cyhpdCkge1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuICB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gIHJldHVybiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPyBrZXlzLmNvbmNhdChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5Mjc2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDc0ODc6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3MzMpO1xudmFyIGhhcyA9IF9fd2VicGFja19yZXF1aXJlX18oODE2KTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU3NjIpO1xudmFyIHNldEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjA3OSk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd2VicGFja19yZXF1aXJlX18oODUxMSk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjQwNyk7XG52YXIgQ09ORklHVVJBQkxFX0ZVTkNUSU9OX05BTUUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4MDUpLkNPTkZJR1VSQUJMRTtcblxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBURU1QTEFURSA9IFN0cmluZyhTdHJpbmcpLnNwbGl0KCdTdHJpbmcnKTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHVuc2FmZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMudW5zYWZlIDogZmFsc2U7XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zID8gISFvcHRpb25zLmVudW1lcmFibGUgOiBmYWxzZTtcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuICB2YXIgbmFtZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5uYW1lICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5hbWUgOiBrZXk7XG4gIHZhciBzdGF0ZTtcbiAgaWYgKGlzQ2FsbGFibGUodmFsdWUpKSB7XG4gICAgaWYgKFN0cmluZyhuYW1lKS5zbGljZSgwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gICAgICBuYW1lID0gJ1snICsgU3RyaW5nKG5hbWUpLnJlcGxhY2UoL15TeW1ib2xcXCgoW14pXSopXFwpLywgJyQxJykgKyAnXSc7XG4gICAgfVxuICAgIGlmICghaGFzKHZhbHVlLCAnbmFtZScpIHx8IChDT05GSUdVUkFCTEVfRlVOQ1RJT05fTkFNRSAmJiB2YWx1ZS5uYW1lICE9PSBuYW1lKSkge1xuICAgICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIG5hbWUpO1xuICAgIH1cbiAgICBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiAgICBpZiAoIXN0YXRlLnNvdXJjZSkge1xuICAgICAgc3RhdGUuc291cmNlID0gVEVNUExBVEUuam9pbih0eXBlb2YgbmFtZSA9PSAnc3RyaW5nJyA/IG5hbWUgOiAnJyk7XG4gICAgfVxuICB9XG4gIGlmIChPID09PSBnbG9iYWwpIHtcbiAgICBpZiAoc2ltcGxlKSBPW2tleV0gPSB2YWx1ZTtcbiAgICBlbHNlIHNldEdsb2JhbChrZXksIHZhbHVlKTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIXVuc2FmZSkge1xuICAgIGRlbGV0ZSBPW2tleV07XG4gIH0gZWxzZSBpZiAoIW5vVGFyZ2V0R2V0ICYmIE9ba2V5XSkge1xuICAgIHNpbXBsZSA9IHRydWU7XG4gIH1cbiAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gIGVsc2UgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KE8sIGtleSwgdmFsdWUpO1xuLy8gYWRkIGZha2UgRnVuY3Rpb24jdG9TdHJpbmcgZm9yIGNvcnJlY3Qgd29yayB3cmFwcGVkIG1ldGhvZHMgLyBjb25zdHJ1Y3RvcnMgd2l0aCBtZXRob2RzIGxpa2UgTG9EYXNoIGlzTmF0aXZlXG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gaXNDYWxsYWJsZSh0aGlzKSAmJiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnNvdXJjZSB8fCBpbnNwZWN0U291cmNlKHRoaXMpO1xufSk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDg4ODU6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG4vLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXJlcXVpcmVvYmplY3Rjb2VyY2libGVcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCA9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiICsgaXQpO1xuICByZXR1cm4gaXQ7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMDc5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgZ2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5ODU5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcy9uby1vYmplY3QtZGVmaW5lcHJvcGVydHkgLS0gc2FmZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShnbG9iYWwsIGtleSwgeyB2YWx1ZTogdmFsdWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdmFsdWU7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0Mzk5OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgc2hhcmVkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMDM2KTtcbnZhciB1aWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0NDEpO1xuXG52YXIga2V5cyA9IHNoYXJlZCgna2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIGtleXNba2V5XSB8fCAoa2V5c1trZXldID0gdWlkKGtleSkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNTM1Mzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIGdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTg1OSk7XG52YXIgc2V0R2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMDc5KTtcblxudmFyIFNIQVJFRCA9ICdfX2NvcmUtanNfc2hhcmVkX18nO1xudmFyIHN0b3JlID0gZ2xvYmFsW1NIQVJFRF0gfHwgc2V0R2xvYmFsKFNIQVJFRCwge30pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMDM2OlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgSVNfUFVSRSA9IF9fd2VicGFja19yZXF1aXJlX18oNDIzMSk7XG52YXIgc3RvcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUzNTMpO1xuXG4obW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiAgdmVyc2lvbjogJzMuMTguMScsXG4gIG1vZGU6IElTX1BVUkUgPyAncHVyZScgOiAnZ2xvYmFsJyxcbiAgY29weXJpZ2h0OiAnwqkgMjAyMSBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAzMjMxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgdG9JbnRlZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDUxKTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBIZWxwZXIgZm9yIGEgcG9wdWxhciByZXBlYXRpbmcgY2FzZSBvZiB0aGUgc3BlYzpcbi8vIExldCBpbnRlZ2VyIGJlID8gVG9JbnRlZ2VyKGluZGV4KS5cbi8vIElmIGludGVnZXIgPCAwLCBsZXQgcmVzdWx0IGJlIG1heCgobGVuZ3RoICsgaW50ZWdlciksIDApOyBlbHNlIGxldCByZXN1bHQgYmUgbWluKGludGVnZXIsIGxlbmd0aCkuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmRleCwgbGVuZ3RoKSB7XG4gIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTtcbiAgcmV0dXJuIGludGVnZXIgPCAwID8gbWF4KGludGVnZXIgKyBsZW5ndGgsIDApIDogbWluKGludGVnZXIsIGxlbmd0aCk7XG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5MDU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbi8vIHRvT2JqZWN0IHdpdGggZmFsbGJhY2sgZm9yIG5vbi1hcnJheS1saWtlIEVTMyBzdHJpbmdzXG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oOTMzNyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODg4NSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDYwNTE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBUb0ludGVnZXJgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy10b2ludGVnZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBpc05hTihhcmd1bWVudCA9ICthcmd1bWVudCkgPyAwIDogKGFyZ3VtZW50ID4gMCA/IGZsb29yIDogY2VpbCkoYXJndW1lbnQpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNDIzNzpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHRvSW50ZWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oNjA1MSk7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtdG9sZW5ndGhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyKGFyZ3VtZW50KSwgMHgxRkZGRkZGRkZGRkZGRikgOiAwOyAvLyAyICoqIDUzIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAyOTkxOlxuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd2VicGFja19yZXF1aXJlX18oODg4NSk7XG5cbi8vIGBUb09iamVjdGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvb2JqZWN0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDIwNjY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oNTA1Mik7XG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzOTUpO1xudmFyIGdldE1ldGhvZCA9IF9fd2VicGFja19yZXF1aXJlX18oNTMwMCk7XG52YXIgb3JkaW5hcnlUb1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjkxNCk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG5cbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJpbWl0aXZlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSB8fCBpc1N5bWJvbChpbnB1dCkpIHJldHVybiBpbnB1dDtcbiAgdmFyIGV4b3RpY1RvUHJpbSA9IGdldE1ldGhvZChpbnB1dCwgVE9fUFJJTUlUSVZFKTtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKGV4b3RpY1RvUHJpbSkge1xuICAgIGlmIChwcmVmID09PSB1bmRlZmluZWQpIHByZWYgPSAnZGVmYXVsdCc7XG4gICAgcmVzdWx0ID0gZXhvdGljVG9QcmltLmNhbGwoaW5wdXQsIHByZWYpO1xuICAgIGlmICghaXNPYmplY3QocmVzdWx0KSB8fCBpc1N5bWJvbChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbiAgfVxuICBpZiAocHJlZiA9PT0gdW5kZWZpbmVkKSBwcmVmID0gJ251bWJlcic7XG4gIHJldHVybiBvcmRpbmFyeVRvUHJpbWl0aXZlKGlucHV0LCBwcmVmKTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDkzMTA6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjA2Nik7XG52YXIgaXNTeW1ib2wgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkzOTUpO1xuXG4vLyBgVG9Qcm9wZXJ0eUtleWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLXRvcHJvcGVydHlrZXlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuICByZXR1cm4gaXNTeW1ib2woa2V5KSA/IGtleSA6IFN0cmluZyhrZXkpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTYwMTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTUpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciB0ZXN0ID0ge307XG5cbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDMzMjY6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBjbGFzc29mID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNTg5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgaWYgKGNsYXNzb2YoYXJndW1lbnQpID09PSAnU3ltYm9sJykgdGhyb3cgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCBhIFN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZycpO1xuICByZXR1cm4gU3RyaW5nKGFyZ3VtZW50KTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDk4MjE6XG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICB0cnkge1xuICAgIHJldHVybiBTdHJpbmcoYXJndW1lbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnT2JqZWN0JztcbiAgfVxufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTQ0MTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbnZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgU3RyaW5nKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArICgrK2lkICsgcG9zdGZpeCkudG9TdHJpbmcoMzYpO1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gNjk2OTpcbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogZXNsaW50LWRpc2FibGUgZXMvbm8tc3ltYm9sIC0tIHJlcXVpcmVkIGZvciB0ZXN0aW5nICovXG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18oMzgzOSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTkFUSVZFX1NZTUJPTFxuICAmJiAhU3ltYm9sLnNoYW1cbiAgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTU6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciBnbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk4NTkpO1xudmFyIHNoYXJlZCA9IF9fd2VicGFja19yZXF1aXJlX18oMzAzNik7XG52YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4MTYpO1xudmFyIHVpZCA9IF9fd2VicGFja19yZXF1aXJlX18oMTQ0MSk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd2VicGFja19yZXF1aXJlX18oMzgzOSk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NjkpO1xuXG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sIDogU3ltYm9sICYmIFN5bWJvbC53aXRob3V0U2V0dGVyIHx8IHVpZDtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICBpZiAoIWhhcyhXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpIHx8ICEoTkFUSVZFX1NZTUJPTCB8fCB0eXBlb2YgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID09ICdzdHJpbmcnKSkge1xuICAgIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhcyhTeW1ib2wsIG5hbWUpKSB7XG4gICAgICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBTeW1ib2xbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IGNyZWF0ZVdlbGxLbm93blN5bWJvbCgnU3ltYm9sLicgKyBuYW1lKTtcbiAgICB9XG4gIH0gcmV0dXJuIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXTtcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIDM0MzA6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd2VicGFja19yZXF1aXJlX18oMzEwMyk7XG52YXIgYUNhbGxhYmxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MTExKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjk5MSk7XG52YXIgdG9MZW5ndGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMzcpO1xudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMzI2KTtcbnZhciBmYWlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNDIyOSk7XG52YXIgaW50ZXJuYWxTb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzODY3KTtcbnZhciBhcnJheU1ldGhvZElzU3RyaWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2MDM4KTtcbnZhciBGRiA9IF9fd2VicGFja19yZXF1aXJlX18oMjY3MSk7XG52YXIgSUVfT1JfRURHRSA9IF9fd2VicGFja19yZXF1aXJlX18oODUwNik7XG52YXIgVjggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzNTgpO1xudmFyIFdFQktJVCA9IF9fd2VicGFja19yZXF1aXJlX18oOTgxMSk7XG5cbnZhciB0ZXN0ID0gW107XG52YXIgbmF0aXZlU29ydCA9IHRlc3Quc29ydDtcblxuLy8gSUU4LVxudmFyIEZBSUxTX09OX1VOREVGSU5FRCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdGVzdC5zb3J0KHVuZGVmaW5lZCk7XG59KTtcbi8vIFY4IGJ1Z1xudmFyIEZBSUxTX09OX05VTEwgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHRlc3Quc29ydChudWxsKTtcbn0pO1xuLy8gT2xkIFdlYktpdFxudmFyIFNUUklDVF9NRVRIT0QgPSBhcnJheU1ldGhvZElzU3RyaWN0KCdzb3J0Jyk7XG5cbnZhciBTVEFCTEVfU09SVCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGZlYXR1cmUgZGV0ZWN0aW9uIGNhbiBiZSB0b28gc2xvdywgc28gY2hlY2sgZW5naW5lcyB2ZXJzaW9uc1xuICBpZiAoVjgpIHJldHVybiBWOCA8IDcwO1xuICBpZiAoRkYgJiYgRkYgPiAzKSByZXR1cm47XG4gIGlmIChJRV9PUl9FREdFKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKFdFQktJVCkgcmV0dXJuIFdFQktJVCA8IDYwMztcblxuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBjb2RlLCBjaHIsIHZhbHVlLCBpbmRleDtcblxuICAvLyBnZW5lcmF0ZSBhbiBhcnJheSB3aXRoIG1vcmUgNTEyIGVsZW1lbnRzIChDaGFrcmEgYW5kIG9sZCBWOCBmYWlscyBvbmx5IGluIHRoaXMgY2FzZSlcbiAgZm9yIChjb2RlID0gNjU7IGNvZGUgPCA3NjsgY29kZSsrKSB7XG4gICAgY2hyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcblxuICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgY2FzZSA2NjogY2FzZSA2OTogY2FzZSA3MDogY2FzZSA3MjogdmFsdWUgPSAzOyBicmVhaztcbiAgICAgIGNhc2UgNjg6IGNhc2UgNzE6IHZhbHVlID0gNDsgYnJlYWs7XG4gICAgICBkZWZhdWx0OiB2YWx1ZSA9IDI7XG4gICAgfVxuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNDc7IGluZGV4KyspIHtcbiAgICAgIHRlc3QucHVzaCh7IGs6IGNociArIGluZGV4LCB2OiB2YWx1ZSB9KTtcbiAgICB9XG4gIH1cblxuICB0ZXN0LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGIudiAtIGEudjsgfSk7XG5cbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGVzdC5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBjaHIgPSB0ZXN0W2luZGV4XS5rLmNoYXJBdCgwKTtcbiAgICBpZiAocmVzdWx0LmNoYXJBdChyZXN1bHQubGVuZ3RoIC0gMSkgIT09IGNocikgcmVzdWx0ICs9IGNocjtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQgIT09ICdER0JFRkhBQ0lKSyc7XG59KTtcblxudmFyIEZPUkNFRCA9IEZBSUxTX09OX1VOREVGSU5FRCB8fCAhRkFJTFNfT05fTlVMTCB8fCAhU1RSSUNUX01FVEhPRCB8fCAhU1RBQkxFX1NPUlQ7XG5cbnZhciBnZXRTb3J0Q29tcGFyZSA9IGZ1bmN0aW9uIChjb21wYXJlZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgaWYgKHkgPT09IHVuZGVmaW5lZCkgcmV0dXJuIC0xO1xuICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHJldHVybiAxO1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgcmV0dXJuICtjb21wYXJlZm4oeCwgeSkgfHwgMDtcbiAgICByZXR1cm4gdG9TdHJpbmcoeCkgPiB0b1N0cmluZyh5KSA/IDEgOiAtMTtcbiAgfTtcbn07XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc29ydGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb3J0XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIGlmIChjb21wYXJlZm4gIT09IHVuZGVmaW5lZCkgYUNhbGxhYmxlKGNvbXBhcmVmbik7XG5cbiAgICB2YXIgYXJyYXkgPSB0b09iamVjdCh0aGlzKTtcblxuICAgIGlmIChTVEFCTEVfU09SVCkgcmV0dXJuIGNvbXBhcmVmbiA9PT0gdW5kZWZpbmVkID8gbmF0aXZlU29ydC5jYWxsKGFycmF5KSA6IG5hdGl2ZVNvcnQuY2FsbChhcnJheSwgY29tcGFyZWZuKTtcblxuICAgIHZhciBpdGVtcyA9IFtdO1xuICAgIHZhciBhcnJheUxlbmd0aCA9IHRvTGVuZ3RoKGFycmF5Lmxlbmd0aCk7XG4gICAgdmFyIGl0ZW1zTGVuZ3RoLCBpbmRleDtcblxuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGFycmF5TGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoaW5kZXggaW4gYXJyYXkpIGl0ZW1zLnB1c2goYXJyYXlbaW5kZXhdKTtcbiAgICB9XG5cbiAgICBpdGVtcyA9IGludGVybmFsU29ydChpdGVtcywgZ2V0U29ydENvbXBhcmUoY29tcGFyZWZuKSk7XG4gICAgaXRlbXNMZW5ndGggPSBpdGVtcy5sZW5ndGg7XG4gICAgaW5kZXggPSAwO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgaXRlbXNMZW5ndGgpIGFycmF5W2luZGV4XSA9IGl0ZW1zW2luZGV4KytdO1xuICAgIHdoaWxlIChpbmRleCA8IGFycmF5TGVuZ3RoKSBkZWxldGUgYXJyYXlbaW5kZXgrK107XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA0NzY5OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cbnZhciAkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMTAzKTtcbnZhciB0b09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjk5MSk7XG52YXIgbmF0aXZlS2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oNTYzMik7XG52YXIgZmFpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyMjkpO1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlS2V5cygxKTsgfSk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLW9iamVjdC5rZXlzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHtcbiAga2V5czogZnVuY3Rpb24ga2V5cyhpdCkge1xuICAgIHJldHVybiBuYXRpdmVLZXlzKHRvT2JqZWN0KGl0KSk7XG4gIH1cbn0pO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyAxMzg4OlxuLyoqKi8gKChtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJaXCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfc291cmNlTWFwc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNzIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfc291cmNlTWFwc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfc291cmNlTWFwc19qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNjA5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX2FwaV9qc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xuLy8gSW1wb3J0c1xuXG5cbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9ub2RlX21vZHVsZXNfY3NzX2xvYWRlcl9kaXN0X3J1bnRpbWVfYXBpX2pzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCgpKChfbm9kZV9tb2R1bGVzX2Nzc19sb2FkZXJfZGlzdF9ydW50aW1lX3NvdXJjZU1hcHNfanNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkpKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qIEJ1dHRvbnMgc3R5bGVzIHN0YXJ0ICovXFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5IHtcXHJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXHJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXHJcXG4gIHotaW5kZXg6IDk5OTtcXHJcXG4gIGJvcmRlci1yYWRpdXM6IDZweDtcXHJcXG4gIGJvcmRlcjogbm9uZTtcXHJcXG4gIC8qYm9yZGVyOiAzcHggc29saWQ7XFxyXFxuICAgIGJvcmRlci1jb2xvcjogd2hpdGU7XFxyXFxuICAgIGJveC1zaGFkb3c6IDAgMCAxMHB4ICNjY2M7Ki9cXHJcXG4gIHBhZGRpbmc6IDFyZW0gMS41cmVtIDFyZW0gNHJlbTtcXHJcXG4gIG1hcmdpbjogMDtcXHJcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXHJcXG4gIGJhY2tncm91bmQ6ICMwMGIyMzM7XFxyXFxuICBjb2xvcjogI2ZmZmZmZjtcXHJcXG4gIGZvbnQtZmFtaWx5OiBzYW5zLXNlcmlmO1xcclxcbiAgZm9udC1zaXplOiAycmVtO1xcclxcbiAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcXHJcXG4gIGxpbmUtaGVpZ2h0OiAxO1xcclxcbiAgY3Vyc29yOiBwb2ludGVyO1xcclxcbiAgdGV4dC1hbGlnbjogY2VudGVyO1xcclxcbiAgdHJhbnNpdGlvbjogYmFja2dyb3VuZCAyNTBtcyBlYXNlLWluLW91dCwgdHJhbnNmb3JtIDE1MG1zIGVhc2U7XFxyXFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxyXFxuICAtbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxyXFxuXFxyXFxuICAtd2Via2l0LWFuaW1hdGlvbjogZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4gMjAwbXM7IC8qIFNhZmFyaSwgQ2hyb21lIGFuZCBPcGVyYSA+IDEyLjEgKi9cXHJcXG4gIC1tb3otYW5pbWF0aW9uOiBleGNhbGlidXItYnV0dG9uLWZhZGVpbiAyMDBtczsgLyogRmlyZWZveCA8IDE2ICovXFxyXFxuICAtbXMtYW5pbWF0aW9uOiBleGNhbGlidXItYnV0dG9uLWZhZGVpbiAyMDBtczsgLyogSW50ZXJuZXQgRXhwbG9yZXIgKi9cXHJcXG4gIC1vLWFuaW1hdGlvbjogZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4gMjAwbXM7IC8qIE9wZXJhIDwgMTIuMSAqL1xcclxcbiAgYW5pbWF0aW9uOiBleGNhbGlidXItYnV0dG9uLWZhZGVpbiAyMDBtcztcXHJcXG59XFxyXFxuXFxyXFxuLypcXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXkge1xcclxcbiAgZGlzcGxheTogbm9uZTtcXHJcXG59Ki9cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6YWZ0ZXIge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgY29udGVudDogJyc7XFxyXFxuICBib3JkZXI6IDhweCBzb2xpZDtcXHJcXG4gIGJvcmRlci1jb2xvcjogdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgd2hpdGU7XFxyXFxuICBsZWZ0OiAzNXB4O1xcclxcbiAgdG9wOiAyNHB4O1xcclxcbiAgd2lkdGg6IDA7XFxyXFxuICBoZWlnaHQ6IDA7XFxyXFxufVxcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTpiZWZvcmUge1xcclxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcclxcbiAgY29udGVudDogJyc7XFxyXFxuICBib3JkZXI6IDNweCBzb2xpZDtcXHJcXG4gIGxlZnQ6IDE5cHg7XFxyXFxuICB0b3A6IDE0cHg7XFxyXFxuICBib3JkZXItcmFkaXVzOiAyMHB4O1xcclxcbiAgd2lkdGg6IDMwcHg7XFxyXFxuICBoZWlnaHQ6IDMwcHg7XFxyXFxufVxcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTpob3ZlcixcXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6Zm9jdXMge1xcclxcbiAgYmFja2dyb3VuZDogIzAwOTgyYztcXHJcXG59XFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmZvY3VzIHtcXHJcXG4gIG91dGxpbmU6IDFweCBzb2xpZCAjZmZmO1xcclxcbiAgb3V0bGluZS1vZmZzZXQ6IC00cHg7XFxyXFxufVxcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTphY3RpdmUge1xcclxcbiAgdHJhbnNmb3JtOiBzY2FsZSgwLjk5KTtcXHJcXG59XFxyXFxuXFxyXFxuQGtleWZyYW1lcyBleGNhbGlidXItYnV0dG9uLWZhZGVpbiB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLyogRmlyZWZveCA8IDE2ICovXFxyXFxuQC1tb3ota2V5ZnJhbWVzIGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKiBTYWZhcmksIENocm9tZSBhbmQgT3BlcmEgPiAxMi4xICovXFxyXFxuQC13ZWJraXQta2V5ZnJhbWVzIGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKiBJbnRlcm5ldCBFeHBsb3JlciAqL1xcclxcbkAtbXMta2V5ZnJhbWVzIGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cXHJcXG4vKiBPcGVyYSA8IDEyLjEgKi9cXHJcXG5ALW8ta2V5ZnJhbWVzIGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIHtcXHJcXG4gIGZyb20ge1xcclxcbiAgICBvcGFjaXR5OiAwO1xcclxcbiAgfVxcclxcbiAgdG8ge1xcclxcbiAgICBvcGFjaXR5OiAxO1xcclxcbiAgfVxcclxcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9Mb2FkZXIuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLHlCQUF5Qjs7QUFFekI7RUFDRSxxQkFBcUI7RUFDckIsa0JBQWtCO0VBQ2xCLFlBQVk7RUFDWixrQkFBa0I7RUFDbEIsWUFBWTtFQUNaOzsrQkFFNkI7RUFDN0IsOEJBQThCO0VBQzlCLFNBQVM7RUFDVCxxQkFBcUI7RUFDckIsbUJBQW1CO0VBQ25CLGNBQWM7RUFDZCx1QkFBdUI7RUFDdkIsZUFBZTtFQUNmLG1CQUFtQjtFQUNuQixjQUFjO0VBQ2QsZUFBZTtFQUNmLGtCQUFrQjtFQUNsQiw4REFBOEQ7RUFDOUQsd0JBQXdCO0VBQ3hCLHFCQUFxQjs7RUFFckIsZ0RBQWdELEVBQUUsb0NBQW9DO0VBQ3RGLDZDQUE2QyxFQUFFLGlCQUFpQjtFQUNoRSw0Q0FBNEMsRUFBRSxzQkFBc0I7RUFDcEUsMkNBQTJDLEVBQUUsaUJBQWlCO0VBQzlELHdDQUF3QztBQUMxQzs7QUFFQTs7O0VBR0U7O0FBRUY7RUFDRSxrQkFBa0I7RUFDbEIsV0FBVztFQUNYLGlCQUFpQjtFQUNqQix1REFBdUQ7RUFDdkQsVUFBVTtFQUNWLFNBQVM7RUFDVCxRQUFRO0VBQ1IsU0FBUztBQUNYOztBQUVBO0VBQ0Usa0JBQWtCO0VBQ2xCLFdBQVc7RUFDWCxpQkFBaUI7RUFDakIsVUFBVTtFQUNWLFNBQVM7RUFDVCxtQkFBbUI7RUFDbkIsV0FBVztFQUNYLFlBQVk7QUFDZDs7QUFFQTs7RUFFRSxtQkFBbUI7QUFDckI7O0FBRUE7RUFDRSx1QkFBdUI7RUFDdkIsb0JBQW9CO0FBQ3RCOztBQUVBO0VBQ0Usc0JBQXNCO0FBQ3hCOztBQUVBO0VBQ0U7SUFDRSxVQUFVO0VBQ1o7RUFDQTtJQUNFLFVBQVU7RUFDWjtBQUNGOztBQUVBLGlCQUFpQjtBQUNqQjtFQUNFO0lBQ0UsVUFBVTtFQUNaO0VBQ0E7SUFDRSxVQUFVO0VBQ1o7QUFDRjs7QUFFQSxvQ0FBb0M7QUFDcEM7RUFDRTtJQUNFLFVBQVU7RUFDWjtFQUNBO0lBQ0UsVUFBVTtFQUNaO0FBQ0Y7O0FBRUEsc0JBQXNCO0FBQ3RCO0VBQ0U7SUFDRSxVQUFVO0VBQ1o7RUFDQTtJQUNFLFVBQVU7RUFDWjtBQUNGOztBQUVBLGlCQUFpQjtBQUNqQjtFQUNFO0lBQ0UsVUFBVTtFQUNaO0VBQ0E7SUFDRSxVQUFVO0VBQ1o7QUFDRlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIvKiBCdXR0b25zIHN0eWxlcyBzdGFydCAqL1xcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheSB7XFxyXFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxyXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxyXFxuICB6LWluZGV4OiA5OTk7XFxyXFxuICBib3JkZXItcmFkaXVzOiA2cHg7XFxyXFxuICBib3JkZXI6IG5vbmU7XFxyXFxuICAvKmJvcmRlcjogM3B4IHNvbGlkO1xcclxcbiAgICBib3JkZXItY29sb3I6IHdoaXRlO1xcclxcbiAgICBib3gtc2hhZG93OiAwIDAgMTBweCAjY2NjOyovXFxyXFxuICBwYWRkaW5nOiAxcmVtIDEuNXJlbSAxcmVtIDRyZW07XFxyXFxuICBtYXJnaW46IDA7XFxyXFxuICB0ZXh0LWRlY29yYXRpb246IG5vbmU7XFxyXFxuICBiYWNrZ3JvdW5kOiAjMDBiMjMzO1xcclxcbiAgY29sb3I6ICNmZmZmZmY7XFxyXFxuICBmb250LWZhbWlseTogc2Fucy1zZXJpZjtcXHJcXG4gIGZvbnQtc2l6ZTogMnJlbTtcXHJcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxyXFxuICBsaW5lLWhlaWdodDogMTtcXHJcXG4gIGN1cnNvcjogcG9pbnRlcjtcXHJcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXHJcXG4gIHRyYW5zaXRpb246IGJhY2tncm91bmQgMjUwbXMgZWFzZS1pbi1vdXQsIHRyYW5zZm9ybSAxNTBtcyBlYXNlO1xcclxcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcclxcbiAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcclxcblxcclxcbiAgLXdlYmtpdC1hbmltYXRpb246IGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIDIwMG1zOyAvKiBTYWZhcmksIENocm9tZSBhbmQgT3BlcmEgPiAxMi4xICovXFxyXFxuICAtbW96LWFuaW1hdGlvbjogZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4gMjAwbXM7IC8qIEZpcmVmb3ggPCAxNiAqL1xcclxcbiAgLW1zLWFuaW1hdGlvbjogZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4gMjAwbXM7IC8qIEludGVybmV0IEV4cGxvcmVyICovXFxyXFxuICAtby1hbmltYXRpb246IGV4Y2FsaWJ1ci1idXR0b24tZmFkZWluIDIwMG1zOyAvKiBPcGVyYSA8IDEyLjEgKi9cXHJcXG4gIGFuaW1hdGlvbjogZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4gMjAwbXM7XFxyXFxufVxcclxcblxcclxcbi8qXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5IHtcXHJcXG4gIGRpc3BsYXk6IG5vbmU7XFxyXFxufSovXFxyXFxuXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmFmdGVyIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGNvbnRlbnQ6ICcnO1xcclxcbiAgYm9yZGVyOiA4cHggc29saWQ7XFxyXFxuICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHdoaXRlO1xcclxcbiAgbGVmdDogMzVweDtcXHJcXG4gIHRvcDogMjRweDtcXHJcXG4gIHdpZHRoOiAwO1xcclxcbiAgaGVpZ2h0OiAwO1xcclxcbn1cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6YmVmb3JlIHtcXHJcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG4gIGNvbnRlbnQ6ICcnO1xcclxcbiAgYm9yZGVyOiAzcHggc29saWQ7XFxyXFxuICBsZWZ0OiAxOXB4O1xcclxcbiAgdG9wOiAxNHB4O1xcclxcbiAgYm9yZGVyLXJhZGl1czogMjBweDtcXHJcXG4gIHdpZHRoOiAzMHB4O1xcclxcbiAgaGVpZ2h0OiAzMHB4O1xcclxcbn1cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6aG92ZXIsXFxyXFxuYnV0dG9uI2V4Y2FsaWJ1ci1wbGF5OmZvY3VzIHtcXHJcXG4gIGJhY2tncm91bmQ6ICMwMDk4MmM7XFxyXFxufVxcclxcblxcclxcbmJ1dHRvbiNleGNhbGlidXItcGxheTpmb2N1cyB7XFxyXFxuICBvdXRsaW5lOiAxcHggc29saWQgI2ZmZjtcXHJcXG4gIG91dGxpbmUtb2Zmc2V0OiAtNHB4O1xcclxcbn1cXHJcXG5cXHJcXG5idXR0b24jZXhjYWxpYnVyLXBsYXk6YWN0aXZlIHtcXHJcXG4gIHRyYW5zZm9ybTogc2NhbGUoMC45OSk7XFxyXFxufVxcclxcblxcclxcbkBrZXlmcmFtZXMgZXhjYWxpYnVyLWJ1dHRvbi1mYWRlaW4ge1xcclxcbiAgZnJvbSB7XFxyXFxuICAgIG9wYWNpdHk6IDA7XFxyXFxuICB9XFxyXFxuICB0byB7XFxyXFxuICAgIG9wYWNpdHk6IDE7XFxyXFxuICB9XFxyXFxufVxcclxcblxcclxcbi8qIEZpcmVmb3ggPCAxNiAqL1xcclxcbkAtbW96LWtleWZyYW1lcyBleGNhbGlidXItYnV0dG9uLWZhZGVpbiB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLyogU2FmYXJpLCBDaHJvbWUgYW5kIE9wZXJhID4gMTIuMSAqL1xcclxcbkAtd2Via2l0LWtleWZyYW1lcyBleGNhbGlidXItYnV0dG9uLWZhZGVpbiB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLyogSW50ZXJuZXQgRXhwbG9yZXIgKi9cXHJcXG5ALW1zLWtleWZyYW1lcyBleGNhbGlidXItYnV0dG9uLWZhZGVpbiB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXFxyXFxuLyogT3BlcmEgPCAxMi4xICovXFxyXFxuQC1vLWtleWZyYW1lcyBleGNhbGlidXItYnV0dG9uLWZhZGVpbiB7XFxyXFxuICBmcm9tIHtcXHJcXG4gICAgb3BhY2l0eTogMDtcXHJcXG4gIH1cXHJcXG4gIHRvIHtcXHJcXG4gICAgb3BhY2l0eTogMTtcXHJcXG4gIH1cXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fID0gKF9fX0NTU19MT0FERVJfRVhQT1JUX19fKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMjYwOTpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdOyAvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuXG4gICAgICBpZiAoaXRlbVs0XSkge1xuICAgICAgICBjb250ZW50ICs9IFwiQHN1cHBvcnRzIChcIi5jb25jYXQoaXRlbVs0XSwgXCIpIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtWzJdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuXG4gICAgICBjb250ZW50ICs9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSk7XG5cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfSkuam9pbihcIlwiKTtcbiAgfTsgLy8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcblxuXG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG5cbiAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXG4gICAgaWYgKGRlZHVwZSkge1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBpZCA9IHRoaXNbX2ldWzBdO1xuXG4gICAgICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICAgICAgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgbW9kdWxlcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19pMl0pO1xuXG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbGF5ZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtWzVdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs1XSA9IGxheWVyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChtZWRpYSkge1xuICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbVsxXSA9IFwiQG1lZGlhIFwiLmNvbmNhdChpdGVtWzJdLCBcIiB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVsyXSA9IG1lZGlhO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxpc3Q7XG59O1xuXG4vKioqLyB9KSxcblxuLyoqKi8gMjcyOlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cbiAgaWYgKCFjc3NNYXBwaW5nKSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cblxuICBpZiAodHlwZW9mIGJ0b2EgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShjc3NNYXBwaW5nKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgdmFyIHNvdXJjZU1hcHBpbmcgPSBcIi8qIyBcIi5jb25jYXQoZGF0YSwgXCIgKi9cIik7XG4gICAgdmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcbiAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKFwiXFxuXCIpO1xuICB9XG5cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gLy8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gdmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXG4vKioqKioqLyAvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi8gXG4vKioqKioqLyBcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovIFxuLyoqKioqKi8gXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyB9XG4vKioqKioqLyBcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAvKiB3ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG4vKioqKioqLyBcdFx0XHQoKSA9PiAobW9kdWxlKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzICovXG4vKioqKioqLyAoKCkgPT4ge1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG4vKioqKioqLyBcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2dsb2JhbCAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuLyoqKioqKi8gXHRcdHRyeSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbi8qKioqKiovIFx0XHR9IGNhdGNoIChlKSB7XG4vKioqKioqLyBcdFx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gfSkoKTtcbi8qKioqKiovIFxuLyoqKioqKi8gLyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gKCgpID0+IHtcbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqLyB9KSgpO1xuLyoqKioqKi8gXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4oKCkgPT4ge1xuXG4vLyBFWFBPUlRTXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xuICBcImZXblwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWN0aW9uQ29udGV4dCksXG4gIFwiSWE4XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBY3Rpb25RdWV1ZSksXG4gIFwiaExJXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBY3Rpb25zQ29tcG9uZW50KSxcbiAgXCJ5eXZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFjdGlvbnNTeXN0ZW0pLFxuICBcInRYNVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQWN0aXZhdGVFdmVudCksXG4gIFwidnRYXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBY3RvciksXG4gIFwicjdLXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBZGRlZENvbXBvbmVudCksXG4gIFwibENoXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBZGRlZEVudGl0eSksXG4gIFwiZndGXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBbmltYXRpb24pLFxuICBcInNjZVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQW5pbWF0aW9uRGlyZWN0aW9uKSxcbiAgXCJfYzdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFuaW1hdGlvblN0cmF0ZWd5KSxcbiAgXCJLVXNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEFyY2FkZVNvbHZlciksXG4gIFwiQWpwXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBBdWRpb0NvbnRleHRGYWN0b3J5KSxcbiAgXCJSRGhcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEF4aXMpLFxuICBcIl9IOVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQmFzZUFsaWduKSxcbiAgXCJVbGZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEJpbmFyeVRyZWVOb2RlKSxcbiAgXCJteHNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEJsaW5rKSxcbiAgXCJPbURcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEJvZHlDb21wb25lbnQpLFxuICBcImtCZlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQm91bmRpbmdCb3gpLFxuICBcIkM0RlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQnJvYWRwaGFzZVN0cmF0ZWd5KSxcbiAgXCJOUXRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEJyb3dzZXJDb21wb25lbnQpLFxuICBcIkpqTlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQnJvd3NlckV2ZW50cyksXG4gIFwiVjFzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDYW1lcmEpLFxuICBcIlh6N1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ2FudmFzKSxcbiAgXCJiTGRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENlbGwpLFxuICBcIkNkY1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ2lyY2xlKSxcbiAgXCJGS25cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENpcmNsZUNvbGxpZGVyKSxcbiAgXCJ3VFdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENsYXNzKSxcbiAgXCJhYjJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENsb3Nlc3RMaW5lKSxcbiAgXCJHZlpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENsb3Nlc3RMaW5lSnVtcFRhYmxlKSxcbiAgXCJZTVNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpZGVyKSxcbiAgXCJveXZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpZGVyQ29tcG9uZW50KSxcbiAgXCJhVWJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvbkNvbnRhY3QpLFxuICBcIlNkRFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uRW5kRXZlbnQpLFxuICBcIkpVdlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uR3JvdXApLFxuICBcImpFalwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uR3JvdXBNYW5hZ2VyKSxcbiAgXCJURnFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvbkp1bXBUYWJsZSksXG4gIFwiSERVXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaXNpb25Qb3N0U29sdmVFdmVudCksXG4gIFwiUl95XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaXNpb25QcmVTb2x2ZUV2ZW50KSxcbiAgXCJ5ZE5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSksXG4gIFwiX04yXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaXNpb25Tb2x2ZXIpLFxuICBcInQ1MFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uU3RhcnRFdmVudCksXG4gIFwicyQkXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xsaXNpb25TeXN0ZW0pLFxuICBcInYyR1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29sbGlzaW9uVHlwZSksXG4gIFwiSWxrXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xvciksXG4gIFwiSF85XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xvckJsaW5kQ29ycmVjdG9yKSxcbiAgXCJzOWlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbG9yQmxpbmRGbGFncyksXG4gIFwia3NsXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb2xvckJsaW5kbmVzcyksXG4gIFwid0EyXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb21wb25lbnQpLFxuICBcIlJfcFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29tcG9zaXRlQ29sbGlkZXIpLFxuICBcIklRJFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gQ29uZmlndXJhYmxlKSxcbiAgXCJJNUZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbnNvbGVBcHBlbmRlciksXG4gIFwiWDgkXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb250YWN0Q29uc3RyYWludFBvaW50KSxcbiAgXCJGUjZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIENvbnRhY3RFbmRFdmVudCksXG4gIFwiVThvXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb250YWN0U3RhcnRFdmVudCksXG4gIFwia2JHXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBDb29yZFBsYW5lKSxcbiAgXCJvZUpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEN1bGxpbmdCb3gpLFxuICBcImlTX1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGVhY3RpdmF0ZUV2ZW50KSxcbiAgXCJjR0dcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERlYnVnKSxcbiAgXCJza2JcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERlYnVnU3lzdGVtKSxcbiAgXCJTTFVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERlYnVnVGV4dCksXG4gIFwiUmRKXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEZWdyZWVPZkZyZWVkb20pLFxuICBcImdVN1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGV0ZWN0b3IpLFxuICBcIkxTa1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRGllKSxcbiAgXCJObXBcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERpcmVjdGlvbiksXG4gIFwiZDFZXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEaXNwbGF5TW9kZSksXG4gIFwieHJMXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEeW5hbWljVHJlZSksXG4gIFwic1JXXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBEeW5hbWljVHJlZUNvbGxpc2lvblByb2Nlc3NvciksXG4gIFwiY21WXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIEVYX1ZFUlNJT04pLFxuICBcIk4wUVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRWFzZVRvKSxcbiAgXCJxOGJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVhc2luZ0Z1bmN0aW9ucyksXG4gIFwieW5CXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFZGdlQ29sbGlkZXIpLFxuICBcImpUOVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRWxhc3RpY1RvQWN0b3JTdHJhdGVneSksXG4gIFwid0F6XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFbWl0dGVyVHlwZSksXG4gIFwiRDRWXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFbmdpbmUpLFxuICBcIk42SFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRW50ZXJUcmlnZ2VyRXZlbnQpLFxuICBcIlcxQVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRW50ZXJWaWV3UG9ydEV2ZW50KSxcbiAgXCJKSFdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEVudGl0eSksXG4gIFwidjJLXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFbnRpdHlNYW5hZ2VyKSxcbiAgXCJwQmZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEV2ZW50RGlzcGF0Y2hlciksXG4gIFwiR01sXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFdmVudFR5cGVzKSxcbiAgXCJ6VzJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEV2ZW50c19uYW1lc3BhY2VPYmplY3QpLFxuICBcIkIwS1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRXhSZXNwb25zZSksXG4gIFwiTnY3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhcyksXG4gIFwiQ19wXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHRXZWJHTCksXG4gIFwiTVVBXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBFeGl0VHJpZ2dlckV2ZW50KSxcbiAgXCJ4cVVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEV4aXRWaWV3UG9ydEV2ZW50KSxcbiAgXCJwZUdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEV4cGVyaW1lbnRzKSxcbiAgXCJwVHBcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZhZGUpLFxuICBcInZVS1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRmxhZ3MpLFxuICBcImo5bFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRm9sbG93KSxcbiAgXCJaeHdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZvbnQpLFxuICBcIkhkeFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gRm9udFN0eWxlKSxcbiAgXCJaJGRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZvbnRVbml0KSxcbiAgXCJvJDdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEZyYW1lU3RhdHMpLFxuICBcIlptJFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR2FtZUV2ZW50KSxcbiAgXCIkUUhcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdhbWVTdGFydEV2ZW50KSxcbiAgXCJpNzhcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdhbWVTdG9wRXZlbnQpLFxuICBcImg2dVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR2FtZXBhZEF4aXNFdmVudCksXG4gIFwiaHRzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHYW1lcGFkQnV0dG9uRXZlbnQpLFxuICBcImo4OFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR2FtZXBhZENvbm5lY3RFdmVudCksXG4gIFwiVk1FXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHYW1lcGFkRGlzY29ubmVjdEV2ZW50KSxcbiAgXCJudFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR2lmKSxcbiAgXCJVa3JcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdsb2JhbENvb3JkaW5hdGVzKSxcbiAgXCJ6c3VcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdyYXBoaWMpLFxuICBcIm9BNlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR3JhcGhpY3NDb21wb25lbnQpLFxuICBcIlRWaFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gR3JhcGhpY3NHcm91cCksXG4gIFwiVHdaXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBHcmFwaGljc0xheWVyKSxcbiAgXCJHVFRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdyYXBoaWNzTGF5ZXJzKSxcbiAgXCJ4eGpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEdyYXBoaWNzU3lzdGVtKSxcbiAgXCJYZEtcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEhpZGRlbkV2ZW50KSxcbiAgXCJjWG9cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEltYWdlU291cmNlKSxcbiAgXCJEbTVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIEluaXRpYWxpemVFdmVudCksXG4gIFwiSUlCXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBJbnB1dF9JbmRleF9uYW1lc3BhY2VPYmplY3QpLFxuICBcInpJMFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gSW50ZWdyYXRvciksXG4gIFwiU0taXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBLaWxsRXZlbnQpLFxuICBcIl9fSlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTGFiZWxfTGFiZWwpLFxuICBcIkR2clwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTGVnYWN5KSxcbiAgXCJUZjlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIERyYXdpbmdfSW5kZXhfbmFtZXNwYWNlT2JqZWN0KSxcbiAgXCJSSSRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIExpbWl0Q2FtZXJhQm91bmRzU3RyYXRlZ3kpLFxuICBcIngxMlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTGluZSksXG4gIFwiYU53XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBMb2FkZXIpLFxuICBcInh3blwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3kpLFxuICBcImROS1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTG9ja0NhbWVyYVRvQWN0b3JTdHJhdGVneSksXG4gIFwiaW5pXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBMb2dMZXZlbCksXG4gIFwiWWRIXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBMb2dnZXIpLFxuICBcInkzR1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTWF0cml4KSxcbiAgXCJsNTdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1hdHJpeExvY2F0aW9ucyksXG4gIFwieG4wXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNZWRpYUV2ZW50KSxcbiAgXCJ0MlZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1lZXQpLFxuICBcIlp5U1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTW9ja2VkRWxlbWVudCksXG4gIFwidXhCXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNb3Rpb25Db21wb25lbnQpLFxuICBcImNwZFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTW90aW9uU3lzdGVtKSxcbiAgXCJmaXlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE1vdmVCeSksXG4gIFwiJFhaXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBNb3ZlVG8pLFxuICBcInVxS1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gTmF0aXZlU291bmRFdmVudCksXG4gIFwiU1RFXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBOYXRpdmVTb3VuZFByb2Nlc3NlZEV2ZW50KSxcbiAgXCJ5JHpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIE9ic2VydmFibGUpLFxuICBcInNPcVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGFpciksXG4gIFwiU3FzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQYXJzZUdpZiksXG4gIFwiaHBaXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQYXJ0aWNsZSksXG4gIFwiVm9sXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQYXJ0aWNsZUVtaXR0ZXIpLFxuICBcIndJWlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUGh5c2ljcyksXG4gIFwiY0JpXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQaHlzaWNzU3RhdHMpLFxuICBcIm1ncVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUG9seWdvbl9Qb2x5Z29uKSxcbiAgXCJZVkFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBvbHlnb25Db2xsaWRlciksXG4gIFwiS2dwXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb29sKSxcbiAgXCJISCRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBvc3RDb2xsaXNpb25FdmVudCksXG4gIFwiTV9kXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb3N0RGVidWdEcmF3RXZlbnQpLFxuICBcInJnaFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUG9zdERyYXdFdmVudCksXG4gIFwiUmE2XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb3N0RnJhbWVFdmVudCksXG4gIFwiS2hSXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQb3N0S2lsbEV2ZW50KSxcbiAgXCJCUzVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFBvc3RVcGRhdGVFdmVudCksXG4gIFwieGh6XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcmVDb2xsaXNpb25FdmVudCksXG4gIFwieE9xXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcmVEZWJ1Z0RyYXdFdmVudCksXG4gIFwiYTlqXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcmVEcmF3RXZlbnQpLFxuICBcImJIa1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUHJlRnJhbWVFdmVudCksXG4gIFwiQ2dLXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcmVLaWxsRXZlbnQpLFxuICBcImN1WVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUHJlVXBkYXRlRXZlbnQpLFxuICBcImt2RVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUHJvamVjdGlvbiksXG4gIFwiSkRiXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBQcm9taXNlc19Qcm9taXNlKSxcbiAgXCJDYmlcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFByb21pc2VTdGF0ZSksXG4gIFwiQUVfXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBRdWVyeSksXG4gIFwiY3RPXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBRdWVyeU1hbmFnZXIpLFxuICBcIk9MSFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneSksXG4gIFwia2t5XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSYW5kb20pLFxuICBcIm5TRlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmFzdGVyKSxcbiAgXCJ6SG5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJheSksXG4gIFwiend4XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSZWFsaXN0aWNTb2x2ZXIpLFxuICBcIkFlSlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmVjdGFuZ2xlKSxcbiAgXCJoTHpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlbW92ZWRDb21wb25lbnQpLFxuICBcIkQ5Z1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmVtb3ZlZEVudGl0eSksXG4gIFwid0FcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlcGVhdCksXG4gIFwiamhyXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBSZXBlYXRGb3JldmVyKSxcbiAgXCJHVnNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFJlc29sdXRpb24pLFxuICBcIl96T1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUmVzb3VyY2UpLFxuICBcInc2JFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUm90YXRlQnkpLFxuICBcIm1oVlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUm90YXRlVG8pLFxuICBcIk1PRFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gUm90YXRpb25UeXBlKSxcbiAgXCJrd2RcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNjYWxlQnkpLFxuICBcIkxtclwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2NhbGVUbyksXG4gIFwieHNTXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTY2VuZSksXG4gIFwibExyXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTY3JlZW4pLFxuICBcIlokclwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2NyZWVuQXBwZW5kZXIpLFxuICBcIklYYlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU2NyZWVuRWxlbWVudF9TY3JlZW5FbGVtZW50KSxcbiAgXCJTTWpcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNjcm9sbFByZXZlbnRpb25Nb2RlKSxcbiAgXCJibkZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNoYXBlKSxcbiAgXCJNRkFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNpZGUpLFxuICBcIiRYQ1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU29ydGVkTGlzdCksXG4gIFwiJHVVXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTb3VuZCksXG4gIFwianlpXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTcHJpdGUpLFxuICBcIkUwM1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3ByaXRlRm9udF9TcHJpdGVGb250KSxcbiAgXCJWNnFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFNwcml0ZVNoZWV0KSxcbiAgXCJuVm9cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFN0cmF0ZWd5Q29udGFpbmVyKSxcbiAgXCJGNk5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFN0cmVhbSksXG4gIFwiYWQzXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTdWJzY3JpYmVFdmVudCksXG4gIFwieFA3XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTeXN0ZW0pLFxuICBcIk9kcVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gU3lzdGVtTWFuYWdlciksXG4gIFwiWmlmXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBTeXN0ZW1UeXBlKSxcbiAgXCJaR0pcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRhZ0NvbXBvbmVudCksXG4gIFwieHZUXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUZXh0KSxcbiAgXCJQSE1cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRleHRBbGlnbiksXG4gIFwiS3dPXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBUaWxlTWFwKSxcbiAgXCJCN3lcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRpbWVyKSxcbiAgXCJTRnBcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRyYWl0c19JbmRleF9uYW1lc3BhY2VPYmplY3QpLFxuICBcIlV2blwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gVHJhbnNmb3JtQ29tcG9uZW50KSxcbiAgXCJPRlRcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRyZWVOb2RlKSxcbiAgXCJ4ek5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFRyaWdnZXJfVHJpZ2dlciksXG4gIFwiSDZqXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBVbnN1YnNjcmliZUV2ZW50KSxcbiAgXCJack5cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFV0aWxfSW5kZXhfbmFtZXNwYWNlT2JqZWN0KSxcbiAgXCJPV3NcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFZlY3RvciksXG4gIFwiZEY5XCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBWZWN0b3JWaWV3KSxcbiAgXCJWSG9cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFZpc2libGVFdmVudCksXG4gIFwiUiRFXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBXZWJBdWRpb0luc3RhbmNlKSxcbiAgXCJxM0lcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIFdvcmxkKSxcbiAgXCJQYWJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGNhbm9uaWNhbGl6ZUFuZ2xlKSxcbiAgXCJ1WjVcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGNsYW1wKSxcbiAgXCJNY0tcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGNyZWF0ZUlkKSxcbiAgXCJrMGJcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc0dyYXBoaWNzVGljayksXG4gIFwiaG5UXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBoYXNPbkluaXRpYWxpemUpLFxuICBcIlJTSlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaGFzT25Qb3N0VXBkYXRlKSxcbiAgXCJNa3VcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc09uUHJlVXBkYXRlKSxcbiAgXCJoOTBcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc1Bvc3REcmF3KSxcbiAgXCJybXNcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGhhc1ByZURyYXcpLFxuICBcIkVyUFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaGFzX2luaXRpYWxpemUpLFxuICBcImFWZ1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaGFzX3Bvc3R1cGRhdGUpLFxuICBcImxQY1wiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaGFzX3ByZXVwZGF0ZSksXG4gIFwiWjhFXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyBpc0FkZGVkQ29tcG9uZW50KSxcbiAgXCJOTkFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIGlzQWRkZWRTeXN0ZW1FbnRpdHkpLFxuICBcInlGblwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaXNSZW1vdmVTeXN0ZW1FbnRpdHkpLFxuICBcImxOdlwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gaXNSZW1vdmVkQ29tcG9uZW50KSxcbiAgXCJNWlFcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIG1heE1lc3NhZ2VzKSxcbiAgXCJGVU1cIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIG9ic29sZXRlKSxcbiAgXCJ2ZGZcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHJhbmRvbUluUmFuZ2UpLFxuICBcImlhTFwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gcmFuZG9tSW50SW5SYW5nZSksXG4gIFwidzZIXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyByYW5nZSksXG4gIFwiUTRjXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyByZXNldE9ic29sZXRlQ291bnRlciksXG4gIFwiVXhiXCI6ICgpID0+ICgvKiByZWV4cG9ydCAqLyB0b0RlZ3JlZXMpLFxuICBcIllyNVwiOiAoKSA9PiAoLyogcmVleHBvcnQgKi8gdG9SYWRpYW5zKSxcbiAgXCJCaHdcIjogKCkgPT4gKC8qIHJlZXhwb3J0ICovIHZlYylcbn0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL0V2ZW50cy50c1xudmFyIEV2ZW50c19uYW1lc3BhY2VPYmplY3QgPSB7fTtcbl9fd2VicGFja19yZXF1aXJlX18ucihFdmVudHNfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChFdmVudHNfbmFtZXNwYWNlT2JqZWN0LCB7XG4gIFwiQWN0aXZhdGVFdmVudFwiOiAoKSA9PiAoQWN0aXZhdGVFdmVudCksXG4gIFwiQ29sbGlzaW9uRW5kRXZlbnRcIjogKCkgPT4gKENvbGxpc2lvbkVuZEV2ZW50KSxcbiAgXCJDb2xsaXNpb25Qb3N0U29sdmVFdmVudFwiOiAoKSA9PiAoQ29sbGlzaW9uUG9zdFNvbHZlRXZlbnQpLFxuICBcIkNvbGxpc2lvblByZVNvbHZlRXZlbnRcIjogKCkgPT4gKENvbGxpc2lvblByZVNvbHZlRXZlbnQpLFxuICBcIkNvbGxpc2lvblN0YXJ0RXZlbnRcIjogKCkgPT4gKENvbGxpc2lvblN0YXJ0RXZlbnQpLFxuICBcIkNvbnRhY3RFbmRFdmVudFwiOiAoKSA9PiAoQ29udGFjdEVuZEV2ZW50KSxcbiAgXCJDb250YWN0U3RhcnRFdmVudFwiOiAoKSA9PiAoQ29udGFjdFN0YXJ0RXZlbnQpLFxuICBcIkRlYWN0aXZhdGVFdmVudFwiOiAoKSA9PiAoRGVhY3RpdmF0ZUV2ZW50KSxcbiAgXCJFbnRlclRyaWdnZXJFdmVudFwiOiAoKSA9PiAoRW50ZXJUcmlnZ2VyRXZlbnQpLFxuICBcIkVudGVyVmlld1BvcnRFdmVudFwiOiAoKSA9PiAoRW50ZXJWaWV3UG9ydEV2ZW50KSxcbiAgXCJFdmVudFR5cGVzXCI6ICgpID0+IChFdmVudFR5cGVzKSxcbiAgXCJFeGl0VHJpZ2dlckV2ZW50XCI6ICgpID0+IChFeGl0VHJpZ2dlckV2ZW50KSxcbiAgXCJFeGl0Vmlld1BvcnRFdmVudFwiOiAoKSA9PiAoRXhpdFZpZXdQb3J0RXZlbnQpLFxuICBcIkdhbWVFdmVudFwiOiAoKSA9PiAoR2FtZUV2ZW50KSxcbiAgXCJHYW1lU3RhcnRFdmVudFwiOiAoKSA9PiAoR2FtZVN0YXJ0RXZlbnQpLFxuICBcIkdhbWVTdG9wRXZlbnRcIjogKCkgPT4gKEdhbWVTdG9wRXZlbnQpLFxuICBcIkdhbWVwYWRBeGlzRXZlbnRcIjogKCkgPT4gKEdhbWVwYWRBeGlzRXZlbnQpLFxuICBcIkdhbWVwYWRCdXR0b25FdmVudFwiOiAoKSA9PiAoR2FtZXBhZEJ1dHRvbkV2ZW50KSxcbiAgXCJHYW1lcGFkQ29ubmVjdEV2ZW50XCI6ICgpID0+IChHYW1lcGFkQ29ubmVjdEV2ZW50KSxcbiAgXCJHYW1lcGFkRGlzY29ubmVjdEV2ZW50XCI6ICgpID0+IChHYW1lcGFkRGlzY29ubmVjdEV2ZW50KSxcbiAgXCJIaWRkZW5FdmVudFwiOiAoKSA9PiAoSGlkZGVuRXZlbnQpLFxuICBcIkluaXRpYWxpemVFdmVudFwiOiAoKSA9PiAoSW5pdGlhbGl6ZUV2ZW50KSxcbiAgXCJLaWxsRXZlbnRcIjogKCkgPT4gKEtpbGxFdmVudCksXG4gIFwiUG9zdENvbGxpc2lvbkV2ZW50XCI6ICgpID0+IChQb3N0Q29sbGlzaW9uRXZlbnQpLFxuICBcIlBvc3REZWJ1Z0RyYXdFdmVudFwiOiAoKSA9PiAoUG9zdERlYnVnRHJhd0V2ZW50KSxcbiAgXCJQb3N0RHJhd0V2ZW50XCI6ICgpID0+IChQb3N0RHJhd0V2ZW50KSxcbiAgXCJQb3N0RnJhbWVFdmVudFwiOiAoKSA9PiAoUG9zdEZyYW1lRXZlbnQpLFxuICBcIlBvc3RLaWxsRXZlbnRcIjogKCkgPT4gKFBvc3RLaWxsRXZlbnQpLFxuICBcIlBvc3RVcGRhdGVFdmVudFwiOiAoKSA9PiAoUG9zdFVwZGF0ZUV2ZW50KSxcbiAgXCJQcmVDb2xsaXNpb25FdmVudFwiOiAoKSA9PiAoUHJlQ29sbGlzaW9uRXZlbnQpLFxuICBcIlByZURlYnVnRHJhd0V2ZW50XCI6ICgpID0+IChQcmVEZWJ1Z0RyYXdFdmVudCksXG4gIFwiUHJlRHJhd0V2ZW50XCI6ICgpID0+IChQcmVEcmF3RXZlbnQpLFxuICBcIlByZUZyYW1lRXZlbnRcIjogKCkgPT4gKFByZUZyYW1lRXZlbnQpLFxuICBcIlByZUtpbGxFdmVudFwiOiAoKSA9PiAoUHJlS2lsbEV2ZW50KSxcbiAgXCJQcmVVcGRhdGVFdmVudFwiOiAoKSA9PiAoUHJlVXBkYXRlRXZlbnQpLFxuICBcIlN1YnNjcmliZUV2ZW50XCI6ICgpID0+IChTdWJzY3JpYmVFdmVudCksXG4gIFwiVW5zdWJzY3JpYmVFdmVudFwiOiAoKSA9PiAoVW5zdWJzY3JpYmVFdmVudCksXG4gIFwiVmlzaWJsZUV2ZW50XCI6ICgpID0+IChWaXNpYmxlRXZlbnQpXG59KTtcblxuLy8gTkFNRVNQQUNFIE9CSkVDVDogLi9EcmF3aW5nL1Nwcml0ZUVmZmVjdHMudHNcbnZhciBTcHJpdGVFZmZlY3RzX25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKFNwcml0ZUVmZmVjdHNfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChTcHJpdGVFZmZlY3RzX25hbWVzcGFjZU9iamVjdCwge1xuICBcIkNvbG9yaXplXCI6ICgpID0+IChDb2xvcml6ZSksXG4gIFwiRGFya2VuXCI6ICgpID0+IChEYXJrZW4pLFxuICBcIkRlc2F0dXJhdGVcIjogKCkgPT4gKERlc2F0dXJhdGUpLFxuICBcIkZpbGxcIjogKCkgPT4gKEZpbGwpLFxuICBcIkdyYXlzY2FsZVwiOiAoKSA9PiAoR3JheXNjYWxlKSxcbiAgXCJJbnZlcnRcIjogKCkgPT4gKEludmVydCksXG4gIFwiTGlnaHRlblwiOiAoKSA9PiAoTGlnaHRlbiksXG4gIFwiT3BhY2l0eVwiOiAoKSA9PiAoT3BhY2l0eSksXG4gIFwiU2F0dXJhdGVcIjogKCkgPT4gKFNhdHVyYXRlKVxufSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vVXRpbC9EcmF3VXRpbC50c1xudmFyIERyYXdVdGlsX25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKERyYXdVdGlsX25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoRHJhd1V0aWxfbmFtZXNwYWNlT2JqZWN0LCB7XG4gIFwiY2lyY2xlXCI6ICgpID0+IChjaXJjbGUpLFxuICBcImxpbmVcIjogKCkgPT4gKGxpbmUpLFxuICBcInBvaW50XCI6ICgpID0+IChwb2ludCksXG4gIFwicm91bmRSZWN0XCI6ICgpID0+IChyb3VuZFJlY3QpLFxuICBcInZlY3RvclwiOiAoKSA9PiAodmVjdG9yKVxufSk7XG5cbi8vIE5BTUVTUEFDRSBPQkpFQ1Q6IC4vRHJhd2luZy9JbmRleC50c1xudmFyIERyYXdpbmdfSW5kZXhfbmFtZXNwYWNlT2JqZWN0ID0ge307XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoRHJhd2luZ19JbmRleF9uYW1lc3BhY2VPYmplY3QpO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kKERyYXdpbmdfSW5kZXhfbmFtZXNwYWNlT2JqZWN0LCB7XG4gIFwiQW5pbWF0aW9uXCI6ICgpID0+IChBbmltYXRpb25fQW5pbWF0aW9uKSxcbiAgXCJDYW52YXNEcmF3Q29tcG9uZW50XCI6ICgpID0+IChDYW52YXNEcmF3Q29tcG9uZW50KSxcbiAgXCJDYW52YXNEcmF3aW5nU3lzdGVtXCI6ICgpID0+IChDYW52YXNEcmF3aW5nU3lzdGVtKSxcbiAgXCJFZmZlY3RzXCI6ICgpID0+IChTcHJpdGVFZmZlY3RzX25hbWVzcGFjZU9iamVjdCksXG4gIFwiUG9seWdvblwiOiAoKSA9PiAoUG9seWdvbiksXG4gIFwiU3ByaXRlXCI6ICgpID0+IChTcHJpdGVfU3ByaXRlKSxcbiAgXCJTcHJpdGVGb250XCI6ICgpID0+IChTcHJpdGVGb250KSxcbiAgXCJTcHJpdGVTaGVldFwiOiAoKSA9PiAoU3ByaXRlU2hlZXRfU3ByaXRlU2hlZXQpLFxuICBcIlRleHR1cmVcIjogKCkgPT4gKFRleHR1cmUpXG59KTtcblxuLy8gTkFNRVNQQUNFIE9CSkVDVDogLi9JbnB1dC9JbmRleC50c1xudmFyIElucHV0X0luZGV4X25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKElucHV0X0luZGV4X25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoSW5wdXRfSW5kZXhfbmFtZXNwYWNlT2JqZWN0LCB7XG4gIFwiQXhlc1wiOiAoKSA9PiAoQXhlcyksXG4gIFwiQnV0dG9uc1wiOiAoKSA9PiAoQnV0dG9ucyksXG4gIFwiR2FtZXBhZFwiOiAoKSA9PiAoR2FtZXBhZCksXG4gIFwiR2FtZXBhZHNcIjogKCkgPT4gKEdhbWVwYWRzKSxcbiAgXCJLZXlFdmVudFwiOiAoKSA9PiAoS2V5RXZlbnQpLFxuICBcIktleWJvYXJkXCI6ICgpID0+IChLZXlib2FyZCksXG4gIFwiS2V5c1wiOiAoKSA9PiAoS2V5cyksXG4gIFwiTmF0aXZlUG9pbnRlckJ1dHRvblwiOiAoKSA9PiAoTmF0aXZlUG9pbnRlckJ1dHRvbiksXG4gIFwiUG9pbnRlclwiOiAoKSA9PiAoUG9pbnRlciksXG4gIFwiUG9pbnRlckJ1dHRvblwiOiAoKSA9PiAoUG9pbnRlckJ1dHRvbiksXG4gIFwiUG9pbnRlckNhbmNlbEV2ZW50XCI6ICgpID0+IChQb2ludGVyQ2FuY2VsRXZlbnQpLFxuICBcIlBvaW50ZXJEb3duRXZlbnRcIjogKCkgPT4gKFBvaW50ZXJEb3duRXZlbnQpLFxuICBcIlBvaW50ZXJEcmFnRXZlbnRcIjogKCkgPT4gKFBvaW50ZXJEcmFnRXZlbnQpLFxuICBcIlBvaW50ZXJFbnRlckV2ZW50XCI6ICgpID0+IChQb2ludGVyRW50ZXJFdmVudCksXG4gIFwiUG9pbnRlckV2ZW50XCI6ICgpID0+IChQb2ludGVyRXZlbnQpLFxuICBcIlBvaW50ZXJFdmVudEZhY3RvcnlcIjogKCkgPT4gKFBvaW50ZXJFdmVudEZhY3RvcnkpLFxuICBcIlBvaW50ZXJMZWF2ZUV2ZW50XCI6ICgpID0+IChQb2ludGVyTGVhdmVFdmVudCksXG4gIFwiUG9pbnRlck1vdmVFdmVudFwiOiAoKSA9PiAoUG9pbnRlck1vdmVFdmVudCksXG4gIFwiUG9pbnRlclNjb3BlXCI6ICgpID0+IChQb2ludGVyU2NvcGUpLFxuICBcIlBvaW50ZXJUeXBlXCI6ICgpID0+IChQb2ludGVyVHlwZSksXG4gIFwiUG9pbnRlclVwRXZlbnRcIjogKCkgPT4gKFBvaW50ZXJVcEV2ZW50KSxcbiAgXCJQb2ludGVyc1wiOiAoKSA9PiAoUG9pbnRlcnMpLFxuICBcIldoZWVsRGVsdGFNb2RlXCI6ICgpID0+IChXaGVlbERlbHRhTW9kZSksXG4gIFwiV2hlZWxFdmVudFwiOiAoKSA9PiAoV2hlZWxFdmVudCksXG4gIFwiY3JlYXRlUG9pbnRlckV2ZW50QnlOYW1lXCI6ICgpID0+IChjcmVhdGVQb2ludGVyRXZlbnRCeU5hbWUpXG59KTtcblxuLy8gTkFNRVNQQUNFIE9CSkVDVDogLi9UcmFpdHMvSW5kZXgudHNcbnZhciBUcmFpdHNfSW5kZXhfbmFtZXNwYWNlT2JqZWN0ID0ge307XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoVHJhaXRzX0luZGV4X25hbWVzcGFjZU9iamVjdCk7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQoVHJhaXRzX0luZGV4X25hbWVzcGFjZU9iamVjdCwge1xuICBcIkNhcHR1cmVQb2ludGVyXCI6ICgpID0+IChDYXB0dXJlUG9pbnRlciksXG4gIFwiT2Zmc2NyZWVuQ3VsbGluZ1wiOiAoKSA9PiAoT2Zmc2NyZWVuQ3VsbGluZylcbn0pO1xuXG4vLyBOQU1FU1BBQ0UgT0JKRUNUOiAuL1V0aWwvSW5kZXgudHNcbnZhciBVdGlsX0luZGV4X25hbWVzcGFjZU9iamVjdCA9IHt9O1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKFV0aWxfSW5kZXhfbmFtZXNwYWNlT2JqZWN0KTtcbl9fd2VicGFja19yZXF1aXJlX18uZChVdGlsX0luZGV4X25hbWVzcGFjZU9iamVjdCwge1xuICBcIkNvbGxlY3Rpb25cIjogKCkgPT4gKENvbGxlY3Rpb24pLFxuICBcIkNvbnNvbGVBcHBlbmRlclwiOiAoKSA9PiAoQ29uc29sZUFwcGVuZGVyKSxcbiAgXCJEcmF3VXRpbFwiOiAoKSA9PiAoRHJhd1V0aWxfbmFtZXNwYWNlT2JqZWN0KSxcbiAgXCJFYXNpbmdGdW5jdGlvbnNcIjogKCkgPT4gKEVhc2luZ0Z1bmN0aW9ucyksXG4gIFwiTG9nTGV2ZWxcIjogKCkgPT4gKExvZ0xldmVsKSxcbiAgXCJMb2dnZXJcIjogKCkgPT4gKExvZ2dlciksXG4gIFwiT2JzZXJ2YWJsZVwiOiAoKSA9PiAoT2JzZXJ2YWJsZSksXG4gIFwiU2NyZWVuQXBwZW5kZXJcIjogKCkgPT4gKFNjcmVlbkFwcGVuZGVyKSxcbiAgXCJUd29QSVwiOiAoKSA9PiAoVHdvUEkpLFxuICBcImFkZEl0ZW1Ub0FycmF5XCI6ICgpID0+IChhZGRJdGVtVG9BcnJheSksXG4gIFwiYmFzZTY0RW5jb2RlXCI6ICgpID0+IChiYXNlNjRFbmNvZGUpLFxuICBcImNhbm9uaWNhbGl6ZUFuZ2xlXCI6ICgpID0+IChjYW5vbmljYWxpemVBbmdsZSksXG4gIFwiY2xhbXBcIjogKCkgPT4gKGNsYW1wKSxcbiAgXCJjb250YWluc1wiOiAoKSA9PiAoY29udGFpbnMpLFxuICBcImRlbGF5XCI6ICgpID0+IChkZWxheSksXG4gIFwiZXh0ZW5kXCI6ICgpID0+IChleHRlbmQpLFxuICBcImZhaWxcIjogKCkgPT4gKGZhaWwpLFxuICBcImdldE9wcG9zaXRlU2lkZVwiOiAoKSA9PiAoZ2V0T3Bwb3NpdGVTaWRlKSxcbiAgXCJnZXRQb3NpdGlvblwiOiAoKSA9PiAoZ2V0UG9zaXRpb24pLFxuICBcImdldFNpZGVGcm9tRGlyZWN0aW9uXCI6ICgpID0+IChnZXRTaWRlRnJvbURpcmVjdGlvbiksXG4gIFwibnVsbGlzaFwiOiAoKSA9PiAobnVsbGlzaCksXG4gIFwicmFuZG9tSW5SYW5nZVwiOiAoKSA9PiAocmFuZG9tSW5SYW5nZSksXG4gIFwicmFuZG9tSW50SW5SYW5nZVwiOiAoKSA9PiAocmFuZG9tSW50SW5SYW5nZSksXG4gIFwicmFuZ2VcIjogKCkgPT4gKHJhbmdlKSxcbiAgXCJyZW1vdmVJdGVtRnJvbUFycmF5XCI6ICgpID0+IChyZW1vdmVJdGVtRnJvbUFycmF5KSxcbiAgXCJ0b0RlZ3JlZXNcIjogKCkgPT4gKHRvRGVncmVlcyksXG4gIFwidG9SYWRpYW5zXCI6ICgpID0+ICh0b1JhZGlhbnMpXG59KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuLi8uLi9ub2RlX21vZHVsZXMvY29yZS1qcy9lcy9hcnJheS9zb3J0LmpzXG52YXIgc29ydCA9IF9fd2VicGFja19yZXF1aXJlX18oNDY2Mik7XG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4uLy4uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL29iamVjdC9rZXlzLmpzXG52YXIga2V5cyA9IF9fd2VicGFja19yZXF1aXJlX18oODM0Myk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Qb2x5ZmlsbC50c1xuXHJcblxyXG4vKipcclxuICogUG9seWZpbGwgYWRkaW5nIGZ1bmN0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBwb2x5ZmlsbCgpIHtcclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB3aW5kb3cgPSB7XHJcbiAgICAgICAgICAgIGF1ZGlvQ29udGV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUpIHtcclxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID1cclxuICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgd2luZG93Lm1velJlcXVlc3RBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldEludGVydmFsKGNhbGxiYWNrLCAxMDAwIC8gNjApO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xyXG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9XHJcbiAgICAgICAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG4gICAgICAgICAgICAgICAgd2luZG93Lm1vekNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8XHJcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgIXdpbmRvdy5BdWRpb0NvbnRleHQpIHtcclxuICAgICAgICBpZiAod2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCkge1xyXG4gICAgICAgICAgICBjb25zdCBjdHggPSB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0O1xyXG4gICAgICAgICAgICBjb25zdCByZXBsYWNlTWUgPSBjdHgucHJvdG90eXBlLmRlY29kZUF1ZGlvRGF0YTtcclxuICAgICAgICAgICAgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dC5wcm90b3R5cGUuZGVjb2RlQXVkaW9EYXRhID0gZnVuY3Rpb24gKGFycmF5QnVmZmVyKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcGxhY2VNZS5jYWxsKHRoaXMsIGFycmF5QnVmZmVyLCByZXNvbHZlLCByZWplY3QpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHdpbmRvdy5BdWRpb0NvbnRleHQgPVxyXG4gICAgICAgICAgICB3aW5kb3cuQXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cubW96QXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cubXNBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5vQXVkaW9Db250ZXh0O1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAhd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHtcclxuICAgICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9GbGFncy50c1xuLyoqXHJcbiAqIEZlYXR1cmVzIGluIHByZXZpZXdcclxuICovXHJcbnZhciBFeHBlcmltZW50cztcclxuKGZ1bmN0aW9uIChFeHBlcmltZW50cykge1xyXG4gICAgRXhwZXJpbWVudHNbXCJXZWJHTFwiXSA9IFwidXNlLXdlYmdsXCI7XHJcbn0pKEV4cGVyaW1lbnRzIHx8IChFeHBlcmltZW50cyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBMZWdhY3kgZmVhdHVyZXMgdGhhdCB3aWxsIGdvIGF3YXlcclxuICovXHJcbnZhciBMZWdhY3k7XHJcbihmdW5jdGlvbiAoTGVnYWN5KSB7XHJcbiAgICBMZWdhY3lbXCJDYW52YXNcIl0gPSBcInVzZS1jYW52YXMtY29udGV4dFwiO1xyXG4gICAgTGVnYWN5W1wiTGVnYWN5RHJhd2luZ1wiXSA9IFwidXNlLWxlZ2FjeS1kcmF3aW5nXCI7XHJcbn0pKExlZ2FjeSB8fCAoTGVnYWN5ID0ge30pKTtcclxuLyoqXHJcbiAqIEZsYWdzIGlzIGEgZmVhdHVyZSBmbGFnIGltcGxlbWVudGF0aW9uIGZvciBFeGNhbGlidXIuIFRoZXkgY2FuIG9ubHkgYmUgb3BlcmF0ZWQgKipiZWZvcmUgW1tFbmdpbmVdXSBjb25zdHJ1Y3Rpb24qKlxyXG4gKiBhZnRlciB3aGljaCB0aGV5IGFyZSBmcm96ZW4gYW5kIGFyZSByZWFkLW9ubHkuXHJcbiAqXHJcbiAqIEZsYWdzIGFyZSB1c2VkIHRvIGVuYWJsZSBleHBlcmltZW50YWwgb3IgcHJldmlldyBmZWF0dXJlcyBpbiBFeGNhbGlidXIuXHJcbiAqL1xyXG5jbGFzcyBGbGFncyB7XHJcbiAgICAvKipcclxuICAgICAqIEZyZWV6ZSBhbGwgZmxhZyBtb2RpZmljYXRpb25zIG1ha2luZyB0aGVtIHJlYWRvbmx5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcmVlemUoKSB7XHJcbiAgICAgICAgRmxhZ3MuX0ZST1pFTiA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyBpbnRlcm5hbCBmbGFnIHN0YXRlLCBub3QgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IHVzZXJzLiBPbmx5IHVzZWQgZm9yIHRlc3RpbmcuXHJcbiAgICAgKlxyXG4gICAgICogQ2FsbGluZyB0aGlzIGluIHlvdXIgZ2FtZSBpcyBVTlNVUFBPUlRFRFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBfcmVzZXQoKSB7XHJcbiAgICAgICAgRmxhZ3MuX0ZST1pFTiA9IGZhbHNlO1xyXG4gICAgICAgIEZsYWdzLl9GTEFHUyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUdXJuIG9uIHdlYmdsIHN1cHBvcnRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHVzZVdlYkdMKCkge1xyXG4gICAgICAgIEZsYWdzLmVuYWJsZShFeHBlcmltZW50cy5XZWJHTCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgdXNlQ2FudmFzR3JhcGhpY3NDb250ZXh0KCkge1xyXG4gICAgICAgIEZsYWdzLmVuYWJsZShMZWdhY3kuQ2FudmFzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGRlcHJlY2F0ZWQgUmVjb21tZW5kZWQgbm90IHRvIHVzZSBsZWdhY3kgZHJhd2luZywgZ29pbmcgYXdheSBpbiB2MC4yNi4wXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB1c2VMZWdhY3lEcmF3aW5nKCkge1xyXG4gICAgICAgIEZsYWdzLmVuYWJsZShMZWdhY3kuTGVnYWN5RHJhd2luZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSBhIHNwZWNpZmljIGZlYXR1cmUgZmxhZyBieSBuYW1lLiAqKk5vdGU6IGNhbiBvbmx5IGJlIHNldCBiZWZvcmUgW1tFbmdpbmVdXSBjb25zdHJ1Y3RvciB0aW1lKipcclxuICAgICAqIEBwYXJhbSBmbGFnTmFtZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZW5hYmxlKGZsYWdOYW1lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX0ZST1pFTikge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcignRmVhdHVyZSBmbGFncyBjYW4gb25seSBiZSBlbmFibGVkIGJlZm9yZSBFbmdpbmUgY29uc3RydWN0b3IgdGltZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBGbGFncy5fRkxBR1NbZmxhZ05hbWVdID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGlzYWJsZSBhIHNwZWNpZmljIGZlYXR1cmUgZmxhZyBieSBuYW1lLiAqKk5vdGU6IGNhbiBvbmx5IGJlIHNldCBiZWZvcmUgW1tFbmdpbmVdXSBjb25zdHJ1Y3RvciB0aW1lKipcclxuICAgICAqIEBwYXJhbSBmbGFnTmFtZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZGlzYWJsZShmbGFnTmFtZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9GUk9aRU4pIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ZlYXR1cmUgZmxhZ3MgY2FuIG9ubHkgYmUgZGlzYWJsZWQgYmVmb3JlIEVuZ2luZSBjb25zdHJ1Y3RvciB0aW1lJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEZsYWdzLl9GTEFHU1tmbGFnTmFtZV0gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYSBmbGFnIGlzIGVuYWJsZWQuIElmIHRoZSBmbGFnIGlzIGRpc2FibGVkIG9yIGRvZXMgbm90IGV4aXN0IGBmYWxzZWAgaXMgcmV0dXJuZWRcclxuICAgICAqIEBwYXJhbSBmbGFnTmFtZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgaXNFbmFibGVkKGZsYWdOYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuICEhRmxhZ3MuX0ZMQUdTW2ZsYWdOYW1lXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBhIGxpc3Qgb2YgY3VycmVudGx5IGtub3duIGZsYWdzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBzaG93KCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhGbGFncy5fRkxBR1MpO1xyXG4gICAgfVxyXG59XHJcbkZsYWdzLl9GUk9aRU4gPSBmYWxzZTtcclxuRmxhZ3MuX0ZMQUdTID0ge307XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vSWQudHNcbi8qKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlSWQodHlwZSwgdmFsdWUpIHtcclxuICAgIHJldHVybiB7IHR5cGUsIHZhbHVlIH07XHJcbn1cclxuO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvTG9nLnRzXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXHJcbi8qKlxyXG4gKiBMb2dnaW5nIGxldmVsIHRoYXQgRXhjYWxpYnVyIHdpbGwgdGFnXHJcbiAqL1xyXG52YXIgTG9nTGV2ZWw7XHJcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiRGVidWdcIl0gPSAwXSA9IFwiRGVidWdcIjtcclxuICAgIExvZ0xldmVsW0xvZ0xldmVsW1wiSW5mb1wiXSA9IDFdID0gXCJJbmZvXCI7XHJcbiAgICBMb2dMZXZlbFtMb2dMZXZlbFtcIldhcm5cIl0gPSAyXSA9IFwiV2FyblwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJFcnJvclwiXSA9IDNdID0gXCJFcnJvclwiO1xyXG4gICAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJGYXRhbFwiXSA9IDRdID0gXCJGYXRhbFwiO1xyXG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xyXG4vKipcclxuICogU3RhdGljIHNpbmdsZXRvbiB0aGF0IHJlcHJlc2VudHMgdGhlIGxvZ2dpbmcgZmFjaWxpdHkgZm9yIEV4Y2FsaWJ1ci5cclxuICogRXhjYWxpYnVyIGNvbWVzIGJ1aWx0LWluIHdpdGggYSBbW0NvbnNvbGVBcHBlbmRlcl1dIGFuZCBbW1NjcmVlbkFwcGVuZGVyXV0uXHJcbiAqIERlcml2ZSBmcm9tIFtbQXBwZW5kZXJdXSB0byBjcmVhdGUgeW91ciBvd24gbG9nZ2luZyBhcHBlbmRlcnMuXHJcbiAqL1xyXG5jbGFzcyBMb2dnZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fYXBwZW5kZXJzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBkZWZhdWx0IGxvZ2dpbmcgbGV2ZWwuIEV4Y2FsaWJ1ciB3aWxsIG9ubHkgbG9nXHJcbiAgICAgICAgICogbWVzc2FnZXMgaWYgZXF1YWwgdG8gb3IgYWJvdmUgdGhpcyBsZXZlbC4gRGVmYXVsdDogW1tMb2dMZXZlbC5JbmZvXV1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRlZmF1bHRMZXZlbCA9IExvZ0xldmVsLkluZm87XHJcbiAgICAgICAgaWYgKExvZ2dlci5fSU5TVEFOQ0UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dnZXIgaXMgYSBzaW5nbGV0b24nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgTG9nZ2VyLl9JTlNUQU5DRSA9IHRoaXM7XHJcbiAgICAgICAgLy8gRGVmYXVsdCBjb25zb2xlIGFwcGVuZGVyXHJcbiAgICAgICAgTG9nZ2VyLl9JTlNUQU5DRS5hZGRBcHBlbmRlcihuZXcgQ29uc29sZUFwcGVuZGVyKCkpO1xyXG4gICAgICAgIHJldHVybiBMb2dnZXIuX0lOU1RBTkNFO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHN0YXRpYyBpbnN0YW5jZSBvZiBMb2dnZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldEluc3RhbmNlKCkge1xyXG4gICAgICAgIGlmIChMb2dnZXIuX0lOU1RBTkNFID09IG51bGwpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLl9JTlNUQU5DRSA9IG5ldyBMb2dnZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIExvZ2dlci5fSU5TVEFOQ0U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgW1tBcHBlbmRlcl1dIHRvIHRoZSBsaXN0IG9mIGFwcGVuZGVycyB0byB3cml0ZSB0b1xyXG4gICAgICovXHJcbiAgICBhZGRBcHBlbmRlcihhcHBlbmRlcikge1xyXG4gICAgICAgIHRoaXMuX2FwcGVuZGVycy5wdXNoKGFwcGVuZGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGFsbCBhcHBlbmRlcnMgZnJvbSB0aGUgbG9nZ2VyXHJcbiAgICAgKi9cclxuICAgIGNsZWFyQXBwZW5kZXJzKCkge1xyXG4gICAgICAgIHRoaXMuX2FwcGVuZGVycy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBMb2dzIGEgbWVzc2FnZSBhdCBhIGdpdmVuIExvZ0xldmVsXHJcbiAgICAgKiBAcGFyYW0gbGV2ZWwgIFRoZSBMb2dMZXZlbGB0byBsb2cgdGhlIG1lc3NhZ2UgYXRcclxuICAgICAqIEBwYXJhbSBhcmdzICAgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIHdyaXRlIHRvIGFuIGFwcGVuZGVyXHJcbiAgICAgKi9cclxuICAgIF9sb2cobGV2ZWwsIGFyZ3MpIHtcclxuICAgICAgICBpZiAobGV2ZWwgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICBsZXZlbCA9IHRoaXMuZGVmYXVsdExldmVsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLl9hcHBlbmRlcnMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGxldmVsID49IHRoaXMuZGVmYXVsdExldmVsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmRlcnNbaV0ubG9nKGxldmVsLCBhcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIFtbTG9nTGV2ZWwuRGVidWddXSBsZXZlbFxyXG4gICAgICogQHBhcmFtIGFyZ3MgIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcclxuICAgICAqL1xyXG4gICAgZGVidWcoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5EZWJ1ZywgYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkluZm9dXSBsZXZlbFxyXG4gICAgICogQHBhcmFtIGFyZ3MgIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcclxuICAgICAqL1xyXG4gICAgaW5mbyguLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5fbG9nKExvZ0xldmVsLkluZm8sIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgYSBsb2cgbWVzc2FnZSBhdCB0aGUgW1tMb2dMZXZlbC5XYXJuXV0gbGV2ZWxcclxuICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIHdhcm4oLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5XYXJuLCBhcmdzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV3JpdGVzIGEgbG9nIG1lc3NhZ2UgYXQgdGhlIFtbTG9nTGV2ZWwuRXJyb3JdXSBsZXZlbFxyXG4gICAgICogQHBhcmFtIGFyZ3MgIEFjY2VwdHMgYW55IG51bWJlciBvZiBhcmd1bWVudHNcclxuICAgICAqL1xyXG4gICAgZXJyb3IoLi4uYXJncykge1xyXG4gICAgICAgIHRoaXMuX2xvZyhMb2dMZXZlbC5FcnJvciwgYXJncyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdyaXRlcyBhIGxvZyBtZXNzYWdlIGF0IHRoZSBbW0xvZ0xldmVsLkZhdGFsXV0gbGV2ZWxcclxuICAgICAqIEBwYXJhbSBhcmdzICBBY2NlcHRzIGFueSBudW1iZXIgb2YgYXJndW1lbnRzXHJcbiAgICAgKi9cclxuICAgIGZhdGFsKC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLl9sb2coTG9nTGV2ZWwuRmF0YWwsIGFyZ3MpO1xyXG4gICAgfVxyXG59XHJcbkxvZ2dlci5fSU5TVEFOQ0UgPSBudWxsO1xyXG4vKipcclxuICogQ29uc29sZSBhcHBlbmRlciBmb3IgYnJvd3NlcnMgKGkuZS4gYGNvbnNvbGUubG9nYClcclxuICovXHJcbmNsYXNzIENvbnNvbGVBcHBlbmRlciB7XHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgYSBtZXNzYWdlIGF0IHRoZSBnaXZlbiBbW0xvZ0xldmVsXV1cclxuICAgICAqIEBwYXJhbSBsZXZlbCAgTGV2ZWwgdG8gbG9nIGF0XHJcbiAgICAgKiBAcGFyYW0gYXJncyAgIEFyZ3VtZW50cyB0byBsb2dcclxuICAgICAqL1xyXG4gICAgbG9nKGxldmVsLCBhcmdzKSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbnNvbGUgc3VwcG9ydFxyXG4gICAgICAgIGlmICghY29uc29sZSAmJiAhY29uc29sZS5sb2cgJiYgY29uc29sZS53YXJuICYmIGNvbnNvbGUuZXJyb3IpIHtcclxuICAgICAgICAgICAgLy8gdG9kbyBtYXliZSBkbyBzb21ldGhpbmcgYmV0dGVyIHRoYW4gbm90aGluZ1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENyZWF0ZSBhIG5ldyBjb25zb2xlIGFyZ3MgYXJyYXlcclxuICAgICAgICBjb25zdCBjb25zb2xlQXJncyA9IFtdO1xyXG4gICAgICAgIGNvbnNvbGVBcmdzLnVuc2hpZnQuYXBwbHkoY29uc29sZUFyZ3MsIGFyZ3MpO1xyXG4gICAgICAgIGNvbnNvbGVBcmdzLnVuc2hpZnQoJ1snICsgTG9nTGV2ZWxbbGV2ZWxdICsgJ10gOiAnKTtcclxuICAgICAgICBpZiAobGV2ZWwgPCBMb2dMZXZlbC5XYXJuKSB7XHJcbiAgICAgICAgICAgIC8vIENhbGwgLmxvZyBmb3IgRGVidWcvSW5mb1xyXG4gICAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgcmVxdWlyZWQgb24gc29tZSBvbGRlciBicm93c2VycyB0aGF0IGRvbid0IHN1cHBvcnQgYXBwbHkgb24gY29uc29sZS5sb2cgOihcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGNvbnNvbGVBcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNvbnNvbGVBcmdzLmpvaW4oJyAnKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobGV2ZWwgPCBMb2dMZXZlbC5FcnJvcikge1xyXG4gICAgICAgICAgICAvLyBDYWxsIC53YXJuIGZvciBXYXJuXHJcbiAgICAgICAgICAgIGlmIChjb25zb2xlLndhcm4uYXBwbHkpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBjb25zb2xlQXJncyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oY29uc29sZUFyZ3Muam9pbignICcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gQ2FsbCAuZXJyb3IgZm9yIEVycm9yL0ZhdGFsXHJcbiAgICAgICAgICAgIGlmIChjb25zb2xlLmVycm9yLmFwcGx5KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yLmFwcGx5KGNvbnNvbGUsIGNvbnNvbGVBcmdzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoY29uc29sZUFyZ3Muam9pbignICcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4vKipcclxuICogT24tc2NyZWVuIChjYW52YXMpIGFwcGVuZGVyXHJcbiAqL1xyXG5jbGFzcyBTY3JlZW5BcHBlbmRlciB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB3aWR0aCAgIFdpZHRoIG9mIHRoZSBzY3JlZW4gYXBwZW5kZXIgaW4gcGl4ZWxzXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0ICBIZWlnaHQgb2YgdGhlIHNjcmVlbiBhcHBlbmRlciBpbiBwaXhlbHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iod2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIC8vIEB0b2RvIENsZWFuIHRoaXMgdXBcclxuICAgICAgICB0aGlzLl9tZXNzYWdlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHdpZHRoIHx8IHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBoZWlnaHQgfHwgd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgdGhpcy5fY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2NhbnZhcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIExvZ3MgYSBtZXNzYWdlIGF0IHRoZSBnaXZlbiBbW0xvZ0xldmVsXV1cclxuICAgICAqIEBwYXJhbSBsZXZlbCAgTGV2ZWwgdG8gbG9nIGF0XHJcbiAgICAgKiBAcGFyYW0gYXJncyAgIEFyZ3VtZW50cyB0byBsb2dcclxuICAgICAqL1xyXG4gICAgbG9nKGxldmVsLCBhcmdzKSB7XHJcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGFyZ3Muam9pbignLCcpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY2FudmFzLndpZHRoLCB0aGlzLl9jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9tZXNzYWdlcy51bnNoaWZ0KCdbJyArIExvZ0xldmVsW2xldmVsXSArICddIDogJyArIG1lc3NhZ2UpO1xyXG4gICAgICAgIGxldCBwb3MgPSAxMDtcclxuICAgICAgICBsZXQgb3BhY2l0eSA9IDEuMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX21lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSAncmdiYSgyNTUsMjU1LDI1NSwnICsgb3BhY2l0eS50b0ZpeGVkKDIpICsgJyknO1xyXG4gICAgICAgICAgICB0aGlzLl9jdHguZmlsbFRleHQodGhpcy5fbWVzc2FnZXNbaV0sIDIwMCwgcG9zKTtcclxuICAgICAgICAgICAgcG9zICs9IDEwO1xyXG4gICAgICAgICAgICBvcGFjaXR5ID0gb3BhY2l0eSA+IDAgPyBvcGFjaXR5IC0gMC4wNSA6IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTWF0aC9SYW5kb20udHNcbi8qKlxyXG4gKiBAbW9kdWxlXHJcbiAqIFBzZXVkby1SYW5kb20gVXRpbGl0eVxyXG4gKlxyXG4gKiBBIHBzZXVkby1yYW5kb20gdXRpbGl0eSB0byBhZGQgc2VlZGVkIHJhbmRvbSBzdXBwb3J0IGZvciBoZWxwIGluXHJcbiAqIGdlbmVyYXRpbmcgdGhpbmdzIGxpa2UgdGVycmFpbiBvciByZXByb2R1Y2libGUgcmFuZG9tbmVzcy4gVXNlcyB0aGVcclxuICogW01lcnNlbm5lIFR3aXN0ZXJdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lcnNlbm5lX1R3aXN0ZXIpIGFsZ29yaXRobS5cclxuICovXHJcbi8qKlxyXG4gKiAzMi1iaXQgbWFza1xyXG4gKi9cclxuY29uc3QgQklUTUFTSzMyID0gMHhmZmZmZmZmZjtcclxuLyoqXHJcbiAqIFBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvciBmb2xsb3dpbmcgdGhlIE1lcnNlbm5lX1R3aXN0ZXIgYWxnb3JpdGhtLiBHaXZlbiBhIHNlZWQgdGhpcyBnZW5lcmF0b3Igd2lsbCBwcm9kdWNlIHRoZSBzYW1lIHNlcXVlbmNlXHJcbiAqIG9mIG51bWJlcnMgZWFjaCB0aW1lIGl0IGlzIGNhbGxlZC5cclxuICogU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01lcnNlbm5lX1R3aXN0ZXIgZm9yIG1vcmUgZGV0YWlscy5cclxuICogVXNlcyB0aGUgTVQxOTkzNy0zMiAoMjAwMikgaW1wbGVtZW50YXRpb24gZG9jdW1lbnRlZCBoZXJlIGh0dHA6Ly93d3cubWF0aC5zY2kuaGlyb3NoaW1hLXUuYWMuanAvfm0tbWF0L01UL01UMjAwMi9lbXQxOTkzN2FyLmh0bWxcclxuICpcclxuICogQXBpIGluc3BpcmVkIGJ5IGh0dHA6Ly9jaGFuY2Vqcy5jb20vIyBodHRwczovL2dpdGh1Yi5jb20vY2hhbmNlanMvY2hhbmNlanNcclxuICovXHJcbmNsYXNzIFJhbmRvbSB7XHJcbiAgICAvKipcclxuICAgICAqIElmIG5vIHNlZWQgaXMgc3BlY2lmaWVkLCB0aGUgRGF0ZS5ub3coKSBpcyB1c2VkXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHNlZWQpIHtcclxuICAgICAgICB0aGlzLnNlZWQgPSBzZWVkO1xyXG4gICAgICAgIC8vIFNlcGFyYXRpb24gcG9pbnQgb2Ygb25lIG9uZSB3b3JkLCB0aGUgbnVtYmVyIG9mIGJpdHMgaW4gdGhlIGxvd2VyIGJpdG1hc2sgMCA8PSByIDw9IHctMVxyXG4gICAgICAgIHRoaXMuX2xvd2VyTWFzayA9IDB4N2ZmZmZmZmY7IC8vIDMxIGJpdHMgc2FtZSBhcyBfclxyXG4gICAgICAgIHRoaXMuX3VwcGVyTWFzayA9IDB4ODAwMDAwMDA7IC8vIDM0IGhpZ2ggYml0c1xyXG4gICAgICAgIC8vIFdvcmQgc2l6ZSwgNjQgYml0c1xyXG4gICAgICAgIHRoaXMuX3cgPSAzMjtcclxuICAgICAgICAvLyBEZWdyZWUgb2YgcmVjdXJyZW5jZVxyXG4gICAgICAgIHRoaXMuX24gPSA2MjQ7XHJcbiAgICAgICAgLy8gTWlkZGxlIHdvcmQsIGFuIG9mZnNldCB1c2VkIGluIHRoZSByZWN1cnJlbmNlIGRlZmluaW5nIHRoZSBzZXJpZXMgeCwgMTw9bTxuXHJcbiAgICAgICAgdGhpcy5fbSA9IDM5NztcclxuICAgICAgICAvLyBjb2VmZmljaWVudHMgb2YgdGVoIHJhdGlvbmFsIG5vcm1hbCBmb3JtIHR3aXN0IG1hdHJpeFxyXG4gICAgICAgIHRoaXMuX2EgPSAweDk5MDhiMGRmO1xyXG4gICAgICAgIC8vIHRlbXBlcmluZyBiaXQgc2hpZnRzIGFuZCBtYXNrc1xyXG4gICAgICAgIHRoaXMuX3UgPSAxMTtcclxuICAgICAgICB0aGlzLl9zID0gNztcclxuICAgICAgICB0aGlzLl9iID0gMHg5ZDJjNTY4MDtcclxuICAgICAgICB0aGlzLl90ID0gMTU7XHJcbiAgICAgICAgdGhpcy5fYyA9IDB4ZWZjNjAwMDA7XHJcbiAgICAgICAgdGhpcy5fbCA9IDE4O1xyXG4gICAgICAgIHRoaXMuX2YgPSAxODEyNDMzMjUzO1xyXG4gICAgICAgIHRoaXMuX210ID0gbmV3IEFycmF5KHRoaXMuX24pO1xyXG4gICAgICAgIC8vIG5lZWQgdG8gbWFzayB0byBzdXBwb3J0IGhpZ2hlciBiaXQgbWFjaGluZXNcclxuICAgICAgICB0aGlzLl9tdFswXSA9IChzZWVkIHx8IERhdGUubm93KCkpID4+PiAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5fbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHMgPSB0aGlzLl9tdFtpIC0gMV0gXiAodGhpcy5fbXRbaSAtIDFdID4+PiAodGhpcy5fdyAtIDIpKTtcclxuICAgICAgICAgICAgLy8gbnVtYmVycyBhcmUgYmlnZ2VyIHRoYW4gdGhlIEpTIG1heCBzYWZlIGludCwgYWRkIGluIDE2LWJpdCBjaHVua3MgdG8gcHJldmVudCBJRUVFIHJvdW5kaW5nIGVycm9ycyBvbiBoaWdoIGJpdHNcclxuICAgICAgICAgICAgdGhpcy5fbXRbaV0gPSAoKCh0aGlzLl9mICogKChzICYgMHhmZmZmMDAwMCkgPj4+IDE2KSkgPDwgMTYpICsgdGhpcy5fZiAqIChzICYgMHhmZmZmKSArIGkpID4+PiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pbmRleCA9IHRoaXMuX247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRoZSB0d2lzdFxyXG4gICAgICovXHJcbiAgICBfdHdpc3QoKSB7XHJcbiAgICAgICAgY29uc3QgbWFnMDEgPSBbMHgwLCB0aGlzLl9hXTtcclxuICAgICAgICBsZXQgeSA9IDAsIGkgPSAwO1xyXG4gICAgICAgIGZvciAoOyBpIDwgdGhpcy5fbiAtIHRoaXMuX207IGkrKykge1xyXG4gICAgICAgICAgICB5ID0gKHRoaXMuX210W2ldICYgdGhpcy5fdXBwZXJNYXNrKSB8ICh0aGlzLl9tdFtpICsgMV0gJiB0aGlzLl9sb3dlck1hc2spO1xyXG4gICAgICAgICAgICB0aGlzLl9tdFtpXSA9IHRoaXMuX210W2kgKyB0aGlzLl9tXSBeICh5ID4+PiAxKSBeIChtYWcwMVt5ICYgMHgxXSAmIEJJVE1BU0szMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoOyBpIDwgdGhpcy5fbiAtIDE7IGkrKykge1xyXG4gICAgICAgICAgICB5ID0gKHRoaXMuX210W2ldICYgdGhpcy5fdXBwZXJNYXNrKSB8ICh0aGlzLl9tdFtpICsgMV0gJiB0aGlzLl9sb3dlck1hc2spO1xyXG4gICAgICAgICAgICB0aGlzLl9tdFtpXSA9IHRoaXMuX210W2kgKyAodGhpcy5fbSAtIHRoaXMuX24pXSBeICh5ID4+PiAxKSBeIChtYWcwMVt5ICYgMHgxXSAmIEJJVE1BU0szMik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHkgPSAodGhpcy5fbXRbdGhpcy5fbiAtIDFdICYgdGhpcy5fdXBwZXJNYXNrKSB8ICh0aGlzLl9tdFswXSAmIHRoaXMuX2xvd2VyTWFzayk7XHJcbiAgICAgICAgdGhpcy5fbXRbdGhpcy5fbiAtIDFdID0gdGhpcy5fbXRbdGhpcy5fbSAtIDFdIF4gKHkgPj4+IDEpIF4gKG1hZzAxW3kgJiAweDFdICYgQklUTUFTSzMyKTtcclxuICAgICAgICB0aGlzLl9pbmRleCA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBuZXh0IDMyIGJpdCBpbnRlZ2VyIG51bWJlciBpbiBzZXF1ZW5jZVxyXG4gICAgICovXHJcbiAgICBuZXh0SW50KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pbmRleCA+PSB0aGlzLl9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R3aXN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCB5ID0gdGhpcy5fbXRbdGhpcy5faW5kZXgrK107XHJcbiAgICAgICAgeSBePSB5ID4+PiB0aGlzLl91O1xyXG4gICAgICAgIHkgXj0gKHkgPDwgdGhpcy5fcykgJiB0aGlzLl9iO1xyXG4gICAgICAgIHkgXj0gKHkgPDwgdGhpcy5fdCkgJiB0aGlzLl9jO1xyXG4gICAgICAgIHkgXj0geSA+Pj4gdGhpcy5fbDtcclxuICAgICAgICByZXR1cm4geSA+Pj4gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgcmFuZG9tIGZsb2F0aW5nIHBvaW50IG51bWJlciBiZXR3ZWVuIFswLCAxKVxyXG4gICAgICovXHJcbiAgICBuZXh0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm5leHRJbnQoKSAqICgxLjAgLyA0Mjk0OTY3Mjk2LjApOyAvLyBkaXZpZGVkIGJ5IDJeMzJcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgcmFuZG9tIGZsb2F0aW5nIHBvaW50IGluIHJhbmdlIFttaW4sIG1heCkgbWluIGlzIGluY2x1ZGVkLCBtYXggaXMgbm90IGluY2x1ZGVkXHJcbiAgICAgKi9cclxuICAgIGZsb2F0aW5nKG1pbiwgbWF4KSB7XHJcbiAgICAgICAgcmV0dXJuIChtYXggLSBtaW4pICogdGhpcy5uZXh0KCkgKyBtaW47XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGluIHJhbmdlIFttaW4sIG1heF0gbWluIGlzIGluY2x1ZGVkLCBtYXggaXMgaW5jbHVkZWQuXHJcbiAgICAgKiBJbXBsZW1lbnRlZCB3aXRoIHJlamVjdGlvbiBzYW1wbGluZywgc2VlIGh0dHBzOi8vbWVkaXVtLmNvbS9AYmV0YWJsZS90aWZ1LWJ5LXVzaW5nLW1hdGgtcmFuZG9tLWYxYzMwOGM0ZmQ5ZCMuaTEzdGRpdTVhXHJcbiAgICAgKi9cclxuICAgIGludGVnZXIobWluLCBtYXgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigobWF4IC0gbWluICsgMSkgKiB0aGlzLm5leHQoKSArIG1pbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBvciBmYWxzZSByYW5kb21seSB3aXRoIDUwLzUwIG9kZHMgYnkgZGVmYXVsdC5cclxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIGxpa2VsaWhvb2Qgb2YgcmV0dXJuaW5nIGEgdHJ1ZSBpcyAuNSAoNTAlKS5cclxuICAgICAqIEBwYXJhbSBsaWtlbGlob29kIHRha2VzIHZhbHVlcyBiZXR3ZWVuIFswLCAxXVxyXG4gICAgICovXHJcbiAgICBib29sKGxpa2VsaWhvb2QgPSAwLjUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0KCkgPD0gbGlrZWxpaG9vZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBvbmUgZWxlbWVudCBmcm9tIGFuIGFycmF5IGF0IHJhbmRvbVxyXG4gICAgICovXHJcbiAgICBwaWNrT25lKGFycmF5KSB7XHJcbiAgICAgICAgcmV0dXJuIGFycmF5W3RoaXMuaW50ZWdlcigwLCBhcnJheS5sZW5ndGggLSAxKV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBuZXcgYXJyYXkgcmFuZG9tIHBpY2tpbmcgZWxlbWVudHMgZnJvbSB0aGUgb3JpZ2luYWxcclxuICAgICAqIEBwYXJhbSBhcnJheSBPcmlnaW5hbCBhcnJheSB0byBwaWNrIGZyb21cclxuICAgICAqIEBwYXJhbSBudW1QaWNrcyBjYW4gYmUgYW55IHBvc2l0aXZlIG51bWJlclxyXG4gICAgICogQHBhcmFtIGFsbG93RHVwbGljYXRlcyBpbmRpY2F0ZXMgd2hldGhlciB0aGUgcmV0dXJuZWQgc2V0IGlzIGFsbG93ZWQgZHVwbGljYXRlcyAoaXQgZG9lcyBub3QgbWVhbiB0aGVyZSB3aWxsIGFsd2F5cyBiZSBkdXBsaWNhdGVzXHJcbiAgICAgKiBqdXN0IHRoYXQgaXQgaXMgcG9zc2libGUpXHJcbiAgICAgKi9cclxuICAgIHBpY2tTZXQoYXJyYXksIG51bVBpY2tzLCBhbGxvd0R1cGxpY2F0ZXMgPSBmYWxzZSkge1xyXG4gICAgICAgIGlmIChhbGxvd0R1cGxpY2F0ZXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BpY2tTZXRXaXRoRHVwbGljYXRlcyhhcnJheSwgbnVtUGlja3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BpY2tTZXRXaXRob3V0RHVwbGljYXRlcyhhcnJheSwgbnVtUGlja3MpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBhcnJheSByYW5kb21seSBwaWNraW5nIGVsZW1lbnRzIGluIHRoZSBvcmlnaW5hbCAobm90IHJldXNlZClcclxuICAgICAqIEBwYXJhbSBhcnJheSBBcnJheSB0byBwaWNrIGVsZW1lbnRzIG91dCBvZlxyXG4gICAgICogQHBhcmFtIG51bVBpY2tzIG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGFycmF5LlxyXG4gICAgICovXHJcbiAgICBfcGlja1NldFdpdGhvdXREdXBsaWNhdGVzKGFycmF5LCBudW1QaWNrcykge1xyXG4gICAgICAgIGlmIChudW1QaWNrcyA+IGFycmF5Lmxlbmd0aCB8fCBudW1QaWNrcyA8IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG51bWJlciBvZiBlbGVtZW50cyB0byBwaWNrLCBtdXN0IHBpY2sgYSB2YWx1ZSAwIDwgbiA8PSBsZW5ndGgnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG51bVBpY2tzID09PSBhcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobnVtUGlja3MpO1xyXG4gICAgICAgIGxldCBjdXJyZW50UGljayA9IDA7XHJcbiAgICAgICAgY29uc3QgdGVtcEFycmF5ID0gYXJyYXkuc2xpY2UoMCk7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRQaWNrIDwgbnVtUGlja3MpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmludGVnZXIoMCwgdGVtcEFycmF5Lmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICByZXN1bHRbY3VycmVudFBpY2srK10gPSB0ZW1wQXJyYXlbaW5kZXhdO1xyXG4gICAgICAgICAgICB0ZW1wQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBhcnJheSByYW5kb20gcGlja2luZyBlbGVtZW50cyBmcm9tIHRoZSBvcmlnaW5hbCBhbGxvd2luZyBkdXBsaWNhdGVzXHJcbiAgICAgKiBAcGFyYW0gYXJyYXkgQXJyYXkgdG8gcGljayBlbGVtZW50cyBvdXQgb2ZcclxuICAgICAqIEBwYXJhbSBudW1QaWNrcyBjYW4gYmUgYW55IHBvc2l0aXZlIG51bWJlclxyXG4gICAgICovXHJcbiAgICBfcGlja1NldFdpdGhEdXBsaWNhdGVzKGFycmF5LCBudW1QaWNrcykge1xyXG4gICAgICAgIC8vIFR5cGVzY3JpcHQgbnVtYmVycyBhcmUgYWxsIGZsb2F0aW5nIHBvaW50LCBzbyBkbyB3ZSBhZGQgY2hlY2sgZm9yIGludD8gKG9yIGZsb29yIHRoZSBpbnB1dD8pXHJcbiAgICAgICAgaWYgKG51bVBpY2tzIDwgMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHBpY2ssIG11c3QgcGljayBhIHZhbHVlIDAgPD0gbiA8IE1BWF9JTlQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KG51bVBpY2tzKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVBpY2tzOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5waWNrT25lKGFycmF5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIG5ldyBhcnJheSB0aGF0IGhhcyBpdHMgZWxlbWVudHMgc2h1ZmZsZWQuIFVzaW5nIHRoZSBGaXNoZXIvWWF0ZXMgbWV0aG9kXHJcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXIlRTIlODAlOTNZYXRlc19zaHVmZmxlXHJcbiAgICAgKi9cclxuICAgIHNodWZmbGUoYXJyYXkpIHtcclxuICAgICAgICBjb25zdCB0ZW1wQXJyYXkgPSBhcnJheS5zbGljZSgwKTtcclxuICAgICAgICBsZXQgc3dhcCA9IG51bGw7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZW1wQXJyYXkubGVuZ3RoIC0gMjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJhbmRvbUluZGV4ID0gdGhpcy5pbnRlZ2VyKGksIHRlbXBBcnJheS5sZW5ndGggLSAxKTtcclxuICAgICAgICAgICAgc3dhcCA9IHRlbXBBcnJheVtpXTtcclxuICAgICAgICAgICAgdGVtcEFycmF5W2ldID0gdGVtcEFycmF5W3JhbmRvbUluZGV4XTtcclxuICAgICAgICAgICAgdGVtcEFycmF5W3JhbmRvbUluZGV4XSA9IHN3YXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0ZW1wQXJyYXk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIGEgbGlzdCBvZiByYW5kb20gaW50ZWdlciBudW1iZXJzXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIHRoZSBsZW5ndGggb2YgdGhlIGZpbmFsIGFycmF5XHJcbiAgICAgKiBAcGFyYW0gbWluIHRoZSBtaW5pbXVtIGludGVnZXIgbnVtYmVyIHRvIGdlbmVyYXRlIGluY2x1c2l2ZVxyXG4gICAgICogQHBhcmFtIG1heCB0aGUgbWF4aW11bSBpbnRlZ2VyIG51bWJlciB0byBnZW5lcmF0ZSBpbmNsdXNpdmVcclxuICAgICAqL1xyXG4gICAgcmFuZ2UobGVuZ3RoLCBtaW4sIG1heCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVzdWx0W2ldID0gdGhpcy5pbnRlZ2VyKG1pbiwgbWF4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDQgZGljZSByb2xsXHJcbiAgICAgKi9cclxuICAgIGQ0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgNCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQ2IGRpY2Ugcm9sbFxyXG4gICAgICovXHJcbiAgICBkNigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDYpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkOCBkaWNlIHJvbGxcclxuICAgICAqL1xyXG4gICAgZDgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCA4KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcmVzdWx0IG9mIGEgZDEwIGRpY2Ugcm9sbFxyXG4gICAgICovXHJcbiAgICBkMTAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZWdlcigxLCAxMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlc3VsdCBvZiBhIGQxMiBkaWNlIHJvbGxcclxuICAgICAqL1xyXG4gICAgZDEyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVnZXIoMSwgMTIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYSBkMjAgZGljZSByb2xsXHJcbiAgICAgKi9cclxuICAgIGQyMCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5pbnRlZ2VyKDEsIDIwKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9TaWRlLnRzXG5cclxuLyoqXHJcbiAqIEFuIGVudW0gdGhhdCBkZXNjcmliZXMgdGhlIHNpZGVzIG9mIGFuIGF4aXMgYWxpZ25lZCBib3ggZm9yIGNvbGxpc2lvblxyXG4gKi9cclxudmFyIFNpZGU7XHJcbihmdW5jdGlvbiAoU2lkZSkge1xyXG4gICAgU2lkZVtcIk5vbmVcIl0gPSBcIk5vbmVcIjtcclxuICAgIFNpZGVbXCJUb3BcIl0gPSBcIlRvcFwiO1xyXG4gICAgU2lkZVtcIkJvdHRvbVwiXSA9IFwiQm90dG9tXCI7XHJcbiAgICBTaWRlW1wiTGVmdFwiXSA9IFwiTGVmdFwiO1xyXG4gICAgU2lkZVtcIlJpZ2h0XCJdID0gXCJSaWdodFwiO1xyXG59KShTaWRlIHx8IChTaWRlID0ge30pKTtcclxuKGZ1bmN0aW9uIChTaWRlKSB7XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG9wcG9zaXRlIHNpZGUgZnJvbSB0aGUgY3VycmVudFxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBnZXRPcHBvc2l0ZShzaWRlKSB7XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGUuVG9wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlLkJvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGUuQm90dG9tKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBTaWRlLlRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGUuTGVmdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gU2lkZS5SaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNpZGUgPT09IFNpZGUuUmlnaHQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNpZGUuTGVmdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFNpZGUuTm9uZTtcclxuICAgIH1cclxuICAgIFNpZGUuZ2V0T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZTtcclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSB2ZWN0b3IsIHJldHVybiB0aGUgU2lkZSBtb3N0IGluIHRoYXQgZGlyZWN0aW9uICh2aWEgZG90IHByb2R1Y3QpXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIGZyb21EaXJlY3Rpb24oZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgZGlyZWN0aW9ucyA9IFtWZWN0b3IuTGVmdCwgVmVjdG9yLlJpZ2h0LCBWZWN0b3IuVXAsIFZlY3Rvci5Eb3duXTtcclxuICAgICAgICBjb25zdCBkaXJlY3Rpb25FbnVtID0gW1NpZGUuTGVmdCwgU2lkZS5SaWdodCwgU2lkZS5Ub3AsIFNpZGUuQm90dG9tXTtcclxuICAgICAgICBsZXQgbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgbGV0IG1heEluZGV4ID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXJlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb25zW2ldLmRvdChkaXJlY3Rpb24pID4gbWF4KSB7XHJcbiAgICAgICAgICAgICAgICBtYXggPSBkaXJlY3Rpb25zW2ldLmRvdChkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgbWF4SW5kZXggPSBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBkaXJlY3Rpb25FbnVtW21heEluZGV4XTtcclxuICAgIH1cclxuICAgIFNpZGUuZnJvbURpcmVjdGlvbiA9IGZyb21EaXJlY3Rpb247XHJcbn0pKFNpZGUgfHwgKFNpZGUgPSB7fSkpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvVXRpbC50c1xuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR3byBQSSBjb25zdGFudFxyXG4gKi9cclxuY29uc3QgVHdvUEkgPSBNYXRoLlBJICogMjtcclxuLyoqXHJcbiAqIE1lcmdlcyBvbmUgb3IgbW9yZSBvYmplY3RzIGludG8gYSBzaW5nbGUgdGFyZ2V0IG9iamVjdFxyXG4gKlxyXG4gKiBAcmV0dXJucyBNZXJnZWQgb2JqZWN0IHdpdGggcHJvcGVydGllcyBmcm9tIG90aGVyIG9iamVjdHNcclxuICogQGNyZWRpdCBodHRwczovL2dvbWFrZXRoaW5ncy5jb20vdmFuaWxsYS1qYXZhc2NyaXB0LXZlcnNpb24tb2YtanF1ZXJ5LWV4dGVuZC9cclxuICovXHJcbmZ1bmN0aW9uIGV4dGVuZCgpIHtcclxuICAgIGNvbnN0IGV4dGVuZGVkID0ge307XHJcbiAgICBsZXQgZGVlcCA9IGZhbHNlO1xyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgY29uc3QgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcclxuICAgIC8vIENoZWNrIGlmIGEgZGVlcCBtZXJnZVxyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudHNbMF0pID09PSAnW29iamVjdCBCb29sZWFuXScpIHtcclxuICAgICAgICBkZWVwID0gYXJndW1lbnRzWzBdO1xyXG4gICAgICAgIGkrKztcclxuICAgIH1cclxuICAgIC8vIE1lcmdlIHRoZSBvYmplY3QgaW50byB0aGUgZXh0ZW5kZWQgb2JqZWN0XHJcbiAgICBjb25zdCBhc3NpZ25FeGlzdHMgPSB0eXBlb2YgT2JqZWN0LmFzc2lnbiA9PT0gJ2Z1bmN0aW9uJztcclxuICAgIGxldCBtZXJnZSA9IG51bGw7XHJcbiAgICBpZiAoIWFzc2lnbkV4aXN0cykge1xyXG4gICAgICAgIG1lcmdlID0gZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBkZWVwIG1lcmdlIGFuZCBwcm9wZXJ0eSBpcyBhbiBvYmplY3QsIG1lcmdlIHByb3BlcnRpZXNcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVlcCAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqW3Byb3BdKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXh0ZW5kZWRbcHJvcF0gPSBleHRlbmQodHJ1ZSwgZXh0ZW5kZWRbcHJvcF0sIG9ialtwcm9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHRlbmRlZFtwcm9wXSA9IG9ialtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgbWVyZ2UgPSBPYmplY3QuYXNzaWduO1xyXG4gICAgfVxyXG4gICAgLy8gTG9vcCB0aHJvdWdoIGVhY2ggb2JqZWN0IGFuZCBjb25kdWN0IGEgbWVyZ2VcclxuICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBvYmogPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgaWYgKCFhc3NpZ25FeGlzdHMpIHtcclxuICAgICAgICAgICAgbWVyZ2Uob2JqKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG1lcmdlKGV4dGVuZGVkLCBvYmopO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBleHRlbmRlZDtcclxufVxyXG4vKipcclxuICogRW5jb2RlIGEgc3RyaW5nIGluIGJhc2U2NFxyXG4gKiBAZGVwcmVjYXRlZCBUaGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG5mdW5jdGlvbiBiYXNlNjRFbmNvZGUoaW5wdXRTdHIpIHtcclxuICAgIGNvbnN0IGI2NCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XHJcbiAgICBsZXQgb3V0cHV0U3RyID0gJyc7XHJcbiAgICBsZXQgaSA9IDA7XHJcbiAgICB3aGlsZSAoaSA8IGlucHV0U3RyLmxlbmd0aCkge1xyXG4gICAgICAgIC8vYWxsIHRocmVlIFwiJiAweGZmXCIgYWRkZWQgYmVsb3cgYXJlIHRoZXJlIHRvIGZpeCBhIGtub3duIGJ1Z1xyXG4gICAgICAgIC8vd2l0aCBieXRlcyByZXR1cm5lZCBieSB4aHIucmVzcG9uc2VUZXh0XHJcbiAgICAgICAgY29uc3QgYnl0ZTEgPSBpbnB1dFN0ci5jaGFyQ29kZUF0KGkrKykgJiAweGZmO1xyXG4gICAgICAgIGNvbnN0IGJ5dGUyID0gaW5wdXRTdHIuY2hhckNvZGVBdChpKyspICYgMHhmZjtcclxuICAgICAgICBjb25zdCBieXRlMyA9IGlucHV0U3RyLmNoYXJDb2RlQXQoaSsrKSAmIDB4ZmY7XHJcbiAgICAgICAgY29uc3QgZW5jMSA9IGJ5dGUxID4+IDI7XHJcbiAgICAgICAgY29uc3QgZW5jMiA9ICgoYnl0ZTEgJiAzKSA8PCA0KSB8IChieXRlMiA+PiA0KTtcclxuICAgICAgICBsZXQgZW5jMywgZW5jNDtcclxuICAgICAgICBpZiAoaXNOYU4oYnl0ZTIpKSB7XHJcbiAgICAgICAgICAgIGVuYzMgPSBlbmM0ID0gNjQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlbmMzID0gKChieXRlMiAmIDE1KSA8PCAyKSB8IChieXRlMyA+PiA2KTtcclxuICAgICAgICAgICAgaWYgKGlzTmFOKGJ5dGUzKSkge1xyXG4gICAgICAgICAgICAgICAgZW5jNCA9IDY0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZW5jNCA9IGJ5dGUzICYgNjM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgb3V0cHV0U3RyICs9IGI2NC5jaGFyQXQoZW5jMSkgKyBiNjQuY2hhckF0KGVuYzIpICsgYjY0LmNoYXJBdChlbmMzKSArIGI2NC5jaGFyQXQoZW5jNCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0U3RyO1xyXG59XHJcbi8qKlxyXG4gKiBTdWdhciB0aGF0IHdpbGwgdXNlIGBudWxsaXNoVmFsYCBpZiBpdCdzIG5vdCBudWxsIG9yIHVuZGVmaW5lZC4gU2ltdWxhdGVzIHRoZSBgPz9gIG9wZXJhdG9yXHJcbiAqIEBwYXJhbSBudWxsaXNoVmFsXHJcbiAqIEBwYXJhbSBkZWZhdWx0VmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBudWxsaXNoKG51bGxpc2hWYWwsIGRlZmF1bHRWYWwpIHtcclxuICAgIHJldHVybiBudWxsaXNoVmFsICE9PSBudWxsICYmIG51bGxpc2hWYWwgIT09IHVuZGVmaW5lZCA/IG51bGxpc2hWYWwgOiBkZWZhdWx0VmFsO1xyXG59XHJcbi8qKlxyXG4gKiBDbGFtcHMgYSB2YWx1ZSBiZXR3ZWVuIGEgbWluIGFuZCBtYXggaW5jbHVzaXZlXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGFtcCh2YWwsIG1pbiwgbWF4KSB7XHJcbiAgICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCB2YWwpLCBtYXgpO1xyXG59XHJcbi8qKlxyXG4gKiBGaW5kIGEgcmFuZG9tIGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiByYW5nZVxyXG4gKi9cclxuZnVuY3Rpb24gcmFuZG9tSW5SYW5nZShtaW4sIG1heCwgcmFuZG9tID0gbmV3IFJhbmRvbSgpKSB7XHJcbiAgICByZXR1cm4gcmFuZG9tID8gcmFuZG9tLmZsb2F0aW5nKG1pbiwgbWF4KSA6IG1pbiArIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKTtcclxufVxyXG4vKipcclxuICogRmluZCBhIHJhbmRvbSBpbnRlZ2VyIGluIGEgcmFuZ2VcclxuICovXHJcbmZ1bmN0aW9uIHJhbmRvbUludEluUmFuZ2UobWluLCBtYXgsIHJhbmRvbSA9IG5ldyBSYW5kb20oKSkge1xyXG4gICAgcmV0dXJuIHJhbmRvbSA/IHJhbmRvbS5pbnRlZ2VyKG1pbiwgbWF4KSA6IE1hdGgucm91bmQocmFuZG9tSW5SYW5nZShtaW4sIG1heCkpO1xyXG59XHJcbi8qKlxyXG4gKiBDb252ZXJ0IGFuIGFuZ2xlIHRvIGJlIHRoZSBlcXVpdmFsZW50IGluIHRoZSByYW5nZSBbMCwgMlBJXVxyXG4gKi9cclxuZnVuY3Rpb24gY2Fub25pY2FsaXplQW5nbGUoYW5nbGUpIHtcclxuICAgIGxldCB0bXBBbmdsZSA9IGFuZ2xlO1xyXG4gICAgaWYgKGFuZ2xlID4gVHdvUEkpIHtcclxuICAgICAgICB3aGlsZSAodG1wQW5nbGUgPiBUd29QSSkge1xyXG4gICAgICAgICAgICB0bXBBbmdsZSAtPSBUd29QSTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoYW5nbGUgPCAwKSB7XHJcbiAgICAgICAgd2hpbGUgKHRtcEFuZ2xlIDwgMCkge1xyXG4gICAgICAgICAgICB0bXBBbmdsZSArPSBUd29QSTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG1wQW5nbGU7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnQgcmFkaWFucyB0byBkZWdyZWVzXHJcbiAqL1xyXG5mdW5jdGlvbiB0b0RlZ3JlZXMocmFkaWFucykge1xyXG4gICAgcmV0dXJuICgxODAgLyBNYXRoLlBJKSAqIHJhZGlhbnM7XHJcbn1cclxuLyoqXHJcbiAqIENvbnZlcnQgZGVncmVlcyB0byByYWRpYW5zXHJcbiAqL1xyXG5mdW5jdGlvbiB0b1JhZGlhbnMoZGVncmVlcykge1xyXG4gICAgcmV0dXJuIChkZWdyZWVzIC8gMTgwKSAqIE1hdGguUEk7XHJcbn1cclxuLyoqXHJcbiAqIEZpbmQgdGhlIHNjcmVlbiBwb3NpdGlvbiBvZiBhbiBIVE1MIGVsZW1lbnRcclxuICovXHJcbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGVsKSB7XHJcbiAgICBsZXQgb0xlZnQgPSAwLCBvVG9wID0gMDtcclxuICAgIGNvbnN0IGNhbGNPZmZzZXRMZWZ0ID0gKHBhcmVudCkgPT4ge1xyXG4gICAgICAgIG9MZWZ0ICs9IHBhcmVudC5vZmZzZXRMZWZ0O1xyXG4gICAgICAgIGlmIChwYXJlbnQub2Zmc2V0UGFyZW50KSB7XHJcbiAgICAgICAgICAgIGNhbGNPZmZzZXRMZWZ0KHBhcmVudC5vZmZzZXRQYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBjYWxjT2Zmc2V0VG9wID0gKHBhcmVudCkgPT4ge1xyXG4gICAgICAgIG9Ub3AgKz0gcGFyZW50Lm9mZnNldFRvcDtcclxuICAgICAgICBpZiAocGFyZW50Lm9mZnNldFBhcmVudCkge1xyXG4gICAgICAgICAgICBjYWxjT2Zmc2V0VG9wKHBhcmVudC5vZmZzZXRQYXJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjYWxjT2Zmc2V0TGVmdChlbCk7XHJcbiAgICBjYWxjT2Zmc2V0VG9wKGVsKTtcclxuICAgIHJldHVybiBuZXcgVmVjdG9yKG9MZWZ0LCBvVG9wKTtcclxufVxyXG4vKipcclxuICogQWRkIGFuIGl0ZW0gdG8gYW4gYXJyYXkgbGlzdCBpZiBpdCBkb2Vzbid0IGFscmVhZHkgZXhpc3QuIFJldHVybnMgdHJ1ZSBpZiBhZGRlZCwgZmFsc2UgaWYgbm90IGFuZCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgYXJyYXkuXHJcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGRJdGVtVG9BcnJheShpdGVtLCBhcnJheSkge1xyXG4gICAgaWYgKGFycmF5LmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XHJcbiAgICAgICAgYXJyYXkucHVzaChpdGVtKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogUmVtb3ZlIGFuIGl0ZW0gZnJvbSBhbiBsaXN0XHJcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVJdGVtRnJvbUFycmF5KGl0ZW0sIGFycmF5KSB7XHJcbiAgICBsZXQgaW5kZXggPSAtMTtcclxuICAgIGlmICgoaW5kZXggPSBhcnJheS5pbmRleE9mKGl0ZW0pKSA+IC0xKSB7XHJcbiAgICAgICAgYXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogU2VlIGlmIGFuIGFycmF5IGNvbnRhaW5zIHNvbWV0aGluZ1xyXG4gKi9cclxuZnVuY3Rpb24gY29udGFpbnMoYXJyYXksIG9iaikge1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gb2JqKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG4vKipcclxuICogR2V0IHRoZSBvcHBvc2l0IHNpZGVcclxuICogVE9ETzogTW92ZSB0byBTaWRlIHR5cGVcclxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmZ1bmN0aW9uIGdldE9wcG9zaXRlU2lkZShzaWRlKSB7XHJcbiAgICBpZiAoc2lkZSA9PT0gU2lkZS5Ub3ApIHtcclxuICAgICAgICByZXR1cm4gU2lkZS5Cb3R0b207XHJcbiAgICB9XHJcbiAgICBpZiAoc2lkZSA9PT0gU2lkZS5Cb3R0b20pIHtcclxuICAgICAgICByZXR1cm4gU2lkZS5Ub3A7XHJcbiAgICB9XHJcbiAgICBpZiAoc2lkZSA9PT0gU2lkZS5MZWZ0KSB7XHJcbiAgICAgICAgcmV0dXJuIFNpZGUuUmlnaHQ7XHJcbiAgICB9XHJcbiAgICBpZiAoc2lkZSA9PT0gU2lkZS5SaWdodCkge1xyXG4gICAgICAgIHJldHVybiBTaWRlLkxlZnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gU2lkZS5Ob25lO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBzaWRlIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHZlY3RvciBzdXBwbGllZFxyXG4gKiBAcGFyYW0gZGlyZWN0aW9uIFZlY3RvciB0byBjaGVja1xyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKiBUT0RPOiBNb3ZlIHRvIFNpZGUgdHlwZVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U2lkZUZyb21EaXJlY3Rpb24oZGlyZWN0aW9uKSB7XHJcbiAgICBjb25zdCBkaXJlY3Rpb25zID0gW1ZlY3Rvci5MZWZ0LCBWZWN0b3IuUmlnaHQsIFZlY3Rvci5VcCwgVmVjdG9yLkRvd25dO1xyXG4gICAgY29uc3QgZGlyZWN0aW9uRW51bSA9IFtTaWRlLkxlZnQsIFNpZGUuUmlnaHQsIFNpZGUuVG9wLCBTaWRlLkJvdHRvbV07XHJcbiAgICBsZXQgbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICBsZXQgbWF4SW5kZXggPSAtMTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlyZWN0aW9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb25zW2ldLmRvdChkaXJlY3Rpb24pID4gbWF4KSB7XHJcbiAgICAgICAgICAgIG1heCA9IGRpcmVjdGlvbnNbaV0uZG90KGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIG1heEluZGV4ID0gaTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZGlyZWN0aW9uRW51bVttYXhJbmRleF07XHJcbn1cclxuLyoqXHJcbiAqIEV4Y2FsaWJ1cidzIGR5bmFtaWNhbGx5IHJlc2l6aW5nIGNvbGxlY3Rpb25cclxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIHYwLjI2LjBcclxuICovXHJcbmNsYXNzIENvbGxlY3Rpb24ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gaW5pdGlhbFNpemUgIEluaXRpYWwgc2l6ZSBvZiB0aGUgaW50ZXJuYWwgYmFja2luZyBhcnJheVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihpbml0aWFsU2l6ZSA9IENvbGxlY3Rpb24uRGVmYXVsdFNpemUpIHtcclxuICAgICAgICB0aGlzLl9pbnRlcm5hbEFycmF5ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9lbmRQb2ludGVyID0gMDtcclxuICAgICAgICB0aGlzLl9pbnRlcm5hbEFycmF5ID0gbmV3IEFycmF5KGluaXRpYWxTaXplKTtcclxuICAgIH1cclxuICAgIF9yZXNpemUoKSB7XHJcbiAgICAgICAgY29uc3QgbmV3U2l6ZSA9IHRoaXMuX2ludGVybmFsQXJyYXkubGVuZ3RoICogMjtcclxuICAgICAgICBjb25zdCBuZXdBcnJheSA9IG5ldyBBcnJheShuZXdTaXplKTtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuY291bnQoKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcclxuICAgICAgICAgICAgbmV3QXJyYXlbaV0gPSB0aGlzLl9pbnRlcm5hbEFycmF5W2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgdGhpcy5faW50ZXJuYWxBcnJheTtcclxuICAgICAgICB0aGlzLl9pbnRlcm5hbEFycmF5ID0gbmV3QXJyYXk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFB1c2ggZWxlbWVudHMgdG8gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvblxyXG4gICAgICovXHJcbiAgICBwdXNoKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fZW5kUG9pbnRlciA9PT0gdGhpcy5faW50ZXJuYWxBcnJheS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVzaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAodGhpcy5faW50ZXJuYWxBcnJheVt0aGlzLl9lbmRQb2ludGVyKytdID0gZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSB0aGUgZW5kIG9mIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHBvcCgpIHtcclxuICAgICAgICB0aGlzLl9lbmRQb2ludGVyID0gdGhpcy5fZW5kUG9pbnRlciAtIDEgPCAwID8gMCA6IHRoaXMuX2VuZFBvaW50ZXIgLSAxO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pbnRlcm5hbEFycmF5W3RoaXMuX2VuZFBvaW50ZXJdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb3VudCBvZiB0aGUgY29sbGVjdGlvblxyXG4gICAgICovXHJcbiAgICBjb3VudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZW5kUG9pbnRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRW1wdGllcyB0aGUgY29sbGVjdGlvblxyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLl9lbmRQb2ludGVyID0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgaW50ZXJuYWwgYmFja2luZyBhcnJheVxyXG4gICAgICovXHJcbiAgICBpbnRlcm5hbFNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXkubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFuIGVsZW1lbnQgYXQgYSBzcGVjaWZpYyBpbmRleFxyXG4gICAgICogQHBhcmFtIGluZGV4ICBJbmRleCBvZiBlbGVtZW50IHRvIHJldHJpZXZlXHJcbiAgICAgKi9cclxuICAgIGVsZW1lbnRBdChpbmRleCkge1xyXG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLmNvdW50KCkpIHtcclxuICAgICAgICAgICAgLy9Mb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignSW52YWxpZCBwYXJhbWV0ZXI6ICcgKyBpbmRleCk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbmRleCAnICsgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxBcnJheVtpbmRleF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYW4gZWxlbWVudCBhdCBhIHNwZWNpZmljIGluZGV4XHJcbiAgICAgKiBAcGFyYW0gaW5kZXggIEluZGV4IHRvIGluc2VydCB0aGUgZWxlbWVudFxyXG4gICAgICogQHBhcmFtIHZhbHVlICBFbGVtZW50IHRvIGluc2VydFxyXG4gICAgICovXHJcbiAgICBpbnNlcnQoaW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuY291bnQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXNpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9pbnRlcm5hbEFycmF5W2luZGV4XSA9IHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGF0IGEgc3BlY2lmaWMgaW5kZXhcclxuICAgICAqIEBwYXJhbSBpbmRleCAgSW5kZXggb2YgZWxlbWVudCB0byByZW1vdmVcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGluZGV4KSB7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmNvdW50KCk7XHJcbiAgICAgICAgaWYgKGNvdW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgIC8vTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyOiAnICsgaW5kZXgpO1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyICcgKyBpbmRleCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE8obikgU2hpZnRcclxuICAgICAgICBjb25zdCByZW1vdmVkID0gdGhpcy5faW50ZXJuYWxBcnJheVtpbmRleF07XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4OyBpIDwgY291bnQ7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnRlcm5hbEFycmF5W2ldID0gdGhpcy5faW50ZXJuYWxBcnJheVtpICsgMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VuZFBvaW50ZXItLTtcclxuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGJ5IHJlZmVyZW5jZVxyXG4gICAgICogQHBhcmFtIGVsZW1lbnQgIEVsZW1lbnQgdG8gcmV0cmlldmVcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlRWxlbWVudChlbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9pbnRlcm5hbEFycmF5LmluZGV4T2YoZWxlbWVudCk7XHJcbiAgICAgICAgdGhpcy5yZW1vdmUoaW5kZXgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIHRvQXJyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsQXJyYXkuc2xpY2UoMCwgdGhpcy5fZW5kUG9pbnRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGUgb3ZlciBldmVyeSBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZnVuYyAgQ2FsbGJhY2sgdG8gY2FsbCBmb3IgZWFjaCBlbGVtZW50IHBhc3NpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCwgcmV0dXJuZWQgdmFsdWVzIGFyZSBpZ25vcmVkXHJcbiAgICAgKi9cclxuICAgIGZvckVhY2goZnVuYykge1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBjb25zdCBjb3VudCA9IHRoaXMuY291bnQoKTtcclxuICAgICAgICBmb3IgKGk7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZ1bmMuY2FsbCh0aGlzLCB0aGlzLl9pbnRlcm5hbEFycmF5W2ldLCBpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE11dGF0ZSBldmVyeSBlbGVtZW50IGluIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZnVuYyAgQ2FsbGJhY2sgdG8gY2FsbCBmb3IgZWFjaCBlbGVtZW50IHBhc3NpbmcgYSByZWZlcmVuY2UgdG8gdGhlIGVsZW1lbnQgYW5kIGl0cyBpbmRleCwgYW55IHZhbHVlcyByZXR1cm5lZCBtdXRhdGVcclxuICAgICAqIHRoZSBjb2xsZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIG1hcChmdW5jKSB7XHJcbiAgICAgICAgY29uc3QgY291bnQgPSB0aGlzLmNvdW50KCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQXJyYXlbaV0gPSBmdW5jLmNhbGwodGhpcywgdGhpcy5faW50ZXJuYWxBcnJheVtpXSwgaSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBEZWZhdWx0IGNvbGxlY3Rpb24gc2l6ZVxyXG4gKi9cclxuQ29sbGVjdGlvbi5EZWZhdWx0U2l6ZSA9IDIwMDtcclxuLyoqXHJcbiAqIFVzZWQgZm9yIGV4aGF1c3RpdmUgY2hlY2tzIGF0IGNvbXBpbGUgdGltZVxyXG4gKi9cclxuZnVuY3Rpb24gZmFpbChtZXNzYWdlKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbn1cclxuLyoqXHJcbiAqIEdlbmVyYXRlIGEgcmFuZ2Ugb2YgbnVtYmVyc1xyXG4gKiBGb3IgZXhhbXBsZTogcmFuZ2UoMCwgNSkgLT4gWzAsIDEsIDIsIDMsIDQsIDVdXHJcbiAqIEBwYXJhbSBmcm9tIGluY2x1c2l2ZVxyXG4gKiBAcGFyYW0gdG8gaW5jbHVzaXZlXHJcbiAqL1xyXG5jb25zdCByYW5nZSA9IChmcm9tLCB0bykgPT4gQXJyYXkuZnJvbShuZXcgQXJyYXkodG8gLSBmcm9tICsgMSksIChfeCwgaSkgPT4gaSArIGZyb20pO1xyXG4vKipcclxuICogQ3JlYXRlIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIGEgY2VydGFpbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzXHJcbiAqIEBwYXJhbSBtaWxsaXNlY29uZHNcclxuICovXHJcbmZ1bmN0aW9uIGRlbGF5KG1pbGxpc2Vjb25kcykge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9LCBtaWxsaXNlY29uZHMpO1xyXG4gICAgfSk7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL0RlY29yYXRvcnMudHNcblxyXG5cclxuXHJcbmNvbnN0IG1heE1lc3NhZ2VzID0gNTtcclxuY29uc3Qgb2Jzb2xldGVNZXNzYWdlID0ge307XHJcbmNvbnN0IHJlc2V0T2Jzb2xldGVDb3VudGVyID0gKCkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBtZXNzYWdlIGluIG9ic29sZXRlTWVzc2FnZSkge1xyXG4gICAgICAgIG9ic29sZXRlTWVzc2FnZVttZXNzYWdlXSA9IDA7XHJcbiAgICB9XHJcbn07XHJcbmNvbnN0IGxvZ01lc3NhZ2UgPSAobWVzc2FnZSwgb3B0aW9ucykgPT4ge1xyXG4gICAgY29uc3Qgc3VwcHJlc3NPYnNvbGV0ZU1lc3NhZ2VzID0gRmxhZ3MuaXNFbmFibGVkKCdzdXBwcmVzcy1vYnNvbGV0ZS1tZXNzYWdlJyk7XHJcbiAgICBpZiAob2Jzb2xldGVNZXNzYWdlW21lc3NhZ2VdIDwgbWF4TWVzc2FnZXMgJiYgIXN1cHByZXNzT2Jzb2xldGVNZXNzYWdlcykge1xyXG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4obWVzc2FnZSk7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1jb25zb2xlXHJcbiAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UgJiYgb3B0aW9ucy5zaG93U3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgY29uc29sZS50cmFjZSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9ic29sZXRlTWVzc2FnZVttZXNzYWdlXSsrO1xyXG59O1xyXG4vKipcclxuICogT2Jzb2xldGUgZGVjb3JhdG9yIGZvciBtYXJraW5nIEV4Y2FsaWJ1ciBtZXRob2RzIG9ic29sZXRlLCB5b3UgY2FuIG9wdGlvbmFsbHkgc3BlY2lmeSBhIGN1c3RvbSBtZXNzYWdlIGFuZC9vciBhbHRlcm5hdGUgcmVwbGFjZW1lbnRcclxuICogbWV0aG9kIGRvIHRoZSBkZXByZWNhdGVkIG9uZS4gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2pheXBoZWxwcy9jb3JlLWRlY29yYXRvcnMuanNcclxuICovXHJcbmZ1bmN0aW9uIG9ic29sZXRlKG9wdGlvbnMpIHtcclxuICAgIG9wdGlvbnMgPSBleHRlbmQoe30sIHtcclxuICAgICAgICBtZXNzYWdlOiAnVGhpcyBmZWF0dXJlIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgRXhjYWxpYnVyLicsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiBudWxsLFxyXG4gICAgICAgIHNob3dTdGFja1RyYWNrOiBmYWxzZVxyXG4gICAgfSwgb3B0aW9ucyk7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwgcHJvcGVydHksIGRlc2NyaXB0b3IpIHtcclxuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJlxyXG4gICAgICAgICAgICAhKHR5cGVvZiBkZXNjcmlwdG9yLnZhbHVlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLmdldCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5zZXQgPT09ICdmdW5jdGlvbicpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignT25seSBjbGFzc2VzL2Z1bmN0aW9ucy9nZXR0ZXJzL3NldHRlcnMgY2FuIGJlIG1hcmtlZCBhcyBvYnNvbGV0ZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBtZXRob2RTaWduYXR1cmUgPSBgJHt0YXJnZXQubmFtZSB8fCAnJ30ke3RhcmdldC5uYW1lICYmIHByb3BlcnR5ID8gJy4nIDogJyd9JHtwcm9wZXJ0eSA/IHByb3BlcnR5IDogJyd9YDtcclxuICAgICAgICBjb25zdCBtZXNzYWdlID0gYCR7bWV0aG9kU2lnbmF0dXJlfSBpcyBtYXJrZWQgb2Jzb2xldGU6ICR7b3B0aW9ucy5tZXNzYWdlfWAgK1xyXG4gICAgICAgICAgICAob3B0aW9ucy5hbHRlcm5hdGVNZXRob2QgPyBgIFVzZSAke29wdGlvbnMuYWx0ZXJuYXRlTWV0aG9kfSBpbnN0ZWFkYCA6ICcnKTtcclxuICAgICAgICBpZiAoIW9ic29sZXRlTWVzc2FnZVttZXNzYWdlXSkge1xyXG4gICAgICAgICAgICBvYnNvbGV0ZU1lc3NhZ2VbbWVzc2FnZV0gPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBkZXNjcmlwdG9yIGlzIG51bGwgaXQgaXMgYSBjbGFzc1xyXG4gICAgICAgIGNvbnN0IG1ldGhvZCA9IGRlc2NyaXB0b3IgPyBPYmplY3QuYXNzaWduKHt9LCBkZXNjcmlwdG9yKSA6IHRhcmdldDtcclxuICAgICAgICBpZiAoIWRlc2NyaXB0b3IpIHtcclxuICAgICAgICAgICAgLy8gd2l0aCBlczIwMTUgY2xhc3NlcyB3ZSBuZWVkIHRvIGNoYW5nZSBvdXIgZGVjb3JhdGlvbiB0YWN0aWNcclxuICAgICAgICAgICAgY2xhc3MgRGVjb3JhdGVkQ2xhc3MgZXh0ZW5kcyBtZXRob2Qge1xyXG4gICAgICAgICAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxvZ01lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIoLi4uYXJncyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRlZENsYXNzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlKSB7XHJcbiAgICAgICAgICAgIG1ldGhvZC52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGxvZ01lc3NhZ2UobWVzc2FnZSwgb3B0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpcHRvci52YWx1ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLmdldCkge1xyXG4gICAgICAgICAgICBtZXRob2QuZ2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbG9nTWVzc2FnZShtZXNzYWdlLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yLmdldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnNldCkge1xyXG4gICAgICAgICAgICBtZXRob2Quc2V0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgbG9nTWVzc2FnZShtZXNzYWdlLCBvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjcmlwdG9yLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbWV0aG9kO1xyXG4gICAgfTtcclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL01hdGgvdmVjdG9yLnRzXG52YXIgX19kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBIDJEIHZlY3RvciBvbiBhIHBsYW5lLlxyXG4gKi9cclxuY2xhc3MgVmVjdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHggIFggY29tcG9uZW50IG9mIHRoZSBWZWN0b3JcclxuICAgICAqIEBwYXJhbSB5ICBZIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHgsIHkpIHtcclxuICAgICAgICB0aGlzLl94ID0gMDtcclxuICAgICAgICB0aGlzLl95ID0gMDtcclxuICAgICAgICB0aGlzLl94ID0geDtcclxuICAgICAgICB0aGlzLl95ID0geTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSAoMCwgMCkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgWmVybygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSAoMSwgMSkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgT25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDEsIDEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBICgwLjUsIDAuNSkgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgSGFsZigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLjUsIDAuNSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgdXAgKDAsIC0xKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IFVwKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIC0xKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQSB1bml0IHZlY3RvciBwb2ludGluZyBkb3duICgwLCAxKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IERvd24oKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMCwgMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgbGVmdCAoLTEsIDApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgTGVmdCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigtMSwgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEEgdW5pdCB2ZWN0b3IgcG9pbnRpbmcgcmlnaHQgKDEsIDApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgUmlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMSwgMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSB2ZWN0b3Igb2YgdW5pdCBsZW5ndGggaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgc3BlY2lmaWVkIGFuZ2xlIGluIFJhZGlhbnMuXHJcbiAgICAgKiBAcGFyYW0gYW5nbGUgVGhlIGFuZ2xlIHRvIGdlbmVyYXRlIHRoZSB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGZyb21BbmdsZShhbmdsZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKE1hdGguY29zKGFuZ2xlKSwgTWF0aC5zaW4oYW5nbGUpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIHZlY3RvciBpcyBub3QgbnVsbCwgdW5kZWZpbmVkLCBvciBpZiBhbnkgb2YgaXRzIGNvbXBvbmVudHMgYXJlIE5hTiBvciBJbmZpbml0eS5cclxuICAgICAqL1xyXG4gICAgc3RhdGljIGlzVmFsaWQodmVjKSB7XHJcbiAgICAgICAgaWYgKHZlYyA9PT0gbnVsbCB8fCB2ZWMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc05hTih2ZWMueCkgfHwgaXNOYU4odmVjLnkpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHZlYy54ID09PSBJbmZpbml0eSB8fCB2ZWMueSA9PT0gSW5maW5pdHkgfHwgdmVjLnggPT09IC1JbmZpbml0eSB8fCB2ZWMueSA9PT0gLUluZmluaXR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGN1bGF0ZXMgZGlzdGFuY2UgYmV0d2VlbiB0d28gVmVjdG9yc1xyXG4gICAgICogQHBhcmFtIHZlYzFcclxuICAgICAqIEBwYXJhbSB2ZWMyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBkaXN0YW5jZSh2ZWMxLCB2ZWMyKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyh2ZWMxLnggLSB2ZWMyLngsIDIpICsgTWF0aC5wb3codmVjMS55IC0gdmVjMi55LCAyKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgeCBjb21wb25lbnQgb2YgdGhlIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBnZXQgeCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5feDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSB4IGNvbXBvbmVudCwgVEhJUyBNVVRBVEVTIHRoZSBjdXJyZW50IHZlY3Rvci4gSXQgaXMgdXN1YWxseSBiZXR0ZXIgdG8gY3JlYXRlIGEgbmV3IHZlY3Rvci5cclxuICAgICAqIEB3YXJuaW5nICoqQmUgdmVyeSBjYXJlZnVsIHNldHRpbmcgY29tcG9uZW50cyBvbiBzaGFyZWQgdmVjdG9ycywgbXV0YXRpbmcgc2hhcmVkIHZlY3RvcnMgY2FuIGNhdXNlIGhhcmQgdG8gZmluZCBidWdzKipcclxuICAgICAqL1xyXG4gICAgc2V0IHgodmFsKSB7XHJcbiAgICAgICAgdGhpcy5feCA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB5IGNvbXBvbmVudCBvZiB0aGUgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldCB5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl95O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHkgY29tcG9uZW50LCBUSElTIE1VVEFURVMgdGhlIGN1cnJlbnQgdmVjdG9yLiBJdCBpcyB1c3VhbGx5IGJldHRlciB0byBjcmVhdGUgYSBuZXcgdmVjdG9yLlxyXG4gICAgICogQHdhcm5pbmcgKipCZSB2ZXJ5IGNhcmVmdWwgc2V0dGluZyBjb21wb25lbnRzIG9uIHNoYXJlZCB2ZWN0b3JzLCBtdXRhdGluZyBzaGFyZWQgdmVjdG9ycyBjYW4gY2F1c2UgaGFyZCB0byBmaW5kIGJ1Z3MqKlxyXG4gICAgICovXHJcbiAgICBzZXQgeSh2YWwpIHtcclxuICAgICAgICB0aGlzLl95ID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB4IGFuZCB5IGNvbXBvbmVudHMgYXQgb25jZSwgVEhJUyBNVVRBVEVTIHRoZSBjdXJyZW50IHZlY3Rvci4gSXQgaXMgdXN1YWxseSBiZXR0ZXIgdG8gY3JlYXRlIGEgbmV3IHZlY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiBAd2FybmluZyAqKkJlIHZlcnkgY2FyZWZ1bCB1c2luZyB0aGlzLCBtdXRhdGluZyB2ZWN0b3JzIGNhbiBjYXVzZSBoYXJkIHRvIGZpbmQgYnVncyoqXHJcbiAgICAgKi9cclxuICAgIHNldFRvKHgsIHkpIHtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbXBhcmVzIHRoaXMgcG9pbnQgYWdhaW5zdCBhbm90aGVyIGFuZCB0ZXN0cyBmb3IgZXF1YWxpdHlcclxuICAgICAqIEBwYXJhbSB2ZWN0b3IgVGhlIG90aGVyIHBvaW50IHRvIGNvbXBhcmUgdG9cclxuICAgICAqIEBwYXJhbSB0b2xlcmFuY2UgQW1vdW50IG9mIGV1Y2xpZGVhbiBkaXN0YW5jZSBvZmYgd2UgYXJlIHdpbGxpbmcgdG8gdG9sZXJhdGVcclxuICAgICAqL1xyXG4gICAgZXF1YWxzKHZlY3RvciwgdG9sZXJhbmNlID0gMC4wMDEpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy54IC0gdmVjdG9yLngpIDw9IHRvbGVyYW5jZSAmJiBNYXRoLmFicyh0aGlzLnkgLSB2ZWN0b3IueSkgPD0gdG9sZXJhbmNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZGlzdGFuY2UgdG8gYW5vdGhlciB2ZWN0b3IuIElmIG5vIG90aGVyIFZlY3RvciBpcyBzcGVjaWZpZWQsIHRoaXMgd2lsbCByZXR1cm4gdGhlIFtbbWFnbml0dWRlXV0uXHJcbiAgICAgKiBAcGFyYW0gdiAgVGhlIG90aGVyIHZlY3Rvci4gTGVhdmUgYmxhbmsgdG8gdXNlIG9yaWdpbiB2ZWN0b3IuXHJcbiAgICAgKi9cclxuICAgIGRpc3RhbmNlKHYpIHtcclxuICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgICAgdiA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMueCAtIHYueCwgMikgKyBNYXRoLnBvdyh0aGlzLnkgLSB2LnksIDIpKTtcclxuICAgIH1cclxuICAgIHNxdWFyZURpc3RhbmNlKHYpIHtcclxuICAgICAgICBpZiAoIXYpIHtcclxuICAgICAgICAgICAgdiA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gTWF0aC5wb3codGhpcy54IC0gdi54LCAyKSArIE1hdGgucG93KHRoaXMueSAtIHYueSwgMik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBtYWduaXR1ZGUgKHNpemUpIG9mIHRoZSBWZWN0b3JcclxuICAgICAqIEBkZXByZWNhdGVkIG1hZ25pdHVkZSB3aWxsIGJlIHJlbW92ZWQgaW4gZmF2b3VyIG9mICcuc2l6ZScgaW4gdmVyc2lvbiAwLjI1LjBcclxuICAgICAqL1xyXG4gICAgbWFnbml0dWRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRpc3RhbmNlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBzaXplIChtYWduaXR1ZGUpIG9mIHRoZSBWZWN0b3JcclxuICAgICAqL1xyXG4gICAgZ2V0IHNpemUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzdGFuY2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0dGluZyB0aGUgc2l6ZSBtdXRhdGVzIHRoZSBjdXJyZW50IHZlY3RvclxyXG4gICAgICpcclxuICAgICAqIEB3YXJuaW5nIENhbiBiZSB1c2VkIHRvIHNldCB0aGUgc2l6ZSBvZiB0aGUgdmVjdG9yLCAqKmJlIHZlcnkgY2FyZWZ1bCB1c2luZyB0aGlzLCBtdXRhdGluZyB2ZWN0b3JzIGNhbiBjYXVzZSBoYXJkIHRvIGZpbmQgYnVncyoqXHJcbiAgICAgKi9cclxuICAgIHNldCBzaXplKG5ld0xlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLm5vcm1hbGl6ZSgpLnNjYWxlKG5ld0xlbmd0aCk7XHJcbiAgICAgICAgdGhpcy5zZXRUbyh2LngsIHYueSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE5vcm1hbGl6ZXMgYSB2ZWN0b3IgdG8gaGF2ZSBhIG1hZ25pdHVkZSBvZiAxLlxyXG4gICAgICovXHJcbiAgICBub3JtYWxpemUoKSB7XHJcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZGlzdGFuY2UoKTtcclxuICAgICAgICBpZiAoZCA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54IC8gZCwgdGhpcy55IC8gZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigwLCAxKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGF2ZXJhZ2UgKG1pZHBvaW50KSBiZXR3ZWVuIHRoZSBjdXJyZW50IHBvaW50IGFuZCB0aGUgc3BlY2lmaWVkXHJcbiAgICAgKi9cclxuICAgIGF2ZXJhZ2UodmVjKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKHZlYykuc2NhbGUoMC41KTtcclxuICAgIH1cclxuICAgIHNjYWxlKHNpemVPclNjYWxlKSB7XHJcbiAgICAgICAgaWYgKHNpemVPclNjYWxlIGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAqIHNpemVPclNjYWxlLngsIHRoaXMueSAqIHNpemVPclNjYWxlLnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54ICogc2l6ZU9yU2NhbGUsIHRoaXMueSAqIHNpemVPclNjYWxlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgb25lIHZlY3RvciB0byBhbm90aGVyXHJcbiAgICAgKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBhZGQodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCArIHYueCwgdGhpcy55ICsgdi55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3VidHJhY3RzIGEgdmVjdG9yIGZyb20gYW5vdGhlciwgaWYgeW91IHN1YnRyYWN0IHZlY3RvciBgQi5zdWIoQSlgIHRoZSByZXN1bHRpbmcgdmVjdG9yIHBvaW50cyBmcm9tIEEgLT4gQlxyXG4gICAgICogQHBhcmFtIHYgVGhlIHZlY3RvciB0byBzdWJ0cmFjdFxyXG4gICAgICovXHJcbiAgICBzdWIodikge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCAtIHYueCwgdGhpcy55IC0gdi55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBvbmUgdmVjdG9yIHRvIHRoaXMgb25lIG1vZGlmeWluZyB0aGUgb3JpZ2luYWxcclxuICAgICAqIEBwYXJhbSB2IFRoZSB2ZWN0b3IgdG8gYWRkXHJcbiAgICAgKiBAd2FybmluZyBCZSB2ZXJ5IGNhcmVmdWwgdXNpbmcgdGhpcywgbXV0YXRpbmcgdmVjdG9ycyBjYW4gY2F1c2UgaGFyZCB0byBmaW5kIGJ1Z3NcclxuICAgICAqL1xyXG4gICAgYWRkRXF1YWwodikge1xyXG4gICAgICAgIHRoaXMuc2V0VG8odGhpcy54ICsgdi54LCB0aGlzLnkgKyB2LnkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdWJ0cmFjdHMgYSB2ZWN0b3IgZnJvbSB0aGlzIG9uZSBtb2RpZnlpbmcgdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBAcGFyYW0gdiBUaGUgdmVjdG9yIHRvIHN1YnRyYWN0XHJcbiAgICAgKiBAd2FybmluZyBCZSB2ZXJ5IGNhcmVmdWwgdXNpbmcgdGhpcywgbXV0YXRpbmcgdmVjdG9ycyBjYW4gY2F1c2UgaGFyZCB0byBmaW5kIGJ1Z3NcclxuICAgICAqL1xyXG4gICAgc3ViRXF1YWwodikge1xyXG4gICAgICAgIHRoaXMuc2V0VG8odGhpcy54IC0gdi54LCB0aGlzLnkgLSB2LnkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2FsZXMgdGhpcyB2ZWN0b3IgYnkgYSBmYWN0b3Igb2Ygc2l6ZSBhbmQgbW9kaWZpZXMgdGhlIG9yaWdpbmFsXHJcbiAgICAgKiBAd2FybmluZyBCZSB2ZXJ5IGNhcmVmdWwgdXNpbmcgdGhpcywgbXV0YXRpbmcgdmVjdG9ycyBjYW4gY2F1c2UgaGFyZCB0byBmaW5kIGJ1Z3NcclxuICAgICAqL1xyXG4gICAgc2NhbGVFcXVhbChzaXplKSB7XHJcbiAgICAgICAgdGhpcy5zZXRUbyh0aGlzLnggKiBzaXplLCB0aGlzLnkgKiBzaXplKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGVyZm9ybXMgYSBkb3QgcHJvZHVjdCB3aXRoIGFub3RoZXIgdmVjdG9yXHJcbiAgICAgKiBAcGFyYW0gdiAgVGhlIHZlY3RvciB0byBkb3RcclxuICAgICAqL1xyXG4gICAgZG90KHYpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy54ICogdi54ICsgdGhpcy55ICogdi55O1xyXG4gICAgfVxyXG4gICAgY3Jvc3Modikge1xyXG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgVmVjdG9yKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnggKiB2LnkgLSB0aGlzLnkgKiB2Lng7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih2ICogdGhpcy55LCAtdiAqIHRoaXMueCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGNyb3NzKG51bSwgdmVjKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoLW51bSAqIHZlYy55LCBudW0gKiB2ZWMueCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHBlcnBlbmRpY3VsYXIgdmVjdG9yIHRvIHRoaXMgb25lXHJcbiAgICAgKi9cclxuICAgIHBlcnBlbmRpY3VsYXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy55LCAtdGhpcy54KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbm9ybWFsIHZlY3RvciB0byB0aGlzIG9uZSwgc2FtZSBhcyB0aGUgcGVycGVuZGljdWxhciBvZiBsZW5ndGggMVxyXG4gICAgICovXHJcbiAgICBub3JtYWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGVycGVuZGljdWxhcigpLm5vcm1hbGl6ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOZWdhdGUgdGhlIGN1cnJlbnQgdmVjdG9yXHJcbiAgICAgKi9cclxuICAgIG5lZ2F0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZSgtMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGFuZ2xlIG9mIHRoaXMgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICB0b0FuZ2xlKCkge1xyXG4gICAgICAgIHJldHVybiBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUm90YXRlcyB0aGUgY3VycmVudCB2ZWN0b3IgYXJvdW5kIGEgcG9pbnQgYnkgYSBjZXJ0YWluIG51bWJlciBvZlxyXG4gICAgICogZGVncmVlcyBpbiByYWRpYW5zXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZShhbmdsZSwgYW5jaG9yKSB7XHJcbiAgICAgICAgaWYgKCFhbmNob3IpIHtcclxuICAgICAgICAgICAgYW5jaG9yID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc2luQW5nbGUgPSBNYXRoLnNpbihhbmdsZSk7XHJcbiAgICAgICAgY29uc3QgY29zQW5nbGUgPSBNYXRoLmNvcyhhbmdsZSk7XHJcbiAgICAgICAgY29uc3QgeCA9IGNvc0FuZ2xlICogKHRoaXMueCAtIGFuY2hvci54KSAtIHNpbkFuZ2xlICogKHRoaXMueSAtIGFuY2hvci55KSArIGFuY2hvci54O1xyXG4gICAgICAgIGNvbnN0IHkgPSBzaW5BbmdsZSAqICh0aGlzLnggLSBhbmNob3IueCkgKyBjb3NBbmdsZSAqICh0aGlzLnkgLSBhbmNob3IueSkgKyBhbmNob3IueTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih4LCB5KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgdmVjdG9yIHRoYXQgaGFzIHRoZSBzYW1lIHZhbHVlcyBhcyB0aGUgcHJldmlvdXMuXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMueCwgdGhpcy55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgdmVjdG9yLlxyXG4gICAgICovXHJcbiAgICB0b1N0cmluZyhmaXhlZCkge1xyXG4gICAgICAgIGlmIChmaXhlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gYCgke3RoaXMueC50b0ZpeGVkKGZpeGVkKX0sICR7dGhpcy55LnRvRml4ZWQoZml4ZWQpfSlgO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYCgke3RoaXMueH0sICR7dGhpcy55fSlgO1xyXG4gICAgfVxyXG59XHJcbl9fZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnd2lsbCBiZSByZW1vdmVkIGluIGZhdm91ciBvZiBgLnNpemVgIGluIHZlcnNpb24gMC4yNS4wJyB9KVxyXG5dLCBWZWN0b3IucHJvdG90eXBlLCBcIm1hZ25pdHVkZVwiLCBudWxsKTtcclxuLyoqXHJcbiAqIFNob3J0aGFuZCBmb3IgY3JlYXRpbmcgbmV3IFZlY3RvcnMgLSByZXR1cm5zIGEgbmV3IFZlY3RvciBpbnN0YW5jZSB3aXRoIHRoZVxyXG4gKiBwcm92aWRlZCBYIGFuZCBZIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB4ICBYIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXHJcbiAqIEBwYXJhbSB5ICBZIGNvbXBvbmVudCBvZiB0aGUgVmVjdG9yXHJcbiAqL1xyXG5mdW5jdGlvbiB2ZWMoeCwgeSkge1xyXG4gICAgcmV0dXJuIG5ldyBWZWN0b3IoeCwgeSk7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xvci50c1xudmFyIENvbG9yX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFByb3ZpZGVzIHN0YW5kYXJkIGNvbG9ycyAoZS5nLiBbW0NvbG9yLkJsYWNrXV0pXHJcbiAqIGJ1dCB5b3UgY2FuIGFsc28gY3JlYXRlIGN1c3RvbSBjb2xvcnMgdXNpbmcgUkdCLCBIU0wsIG9yIEhleC4gQWxzbyBwcm92aWRlc1xyXG4gKiB1c2VmdWwgY29sb3Igb3BlcmF0aW9ucyBsaWtlIFtbQ29sb3IubGlnaHRlbl1dLCBbW0NvbG9yLmRhcmtlbl1dLCBhbmQgbW9yZS5cclxuICovXHJcbmNsYXNzIENvbG9yIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDb2xvciBmcm9tIGFuIHIsIGcsIGIsIGFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gciAgVGhlIHJlZCBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICogQHBhcmFtIGcgIFRoZSBncmVlbiBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICogQHBhcmFtIGIgIFRoZSBibHVlIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgKiBAcGFyYW0gYSAgVGhlIGFscGhhIGNvbXBvbmVudCBvZiBjb2xvciAoMC0xLjApXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHIsIGcsIGIsIGEpIHtcclxuICAgICAgICB0aGlzLnIgPSByO1xyXG4gICAgICAgIHRoaXMuZyA9IGc7XHJcbiAgICAgICAgdGhpcy5iID0gYjtcclxuICAgICAgICB0aGlzLmEgPSBhICE9IG51bGwgPyBhIDogMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDb2xvciBmcm9tIGFuIHIsIGcsIGIsIGFcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gciAgVGhlIHJlZCBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICogQHBhcmFtIGcgIFRoZSBncmVlbiBjb21wb25lbnQgb2YgY29sb3IgKDAtMjU1KVxyXG4gICAgICogQHBhcmFtIGIgIFRoZSBibHVlIGNvbXBvbmVudCBvZiBjb2xvciAoMC0yNTUpXHJcbiAgICAgKiBAcGFyYW0gYSAgVGhlIGFscGhhIGNvbXBvbmVudCBvZiBjb2xvciAoMC0xLjApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tUkdCKHIsIGcsIGIsIGEpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gYSByZ2Igc3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN0cmluZyAgQ1NTIGNvbG9yIHN0cmluZyBvZiB0aGUgZm9ybSByZ2JhKDI1NSwgMjU1LCAyNTUsIDEpIG9yIHJnYigyNTUsIDI1NSwgMjU1KVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbVJHQlN0cmluZyhzdHJpbmcpIHtcclxuICAgICAgICBjb25zdCByZ2JhUmVnRXggPSAvXnJnYmE/XFwoKFxcZCspLFxccyooXFxkKyksXFxzKihcXGQrKSg/OixcXHMqKFxcZCsoPzpcXC5cXGQrKT8pKT9cXCkvaTtcclxuICAgICAgICBsZXQgbWF0Y2ggPSBudWxsO1xyXG4gICAgICAgIGlmICgobWF0Y2ggPSBzdHJpbmcubWF0Y2gocmdiYVJlZ0V4KSkpIHtcclxuICAgICAgICAgICAgY29uc3QgciA9IHBhcnNlSW50KG1hdGNoWzFdLCAxMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGcgPSBwYXJzZUludChtYXRjaFsyXSwgMTApO1xyXG4gICAgICAgICAgICBjb25zdCBiID0gcGFyc2VJbnQobWF0Y2hbM10sIDEwKTtcclxuICAgICAgICAgICAgbGV0IGEgPSAxO1xyXG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcclxuICAgICAgICAgICAgICAgIGEgPSBwYXJzZUZsb2F0KG1hdGNoWzRdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJnYi9hIHN0cmluZzogJyArIHN0cmluZyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIENvbG9yIGZyb20gYSBoZXggc3RyaW5nXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGhleCAgQ1NTIGNvbG9yIHN0cmluZyBvZiB0aGUgZm9ybSAjZmZmZmZmLCB0aGUgYWxwaGEgY29tcG9uZW50IGlzIG9wdGlvbmFsXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xyXG4gICAgICAgIGNvbnN0IGhleFJlZ0V4ID0gL14jPyhbMC05YS1mXXsyfSkoWzAtOWEtZl17Mn0pKFswLTlhLWZdezJ9KShbMC05YS1mXXsyfSk/JC9pO1xyXG4gICAgICAgIGxldCBtYXRjaCA9IG51bGw7XHJcbiAgICAgICAgaWYgKChtYXRjaCA9IGhleC5tYXRjaChoZXhSZWdFeCkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHIgPSBwYXJzZUludChtYXRjaFsxXSwgMTYpO1xyXG4gICAgICAgICAgICBjb25zdCBnID0gcGFyc2VJbnQobWF0Y2hbMl0sIDE2KTtcclxuICAgICAgICAgICAgY29uc3QgYiA9IHBhcnNlSW50KG1hdGNoWzNdLCAxNik7XHJcbiAgICAgICAgICAgIGxldCBhID0gMTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoWzRdKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gcGFyc2VJbnQobWF0Y2hbNF0sIDE2KSAvIDI1NTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIsIGcsIGIsIGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmc6ICcgKyBoZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBDb2xvciBmcm9tIGhzbGEgdmFsdWVzXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGggIEh1ZSBpcyByZXByZXNlbnRlZCBbMC0xXVxyXG4gICAgICogQHBhcmFtIHMgIFNhdHVyYXRpb24gaXMgcmVwcmVzZW50ZWQgWzAtMV1cclxuICAgICAqIEBwYXJhbSBsICBMdW1pbmFuY2UgaXMgcmVwcmVzZW50ZWQgWzAtMV1cclxuICAgICAqIEBwYXJhbSBhICBBbHBoYSBpcyByZXByZXNlbnRlZCBbMC0xXVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUhTTChoLCBzLCBsLCBhID0gMS4wKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IG5ldyBIU0xDb2xvcihoLCBzLCBsLCBhKTtcclxuICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTGlnaHRlbnMgdGhlIGN1cnJlbnQgY29sb3IgYnkgYSBzcGVjaWZpZWQgYW1vdW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGFtb3VudCB0byBsaWdodGVuIGJ5IFswLTFdXHJcbiAgICAgKi9cclxuICAgIGxpZ2h0ZW4oZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgdGVtcC5sICs9ICgxIC0gdGVtcC5sKSAqIGZhY3RvcjtcclxuICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGFya2VucyB0aGUgY3VycmVudCBjb2xvciBieSBhIHNwZWNpZmllZCBhbW91bnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgYW1vdW50IHRvIGRhcmtlbiBieSBbMC0xXVxyXG4gICAgICovXHJcbiAgICBkYXJrZW4oZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgdGVtcC5sIC09IHRlbXAubCAqIGZhY3RvcjtcclxuICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2F0dXJhdGVzIHRoZSBjdXJyZW50IGNvbG9yIGJ5IGEgc3BlY2lmaWVkIGFtb3VudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBhbW91bnQgdG8gc2F0dXJhdGUgYnkgWzAtMV1cclxuICAgICAqL1xyXG4gICAgc2F0dXJhdGUoZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgdGVtcC5zICs9IHRlbXAucyAqIGZhY3RvcjtcclxuICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGVzYXR1cmF0ZXMgdGhlIGN1cnJlbnQgY29sb3IgYnkgYSBzcGVjaWZpZWQgYW1vdW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGFtb3VudCB0byBkZXNhdHVyYXRlIGJ5IFswLTFdXHJcbiAgICAgKi9cclxuICAgIGRlc2F0dXJhdGUoZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSk7XHJcbiAgICAgICAgdGVtcC5zIC09IHRlbXAucyAqIGZhY3RvcjtcclxuICAgICAgICByZXR1cm4gdGVtcC50b1JHQkEoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbGllcyBhIGNvbG9yIGJ5IGFub3RoZXIsIHJlc3VsdHMgaW4gYSBkYXJrZXIgY29sb3JcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgIFRoZSBvdGhlciBjb2xvclxyXG4gICAgICovXHJcbiAgICBtdWx0aXBseShjb2xvcikge1xyXG4gICAgICAgIGNvbnN0IG5ld1IgPSAoKChjb2xvci5yIC8gMjU1KSAqIHRoaXMucikgLyAyNTUpICogMjU1O1xyXG4gICAgICAgIGNvbnN0IG5ld0cgPSAoKChjb2xvci5nIC8gMjU1KSAqIHRoaXMuZykgLyAyNTUpICogMjU1O1xyXG4gICAgICAgIGNvbnN0IG5ld0IgPSAoKChjb2xvci5iIC8gMjU1KSAqIHRoaXMuYikgLyAyNTUpICogMjU1O1xyXG4gICAgICAgIGNvbnN0IG5ld0EgPSBjb2xvci5hICogdGhpcy5hO1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29sb3IobmV3UiwgbmV3RywgbmV3QiwgbmV3QSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE11bHRpcGxpZXMgYSBjb2xvciBieSBhbm90aGVyLCByZXN1bHRzIGluIGEgZGFya2VyIGNvbG9yXHJcbiAgICAgKiBAcGFyYW0gY29sb3JcclxuICAgICAqIEBkZXByZWNhdGVkIEFsaWFzIGZvciBpbmNvcnJlY3Qgc3BlbGxpbmcgdXNlZCBpbiBvbGRlciB2ZXJzaW9ucywgdXNlIG11bHRpcGx5IGluc3RlYWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNS4wXHJcbiAgICAgKi9cclxuICAgIG11bGl0aXBseShjb2xvcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5KGNvbG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2NyZWVucyBhIGNvbG9yIGJ5IGFub3RoZXIsIHJlc3VsdHMgaW4gYSBsaWdodGVyIGNvbG9yXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGNvbG9yICBUaGUgb3RoZXIgY29sb3JcclxuICAgICAqL1xyXG4gICAgc2NyZWVuKGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgY29sb3IxID0gY29sb3IuaW52ZXJ0KCk7XHJcbiAgICAgICAgY29uc3QgY29sb3IyID0gY29sb3IuaW52ZXJ0KCk7XHJcbiAgICAgICAgcmV0dXJuIGNvbG9yMS5tdWx0aXBseShjb2xvcjIpLmludmVydCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZlcnRzIHRoZSBjdXJyZW50IGNvbG9yXHJcbiAgICAgKi9cclxuICAgIGludmVydCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKDI1NSAtIHRoaXMuciwgMjU1IC0gdGhpcy5nLCAyNTUgLSB0aGlzLmIsIDEuMCAtIHRoaXMuYSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEF2ZXJhZ2VzIHRoZSBjdXJyZW50IGNvbG9yIHdpdGggYW5vdGhlclxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIG90aGVyIGNvbG9yXHJcbiAgICAgKi9cclxuICAgIGF2ZXJhZ2UoY29sb3IpIHtcclxuICAgICAgICBjb25zdCBuZXdSID0gKGNvbG9yLnIgKyB0aGlzLnIpIC8gMjtcclxuICAgICAgICBjb25zdCBuZXdHID0gKGNvbG9yLmcgKyB0aGlzLmcpIC8gMjtcclxuICAgICAgICBjb25zdCBuZXdCID0gKGNvbG9yLmIgKyB0aGlzLmIpIC8gMjtcclxuICAgICAgICBjb25zdCBuZXdBID0gKGNvbG9yLmEgKyB0aGlzLmEpIC8gMjtcclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKG5ld1IsIG5ld0csIG5ld0IsIG5ld0EpO1xyXG4gICAgfVxyXG4gICAgZXF1YWwoY29sb3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1N0cmluZygpID09PSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgQ1NTIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmb3JtYXQgQ29sb3IgcmVwcmVzZW50YXRpb24sIGFjY2VwdHM6IHJnYiwgaHNsLCBvciBoZXhcclxuICAgICAqL1xyXG4gICAgdG9TdHJpbmcoZm9ybWF0ID0gJ3JnYicpIHtcclxuICAgICAgICBzd2l0Y2ggKGZvcm1hdCkge1xyXG4gICAgICAgICAgICBjYXNlICdyZ2InOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9SR0JBKCk7XHJcbiAgICAgICAgICAgIGNhc2UgJ2hzbCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50b0hTTEEoKTtcclxuICAgICAgICAgICAgY2FzZSAnaGV4JzpcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgQ29sb3IgZm9ybWF0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIEhleCBWYWx1ZSBvZiBhIGNvbG9yIGNvbXBvbmVudFxyXG4gICAgICogQHBhcmFtIGMgY29sb3IgY29tcG9uZW50XHJcbiAgICAgKiBAc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU2MjM4MzgvcmdiLXRvLWhleC1hbmQtaGV4LXRvLXJnYlxyXG4gICAgICovXHJcbiAgICBfY29tcG9uZW50VG9IZXgoYykge1xyXG4gICAgICAgIGNvbnN0IGhleCA9IGMudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgIHJldHVybiBoZXgubGVuZ3RoID09PSAxID8gJzAnICsgaGV4IDogaGV4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gSGV4IHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHRvSGV4KCkge1xyXG4gICAgICAgIHJldHVybiAnIycgKyB0aGlzLl9jb21wb25lbnRUb0hleCh0aGlzLnIpICsgdGhpcy5fY29tcG9uZW50VG9IZXgodGhpcy5nKSArIHRoaXMuX2NvbXBvbmVudFRvSGV4KHRoaXMuYik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBSR0JBIHJlcHJlc2VudGF0aW9uIG9mIGEgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIHRvUkdCQSgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBTdHJpbmcodGhpcy5yLnRvRml4ZWQoMCkpICsgJywgJyArIFN0cmluZyh0aGlzLmcudG9GaXhlZCgwKSkgKyAnLCAnICsgU3RyaW5nKHRoaXMuYi50b0ZpeGVkKDApKTtcclxuICAgICAgICBpZiAodGhpcy5hICE9PSB1bmRlZmluZWQgfHwgdGhpcy5hICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAncmdiYSgnICsgcmVzdWx0ICsgJywgJyArIFN0cmluZyh0aGlzLmEpICsgJyknO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gJ3JnYignICsgcmVzdWx0ICsgJyknO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gSFNMQSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbG9yLlxyXG4gICAgICovXHJcbiAgICB0b0hTTEEoKSB7XHJcbiAgICAgICAgcmV0dXJuIEhTTENvbG9yLmZyb21SR0JBKHRoaXMuciwgdGhpcy5nLCB0aGlzLmIsIHRoaXMuYSkudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIENTUyBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBjb2xvci5cclxuICAgICAqL1xyXG4gICAgZmlsbFN0eWxlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGUgY3VycmVudCBjb2xvci5cclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xvcih0aGlzLnIsIHRoaXMuZywgdGhpcy5iLCB0aGlzLmEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCbGFjayAoIzAwMDAwMClcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBCbGFjaygpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnIzAwMDAwMCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGl0ZSAoI0ZGRkZGRilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBXaGl0ZSgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnI0ZGRkZGRicpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHcmF5ICgjODA4MDgwKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IEdyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyM4MDgwODAnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTGlnaHQgZ3JheSAoI0QzRDNEMylcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBMaWdodEdyYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyNEM0QzRDMnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGFyayBncmF5ICgjQTlBOUE5KVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IERhcmtHcmF5KCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjQTlBOUE5Jyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFllbGxvdyAoI0ZGRkYwMClcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBZZWxsb3coKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyNGRkZGMDAnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT3JhbmdlICgjRkZBNTAwKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IE9yYW5nZSgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnI0ZGQTUwMCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZWQgKCNGRjAwMDApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgUmVkKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjRkYwMDAwJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZlcm1pbGlvbiAoI0ZGNUIzMSlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBWZXJtaWxpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyNGRjVCMzEnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmVybWlsaW9uICgjRkY1QjMxKVxyXG4gICAgICogQGRlcHJlY2F0ZWQgQWxpYXMgZm9yIGluY29ycmVjdCBzcGVsbGluZyB1c2VkIGluIG9sZGVyIHZlcnNpb25zLCB1c2UgbXVsdGlwbHkgaW5zdGVhZCwgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI1LjBcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBWZXJtaWxsaW9uKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5WZXJtaWxpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJvc2UgKCNGRjAwN0YpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgUm9zZSgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnI0ZGMDA3RicpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYWdlbnRhICgjRkYwMEZGKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IE1hZ2VudGEoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyNGRjAwRkYnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVmlvbGV0ICgjN0YwMEZGKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IFZpb2xldCgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnIzdGMDBGRicpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCbHVlICgjMDAwMEZGKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IEJsdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyMwMDAwRkYnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXp1cmUgKCMwMDdGRkYpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgQXp1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbG9yLmZyb21IZXgoJyMwMDdGRkYnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3lhbiAoIzAwRkZGRilcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBDeWFuKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjMDBGRkZGJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFZpcmlkaWFuICgjNTk5NzhGKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IFZpcmlkaWFuKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjNTk5NzhGJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdyZWVuICgjMDBGRjAwKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IEdyZWVuKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjMDBGRjAwJyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoYXJ0cmV1c2UgKCM3RkZGMDApXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBnZXQgQ2hhcnRyZXVzZSgpIHtcclxuICAgICAgICByZXR1cm4gQ29sb3IuZnJvbUhleCgnIzdGRkYwMCcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc3BhcmVudCAoI0ZGRkZGRjAwKVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IFRyYW5zcGFyZW50KCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjRkZGRkZGMDAnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXhjYWxpYnVyQmx1ZSAoIzE3NkJBQSlcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldCBFeGNhbGlidXJCbHVlKCkge1xyXG4gICAgICAgIHJldHVybiBDb2xvci5mcm9tSGV4KCcjMTc2QkFBJyk7XHJcbiAgICB9XHJcbn1cclxuQ29sb3JfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnQWxpYXMgZm9yIGluY29ycmVjdCBzcGVsbGluZyB1c2VkIGluIG9sZGVyIHZlcnNpb25zLCB1c2UgbXVsdGlwbHkgaW5zdGVhZCwgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI1LjAnIH0pXHJcbl0sIENvbG9yLnByb3RvdHlwZSwgXCJtdWxpdGlwbHlcIiwgbnVsbCk7XHJcbkNvbG9yX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnQWxpYXMgZm9yIGluY29ycmVjdCBzcGVsbGluZyB1c2VkIGluIG9sZGVyIHZlcnNpb25zJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdWZXJtaWxpb24nXHJcbiAgICB9KVxyXG5dLCBDb2xvciwgXCJWZXJtaWxsaW9uXCIsIG51bGwpO1xyXG4vKipcclxuICogSW50ZXJuYWwgSFNMIENvbG9yIHJlcHJlc2VudGF0aW9uXHJcbiAqXHJcbiAqIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSFNMX2FuZF9IU1ZcclxuICogaHR0cDovL2F4b25mbHV4LmNvbS9oYW5keS1yZ2ItdG8taHNsLWFuZC1yZ2ItdG8taHN2LWNvbG9yLW1vZGVsLWNcclxuICovXHJcbmNsYXNzIEhTTENvbG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKGgsIHMsIGwsIGEpIHtcclxuICAgICAgICB0aGlzLmggPSBoO1xyXG4gICAgICAgIHRoaXMucyA9IHM7XHJcbiAgICAgICAgdGhpcy5sID0gbDtcclxuICAgICAgICB0aGlzLmEgPSBhO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGh1ZTJyZ2IocCwgcSwgdCkge1xyXG4gICAgICAgIGlmICh0IDwgMCkge1xyXG4gICAgICAgICAgICB0ICs9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ID4gMSkge1xyXG4gICAgICAgICAgICB0IC09IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0IDwgMSAvIDYpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0IDwgMSAvIDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0IDwgMiAvIDMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tUkdCQShyLCBnLCBiLCBhKSB7XHJcbiAgICAgICAgciAvPSAyNTU7XHJcbiAgICAgICAgZyAvPSAyNTU7XHJcbiAgICAgICAgYiAvPSAyNTU7XHJcbiAgICAgICAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYiksIG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xyXG4gICAgICAgIGxldCBoLCBzO1xyXG4gICAgICAgIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XHJcbiAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XHJcbiAgICAgICAgICAgIGggPSBzID0gMDsgLy8gYWNocm9tYXRpY1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZCA9IG1heCAtIG1pbjtcclxuICAgICAgICAgICAgcyA9IGwgPiAwLjUgPyBkIC8gKDIgLSBtYXggLSBtaW4pIDogZCAvIChtYXggKyBtaW4pO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG1heCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSByOlxyXG4gICAgICAgICAgICAgICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgZzpcclxuICAgICAgICAgICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBiOlxyXG4gICAgICAgICAgICAgICAgICAgIGggPSAociAtIGcpIC8gZCArIDQ7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaCAvPSA2O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEhTTENvbG9yKGgsIHMsIGwsIGEpO1xyXG4gICAgfVxyXG4gICAgdG9SR0JBKCkge1xyXG4gICAgICAgIGxldCByLCBnLCBiO1xyXG4gICAgICAgIGlmICh0aGlzLnMgPT09IDApIHtcclxuICAgICAgICAgICAgciA9IGcgPSBiID0gdGhpcy5sOyAvLyBhY2hyb21hdGljXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBxID0gdGhpcy5sIDwgMC41ID8gdGhpcy5sICogKDEgKyB0aGlzLnMpIDogdGhpcy5sICsgdGhpcy5zIC0gdGhpcy5sICogdGhpcy5zO1xyXG4gICAgICAgICAgICBjb25zdCBwID0gMiAqIHRoaXMubCAtIHE7XHJcbiAgICAgICAgICAgIHIgPSBIU0xDb2xvci5odWUycmdiKHAsIHEsIHRoaXMuaCArIDEgLyAzKTtcclxuICAgICAgICAgICAgZyA9IEhTTENvbG9yLmh1ZTJyZ2IocCwgcSwgdGhpcy5oKTtcclxuICAgICAgICAgICAgYiA9IEhTTENvbG9yLmh1ZTJyZ2IocCwgcSwgdGhpcy5oIC0gMSAvIDMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IENvbG9yKHIgKiAyNTUsIGcgKiAyNTUsIGIgKiAyNTUsIHRoaXMuYSk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICBjb25zdCBoID0gdGhpcy5oLnRvRml4ZWQoMCksIHMgPSB0aGlzLnMudG9GaXhlZCgwKSwgbCA9IHRoaXMubC50b0ZpeGVkKDApLCBhID0gdGhpcy5hLnRvRml4ZWQoMCk7XHJcbiAgICAgICAgcmV0dXJuIGBoc2xhKCR7aH0sICR7c30sICR7bH0sICR7YX0pYDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Cb3VuZGluZ0JveC50c1xuXHJcblxyXG5cclxuLyoqXHJcbiAqIEF4aXMgQWxpZ25lZCBjb2xsaXNpb24gcHJpbWl0aXZlIGZvciBFeGNhbGlidXIuXHJcbiAqL1xyXG5jbGFzcyBCb3VuZGluZ0JveCB7XHJcbiAgICAvKipcclxuICAgICAqIENvbnN0cnVjdG9yIGFsbG93cyBwYXNzaW5nIG9mIGVpdGhlciBhbiBvYmplY3Qgd2l0aCBhbGwgY29vcmRpbmF0ZSBjb21wb25lbnRzLFxyXG4gICAgICogb3IgdGhlIGNvb3JkaW5hdGUgY29tcG9uZW50cyBwYXNzZWQgc2VwYXJhdGVseS5cclxuICAgICAqIEBwYXJhbSBsZWZ0T3JPcHRpb25zICAgIEVpdGhlciB4IGNvb3JkaW5hdGUgb2YgdGhlIGxlZnQgZWRnZSBvciBhbiBvcHRpb25zIG9iamVjdFxyXG4gICAgICogY29udGFpbmluZyB0aGUgZm91ciBjb29yZGluYXRlIGNvbXBvbmVudHMuXHJcbiAgICAgKiBAcGFyYW0gdG9wICAgICB5IGNvb3JkaW5hdGUgb2YgdGhlIHRvcCBlZGdlXHJcbiAgICAgKiBAcGFyYW0gcmlnaHQgICB4IGNvb3JkaW5hdGUgb2YgdGhlIHJpZ2h0IGVkZ2VcclxuICAgICAqIEBwYXJhbSBib3R0b20gIHkgY29vcmRpbmF0ZSBvZiB0aGUgYm90dG9tIGVkZ2VcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobGVmdE9yT3B0aW9ucyA9IDAsIHRvcCA9IDAsIHJpZ2h0ID0gMCwgYm90dG9tID0gMCkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGVmdE9yT3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gbGVmdE9yT3B0aW9ucy5sZWZ0O1xyXG4gICAgICAgICAgICB0aGlzLnRvcCA9IGxlZnRPck9wdGlvbnMudG9wO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gbGVmdE9yT3B0aW9ucy5yaWdodDtcclxuICAgICAgICAgICAgdGhpcy5ib3R0b20gPSBsZWZ0T3JPcHRpb25zLmJvdHRvbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGxlZnRPck9wdGlvbnMgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRoaXMubGVmdCA9IGxlZnRPck9wdGlvbnM7XHJcbiAgICAgICAgICAgIHRoaXMudG9wID0gdG9wO1xyXG4gICAgICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYm91bmRpbmcgYm94IEEgJiBCLCByZXR1cm5zIHRoZSBzaWRlIHJlbGF0aXZlIHRvIEEgd2hlbiBpbnRlcnNlY3Rpb24gaXMgcGVyZm9ybWVkLlxyXG4gICAgICogQHBhcmFtIGludGVyc2VjdGlvbiBJbnRlcnNlY3Rpb24gdmVjdG9yIGJldHdlZW4gMiBib3VuZGluZyBib3hlc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0U2lkZUZyb21JbnRlcnNlY3Rpb24oaW50ZXJzZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKCFpbnRlcnNlY3Rpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIFNpZGUuTm9uZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGludGVyc2VjdGlvbikge1xyXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoaW50ZXJzZWN0aW9uLngpID4gTWF0aC5hYnMoaW50ZXJzZWN0aW9uLnkpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uLnggPCAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFNpZGUuUmlnaHQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gU2lkZS5MZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbi55IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTaWRlLkJvdHRvbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBTaWRlLlRvcDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gU2lkZS5Ob25lO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21Qb2ludHMocG9pbnRzKSB7XHJcbiAgICAgICAgbGV0IG1pblggPSBJbmZpbml0eTtcclxuICAgICAgICBsZXQgbWluWSA9IEluZmluaXR5O1xyXG4gICAgICAgIGxldCBtYXhYID0gLUluZmluaXR5O1xyXG4gICAgICAgIGxldCBtYXhZID0gLUluZmluaXR5O1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChwb2ludHNbaV0ueCA8IG1pblgpIHtcclxuICAgICAgICAgICAgICAgIG1pblggPSBwb2ludHNbaV0ueDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAocG9pbnRzW2ldLnggPiBtYXhYKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhYID0gcG9pbnRzW2ldLng7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHBvaW50c1tpXS55IDwgbWluWSkge1xyXG4gICAgICAgICAgICAgICAgbWluWSA9IHBvaW50c1tpXS55O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChwb2ludHNbaV0ueSA+IG1heFkpIHtcclxuICAgICAgICAgICAgICAgIG1heFkgPSBwb2ludHNbaV0ueTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KG1pblgsIG1pblksIG1heFgsIG1heFkpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGZyb21EaW1lbnNpb24od2lkdGgsIGhlaWdodCwgYW5jaG9yID0gVmVjdG9yLkhhbGYsIHBvcyA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCgtd2lkdGggKiBhbmNob3IueCArIHBvcy54LCAtaGVpZ2h0ICogYW5jaG9yLnkgKyBwb3MueSwgd2lkdGggLSB3aWR0aCAqIGFuY2hvci54ICsgcG9zLngsIGhlaWdodCAtIGhlaWdodCAqIGFuY2hvci55ICsgcG9zLnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIHdpZHRoIG9mIHRoZSBib3VuZGluZyBib3hcclxuICAgICAqL1xyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjYWxjdWxhdGVkIGhlaWdodCBvZiB0aGUgYm91bmRpbmcgYm94XHJcbiAgICAgKi9cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tIC0gdGhpcy50b3A7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiB3aGV0aGVyIHRoZSBib3VuZGluZyBib3ggaGFzIHplcm8gZGltZW5zaW9ucyBpbiBoZWlnaHQsd2lkdGggb3IgYm90aFxyXG4gICAgICovXHJcbiAgICBoYXNaZXJvRGltZW5zaW9ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53aWR0aCA9PT0gMCB8fCB0aGlzLmhlaWdodCA9PT0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2VudGVyIG9mIHRoZSBib3VuZGluZyBib3hcclxuICAgICAqL1xyXG4gICAgZ2V0IGNlbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvcigodGhpcy5sZWZ0ICsgdGhpcy5yaWdodCkgLyAyLCAodGhpcy50b3AgKyB0aGlzLmJvdHRvbSkgLyAyKTtcclxuICAgIH1cclxuICAgIHRyYW5zbGF0ZShwb3MpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHRoaXMubGVmdCArIHBvcy54LCB0aGlzLnRvcCArIHBvcy55LCB0aGlzLnJpZ2h0ICsgcG9zLngsIHRoaXMuYm90dG9tICsgcG9zLnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGVzIGEgYm91bmRpbmcgYm94IGJ5IGFuZCBhbmdsZSBhbmQgYXJvdW5kIGEgcG9pbnQsIGlmIG5vIHBvaW50IGlzIHNwZWNpZmllZCAoMCwgMCkgaXMgdXNlZCBieSBkZWZhdWx0LiBUaGUgcmVzdWx0aW5nIGJvdW5kaW5nXHJcbiAgICAgKiBib3ggaXMgYWxzbyBheGlzLWFsaWduLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbmV3IGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3ggaXMgbmVlZGVkIGZvciByb3RhdGVkIGdlb21ldHJ5LlxyXG4gICAgICovXHJcbiAgICByb3RhdGUoYW5nbGUsIHBvaW50ID0gVmVjdG9yLlplcm8pIHtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLmdldFBvaW50cygpLm1hcCgocCkgPT4gcC5yb3RhdGUoYW5nbGUsIHBvaW50KSk7XHJcbiAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94LmZyb21Qb2ludHMocG9pbnRzKTtcclxuICAgIH1cclxuICAgIHNjYWxlKHNjYWxlLCBwb2ludCA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgY29uc3Qgc2hpZnRlZCA9IHRoaXMudHJhbnNsYXRlKHBvaW50KTtcclxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHNoaWZ0ZWQubGVmdCAqIHNjYWxlLngsIHNoaWZ0ZWQudG9wICogc2NhbGUueSwgc2hpZnRlZC5yaWdodCAqIHNjYWxlLngsIHNoaWZ0ZWQuYm90dG9tICogc2NhbGUueSk7XHJcbiAgICB9XHJcbiAgICB0cmFuc2Zvcm0obWF0cml4KSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRzID0gdGhpcy5nZXRQb2ludHMoKS5tYXAoKHApID0+IG1hdHJpeC5tdWx0dihwKSk7XHJcbiAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94LmZyb21Qb2ludHMocG9pbnRzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgcGVyaW1ldGVyIG9mIHRoZSBib3VuZGluZyBib3hcclxuICAgICAqL1xyXG4gICAgZ2V0UGVyaW1ldGVyKCkge1xyXG4gICAgICAgIGNvbnN0IHd4ID0gdGhpcy53aWR0aDtcclxuICAgICAgICBjb25zdCB3eSA9IHRoaXMuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiAyICogKHd4ICsgd3kpO1xyXG4gICAgfVxyXG4gICAgZ2V0UG9pbnRzKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcclxuICAgICAgICByZXN1bHRzLnB1c2gobmV3IFZlY3Rvcih0aGlzLmxlZnQsIHRoaXMudG9wKSk7XHJcbiAgICAgICAgcmVzdWx0cy5wdXNoKG5ldyBWZWN0b3IodGhpcy5yaWdodCwgdGhpcy50b3ApKTtcclxuICAgICAgICByZXN1bHRzLnB1c2gobmV3IFZlY3Rvcih0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbSkpO1xyXG4gICAgICAgIHJlc3VsdHMucHVzaChuZXcgVmVjdG9yKHRoaXMubGVmdCwgdGhpcy5ib3R0b20pKTtcclxuICAgICAgICByZXR1cm4gcmVzdWx0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcmF5IGludGVyc2VjdHMgd2l0aCBhIGJvdW5kaW5nIGJveFxyXG4gICAgICovXHJcbiAgICByYXlDYXN0KHJheSwgZmFyQ2xpcERpc3RhbmNlID0gSW5maW5pdHkpIHtcclxuICAgICAgICAvLyBhbGdvcml0aG0gZnJvbSBodHRwczovL3RhdmlhbmF0b3IuY29tL2Zhc3QtYnJhbmNobGVzcy1yYXlib3VuZGluZy1ib3gtaW50ZXJzZWN0aW9ucy9cclxuICAgICAgICBsZXQgdG1pbiA9IC1JbmZpbml0eTtcclxuICAgICAgICBsZXQgdG1heCA9ICtJbmZpbml0eTtcclxuICAgICAgICBjb25zdCB4aW52ID0gcmF5LmRpci54ID09PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6IDEgLyByYXkuZGlyLng7XHJcbiAgICAgICAgY29uc3QgeWludiA9IHJheS5kaXIueSA9PT0gMCA/IE51bWJlci5NQVhfVkFMVUUgOiAxIC8gcmF5LmRpci55O1xyXG4gICAgICAgIGNvbnN0IHR4MSA9ICh0aGlzLmxlZnQgLSByYXkucG9zLngpICogeGludjtcclxuICAgICAgICBjb25zdCB0eDIgPSAodGhpcy5yaWdodCAtIHJheS5wb3MueCkgKiB4aW52O1xyXG4gICAgICAgIHRtaW4gPSBNYXRoLm1pbih0eDEsIHR4Mik7XHJcbiAgICAgICAgdG1heCA9IE1hdGgubWF4KHR4MSwgdHgyKTtcclxuICAgICAgICBjb25zdCB0eTEgPSAodGhpcy50b3AgLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICBjb25zdCB0eTIgPSAodGhpcy5ib3R0b20gLSByYXkucG9zLnkpICogeWludjtcclxuICAgICAgICB0bWluID0gTWF0aC5tYXgodG1pbiwgTWF0aC5taW4odHkxLCB0eTIpKTtcclxuICAgICAgICB0bWF4ID0gTWF0aC5taW4odG1heCwgTWF0aC5tYXgodHkxLCB0eTIpKTtcclxuICAgICAgICByZXR1cm4gdG1heCA+PSBNYXRoLm1heCgwLCB0bWluKSAmJiB0bWluIDwgZmFyQ2xpcERpc3RhbmNlO1xyXG4gICAgfVxyXG4gICAgcmF5Q2FzdFRpbWUocmF5LCBmYXJDbGlwRGlzdGFuY2UgPSBJbmZpbml0eSkge1xyXG4gICAgICAgIC8vIGFsZ29yaXRobSBmcm9tIGh0dHBzOi8vdGF2aWFuYXRvci5jb20vZmFzdC1icmFuY2hsZXNzLXJheWJvdW5kaW5nLWJveC1pbnRlcnNlY3Rpb25zL1xyXG4gICAgICAgIGxldCB0bWluID0gLUluZmluaXR5O1xyXG4gICAgICAgIGxldCB0bWF4ID0gK0luZmluaXR5O1xyXG4gICAgICAgIGNvbnN0IHhpbnYgPSByYXkuZGlyLnggPT09IDAgPyBOdW1iZXIuTUFYX1ZBTFVFIDogMSAvIHJheS5kaXIueDtcclxuICAgICAgICBjb25zdCB5aW52ID0gcmF5LmRpci55ID09PSAwID8gTnVtYmVyLk1BWF9WQUxVRSA6IDEgLyByYXkuZGlyLnk7XHJcbiAgICAgICAgY29uc3QgdHgxID0gKHRoaXMubGVmdCAtIHJheS5wb3MueCkgKiB4aW52O1xyXG4gICAgICAgIGNvbnN0IHR4MiA9ICh0aGlzLnJpZ2h0IC0gcmF5LnBvcy54KSAqIHhpbnY7XHJcbiAgICAgICAgdG1pbiA9IE1hdGgubWluKHR4MSwgdHgyKTtcclxuICAgICAgICB0bWF4ID0gTWF0aC5tYXgodHgxLCB0eDIpO1xyXG4gICAgICAgIGNvbnN0IHR5MSA9ICh0aGlzLnRvcCAtIHJheS5wb3MueSkgKiB5aW52O1xyXG4gICAgICAgIGNvbnN0IHR5MiA9ICh0aGlzLmJvdHRvbSAtIHJheS5wb3MueSkgKiB5aW52O1xyXG4gICAgICAgIHRtaW4gPSBNYXRoLm1heCh0bWluLCBNYXRoLm1pbih0eTEsIHR5MikpO1xyXG4gICAgICAgIHRtYXggPSBNYXRoLm1pbih0bWF4LCBNYXRoLm1heCh0eTEsIHR5MikpO1xyXG4gICAgICAgIGlmICh0bWF4ID49IE1hdGgubWF4KDAsIHRtaW4pICYmIHRtaW4gPCBmYXJDbGlwRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRtaW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIGNvbnRhaW5zKHZhbCkge1xyXG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVmdCA8PSB2YWwueCAmJiB0aGlzLnRvcCA8PSB2YWwueSAmJiB0aGlzLmJvdHRvbSA+PSB2YWwueSAmJiB0aGlzLnJpZ2h0ID49IHZhbC54O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBCb3VuZGluZ0JveCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5sZWZ0IDwgdmFsLmxlZnQgJiYgdGhpcy50b3AgPCB2YWwudG9wICYmIHZhbC5ib3R0b20gPCB0aGlzLmJvdHRvbSAmJiB2YWwucmlnaHQgPCB0aGlzLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tYmluZXMgdGhpcyBib3VuZGluZyBib3ggYW5kIGFub3RoZXIgdG9nZXRoZXIgcmV0dXJuaW5nIGEgbmV3IGJvdW5kaW5nIGJveFxyXG4gICAgICogQHBhcmFtIG90aGVyICBUaGUgYm91bmRpbmcgYm94IHRvIGNvbWJpbmVcclxuICAgICAqL1xyXG4gICAgY29tYmluZShvdGhlcikge1xyXG4gICAgICAgIGNvbnN0IGNvbXBvc2l0ZUJCID0gbmV3IEJvdW5kaW5nQm94KE1hdGgubWluKHRoaXMubGVmdCwgb3RoZXIubGVmdCksIE1hdGgubWluKHRoaXMudG9wLCBvdGhlci50b3ApLCBNYXRoLm1heCh0aGlzLnJpZ2h0LCBvdGhlci5yaWdodCksIE1hdGgubWF4KHRoaXMuYm90dG9tLCBvdGhlci5ib3R0b20pKTtcclxuICAgICAgICByZXR1cm4gY29tcG9zaXRlQkI7XHJcbiAgICB9XHJcbiAgICBnZXQgZGltZW5zaW9ucygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3Rvcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3Qgd2V0aGVyIHRoaXMgYm91bmRpbmcgYm94IGludGVyc2VjdHMgd2l0aCBhbm90aGVyIHJldHVybmluZ1xyXG4gICAgICogdGhlIGludGVyc2VjdGlvbiB2ZWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNvbHZlIHRoZSBjb2xsaXNpb24uIElmIHRoZXJlXHJcbiAgICAgKiBpcyBubyBpbnRlcnNlY3Rpb24gbnVsbCBpcyByZXR1cm5lZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgIE90aGVyIFtbQm91bmRpbmdCb3hdXSB0byB0ZXN0IGludGVyc2VjdGlvbiB3aXRoXHJcbiAgICAgKiBAcmV0dXJucyBBIFZlY3RvciBpbiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBjdXJyZW50IEJvdW5kaW5nQm94LCB0aGlzIDwtIG90aGVyXHJcbiAgICAgKi9cclxuICAgIGludGVyc2VjdChvdGhlcikge1xyXG4gICAgICAgIGNvbnN0IHRvdGFsQm91bmRpbmdCb3ggPSB0aGlzLmNvbWJpbmUob3RoZXIpO1xyXG4gICAgICAgIC8vIElmIHRoZSB0b3RhbCBib3VuZGluZyBib3ggaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRoZSBzdW0gb2YgdGhlIDIgYm91bmRzIHRoZW4gdGhlcmUgaXMgY29sbGlzaW9uXHJcbiAgICAgICAgaWYgKHRvdGFsQm91bmRpbmdCb3gud2lkdGggPCBvdGhlci53aWR0aCArIHRoaXMud2lkdGggJiZcclxuICAgICAgICAgICAgdG90YWxCb3VuZGluZ0JveC5oZWlnaHQgPCBvdGhlci5oZWlnaHQgKyB0aGlzLmhlaWdodCAmJlxyXG4gICAgICAgICAgICAhdG90YWxCb3VuZGluZ0JveC5kaW1lbnNpb25zLmVxdWFscyhvdGhlci5kaW1lbnNpb25zKSAmJlxyXG4gICAgICAgICAgICAhdG90YWxCb3VuZGluZ0JveC5kaW1lbnNpb25zLmVxdWFscyh0aGlzLmRpbWVuc2lvbnMpKSB7XHJcbiAgICAgICAgICAgIC8vIGNvbGxpc2lvblxyXG4gICAgICAgICAgICBsZXQgb3ZlcmxhcFggPSAwO1xyXG4gICAgICAgICAgICAvLyByaWdodCBlZGdlIGlzIGJldHdlZW4gdGhlIG90aGVyJ3MgbGVmdCBhbmQgcmlnaHQgZWRnZVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogICAgICstdGhpcy0rXHJcbiAgICAgICAgICAgICAqICAgICB8ICAgICAgfFxyXG4gICAgICAgICAgICAgKiAgICAgfCAgICArLW90aGVyLStcclxuICAgICAgICAgICAgICogICAgICstLS0tfC0rICAgICB8XHJcbiAgICAgICAgICAgICAqICAgICAgICAgIHwgICAgICAgfFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICArLS0tLS0tLStcclxuICAgICAgICAgICAgICogICAgICAgICA8LS0tXHJcbiAgICAgICAgICAgICAqICAgICAgICAgIF4gb3ZlcmxhcFxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgaWYgKHRoaXMucmlnaHQgPj0gb3RoZXIubGVmdCAmJiB0aGlzLnJpZ2h0IDw9IG90aGVyLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBvdmVybGFwWCA9IG90aGVyLmxlZnQgLSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgLy8gcmlnaHQgZWRnZSBpcyBwYXN0IHRoZSBvdGhlcidzIHJpZ2h0IGVkZ2VcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICogICAgICstb3RoZXItK1xyXG4gICAgICAgICAgICAgICAgICogICAgIHwgICAgICAgfFxyXG4gICAgICAgICAgICAgICAgICogICAgIHwgICAgKy10aGlzLStcclxuICAgICAgICAgICAgICAgICAqICAgICArLS0tLXwtLSsgICB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICB8ICAgICAgfFxyXG4gICAgICAgICAgICAgICAgICogICAgICAgICAgKy0tLS0tLStcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgIC0tLT5cclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgIF4gb3ZlcmxhcFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdmVybGFwWCA9IG90aGVyLnJpZ2h0IC0gdGhpcy5sZWZ0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBvdmVybGFwWSA9IDA7XHJcbiAgICAgICAgICAgIC8vIHRvcCBlZGdlIGlzIGJldHdlZW4gdGhlIG90aGVyJ3MgdG9wIGFuZCBib3R0b20gZWRnZVxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogICAgICstb3RoZXItK1xyXG4gICAgICAgICAgICAgKiAgICAgfCAgICAgICB8XHJcbiAgICAgICAgICAgICAqICAgICB8ICAgICstdGhpcy0rICAgfCA8LSBvdmVybGFwXHJcbiAgICAgICAgICAgICAqICAgICArLS0tLXwtLSsgICB8ICAgfFxyXG4gICAgICAgICAgICAgKiAgICAgICAgICB8ICAgICAgfCAgXFwgL1xyXG4gICAgICAgICAgICAgKiAgICAgICAgICArLS0tLS0tKyAgICdcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRvcCA8PSBvdGhlci5ib3R0b20gJiYgdGhpcy50b3AgPj0gb3RoZXIudG9wKSB7XHJcbiAgICAgICAgICAgICAgICBvdmVybGFwWSA9IG90aGVyLmJvdHRvbSAtIHRoaXMudG9wO1xyXG4gICAgICAgICAgICAgICAgLy8gdG9wIGVkZ2UgaXMgYWJvdmUgdGhlIG90aGVyIHRvcCBlZGdlXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqICAgICArLXRoaXMtKyAgICAgICAgIC5cclxuICAgICAgICAgICAgICAgICAqICAgICB8ICAgICAgfCAgICAgICAgLyBcXFxyXG4gICAgICAgICAgICAgICAgICogICAgIHwgICAgKy1vdGhlci0rICAgfCA8LSBvdmVybGFwXHJcbiAgICAgICAgICAgICAgICAgKiAgICAgKy0tLS18LSsgICAgIHwgICB8XHJcbiAgICAgICAgICAgICAgICAgKiAgICAgICAgICB8ICAgICAgIHxcclxuICAgICAgICAgICAgICAgICAqICAgICAgICAgICstLS0tLS0tK1xyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvdmVybGFwWSA9IG90aGVyLnRvcCAtIHRoaXMuYm90dG9tO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChNYXRoLmFicyhvdmVybGFwWCkgPCBNYXRoLmFicyhvdmVybGFwWSkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG92ZXJsYXBYLCAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKDAsIG92ZXJsYXBZKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBDYXNlIG9mIHRvdGFsIGNvbnRhaW5tZW50IG9mIG9uZSBib3VuZGluZyBib3ggYnkgYW5vdGhlclxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0b3RhbEJvdW5kaW5nQm94LmRpbWVuc2lvbnMuZXF1YWxzKG90aGVyLmRpbWVuc2lvbnMpIHx8IHRvdGFsQm91bmRpbmdCb3guZGltZW5zaW9ucy5lcXVhbHModGhpcy5kaW1lbnNpb25zKSkge1xyXG4gICAgICAgICAgICBsZXQgb3ZlcmxhcFggPSAwO1xyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHdpZGVyIHRoYW4gdGhlIG90aGVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoIC0gb3RoZXIud2lkdGggPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhpcyByaWdodCBlZGdlIGlzIGNsb3Nlc3QgdG8gdGhlIG90aGVycyByaWdodCBlZGdlXHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yaWdodCAtIG90aGVyLnJpZ2h0IDw9IG90aGVyLmxlZnQgLSB0aGlzLmxlZnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwWCA9IG90aGVyLmxlZnQgLSB0aGlzLnJpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbGVmdCBlZGdlIGlzIGNsb3Nlc3QgdG8gdGhlIG90aGVycyBsZWZ0IGVkZ2VcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBYID0gb3RoZXIucmlnaHQgLSB0aGlzLmxlZnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBvdGhlciBpcyB3aWRlciB0aGFuIHRoaXNcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgcmlnaHQgZWRnZSBpcyBjbG9zZXN0IHRvIHRoZSBvdGhlcnMgcmlnaHQgZWRnZVxyXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyLnJpZ2h0IC0gdGhpcy5yaWdodCA8PSB0aGlzLmxlZnQgLSBvdGhlci5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFggPSB0aGlzLmxlZnQgLSBvdGhlci5yaWdodDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGxlZnQgZWRnZSBpcyBjbG9zZXN0IHRvIHRoZSBvdGhlcnMgbGVmdCBlZGdlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwWCA9IHRoaXMucmlnaHQgLSBvdGhlci5sZWZ0O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBvdmVybGFwWSA9IDA7XHJcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgdGFsbGVyIHRoYW4gb3RoZXJcclxuICAgICAgICAgICAgaWYgKHRoaXMuaGVpZ2h0IC0gb3RoZXIuaGVpZ2h0ID49IDApIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoZSBib3R0b20gZWRnZSBpcyBjbG9zZXN0IHRvIHRoZSBvdGhlcnMgYm90dG9tIGVkZ2VcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmJvdHRvbSAtIG90aGVyLmJvdHRvbSA8PSBvdGhlci50b3AgLSB0aGlzLnRvcCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBZID0gb3RoZXIudG9wIC0gdGhpcy5ib3R0b207XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGFwWSA9IG90aGVyLmJvdHRvbSAtIHRoaXMudG9wO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgaXMgdGFsbGVyIHRoYW4gdGhpc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGJvdHRvbSBlZGdlIGlzIGNsb3Nlc3QgdG8gdGhlIG90aGVycyBib3R0b20gZWRnZVxyXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyLmJvdHRvbSAtIHRoaXMuYm90dG9tIDw9IHRoaXMudG9wIC0gb3RoZXIudG9wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFkgPSB0aGlzLnRvcCAtIG90aGVyLmJvdHRvbTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXBZID0gdGhpcy5ib3R0b20gLSBvdGhlci50b3A7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKE1hdGguYWJzKG92ZXJsYXBYKSA8IE1hdGguYWJzKG92ZXJsYXBZKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3Iob3ZlcmxhcFgsIDApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoMCwgb3ZlcmxhcFkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3Qgd2hldGhlciB0aGUgYm91bmRpbmcgYm94IGhhcyBpbnRlcnNlY3RlZCB3aXRoIGFub3RoZXIgYm91bmRpbmcgYm94LCByZXR1cm5zIHRoZSBzaWRlIG9mIHRoZSBjdXJyZW50IGJiIHRoYXQgaW50ZXJzZWN0ZWQuXHJcbiAgICAgKiBAcGFyYW0gYmIgVGhlIG90aGVyIGFjdG9yIHRvIHRlc3RcclxuICAgICAqL1xyXG4gICAgaW50ZXJzZWN0V2l0aFNpZGUoYmIpIHtcclxuICAgICAgICBjb25zdCBpbnRlcnNlY3QgPSB0aGlzLmludGVyc2VjdChiYik7XHJcbiAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94LmdldFNpZGVGcm9tSW50ZXJzZWN0aW9uKGludGVyc2VjdCk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgZGVidWdEcmF3KGN0eCwgY29sb3IgPSBDb2xvci5ZZWxsb3cpIHtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5zdHJva2VSZWN0KHRoaXMubGVmdCwgdGhpcy50b3AsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGRlYnVnIGJvdW5kaW5nIGJveFxyXG4gICAgICogQHBhcmFtIGV4XHJcbiAgICAgKiBAcGFyYW0gY29sb3JcclxuICAgICAqL1xyXG4gICAgZHJhdyhleCwgY29sb3IgPSBDb2xvci5ZZWxsb3cpIHtcclxuICAgICAgICBleC5kZWJ1Zy5kcmF3UmVjdCh0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgeyBjb2xvciB9KTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL01hdGgvbWF0cml4LnRzXG5cclxuXHJcblxyXG52YXIgTWF0cml4TG9jYXRpb25zO1xyXG4oZnVuY3Rpb24gKE1hdHJpeExvY2F0aW9ucykge1xyXG4gICAgTWF0cml4TG9jYXRpb25zW01hdHJpeExvY2F0aW9uc1tcIlhcIl0gPSAxMl0gPSBcIlhcIjtcclxuICAgIE1hdHJpeExvY2F0aW9uc1tNYXRyaXhMb2NhdGlvbnNbXCJZXCJdID0gMTNdID0gXCJZXCI7XHJcbn0pKE1hdHJpeExvY2F0aW9ucyB8fCAoTWF0cml4TG9jYXRpb25zID0ge30pKTtcclxuY29uc3Qgc2lnbiA9ICh2YWwpID0+IHtcclxuICAgIGlmICh2YWwgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIHJldHVybiB2YWwgPCAwID8gLTEgOiAxO1xyXG59O1xyXG4vLyBjb25zdCBtdWx0TWF0Y2ggPSAoYTogbnVtYmVyLCBiOiBudW1iZXIpID0+IHtcclxuLy8gICBpZiAoc2lnbihhKSA8IDAgJiYgc2lnbihiKSA8IDApIHtcclxuLy8gICAgIHJldHVybiAtTWF0aC5hYnMoYSAqIGIpO1xyXG4vLyAgIH1cclxuLy8gICByZXR1cm4gYSAqIGI7XHJcbi8vIH1cclxuLy8gY29uc3QgZXBzaWxvbiA9ICh2YWw6IG51bWJlcikgPT4ge1xyXG4vLyAgIGlmICh2YWwgKiB2YWwgPCAuMDAwMSkge1xyXG4vLyAgICAgcmV0dXJuIDA7XHJcbi8vICAgfVxyXG4vLyAgIHJldHVybiB2YWw7XHJcbi8vIH1cclxuLyoqXHJcbiAqIEV4Y2FsaWJ1ciBNYXRyaXggaGVscGVyIGZvciA0eDQgbWF0cmljZXNcclxuICpcclxuICogVXNlZnVsIGZvciB3ZWJnbCA0eDQgbWF0cmljZXNcclxuICovXHJcbmNsYXNzIE1hdHJpeCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiAgNHg0IG1hdHJpeCBpbiBjb2x1bW4gbWFqb3Igb3JkZXJcclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIHwgICAgICAgICB8ICAgICAgICAgfCAgICAgICAgICB8ICAgICAgICAgIHxcclxuICAgICAgICAgKiB8IC0tLS0tLS0gfCAtLS0tLS0tIHwgLS0tLS0tLS0gfCAgICAgICAgICB8XHJcbiAgICAgICAgICogfCBkYXRhWzBdIHwgZGF0YVs0XSB8IGRhdGFbOF0gIHwgZGF0YVsxMl0gfFxyXG4gICAgICAgICAqIHwgZGF0YVsxXSB8IGRhdGFbNV0gfCBkYXRhWzldICB8IGRhdGFbMTNdIHxcclxuICAgICAgICAgKiB8IGRhdGFbMl0gfCBkYXRhWzZdIHwgZGF0YVsxMF0gfCBkYXRhWzE0XSB8XHJcbiAgICAgICAgICogfCBkYXRhWzNdIHwgZGF0YVs3XSB8IGRhdGFbMTFdIHwgZGF0YVsxNV0gfFxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XHJcbiAgICAgICAgdGhpcy5fc2NhbGVTaWduWCA9IDE7XHJcbiAgICAgICAgdGhpcy5fc2NhbGVTaWduWSA9IDE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gb3J0aG9ncmFwaGljIChmbGF0IG5vbi1wZXJzcGVjdGl2ZSkgcHJvamVjdGlvblxyXG4gICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3J0aG9ncmFwaGljX3Byb2plY3Rpb25cclxuICAgICAqIEBwYXJhbSBsZWZ0XHJcbiAgICAgKiBAcGFyYW0gcmlnaHRcclxuICAgICAqIEBwYXJhbSBib3R0b21cclxuICAgICAqIEBwYXJhbSB0b3BcclxuICAgICAqIEBwYXJhbSBuZWFyXHJcbiAgICAgKiBAcGFyYW0gZmFyXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBvcnRobyhsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xyXG4gICAgICAgIGNvbnN0IG1hdCA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICBtYXQuZGF0YVswXSA9IDIgLyAocmlnaHQgLSBsZWZ0KTtcclxuICAgICAgICBtYXQuZGF0YVsxXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbMl0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzNdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs0XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbNV0gPSAyIC8gKHRvcCAtIGJvdHRvbSk7XHJcbiAgICAgICAgbWF0LmRhdGFbNl0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzddID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs4XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbOV0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzEwXSA9IC0yIC8gKGZhciAtIG5lYXIpO1xyXG4gICAgICAgIG1hdC5kYXRhWzExXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbMTJdID0gLShyaWdodCArIGxlZnQpIC8gKHJpZ2h0IC0gbGVmdCk7XHJcbiAgICAgICAgbWF0LmRhdGFbMTNdID0gLSh0b3AgKyBib3R0b20pIC8gKHRvcCAtIGJvdHRvbSk7XHJcbiAgICAgICAgbWF0LmRhdGFbMTRdID0gLShmYXIgKyBuZWFyKSAvIChmYXIgLSBuZWFyKTtcclxuICAgICAgICBtYXQuZGF0YVsxNV0gPSAxO1xyXG4gICAgICAgIHJldHVybiBtYXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgTWF0cml4IHdpdGggdGhlIHNhbWUgZGF0YSBhcyB0aGUgY3VycmVudCA0eDRcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgY29uc3QgbWF0ID0gbmV3IE1hdHJpeCgpO1xyXG4gICAgICAgIG1hdC5kYXRhWzBdID0gdGhpcy5kYXRhWzBdO1xyXG4gICAgICAgIG1hdC5kYXRhWzFdID0gdGhpcy5kYXRhWzFdO1xyXG4gICAgICAgIG1hdC5kYXRhWzJdID0gdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgIG1hdC5kYXRhWzNdID0gdGhpcy5kYXRhWzNdO1xyXG4gICAgICAgIG1hdC5kYXRhWzRdID0gdGhpcy5kYXRhWzRdO1xyXG4gICAgICAgIG1hdC5kYXRhWzVdID0gdGhpcy5kYXRhWzVdO1xyXG4gICAgICAgIG1hdC5kYXRhWzZdID0gdGhpcy5kYXRhWzZdO1xyXG4gICAgICAgIG1hdC5kYXRhWzddID0gdGhpcy5kYXRhWzddO1xyXG4gICAgICAgIG1hdC5kYXRhWzhdID0gdGhpcy5kYXRhWzhdO1xyXG4gICAgICAgIG1hdC5kYXRhWzldID0gdGhpcy5kYXRhWzldO1xyXG4gICAgICAgIG1hdC5kYXRhWzEwXSA9IHRoaXMuZGF0YVsxMF07XHJcbiAgICAgICAgbWF0LmRhdGFbMTFdID0gdGhpcy5kYXRhWzExXTtcclxuICAgICAgICBtYXQuZGF0YVsxMl0gPSB0aGlzLmRhdGFbMTJdO1xyXG4gICAgICAgIG1hdC5kYXRhWzEzXSA9IHRoaXMuZGF0YVsxM107XHJcbiAgICAgICAgbWF0LmRhdGFbMTRdID0gdGhpcy5kYXRhWzE0XTtcclxuICAgICAgICBtYXQuZGF0YVsxNV0gPSB0aGlzLmRhdGFbMTVdO1xyXG4gICAgICAgIHJldHVybiBtYXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0cml4IChhIG1hdHJpeCB0aGF0IHdoZW4gYXBwbGllZCBkb2VzIG5vdGhpbmcpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBpZGVudGl0eSgpIHtcclxuICAgICAgICBjb25zdCBtYXQgPSBuZXcgTWF0cml4KCk7XHJcbiAgICAgICAgbWF0LmRhdGFbMF0gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzFdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsyXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbM10gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzRdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs1XSA9IDE7XHJcbiAgICAgICAgbWF0LmRhdGFbNl0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzddID0gMDtcclxuICAgICAgICBtYXQuZGF0YVs4XSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbOV0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzEwXSA9IDE7XHJcbiAgICAgICAgbWF0LmRhdGFbMTFdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsxMl0gPSAwO1xyXG4gICAgICAgIG1hdC5kYXRhWzEzXSA9IDA7XHJcbiAgICAgICAgbWF0LmRhdGFbMTRdID0gMDtcclxuICAgICAgICBtYXQuZGF0YVsxNV0gPSAxO1xyXG4gICAgICAgIHJldHVybiBtYXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBicmFuZCBuZXcgdHJhbnNsYXRpb24gbWF0cml4IGF0IHRoZSBzcGVjaWZpZWQgM2QgcG9pbnRcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdHJhbnNsYXRpb24oeCwgeSkge1xyXG4gICAgICAgIGNvbnN0IG1hdCA9IE1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgICAgIG1hdC5kYXRhWzEyXSA9IHg7XHJcbiAgICAgICAgbWF0LmRhdGFbMTNdID0geTtcclxuICAgICAgICByZXR1cm4gbWF0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgYnJhbmQgbmV3IHNjYWxpbmcgbWF0cml4IHdpdGggdGhlIHNwZWNpZmllZCBzY2FsaW5nIGZhY3RvclxyXG4gICAgICogQHBhcmFtIHN4XHJcbiAgICAgKiBAcGFyYW0gc3lcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHNjYWxlKHN4LCBzeSkge1xyXG4gICAgICAgIGNvbnN0IG1hdCA9IE1hdHJpeC5pZGVudGl0eSgpO1xyXG4gICAgICAgIG1hdC5kYXRhWzBdID0gc3g7XHJcbiAgICAgICAgbWF0LmRhdGFbNV0gPSBzeTtcclxuICAgICAgICBtYXQuZGF0YVsxMF0gPSAxO1xyXG4gICAgICAgIG1hdC5kYXRhWzE1XSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIG1hdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGJyYW5kIG5ldyByb3RhdGlvbiBtYXRyaXggd2l0aCB0aGUgc3BlY2lmaWVkIGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0gYW5nbGVSYWRpYW5zXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByb3RhdGlvbihhbmdsZVJhZGlhbnMpIHtcclxuICAgICAgICBjb25zdCBtYXQgPSBNYXRyaXguaWRlbnRpdHkoKTtcclxuICAgICAgICBtYXQuZGF0YVswXSA9IE1hdGguY29zKGFuZ2xlUmFkaWFucyk7XHJcbiAgICAgICAgbWF0LmRhdGFbNF0gPSAtTWF0aC5zaW4oYW5nbGVSYWRpYW5zKTtcclxuICAgICAgICBtYXQuZGF0YVsxXSA9IE1hdGguc2luKGFuZ2xlUmFkaWFucyk7XHJcbiAgICAgICAgbWF0LmRhdGFbNV0gPSBNYXRoLmNvcyhhbmdsZVJhZGlhbnMpO1xyXG4gICAgICAgIHJldHVybiBtYXQ7XHJcbiAgICB9XHJcbiAgICBtdWx0dihvdGhlcikge1xyXG4gICAgICAgIGNvbnN0IHogPSAwO1xyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IFZlY3RvcihvdGhlci54ICogdGhpcy5kYXRhWzBdICsgb3RoZXIueSAqIHRoaXMuZGF0YVs0XSArIHogKiB0aGlzLmRhdGFbNl0gKyAxICogdGhpcy5kYXRhWzEyXSwgb3RoZXIueCAqIHRoaXMuZGF0YVsxXSArIG90aGVyLnkgKiB0aGlzLmRhdGFbNV0gKyB6ICogdGhpcy5kYXRhWzldICsgMSAqIHRoaXMuZGF0YVsxM10pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZGVzdCA9IFtcclxuICAgICAgICAgICAgICAgIG90aGVyWzBdICogdGhpcy5kYXRhWzBdICsgb3RoZXJbMV0gKiB0aGlzLmRhdGFbNF0gKyB6ICogdGhpcy5kYXRhWzZdICsgMSAqIHRoaXMuZGF0YVsxMl0sXHJcbiAgICAgICAgICAgICAgICBvdGhlclswXSAqIHRoaXMuZGF0YVsxXSArIG90aGVyWzFdICogdGhpcy5kYXRhWzVdICsgeiAqIHRoaXMuZGF0YVs5XSArIDEgKiB0aGlzLmRhdGFbMTNdXHJcbiAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTXVsdGlwbGllcyB0aGUgY3VycmVudCBtYXRyaXggYnkgYW5vdGhlciBhbmQgcmV0dXJucyB0aGUgcmVzdWx0aW5nIG1hdHJpeFxyXG4gICAgICogQHBhcmFtIG90aGVyXHJcbiAgICAgKi9cclxuICAgIG11bHRtKG90aGVyKSB7XHJcbiAgICAgICAgY29uc3QgZGVzdCA9IG5ldyBNYXRyaXgoKTtcclxuICAgICAgICBjb25zdCBhMTEgPSB0aGlzLmRhdGFbMF07XHJcbiAgICAgICAgY29uc3QgYTIxID0gdGhpcy5kYXRhWzFdO1xyXG4gICAgICAgIGNvbnN0IGEzMSA9IHRoaXMuZGF0YVsyXTtcclxuICAgICAgICBjb25zdCBhNDEgPSB0aGlzLmRhdGFbM107XHJcbiAgICAgICAgY29uc3QgYTEyID0gdGhpcy5kYXRhWzRdO1xyXG4gICAgICAgIGNvbnN0IGEyMiA9IHRoaXMuZGF0YVs1XTtcclxuICAgICAgICBjb25zdCBhMzIgPSB0aGlzLmRhdGFbNl07XHJcbiAgICAgICAgY29uc3QgYTQyID0gdGhpcy5kYXRhWzddO1xyXG4gICAgICAgIGNvbnN0IGExMyA9IHRoaXMuZGF0YVs4XTtcclxuICAgICAgICBjb25zdCBhMjMgPSB0aGlzLmRhdGFbOV07XHJcbiAgICAgICAgY29uc3QgYTMzID0gdGhpcy5kYXRhWzEwXTtcclxuICAgICAgICBjb25zdCBhNDMgPSB0aGlzLmRhdGFbMTFdO1xyXG4gICAgICAgIGNvbnN0IGExNCA9IHRoaXMuZGF0YVsxMl07XHJcbiAgICAgICAgY29uc3QgYTI0ID0gdGhpcy5kYXRhWzEzXTtcclxuICAgICAgICBjb25zdCBhMzQgPSB0aGlzLmRhdGFbMTRdO1xyXG4gICAgICAgIGNvbnN0IGE0NCA9IHRoaXMuZGF0YVsxNV07XHJcbiAgICAgICAgY29uc3QgYjExID0gb3RoZXIuZGF0YVswXTtcclxuICAgICAgICBjb25zdCBiMjEgPSBvdGhlci5kYXRhWzFdO1xyXG4gICAgICAgIGNvbnN0IGIzMSA9IG90aGVyLmRhdGFbMl07XHJcbiAgICAgICAgY29uc3QgYjQxID0gb3RoZXIuZGF0YVszXTtcclxuICAgICAgICBjb25zdCBiMTIgPSBvdGhlci5kYXRhWzRdO1xyXG4gICAgICAgIGNvbnN0IGIyMiA9IG90aGVyLmRhdGFbNV07XHJcbiAgICAgICAgY29uc3QgYjMyID0gb3RoZXIuZGF0YVs2XTtcclxuICAgICAgICBjb25zdCBiNDIgPSBvdGhlci5kYXRhWzddO1xyXG4gICAgICAgIGNvbnN0IGIxMyA9IG90aGVyLmRhdGFbOF07XHJcbiAgICAgICAgY29uc3QgYjIzID0gb3RoZXIuZGF0YVs5XTtcclxuICAgICAgICBjb25zdCBiMzMgPSBvdGhlci5kYXRhWzEwXTtcclxuICAgICAgICBjb25zdCBiNDMgPSBvdGhlci5kYXRhWzExXTtcclxuICAgICAgICBjb25zdCBiMTQgPSBvdGhlci5kYXRhWzEyXTtcclxuICAgICAgICBjb25zdCBiMjQgPSBvdGhlci5kYXRhWzEzXTtcclxuICAgICAgICBjb25zdCBiMzQgPSBvdGhlci5kYXRhWzE0XTtcclxuICAgICAgICBjb25zdCBiNDQgPSBvdGhlci5kYXRhWzE1XTtcclxuICAgICAgICBkZXN0LmRhdGFbMF0gPSBhMTEgKiBiMTEgKyBhMTIgKiBiMjEgKyBhMTMgKiBiMzEgKyBhMTQgKiBiNDE7XHJcbiAgICAgICAgZGVzdC5kYXRhWzFdID0gYTIxICogYjExICsgYTIyICogYjIxICsgYTIzICogYjMxICsgYTI0ICogYjQxO1xyXG4gICAgICAgIGRlc3QuZGF0YVsyXSA9IGEzMSAqIGIxMSArIGEzMiAqIGIyMSArIGEzMyAqIGIzMSArIGEzNCAqIGI0MTtcclxuICAgICAgICBkZXN0LmRhdGFbM10gPSBhNDEgKiBiMTEgKyBhNDIgKiBiMjEgKyBhNDMgKiBiMzEgKyBhNDQgKiBiNDE7XHJcbiAgICAgICAgZGVzdC5kYXRhWzRdID0gYTExICogYjEyICsgYTEyICogYjIyICsgYTEzICogYjMyICsgYTE0ICogYjQyO1xyXG4gICAgICAgIGRlc3QuZGF0YVs1XSA9IGEyMSAqIGIxMiArIGEyMiAqIGIyMiArIGEyMyAqIGIzMiArIGEyNCAqIGI0MjtcclxuICAgICAgICBkZXN0LmRhdGFbNl0gPSBhMzEgKiBiMTIgKyBhMzIgKiBiMjIgKyBhMzMgKiBiMzIgKyBhMzQgKiBiNDI7XHJcbiAgICAgICAgZGVzdC5kYXRhWzddID0gYTQxICogYjEyICsgYTQyICogYjIyICsgYTQzICogYjMyICsgYTQ0ICogYjQyO1xyXG4gICAgICAgIGRlc3QuZGF0YVs4XSA9IGExMSAqIGIxMyArIGExMiAqIGIyMyArIGExMyAqIGIzMyArIGExNCAqIGI0MztcclxuICAgICAgICBkZXN0LmRhdGFbOV0gPSBhMjEgKiBiMTMgKyBhMjIgKiBiMjMgKyBhMjMgKiBiMzMgKyBhMjQgKiBiNDM7XHJcbiAgICAgICAgZGVzdC5kYXRhWzEwXSA9IGEzMSAqIGIxMyArIGEzMiAqIGIyMyArIGEzMyAqIGIzMyArIGEzNCAqIGI0MztcclxuICAgICAgICBkZXN0LmRhdGFbMTFdID0gYTQxICogYjEzICsgYTQyICogYjIzICsgYTQzICogYjMzICsgYTQ0ICogYjQzO1xyXG4gICAgICAgIGRlc3QuZGF0YVsxMl0gPSBhMTEgKiBiMTQgKyBhMTIgKiBiMjQgKyBhMTMgKiBiMzQgKyBhMTQgKiBiNDQ7XHJcbiAgICAgICAgZGVzdC5kYXRhWzEzXSA9IGEyMSAqIGIxNCArIGEyMiAqIGIyNCArIGEyMyAqIGIzNCArIGEyNCAqIGI0NDtcclxuICAgICAgICBkZXN0LmRhdGFbMTRdID0gYTMxICogYjE0ICsgYTMyICogYjI0ICsgYTMzICogYjM0ICsgYTM0ICogYjQ0O1xyXG4gICAgICAgIGRlc3QuZGF0YVsxNV0gPSBhNDEgKiBiMTQgKyBhNDIgKiBiMjQgKyBhNDMgKiBiMzQgKyBhNDQgKiBiNDQ7XHJcbiAgICAgICAgY29uc3QgcyA9IHRoaXMuZ2V0U2NhbGUoKTtcclxuICAgICAgICBkZXN0Ll9zY2FsZVNpZ25YID0gc2lnbihzLngpICogc2lnbihkZXN0Ll9zY2FsZVNpZ25YKTtcclxuICAgICAgICBkZXN0Ll9zY2FsZVNpZ25ZID0gc2lnbihzLnkpICogc2lnbihkZXN0Ll9zY2FsZVNpZ25ZKTtcclxuICAgICAgICByZXR1cm4gZGVzdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0cmFuc2xhdGlvbiB0byB0aGUgY3VycmVudCBtYXRyaXggbXV0YXRpbmcgaXRcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICovXHJcbiAgICB0cmFuc2xhdGUoeCwgeSkge1xyXG4gICAgICAgIGNvbnN0IGExMSA9IHRoaXMuZGF0YVswXTtcclxuICAgICAgICBjb25zdCBhMjEgPSB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgY29uc3QgYTMxID0gdGhpcy5kYXRhWzJdO1xyXG4gICAgICAgIGNvbnN0IGE0MSA9IHRoaXMuZGF0YVszXTtcclxuICAgICAgICBjb25zdCBhMTIgPSB0aGlzLmRhdGFbNF07XHJcbiAgICAgICAgY29uc3QgYTIyID0gdGhpcy5kYXRhWzVdO1xyXG4gICAgICAgIGNvbnN0IGEzMiA9IHRoaXMuZGF0YVs2XTtcclxuICAgICAgICBjb25zdCBhNDIgPSB0aGlzLmRhdGFbN107XHJcbiAgICAgICAgY29uc3QgYTEzID0gdGhpcy5kYXRhWzhdO1xyXG4gICAgICAgIGNvbnN0IGEyMyA9IHRoaXMuZGF0YVs5XTtcclxuICAgICAgICBjb25zdCBhMzMgPSB0aGlzLmRhdGFbMTBdO1xyXG4gICAgICAgIGNvbnN0IGE0MyA9IHRoaXMuZGF0YVsxMV07XHJcbiAgICAgICAgY29uc3QgYTE0ID0gdGhpcy5kYXRhWzEyXTtcclxuICAgICAgICBjb25zdCBhMjQgPSB0aGlzLmRhdGFbMTNdO1xyXG4gICAgICAgIGNvbnN0IGEzNCA9IHRoaXMuZGF0YVsxNF07XHJcbiAgICAgICAgY29uc3QgYTQ0ID0gdGhpcy5kYXRhWzE1XTtcclxuICAgICAgICAvLyBEb2Vzbid0IGNoYW5nZSB6XHJcbiAgICAgICAgY29uc3QgeiA9IDA7XHJcbiAgICAgICAgY29uc3QgdyA9IDE7XHJcbiAgICAgICAgdGhpcy5kYXRhWzEyXSA9IGExMSAqIHggKyBhMTIgKiB5ICsgYTEzICogeiArIGExNCAqIHc7XHJcbiAgICAgICAgdGhpcy5kYXRhWzEzXSA9IGEyMSAqIHggKyBhMjIgKiB5ICsgYTIzICogeiArIGEyNCAqIHc7XHJcbiAgICAgICAgdGhpcy5kYXRhWzE0XSA9IGEzMSAqIHggKyBhMzIgKiB5ICsgYTMzICogeiArIGEzNCAqIHc7XHJcbiAgICAgICAgdGhpcy5kYXRhWzE1XSA9IGE0MSAqIHggKyBhNDIgKiB5ICsgYTQzICogeiArIGE0NCAqIHc7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRQb3NpdGlvbih4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5kYXRhWzEyXSA9IHg7XHJcbiAgICAgICAgdGhpcy5kYXRhWzEzXSA9IHk7XHJcbiAgICB9XHJcbiAgICBnZXRQb3NpdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdmVjKHRoaXMuZGF0YVsxMl0sIHRoaXMuZGF0YVsxM10pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHJvdGF0aW9uIHRvIHRoZSBjdXJyZW50IG1hdHJpeCBtdXRhdGluZyBpdFxyXG4gICAgICogQHBhcmFtIGFuZ2xlIGluIFJhZGlhbnNcclxuICAgICAqL1xyXG4gICAgcm90YXRlKGFuZ2xlKSB7XHJcbiAgICAgICAgY29uc3QgYTExID0gdGhpcy5kYXRhWzBdO1xyXG4gICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuZGF0YVsxXTtcclxuICAgICAgICBjb25zdCBhMzEgPSB0aGlzLmRhdGFbMl07XHJcbiAgICAgICAgY29uc3QgYTQxID0gdGhpcy5kYXRhWzNdO1xyXG4gICAgICAgIGNvbnN0IGExMiA9IHRoaXMuZGF0YVs0XTtcclxuICAgICAgICBjb25zdCBhMjIgPSB0aGlzLmRhdGFbNV07XHJcbiAgICAgICAgY29uc3QgYTMyID0gdGhpcy5kYXRhWzZdO1xyXG4gICAgICAgIGNvbnN0IGE0MiA9IHRoaXMuZGF0YVs3XTtcclxuICAgICAgICBjb25zdCBzaW5lID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIGNvbnN0IGNvc2luZSA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICB0aGlzLmRhdGFbMF0gPSBjb3NpbmUgKiBhMTEgKyBzaW5lICogYTEyO1xyXG4gICAgICAgIHRoaXMuZGF0YVsxXSA9IGNvc2luZSAqIGEyMSArIHNpbmUgKiBhMjI7XHJcbiAgICAgICAgdGhpcy5kYXRhWzJdID0gY29zaW5lICogYTMxICsgc2luZSAqIGEzMjtcclxuICAgICAgICB0aGlzLmRhdGFbM10gPSBjb3NpbmUgKiBhNDEgKyBzaW5lICogYTQyO1xyXG4gICAgICAgIHRoaXMuZGF0YVs0XSA9IGNvc2luZSAqIGExMiAtIHNpbmUgKiBhMTE7XHJcbiAgICAgICAgdGhpcy5kYXRhWzVdID0gY29zaW5lICogYTIyIC0gc2luZSAqIGEyMTtcclxuICAgICAgICB0aGlzLmRhdGFbNl0gPSBjb3NpbmUgKiBhMzIgLSBzaW5lICogYTMxO1xyXG4gICAgICAgIHRoaXMuZGF0YVs3XSA9IGNvc2luZSAqIGE0MiAtIHNpbmUgKiBhNDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgc2NhbGluZyB0byB0aGUgY3VycmVudCBtYXRyaXggbXV0YXRpbmcgaXRcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICovXHJcbiAgICBzY2FsZSh4LCB5KSB7XHJcbiAgICAgICAgY29uc3QgYTExID0gdGhpcy5kYXRhWzBdO1xyXG4gICAgICAgIGNvbnN0IGEyMSA9IHRoaXMuZGF0YVsxXTtcclxuICAgICAgICBjb25zdCBhMzEgPSB0aGlzLmRhdGFbMl07XHJcbiAgICAgICAgY29uc3QgYTQxID0gdGhpcy5kYXRhWzNdO1xyXG4gICAgICAgIGNvbnN0IGExMiA9IHRoaXMuZGF0YVs0XTtcclxuICAgICAgICBjb25zdCBhMjIgPSB0aGlzLmRhdGFbNV07XHJcbiAgICAgICAgY29uc3QgYTMyID0gdGhpcy5kYXRhWzZdO1xyXG4gICAgICAgIGNvbnN0IGE0MiA9IHRoaXMuZGF0YVs3XTtcclxuICAgICAgICB0aGlzLmRhdGFbMF0gPSBhMTEgKiB4O1xyXG4gICAgICAgIHRoaXMuZGF0YVsxXSA9IGEyMSAqIHg7XHJcbiAgICAgICAgdGhpcy5kYXRhWzJdID0gYTMxICogeDtcclxuICAgICAgICB0aGlzLmRhdGFbM10gPSBhNDEgKiB4O1xyXG4gICAgICAgIHRoaXMuZGF0YVs0XSA9IGExMiAqIHk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzVdID0gYTIyICogeTtcclxuICAgICAgICB0aGlzLmRhdGFbNl0gPSBhMzIgKiB5O1xyXG4gICAgICAgIHRoaXMuZGF0YVs3XSA9IGE0MiAqIHk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzZXRSb3RhdGlvbihhbmdsZSkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRTY2FsZSA9IHRoaXMuZ2V0U2NhbGUoKTtcclxuICAgICAgICBjb25zdCBzaW5lID0gTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIGNvbnN0IGNvc2luZSA9IE1hdGguY29zKGFuZ2xlKTtcclxuICAgICAgICB0aGlzLmRhdGFbMF0gPSBjb3NpbmUgKiBjdXJyZW50U2NhbGUueDtcclxuICAgICAgICB0aGlzLmRhdGFbMV0gPSBzaW5lICogY3VycmVudFNjYWxlLnk7XHJcbiAgICAgICAgdGhpcy5kYXRhWzRdID0gLXNpbmUgKiBjdXJyZW50U2NhbGUueDtcclxuICAgICAgICB0aGlzLmRhdGFbNV0gPSBjb3NpbmUgKiBjdXJyZW50U2NhbGUueTtcclxuICAgIH1cclxuICAgIGdldFJvdGF0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gTWF0aC5hdGFuMih0aGlzLmRhdGFbMV0gLyB0aGlzLmdldFNjYWxlWSgpLCB0aGlzLmRhdGFbMF0gLyB0aGlzLmdldFNjYWxlWCgpKTtcclxuICAgICAgICByZXR1cm4gY2Fub25pY2FsaXplQW5nbGUoYW5nbGUpO1xyXG4gICAgfVxyXG4gICAgZ2V0U2NhbGVYKCkge1xyXG4gICAgICAgIC8vIGFic29sdXRlIHNjYWxlIG9mIHRoZSBtYXRyaXggKHdlIGxvc2Ugc2lnbiBzbyBuZWVkIHRvIGFkZCBpdCBiYWNrKVxyXG4gICAgICAgIGNvbnN0IHhzY2FsZSA9IHZlYyh0aGlzLmRhdGFbMF0sIHRoaXMuZGF0YVs0XSkuc2l6ZTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2NhbGVTaWduWCAqIHhzY2FsZTtcclxuICAgIH1cclxuICAgIGdldFNjYWxlWSgpIHtcclxuICAgICAgICAvLyBhYnNvbHV0ZSBzY2FsZSBvZiB0aGUgbWF0cml4ICh3ZSBsb3NlIHNpZ24gc28gbmVlZCB0byBhZGQgaXQgYmFjaylcclxuICAgICAgICBjb25zdCB5c2NhbGUgPSB2ZWModGhpcy5kYXRhWzFdLCB0aGlzLmRhdGFbNV0pLnNpemU7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlU2lnblkgKiB5c2NhbGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc2NhbGUgb2YgdGhlIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBnZXRTY2FsZSgpIHtcclxuICAgICAgICByZXR1cm4gdmVjKHRoaXMuZ2V0U2NhbGVYKCksIHRoaXMuZ2V0U2NhbGVZKCkpO1xyXG4gICAgfVxyXG4gICAgc2V0U2NhbGVYKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3NjYWxlU2lnblggPSBzaWduKHZhbCk7XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgc2NhbGUgYWN0cyBsaWtlIGEgMTgwIHJvdGF0aW9uLCBzbyBmbGlwXHJcbiAgICAgICAgY29uc3QgeHNjYWxlID0gdmVjKHRoaXMuZGF0YVswXSAqIHRoaXMuX3NjYWxlU2lnblgsIHRoaXMuZGF0YVs0XSAqIHRoaXMuX3NjYWxlU2lnblgpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHRoaXMuZGF0YVswXSA9IHhzY2FsZS54ICogdmFsO1xyXG4gICAgICAgIHRoaXMuZGF0YVs0XSA9IHhzY2FsZS55ICogdmFsO1xyXG4gICAgfVxyXG4gICAgc2V0U2NhbGVZKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3NjYWxlU2lnblkgPSBzaWduKHZhbCk7XHJcbiAgICAgICAgLy8gbmVnYXRpdmUgc2NhbGUgYWN0cyBsaWtlIGEgMTgwIHJvdGF0aW9uLCBzbyBmbGlwXHJcbiAgICAgICAgY29uc3QgeXNjYWxlID0gdmVjKHRoaXMuZGF0YVsxXSAqIHRoaXMuX3NjYWxlU2lnblksIHRoaXMuZGF0YVs1XSAqIHRoaXMuX3NjYWxlU2lnblkpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHRoaXMuZGF0YVsxXSA9IHlzY2FsZS54ICogdmFsO1xyXG4gICAgICAgIHRoaXMuZGF0YVs1XSA9IHlzY2FsZS55ICogdmFsO1xyXG4gICAgfVxyXG4gICAgc2V0U2NhbGUoc2NhbGUpIHtcclxuICAgICAgICB0aGlzLnNldFNjYWxlWChzY2FsZS54KTtcclxuICAgICAgICB0aGlzLnNldFNjYWxlWShzY2FsZS55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZXJtaW5hbnQgb2YgdGhlIHVwcGVyIGxlZnQgMngyIG1hdHJpeFxyXG4gICAgICovXHJcbiAgICBnZXRCYXNpc0RldGVybWluYW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbMF0gKiB0aGlzLmRhdGFbNV0gLSB0aGlzLmRhdGFbMV0gKiB0aGlzLmRhdGFbNF07XHJcbiAgICB9XHJcbiAgICBnZXRBZmZpbmVJbnZlcnNlKCkge1xyXG4gICAgICAgIC8vIFNlZSBodHRwOi8vbmVnYXRpdmVwcm9iYWJpbGl0eS5ibG9nc3BvdC5jb20vMjAxMS8xMS9hZmZpbmUtdHJhbnNmb3JtYXRpb25zLWFuZC10aGVpci5odG1sXHJcbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vd3d3Lm1hdGhzaXNmdW4uY29tL2FsZ2VicmEvbWF0cml4LWludmVyc2UuaHRtbFxyXG4gICAgICAgIC8vIFNpbmNlIHdlIGFyZSBhY3R1YWxseSBvbmx5IGRvaW5nIDJEIHRyYW5zZm9ybWF0aW9ucyB3ZSBjYW4gdXNlIHRoaXMgaGFja1xyXG4gICAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IHVzZSB0aGUgM3JkIG9yIDR0aCBkaW1lbnNpb25cclxuICAgICAgICBjb25zdCBkZXQgPSB0aGlzLmdldEJhc2lzRGV0ZXJtaW5hbnQoKTtcclxuICAgICAgICBjb25zdCBpbnZlcnNlRGV0ID0gMSAvIGRldDsgLy8gdG9kbyB6ZXJvIGNoZWNrXHJcbiAgICAgICAgY29uc3QgYSA9IHRoaXMuZGF0YVswXTtcclxuICAgICAgICBjb25zdCBiID0gdGhpcy5kYXRhWzRdO1xyXG4gICAgICAgIGNvbnN0IGMgPSB0aGlzLmRhdGFbMV07XHJcbiAgICAgICAgY29uc3QgZCA9IHRoaXMuZGF0YVs1XTtcclxuICAgICAgICBjb25zdCBtID0gTWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICAgICAgLy8gaW52ZXJ0cyByb3RhdGlvbiBhbmQgc2NhbGVcclxuICAgICAgICBtLmRhdGFbMF0gPSBkICogaW52ZXJzZURldDtcclxuICAgICAgICBtLmRhdGFbMV0gPSAtYyAqIGludmVyc2VEZXQ7XHJcbiAgICAgICAgbS5kYXRhWzRdID0gLWIgKiBpbnZlcnNlRGV0O1xyXG4gICAgICAgIG0uZGF0YVs1XSA9IGEgKiBpbnZlcnNlRGV0O1xyXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy5kYXRhWzEyXTtcclxuICAgICAgICBjb25zdCB0eSA9IHRoaXMuZGF0YVsxM107XHJcbiAgICAgICAgLy8gaW52ZXJ0IHRyYW5zbGF0aW9uXHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIHRyYW5zbGF0aW9uIGludG8gdGhlIG1hdHJpeCBiYXNpcyBjcmVhdGVkIGJ5IHJvdC9zY2FsZVxyXG4gICAgICAgIG0uZGF0YVsxMl0gPSAtKHR4ICogbS5kYXRhWzBdICsgdHkgKiBtLmRhdGFbNF0pO1xyXG4gICAgICAgIG0uZGF0YVsxM10gPSAtKHR4ICogbS5kYXRhWzFdICsgdHkgKiBtLmRhdGFbNV0pO1xyXG4gICAgICAgIHJldHVybiBtO1xyXG4gICAgfVxyXG4gICAgaXNJZGVudGl0eSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZGF0YVswXSA9PT0gMSAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbMV0gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzJdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVszXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbNF0gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzVdID09PSAxICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVs2XSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbN10gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzhdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVs5XSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbMTBdID09PSAxICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVsxMV0gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzEyXSA9PT0gMCAmJlxyXG4gICAgICAgICAgICB0aGlzLmRhdGFbMTNdID09PSAwICYmXHJcbiAgICAgICAgICAgIHRoaXMuZGF0YVsxNF0gPT09IDAgJiZcclxuICAgICAgICAgICAgdGhpcy5kYXRhWzE1XSA9PT0gMSk7XHJcbiAgICB9XHJcbiAgICB0b1N0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYFxuWyR7dGhpcy5kYXRhWzBdfSAke3RoaXMuZGF0YVs0XX0gJHt0aGlzLmRhdGFbOF19ICR7dGhpcy5kYXRhWzEyXX1dXG5bJHt0aGlzLmRhdGFbMV19ICR7dGhpcy5kYXRhWzVdfSAke3RoaXMuZGF0YVs5XX0gJHt0aGlzLmRhdGFbMTNdfV1cblske3RoaXMuZGF0YVsyXX0gJHt0aGlzLmRhdGFbNl19ICR7dGhpcy5kYXRhWzEwXX0gJHt0aGlzLmRhdGFbMTRdfV1cblske3RoaXMuZGF0YVszXX0gJHt0aGlzLmRhdGFbN119ICR7dGhpcy5kYXRhWzExXX0gJHt0aGlzLmRhdGFbMTVdfV1cbmA7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3RyYW5zZm9ybS1zdGFjay50c1xuXHJcbmNsYXNzIFRyYW5zZm9ybVN0YWNrIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gTWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICB9XHJcbiAgICBzYXZlKCkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybXMucHVzaCh0aGlzLl9jdXJyZW50VHJhbnNmb3JtKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gdGhpcy5fY3VycmVudFRyYW5zZm9ybS5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgcmVzdG9yZSgpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50VHJhbnNmb3JtID0gdGhpcy5fdHJhbnNmb3Jtcy5wb3AoKTtcclxuICAgIH1cclxuICAgIHRyYW5zbGF0ZSh4LCB5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0udHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgfVxyXG4gICAgcm90YXRlKGFuZ2xlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0ucm90YXRlKGFuZ2xlKTtcclxuICAgIH1cclxuICAgIHNjYWxlKHgsIHkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRyYW5zZm9ybS5zY2FsZSh4LCB5KTtcclxuICAgIH1cclxuICAgIHNldCBjdXJyZW50KG1hdHJpeCkge1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSBtYXRyaXg7XHJcbiAgICB9XHJcbiAgICBnZXQgY3VycmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFRyYW5zZm9ybTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvc3RhdGUtc3RhY2sudHNcbmNsYXNzIFN0YXRlU3RhY2sge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhdGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gdGhpcy5fZ2V0RGVmYXVsdFN0YXRlKCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0RGVmYXVsdFN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIG9wYWNpdHk6IDFcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgX2Nsb25lU3RhdGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3BhY2l0eTogdGhpcy5fY3VycmVudFN0YXRlLm9wYWNpdHlcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc2F2ZSgpIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZXMucHVzaCh0aGlzLl9jdXJyZW50U3RhdGUpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRoaXMuX2Nsb25lU3RhdGUoKTtcclxuICAgIH1cclxuICAgIHJlc3RvcmUoKSB7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gdGhpcy5fc3RhdGVzLnBvcCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGN1cnJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTdGF0ZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvc2hhZGVyLnRzXG4vKipcclxuICogQ3JlYXRlIGEgc2hhZGVyIHByb2dyYW0gZm9yIHRoZSBFeGNhbGlidXIgV2ViR0wgR3JhcGhpY3MgQ29udGV4dFxyXG4gKi9cclxuY2xhc3MgU2hhZGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgc2hhZGVyIHByb2dyYW0gaW4gZXhjYWxpYnVyXHJcbiAgICAgKiBAcGFyYW0gX2dsIFdlYkdMIGdyYXBoaWNzIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBfdmVydGV4U291cmNlIFZlcnRleCBzaGFkZXIgc291cmNlIGFzIGEgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gX2ZyYWdtZW50U291cmNlIEZyYWdtZW50IHNoYWRlciBzb3VyY2UgYXMgYSBzdHJpbmdcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoX2dsLCBfdmVydGV4U291cmNlLCBfZnJhZ21lbnRTb3VyY2UpIHtcclxuICAgICAgICB0aGlzLl9nbCA9IF9nbDtcclxuICAgICAgICB0aGlzLl92ZXJ0ZXhTb3VyY2UgPSBfdmVydGV4U291cmNlO1xyXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50U291cmNlID0gX2ZyYWdtZW50U291cmNlO1xyXG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy51bmlmb3JtcyA9IHt9O1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgICAgIHRoaXMubGF5b3V0ID0gW107XHJcbiAgICAgICAgdGhpcy5jb21waWxlKF9nbCk7XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcikge1xyXG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgICAgaWYgKHByb2dyYW0gPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBjcmVhdGUgZ3JhcGhpY3Mgc2hhZGVyIHByb2dyYW0nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYXR0YWNoIHRoZSBzaGFkZXJzLlxyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCB2ZXJ0ZXhTaGFkZXIpO1xyXG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgLy8gbGluayB0aGUgcHJvZ3JhbS5cclxuICAgICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcclxuICAgICAgICBjb25zdCBzdWNjZXNzID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyk7XHJcbiAgICAgICAgaWYgKCFzdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBDb3VsZCBub3QgbGluayB0aGUgcHJvZ3JhbTogWyR7Z2wuZ2V0UHJvZ3JhbUluZm9Mb2cocHJvZ3JhbSl9XWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcclxuICAgIH1cclxuICAgIF9jb21waWxlU2hhZGVyKGdsLCBzb3VyY2UsIHR5cGUpIHtcclxuICAgICAgICBjb25zdCBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIodHlwZSk7XHJcbiAgICAgICAgaWYgKHNoYWRlciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgQ291bGQgbm90IGJ1aWxkIHNoYWRlcjogWyR7c291cmNlfV1gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcclxuICAgICAgICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XHJcbiAgICAgICAgY29uc3Qgc3VjY2VzcyA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcclxuICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENvdWxkIG5vdCBjb21waWxlIHNoYWRlciBbJHtnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcil9XWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb21waWxlIHRoZSBjdXJyZW50IHNoYWRlciBhZ2FpbnN0IGEgd2ViZ2wgY29udGV4dFxyXG4gICAgICogQHBhcmFtIGdsIFdlYkdMIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgY29tcGlsZShnbCkge1xyXG4gICAgICAgIGNvbnN0IHZlcnRleFNoYWRlciA9IHRoaXMuX2NvbXBpbGVTaGFkZXIoZ2wsIHRoaXMuX3ZlcnRleFNvdXJjZSwgZ2wuVkVSVEVYX1NIQURFUik7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLl9jb21waWxlU2hhZGVyKGdsLCB0aGlzLl9mcmFnbWVudFNvdXJjZSwgZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgICAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5fY3JlYXRlUHJvZ3JhbShnbCwgdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcik7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnByb2dyYW0gPSBwcm9ncmFtKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdW5pZm9ybSBbW01hdHJpeF1dIHRvIHRoZSBzaGFkZXJcclxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0gaW4gdGhlIHNoYWRlciBzb3VyY2VcclxuICAgICAqIEBwYXJhbSBkYXRhICg0eDQpIG1hdHJpeCBpbiBjb2x1bW4gbWFqb3Igb3JkZXJcclxuICAgICAqL1xyXG4gICAgYWRkVW5pZm9ybU1hdHJpeChuYW1lLCBkYXRhKSB7XHJcbiAgICAgICAgaWYgKCFkYXRhKSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBTaGFkZXIgVW5pZm9ybSBNYXRyaXggJyR7bmFtZX0nIHdhcyBzZXQgdG8gbnVsbCBvciB1bmRlZmluZWRgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICB0aGlzLnVuaWZvcm1zW25hbWVdID0ge1xyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICB0eXBlOiAnbWF0cml4JyxcclxuICAgICAgICAgICAgbG9jYXRpb246IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpLFxyXG4gICAgICAgICAgICBkYXRhOiBkYXRhXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGEgdW5pZm9ybSBhcnJheSBvZiBudW1iZXJzIHRvIHRoZSBzaGFkZXJcclxuICAgICAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIHVuaWZvcm0gaW4gdGhlIHNoYWRlciBzb3VyY2VcclxuICAgICAqIEBwYXJhbSBkYXRhIExpc3Qgb2YgbnVtYmVyc1xyXG4gICAgICovXHJcbiAgICBhZGRVbmlmb3JtSW50ZWdlckFycmF5KG5hbWUsIGRhdGEpIHtcclxuICAgICAgICBpZiAoIWRhdGEpIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3IoYFNoYWRlciBVbmlmb3JtIEludGVnZXJ5IEFycmF5ICcke25hbWV9JyB3YXMgc2V0IHRvIG51bGwgb3IgdW5kZWZpbmVkYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fZ2w7XHJcbiAgICAgICAgdGhpcy51bmlmb3Jtc1tuYW1lXSA9IHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgdHlwZTogJ251bWJlcnMnLFxyXG4gICAgICAgICAgICBsb2NhdGlvbjogZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHRoaXMucHJvZ3JhbSwgbmFtZSksXHJcbiAgICAgICAgICAgIGRhdGE6IGRhdGFcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYXR0cmlidXRlcyBpbiB0aGUgb3JkZXIgdGhleSBhcHBlYXIgaW4gdGhlIFZCT1xyXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgYXR0cmlidXRlIGluIHRoZSBzaGFkZXIgc291cmNlXHJcbiAgICAgKiBAcGFyYW0gc2l6ZSBUaGUgc2l6ZSBvZiB0aGUgYXR0cmlidXRlIGluIGdsLlR5cGUgdW5pdHMsIGZvciBleGFtcGxlIGB2ZWMyIGFfcG9zYCB3b3VsZCBiZSAyIGdsLkZMT0FUXHJcbiAgICAgKiBAcGFyYW0gZ2xUeXBlIFRoZSBnbC5UeXBlIG9mIHRoZSBhdHRyaWJ1dGVcclxuICAgICAqL1xyXG4gICAgYWRkQXR0cmlidXRlKG5hbWUsIHNpemUsIGdsVHlwZSwgbm9ybWFsaXplZCA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICAvLyBUT0RPIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGZpcnN0XHJcbiAgICAgICAgY29uc3QgbG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbih0aGlzLnByb2dyYW0sIG5hbWUpO1xyXG4gICAgICAgIHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IHtcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgc2l6ZSxcclxuICAgICAgICAgICAgZ2xUeXBlLFxyXG4gICAgICAgICAgICBub3JtYWxpemVkLFxyXG4gICAgICAgICAgICBsb2NhdGlvblxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5sYXlvdXQucHVzaCh0aGlzLmF0dHJpYnV0ZXNbbmFtZV0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOdW1iZXIgb2YgamF2YXNjcmlwdCBmbG9hdHMgYSB2ZXJ0ZXggd2lsbCB0YWtlIHVwXHJcbiAgICAgKi9cclxuICAgIGdldCB2ZXJ0ZXhBdHRyaWJ1dGVTaXplKCkge1xyXG4gICAgICAgIGxldCB2ZXJ0ZXhTaXplID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IHZlcnQgb2YgdGhpcy5sYXlvdXQpIHtcclxuICAgICAgICAgICAgdmVydGV4U2l6ZSArPSB2ZXJ0LnNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2ZXJ0ZXhTaXplO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUb3RhbCBudW1iZXIgb2YgYnl0ZXMgdGhhdCB0aGUgdmVydGV4IHdpbGwgdGFrZSB1cFxyXG4gICAgICovXHJcbiAgICBnZXQgdG90YWxWZXJ0ZXhTaXplQnl0ZXMoKSB7XHJcbiAgICAgICAgbGV0IHZlcnRleFNpemUgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgdmVydCBvZiB0aGlzLmxheW91dCkge1xyXG4gICAgICAgICAgICBsZXQgdHlwZVNpemUgPSAxO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHZlcnQuZ2xUeXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIHRoaXMuX2dsLkZMT0FUOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZVNpemUgPSA0O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVTaXplID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2ZXJ0ZXhTaXplICs9IHR5cGVTaXplICogdmVydC5zaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdmVydGV4U2l6ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgcHJldmlvdXNseSBkZWZpbmVkIGF0dHJpYnV0ZSBzaXplIGluIGJ5dGVzXHJcbiAgICAgKiBAcGFyYW0gbmFtZVxyXG4gICAgICovXHJcbiAgICBnZXRBdHRyaWJ1dGVTaXplKG5hbWUpIHtcclxuICAgICAgICBsZXQgdHlwZVNpemUgPSAxO1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5hdHRyaWJ1dGVzW25hbWVdLmdsVHlwZSkge1xyXG4gICAgICAgICAgICBjYXNlIHRoaXMuX2dsLkZMT0FUOiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlU2l6ZSA9IDQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkZWZhdWx0OiB7XHJcbiAgICAgICAgICAgICAgICB0eXBlU2l6ZSA9IDE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHR5cGVTaXplICogdGhpcy5hdHRyaWJ1dGVzW25hbWVdLnNpemU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhpcyBzaGFkZXIgcHJvZ3JhbSBhcyB0aGUgY3VycmVudCBpbiB0aGUgdW5kZXJseWluZyB3ZWJnbCBjb250ZXh0XHJcbiAgICAgKlxyXG4gICAgICogKipNdXN0Kiogc3BlY2lmeSBhbGwgYXR0cmlidXRlcyBhbmQgdW5pZm9ybXMgYmVmb3JlIGNhbGxpbmcgdGhpc1xyXG4gICAgICovXHJcbiAgICB1c2UoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbSk7XHJcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCB2ZXJ0IG9mIHRoaXMubGF5b3V0KSB7XHJcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIodmVydC5sb2NhdGlvbiwgdmVydC5zaXplLCB2ZXJ0LmdsVHlwZSwgdmVydC5ub3JtYWxpemVkLCB0aGlzLnRvdGFsVmVydGV4U2l6ZUJ5dGVzLCBvZmZzZXQpO1xyXG4gICAgICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh2ZXJ0LmxvY2F0aW9uKTtcclxuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuZ2V0QXR0cmlidXRlU2l6ZSh2ZXJ0Lm5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnVuaWZvcm1zKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHVuaWZvcm0gPSB0aGlzLnVuaWZvcm1zW2tleV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAodW5pZm9ybS50eXBlKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdtYXRyaXgnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdih1bmlmb3JtLmxvY2F0aW9uLCBmYWxzZSwgdW5pZm9ybS5kYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhc2UgJ251bWJlcnMnOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ2wudW5pZm9ybTFpdih1bmlmb3JtLmxvY2F0aW9uLCB1bmlmb3JtLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9zaGFkZXJzL2xpbmUtdmVydGV4Lmdsc2xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgbGluZV92ZXJ0ZXggPSAoXCJhdHRyaWJ1dGUgdmVjNCBhX3Bvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxyXFxuXFxyXFxudmFyeWluZyBsb3dwIHZlYzQgdl9jb2xvcjtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDQgdV9tYXRyaXg7XFxyXFxuXFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgIC8vIFNldCB0aGUgdmVydGV4IHBvc2l0aW9uIHVzaW5nIHRoZSBvcnRobyB0cmFuc2Zvcm0gbWF0cml4XFxyXFxuICAgZ2xfUG9zaXRpb24gPSB1X21hdHJpeCAqIGFfcG9zaXRpb247XFxyXFxuXFxyXFxuICAgLy8gUGFzc3Rocm91Z2ggdGhlIGNvbG9yXFxyXFxuICAgdl9jb2xvciA9IGFfY29sb3I7XFxyXFxufVwiKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvc2hhZGVycy9saW5lLWZyYWdtZW50Lmdsc2xcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgbGluZV9mcmFnbWVudCA9IChcInByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcblxcclxcbi8vIENvbG9yXFxyXFxudmFyeWluZyBsb3dwIHZlYzQgdl9jb2xvcjtcXHJcXG5cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xcclxcbn1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2JhdGNoLnRzXG5jbGFzcyBCYXRjaENvbW1hbmQge1xyXG4gICAgY29uc3RydWN0b3IobWF4KSB7XHJcbiAgICAgICAgdGhpcy5tYXggPSBtYXg7XHJcbiAgICAgICAgdGhpcy5fcG9vbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLmNvbW1hbmRzID0gW107XHJcbiAgICB9XHJcbiAgICBpc0Z1bGwoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tbWFuZHMubGVuZ3RoID49IHRoaXMubWF4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjYW5BZGQoKSB7XHJcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRnVsbCgpO1xyXG4gICAgfVxyXG4gICAgYWRkKGNtZCkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZHMucHVzaChjbWQpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9HcmFwaGljc0RpYWdub3N0aWNzLnRzXG5jbGFzcyBHcmFwaGljc0RpYWdub3N0aWNzIHtcclxuICAgIHN0YXRpYyBjbGVhcigpIHtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXdDYWxsQ291bnQgPSAwO1xyXG4gICAgICAgIEdyYXBoaWNzRGlhZ25vc3RpY3MuRHJhd25JbWFnZXNDb3VudCA9IDA7XHJcbiAgICB9XHJcbn1cclxuR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3Q2FsbENvdW50ID0gMDtcclxuR3JhcGhpY3NEaWFnbm9zdGljcy5EcmF3bkltYWdlc0NvdW50ID0gMDtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL1Bvb2wudHNcblxyXG5jbGFzcyBQb29sIHtcclxuICAgIGNvbnN0cnVjdG9yKGJ1aWxkZXIsIHJlY3ljbGVyLCBtYXhPYmplY3RzID0gMTAwKSB7XHJcbiAgICAgICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcclxuICAgICAgICB0aGlzLnJlY3ljbGVyID0gcmVjeWNsZXI7XHJcbiAgICAgICAgdGhpcy5tYXhPYmplY3RzID0gbWF4T2JqZWN0cztcclxuICAgICAgICB0aGlzLnRvdGFsQWxsb2NhdGlvbnMgPSAwO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMub2JqZWN0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgbWFueSBpbnN0YW5jZXMgb3V0IG9mIHRoZSBpbiB0aGUgY29udGV4dCBhbmQgcmV0dXJuIGFsbCB0byB0aGUgcG9vbC5cclxuICAgICAqXHJcbiAgICAgKiBCeSByZXR1cm5pbmcgdmFsdWVzIG91dCBvZiB0aGUgY29udGV4IHRoZXkgd2lsbCBiZSB1bi1ob29rZWQgZnJvbSB0aGUgcG9vbCBhbmQgYXJlIGZyZWUgdG8gYmUgcGFzc2VkIHRvIGNvbnN1bWVyc1xyXG4gICAgICogQHBhcmFtIGNvbnRleHRcclxuICAgICAqL1xyXG4gICAgdXNpbmcoY29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGNvbnRleHQodGhpcyk7XHJcbiAgICAgICAgaWYgKHJlc3VsdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb25lKC4uLnJlc3VsdCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmRvbmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXNlIGEgc2luZ2xlIGluc3RhbmNlIG91dCBvZiB0aCBwb29sIGFuZCBpbW1lZGlhdGVseSByZXR1cm4gaXQgdG8gdGhlIHBvb2xcclxuICAgICAqIEBwYXJhbSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIGJvcnJvdyhjb250ZXh0KSB7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5nZXQoKTtcclxuICAgICAgICBjb250ZXh0KG9iamVjdCk7XHJcbiAgICAgICAgdGhpcy5pbmRleC0tO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBhIHZhbHVlIGZyb20gdGhlIHBvb2wsIHdpbGwgYWxsb2NhdGUgYSBuZXcgaW5zdGFuY2UgaWYgbmVjZXNzYXJ5IG9yIHJlY3ljbGUgZnJvbSB0aGUgcG9vbFxyXG4gICAgICogQHBhcmFtIGFyZ3NcclxuICAgICAqL1xyXG4gICAgZ2V0KC4uLmFyZ3MpIHtcclxuICAgICAgICBpZiAodGhpcy5pbmRleCA9PT0gdGhpcy5tYXhPYmplY3RzKSB7XHJcbiAgICAgICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IGhhcmQgb3Igc29mdCBjYXBcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oJ01heCBwb29sZWQgb2JqZWN0cyByZWFjaGVkLCBwb3NzaWJsZSBtZW1vcnkgbGVhaz8gRG91YmxpbmcnKTtcclxuICAgICAgICAgICAgdGhpcy5tYXhPYmplY3RzID0gdGhpcy5tYXhPYmplY3RzICogMjtcclxuICAgICAgICAgICAgLy8gdGhyb3cgbmV3IEVycm9yKCdNYXggcG9vbGVkIG9iamVjdHMgcmVhY2hlZCwgcG9zc2libGUgbWVtb3J5IGxlYWs/Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm9iamVjdHNbdGhpcy5pbmRleF0pIHtcclxuICAgICAgICAgICAgLy8gUG9vbCBoYXMgYW4gYXZhaWxhYmxlIG9iamVjdCBhbHJlYWR5IGNvbnN0cnVjdGVkXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlY3ljbGVyKHRoaXMub2JqZWN0c1t0aGlzLmluZGV4KytdLCAuLi5hcmdzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE5ldyBhbGxvY2F0aW9uXHJcbiAgICAgICAgICAgIHRoaXMudG90YWxBbGxvY2F0aW9ucysrO1xyXG4gICAgICAgICAgICBjb25zdCBvYmplY3QgPSAodGhpcy5vYmplY3RzW3RoaXMuaW5kZXgrK10gPSB0aGlzLmJ1aWxkZXIoLi4uYXJncykpO1xyXG4gICAgICAgICAgICBvYmplY3QuX3Bvb2wgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRvbmUoLi4ub2JqZWN0cykge1xyXG4gICAgICAgIC8vIEFsbCBvYmplY3RzIGluIHBvb2wgbm93IGNvbnNpZGVyZWQgXCJmcmVlXCJcclxuICAgICAgICB0aGlzLmluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IG9iamVjdCBvZiBvYmplY3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvb2xJbmRleCA9IHRoaXMub2JqZWN0cy5pbmRleE9mKG9iamVjdCk7XHJcbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgbmV3IG9iamVjdCB0byB0YWtlIHRoZSBwb29sIHBsYWNlXHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0c1twb29sSW5kZXhdID0gdGhpcy5idWlsZGVyKCk7IC8vIFRPRE8gcHJvYmxlbWF0aWMgMC1hcmcgb25seSBzdXBwb3J0XHJcbiAgICAgICAgICAgIHRoaXMub2JqZWN0c1twb29sSW5kZXhdLl9wb29sID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy50b3RhbEFsbG9jYXRpb25zKys7XHJcbiAgICAgICAgICAgIC8vIFVuaG9vayBvYmplY3QgZnJvbSB0aGUgcG9vbFxyXG4gICAgICAgICAgICBvYmplY3QuX3Bvb2wgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvYmplY3RzO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9yZW5kZXJlci50c1xuXHJcbi8vIGltcG9ydCB7IFBvb2wsIFBvb2xhYmxlIH0gZnJvbSAnLi9wb29sJztcclxuXHJcblxyXG5jbGFzcyBCYXRjaFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gMDtcclxuICAgICAgICB0aGlzLl9idWZmZXIgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX21heENvbW1hbmRzUGVyQmF0Y2ggPSAyMDAwO1xyXG4gICAgICAgIHRoaXMuX2JhdGNoZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9nbCA9IG9wdGlvbnMuZ2w7XHJcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IG9wdGlvbnMuY29tbWFuZDtcclxuICAgICAgICB0aGlzLl92ZXJ0aWNlc1BlckNvbW1hbmQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudmVydGljZXNQZXJDb21tYW5kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxO1xyXG4gICAgICAgIHRoaXMuX21heENvbW1hbmRzUGVyQmF0Y2ggPSAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4Q29tbWFuZHNQZXJCYXRjaCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5fbWF4Q29tbWFuZHNQZXJCYXRjaDtcclxuICAgICAgICBjb25zdCBiYXRjaEZhY3RvcnkgPSAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYmF0Y2hGYWN0b3J5KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoKCkgPT4gbmV3IEJhdGNoQ29tbWFuZCh0aGlzLl9tYXhDb21tYW5kc1BlckJhdGNoKSk7XHJcbiAgICAgICAgdGhpcy5jb21tYW5kcyA9IG5ldyBQb29sKCgpID0+IG5ldyBjb21tYW5kKCksIChjKSA9PiBjLmRpc3Bvc2UoKSwgdGhpcy5fbWF4Q29tbWFuZHNQZXJCYXRjaCk7XHJcbiAgICAgICAgdGhpcy5fYmF0Y2hQb29sID0gbmV3IFBvb2woYmF0Y2hGYWN0b3J5LCAoYikgPT4gYi5kaXNwb3NlKCksIDEwMCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemUgcmVuZGVyLCBidWlsZHMgc2hhZGVyIGFuZCBpbml0aWFsaXplZCB3ZWJnbCBidWZmZXJzXHJcbiAgICAgKi9cclxuICAgIGluaXQoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICB0aGlzLnNoYWRlciA9IHRoaXMuYnVpbGRTaGFkZXIoZ2wpO1xyXG4gICAgICAgIC8vIEluaXRpYWxpemUgVkJPXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9mb3J1bS8jIXRvcGljL3dlYmdsLWRldi1saXN0L3ZNTlhTTlJBZzhNXHJcbiAgICAgICAgdGhpcy5fdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuc2hhZGVyLnZlcnRleEF0dHJpYnV0ZVNpemUgKiB0aGlzLl92ZXJ0aWNlc1BlckNvbW1hbmQgKiB0aGlzLl9tYXhDb21tYW5kc1BlckJhdGNoKTtcclxuICAgICAgICB0aGlzLl9idWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5fYnVmZmVyKTtcclxuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5fdmVydGljZXMsIGdsLkRZTkFNSUNfRFJBVyk7XHJcbiAgICB9XHJcbiAgICBnZXQgdmVydGV4U2l6ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zaGFkZXIudmVydGV4QXR0cmlidXRlU2l6ZTtcclxuICAgIH1cclxuICAgIGFkZENvbW1hbmQoY21kKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2JhdGNoZXMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2JhdGNoZXMucHVzaCh0aGlzLl9iYXRjaFBvb2wuZ2V0KCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsYXN0QmF0Y2ggPSB0aGlzLl9iYXRjaGVzW3RoaXMuX2JhdGNoZXMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgaWYgKGxhc3RCYXRjaC5jYW5BZGQoKSkge1xyXG4gICAgICAgICAgICBsYXN0QmF0Y2guYWRkKGNtZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdCYXRjaCA9IHRoaXMuX2JhdGNoUG9vbC5nZXQoKTtcclxuICAgICAgICAgICAgbmV3QmF0Y2guYWRkKGNtZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JhdGNoZXMucHVzaChuZXdCYXRjaCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCBiYXRjaCBnZW9tZXRyeSwgc3VibWl0IHRvIHRoZSBncHUsIGFuZCBpc3N1ZSBkcmF3IGNvbW1hbmQgdG8gdW5kZXJseWluZyB3ZWJnbFxyXG4gICAgICovXHJcbiAgICByZW5kZXIoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9nbDtcclxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5fYnVmZmVyKTtcclxuICAgICAgICB0aGlzLnNoYWRlci51c2UoKTtcclxuICAgICAgICBsZXQgZHJhd0NhbGxDb3VudCA9IDA7XHJcbiAgICAgICAgbGV0IGRyYXduSW1hZ2VzQ291bnQgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgYmF0Y2ggb2YgdGhpcy5fYmF0Y2hlcykge1xyXG4gICAgICAgICAgICAvLyBCdWlsZCBhbGwgZ2VvbWV0cnkgYW5kIHNoaXAgdG8gR1BVXHJcbiAgICAgICAgICAgIC8vIGludGVybGVhdmUgVkJPcyBodHRwczovL2dvaGFyc2hhLmNvbS9sd2pnbC10dXRvcmlhbC1zZXJpZXMvaW50ZXJsZWF2aW5nLWJ1ZmZlci1vYmplY3RzL1xyXG4gICAgICAgICAgICBjb25zdCB2ZXJ0ZXhDb3VudCA9IHRoaXMuYnVpbGRCYXRjaFZlcnRpY2VzKHRoaXMuX3ZlcnRpY2VzLCBiYXRjaCk7XHJcbiAgICAgICAgICAgIGdsLmJ1ZmZlclN1YkRhdGEoZ2wuQVJSQVlfQlVGRkVSLCAwLCB0aGlzLl92ZXJ0aWNlcyk7XHJcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQmF0Y2goZ2wsIGJhdGNoLCB2ZXJ0ZXhDb3VudCk7XHJcbiAgICAgICAgICAgIGRyYXduSW1hZ2VzQ291bnQgKz0gYmF0Y2guY29tbWFuZHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBkcmF3Q2FsbENvdW50Kys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29tbWFuZHMuZG9uZSgpO1xyXG4gICAgICAgIHRoaXMuX2JhdGNoUG9vbC5kb25lKCk7XHJcbiAgICAgICAgdGhpcy5fYmF0Y2hlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIEdyYXBoaWNzRGlhZ25vc3RpY3MuRHJhd0NhbGxDb3VudCArPSBkcmF3Q2FsbENvdW50O1xyXG4gICAgICAgIEdyYXBoaWNzRGlhZ25vc3RpY3MuRHJhd25JbWFnZXNDb3VudCArPSBkcmF3bkltYWdlc0NvdW50O1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9saW5lLXJlbmRlcmVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBEcmF3TGluZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmNvbG9yID0gQ29sb3IuQmxhY2s7XHJcbiAgICAgICAgdGhpcy5zdGFydCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIHRoaXMuZW5kID0gVmVjdG9yLlplcm87XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICAgIHRoaXMuY29sb3IuciA9IDA7XHJcbiAgICAgICAgdGhpcy5jb2xvci5nID0gMDtcclxuICAgICAgICB0aGlzLmNvbG9yLmIgPSAwO1xyXG4gICAgICAgIHRoaXMuY29sb3IuYSA9IDE7XHJcbiAgICAgICAgdGhpcy5zdGFydC5zZXRUbygwLCAwKTtcclxuICAgICAgICB0aGlzLmVuZC5zZXRUbygwLCAwKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG5jbGFzcyBMaW5lUmVuZGVyZXIgZXh0ZW5kcyBCYXRjaFJlbmRlcmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGdsLCBfY29udGV4dEluZm8pIHtcclxuICAgICAgICBzdXBlcih7IGdsLCBjb21tYW5kOiBEcmF3TGluZSwgdmVydGljZXNQZXJDb21tYW5kOiAyIH0pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHRJbmZvID0gX2NvbnRleHRJbmZvO1xyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgfVxyXG4gICAgYnVpbGRTaGFkZXIoZ2wpIHtcclxuICAgICAgICBjb25zdCBzaGFkZXIgPSBuZXcgU2hhZGVyKGdsLCBsaW5lX3ZlcnRleCwgbGluZV9mcmFnbWVudCk7XHJcbiAgICAgICAgc2hhZGVyLmFkZEF0dHJpYnV0ZSgnYV9wb3NpdGlvbicsIDIsIGdsLkZMT0FUKTtcclxuICAgICAgICBzaGFkZXIuYWRkQXR0cmlidXRlKCdhX2NvbG9yJywgNCwgZ2wuRkxPQVQpO1xyXG4gICAgICAgIHNoYWRlci5hZGRVbmlmb3JtTWF0cml4KCd1X21hdHJpeCcsIHRoaXMuX2NvbnRleHRJbmZvLm1hdHJpeC5kYXRhKTtcclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfVxyXG4gICAgYWRkTGluZShzdGFydCwgZW5kLCBjb2xvcikge1xyXG4gICAgICAgIGNvbnN0IGNtZCA9IHRoaXMuY29tbWFuZHMuZ2V0KCk7XHJcbiAgICAgICAgY21kLnN0YXJ0ID0gdGhpcy5fY29udGV4dEluZm8udHJhbnNmb3JtLmN1cnJlbnQubXVsdHYoc3RhcnQpO1xyXG4gICAgICAgIGNtZC5lbmQgPSB0aGlzLl9jb250ZXh0SW5mby50cmFuc2Zvcm0uY3VycmVudC5tdWx0dihlbmQpO1xyXG4gICAgICAgIGNtZC5jb2xvci5yID0gY29sb3IucjtcclxuICAgICAgICBjbWQuY29sb3IuZyA9IGNvbG9yLmc7XHJcbiAgICAgICAgY21kLmNvbG9yLmIgPSBjb2xvci5iO1xyXG4gICAgICAgIGNtZC5jb2xvci5hID0gY21kLmNvbG9yLmEgKiB0aGlzLl9jb250ZXh0SW5mby5zdGF0ZS5jdXJyZW50Lm9wYWNpdHk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKGNtZCk7XHJcbiAgICB9XHJcbiAgICBidWlsZEJhdGNoVmVydGljZXModmVydGV4QnVmZmVyLCBiYXRjaCkge1xyXG4gICAgICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb21tYW5kIG9mIGJhdGNoLmNvbW1hbmRzKSB7XHJcbiAgICAgICAgICAgIC8vIFN0YXJ0XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcltpbmRleCsrXSA9IGNvbW1hbmQuc3RhcnQueDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5zdGFydC55O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLmNvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcltpbmRleCsrXSA9IGNvbW1hbmQuY29sb3IuZyAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5jb2xvci5iIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLmNvbG9yLmE7XHJcbiAgICAgICAgICAgIC8vIEVuZFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLmVuZC54O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLmVuZC55O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLmNvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcltpbmRleCsrXSA9IGNvbW1hbmQuY29sb3IuZyAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5jb2xvci5iIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLmNvbG9yLmE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbmRleCAvIHRoaXMudmVydGV4U2l6ZTtcclxuICAgIH1cclxuICAgIHJlbmRlckJhdGNoKGdsLCBfYmF0Y2gsIHZlcnRleENvdW50KSB7XHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5MSU5FUywgMCwgdmVydGV4Q291bnQpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ29udGV4dC9zaGFkZXJzL2ltYWdlLXZlcnRleC5nbHNsXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGltYWdlX3ZlcnRleCA9IChcImF0dHJpYnV0ZSB2ZWM0IGFfcG9zaXRpb247XFxyXFxuXFxyXFxuLy8gT3BhY2l0eSBcXHJcXG5hdHRyaWJ1dGUgZmxvYXQgYV9vcGFjaXR5O1xcclxcbnZhcnlpbmcgZmxvYXQgdl9vcGFjaXR5O1xcclxcblxcclxcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxyXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxyXFxuXFxyXFxuLy8gVVYgY29vcmRpbmF0ZVxcclxcbmF0dHJpYnV0ZSB2ZWMyIGFfdGV4Y29vcmQ7XFxyXFxudmFyeWluZyB2ZWMyIHZfdGV4Y29vcmQ7XFxyXFxuXFxyXFxuLy8gVGV4dHVyZSBudW1iZXJcXHJcXG5hdHRyaWJ1dGUgbG93cCBmbG9hdCBhX3RleHR1cmVJbmRleDtcXHJcXG52YXJ5aW5nIGxvd3AgZmxvYXQgdl90ZXh0dXJlSW5kZXg7XFxyXFxuXFxyXFxudW5pZm9ybSBtYXQ0IHVfbWF0cml4O1xcclxcblxcclxcblxcclxcbnZvaWQgbWFpbigpIHtcXHJcXG4gICAvLyBTZXQgdGhlIHZlcnRleCBwb3NpdGlvbiB1c2luZyB0aGUgb3J0aG8gdHJhbnNmb3JtIG1hdHJpeFxcclxcbiAgIGdsX1Bvc2l0aW9uID0gdV9tYXRyaXggKiBhX3Bvc2l0aW9uO1xcclxcblxcclxcbiAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgT3BhY2l0eSB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXFxyXFxuICAgdl9vcGFjaXR5ID0gYV9vcGFjaXR5O1xcclxcbiAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgVVYgY29vcmQgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxcclxcbiAgIHZfdGV4Y29vcmQgPSBhX3RleGNvb3JkO1xcclxcbiAgIC8vIFBhc3MgdGhyb3VnaCB0aGUgdGV4dHVyZSBudW1iZXIgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxcclxcbiAgIHZfdGV4dHVyZUluZGV4ID0gYV90ZXh0dXJlSW5kZXg7XFxyXFxuICAgLy8gUGFzcyB0aHJvdWdoIHRoZSBjb2xvciB0byB0aGUgZnJhZ21lbnQgc2hhZGVyXFxyXFxuICAgdl9jb2xvciA9IGFfY29sb3I7XFxyXFxufVwiKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvc2hhZGVycy9pbWFnZS1mcmFnbWVudC5nbHNsXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IGltYWdlX2ZyYWdtZW50ID0gKFwiI2lmZGVmIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlc1xcclxcbiNleHRlbnNpb24gR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzIDogZW5hYmxlXFxyXFxuI2VuZGlmXFxyXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxyXFxuXFxyXFxuLy8gVVYgY29vcmRcXHJcXG52YXJ5aW5nIHZlYzIgdl90ZXhjb29yZDtcXHJcXG5cXHJcXG4vLyBUZXh0dXJlIGluZGV4XFxyXFxudmFyeWluZyBsb3dwIGZsb2F0IHZfdGV4dHVyZUluZGV4O1xcclxcblxcclxcbi8vIENvbG9yIGNvb3JkIHRvIGJsZW5kIHdpdGggaW1hZ2VcXHJcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcclxcblxcclxcbi8vIE9wYWNpdHlcXHJcXG52YXJ5aW5nIGZsb2F0IHZfb3BhY2l0eTtcXHJcXG5cXHJcXG51bmlmb3JtIHNhbXBsZXIyRCB1X3RleHR1cmVzWyUlY291bnQlJV07XFxyXFxuXFxyXFxuZmxvYXQgY2lyY2xlKGluIHZlYzIgc3QsIGluIGZsb2F0IHJhZGl1cykge1xcclxcbiAgdmVjMiBkaXN0ID0gc3QgLSB2ZWMyKDAuNSk7XFxyXFxuICBmbG9hdCByID0gZG90KGRpc3QsIGRpc3QpICogNC4wO1xcclxcbiAgZmxvYXQgZGVsdGEgPSBmd2lkdGgocik7XFxyXFxuICByZXR1cm4gMS4wIC0gc21vb3Roc3RlcChyYWRpdXMgLSBkZWx0YSwgcmFkaXVzICsgZGVsdGEsIHIpO1xcclxcbn1cXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICBmbG9hdCByID0gMC4wLCBkZWx0YSA9IDAuMCwgYWxwaGEgPSAxLjA7XFxyXFxuICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCB0aGUgbW9zdCBlZmZpY2llbnQgc3ByaXRlIGJhdGNoaW5nLCB3ZSBoYXZlIG11bHRpcGxlXFxyXFxuICAgLy8gdGV4dHVyZXMgbG9hZGVkIGludG8gdGhlIGdwdSAodXN1YWxseSA4KSB0aGlzIHBpY2tlciBsb2dpYyBza2lwcyBvdmVyIHRleHR1cmVzXFxyXFxuICAgLy8gdGhhdCBkbyBub3QgYXBwbHkgdG8gYSBwYXJ0aWN1bGFyIHNwcml0ZS5cXHJcXG5cXHJcXG4gICB2ZWM0IGNvbG9yO1xcclxcbiAgIC8vIC0xIElmIHRoZXJlIGlzIG5vIHRleHR1cmUgdG8gc2FtcGxlIHdlIGFyZSBkcmF3aW5nIGEgc29saWQgZ2VvbWV0cnkgKHJlY3RhbmdsZXMpXFxyXFxuICAgaWYgKHZfdGV4dHVyZUluZGV4ID09IC0xLjApIHtcXHJcXG4gICAgIGNvbG9yID0gdl9jb2xvcjtcXHJcXG4gICAgIGNvbG9yLncgPSBjb2xvci53ICogdl9vcGFjaXR5O1xcclxcbiAgIC8vIC0yIElmIHRoZXJlIGlzIG5vIHRleHR1cmUgd2UgYXJlIGRyYXdpbmcgYSBjaXJjbGVcXHJcXG4gICB9IGVsc2UgaWYgKHZfdGV4dHVyZUluZGV4ID09IC0yLjApIHtcXHJcXG4gICAgIGNvbG9yID0gdl9jb2xvcjtcXHJcXG4gICAgIGNvbG9yLmEgPSBjb2xvci5hICogY2lyY2xlKHZfdGV4Y29vcmQsIC45NSk7XFxyXFxuICAgfSBlbHNlIHtcXHJcXG4gICAgIC8vIEdMU0wgaXMgdGVtcGxhdGVkIG91dCB0byBwaWNrIHRoZSByaWdodCB0ZXh0dXJlIGFuZCBzZXQgdGhlIHZlYzQgY29sb3JcXHJcXG4gICAgICAlJXRleHR1cmVfcGlja2VyJSVcXHJcXG4gICB9XFxyXFxuICAgY29sb3IudyA9IGNvbG9yLncgKiB2X29wYWNpdHk7XFxyXFxuICAgZ2xfRnJhZ0NvbG9yID0gY29sb3I7XFxyXFxufVwiKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvZHJhdy1pbWFnZS1jb21tYW5kLnRzXG5cclxudmFyIERyYXdDb21tYW5kVHlwZTtcclxuKGZ1bmN0aW9uIChEcmF3Q29tbWFuZFR5cGUpIHtcclxuICAgIERyYXdDb21tYW5kVHlwZVtcIkltYWdlXCJdID0gXCJpbWFnZVwiO1xyXG4gICAgRHJhd0NvbW1hbmRUeXBlW1wiTGluZVwiXSA9IFwibGluZVwiO1xyXG4gICAgRHJhd0NvbW1hbmRUeXBlW1wiUmVjdGFuZ2xlXCJdID0gXCJyZWN0YW5nbGVcIjtcclxuICAgIERyYXdDb21tYW5kVHlwZVtcIkNpcmNsZVwiXSA9IFwiY2lyY2xlXCI7XHJcbn0pKERyYXdDb21tYW5kVHlwZSB8fCAoRHJhd0NvbW1hbmRUeXBlID0ge30pKTtcclxuY2xhc3MgRHJhd0ltYWdlQ29tbWFuZCB7XHJcbiAgICBjb25zdHJ1Y3RvcihpbWFnZSwgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQsIGR4LCBkeSwgZHdpZHRoLCBkaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5fcG9vbCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnNuYXBUb1BpeGVsID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLnR5cGUgPSBEcmF3Q29tbWFuZFR5cGUuSW1hZ2U7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcclxuICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy5kZXN0ID0gWzAsIDBdOyAvLyB4LCB5XHJcbiAgICAgICAgdGhpcy52aWV3ID0gWzAsIDAsIDAsIDBdOyAvLyBzeCwgc3ksIHN3LCBzaFxyXG4gICAgICAgIHRoaXMuX2dlb20gPSBbXHJcbiAgICAgICAgICAgIFswLCAwXSxcclxuICAgICAgICAgICAgWzAsIDBdLFxyXG4gICAgICAgICAgICBbMCwgMF0sXHJcbiAgICAgICAgICAgIFswLCAwXSxcclxuICAgICAgICAgICAgWzAsIDBdLFxyXG4gICAgICAgICAgICBbMCwgMF1cclxuICAgICAgICBdO1xyXG4gICAgICAgIHRoaXMuaW5pdChpbWFnZSwgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQsIGR4LCBkeSwgZHdpZHRoLCBkaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGluaXQoaW1hZ2UsIHN4LCBzeSwgc3dpZHRoLCBzaGVpZ2h0LCBkeCwgZHksIGR3aWR0aCwgZGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IERyYXdDb21tYW5kVHlwZS5JbWFnZTtcclxuICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IChpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2Uud2lkdGgpIHx8IHN3aWR0aCB8fCAwO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gKGltYWdlID09PSBudWxsIHx8IGltYWdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbWFnZS5oZWlnaHQpIHx8IHNoZWlnaHQgfHwgMDtcclxuICAgICAgICB0aGlzLnZpZXcgPSBbMCwgMCwgc3dpZHRoICE9PSBudWxsICYmIHN3aWR0aCAhPT0gdm9pZCAwID8gc3dpZHRoIDogaW1hZ2UgPT09IG51bGwgfHwgaW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGltYWdlLndpZHRoLCBzaGVpZ2h0ICE9PSBudWxsICYmIHNoZWlnaHQgIT09IHZvaWQgMCA/IHNoZWlnaHQgOiBpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2UuaGVpZ2h0XTtcclxuICAgICAgICB0aGlzLmRlc3QgPSBbc3gsIHN5XTtcclxuICAgICAgICAvLyBJZiBkZXN0aW5hdGlvbiBpcyBzcGVjaWZpZWQsIHVwZGF0ZSB2aWV3IGFuZCBkZXN0XHJcbiAgICAgICAgaWYgKGR4ICE9PSB1bmRlZmluZWQgJiYgZHkgIT09IHVuZGVmaW5lZCAmJiBkd2lkdGggIT09IHVuZGVmaW5lZCAmJiBkaGVpZ2h0ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy52aWV3ID0gW3N4LCBzeSwgc3dpZHRoICE9PSBudWxsICYmIHN3aWR0aCAhPT0gdm9pZCAwID8gc3dpZHRoIDogaW1hZ2UgPT09IG51bGwgfHwgaW1hZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGltYWdlLndpZHRoLCBzaGVpZ2h0ICE9PSBudWxsICYmIHNoZWlnaHQgIT09IHZvaWQgMCA/IHNoZWlnaHQgOiBpbWFnZSA9PT0gbnVsbCB8fCBpbWFnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW1hZ2UuaGVpZ2h0XTtcclxuICAgICAgICAgICAgdGhpcy5kZXN0ID0gW2R4LCBkeV07XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBkd2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gZGhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RoaXMuZGVzdFswXSwgdGhpcy5kZXN0WzFdXTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RoaXMuZGVzdFswXSwgdGhpcy5kZXN0WzFdICsgdGhpcy5oZWlnaHRdO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbdGhpcy5kZXN0WzBdICsgdGhpcy53aWR0aCwgdGhpcy5kZXN0WzFdXTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RoaXMuZGVzdFswXSArIHRoaXMud2lkdGgsIHRoaXMuZGVzdFsxXV07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0aGlzLmRlc3RbMF0sIHRoaXMuZGVzdFsxXSArIHRoaXMuaGVpZ2h0XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RoaXMuZGVzdFswXSArIHRoaXMud2lkdGgsIHRoaXMuZGVzdFsxXSArIHRoaXMuaGVpZ2h0XTtcclxuICAgICAgICBpZiAodGhpcy5zbmFwVG9QaXhlbCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHRoaXMuX2dlb20pIHtcclxuICAgICAgICAgICAgICAgIHBvaW50WzBdID0gfn5wb2ludFswXTtcclxuICAgICAgICAgICAgICAgIHBvaW50WzFdID0gfn5wb2ludFsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGluaXRSZWN0KGNvbG9yLCBzdGFydCwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IERyYXdDb21tYW5kVHlwZS5SZWN0YW5nbGU7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICBsZXQgaW5kZXggPSAwO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbc3RhcnQueCwgc3RhcnQueV07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFtzdGFydC54LCBzdGFydC55ICsgdGhpcy5oZWlnaHRdO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbc3RhcnQueCArIHRoaXMud2lkdGgsIHN0YXJ0LnldO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbc3RhcnQueCArIHRoaXMud2lkdGgsIHN0YXJ0LnldO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbc3RhcnQueCwgc3RhcnQueSArIHRoaXMuaGVpZ2h0XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3N0YXJ0LnggKyB0aGlzLndpZHRoLCBzdGFydC55ICsgdGhpcy5oZWlnaHRdO1xyXG4gICAgICAgIGlmICh0aGlzLnNuYXBUb1BpeGVsKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgdGhpcy5fZ2VvbSkge1xyXG4gICAgICAgICAgICAgICAgcG9pbnRbMF0gPSB+fnBvaW50WzBdO1xyXG4gICAgICAgICAgICAgICAgcG9pbnRbMV0gPSB+fnBvaW50WzFdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgaW5pdExpbmUoY29sb3IsIHN0YXJ0LCBlbmQsIHRoaWNrbmVzcykge1xyXG4gICAgICAgIHRoaXMudHlwZSA9IERyYXdDb21tYW5kVHlwZS5MaW5lO1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcclxuICAgICAgICBjb25zdCBkaXIgPSBlbmQuc3ViKHN0YXJ0KS5ub3JtYWxpemUoKTtcclxuICAgICAgICBjb25zdCBub3JtYWwgPSBkaXIucGVycGVuZGljdWxhcigpO1xyXG4gICAgICAgIGNvbnN0IGhhbGZUaGljayA9IHRoaWNrbmVzcyAvIDI7XHJcbiAgICAgICAgY29uc3Qgc3RhcnRUb3AgPSBub3JtYWwuc2NhbGUoaGFsZlRoaWNrKS5hZGQoc3RhcnQpO1xyXG4gICAgICAgIGNvbnN0IHN0YXJ0Qm90dG9tID0gbm9ybWFsLnNjYWxlKC1oYWxmVGhpY2spLmFkZChzdGFydCk7XHJcbiAgICAgICAgY29uc3QgZW5kVG9wID0gbm9ybWFsLnNjYWxlKGhhbGZUaGljaykuYWRkKGVuZCk7XHJcbiAgICAgICAgY29uc3QgZW5kQm90dG9tID0gbm9ybWFsLnNjYWxlKC1oYWxmVGhpY2spLmFkZChlbmQpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS1eLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcclxuICAgICAgICAgKiAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAobm9ybWFsKSAgICAgICAgICAgICB8XHJcbiAgICAgICAgICogICAoc3RhcnR4LCBzdGFydHkpLS0tLS0tLS0tLS0tLS0tLS0tPihlbmR4LCBlbmR5KVxyXG4gICAgICAgICAqICAgIHwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcclxuICAgICAgICAgKiAgICArIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3N0YXJ0VG9wLngsIHN0YXJ0VG9wLnldO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbZW5kVG9wLngsIGVuZFRvcC55XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3N0YXJ0Qm90dG9tLngsIHN0YXJ0Qm90dG9tLnldO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbc3RhcnRCb3R0b20ueCwgc3RhcnRCb3R0b20ueV07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFtlbmRUb3AueCwgZW5kVG9wLnldO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbZW5kQm90dG9tLngsIGVuZEJvdHRvbS55XTtcclxuICAgICAgICBpZiAodGhpcy5zbmFwVG9QaXhlbCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHRoaXMuX2dlb20pIHtcclxuICAgICAgICAgICAgICAgIHBvaW50WzBdID0gfn5wb2ludFswXTtcclxuICAgICAgICAgICAgICAgIHBvaW50WzFdID0gfn5wb2ludFsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGluaXRDaXJjbGUocG9zLCByYWRpdXMsIGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy50eXBlID0gRHJhd0NvbW1hbmRUeXBlLkNpcmNsZTtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgY29uc3QgdG9wTGVmdCA9IHBvcy5hZGQodmVjKC1yYWRpdXMsIC1yYWRpdXMpKTtcclxuICAgICAgICBjb25zdCB0b3BSaWdodCA9IHBvcy5hZGQodmVjKHJhZGl1cywgLXJhZGl1cykpO1xyXG4gICAgICAgIGNvbnN0IGJvdHRvbVJpZ2h0ID0gcG9zLmFkZCh2ZWMocmFkaXVzLCByYWRpdXMpKTtcclxuICAgICAgICBjb25zdCBib3R0b21MZWZ0ID0gcG9zLmFkZCh2ZWMoLXJhZGl1cywgcmFkaXVzKSk7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RvcExlZnQueCwgdG9wTGVmdC55XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RvcFJpZ2h0LngsIHRvcFJpZ2h0LnldO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbYm90dG9tTGVmdC54LCBib3R0b21MZWZ0LnldO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbYm90dG9tTGVmdC54LCBib3R0b21MZWZ0LnldO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbdG9wUmlnaHQueCwgdG9wUmlnaHQueV07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFtib3R0b21SaWdodC54LCBib3R0b21SaWdodC55XTtcclxuICAgICAgICBpZiAodGhpcy5zbmFwVG9QaXhlbCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHRoaXMuX2dlb20pIHtcclxuICAgICAgICAgICAgICAgIHBvaW50WzBdID0gfn5wb2ludFswXTtcclxuICAgICAgICAgICAgICAgIHBvaW50WzFdID0gfn5wb2ludFsxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5pbWFnZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMudmlldyA9IFswLCAwLCAwLCAwXTtcclxuICAgICAgICB0aGlzLmRlc3QgPSBbMCwgMF07XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RoaXMuZGVzdFswXSwgdGhpcy5kZXN0WzFdXTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RoaXMuZGVzdFswXSwgdGhpcy5kZXN0WzFdICsgdGhpcy5oZWlnaHRdO1xyXG4gICAgICAgIHRoaXMuX2dlb21baW5kZXgrK10gPSBbdGhpcy5kZXN0WzBdICsgdGhpcy53aWR0aCwgdGhpcy5kZXN0WzFdXTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RoaXMuZGVzdFswXSArIHRoaXMud2lkdGgsIHRoaXMuZGVzdFsxXV07XHJcbiAgICAgICAgdGhpcy5fZ2VvbVtpbmRleCsrXSA9IFt0aGlzLmRlc3RbMF0sIHRoaXMuZGVzdFsxXSArIHRoaXMuaGVpZ2h0XTtcclxuICAgICAgICB0aGlzLl9nZW9tW2luZGV4KytdID0gW3RoaXMuZGVzdFswXSArIHRoaXMud2lkdGgsIHRoaXMuZGVzdFsxXSArIHRoaXMuaGVpZ2h0XTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8vIHRvZG8gd2VpcmRcclxuICAgIGFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSwgb3BhY2l0eSkge1xyXG4gICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9nZW9tLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9nZW9tW2ldID0gdHJhbnNmb3JtLm11bHR2KHRoaXMuX2dlb21baV0pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc25hcFRvUGl4ZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9nZW9tW2ldID0gW35+dGhpcy5fZ2VvbVtpXVswXSwgfn50aGlzLl9nZW9tW2ldWzFdXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgZ2V0IGdlb21ldHJ5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9nZW9tO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIERyYXdSZWN0Q29tbWFuZCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XHJcbiAgICAgICAgdGhpcy5kZXN0ID0gWzAsIDBdO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgICAgICB0aGlzLmRlc3QgPSBbeCwgeV07XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIERyYXdEZWJ1Z1JlY3RDb21tYW5kIHtcclxuICAgIGNvbnN0cnVjdG9yKGJvdW5kcywgY29sb3IpIHtcclxuICAgICAgICB0aGlzLmJvdW5kcyA9IGJvdW5kcztcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3dlYmdsLXV0aWwudHNcbi8qKlxyXG4gKiBDaGVja3MgaWYgdGhlIGN1cnJlbnQgbnVtYmVyIGlzIGEgcG93ZXIgb2YgdHdvXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1Bvd2VyT2ZUd28oeCkge1xyXG4gICAgcmV0dXJuICh4ICYgKHggLSAxKSkgPT09IDA7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiB0d29cclxuICovXHJcbmZ1bmN0aW9uIG5leHRIaWdoZXN0UG93ZXJPZlR3byh4KSB7XHJcbiAgICAtLXg7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDMyOyBpIDw8PSAxKSB7XHJcbiAgICAgICAgeCA9IHggfCAoeCA+PiBpKTtcclxuICAgIH1cclxuICAgIHJldHVybiB4ICsgMTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgaW5wdXQgbnVtYmVyIGlmIGEgcG93ZXIgb2YgdHdvLCBvdGhlcndpc2UgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiB0d29cclxuICovXHJcbmZ1bmN0aW9uIGVuc3VyZVBvd2VyT2ZUd28oeCkge1xyXG4gICAgaWYgKCFpc1Bvd2VyT2ZUd28oeCkpIHtcclxuICAgICAgICByZXR1cm4gbmV4dEhpZ2hlc3RQb3dlck9mVHdvKHgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHg7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3RleHR1cmUtbG9hZGVyLnRzXG5cclxuLyoqXHJcbiAqIE1hbmFnZXMgbG9hZGluZyBpbWFnZSBzb3VyY2VzIGludG8gd2ViZ2wgdGV4dHVyZXMsIGEgdW5pcXVlIGlkIGlzIGFzc29jaWF0ZWQgd2l0aCBhbGwgc291cmNlc1xyXG4gKi9cclxuY2xhc3MgVGV4dHVyZUxvYWRlciB7XHJcbiAgICBzdGF0aWMgcmVnaXN0ZXJDb250ZXh0KGNvbnRleHQpIHtcclxuICAgICAgICBUZXh0dXJlTG9hZGVyLl9HTCA9IGNvbnRleHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgV2ViR0wgVGV4dHVyZSBmcm9tIGEgc291cmNlIGltYWdlXHJcbiAgICAgKiBAcGFyYW0gaW1hZ2VcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGdldChpbWFnZSkge1xyXG4gICAgICAgIHJldHVybiBUZXh0dXJlTG9hZGVyLl9URVhUVVJFX01BUC5nZXQoaW1hZ2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBzb3VyY2UgaW1hZ2UgaGFzIGJlZW4gbG9hZGVkIGFzIGEgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIGltYWdlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBoYXMoaW1hZ2UpIHtcclxuICAgICAgICByZXR1cm4gVGV4dHVyZUxvYWRlci5fVEVYVFVSRV9NQVAuaGFzKGltYWdlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9hZHMgYSBncmFwaGljIGludG8gd2ViZ2wgYW5kIHJldHVybnMgaXQncyB0ZXh0dXJlIGluZm8sIGEgd2ViZ2wgY29udGV4dCBtdXN0IGJlIHByZXZpb3VzbHkgcmVnaXN0ZXJlZFxyXG4gICAgICogQHBhcmFtIGltYWdlIFNvdXJjZSBncmFwaGljXHJcbiAgICAgKiBAcGFyYW0gZm9yY2VVcGRhdGUgT3B0aW9uYWxseSBmb3JjZSBhIHRleHR1cmUgdG8gYmUgcmVsb2FkZWQsIHVzZWZ1bCBpZiB0aGUgc291cmNlIGdyYXBoaWMgaGFzIGNoYW5nZWRcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGxvYWQoaW1hZ2UsIGZvcmNlVXBkYXRlID0gZmFsc2UpIHtcclxuICAgICAgICAvLyBJZ25vcmUgbG9hZGluZyBpZiB3ZWJnbCBpcyBub3QgcmVnaXN0ZXJlZFxyXG4gICAgICAgIGNvbnN0IGdsID0gVGV4dHVyZUxvYWRlci5fR0w7XHJcbiAgICAgICAgaWYgKCFnbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IHRleCA9IG51bGw7XHJcbiAgICAgICAgLy8gSWYgcmV1c2UgdGhlIHRleHR1cmUgaWYgaXQncyBmcm9tIHRoZSBzYW1lIHNvdXJjZVxyXG4gICAgICAgIGlmIChUZXh0dXJlTG9hZGVyLmhhcyhpbWFnZSkpIHtcclxuICAgICAgICAgICAgdGV4ID0gVGV4dHVyZUxvYWRlci5nZXQoaW1hZ2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBVcGRhdGUgZXhpc3Rpbmcgd2ViZ2wgdGV4dHVyZSBhbmQgcmV0dXJuIGVhcmx5XHJcbiAgICAgICAgaWYgKHRleCkge1xyXG4gICAgICAgICAgICBpZiAoZm9yY2VVcGRhdGUpIHtcclxuICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBUZXh0dXJlTG9hZGVyLnRvUG93ZXJPZlR3b0ltYWdlKGltYWdlKTtcclxuICAgICAgICAgICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgc291cmNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGV4O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBObyB0ZXh0dXJlIGV4aXN0cyBjcmVhdGUgYSBuZXcgb25lXHJcbiAgICAgICAgdGV4ID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IFRleHR1cmVMb2FkZXIudG9Qb3dlck9mVHdvSW1hZ2UoaW1hZ2UpO1xyXG4gICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleCk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICAgICAgLy8gTkVBUkVTVCBmb3IgcGl4ZWxzXHJcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xyXG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKTtcclxuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHNvdXJjZSk7XHJcbiAgICAgICAgVGV4dHVyZUxvYWRlci5fVEVYVFVSRV9NQVAuc2V0KGltYWdlLCB0ZXgpO1xyXG4gICAgICAgIHJldHVybiB0ZXg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIHNvdXJjZSBpbWFnZXMgaW50byBwb3dlciBvZiB0d28gaW1hZ2VzLCBXZWJHTCBvbmx5IHN1cHBvcnRzIFBPVCBpbWFnZXNcclxuICAgICAqIGh0dHBzOi8vd3d3Lmtocm9ub3Mub3JnL3dlYmdsL3dpa2kvV2ViR0xfYW5kX09wZW5HTF9EaWZmZXJlbmNlcyNOb24tUG93ZXJfb2ZfVHdvX1RleHR1cmVfU3VwcG9ydFxyXG4gICAgICogQHBhcmFtIGltYWdlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0b1Bvd2VyT2ZUd29JbWFnZShpbWFnZSkge1xyXG4gICAgICAgIGNvbnN0IHBvdENhbnZhcyA9IFRleHR1cmVMb2FkZXIuX1BPVF9DQU5WQVM7XHJcbiAgICAgICAgY29uc3QgcG90Q3R4ID0gVGV4dHVyZUxvYWRlci5fUE9UX0NUWDtcclxuICAgICAgICBpZiAoIWlzUG93ZXJPZlR3byhpbWFnZS53aWR0aCkgfHwgIWlzUG93ZXJPZlR3byhpbWFnZS5oZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIC8vIFNjYWxlIHVwIHRoZSB0ZXh0dXJlIHRvIHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgdHdvIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgICAgIHBvdENhbnZhcy53aWR0aCA9IGVuc3VyZVBvd2VyT2ZUd28oaW1hZ2Uud2lkdGgpO1xyXG4gICAgICAgICAgICBwb3RDYW52YXMuaGVpZ2h0ID0gZW5zdXJlUG93ZXJPZlR3byhpbWFnZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICBwb3RDdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHBvdEN0eC5jbGVhclJlY3QoMCwgMCwgcG90Q2FudmFzLndpZHRoLCBwb3RDYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAgICAgcG90Q3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XHJcbiAgICAgICAgICAgIGltYWdlID0gcG90Q2FudmFzO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW1hZ2U7XHJcbiAgICB9XHJcbn1cclxuVGV4dHVyZUxvYWRlci5fUE9UX0NBTlZBUyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG5UZXh0dXJlTG9hZGVyLl9QT1RfQ1RYID0gVGV4dHVyZUxvYWRlci5fUE9UX0NBTlZBUy5nZXRDb250ZXh0KCcyZCcpO1xyXG5UZXh0dXJlTG9hZGVyLl9URVhUVVJFX01BUCA9IG5ldyBNYXAoKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L2ltYWdlLXJlbmRlcmVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBCYXRjaEltYWdlIGV4dGVuZHMgQmF0Y2hDb21tYW5kIHtcclxuICAgIGNvbnN0cnVjdG9yKG1heERyYXdzLCBtYXhUZXh0dXJlcykge1xyXG4gICAgICAgIHN1cGVyKG1heERyYXdzKTtcclxuICAgICAgICB0aGlzLm1heERyYXdzID0gbWF4RHJhd3M7XHJcbiAgICAgICAgdGhpcy5tYXhUZXh0dXJlcyA9IG1heFRleHR1cmVzO1xyXG4gICAgICAgIHRoaXMudGV4dHVyZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmNvbW1hbmRzID0gW107XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY01hcCA9IHt9O1xyXG4gICAgfVxyXG4gICAgaXNGdWxsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbW1hbmRzLmxlbmd0aCA+PSB0aGlzLm1heERyYXdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlcy5sZW5ndGggPj0gdGhpcy5tYXhUZXh0dXJlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY2FuQWRkKCkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbW1hbmRzLmxlbmd0aCA+PSB0aGlzLm1heERyYXdzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZXMubGVuZ3RoIDwgdGhpcy5tYXhUZXh0dXJlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgX2lzQ29tbWFuZEZ1bGwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tbWFuZHMubGVuZ3RoID49IHRoaXMubWF4RHJhd3M7XHJcbiAgICB9XHJcbiAgICBfaXNUZXh0dXJlRnVsbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlcy5sZW5ndGggPj0gdGhpcy5tYXhUZXh0dXJlcztcclxuICAgIH1cclxuICAgIF93b3VsZEFkZFRleHR1cmUoY29tbWFuZCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5fZ3JhcGhpY01hcFtjb21tYW5kLmltYWdlLmlkXTtcclxuICAgIH1cclxuICAgIG1heWJlQWRkKGNvbW1hbmQpIHtcclxuICAgICAgICBpZiAoKHRoaXMuX2lzQ29tbWFuZEZ1bGwoKSB8fCB0aGlzLl9pc1RleHR1cmVGdWxsKCkpICYmIHRoaXMuX3dvdWxkQWRkVGV4dHVyZShjb21tYW5kKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWRkKGNvbW1hbmQpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgYWRkKGNvbW1hbmQpIHtcclxuICAgICAgICBpZiAoY29tbWFuZC50eXBlID09PSBEcmF3Q29tbWFuZFR5cGUuSW1hZ2UpIHtcclxuICAgICAgICAgICAgY29uc3QgdGV4dHVyZSA9IFRleHR1cmVMb2FkZXIubG9hZChjb21tYW5kLmltYWdlKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMudGV4dHVyZXMuaW5kZXhPZih0ZXh0dXJlKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmNvbW1hbmRzLnB1c2goY29tbWFuZCk7XHJcbiAgICB9XHJcbiAgICBiaW5kVGV4dHVyZXMoZ2wpIHtcclxuICAgICAgICAvLyBCaW5kIHRleHR1cmVzIGluIHRoZSBjb3JyZWN0IG9yZGVyXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1heFRleHR1cmVzOyBpKyspIHtcclxuICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCArIGkpO1xyXG4gICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmVzW2ldIHx8IHRoaXMudGV4dHVyZXNbMF0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldEJhdGNoVGV4dHVyZUlkKGNvbW1hbmQpIHtcclxuICAgICAgICBpZiAoY29tbWFuZC5pbWFnZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZXh0dXJlcy5pbmRleE9mKFRleHR1cmVMb2FkZXIuZ2V0KGNvbW1hbmQuaW1hZ2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy50ZXh0dXJlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNNYXAgPSB7fTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBJbWFnZVJlbmRlcmVyIGV4dGVuZHMgQmF0Y2hSZW5kZXJlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihnbCwgX2NvbnRleHRJbmZvKSB7XHJcbiAgICAgICAgc3VwZXIoe1xyXG4gICAgICAgICAgICBnbCxcclxuICAgICAgICAgICAgY29tbWFuZDogRHJhd0ltYWdlQ29tbWFuZCxcclxuICAgICAgICAgICAgLy8gNiB2ZXJ0cyBwZXIgcXVhZFxyXG4gICAgICAgICAgICB2ZXJ0aWNlc1BlckNvbW1hbmQ6IDYsXHJcbiAgICAgICAgICAgIG1heENvbW1hbmRzUGVyQmF0Y2g6IDIwMDAsXHJcbiAgICAgICAgICAgIGJhdGNoRmFjdG9yeTogKCkgPT4gbmV3IEJhdGNoSW1hZ2UoMjAwMCwgZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKSlcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9jb250ZXh0SW5mbyA9IF9jb250ZXh0SW5mbztcclxuICAgICAgICBUZXh0dXJlTG9hZGVyLnJlZ2lzdGVyQ29udGV4dChnbCk7XHJcbiAgICAgICAgdGhpcy5pbml0KCk7XHJcbiAgICB9XHJcbiAgICBidWlsZFNoYWRlcihnbCkge1xyXG4gICAgICAgIC8vIEluaXRpYWxpbHplIGRlZmF1bHQgYmF0Y2ggcmVuZGVyaW5nIHNoYWRlclxyXG4gICAgICAgIGNvbnN0IG1heEdQVVRleHR1cmVzID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX0lNQUdFX1VOSVRTKTtcclxuICAgICAgICBjb25zdCBzaGFkZXIgPSBuZXcgU2hhZGVyKGdsLCBpbWFnZV92ZXJ0ZXgsIHRoaXMuX3RyYW5zZm9ybUZyYWdtZW50U291cmNlKGltYWdlX2ZyYWdtZW50LCBtYXhHUFVUZXh0dXJlcykpO1xyXG4gICAgICAgIHNoYWRlci5hZGRBdHRyaWJ1dGUoJ2FfcG9zaXRpb24nLCAzLCBnbC5GTE9BVCk7XHJcbiAgICAgICAgc2hhZGVyLmFkZEF0dHJpYnV0ZSgnYV90ZXhjb29yZCcsIDIsIGdsLkZMT0FUKTtcclxuICAgICAgICBzaGFkZXIuYWRkQXR0cmlidXRlKCdhX3RleHR1cmVJbmRleCcsIDEsIGdsLkZMT0FUKTtcclxuICAgICAgICBzaGFkZXIuYWRkQXR0cmlidXRlKCdhX29wYWNpdHknLCAxLCBnbC5GTE9BVCk7XHJcbiAgICAgICAgc2hhZGVyLmFkZEF0dHJpYnV0ZSgnYV9jb2xvcicsIDQsIGdsLkZMT0FUKTtcclxuICAgICAgICBzaGFkZXIuYWRkVW5pZm9ybU1hdHJpeCgndV9tYXRyaXgnLCB0aGlzLl9jb250ZXh0SW5mby5tYXRyaXguZGF0YSk7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSB0ZXh0dXJlIHNsb3RzIHRvIFswLCAxLCAyLCAzLCA0LCAuLi4uIG1heEdQVVRleHR1cmVzXVxyXG4gICAgICAgIHNoYWRlci5hZGRVbmlmb3JtSW50ZWdlckFycmF5KCd1X3RleHR1cmVzJywgWy4uLkFycmF5KG1heEdQVVRleHR1cmVzKV0ubWFwKChfLCBpKSA9PiBpKSk7XHJcbiAgICAgICAgcmV0dXJuIHNoYWRlcjtcclxuICAgIH1cclxuICAgIF90cmFuc2Zvcm1GcmFnbWVudFNvdXJjZShzb3VyY2UsIG1heFRleHR1cmVzKSB7XHJcbiAgICAgICAgbGV0IG5ld1NvdXJjZSA9IHNvdXJjZS5yZXBsYWNlKCclJWNvdW50JSUnLCBtYXhUZXh0dXJlcy50b1N0cmluZygpKTtcclxuICAgICAgICBsZXQgdGV4dHVyZVBpY2tlckJ1aWxkZXIgPSAnJztcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heFRleHR1cmVzOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVQaWNrZXJCdWlsZGVyICs9IGBpZiAodl90ZXh0dXJlSW5kZXggPD0gJHtpfS41KSB7XFxuYDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVQaWNrZXJCdWlsZGVyICs9IGAgICBlbHNlIGlmICh2X3RleHR1cmVJbmRleCA8PSAke2l9LjUpIHtcXG5gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRleHR1cmVQaWNrZXJCdWlsZGVyICs9IGAgICAgICBjb2xvciA9IHRleHR1cmUyRCh1X3RleHR1cmVzWyR7aX1dLCB2X3RleGNvb3JkKTtcXG5gO1xyXG4gICAgICAgICAgICB0ZXh0dXJlUGlja2VyQnVpbGRlciArPSBgICAgfVxcbmA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG5ld1NvdXJjZSA9IG5ld1NvdXJjZS5yZXBsYWNlKCclJXRleHR1cmVfcGlja2VyJSUnLCB0ZXh0dXJlUGlja2VyQnVpbGRlcik7XHJcbiAgICAgICAgcmV0dXJuIG5ld1NvdXJjZTtcclxuICAgIH1cclxuICAgIGFkZENpcmNsZShwb3MsIHJhZGl1cywgY29sb3IpIHtcclxuICAgICAgICBjb25zdCBjb21tYW5kID0gdGhpcy5jb21tYW5kcy5nZXQoKS5pbml0Q2lyY2xlKHBvcywgcmFkaXVzLCBjb2xvcik7XHJcbiAgICAgICAgY29tbWFuZC5hcHBseVRyYW5zZm9ybSh0aGlzLl9jb250ZXh0SW5mby50cmFuc2Zvcm0uY3VycmVudCwgdGhpcy5fY29udGV4dEluZm8uc3RhdGUuY3VycmVudC5vcGFjaXR5KTtcclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoY29tbWFuZCk7XHJcbiAgICB9XHJcbiAgICBhZGRSZWN0YW5nbGUoY29sb3IsIHBvcywgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzLmdldCgpLmluaXRSZWN0KGNvbG9yLCBwb3MsIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgICAgIGNvbW1hbmQuYXBwbHlUcmFuc2Zvcm0odGhpcy5fY29udGV4dEluZm8udHJhbnNmb3JtLmN1cnJlbnQsIHRoaXMuX2NvbnRleHRJbmZvLnN0YXRlLmN1cnJlbnQub3BhY2l0eSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKGNvbW1hbmQpO1xyXG4gICAgfVxyXG4gICAgYWRkTGluZShjb2xvciwgc3RhcnQsIGVuZCwgdGhpY2tuZXNzID0gMSkge1xyXG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSB0aGlzLmNvbW1hbmRzLmdldCgpLmluaXRMaW5lKGNvbG9yLCBzdGFydCwgZW5kLCB0aGlja25lc3MpO1xyXG4gICAgICAgIGNvbW1hbmQuYXBwbHlUcmFuc2Zvcm0odGhpcy5fY29udGV4dEluZm8udHJhbnNmb3JtLmN1cnJlbnQsIHRoaXMuX2NvbnRleHRJbmZvLnN0YXRlLmN1cnJlbnQub3BhY2l0eSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKGNvbW1hbmQpO1xyXG4gICAgfVxyXG4gICAgYWRkSW1hZ2UoZ3JhcGhpYywgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQsIGR4LCBkeSwgZHdpZHRoLCBkaGVpZ2h0KSB7XHJcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IHRoaXMuY29tbWFuZHMuZ2V0KCkuaW5pdChncmFwaGljLCBzeCwgc3ksIHN3aWR0aCwgc2hlaWdodCwgZHgsIGR5LCBkd2lkdGgsIGRoZWlnaHQpO1xyXG4gICAgICAgIGNvbW1hbmQuYXBwbHlUcmFuc2Zvcm0odGhpcy5fY29udGV4dEluZm8udHJhbnNmb3JtLmN1cnJlbnQsIHRoaXMuX2NvbnRleHRJbmZvLnN0YXRlLmN1cnJlbnQub3BhY2l0eSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKGNvbW1hbmQpO1xyXG4gICAgfVxyXG4gICAgcmVuZGVyQmF0Y2goZ2wsIGJhdGNoLCB2ZXJ0ZXhDb3VudCkge1xyXG4gICAgICAgIC8vIEJpbmQgdGV4dHVyZXMgaW4gdGhlIGNvcnJlY3Qgb3JkZXJcclxuICAgICAgICBiYXRjaC5iaW5kVGV4dHVyZXMoZ2wpO1xyXG4gICAgICAgIC8vIGRyYXcgdGhlIHF1YWRzXHJcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIHZlcnRleENvdW50KTtcclxuICAgIH1cclxuICAgIGJ1aWxkQmF0Y2hWZXJ0aWNlcyh2ZXJ0ZXhCdWZmZXIsIGJhdGNoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBsZXQgdmVydEluZGV4ID0gMDtcclxuICAgICAgICBsZXQgc3ggPSAwO1xyXG4gICAgICAgIGxldCBzeSA9IDA7XHJcbiAgICAgICAgbGV0IHN3ID0gMDtcclxuICAgICAgICBsZXQgc2ggPSAwO1xyXG4gICAgICAgIGxldCBwb3RXaWR0aCA9IDE7XHJcbiAgICAgICAgbGV0IHBvdEhlaWdodCA9IDE7XHJcbiAgICAgICAgbGV0IHRleHR1cmVJZCA9IDA7XHJcbiAgICAgICAgbGV0IGNvbW1hbmRDb2xvciA9IENvbG9yLlRyYW5zcGFyZW50O1xyXG4gICAgICAgIGZvciAoY29uc3QgY29tbWFuZCBvZiBiYXRjaC5jb21tYW5kcykge1xyXG4gICAgICAgICAgICBzeCA9IGNvbW1hbmQudmlld1swXTtcclxuICAgICAgICAgICAgc3kgPSBjb21tYW5kLnZpZXdbMV07XHJcbiAgICAgICAgICAgIHN3ID0gY29tbWFuZC52aWV3WzJdO1xyXG4gICAgICAgICAgICBzaCA9IGNvbW1hbmQudmlld1szXTtcclxuICAgICAgICAgICAgcG90V2lkdGggPSBlbnN1cmVQb3dlck9mVHdvKCgoX2EgPSBjb21tYW5kLmltYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGgpIHx8IGNvbW1hbmQud2lkdGgpO1xyXG4gICAgICAgICAgICBwb3RIZWlnaHQgPSBlbnN1cmVQb3dlck9mVHdvKCgoX2IgPSBjb21tYW5kLmltYWdlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaGVpZ2h0KSB8fCBjb21tYW5kLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHRleHR1cmVJZCA9IGJhdGNoLmdldEJhdGNoVGV4dHVyZUlkKGNvbW1hbmQpO1xyXG4gICAgICAgICAgICBpZiAoY29tbWFuZC50eXBlID09PSBEcmF3Q29tbWFuZFR5cGUuTGluZSB8fCBjb21tYW5kLnR5cGUgPT09IERyYXdDb21tYW5kVHlwZS5SZWN0YW5nbGUpIHtcclxuICAgICAgICAgICAgICAgIHRleHR1cmVJZCA9IC0xOyAvLyBzZW50aW5lbCBmb3Igbm8gaW1hZ2UgcmVjdFxyXG4gICAgICAgICAgICAgICAgY29tbWFuZENvbG9yID0gY29tbWFuZC5jb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoY29tbWFuZC50eXBlID09PSBEcmF3Q29tbWFuZFR5cGUuQ2lyY2xlKSB7XHJcbiAgICAgICAgICAgICAgICB0ZXh0dXJlSWQgPSAtMjsgLy8gc2VudGluZWwgZm9yIGNpcmNsZVxyXG4gICAgICAgICAgICAgICAgY29tbWFuZENvbG9yID0gY29tbWFuZC5jb2xvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBwb3RlbnRpYWwgb3B0aW1pemF0aW9uIHdoZW4gZGl2ZGluZyBieSAyIChiaXRzaGlmdClcclxuICAgICAgICAgICAgLy8gTW9kaWZ5aW5nIHRoZSBpbWFnZXMgdG8gcG93ZXJvZnR3byBpbWFnZXMgd2FycCB0aGUgVVYgY29vcmRpbmF0ZXNcclxuICAgICAgICAgICAgbGV0IHV2eDAgPSBzeCAvIHBvdFdpZHRoO1xyXG4gICAgICAgICAgICBsZXQgdXZ5MCA9IHN5IC8gcG90SGVpZ2h0O1xyXG4gICAgICAgICAgICBsZXQgdXZ4MSA9IChzeCArIHN3KSAvIHBvdFdpZHRoO1xyXG4gICAgICAgICAgICBsZXQgdXZ5MSA9IChzeSArIHNoKSAvIHBvdEhlaWdodDtcclxuICAgICAgICAgICAgaWYgKHRleHR1cmVJZCA9PT0gLTIpIHtcclxuICAgICAgICAgICAgICAgIHV2eDAgPSAwO1xyXG4gICAgICAgICAgICAgICAgdXZ5MCA9IDA7XHJcbiAgICAgICAgICAgICAgICB1dngxID0gMTtcclxuICAgICAgICAgICAgICAgIHV2eTEgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFF1YWQgdXBkYXRlXHJcbiAgICAgICAgICAgIC8vICgwLCAwLCB6KSB6LWluZGV4IGRvZXNuJ3Qgd29yayBpbiBiYXRjaCByZW5kZXJpbmcgYmV0d2VlbiBiYXRjaGVzXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kLmdlb21ldHJ5WzBdWzBdOyAvLyB4ICsgMCAqIHdpZHRoO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5nZW9tZXRyeVswXVsxXTsgLy95ICsgMCAqIGhlaWdodDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IDA7XHJcbiAgICAgICAgICAgIC8vIFVWIGNvb3Jkc1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gdXZ4MDsgLy8gMDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHV2eTA7IC8vIDA7XHJcbiAgICAgICAgICAgIC8vIHRleHR1cmUgaWRcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHRleHR1cmVJZDtcclxuICAgICAgICAgICAgLy8gb3BhY2l0eVxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5vcGFjaXR5O1xyXG4gICAgICAgICAgICAvLyBjb2xvclxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuZyAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5iIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmE7XHJcbiAgICAgICAgICAgIC8vICgwLCAxKVxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5nZW9tZXRyeVsxXVswXTsgLy8geCArIDAgKiB3aWR0aDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmQuZ2VvbWV0cnlbMV1bMV07IC8vIHkgKyAxICogaGVpZ2h0O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gMDtcclxuICAgICAgICAgICAgLy8gVVYgY29vcmRzXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSB1dngwOyAvLyAwO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gdXZ5MTsgLy8gMTtcclxuICAgICAgICAgICAgLy8gdGV4dHVyZSBpZFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gdGV4dHVyZUlkO1xyXG4gICAgICAgICAgICAvLyBvcGFjaXR5XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIC8vIGNvbG9yXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuciAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5nIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuYTtcclxuICAgICAgICAgICAgLy8gKDEsIDApXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kLmdlb21ldHJ5WzJdWzBdOyAvLyB4ICsgMSAqIHdpZHRoO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5nZW9tZXRyeVsyXVsxXTsgLy8geSArIDAgKiBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSAwO1xyXG4gICAgICAgICAgICAvLyBVViBjb29yZHNcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHV2eDE7IC8vMTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHV2eTA7IC8vMDtcclxuICAgICAgICAgICAgLy8gdGV4dHVyZSBpZFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gdGV4dHVyZUlkO1xyXG4gICAgICAgICAgICAvLyBvcGFjaXR5XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIC8vIGNvbG9yXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuciAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5nIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuYTtcclxuICAgICAgICAgICAgLy8gKDEsIDApXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kLmdlb21ldHJ5WzNdWzBdOyAvLyB4ICsgMSAqIHdpZHRoO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5nZW9tZXRyeVszXVsxXTsgLy8geSArIDAgKiBoZWlnaHQ7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSAwO1xyXG4gICAgICAgICAgICAvLyBVViBjb29yZHNcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHV2eDE7IC8vMTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHV2eTA7IC8vMDtcclxuICAgICAgICAgICAgLy8gdGV4dHVyZSBpZFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gdGV4dHVyZUlkO1xyXG4gICAgICAgICAgICAvLyBvcGFjaXR5XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIC8vIGNvbG9yXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuciAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5nIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuYTtcclxuICAgICAgICAgICAgLy8gKDAsIDEpXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kLmdlb21ldHJ5WzRdWzBdOyAvLyB4ICsgMCAqIHdpZHRoO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5nZW9tZXRyeVs0XVsxXTsgLy8geSArIDEgKiBoZWlnaHRcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IDA7XHJcbiAgICAgICAgICAgIC8vIFVWIGNvb3Jkc1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gdXZ4MDsgLy8gMDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHV2eTE7IC8vIDE7XHJcbiAgICAgICAgICAgIC8vIHRleHR1cmUgaWRcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IHRleHR1cmVJZDtcclxuICAgICAgICAgICAgLy8gb3BhY2l0eVxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5vcGFjaXR5O1xyXG4gICAgICAgICAgICAvLyBjb2xvclxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLnIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuZyAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5iIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmE7XHJcbiAgICAgICAgICAgIC8vICgxLCAxKVxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZC5nZW9tZXRyeVs1XVswXTsgLy8geCArIDEgKiB3aWR0aDtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmQuZ2VvbWV0cnlbNV1bMV07IC8vIHkgKyAxICogaGVpZ2h0O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gMDtcclxuICAgICAgICAgICAgLy8gVVYgY29vcmRzXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSB1dngxOyAvLyAxO1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gdXZ5MTsgLy8gMTtcclxuICAgICAgICAgICAgLy8gdGV4dHVyZSBpZFxyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gdGV4dHVyZUlkO1xyXG4gICAgICAgICAgICAvLyBvcGFjaXR5XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIC8vIGNvbG9yXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuciAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW3ZlcnRJbmRleCsrXSA9IGNvbW1hbmRDb2xvci5nIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbdmVydEluZGV4KytdID0gY29tbWFuZENvbG9yLmIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlclt2ZXJ0SW5kZXgrK10gPSBjb21tYW5kQ29sb3IuYTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHZlcnRJbmRleCAvIHRoaXMudmVydGV4U2l6ZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvc2hhZGVycy9wb2ludC12ZXJ0ZXguZ2xzbFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBwb2ludF92ZXJ0ZXggPSAoXCJhdHRyaWJ1dGUgdmVjNCBhX3Bvc2l0aW9uO1xcclxcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxyXFxuYXR0cmlidXRlIGZsb2F0IGFfc2l6ZTtcXHJcXG52YXJ5aW5nIGxvd3AgdmVjNCB2X2NvbG9yO1xcclxcbnVuaWZvcm0gbWF0NCB1X21hdHJpeDtcXHJcXG5cXHJcXG52b2lkIG1haW4oKSB7XFxyXFxuICBnbF9Qb3NpdGlvbiA9IHVfbWF0cml4ICogYV9wb3NpdGlvbjtcXHJcXG4gIGdsX1BvaW50U2l6ZSA9IGFfc2l6ZSAqIDIuMDtcXHJcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcclxcbn1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3NoYWRlcnMvcG9pbnQtZnJhZ21lbnQuZ2xzbFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBwb2ludF9mcmFnbWVudCA9IChcIiNpZmRlZiBHTF9PRVNfc3RhbmRhcmRfZGVyaXZhdGl2ZXNcXHJcXG4jZXh0ZW5zaW9uIEdMX09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcyA6IGVuYWJsZVxcclxcbiNlbmRpZlxcclxcblxcclxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcclxcbnZhcnlpbmcgbG93cCB2ZWM0IHZfY29sb3I7XFxyXFxuXFxyXFxudm9pZCBtYWluKCkge1xcclxcbiAgZmxvYXQgciA9IDAuMCwgZGVsdGEgPSAwLjAsIGFscGhhID0gMS4wO1xcclxcbiAgdmVjMiBjeHkgPSAyLjAgKiBnbF9Qb2ludENvb3JkIC0gMS4wO1xcclxcbiAgciA9IGRvdChjeHksIGN4eSk7XFxyXFxuICBcXHJcXG4jaWZkZWYgR0xfT0VTX3N0YW5kYXJkX2Rlcml2YXRpdmVzXFxyXFxuICBkZWx0YSA9IGZ3aWR0aChyKTtcXHJcXG4gIGFscGhhID0gMS4wIC0gc21vb3Roc3RlcCgxLjAgLSBkZWx0YSwgMS4wICsgZGVsdGEsIHIpO1xcclxcbiNlbHNlXFxyXFxuICBpZiAociA+IDEuMCkge1xcclxcbiAgICBkaXNjYXJkO1xcclxcbiAgfVxcclxcbiNlbmRpZlxcclxcbiAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh2X2NvbG9yLnJnYiwgdl9jb2xvci5hICogYWxwaGEpO1xcclxcbn1cIik7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9Db250ZXh0L3BvaW50LXJlbmRlcmVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyBpbXBvcnQgeyBSYW5kb20gfSBmcm9tICcuLi8uLi9NYXRoL0luZGV4JztcclxuY2xhc3MgRHJhd1BvaW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMucG9pbnQgPSBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLmNvbG9yID0gQ29sb3IuQmxhY2s7XHJcbiAgICAgICAgdGhpcy5zaXplID0gMTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgdGhpcy5wb2ludC5zZXRUbygwLCAwKTtcclxuICAgICAgICB0aGlzLmNvbG9yLnIgPSAwO1xyXG4gICAgICAgIHRoaXMuY29sb3IuZyA9IDA7XHJcbiAgICAgICAgdGhpcy5jb2xvci5iID0gMDtcclxuICAgICAgICB0aGlzLmNvbG9yLmEgPSAxO1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDE7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUG9pbnRSZW5kZXJlciBleHRlbmRzIEJhdGNoUmVuZGVyZXIge1xyXG4gICAgY29uc3RydWN0b3IoZ2wsIF9jb250ZXh0SW5mbykge1xyXG4gICAgICAgIHN1cGVyKHsgZ2wsIGNvbW1hbmQ6IERyYXdQb2ludCwgdmVydGljZXNQZXJDb21tYW5kOiAxIH0pO1xyXG4gICAgICAgIHRoaXMuX2NvbnRleHRJbmZvID0gX2NvbnRleHRJbmZvO1xyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgfVxyXG4gICAgYnVpbGRTaGFkZXIoZ2wpIHtcclxuICAgICAgICBnbC5nZXRFeHRlbnNpb24oJ09FU19zdGFuZGFyZF9kZXJpdmF0aXZlcycpO1xyXG4gICAgICAgIGNvbnN0IHNoYWRlciA9IG5ldyBTaGFkZXIoZ2wsIHBvaW50X3ZlcnRleCwgcG9pbnRfZnJhZ21lbnQpO1xyXG4gICAgICAgIHNoYWRlci5hZGRBdHRyaWJ1dGUoJ2FfcG9zaXRpb24nLCAyLCBnbC5GTE9BVCk7XHJcbiAgICAgICAgc2hhZGVyLmFkZEF0dHJpYnV0ZSgnYV9jb2xvcicsIDQsIGdsLkZMT0FUKTtcclxuICAgICAgICBzaGFkZXIuYWRkQXR0cmlidXRlKCdhX3NpemUnLCAxLCBnbC5GTE9BVCk7XHJcbiAgICAgICAgc2hhZGVyLmFkZFVuaWZvcm1NYXRyaXgoJ3VfbWF0cml4JywgdGhpcy5fY29udGV4dEluZm8ubWF0cml4LmRhdGEpO1xyXG4gICAgICAgIHJldHVybiBzaGFkZXI7XHJcbiAgICB9XHJcbiAgICBhZGRQb2ludChwb2ludCwgY29sb3IsIHNpemUpIHtcclxuICAgICAgICBjb25zdCBjbWQgPSB0aGlzLmNvbW1hbmRzLmdldCgpO1xyXG4gICAgICAgIGNtZC5wb2ludCA9IHRoaXMuX2NvbnRleHRJbmZvLnRyYW5zZm9ybS5jdXJyZW50Lm11bHR2KHBvaW50KTtcclxuICAgICAgICBjbWQuY29sb3IuciA9IGNvbG9yLnI7XHJcbiAgICAgICAgY21kLmNvbG9yLmcgPSBjb2xvci5nO1xyXG4gICAgICAgIGNtZC5jb2xvci5iID0gY29sb3IuYjtcclxuICAgICAgICBjbWQuY29sb3IuYSA9IGNvbG9yLmEgKiB0aGlzLl9jb250ZXh0SW5mby5zdGF0ZS5jdXJyZW50Lm9wYWNpdHk7XHJcbiAgICAgICAgY21kLnNpemUgPSBzaXplICogTWF0aC5tYXgodGhpcy5fY29udGV4dEluZm8udHJhbnNmb3JtLmN1cnJlbnQuZ2V0U2NhbGVYKCksIHRoaXMuX2NvbnRleHRJbmZvLnRyYW5zZm9ybS5jdXJyZW50LmdldFNjYWxlWSgpKTtcclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoY21kKTtcclxuICAgIH1cclxuICAgIGJ1aWxkQmF0Y2hWZXJ0aWNlcyh2ZXJ0ZXhCdWZmZXIsIGJhdGNoKSB7XHJcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgYmF0Y2guY29tbWFuZHMpIHtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5wb2ludC54O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLnBvaW50Lnk7XHJcbiAgICAgICAgICAgIC8vIG5vcm1hbGl6ZSB0byBbMCwgMV0gZm9yIHdlYmdsXHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcltpbmRleCsrXSA9IGNvbW1hbmQuY29sb3IuciAvIDI1NTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5jb2xvci5nIC8gMjU1O1xyXG4gICAgICAgICAgICB2ZXJ0ZXhCdWZmZXJbaW5kZXgrK10gPSBjb21tYW5kLmNvbG9yLmIgLyAyNTU7XHJcbiAgICAgICAgICAgIHZlcnRleEJ1ZmZlcltpbmRleCsrXSA9IGNvbW1hbmQuY29sb3IuYTtcclxuICAgICAgICAgICAgdmVydGV4QnVmZmVyW2luZGV4KytdID0gY29tbWFuZC5zaXplO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5kZXggLyB0aGlzLnZlcnRleFNpemU7XHJcbiAgICB9XHJcbiAgICByZW5kZXJCYXRjaChnbCwgX2JhdGNoLCB2ZXJ0ZXhDb3VudCkge1xyXG4gICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuUE9JTlRTLCAwLCB2ZXJ0ZXhDb3VudCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9HcmFwaGljLnRzXG5cclxuXHJcbi8qKlxyXG4gKiBBIEdyYXBoaWMgaXMgdGhlIGJhc2UgRXhjYWxpYnVyIHByaW1pdGl2ZSBmb3Igc29tZXRoaW5nIHRoYXQgY2FuIGJlIGRyYXduIHRvIHRoZSBbW0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dF1dLlxyXG4gKiBbW1Nwcml0ZV1dLCBbW0FuaW1hdGlvbl1dLCBbW0dyYXBoaWNzR3JvdXBdXSwgW1tDYW52YXNdXSwgW1tSZWN0YW5nbGVdXSwgW1tDaXJjbGVdXSwgYW5kIFtbUG9seWdvbl1dIGFsbCBkZXJpdmUgZnJvbSB0aGVcclxuICogW1tHcmFwaGljXV0gYWJzdHJhY3QgY2xhc3MuXHJcbiAqXHJcbiAqIEltcGxlbWVudG9ycyBvZiBhIEdyYXBoaWMgbXVzdCBvdmVycmlkZSB0aGUgYWJzdHJhY3QgW1tHcmFwaGljLl9kcmF3SW1hZ2VdXSBtZXRob2QgdG8gcmVuZGVyIGFuIGltYWdlIHRvIHRoZSBncmFwaGljcyBjb250ZXh0LiBHcmFwaGljXHJcbiAqIGhhbmRsZXMgYWxsIHRoZSBwb3NpdGlvbiwgcm90YXRpb24sIGFuZCBzY2FsZSB0cmFuc2Zvcm1hdGlvbnMgaW4gW1tHcmFwaGljLl9wcmVEcmF3XV0gYW5kIFtbR3JhcGhpYy5fcG9zdERyYXddXVxyXG4gKi9cclxuY2xhc3MgR3JhcGhpYyB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XHJcbiAgICAgICAgdGhpcy5pZCA9IEdyYXBoaWMuX0lEKys7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHdldGhlciB0byBzaG93IGRlYnVnIGluZm9ybWF0aW9uIGFib3V0IHRoZSBncmFwaGljXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zaG93RGVidWcgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGZsaXBIb3Jpem9udGFsLCB3aGljaCB3aWxsIGZsaXAgdGhlIGdyYXBoaWMgaG9yaXpvbnRhbGx5IChhY3Jvc3MgdGhlIHkgYXhpcylcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZsaXBIb3Jpem9udGFsID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBmbGlwVmVydGljYWwsIHdoaWNoIHdpbGwgZmxpcCB0aGUgZ3JhcGhpYyB2ZXJ0aWNhbGx5IChhY3Jvc3MgdGhlIHggYXhpcylcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZsaXBWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcm90YXRpb24gb2YgdGhlIGdyYXBoaWNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJvdGF0aW9uID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wYWNpdHkgb2YgdGhlIGdyYXBoaWMsIDAgaXMgdHJhbnNwYXJlbnQsIDEgaXMgc29saWQgKG9wYXF1ZSkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHNjYWxlIG9mIHRoZSBncmFwaGljLCB0aGlzIGFmZmVjdHMgdGhlIHdpZHRoIGFuZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBWZWN0b3IuT25lO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3JpZ2luIG9mIHRoZSBncmFwaGljLCBpZiBub3Qgc2V0IHRoZSBjZW50ZXIgb2YgdGhlIGdyYXBoaWMgaXMgdGhlIG9yaWdpblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub3JpZ2luID0gbnVsbDtcclxuICAgICAgICB0aGlzLl93aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gMDtcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLm9yaWdpbiA9IChfYSA9IG9wdGlvbnMub3JpZ2luKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLm9yaWdpbjtcclxuICAgICAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCA9IChfYiA9IG9wdGlvbnMuZmxpcEhvcml6b250YWwpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuZmxpcEhvcml6b250YWw7XHJcbiAgICAgICAgICAgIHRoaXMuZmxpcFZlcnRpY2FsID0gKF9jID0gb3B0aW9ucy5mbGlwVmVydGljYWwpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMuZmxpcFZlcnRpY2FsO1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gKF9kID0gb3B0aW9ucy5yb3RhdGlvbikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpcy5yb3RhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gKF9lID0gb3B0aW9ucy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSAoX2YgPSBvcHRpb25zLnNjYWxlKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0aGlzLnNjYWxlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsb25lR3JhcGhpY09wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgb3JpZ2luOiB0aGlzLm9yaWdpbiA/IHRoaXMub3JpZ2luLmNsb25lKCkgOiBudWxsLFxyXG4gICAgICAgICAgICBmbGlwSG9yaXpvbnRhbDogdGhpcy5mbGlwSG9yaXpvbnRhbCxcclxuICAgICAgICAgICAgZmxpcFZlcnRpY2FsOiB0aGlzLmZsaXBWZXJ0aWNhbCxcclxuICAgICAgICAgICAgcm90YXRpb246IHRoaXMucm90YXRpb24sXHJcbiAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcclxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGUgPyB0aGlzLnNjYWxlLmNsb25lKCkgOiBudWxsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSB3aWR0aCBvZiB0aGUgZ3JhcGhpYyAoYWx3YXlzIHBvc2l0aXZlKVxyXG4gICAgICovXHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuX3dpZHRoICogdGhpcy5zY2FsZS54KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGdyYXBoaWMgKGFsd2F5cyBwb3NpdGl2ZSlcclxuICAgICAqL1xyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gTWF0aC5hYnModGhpcy5faGVpZ2h0ICogdGhpcy5zY2FsZS55KTtcclxuICAgIH1cclxuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3dpZHRoID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBzZXQgaGVpZ2h0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYSBjb3B5IG9mIHRoZSBib3VuZHMgaW4gcGl4ZWxzIG9jY3VwaWVkIGJ5IHRoZSBncmFwaGljIG9uIHRoZSB0aGUgc2NyZWVuLiBUaGlzIGluY2x1ZGVzIHNjYWxlLlxyXG4gICAgICovXHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEJvdW5kaW5nQm94LmZyb21EaW1lbnNpb24odGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIFZlY3Rvci5aZXJvKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyB0aGUgd2hvbGUgZ3JhcGhpYyB0byB0aGUgY29udGV4dCBpbmNsdWRpbmcgdHJhbnNmb3JtXHJcbiAgICAgKiBAcGFyYW0gZXggVGhlIGV4Y2FsaWJ1ciBncmFwaGljcyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgZHJhdyhleCwgeCwgeSkge1xyXG4gICAgICAgIHRoaXMuX3ByZURyYXcoZXgsIHgsIHkpO1xyXG4gICAgICAgIHRoaXMuX2RyYXdJbWFnZShleCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fcG9zdERyYXcoZXgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBhZmZpbmUgdHJhbnNmb3JtYXRpb25zIHRvIHRoZSBncmFwaGljcyBjb250ZXh0IHRvIG1hbmlwdWxhdGUgdGhlIGdyYXBoaWMgYmVmb3JlIFtbR3JhcGhpYy5fZHJhd0ltYWdlXV1cclxuICAgICAqIEBwYXJhbSBleFxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKi9cclxuICAgIF9wcmVEcmF3KGV4LCB4LCB5KSB7XHJcbiAgICAgICAgZXguc2F2ZSgpO1xyXG4gICAgICAgIGV4LnRyYW5zbGF0ZSh4LCB5KTtcclxuICAgICAgICBleC5zY2FsZShNYXRoLmFicyh0aGlzLnNjYWxlLngpLCBNYXRoLmFicyh0aGlzLnNjYWxlLnkpKTtcclxuICAgICAgICB0aGlzLl9yb3RhdGUoZXgpO1xyXG4gICAgICAgIHRoaXMuX2ZsaXAoZXgpO1xyXG4gICAgICAgIC8vIGl0IGlzIGltcG9ydGFudCB0byBtdWx0aXBseSBhbHBoYXMgc28gZ3JhcGhpY3MgcmVzcGVjdCB0aGUgY3VycmVudCBjb250ZXh0XHJcbiAgICAgICAgZXgub3BhY2l0eSA9IGV4Lm9wYWNpdHkgKiB0aGlzLm9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICBfcm90YXRlKGV4KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHNjYWxlRGlyWCA9IHRoaXMuc2NhbGUueCA+IDAgPyAxIDogLTE7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVEaXJZID0gdGhpcy5zY2FsZS55ID4gMCA/IDEgOiAtMTtcclxuICAgICAgICBjb25zdCBvcmlnaW4gPSAoX2EgPSB0aGlzLm9yaWdpbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdmVjKHRoaXMud2lkdGggLyAyLCB0aGlzLmhlaWdodCAvIDIpO1xyXG4gICAgICAgIGV4LnRyYW5zbGF0ZShvcmlnaW4ueCwgb3JpZ2luLnkpO1xyXG4gICAgICAgIGV4LnJvdGF0ZSh0aGlzLnJvdGF0aW9uKTtcclxuICAgICAgICAvLyBUaGlzIGlzIGZvciBoYW5kbGluZyBkaXJlY3Rpb24gY2hhbmdlcyAxIG9yIC0xLCB0aGF0IHdheSB3ZSBkb24ndCBoYXZlIG1pc21hdGNoZWQgdHJhbnNsYXRlcygpXHJcbiAgICAgICAgZXguc2NhbGUoc2NhbGVEaXJYLCBzY2FsZURpclkpO1xyXG4gICAgICAgIGV4LnRyYW5zbGF0ZSgtb3JpZ2luLngsIC1vcmlnaW4ueSk7XHJcbiAgICB9XHJcbiAgICBfZmxpcChleCkge1xyXG4gICAgICAgIGlmICh0aGlzLmZsaXBIb3Jpem9udGFsKSB7XHJcbiAgICAgICAgICAgIGV4LnRyYW5zbGF0ZSh0aGlzLndpZHRoIC8gdGhpcy5zY2FsZS54LCAwKTtcclxuICAgICAgICAgICAgZXguc2NhbGUoLTEsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5mbGlwVmVydGljYWwpIHtcclxuICAgICAgICAgICAgZXgudHJhbnNsYXRlKDAsIHRoaXMuaGVpZ2h0IC8gdGhpcy5zY2FsZS55KTtcclxuICAgICAgICAgICAgZXguc2NhbGUoMSwgLTEpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgYW55IGFkZHRpb25hbCB3b3JrIGFmdGVyIFtbR3JhcGhpYy5fZHJhd0ltYWdlXV0gYW5kIHJlc3RvcmUgdGhlIGNvbnRleHQgc3RhdGUuXHJcbiAgICAgKiBAcGFyYW0gZXhcclxuICAgICAqL1xyXG4gICAgX3Bvc3REcmF3KGV4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0RlYnVnKSB7XHJcbiAgICAgICAgICAgIGV4LmRlYnVnLmRyYXdSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG59XHJcbkdyYXBoaWMuX0lEID0gMDtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL1dhdGNoLnRzXG4vKipcclxuICogV2F0Y2ggYW4gb2JqZWN0IHdpdGggYSBwcm94eSwgb25seSBmaXJlcyBpZiBwcm9wZXJ0eSB2YWx1ZSBpcyBkaWZmZXJlbnRcclxuICovXHJcbmZ1bmN0aW9uIHdhdGNoKHR5cGUsIGNoYW5nZSkge1xyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGU7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZS5fX2lzUHJveHkgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIGV4cGFuZG8gaGFjayB0byBtYXJrIGEgcHJveHlcclxuICAgICAgICByZXR1cm4gbmV3IFByb3h5KHR5cGUsIHtcclxuICAgICAgICAgICAgc2V0OiAob2JqLCBwcm9wLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgYmVoYXZpb3IgdG8gc3RvcmUgdGhlIHZhbHVlXHJcbiAgICAgICAgICAgICAgICBpZiAob2JqW3Byb3BdICE9PSB2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIHdhdGNoaW5nIHByaXZhdGUganVua1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcHJvcCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BbMF0gIT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlKG9iaik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZSBzdWNjZXNzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0OiAob2JqLCBwcm9wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPT0gJ19faXNQcm94eScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0eXBlO1xyXG59XHJcbi8qKlxyXG4gKiBXYXRjaCBhbiBvYmplY3Qgd2l0aCBhIHByb3h5LCBmaXJlcyBjaGFuZ2Ugb24gYW55IHByb3BlcnR5IHZhbHVlIGNoYW5nZVxyXG4gKi9cclxuZnVuY3Rpb24gd2F0Y2hBbnkodHlwZSwgY2hhbmdlKSB7XHJcbiAgICBpZiAoIXR5cGUpIHtcclxuICAgICAgICByZXR1cm4gdHlwZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlLl9faXNQcm94eSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgLy8gZXhwYW5kbyBoYWNrIHRvIG1hcmsgYSBwcm94eVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJveHkodHlwZSwge1xyXG4gICAgICAgICAgICBzZXQ6IChvYmosIHByb3AsIHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBiZWhhdmlvciB0byBzdG9yZSB0aGUgdmFsdWVcclxuICAgICAgICAgICAgICAgIG9ialtwcm9wXSA9IHZhbHVlO1xyXG4gICAgICAgICAgICAgICAgLy8gQXZvaWQgd2F0Y2hpbmcgcHJpdmF0ZSBqdW5rXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BbMF0gIT09ICdfJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2Uob2JqKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJbmRpY2F0ZSBzdWNjZXNzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0OiAob2JqLCBwcm9wKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCAhPT0gJ19faXNQcm94eScpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb2JqW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0eXBlO1xyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvUmFzdGVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEEgUmFzdGVyIGlzIGEgR3JhcGhpYyB0aGF0IG5lZWRzIHRvIGJlIGZpcnN0IHBhaW50ZWQgdG8gYSBIVE1MQ2FudmFzRWxlbWVudCBiZWZvcmUgaXQgY2FuIGJlIGRyYXduIHRvIHRoZVxyXG4gKiBbW0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dF1dLiBUaGlzIGlzIHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBjdXN0b20gaW1hZ2VzIHVzaW5nIHRoZSAyRCBjYW52YXMgYXBpLlxyXG4gKlxyXG4gKiBJbXBsZW1lbnRvcnMgbXVzdCBpbXBsZW1lbmV0IHRoZSBbW1Jhc3Rlci5leGVjdXRlXV0gbWV0aG9kIHRvIHJhc3Rlcml6ZSB0aGVpciBkcmF3aW5nLlxyXG4gKi9cclxuY2xhc3MgUmFzdGVyIGV4dGVuZHMgR3JhcGhpYyB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9zbW9vdGhpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jb2xvciA9IHdhdGNoKENvbG9yLkJsYWNrLCAoKSA9PiB0aGlzLmZsYWdEaXJ0eSgpKTtcclxuICAgICAgICB0aGlzLl9saW5lV2lkdGggPSAxO1xyXG4gICAgICAgIHRoaXMuX2xpbmVEYXNoID0gW107XHJcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IDA7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgdGhpcy5jb2xvciA9IChfYSA9IG9wdGlvbnMuY29sb3IpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IENvbG9yLkJsYWNrO1xyXG4gICAgICAgICAgICB0aGlzLnN0cm9rZUNvbG9yID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0cm9rZUNvbG9yO1xyXG4gICAgICAgICAgICB0aGlzLnNtb290aGluZyA9IChfYiA9IG9wdGlvbnMuc21vb3RoaW5nKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLnNtb290aGluZztcclxuICAgICAgICAgICAgdGhpcy5saW5lV2lkdGggPSAoX2MgPSBvcHRpb25zLmxpbmVXaWR0aCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdGhpcy5saW5lV2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMubGluZURhc2ggPSAoX2QgPSBvcHRpb25zLmxpbmVEYXNoKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiB0aGlzLmxpbmVEYXNoO1xyXG4gICAgICAgICAgICB0aGlzLnBhZGRpbmcgPSAoX2UgPSBvcHRpb25zLnBhZGRpbmcpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMucGFkZGluZztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYml0bWFwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgICAgICAgLy8gZ2V0IHRoZSBkZWZhdWx0IGNhbnZhcyB3aWR0aC9oZWlnaHQgYXMgYSBmYWxsYmFja1xyXG4gICAgICAgIGNvbnN0IGJpdG1hcFdpZHRoID0gKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndpZHRoKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0aGlzLl9iaXRtYXAud2lkdGg7XHJcbiAgICAgICAgY29uc3QgYml0bWFwSGVpZ2h0ID0gKF9nID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmhlaWdodCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogdGhpcy5fYml0bWFwLmhlaWdodDtcclxuICAgICAgICAvLyBSYXN0ZXJzIHVzZSBwb3dlciBvZiB0d28gaW1hZ2VzIGFzIGFuIG9wdGltaXphdGlvbiBmb3Igd2ViZ2xcclxuICAgICAgICB0aGlzLndpZHRoID0gZW5zdXJlUG93ZXJPZlR3byhiaXRtYXBXaWR0aCk7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBlbnN1cmVQb3dlck9mVHdvKGJpdG1hcEhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgbWF5YmVDdHggPSB0aGlzLl9iaXRtYXAuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICBpZiAoIW1heWJlQ3R4KSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IDJkIGNhbnZhcyBkcmF3aW5nLCBjYW5ub3QgY3JlYXRlIFJhc3RlciBncmFwaGljJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9jdHggPSBtYXliZUN0eDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbG9uZVJhc3Rlck9wdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29sb3I6IHRoaXMuY29sb3IgPyB0aGlzLmNvbG9yLmNsb25lKCkgOiBudWxsLFxyXG4gICAgICAgICAgICBzdHJva2VDb2xvcjogdGhpcy5zdHJva2VDb2xvciA/IHRoaXMuc3Ryb2tlQ29sb3IuY2xvbmUoKSA6IG51bGwsXHJcbiAgICAgICAgICAgIHNtb290aGluZzogdGhpcy5zbW9vdGhpbmcsXHJcbiAgICAgICAgICAgIGxpbmVXaWR0aDogdGhpcy5saW5lV2lkdGgsXHJcbiAgICAgICAgICAgIGxpbmVEYXNoOiB0aGlzLmxpbmVEYXNoLFxyXG4gICAgICAgICAgICBwYWRkaW5nOiB0aGlzLnBhZGRpbmdcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIGdyYXBoaWMgaXMgZGlydHksIHRoaXMgbWVhbnMgdGhlcmUgYXJlIGNoYW5nZXMgdGhhdCBoYXZlbid0IGJlZW4gcmUtcmFzdGVyaXplZFxyXG4gICAgICovXHJcbiAgICBnZXQgZGlydHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcnR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGbGFncyB0aGUgZ3JhcGhpYyBhcyBkaXJ0eSwgbWVhbmluZyBpdCBtdXN0IGJlIHJlLXJhc3Rlcml6ZWQgYmVmb3JlIGRyYXcuXHJcbiAgICAgKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYW55IHRpbWUgdGhlIGdyYXBoaWNzIHN0YXRlIGNoYW5nZXMgc3VjaCB0aGF0IGl0IGFmZmVjdHMgdGhlIG91dHB1dGVkIGRyYXdpbmdcclxuICAgICAqL1xyXG4gICAgZmxhZ0RpcnR5KCkge1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBjdXJyZW50IHdpZHRoIG9mIHRoZSBSYXN0ZXIgZ3JhcGhpYy4gU2V0dGluZyB0aGUgd2lkdGggd2lsbCBjYXVzZSB0aGUgcmFzdGVyXHJcbiAgICAgKiB0byBiZSBmbGFnZ2VkIGRpcnR5IGNhdXNpbmcgYSByZS1yYXN0ZXIgb24gdGhlIG5leHQgZHJhdy5cclxuICAgICAqXHJcbiAgICAgKiBBbnkgYHBhZGRpbmdgcyBzZXQgd2lsbCBiZSBmYWN0b3JlZCBpbnRvIHRoZSB3aWR0aFxyXG4gICAgICovXHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFRvdGFsV2lkdGgoKTtcclxuICAgIH1cclxuICAgIHNldCB3aWR0aCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2JpdG1hcC53aWR0aCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsV2lkdGggPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGN1cnJlbnQgaGVpZ2h0IG9mIHRoZSBSYXN0ZXIgZ3JhcGhpYy4gU2V0dGluZyB0aGUgaGVpZ2h0IHdpbGwgY2F1c2UgdGhlIHJhc3RlclxyXG4gICAgICogdG8gYmUgZmxhZ2dlZCBkaXJ0eSBjYXVzaW5nIGEgcmUtcmFzdGVyIG9uIHRoZSBuZXh0IGRyYXcuXHJcbiAgICAgKlxyXG4gICAgICogQW55IGBwYWRkaW5nYCBzZXQgd2lsbCBiZSBmYWN0b3JlZCBpbnRvIHRoZSBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0VG90YWxIZWlnaHQoKTtcclxuICAgIH1cclxuICAgIHNldCBoZWlnaHQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9iaXRtYXAuaGVpZ2h0ID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxIZWlnaHQgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgX2dldFRvdGFsV2lkdGgoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fb3JpZ2luYWxXaWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5fYml0bWFwLndpZHRoKSArIHRoaXMucGFkZGluZyAqIDI7XHJcbiAgICB9XHJcbiAgICBfZ2V0VG90YWxIZWlnaHQoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5fb3JpZ2luYWxIZWlnaHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuX2JpdG1hcC5oZWlnaHQpICsgdGhpcy5wYWRkaW5nICogMjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbG9jYWwgYm91bmRzIG9mIHRoZSBSYXN0ZXIgaW5jbHVkaW5nIHRoZSBwYWRkaW5nXHJcbiAgICAgKi9cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICByZXR1cm4gQm91bmRpbmdCb3guZnJvbURpbWVuc2lvbih0aGlzLl9nZXRUb3RhbFdpZHRoKCkgKiB0aGlzLnNjYWxlLngsIHRoaXMuX2dldFRvdGFsSGVpZ2h0KCkgKiB0aGlzLnNjYWxlLnksIFZlY3Rvci5aZXJvKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBzbW9vdGhpbmcgKGFudGktYWxpYXNpbmcgb2YgdGhlIGdyYXBoaWMpLiBTZXR0aW5nIHRoZSBoZWlnaHQgd2lsbCBjYXVzZSB0aGUgcmFzdGVyXHJcbiAgICAgKiB0byBiZSBmbGFnZ2VkIGRpcnR5IGNhdXNpbmcgYSByZS1yYXN0ZXIgb24gdGhlIG5leHQgZHJhdy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHNtb290aGluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc21vb3RoaW5nO1xyXG4gICAgfVxyXG4gICAgc2V0IHNtb290aGluZyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3Ntb290aGluZyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZmlsbFN0eWxlIG9mIHRoZSBSYXN0ZXIgZ3JhcGhpYy4gU2V0dGluZyB0aGUgZmlsbFN0eWxlIHdpbGwgY2F1c2UgdGhlIHJhc3RlciB0byBiZVxyXG4gICAgICogZmxhZ2dlZCBkaXJ0eSBjYXVzaW5nIGEgcmUtcmFzdGVyIG9uIHRoZSBuZXh0IGRyYXcuXHJcbiAgICAgKi9cclxuICAgIGdldCBjb2xvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sb3I7XHJcbiAgICB9XHJcbiAgICBzZXQgY29sb3IodmFsdWUpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKCEoKF9hID0gdGhpcy5fY29sb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lcXVhbCh2YWx1ZSkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbG9yID0gd2F0Y2godmFsdWUsICgpID0+IHRoaXMuZmxhZ0RpcnR5KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIG9yIHNldHMgdGhlIHN0cm9rZVN0eWxlIG9mIHRoZSBSYXN0ZXIgZ3JhcGhpYy4gU2V0dGluZyB0aGUgc3Ryb2tlU3R5bGUgd2lsbCBjYXVzZSB0aGUgcmFzdGVyIHRvIGJlXHJcbiAgICAgKiBmbGFnZ2VkIGRpcnR5IGNhdXNpbmcgYSByZS1yYXN0ZXIgb24gdGhlIG5leHQgZHJhdy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHN0cm9rZUNvbG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdHJva2VDb2xvcjtcclxuICAgIH1cclxuICAgIHNldCBzdHJva2VDb2xvcih2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoISgoX2EgPSB0aGlzLl9zdHJva2VDb2xvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVxdWFsKHZhbHVlKSkpIHtcclxuICAgICAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc3Ryb2tlQ29sb3IgPSB3YXRjaCh2YWx1ZSwgKCkgPT4gdGhpcy5mbGFnRGlydHkoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbGluZSB3aWR0aCBvZiB0aGUgUmFzdGVyIGdyYXBoaWMuIFNldHRpbmcgdGhlIGxpbmVXaWR0aCB3aWxsIGNhdXNlIHRoZSByYXN0ZXIgdG8gYmVcclxuICAgICAqIGZsYWdnZWQgZGlydHkgY2F1c2luZyBhIHJlLXJhc3RlciBvbiB0aGUgbmV4dCBkcmF3LlxyXG4gICAgICovXHJcbiAgICBnZXQgbGluZVdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lV2lkdGg7XHJcbiAgICB9XHJcbiAgICBzZXQgbGluZVdpZHRoKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbGluZVdpZHRoID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgIH1cclxuICAgIGdldCBsaW5lRGFzaCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGluZURhc2g7XHJcbiAgICB9XHJcbiAgICBzZXQgbGluZURhc2godmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9saW5lRGFzaCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcGFkZGluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFkZGluZztcclxuICAgIH1cclxuICAgIHNldCBwYWRkaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJhc3Rlcml6ZSB0aGUgZ3JhcGhpYyB0byBhIGJpdG1hcCBtYWtpbmcgaXQgdXN1YWJsZSBhcyBpbiBleGNhbGlidXIuIFJhc3Rlcml6ZSBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBpZlxyXG4gICAgICogdGhlIGdyYXBoaWMgaXMgW1tSYXN0ZXIuZGlydHldXSBvbiB0aGUgbmV4dCBbW0dyYXBoaWMuZHJhd11dIGNhbGxcclxuICAgICAqL1xyXG4gICAgcmFzdGVyaXplKCkge1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLl9nZXRUb3RhbFdpZHRoKCksIHRoaXMuX2dldFRvdGFsSGVpZ2h0KCkpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fYXBwbHlSYXN0ZXJQcm9wZXJpdGVzKHRoaXMuX2N0eCk7XHJcbiAgICAgICAgdGhpcy5leGVjdXRlKHRoaXMuX2N0eCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICAvLyBUaGUgd2ViZ2wgdGV4dHVyZSBuZWVkcyB0byBiZSB1cGRhdGVkIGlmIGl0IGV4aXN0cyBhZnRlciBhIHJhc3RlciBjeWNsZVxyXG4gICAgICAgIFRleHR1cmVMb2FkZXIubG9hZCh0aGlzLl9iaXRtYXAsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5UmFzdGVyUHJvcGVyaXRlcyhjdHgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICB0aGlzLl9iaXRtYXAud2lkdGggPSB0aGlzLl9nZXRUb3RhbFdpZHRoKCk7XHJcbiAgICAgICAgdGhpcy5fYml0bWFwLmhlaWdodCA9IHRoaXMuX2dldFRvdGFsSGVpZ2h0KCk7XHJcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLnBhZGRpbmcsIHRoaXMucGFkZGluZyk7XHJcbiAgICAgICAgY3R4LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IHRoaXMuc21vb3RoaW5nO1xyXG4gICAgICAgIGN0eC5saW5lV2lkdGggPSB0aGlzLmxpbmVXaWR0aDtcclxuICAgICAgICBjdHguc2V0TGluZURhc2goKF9hID0gdGhpcy5saW5lRGFzaCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3R4LmdldExpbmVEYXNoKCkpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IChfYiA9IHRoaXMuc3Ryb2tlQ29sb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSAoX2MgPSB0aGlzLmNvbG9yKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudG9TdHJpbmcoKTtcclxuICAgIH1cclxuICAgIF9kcmF3SW1hZ2UoZXgsIHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5yYXN0ZXJpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXguZHJhd0ltYWdlKHRoaXMuX2JpdG1hcCwgeCwgeSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9DYW52YXMudHNcblxyXG4vKipcclxuICogQSBjYW52YXMgW1tHcmFwaGljXV0gdG8gcHJvdmlkZSBhbiBhZGFwdGVyIGJldHdlZW4gdGhlIDJEIENhbnZhcyBBUEkgYW5kIHRoZSBbW0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dF1dLlxyXG4gKlxyXG4gKiBUaGUgW1tDYW52YXNdXSB3b3JrcyBieSByZS1yYXN0ZXJpbmcgYSBkcmF3IGhhbmRsZXIgdG8gYSBIVE1MQ2FudmFzRWxlbWVudCBmb3IgZXZlcnkgZHJhdyB3aGljaCBpcyB0aGVuIHBhc3NlZFxyXG4gKiB0byB0aGUgW1tFeGNhbGlidXJHcmFwaGljc0NvbnRleHRdXSBpbXBsZW1lbnRhdGlvbiBhcyBhIHJlbmRlcmVkIGltYWdlLlxyXG4gKlxyXG4gKiAqKkxvdyBwZXJmb3JtYW5jZSBBUEkqKlxyXG4gKi9cclxuY2xhc3MgQ2FudmFzIGV4dGVuZHMgUmFzdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKF9vcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoX29wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSAyRCBncmFwaGljcyBjb250ZXh0IG9mIHRoaXMgY2FudmFzXHJcbiAgICAgKi9cclxuICAgIGdldCBjdHgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eDtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ2FudmFzKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9vcHRpb25zKSwgdGhpcy5jbG9uZUdyYXBoaWNPcHRpb25zKCkpLCB0aGlzLmNsb25lUmFzdGVyT3B0aW9ucygpKSk7XHJcbiAgICB9XHJcbiAgICBleGVjdXRlKGN0eCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kcmF3KSB7XHJcbiAgICAgICAgICAgIChfYiA9IHRoaXMuX29wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kcmF3KGN0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5jYWNoZSkge1xyXG4gICAgICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0V2ZW50cy50c1xudmFyIEV2ZW50VHlwZXM7XHJcbihmdW5jdGlvbiAoRXZlbnRUeXBlcykge1xyXG4gICAgRXZlbnRUeXBlc1tcIktpbGxcIl0gPSBcImtpbGxcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQcmVLaWxsXCJdID0gXCJwcmVraWxsXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9zdEtpbGxcIl0gPSBcInBvc3RraWxsXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUHJlRHJhd1wiXSA9IFwicHJlZHJhd1wiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvc3REcmF3XCJdID0gXCJwb3N0ZHJhd1wiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlByZURlYnVnRHJhd1wiXSA9IFwicHJlZGVidWdkcmF3XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9zdERlYnVnRHJhd1wiXSA9IFwicG9zdGRlYnVnZHJhd1wiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlByZVVwZGF0ZVwiXSA9IFwicHJldXBkYXRlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9zdFVwZGF0ZVwiXSA9IFwicG9zdHVwZGF0ZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlByZUZyYW1lXCJdID0gXCJwcmVmcmFtZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvc3RGcmFtZVwiXSA9IFwicG9zdGZyYW1lXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUHJlQ29sbGlzaW9uXCJdID0gXCJwcmVjb2xsaXNpb25cIjtcclxuICAgIEV2ZW50VHlwZXNbXCJDb2xsaXNpb25TdGFydFwiXSA9IFwiY29sbGlzaW9uc3RhcnRcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJDb2xsaXNpb25FbmRcIl0gPSBcImNvbGxpc2lvbmVuZFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvc3RDb2xsaXNpb25cIl0gPSBcInBvc3Rjb2xsaXNpb25cIjtcclxuICAgIEV2ZW50VHlwZXNbXCJJbml0aWFsaXplXCJdID0gXCJpbml0aWFsaXplXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiQWN0aXZhdGVcIl0gPSBcImFjdGl2YXRlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiRGVhY3RpdmF0ZVwiXSA9IFwiZGVhY3RpdmF0ZVwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkV4aXRWaWV3cG9ydFwiXSA9IFwiZXhpdHZpZXdwb3J0XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiRW50ZXJWaWV3cG9ydFwiXSA9IFwiZW50ZXJ2aWV3cG9ydFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkV4aXRUcmlnZ2VyXCJdID0gXCJleGl0XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiRW50ZXJUcmlnZ2VyXCJdID0gXCJlbnRlclwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIkNvbm5lY3RcIl0gPSBcImNvbm5lY3RcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJEaXNjb25uZWN0XCJdID0gXCJkaXNjb25uZWN0XCI7XHJcbiAgICBFdmVudFR5cGVzW1wiQnV0dG9uXCJdID0gXCJidXR0b25cIjtcclxuICAgIEV2ZW50VHlwZXNbXCJBeGlzXCJdID0gXCJheGlzXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiU3Vic2NyaWJlXCJdID0gXCJzdWJzY3JpYmVcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJVbnN1YnNjcmliZVwiXSA9IFwidW5zdWJzY3JpYmVcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJWaXNpYmxlXCJdID0gXCJ2aXNpYmxlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiSGlkZGVuXCJdID0gXCJoaWRkZW5cIjtcclxuICAgIEV2ZW50VHlwZXNbXCJTdGFydFwiXSA9IFwic3RhcnRcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJTdG9wXCJdID0gXCJzdG9wXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlclVwXCJdID0gXCJwb2ludGVydXBcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyRG93blwiXSA9IFwicG9pbnRlcmRvd25cIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyTW92ZVwiXSA9IFwicG9pbnRlcm1vdmVcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyRW50ZXJcIl0gPSBcInBvaW50ZXJlbnRlclwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJMZWF2ZVwiXSA9IFwicG9pbnRlcmxlYXZlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlckNhbmNlbFwiXSA9IFwicG9pbnRlcmNhbmNlbFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJXaGVlbFwiXSA9IFwicG9pbnRlcndoZWVsXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiVXBcIl0gPSBcInVwXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiRG93blwiXSA9IFwiZG93blwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIk1vdmVcIl0gPSBcIm1vdmVcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJFbnRlclwiXSA9IFwiZW50ZXJcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJMZWF2ZVwiXSA9IFwibGVhdmVcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJDYW5jZWxcIl0gPSBcImNhbmNlbFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIldoZWVsXCJdID0gXCJ3aGVlbFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlByZXNzXCJdID0gXCJwcmVzc1wiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlJlbGVhc2VcIl0gPSBcInJlbGVhc2VcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJIb2xkXCJdID0gXCJob2xkXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlckRyYWdTdGFydFwiXSA9IFwicG9pbnRlcmRyYWdzdGFydFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJEcmFnRW5kXCJdID0gXCJwb2ludGVyZHJhZ2VuZFwiO1xyXG4gICAgRXZlbnRUeXBlc1tcIlBvaW50ZXJEcmFnRW50ZXJcIl0gPSBcInBvaW50ZXJkcmFnZW50ZXJcIjtcclxuICAgIEV2ZW50VHlwZXNbXCJQb2ludGVyRHJhZ0xlYXZlXCJdID0gXCJwb2ludGVyZHJhZ2xlYXZlXCI7XHJcbiAgICBFdmVudFR5cGVzW1wiUG9pbnRlckRyYWdNb3ZlXCJdID0gXCJwb2ludGVyZHJhZ21vdmVcIjtcclxufSkoRXZlbnRUeXBlcyB8fCAoRXZlbnRUeXBlcyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBCYXNlIGV2ZW50IHR5cGUgaW4gRXhjYWxpYnVyIHRoYXQgYWxsIG90aGVyIGV2ZW50IHR5cGVzIGRlcml2ZSBmcm9tLiBOb3QgYWxsIGV2ZW50IHR5cGVzIGFyZSB0aHJvd24gb24gYWxsIEV4Y2FsaWJ1ciBnYW1lIG9iamVjdHMsXHJcbiAqIHNvbWUgZXZlbnRzIGFyZSB1bmlxdWUgdG8gYSB0eXBlLCBvdGhlcnMgYXJlIG5vdC5cclxuICpcclxuICovXHJcbmNsYXNzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9idWJibGVzID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSWYgc2V0IHRvIGZhbHNlLCBwcmV2ZW50cyBldmVudCBmcm9tIHByb3BhZ2F0aW5nIHRvIG90aGVyIGFjdG9ycy4gSWYgdHJ1ZSBpdCB3aWxsIGJlIHByb3BhZ2F0ZWRcclxuICAgICAqIHRvIGFsbCBhY3RvcnMgdGhhdCBhcHBseS5cclxuICAgICAqL1xyXG4gICAgZ2V0IGJ1YmJsZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1YmJsZXM7XHJcbiAgICB9XHJcbiAgICBzZXQgYnViYmxlcyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2J1YmJsZXMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJldmVudHMgZXZlbnQgZnJvbSBidWJibGluZ1xyXG4gICAgICovXHJcbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XHJcbiAgICAgICAgdGhpcy5idWJibGVzID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSAna2lsbCcgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMgd2hlbiBpdCBpcyBraWxsZWQuIFRoZSB0YXJnZXQgaXMgdGhlIGFjdG9yIHRoYXQgd2FzIGtpbGxlZC5cclxuICovXHJcbmNsYXNzIEtpbGxFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3ByZWtpbGwnIGV2ZW50IGlzIGVtaXR0ZWQgZGlyZWN0bHkgYmVmb3JlIGFuIGFjdG9yIGlzIGtpbGxlZC5cclxuICovXHJcbmNsYXNzIFByZUtpbGxFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3Bvc3RraWxsJyBldmVudCBpcyBlbWl0dGVkIGRpcmVjdGx5IGFmdGVyIHRoZSBhY3RvciBpcyBraWxsZWQuXHJcbiAqL1xyXG5jbGFzcyBQb3N0S2lsbEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSAnc3RhcnQnIGV2ZW50IGlzIGVtaXR0ZWQgb24gZW5naW5lIHdoZW4gaGFzIHN0YXJ0ZWQgYW5kIGlzIHJlYWR5IGZvciBpbnRlcmFjdGlvbi5cclxuICovXHJcbmNsYXNzIEdhbWVTdGFydEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSAnc3RvcCcgZXZlbnQgaXMgZW1pdHRlZCBvbiBlbmdpbmUgd2hlbiBoYXMgYmVlbiBzdG9wcGVkIGFuZCB3aWxsIG5vIGxvbmdlciB0YWtlIGlucHV0LCB1cGRhdGUgb3IgZHJhdy5cclxuICovXHJcbmNsYXNzIEdhbWVTdG9wRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwcmVkcmF3JyBldmVudCBpcyBlbWl0dGVkIG9uIGFjdG9ycywgc2NlbmVzLCBhbmQgZW5naW5lIGJlZm9yZSBkcmF3aW5nIHN0YXJ0cy4gQWN0b3JzJyBwcmVkcmF3IGhhcHBlbnMgaW5zaWRlIHRoZWlyIGdyYXBoaWNzXHJcbiAqIHRyYW5zZm9ybSBzbyB0aGF0IGFsbCBkcmF3aW5nIHRha2VzIHBsYWNlIHdpdGggdGhlIGFjdG9yIGFzIHRoZSBvcmlnaW4uXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBQcmVEcmF3RXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoY3R4LCBkZWx0YSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmN0eCA9IGN0eDtcclxuICAgICAgICB0aGlzLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSAncG9zdGRyYXcnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGFuZCBlbmdpbmUgYWZ0ZXIgZHJhd2luZyBmaW5pc2hlcy4gQWN0b3JzJyBwb3N0ZHJhdyBoYXBwZW5zIGluc2lkZSB0aGVpciBncmFwaGljc1xyXG4gKiB0cmFuc2Zvcm0gc28gdGhhdCBhbGwgZHJhd2luZyB0YWtlcyBwbGFjZSB3aXRoIHRoZSBhY3RvciBhcyB0aGUgb3JpZ2luLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgUG9zdERyYXdFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihjdHgsIGRlbHRhLCB0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xyXG4gICAgICAgIHRoaXMuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwcmVkZWJ1Z2RyYXcnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGFuZCBlbmdpbmUgYmVmb3JlIGRlYnVnIGRyYXdpbmcgc3RhcnRzLlxyXG4gKi9cclxuY2xhc3MgUHJlRGVidWdEcmF3RXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoY3R4LCB0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3Bvc3RkZWJ1Z2RyYXcnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGFuZCBlbmdpbmUgYWZ0ZXIgZGVidWcgZHJhd2luZyBzdGFydHMuXHJcbiAqL1xyXG5jbGFzcyBQb3N0RGVidWdEcmF3RXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoY3R4LCB0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY3R4ID0gY3R4O1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3ByZXVwZGF0ZScgZXZlbnQgaXMgZW1pdHRlZCBvbiBhY3RvcnMsIHNjZW5lcywgY2FtZXJhLCBhbmQgZW5naW5lIGJlZm9yZSB0aGUgdXBkYXRlIHN0YXJ0cy5cclxuICovXHJcbmNsYXNzIFByZVVwZGF0ZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgZGVsdGEsIHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgdGhpcy5kZWx0YSA9IGRlbHRhO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUaGUgJ3Bvc3R1cGRhdGUnIGV2ZW50IGlzIGVtaXR0ZWQgb24gYWN0b3JzLCBzY2VuZXMsIGNhbWVyYSwgYW5kIGVuZ2luZSBhZnRlciB0aGUgdXBkYXRlIGVuZHMuXHJcbiAqL1xyXG5jbGFzcyBQb3N0VXBkYXRlRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lLCBkZWx0YSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLmRlbHRhID0gZGVsdGE7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFRoZSAncHJlZnJhbWUnIGV2ZW50IGlzIGVtaXR0ZWQgb24gdGhlIGVuZ2luZSwgYmVmb3JlIHRoZSBmcmFtZSBiZWdpbnMuXHJcbiAqL1xyXG5jbGFzcyBQcmVGcmFtZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVuZ2luZSwgcHJldlN0YXRzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLnByZXZTdGF0cyA9IHByZXZTdGF0cztcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGVuZ2luZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlICdwb3N0ZnJhbWUnIGV2ZW50IGlzIGVtaXR0ZWQgb24gdGhlIGVuZ2luZSwgYWZ0ZXIgYSBmcmFtZSBlbmRzLlxyXG4gKi9cclxuY2xhc3MgUG9zdEZyYW1lRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lLCBzdGF0cykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgdGhpcy5zdGF0cyA9IHN0YXRzO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZW5naW5lO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCByZWNlaXZlZCB3aGVuIGEgZ2FtZXBhZCBpcyBjb25uZWN0ZWQgdG8gRXhjYWxpYnVyLiBbW0dhbWVwYWRzXV0gcmVjZWl2ZXMgdGhpcyBldmVudC5cclxuICovXHJcbmNsYXNzIEdhbWVwYWRDb25uZWN0RXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXgsIGdhbWVwYWQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLmdhbWVwYWQgPSBnYW1lcGFkO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZ2FtZXBhZDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgcmVjZWl2ZWQgd2hlbiBhIGdhbWVwYWQgaXMgZGlzY29ubmVjdGVkIGZyb20gRXhjYWxpYnVyLiBbW0dhbWVwYWRzXV0gcmVjZWl2ZXMgdGhpcyBldmVudC5cclxuICovXHJcbmNsYXNzIEdhbWVwYWREaXNjb25uZWN0RXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoaW5kZXgsIGdhbWVwYWQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcclxuICAgICAgICB0aGlzLmdhbWVwYWQgPSBnYW1lcGFkO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gZ2FtZXBhZDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2FtZXBhZCBidXR0b24gZXZlbnQuIFNlZSBbW0dhbWVwYWRzXV0gZm9yIGluZm9ybWF0aW9uIG9uIHJlc3BvbmRpbmcgdG8gY29udHJvbGxlciBpbnB1dC4gW1tHYW1lcGFkXV0gaW5zdGFuY2VzIHJlY2VpdmUgdGhpcyBldmVudDtcclxuICovXHJcbmNsYXNzIEdhbWVwYWRCdXR0b25FdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBidXR0b24gIFRoZSBHYW1lcGFkIGJ1dHRvblxyXG4gICAgICogQHBhcmFtIHZhbHVlICAgQSBudW1lcmljIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihidXR0b24sIHZhbHVlLCB0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuYnV0dG9uID0gYnV0dG9uO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2FtZXBhZCBheGlzIGV2ZW50LiBTZWUgW1tHYW1lcGFkc11dIGZvciBpbmZvcm1hdGlvbiBvbiByZXNwb25kaW5nIHRvIGNvbnRyb2xsZXIgaW5wdXQuIFtbR2FtZXBhZF1dIGluc3RhbmNlcyByZWNlaXZlIHRoaXMgZXZlbnQ7XHJcbiAqL1xyXG5jbGFzcyBHYW1lcGFkQXhpc0V2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGF4aXMgIFRoZSBHYW1lcGFkIGF4aXNcclxuICAgICAqIEBwYXJhbSB2YWx1ZSBBIG51bWVyaWMgdmFsdWUgYmV0d2VlbiAtMSBhbmQgMVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihheGlzLCB2YWx1ZSwgdGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmF4aXMgPSBheGlzO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogU3Vic2NyaWJlIGV2ZW50IHRocm93biB3aGVuIGhhbmRsZXJzIGZvciBldmVudHMgb3RoZXIgdGhhbiBzdWJzY3JpYmUgYXJlIGFkZGVkLiBNZXRhIGV2ZW50IHRoYXQgaXMgcmVjZWl2ZWQgYnlcclxuICogW1tFdmVudERpc3BhdGNoZXJ8ZXZlbnQgZGlzcGF0Y2hlcnNdXS5cclxuICovXHJcbmNsYXNzIFN1YnNjcmliZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRvcGljLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRvcGljID0gdG9waWM7XHJcbiAgICAgICAgdGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVW5zdWJzY3JpYmUgZXZlbnQgdGhyb3duIHdoZW4gaGFuZGxlcnMgZm9yIGV2ZW50cyBvdGhlciB0aGFuIHVuc3Vic2NyaWJlIGFyZSByZW1vdmVkLiBNZXRhIGV2ZW50IHRoYXQgaXMgcmVjZWl2ZWQgYnlcclxuICogW1tFdmVudERpc3BhdGNoZXJ8ZXZlbnQgZGlzcGF0Y2hlcnNdXS5cclxuICovXHJcbmNsYXNzIFVuc3Vic2NyaWJlRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodG9waWMsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMudG9waWMgPSB0b3BpYztcclxuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCByZWNlaXZlZCBieSB0aGUgW1tFbmdpbmVdXSB3aGVuIHRoZSBicm93c2VyIHdpbmRvdyBpcyB2aXNpYmxlIG9uIGEgc2NyZWVuLlxyXG4gKi9cclxuY2xhc3MgVmlzaWJsZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHJlY2VpdmVkIGJ5IHRoZSBbW0VuZ2luZV1dIHdoZW4gdGhlIGJyb3dzZXIgd2luZG93IGlzIGhpZGRlbiBmcm9tIGFsbCBzY3JlZW5zLlxyXG4gKi9cclxuY2xhc3MgSGlkZGVuRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgdGhyb3duIG9uIGFuIFtbQWN0b3J8YWN0b3JdXSB3aGVuIGEgY29sbGlzaW9uIHdpbGwgb2NjdXIgdGhpcyBmcmFtZSBpZiBpdCByZXNvbHZlc1xyXG4gKi9cclxuY2xhc3MgUHJlQ29sbGlzaW9uRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYWN0b3IgICAgICAgICBUaGUgYWN0b3IgdGhlIGV2ZW50IHdhcyB0aHJvd24gb25cclxuICAgICAqIEBwYXJhbSBvdGhlciAgICAgICAgIFRoZSBhY3RvciB0aGF0IHdpbGwgY29sbGlkZWQgd2l0aCB0aGUgY3VycmVudCBhY3RvclxyXG4gICAgICogQHBhcmFtIHNpZGUgICAgICAgICAgVGhlIHNpZGUgdGhhdCB3aWxsIGJlIGNvbGxpZGVkIHdpdGggdGhlIGN1cnJlbnQgYWN0b3JcclxuICAgICAqIEBwYXJhbSBpbnRlcnNlY3Rpb24gIEludGVyc2VjdGlvbiB2ZWN0b3JcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWN0b3IsIG90aGVyLCBzaWRlLCBpbnRlcnNlY3Rpb24pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xyXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yfGFjdG9yXV0gd2hlbiBhIGNvbGxpc2lvbiBoYXMgYmVlbiByZXNvbHZlZCAoYm9keSByZWFjdGVkKSB0aGlzIGZyYW1lXHJcbiAqL1xyXG5jbGFzcyBQb3N0Q29sbGlzaW9uRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYWN0b3IgICAgICAgICBUaGUgYWN0b3IgdGhlIGV2ZW50IHdhcyB0aHJvd24gb25cclxuICAgICAqIEBwYXJhbSBvdGhlciAgICAgICAgIFRoZSBhY3RvciB0aGF0IGRpZCBjb2xsaWRlIHdpdGggdGhlIGN1cnJlbnQgYWN0b3JcclxuICAgICAqIEBwYXJhbSBzaWRlICAgICAgICAgIFRoZSBzaWRlIHRoYXQgZGlkIGNvbGxpZGUgd2l0aCB0aGUgY3VycmVudCBhY3RvclxyXG4gICAgICogQHBhcmFtIGludGVyc2VjdGlvbiAgSW50ZXJzZWN0aW9uIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihhY3Rvciwgb3RoZXIsIHNpZGUsIGludGVyc2VjdGlvbikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XHJcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgIH1cclxuICAgIGdldCBhY3RvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBzZXQgYWN0b3IoYWN0b3IpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIENvbnRhY3RTdGFydEV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgb3RoZXIsIGNvbnRhY3QpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgdGhpcy5jb250YWN0ID0gY29udGFjdDtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDb250YWN0RW5kRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBvdGhlcikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgIH1cclxufVxyXG5jbGFzcyBDb2xsaXNpb25QcmVTb2x2ZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgb3RoZXIsIHNpZGUsIGludGVyc2VjdGlvbiwgY29udGFjdCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMub3RoZXIgPSBvdGhlcjtcclxuICAgICAgICB0aGlzLnNpZGUgPSBzaWRlO1xyXG4gICAgICAgIHRoaXMuaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xyXG4gICAgICAgIHRoaXMuY29udGFjdCA9IGNvbnRhY3Q7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgQ29sbGlzaW9uUG9zdFNvbHZlRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBvdGhlciwgc2lkZSwgaW50ZXJzZWN0aW9uLCBjb250YWN0KSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5vdGhlciA9IG90aGVyO1xyXG4gICAgICAgIHRoaXMuc2lkZSA9IHNpZGU7XHJcbiAgICAgICAgdGhpcy5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XHJcbiAgICAgICAgdGhpcy5jb250YWN0ID0gY29udGFjdDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgdGhyb3duIHRoZSBmaXJzdCB0aW1lIGFuIFtbQWN0b3J8YWN0b3JdXSBjb2xsaWRlcyB3aXRoIGFub3RoZXIsIGFmdGVyIGFuIGFjdG9yIGlzIGluIGNvbnRhY3Qgbm9ybWFsIGNvbGxpc2lvbiBldmVudHMgYXJlIGZpcmVkLlxyXG4gKi9cclxuY2xhc3MgQ29sbGlzaW9uU3RhcnRFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYWN0b3JcclxuICAgICAqIEBwYXJhbSBvdGhlclxyXG4gICAgICogQHBhcmFtIGNvbnRhY3RcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWN0b3IsIG90aGVyLCBjb250YWN0KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgdGhpcy5jb250YWN0ID0gY29udGFjdDtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgfVxyXG4gICAgZ2V0IGFjdG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhcmdldDtcclxuICAgIH1cclxuICAgIHNldCBhY3RvcihhY3Rvcikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gYWN0b3I7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHRocm93biB3aGVuIHRoZSBbW0FjdG9yfGFjdG9yXV0gaXMgbm8gbG9uZ2VyIGNvbGxpZGluZyB3aXRoIGFub3RoZXJcclxuICovXHJcbmNsYXNzIENvbGxpc2lvbkVuZEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYWN0b3IsIG90aGVyKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLm90aGVyID0gb3RoZXI7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSBhY3RvcjtcclxuICAgIH1cclxuICAgIGdldCBhY3RvcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50YXJnZXQ7XHJcbiAgICB9XHJcbiAgICBzZXQgYWN0b3IoYWN0b3IpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IGFjdG9yO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3Rvcl1dIGFuZCBhIFtbU2NlbmVdXSBvbmx5IG9uY2UgYmVmb3JlIHRoZSBmaXJzdCB1cGRhdGUgY2FsbFxyXG4gKi9cclxuY2xhc3MgSW5pdGlhbGl6ZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGVuZ2luZSAgVGhlIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBlbmdpbmVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lLCB0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCB0aHJvd24gb24gYSBbW1NjZW5lXV0gb24gYWN0aXZhdGlvblxyXG4gKi9cclxuY2xhc3MgQWN0aXZhdGVFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBvbGRTY2VuZSAgVGhlIHJlZmVyZW5jZSB0byB0aGUgb2xkIHNjZW5lXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9sZFNjZW5lLCB0YXJnZXQpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMub2xkU2NlbmUgPSBvbGRTY2VuZTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogRXZlbnQgdGhyb3duIG9uIGEgW1tTY2VuZV1dIG9uIGRlYWN0aXZhdGlvblxyXG4gKi9cclxuY2xhc3MgRGVhY3RpdmF0ZUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG5ld1NjZW5lICBUaGUgcmVmZXJlbmNlIHRvIHRoZSBuZXcgc2NlbmVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmV3U2NlbmUsIHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5uZXdTY2VuZSA9IG5ld1NjZW5lO1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBFdmVudCB0aHJvd24gb24gYW4gW1tBY3Rvcl1dIHdoZW4gaXQgY29tcGxldGVseSBsZWF2ZXMgdGhlIHNjcmVlbi5cclxuICovXHJcbmNsYXNzIEV4aXRWaWV3UG9ydEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEV2ZW50IHRocm93biBvbiBhbiBbW0FjdG9yXV0gd2hlbiBpdCBjb21wbGV0ZWx5IGxlYXZlcyB0aGUgc2NyZWVuLlxyXG4gKi9cclxuY2xhc3MgRW50ZXJWaWV3UG9ydEV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRW50ZXJUcmlnZ2VyRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBhY3Rvcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIEV4aXRUcmlnZ2VyRXZlbnQgZXh0ZW5kcyBHYW1lRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBhY3Rvcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5hY3RvciA9IGFjdG9yO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRXZlbnREaXNwYXRjaGVyLnRzXG5cclxuY2xhc3MgRXZlbnREaXNwYXRjaGVyIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCAgVGhlIG9iamVjdCB0aGF0IHdpbGwgYmUgdGhlIHJlY2lwaWVudCBvZiBldmVudHMgZnJvbSB0aGlzIGV2ZW50IGRpc3BhdGNoZXJcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTtcclxuICAgICAgICB0aGlzLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyBhbnkgZXhpc3RpbmcgaGFuZGxlcnMgb3Igd2lyZWQgZXZlbnQgZGlzcGF0Y2hlcnMgb24gdGhpcyBldmVudCBkaXNwYXRjaGVyXHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzID0ge307XHJcbiAgICAgICAgdGhpcy5fd2lyZWRFdmVudERpc3BhdGNoZXJzID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGZvciB0YXJnZXRcclxuICAgICAqIEBwYXJhbSBldmVudE5hbWUgIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBwdWJsaXNoXHJcbiAgICAgKiBAcGFyYW0gZXZlbnQgICAgICBPcHRpb25hbGx5IHBhc3MgYW4gZXZlbnQgZGF0YSBvYmplY3QgdG8gdGhlIGhhbmRsZXJcclxuICAgICAqL1xyXG4gICAgZW1pdChldmVudE5hbWUsIGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKCFldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgLy8ga2V5IG5vdCBtYXBwZWRcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBldmVudE5hbWUgPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl90YXJnZXQ7XHJcbiAgICAgICAgaWYgKCFldmVudCkge1xyXG4gICAgICAgICAgICBldmVudCA9IG5ldyBHYW1lRXZlbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKCFldmVudC50YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoX2EpIHtcclxuICAgICAgICAgICAgLy8gcGFzc1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgaSwgbGVuO1xyXG4gICAgICAgIGlmICh0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdKSB7XHJcbiAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICBsZW4gPSB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdLmxlbmd0aDtcclxuICAgICAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV1baV0uY2FsbCh0YXJnZXQsIGV2ZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpID0gMDtcclxuICAgICAgICBsZW4gPSB0aGlzLl93aXJlZEV2ZW50RGlzcGF0Y2hlcnMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpcmVkRXZlbnREaXNwYXRjaGVyc1tpXS5lbWl0KGV2ZW50TmFtZSwgZXZlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU3Vic2NyaWJlIGFuIGV2ZW50IGhhbmRsZXIgdG8gYSBwYXJ0aWN1bGFyIGV2ZW50IG5hbWUsIG11bHRpcGxlIGhhbmRsZXJzIHBlciBldmVudCBuYW1lIGFyZSBhbGxvd2VkLlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHN1YnNjcmliZSB0b1xyXG4gICAgICogQHBhcmFtIGhhbmRsZXIgICAgVGhlIGhhbmRsZXIgY2FsbGJhY2sgdG8gZmlyZSBvbiB0aGlzIGV2ZW50XHJcbiAgICAgKi9cclxuICAgIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGlmICghdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ucHVzaChoYW5kbGVyKTtcclxuICAgICAgICAvLyBtZXRhIGV2ZW50IGhhbmRsZXJzXHJcbiAgICAgICAgaWYgKGV2ZW50TmFtZSAhPT0gJ3Vuc3Vic2NyaWJlJyAmJiBldmVudE5hbWUgIT09ICdzdWJzY3JpYmUnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3Vic2NyaWJlJywgbmV3IFN1YnNjcmliZUV2ZW50KGV2ZW50TmFtZSwgaGFuZGxlcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVW5zdWJzY3JpYmUgYW4gZXZlbnQgaGFuZGxlcihzKSBmcm9tIGFuIGV2ZW50LiBJZiBhIHNwZWNpZmljIGhhbmRsZXJcclxuICAgICAqIGlzIHNwZWNpZmllZCBmb3IgYW4gZXZlbnQsIG9ubHkgdGhhdCBoYW5kbGVyIHdpbGwgYmUgdW5zdWJzY3JpYmVkLlxyXG4gICAgICogT3RoZXJ3aXNlIGFsbCBoYW5kbGVycyB3aWxsIGJlIHVuc3Vic2NyaWJlZCBmb3IgdGhhdCBldmVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lICBUaGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gdW5zdWJzY3JpYmVcclxuICAgICAqIEBwYXJhbSBoYW5kbGVyICAgIE9wdGlvbmFsbHkgdGhlIHNwZWNpZmljIGhhbmRsZXIgdG8gdW5zdWJzY3JpYmVcclxuICAgICAqL1xyXG4gICAgb2ZmKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGNvbnN0IGV2ZW50SGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVyc1tldmVudE5hbWVdO1xyXG4gICAgICAgIGlmIChldmVudEhhbmRsZXJzKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIG5vIGV4cGxpY2l0IGhhbmRsZXIgaXMgZ2l2ZSB3aXRoIHRoZSBldmVudCBuYW1lIGNsZWFyIGFsbCBoYW5kbGVyc1xyXG4gICAgICAgICAgICBpZiAoIWhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50TmFtZV0ubGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnRIYW5kbGVycy5pbmRleE9mKGhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlcnNbZXZlbnROYW1lXS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG1ldGEgZXZlbnQgaGFuZGxlcnNcclxuICAgICAgICBpZiAoZXZlbnROYW1lICE9PSAndW5zdWJzY3JpYmUnICYmIGV2ZW50TmFtZSAhPT0gJ3N1YnNjcmliZScpIHtcclxuICAgICAgICAgICAgdGhpcy5lbWl0KCd1bnN1YnNjcmliZScsIG5ldyBVbnN1YnNjcmliZUV2ZW50KGV2ZW50TmFtZSwgaGFuZGxlcikpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25jZSBsaXN0ZW5zIHRvIGFuIGV2ZW50IG9uZSB0aW1lLCB0aGVuIHVuc3Vic2NyaWJlcyBmcm9tIHRoYXQgZXZlbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG8gb25jZVxyXG4gICAgICogQHBhcmFtIGhhbmRsZXIgICBUaGUgaGFuZGxlciBvZiB0aGUgZXZlbnQgdGhhdCB3aWxsIGJlIGF1dG8gdW5zdWJzY3JpYmVkXHJcbiAgICAgKi9cclxuICAgIG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgY29uc3QgbWV0YUhhbmRsZXIgPSAoZXZlbnQpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXYgPSBldmVudCB8fCBuZXcgR2FtZUV2ZW50KCk7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBldi50YXJnZXQgPSBldi50YXJnZXQgfHwgdGhpcy5fdGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgLy8gcGFzc1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICAgICAgICAgIGhhbmRsZXIuY2FsbChldi50YXJnZXQsIGV2KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMub24oZXZlbnROYW1lLCBtZXRhSGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdpcmVzIHRoaXMgZXZlbnQgZGlzcGF0Y2hlciB0byBhbHNvIHJlY2VpdmUgZXZlbnRzIGZyb20gYW5vdGhlclxyXG4gICAgICovXHJcbiAgICB3aXJlKGV2ZW50RGlzcGF0Y2hlcikge1xyXG4gICAgICAgIGV2ZW50RGlzcGF0Y2hlci5fd2lyZWRFdmVudERpc3BhdGNoZXJzLnB1c2godGhpcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVud2lyZXMgdGhpcyBldmVudCBkaXNwYXRjaGVyIGZyb20gYW5vdGhlclxyXG4gICAgICovXHJcbiAgICB1bndpcmUoZXZlbnREaXNwYXRjaGVyKSB7XHJcbiAgICAgICAgY29uc3QgaW5kZXggPSBldmVudERpc3BhdGNoZXIuX3dpcmVkRXZlbnREaXNwYXRjaGVycy5pbmRleE9mKHRoaXMpO1xyXG4gICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgIGV2ZW50RGlzcGF0Y2hlci5fd2lyZWRFdmVudERpc3BhdGNoZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUmVzb3VyY2VzL1Jlc291cmNlLnRzXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgW1tSZXNvdXJjZV1dIHR5cGUgYWxsb3dzIGdhbWVzIGJ1aWx0IGluIEV4Y2FsaWJ1ciB0byBsb2FkIGdlbmVyaWMgcmVzb3VyY2VzLlxyXG4gKiBGb3IgYW55IHR5cGUgb2YgcmVtb3RlIHJlc291cmNlIGl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBbW1Jlc291cmNlXV0gZm9yIHByZWxvYWRpbmcuXHJcbiAqL1xyXG5jbGFzcyBSZXNvdXJjZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXRoICAgICAgICAgIFBhdGggdG8gdGhlIHJlbW90ZSByZXNvdXJjZVxyXG4gICAgICogQHBhcmFtIHJlc3BvbnNlVHlwZSAgVGhlIHR5cGUgdG8gZXhwZWN0IGFzIGEgcmVzcG9uc2U6IFwiXCIgfCBcImFycmF5YnVmZmVyXCIgfCBcImJsb2JcIiB8IFwiZG9jdW1lbnRcIiB8IFwianNvblwiIHwgXCJ0ZXh0XCI7XHJcbiAgICAgKiBAcGFyYW0gYnVzdENhY2hlICAgICBXaGV0aGVyIG9yIG5vdCB0byBjYWNoZS1idXN0IHJlcXVlc3RzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIHJlc3BvbnNlVHlwZSwgYnVzdENhY2hlID0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5yZXNwb25zZVR5cGUgPSByZXNwb25zZVR5cGU7XHJcbiAgICAgICAgdGhpcy5idXN0Q2FjaGUgPSBidXN0Q2FjaGU7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gbnVsbDtcclxuICAgICAgICB0aGlzLmxvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcih0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBSZXNvdXJjZSBpcyBjb21wbGV0ZWx5IGxvYWRlZCBhbmQgaXMgcmVhZHlcclxuICAgICAqIHRvIGJlIGRyYXduLlxyXG4gICAgICovXHJcbiAgICBpc0xvYWRlZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhICE9PSBudWxsO1xyXG4gICAgfVxyXG4gICAgX2NhY2hlQnVzdCh1cmkpIHtcclxuICAgICAgICBjb25zdCBxdWVyeSA9IC9cXD9cXHcqPVxcdyovO1xyXG4gICAgICAgIGlmIChxdWVyeS50ZXN0KHVyaSkpIHtcclxuICAgICAgICAgICAgdXJpICs9ICcmX189JyArIERhdGUubm93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1cmkgKz0gJz9fXz0nICsgRGF0ZS5ub3coKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVyaTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmVnaW4gbG9hZGluZyB0aGUgcmVzb3VyY2UgYW5kIHJldHVybnMgYSBwcm9taXNlIHRvIGJlIHJlc29sdmVkIG9uIGNvbXBsZXRpb25cclxuICAgICAqL1xyXG4gICAgbG9hZCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBFeGl0IGVhcmx5IGlmIHdlIGFscmVhZHkgaGF2ZSBkYXRhXHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdBbHJlYWR5IGhhdmUgZGF0YSBmb3IgcmVzb3VyY2UnLCB0aGlzLnBhdGgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnY29tcGxldGUnLCB0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5vcGVuKCdHRVQnLCB0aGlzLmJ1c3RDYWNoZSA/IHRoaXMuX2NhY2hlQnVzdCh0aGlzLnBhdGgpIDogdGhpcy5wYXRoLCB0cnVlKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSB0aGlzLnJlc3BvbnNlVHlwZTtcclxuICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCAoZSkgPT4gdGhpcy5ldmVudHMuZW1pdCgnbG9hZHN0YXJ0JywgZSkpO1xyXG4gICAgICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgKGUpID0+IHRoaXMuZXZlbnRzLmVtaXQoJ3Byb2dyZXNzJywgZSkpO1xyXG4gICAgICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGUpID0+IHRoaXMuZXZlbnRzLmVtaXQoJ2Vycm9yJywgZSkpO1xyXG4gICAgICAgICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoZSkgPT4gdGhpcy5ldmVudHMuZW1pdCgnbG9hZCcsIGUpKTtcclxuICAgICAgICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gWEhSIG9uIGZpbGU6Ly8gc3VjY2VzcyBzdGF0dXMgaXMgMCwgc3VjaCBhcyB3aXRoIFBoYW50b21KU1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAwICYmIHJlcXVlc3Quc3RhdHVzICE9PSAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignRmFpbGVkIHRvIGxvYWQgcmVzb3VyY2UgJywgdGhpcy5wYXRoLCAnIHNlcnZlciByZXNwb25kZWQgd2l0aCBlcnJvciBjb2RlJywgcmVxdWVzdC5zdGF0dXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2Vycm9yJywgcmVxdWVzdC5yZXNwb25zZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihyZXF1ZXN0LnN0YXR1c1RleHQpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSByZXF1ZXN0LnJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnY29tcGxldGUnLCB0aGlzLmRhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ0NvbXBsZXRlZCBsb2FkaW5nIHJlc291cmNlJywgdGhpcy5wYXRoKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJlcXVlc3Quc2VuZCgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRHJhd2luZy9TcHJpdGVFZmZlY3RzLnRzXG4vKipcclxuICogQG1vZHVsZVxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKiBUaGVzZSBlZmZlY3RzIGNhbiBiZSBhcHBsaWVkIHRvIGFueSBiaXRtYXAgaW1hZ2UgYnV0IGFyZSBtYWlubHkgdXNlZFxyXG4gKiBmb3IgW1tTcHJpdGVdXSBlZmZlY3RzIG9yIFtbQW5pbWF0aW9uXV0gZWZmZWN0cy5cclxuICovXHJcbnZhciBTcHJpdGVFZmZlY3RzX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG4vKipcclxuICogQHR5cGVkb2NcclxuICovXHJcblxyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIFwiR3JheXNjYWxlXCIgZWZmZWN0IHRvIGEgc3ByaXRlLCByZW1vdmluZyBjb2xvciBpbmZvcm1hdGlvbi5cclxuICogQGRlcHJlY2F0ZWQgW1tHcmF5c2NhbGVdXSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxubGV0IEdyYXlzY2FsZSA9IGNsYXNzIEdyYXlzY2FsZSB7XHJcbiAgICB1cGRhdGVQaXhlbCh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICBjb25zdCBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgY29uc3QgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICBjb25zdCBhdmcgPSAocGl4ZWxbZmlyc3RQaXhlbCArIDBdICsgcGl4ZWxbZmlyc3RQaXhlbCArIDFdICsgcGl4ZWxbZmlyc3RQaXhlbCArIDJdKSAvIDM7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gYXZnO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSA9IGF2ZztcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBhdmc7XHJcbiAgICB9XHJcbn07XHJcbkdyYXlzY2FsZSA9IFNwcml0ZUVmZmVjdHNfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdHcmF5c2NhbGUgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnXHJcbiAgICB9KVxyXG5dLCBHcmF5c2NhbGUpO1xyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIFwiSW52ZXJ0XCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBpbnZlcnRpbmcgdGhlIHBpeGVsIGNvbG9ycy5cclxuICogQGRlcHJlY2F0ZWQgW1tJbnZlcnRdXSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxubGV0IEludmVydCA9IGNsYXNzIEludmVydCB7XHJcbiAgICB1cGRhdGVQaXhlbCh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICBjb25zdCBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgY29uc3QgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMF0gPSAyNTUgLSBwaXhlbFtmaXJzdFBpeGVsICsgMF07XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gMjU1IC0gcGl4ZWxbZmlyc3RQaXhlbCArIDFdO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IDI1NSAtIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXTtcclxuICAgIH1cclxufTtcclxuSW52ZXJ0ID0gU3ByaXRlRWZmZWN0c19kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0ludmVydCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCdcclxuICAgIH0pXHJcbl0sIEludmVydCk7XHJcblxyXG4vKipcclxuICogQXBwbGllcyB0aGUgXCJPcGFjaXR5XCIgZWZmZWN0IHRvIGEgc3ByaXRlLCBzZXR0aW5nIHRoZSBhbHBoYSBvZiBhbGwgcGl4ZWxzIHRvIGEgZ2l2ZW4gdmFsdWUuXHJcbiAqIEBkZXByZWNhdGVkIFtbT3BhY2l0eV1dIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG5sZXQgT3BhY2l0eSA9IGNsYXNzIE9wYWNpdHkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gb3BhY2l0eSAgVGhlIG5ldyBvcGFjaXR5IG9mIHRoZSBzcHJpdGUgZnJvbSAwLTEuMFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcGFjaXR5KSB7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVBpeGVsKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICBjb25zdCBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgIGlmIChwaXhlbFtmaXJzdFBpeGVsICsgM10gIT09IDApIHtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDNdID0gTWF0aC5yb3VuZCh0aGlzLm9wYWNpdHkgKiBwaXhlbFtmaXJzdFBpeGVsICsgM10pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcclxuT3BhY2l0eSA9IFNwcml0ZUVmZmVjdHNfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdPcGFjaXR5IHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJ1xyXG4gICAgfSlcclxuXSwgT3BhY2l0eSk7XHJcblxyXG4vKipcclxuICogQXBwbGllcyB0aGUgXCJDb2xvcml6ZVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCB0aGUgcGl4ZWxzIHRvIGFuXHJcbiAqIGF2ZXJhZ2Ugb2YgdGhlIG9yaWdpbmFsIGNvbG9yIGFuZCB0aGUgcHJvdmlkZWQgY29sb3JcclxuICogQGRlcHJlY2F0ZWQgW1tDb2xvcml6ZV1dIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG5sZXQgQ29sb3JpemUgPSBjbGFzcyBDb2xvcml6ZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIGNvbG9yIHRvIGFwcGx5IHRvIHRoZSBzcHJpdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29sb3IpIHtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQaXhlbCh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICBjb25zdCBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgY29uc3QgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICBpZiAocGl4ZWxbZmlyc3RQaXhlbCArIDNdICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IChwaXhlbFtmaXJzdFBpeGVsICsgMF0gKyB0aGlzLmNvbG9yLnIpIC8gMjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gKHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSArIHRoaXMuY29sb3IuZykgLyAyO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSAocGl4ZWxbZmlyc3RQaXhlbCArIDJdICsgdGhpcy5jb2xvci5iKSAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5Db2xvcml6ZSA9IFNwcml0ZUVmZmVjdHNfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdDb2xvcml6ZSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCdcclxuICAgIH0pXHJcbl0sIENvbG9yaXplKTtcclxuXHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSBcIkxpZ2h0ZW5cIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGxpZ2h0bmVzcyBvZiB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gKiBAZGVwcmVjYXRlZCBbW0xpZ2h0ZW5dXSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxubGV0IExpZ2h0ZW4gPSBjbGFzcyBMaWdodGVuIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGZhY3RvciBvZiB0aGUgZWZmZWN0IGJldHdlZW4gMC0xXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIHRoaXMuZmFjdG9yID0gZmFjdG9yO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGl4ZWwoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgIGNvbnN0IHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBDb2xvci5mcm9tUkdCKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDFdLCBwaXhlbFtmaXJzdFBpeGVsICsgMl0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSkubGlnaHRlbih0aGlzLmZhY3Rvcik7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDBdID0gY29sb3IucjtcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMV0gPSBjb2xvci5nO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSA9IGNvbG9yLmI7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDNdID0gY29sb3IuYTtcclxuICAgIH1cclxufTtcclxuTGlnaHRlbiA9IFNwcml0ZUVmZmVjdHNfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdMaWdodGVuIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJ1xyXG4gICAgfSlcclxuXSwgTGlnaHRlbik7XHJcblxyXG4vKipcclxuICogQXBwbGllcyB0aGUgXCJEYXJrZW5cIiBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGRhcmtuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAqIEBkZXByZWNhdGVkIFtbRGFya2VuXV0gd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmxldCBEYXJrZW4gPSBjbGFzcyBEYXJrZW4ge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gZmFjdG9yICBUaGUgZmFjdG9yIG9mIHRoZSBlZmZlY3QgYmV0d2VlbiAwLTFcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgdGhpcy5mYWN0b3IgPSBmYWN0b3I7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQaXhlbCh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICBjb25zdCBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgY29uc3QgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICBjb25zdCBjb2xvciA9IENvbG9yLmZyb21SR0IocGl4ZWxbZmlyc3RQaXhlbCArIDBdLCBwaXhlbFtmaXJzdFBpeGVsICsgMV0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAyXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDNdKS5kYXJrZW4odGhpcy5mYWN0b3IpO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGNvbG9yLnI7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gY29sb3IuZztcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IGNvbG9yLmE7XHJcbiAgICB9XHJcbn07XHJcbkRhcmtlbiA9IFNwcml0ZUVmZmVjdHNfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdEYXJrZW4gd2lsbCBiZSByZW1vdmVkIHYwLjI2LjAnXHJcbiAgICB9KVxyXG5dLCBEYXJrZW4pO1xyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIFwiU2F0dXJhdGVcIiBlZmZlY3QgdG8gYSBzcHJpdGUsIHNhdHVyYXRlcyB0aGUgY29sb3IgYWNjb3JkaW5nIHRvIEhTTFxyXG4gKiBAZGVwcmVjYXRlZCBbW1NhdHVyYXRlXV0gd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmxldCBTYXR1cmF0ZSA9IGNsYXNzIFNhdHVyYXRlIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGZhY3RvciAgVGhlIGZhY3RvciBvZiB0aGUgZWZmZWN0IGJldHdlZW4gMC0xXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIHRoaXMuZmFjdG9yID0gZmFjdG9yO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlUGl4ZWwoeCwgeSwgaW1hZ2VEYXRhKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQaXhlbCA9ICh4ICsgeSAqIGltYWdlRGF0YS53aWR0aCkgKiA0O1xyXG4gICAgICAgIGNvbnN0IHBpeGVsID0gaW1hZ2VEYXRhLmRhdGE7XHJcbiAgICAgICAgY29uc3QgY29sb3IgPSBDb2xvci5mcm9tUkdCKHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDFdLCBwaXhlbFtmaXJzdFBpeGVsICsgMl0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSkuc2F0dXJhdGUodGhpcy5mYWN0b3IpO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGNvbG9yLnI7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gY29sb3IuZztcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IGNvbG9yLmE7XHJcbiAgICB9XHJcbn07XHJcblNhdHVyYXRlID0gU3ByaXRlRWZmZWN0c19kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ1NhdHVyYXRlIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJ1xyXG4gICAgfSlcclxuXSwgU2F0dXJhdGUpO1xyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIFwiRGVzYXR1cmF0ZVwiIGVmZmVjdCB0byBhIHNwcml0ZSwgZGVzYXR1cmF0ZXMgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICogQGRlcHJlY2F0ZWQgW1tEZXNhdHVyYXRlXV0gd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmxldCBEZXNhdHVyYXRlID0gY2xhc3MgRGVzYXR1cmF0ZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBmYWN0b3IgIFRoZSBmYWN0b3Igb2YgdGhlIGVmZmVjdCBiZXR3ZWVuIDAtMVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICB0aGlzLmZhY3RvciA9IGZhY3RvcjtcclxuICAgIH1cclxuICAgIHVwZGF0ZVBpeGVsKHgsIHksIGltYWdlRGF0YSkge1xyXG4gICAgICAgIGNvbnN0IGZpcnN0UGl4ZWwgPSAoeCArIHkgKiBpbWFnZURhdGEud2lkdGgpICogNDtcclxuICAgICAgICBjb25zdCBwaXhlbCA9IGltYWdlRGF0YS5kYXRhO1xyXG4gICAgICAgIGNvbnN0IGNvbG9yID0gQ29sb3IuZnJvbVJHQihwaXhlbFtmaXJzdFBpeGVsICsgMF0sIHBpeGVsW2ZpcnN0UGl4ZWwgKyAxXSwgcGl4ZWxbZmlyc3RQaXhlbCArIDJdLCBwaXhlbFtmaXJzdFBpeGVsICsgM10pLmRlc2F0dXJhdGUodGhpcy5mYWN0b3IpO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IGNvbG9yLnI7XHJcbiAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gY29sb3IuZztcclxuICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSBjb2xvci5iO1xyXG4gICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAzXSA9IGNvbG9yLmE7XHJcbiAgICB9XHJcbn07XHJcbkRlc2F0dXJhdGUgPSBTcHJpdGVFZmZlY3RzX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnRGVzYXR1cmF0ZSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCdcclxuICAgIH0pXHJcbl0sIERlc2F0dXJhdGUpO1xyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgdGhlIFwiRmlsbFwiIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBub24tdHJhbnNwYXJlbnQgcGl4ZWxzIHRvIG1hdGNoXHJcbiAqIGEgZ2l2ZW4gY29sb3JcclxuICogQGRlcHJlY2F0ZWQgW1tGaWxsXV0gd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmxldCBGaWxsID0gY2xhc3MgRmlsbCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb2xvciAgVGhlIGNvbG9yIHRvIGFwcGx5IHRvIHRoZSBzcHJpdGVcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29sb3IpIHtcclxuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVQaXhlbCh4LCB5LCBpbWFnZURhdGEpIHtcclxuICAgICAgICBjb25zdCBmaXJzdFBpeGVsID0gKHggKyB5ICogaW1hZ2VEYXRhLndpZHRoKSAqIDQ7XHJcbiAgICAgICAgY29uc3QgcGl4ZWwgPSBpbWFnZURhdGEuZGF0YTtcclxuICAgICAgICBpZiAocGl4ZWxbZmlyc3RQaXhlbCArIDNdICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHBpeGVsW2ZpcnN0UGl4ZWwgKyAwXSA9IHRoaXMuY29sb3IucjtcclxuICAgICAgICAgICAgcGl4ZWxbZmlyc3RQaXhlbCArIDFdID0gdGhpcy5jb2xvci5nO1xyXG4gICAgICAgICAgICBwaXhlbFtmaXJzdFBpeGVsICsgMl0gPSB0aGlzLmNvbG9yLmI7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5GaWxsID0gU3ByaXRlRWZmZWN0c19kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0ZpbGwgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnXHJcbiAgICB9KVxyXG5dLCBGaWxsKTtcclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRHJhd2luZy9UZXh0dXJlLnRzXG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgW1tUZXh0dXJlXV0gb2JqZWN0IGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBpbWFnZSByZXNvdXJjZXMuXHJcbiAqIFtbVGV4dHVyZV1dIGlzIGFuIFtbTG9hZGFibGVdXSB3aGljaCBtZWFucyBpdCBjYW4gYmUgcGFzc2VkIHRvIGEgW1tMb2FkZXJdXVxyXG4gKiB0byBwcmUtbG9hZCBiZWZvcmUgc3RhcnRpbmcgYSBsZXZlbCBvciBnYW1lLlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKi9cclxuY2xhc3MgVGV4dHVyZSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXRoICAgICAgIFBhdGggdG8gdGhlIGltYWdlIHJlc291cmNlIG9yIGEgYmFzZTY0IHN0cmluZyByZXByZXNlbnRpbmcgYW4gaW1hZ2UgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCLi4uXCJcclxuICAgICAqIEBwYXJhbSBidXN0Q2FjaGUgIE9wdGlvbmFsbHkgbG9hZCB0ZXh0dXJlIHdpdGggY2FjaGUgYnVzdGluZ1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBidXN0Q2FjaGUgPSB0cnVlKSB7XHJcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcclxuICAgICAgICB0aGlzLmJ1c3RDYWNoZSA9IGJ1c3RDYWNoZTtcclxuICAgICAgICB0aGlzLl9zcHJpdGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMubG9hZGVkID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZFJlc29sdmUgPSByZXNvbHZlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlID0gbmV3IFJlc291cmNlKHBhdGgsICdibG9iJywgYnVzdENhY2hlKTtcclxuICAgICAgICB0aGlzLl9zcHJpdGUgPSBuZXcgU3ByaXRlX1Nwcml0ZSh0aGlzLCAwLCAwLCAwLCAwKTtcclxuICAgIH1cclxuICAgIGdldCBpbWFnZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIFRleHR1cmUgaXMgY29tcGxldGVseSBsb2FkZWQgYW5kIGlzIHJlYWR5XHJcbiAgICAgKiB0byBiZSBkcmF3bi5cclxuICAgICAqL1xyXG4gICAgaXNMb2FkZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuICEhdGhpcy5kYXRhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCZWdpbnMgbG9hZGluZyB0aGUgdGV4dHVyZSBhbmQgcmV0dXJucyBhIHByb21pc2UgdG8gYmUgcmVzb2x2ZWQgb24gY29tcGxldGlvblxyXG4gICAgICovXHJcbiAgICBsb2FkKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAvLyBMb2FkIGJhc2U2NCBvciBibG9iIGlmIG5lZWRlZFxyXG4gICAgICAgICAgICAgICAgbGV0IHVybDtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5wYXRoLmluY2x1ZGVzKCdkYXRhOmltYWdlLycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvYiA9IHlpZWxkIHRoaXMuX3Jlc291cmNlLmxvYWQoKTtcclxuICAgICAgICAgICAgICAgICAgICB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gdGhpcy5wYXRoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gRGVjb2RlIHRoZSBpbWFnZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IHVybDtcclxuICAgICAgICAgICAgICAgIHlpZWxkIGltYWdlLmRlY29kZSgpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2V0IHJlc3VsdHNcclxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IGltYWdlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMuX3Nwcml0ZS53aWR0aCA9IGltYWdlLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fc3ByaXRlLmhlaWdodCA9IGltYWdlLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGUgPSBuZXcgU3ByaXRlX1Nwcml0ZSh0aGlzLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBQcm9taXNlLnJlamVjdCgnRXJyb3IgbG9hZGluZyB0ZXh0dXJlJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdG9kbyBlbWl0IGNvbXBsZXRlXHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZFJlc29sdmUodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGFzU3ByaXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zcHJpdGU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db25maWd1cmFibGUudHNcbi8qKlxyXG4gKiBDb25maWd1cmFibGUgaGVscGVyIGV4dGVuZHMgYmFzZSB0eXBlIGFuZCBtYWtlcyBhbGwgcHJvcGVydGllcyBhdmFpbGFibGUgYXMgb3B0aW9uIGJhZyBhcmd1bWVudHNcclxuICogQGludGVybmFsXHJcbiAqIEBwYXJhbSBiYXNlXHJcbiAqL1xyXG5mdW5jdGlvbiBDb25maWd1cmFibGUoYmFzZSkge1xyXG4gICAgcmV0dXJuIGNsYXNzIGV4dGVuZHMgYmFzZSB7XHJcbiAgICAgICAgYXNzaWduKHByb3BzKSB7XHJcbiAgICAgICAgICAgIC8vc2V0IHRoZSB2YWx1ZSBvZiBldmVyeSBwcm9wZXJ0eSB0aGF0IHdhcyBwYXNzZWQgaW4sXHJcbiAgICAgICAgICAgIC8vaWYgdGhlIGNvbnN0cnVjdG9yIHByZXZpb3VzbHkgc2V0IHRoaXMgdmFsdWUsIGl0IHdpbGwgYmUgb3ZlcnJpZGRlbiBoZXJlXHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBpbiBwcm9wcykge1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXNba10gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcclxuICAgICAgICAgICAgICAgICAgICB0aGlzW2tdID0gcHJvcHNba107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xyXG4gICAgICAgICAgICBzdXBlciguLi5hcmdzKTtcclxuICAgICAgICAgICAgLy9nZXQgdGhlIG51bWJlciBvZiBhcmd1bWVudHMgdGhhdCBhcmVuJ3QgdW5kZWZpbmVkLiBUUyBwYXNzZXMgYSB2YWx1ZSB0byBhbGwgcGFyYW1ldGVyc1xyXG4gICAgICAgICAgICAvL29mIHdoYXRldmVyIGN0b3IgaXMgdGhlIGltcGxlbWVudGF0aW9uLCBzbyBhcmdzLmxlbmd0aCBkb2Vzbid0IHdvcmsgaGVyZS5cclxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGFyZ3MuZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH0pLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHNpemUgPT09IDEgJiYgYXJnc1swXSAmJiB0eXBlb2YgYXJnc1swXSA9PT0gJ29iamVjdCcgJiYgIShhcmdzWzBdIGluc3RhbmNlb2YgQXJyYXkpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFzc2lnbihhcmdzWzBdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9EcmF3aW5nL1Nwcml0ZS50c1xudmFyIFNwcml0ZV9kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxudmFyIFNwcml0ZV9hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqIEBkZXByZWNhdGVkIFVzZSBbW1Nwcml0ZV1dXHJcbiAqL1xyXG5jbGFzcyBTcHJpdGVJbXBsIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGltYWdlT3JDb25maWcgIFRoZSBiYWNraW5nIGltYWdlIHRleHR1cmUgdG8gYnVpbGQgdGhlIFNwcml0ZSwgb3IgU3ByaXRlIG9wdGlvbiBiYWdcclxuICAgICAqIEBwYXJhbSB4ICAgICAgVGhlIHggcG9zaXRpb24gb2YgdGhlIHNwcml0ZVxyXG4gICAgICogQHBhcmFtIHkgICAgICBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgc3ByaXRlXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggIFRoZSB3aWR0aCBvZiB0aGUgc3ByaXRlIGluIHBpeGVsc1xyXG4gICAgICogQHBhcmFtIGhlaWdodCBUaGUgaGVpZ2h0IG9mIHRoZSBzcHJpdGUgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGltYWdlT3JDb25maWcsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcclxuICAgICAgICB0aGlzLnggPSAwO1xyXG4gICAgICAgIHRoaXMueSA9IDA7XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDAuMDtcclxuICAgICAgICB0aGlzLmFuY2hvciA9IFZlY3Rvci5IYWxmO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IFZlY3Rvci5PbmU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGVmYXVsdDogZmFsc2UsIHNob3VsZCB0aGUgc3ByaXRlIGJlIGRyYXduIGFyb3VuZCB0aGUgYW5jaG9yIG9yIGZyb20gdGhlIHRvcCBsZWZ0LlxyXG4gICAgICAgICAqIFNwcml0ZSByb3RhdGlvbnMvc2NhbGluZyBzdGlsbCBoYXBwZW4gYXJvdW5kIHRoZSBhbmNob3IgcmVnYXJkbGVzcyBvZiB0aGlzIHNldHRpbmcuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kcmF3QXJvdW5kQW5jaG9yID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBEcmF3cyB0aGUgc3ByaXRlIGZsaXBwZWQgdmVydGljYWxseVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmxpcFZlcnRpY2FsID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRHJhd3MgdGhlIHNwcml0ZSBmbGlwcGVkIGhvcml6b250YWxseVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmxpcEhvcml6b250YWwgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVmZmVjdHMgPSBbXTtcclxuICAgICAgICB0aGlzLndpZHRoID0gMDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlQ2FudmFzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9zcHJpdGVDdHggPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX3BpeGVsRGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcGl4ZWxzTG9hZGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGlydHlFZmZlY3QgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX29wYWNpdHkgPSAxO1xyXG4gICAgICAgIGxldCBpbWFnZSA9IGltYWdlT3JDb25maWc7XHJcbiAgICAgICAgaWYgKGltYWdlT3JDb25maWcgJiYgIShpbWFnZU9yQ29uZmlnIGluc3RhbmNlb2YgVGV4dHVyZSkpIHtcclxuICAgICAgICAgICAgeCA9IGltYWdlT3JDb25maWcueCB8IDA7XHJcbiAgICAgICAgICAgIHkgPSBpbWFnZU9yQ29uZmlnLnkgfCAwO1xyXG4gICAgICAgICAgICB3aWR0aCA9IGltYWdlT3JDb25maWcud2lkdGggfCAwO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBpbWFnZU9yQ29uZmlnLmhlaWdodCB8IDA7XHJcbiAgICAgICAgICAgIGltYWdlID0gaW1hZ2VPckNvbmZpZy5pbWFnZTtcclxuICAgICAgICAgICAgaWYgKCFpbWFnZSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdBbiBpbWFnZSB0ZXh0dXJlIGlzIHJlcXVpcmVkIHRvIGNvbnN0cnVjdCBhIHNwcml0ZSc7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy54ID0geCB8fCAwO1xyXG4gICAgICAgIHRoaXMueSA9IHkgfHwgMDtcclxuICAgICAgICB0aGlzLnRleHR1cmUgPSBpbWFnZTtcclxuICAgICAgICB0aGlzLl9zcHJpdGVDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB0aGlzLl9zcHJpdGVDYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLl9zcHJpdGVDYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZUN0eCA9IHRoaXMuX3Nwcml0ZUNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gICAgICAgIHRoaXMuX2luaXRQaXhlbHNGcm9tVGV4dHVyZSgpO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxuICAgIGdldCBkcmF3V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMud2lkdGggKiB0aGlzLnNjYWxlLngpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRyYXdIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRoaXMuaGVpZ2h0ICogdGhpcy5zY2FsZS55KTtcclxuICAgIH1cclxuICAgIF9pbml0UGl4ZWxzRnJvbVRleHR1cmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIFNwcml0ZV9hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1hZ2UgPSB5aWVsZCB0aGlzLnRleHR1cmUubG9hZGVkO1xyXG4gICAgICAgICAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMud2lkdGggfHwgaW1hZ2UubmF0dXJhbFdpZHRoO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLmhlaWdodCB8fCBpbWFnZS5uYXR1cmFsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ2FudmFzLndpZHRoID0gdGhpcy5fc3ByaXRlQ2FudmFzLndpZHRoIHx8IGltYWdlLm5hdHVyYWxXaWR0aDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUNhbnZhcy5oZWlnaHQgPSB0aGlzLl9zcHJpdGVDYW52YXMuaGVpZ2h0IHx8IGltYWdlLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkUGl4ZWxzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXJ0eUVmZmVjdCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKCdFcnJvciBsb2FkaW5nIHRleHR1cmUgJywgdGhpcy50ZXh0dXJlLnBhdGgsIGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBfbG9hZFBpeGVscygpIHtcclxuICAgICAgICBpZiAodGhpcy50ZXh0dXJlLmlzTG9hZGVkKCkgJiYgIXRoaXMuX3BpeGVsc0xvYWRlZCkge1xyXG4gICAgICAgICAgICBjb25zdCBuYXR1cmFsV2lkdGggPSB0aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbFdpZHRoIHx8IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hdHVyYWxIZWlnaHQgPSB0aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbEhlaWdodCB8fCAwO1xyXG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCA+IG5hdHVyYWxXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihgVGhlIHNwcml0ZSB3aWR0aCAke3RoaXMud2lkdGh9IGV4Y2VlZHMgdGhlIHdpZHRoIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke25hdHVyYWxXaWR0aH0gb2YgdGhlIGJhY2tpbmcgdGV4dHVyZSAke3RoaXMudGV4dHVyZS5wYXRofWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoIDw9IDAgfHwgbmF0dXJhbFdpZHRoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHdpZHRoIG9mIGEgc3ByaXRlIGNhbm5vdCBiZSAwIG9yIG5lZ2F0aXZlLCBzcHJpdGUgd2lkdGg6ICR7dGhpcy53aWR0aH0sIG9yaWdpbmFsIHdpZHRoOiAke25hdHVyYWxXaWR0aH1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5oZWlnaHQgPiBuYXR1cmFsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKGBUaGUgc3ByaXRlIGhlaWdodCAke3RoaXMuaGVpZ2h0fSBleGNlZWRzIHRoZSBoZWlnaHQgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7bmF0dXJhbEhlaWdodH0gb2YgdGhlIGJhY2tpbmcgdGV4dHVyZSAke3RoaXMudGV4dHVyZS5wYXRofWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhlaWdodCA8PSAwIHx8IG5hdHVyYWxIZWlnaHQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaGVpZ2h0IG9mIGEgc3ByaXRlIGNhbm5vdCBiZSAwIG9yIG5lZ2F0aXZlLCBzcHJpdGUgaGVpZ2h0OiAke3RoaXMuaGVpZ2h0fSwgb3JpZ2luYWwgaGVpZ2h0OiAke25hdHVyYWxIZWlnaHR9YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZmx1c2hUZXh0dXJlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsc0xvYWRlZCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2ZsdXNoVGV4dHVyZSgpIHtcclxuICAgICAgICBjb25zdCBuYXR1cmFsV2lkdGggPSB0aGlzLnRleHR1cmUuaW1hZ2UubmF0dXJhbFdpZHRoIHx8IDA7XHJcbiAgICAgICAgY29uc3QgbmF0dXJhbEhlaWdodCA9IHRoaXMudGV4dHVyZS5pbWFnZS5uYXR1cmFsSGVpZ2h0IHx8IDA7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlQ3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlQ3R4LmRyYXdJbWFnZSh0aGlzLnRleHR1cmUuaW1hZ2UsIGNsYW1wKHRoaXMueCwgMCwgbmF0dXJhbFdpZHRoKSwgY2xhbXAodGhpcy55LCAwLCBuYXR1cmFsSGVpZ2h0KSwgY2xhbXAodGhpcy53aWR0aCwgMCwgbmF0dXJhbFdpZHRoKSwgY2xhbXAodGhpcy5oZWlnaHQsIDAsIG5hdHVyYWxIZWlnaHQpLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFtbT3BhY2l0eV1dIGVmZmVjdCB0byBhIHNwcml0ZSwgc2V0dGluZyB0aGUgYWxwaGEgb2YgYWxsIHBpeGVscyB0byBhIGdpdmVuIHZhbHVlXHJcbiAgICAgKi9cclxuICAgIG9wYWNpdHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9vcGFjaXR5ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFtbR3JheXNjYWxlXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCByZW1vdmluZyBjb2xvciBpbmZvcm1hdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ3JheXNjYWxlKCkge1xyXG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBHcmF5c2NhbGUoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFtbSW52ZXJ0XV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBpbnZlcnRpbmcgdGhlIHBpeGVsIGNvbG9ycy5cclxuICAgICAqL1xyXG4gICAgaW52ZXJ0KCkge1xyXG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBJbnZlcnQoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFtbRmlsbF1dIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdpbmcgdGhlIGNvbG9yIGNoYW5uZWxzIG9mIGFsbCBub24tdHJhbnNwYXJlbnQgcGl4ZWxzIHRvIG1hdGNoIGEgZ2l2ZW4gY29sb3JcclxuICAgICAqL1xyXG4gICAgZmlsbChjb2xvcikge1xyXG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBGaWxsKGNvbG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIFtbQ29sb3JpemVdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5naW5nIHRoZSBjb2xvciBjaGFubmVscyBvZiBhbGwgcGl4ZWxzIHRvIGJlIHRoZSBhdmVyYWdlIG9mIHRoZSBvcmlnaW5hbCBjb2xvclxyXG4gICAgICogYW5kIHRoZSBwcm92aWRlZCBjb2xvci5cclxuICAgICAqL1xyXG4gICAgY29sb3JpemUoY29sb3IpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgQ29sb3JpemUoY29sb3IpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgW1tMaWdodGVuXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBsaWdodG5lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAqL1xyXG4gICAgbGlnaHRlbihmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgTGlnaHRlbihmYWN0b3IpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgW1tEYXJrZW5dXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGNoYW5nZXMgdGhlIGRhcmtuZXNzIG9mIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgKi9cclxuICAgIGRhcmtlbihmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgRGFya2VuKGZhY3RvcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBbW1NhdHVyYXRlXV0gZWZmZWN0IHRvIGEgc3ByaXRlLCBzYXR1cmF0ZXMgdGhlIGNvbG9yIGFjY29yZGluZyB0byBIU0xcclxuICAgICAqL1xyXG4gICAgc2F0dXJhdGUoZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IFNhdHVyYXRlKGZhY3RvcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBbW0Rlc2F0dXJhdGVdXSBlZmZlY3QgdG8gYSBzcHJpdGUsIGRlc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gSFNMXHJcbiAgICAgKi9cclxuICAgIGRlc2F0dXJhdGUoZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IERlc2F0dXJhdGUoZmFjdG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBuZXcgW1tTcHJpdGVFZmZlY3RdXSB0byB0aGlzIGRyYXdpbmcuXHJcbiAgICAgKiBAcGFyYW0gZWZmZWN0ICBFZmZlY3QgdG8gYWRkIHRvIHRoZSB0aGlzIGRyYXdpbmdcclxuICAgICAqL1xyXG4gICAgYWRkRWZmZWN0KGVmZmVjdCkge1xyXG4gICAgICAgIHRoaXMuZWZmZWN0cy5wdXNoKGVmZmVjdCk7XHJcbiAgICAgICAgLy8gV2UgbXVzdCBjaGVjayBpZiB0aGUgdGV4dHVyZSBhbmQgdGhlIGJhY2tpbmcgc3ByaXRlIHBpeGVscyBhcmUgbG9hZGVkIGFzIHdlbGwgYmVmb3JlXHJcbiAgICAgICAgLy8gYW4gZWZmZWN0IGNhbiBiZSBhcHBsaWVkXHJcbiAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUuaXNMb2FkZWQoKSB8fCAhdGhpcy5fcGl4ZWxzTG9hZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5RWZmZWN0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5RWZmZWN0cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZUVmZmVjdChwYXJhbSkge1xyXG4gICAgICAgIGxldCBpbmRleFRvUmVtb3ZlID0gLTE7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgaW5kZXhUb1JlbW92ZSA9IHBhcmFtO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaW5kZXhUb1JlbW92ZSA9IHRoaXMuZWZmZWN0cy5pbmRleE9mKHBhcmFtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYm91bmRzIGNoZWNrXHJcbiAgICAgICAgaWYgKGluZGV4VG9SZW1vdmUgPCAwIHx8IGluZGV4VG9SZW1vdmUgPj0gdGhpcy5lZmZlY3RzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZWZmZWN0cy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSk7XHJcbiAgICAgICAgLy8gV2UgbXVzdCBjaGVjayBpZiB0aGUgdGV4dHVyZSBhbmQgdGhlIGJhY2tpbmcgc3ByaXRlIHBpeGVscyBhcmUgbG9hZGVkIGFzIHdlbGwgYmVmb3JlXHJcbiAgICAgICAgLy8gYW4gZWZmZWN0IGNhbiBiZSBhcHBsaWVkXHJcbiAgICAgICAgaWYgKCF0aGlzLnRleHR1cmUuaXNMb2FkZWQoKSB8fCAhdGhpcy5fcGl4ZWxzTG9hZGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5RWZmZWN0ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5RWZmZWN0cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9hcHBseUVmZmVjdHMoKSB7XHJcbiAgICAgICAgdGhpcy5fZmx1c2hUZXh0dXJlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZWZmZWN0cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BpeGVsRGF0YSA9IHRoaXMuX3Nwcml0ZUN0eC5nZXRJbWFnZURhdGEoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmVmZmVjdHMubGVuZ3RoO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVmZmVjdHNbaV0udXBkYXRlUGl4ZWwoeCwgeSwgdGhpcy5fcGl4ZWxEYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlQ3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUN0eC5wdXRJbWFnZURhdGEodGhpcy5fcGl4ZWxEYXRhLCAwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGlydHlFZmZlY3QgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIGFsbCBlZmZlY3RzIGZyb20gdGhlIGRyYXdpbmcgYW5kIHJldHVybiBpdCB0byBpdHMgb3JpZ2luYWwgc3RhdGUuXHJcbiAgICAgKi9cclxuICAgIGNsZWFyRWZmZWN0cygpIHtcclxuICAgICAgICB0aGlzLmVmZmVjdHMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9hcHBseUVmZmVjdHMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzZXRzIHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgZHJhd2luZyAoaWYgYW55KVxyXG4gICAgICovXHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICAvLyBkbyBub3RoaW5nXHJcbiAgICB9XHJcbiAgICBkZWJ1Z0RyYXcoY3R4LCB4LCB5KSB7XHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgIGN0eC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgY29uc3QgeHBvaW50ID0gdGhpcy5kcmF3V2lkdGggKiB0aGlzLmFuY2hvci54O1xyXG4gICAgICAgIGNvbnN0IHlwb2ludCA9IHRoaXMuZHJhd0hlaWdodCAqIHRoaXMuYW5jaG9yLnk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQ29sb3IuQmxhY2sudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguc3Ryb2tlUmVjdCgteHBvaW50LCAteXBvaW50LCB0aGlzLmRyYXdXaWR0aCwgdGhpcy5kcmF3SGVpZ2h0KTtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gICAgZHJhdyhjdHhPck9wdGlvbnMsIHgsIHkpIHtcclxuICAgICAgICBpZiAoY3R4T3JPcHRpb25zIGluc3RhbmNlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYXdXaXRoT3B0aW9ucyh7IGN0eDogY3R4T3JPcHRpb25zLCB4LCB5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZHJhd1dpdGhPcHRpb25zKGN0eE9yT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RyYXdXaXRoT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2o7XHJcbiAgICAgICAgY29uc3QgeyBjdHgsIHgsIHksIHJvdGF0aW9uLCBkcmF3V2lkdGgsIGRyYXdIZWlnaHQsIGFuY2hvciwgb2Zmc2V0LCBvcGFjaXR5LCBmbGlwSG9yaXpvbnRhbCwgZmxpcFZlcnRpY2FsIH0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHJvdGF0aW9uOiAoX2EgPSBvcHRpb25zLnJvdGF0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnJvdGF0aW9uLCBkcmF3V2lkdGg6IChfYiA9IG9wdGlvbnMuZHJhd1dpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLndpZHRoLCBkcmF3SGVpZ2h0OiAoX2MgPSBvcHRpb25zLmRyYXdIZWlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMuaGVpZ2h0LCBmbGlwSG9yaXpvbnRhbDogKF9kID0gb3B0aW9ucy5mbGlwSG9yaXpvbnRhbCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpcy5mbGlwSG9yaXpvbnRhbCwgZmxpcFZlcnRpY2FsOiAoX2UgPSBvcHRpb25zLmZsaXBWZXJ0aWNhbCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdGhpcy5mbGlwVmVydGljYWwsIGFuY2hvcjogKF9mID0gb3B0aW9ucy5hbmNob3IpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRoaXMuYW5jaG9yLCBvZmZzZXQ6IChfZyA9IG9wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB0aGlzLm9mZnNldCwgb3BhY2l0eTogKChfaCA9IG9wdGlvbnMub3BhY2l0eSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogMSkgKiAoKF9qID0gdGhpcy5fb3BhY2l0eSkgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogMSkgfSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5RWZmZWN0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5RWZmZWN0cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBjYWxjdWxhdGluZyBjdXJyZW50IGRpbWVuc2lvbnNcclxuICAgICAgICBjb25zdCBhbmNob3JYID0gZHJhd1dpZHRoICogYW5jaG9yLnggKyBvZmZzZXQueDtcclxuICAgICAgICBjb25zdCBhbmNob3JZID0gZHJhd0hlaWdodCAqIGFuY2hvci55ICsgb2Zmc2V0Lnk7XHJcbiAgICAgICAgY29uc3Qgc2NhbGVEaXJYID0gdGhpcy5zY2FsZS54ID4gMCA/IDEgOiAtMTtcclxuICAgICAgICBjb25zdCBzY2FsZURpclkgPSB0aGlzLnNjYWxlLnkgPiAwID8gMSA6IC0xO1xyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgLy8gTW92ZSB0aGUgZHJhdyBwb2ludCBvZiBvcmlnaW5cclxuICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xyXG4gICAgICAgIC8vIFJvdGF0ZSBhbmQgc2NhbGUgYXJvdW5kIGFuY2hvciBwb2ludFxyXG4gICAgICAgIC8vIFRoaXMgcmVxdWlyZXMgYSBiaXQgb2YgZXhwbGFpbmF0aW9uLCBzY2FsZSBjb29yZGluYXRlcyBmaXJzdCBwb3NpdGl2ZSBmbGlwcGluZyBvciByb3RhdGluZ1xyXG4gICAgICAgIGN0eC5zY2FsZShNYXRoLmFicyh0aGlzLnNjYWxlLngpLCBNYXRoLmFicyh0aGlzLnNjYWxlLnkpKTtcclxuICAgICAgICBpZiAodGhpcy5kcmF3QXJvdW5kQW5jaG9yKSB7XHJcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIHdoZXJlIHlvdSB3YW50IHRoZSBhbmNob3IgdG8gbWF0Y2ggd2l0aCB0aGUgcG9pbnQgb2YgZHJhd1xyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugc3ByaXRlcyBhcmUgYWx3YXlzIGRyYXduIGZyb20gdG9wLWxlZnRcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtYW5jaG9yWCwgLWFuY2hvclkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHgudHJhbnNsYXRlKGFuY2hvclgsIGFuY2hvclkpO1xyXG4gICAgICAgIGN0eC5yb3RhdGUocm90YXRpb24pO1xyXG4gICAgICAgIC8vIFRoaXMgaXMgZm9yIGhhbmRsaW5nIGRpcmVjdGlvbiBjaGFuZ2VzIDEgb3IgLTEsIHRoYXQgd2F5IHdlIGRvbid0IGhhdmUgbWlzbWF0Y2hlZCB0cmFuc2xhdGVzKClcclxuICAgICAgICBjdHguc2NhbGUoc2NhbGVEaXJYLCBzY2FsZURpclkpO1xyXG4gICAgICAgIGN0eC50cmFuc2xhdGUoLWFuY2hvclgsIC1hbmNob3JZKTtcclxuICAgICAgICBpZiAoZmxpcEhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZShkcmF3V2lkdGgsIDApO1xyXG4gICAgICAgICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmxpcFZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoMCwgZHJhd0hlaWdodCk7XHJcbiAgICAgICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9sZEFscGhhID0gY3R4Lmdsb2JhbEFscGhhO1xyXG4gICAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IG9wYWNpdHk7XHJcbiAgICAgICAgLy8gQ29udGV4dCBpcyBhbHJlYWR5IHJvdGF0ZWQgYW5kIHNjYWxlZFxyXG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5fc3ByaXRlQ2FudmFzLCAwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgLy8gc291cmNlXHJcbiAgICAgICAgMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpOyAvLyBkZXN0XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb2xkQWxwaGE7XHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvZHVjZXMgYSBjb3B5IG9mIHRoZSBjdXJyZW50IHNwcml0ZVxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgU3ByaXRlX1Nwcml0ZSh0aGlzLnRleHR1cmUsIHRoaXMueCwgdGhpcy55LCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgcmVzdWx0LmFuY2hvciA9IHRoaXMuYW5jaG9yLmNsb25lKCk7XHJcbiAgICAgICAgcmVzdWx0LnNjYWxlID0gdGhpcy5zY2FsZS5jbG9uZSgpO1xyXG4gICAgICAgIHJlc3VsdC5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgICAgcmVzdWx0LmZsaXBIb3Jpem9udGFsID0gdGhpcy5mbGlwSG9yaXpvbnRhbDtcclxuICAgICAgICByZXN1bHQuZmxpcFZlcnRpY2FsID0gdGhpcy5mbGlwVmVydGljYWw7XHJcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5lZmZlY3RzLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5hZGRFZmZlY3QodGhpcy5lZmZlY3RzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQSBbW0xlZ2FjeURyYXdpbmcuU3ByaXRlXV0gaXMgb25lIG9mIHRoZSBtYWluIGRyYXdpbmcgcHJpbWl0aXZlcy4gSXQgaXMgcmVzcG9uc2libGUgZm9yIGRyYXdpbmdcclxuICogaW1hZ2VzIG9yIHBhcnRzIG9mIGltYWdlcyBmcm9tIGEgW1tMZWdhY3lEcmF3aW5nLlRleHR1cmVdXSByZXNvdXJjZSB0byB0aGUgc2NyZWVuLlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgW1tTcHJpdGVdXVxyXG4gKi9cclxubGV0IFNwcml0ZV9TcHJpdGUgPSBjbGFzcyBTcHJpdGUgZXh0ZW5kcyBDb25maWd1cmFibGUoU3ByaXRlSW1wbCkge1xyXG4gICAgY29uc3RydWN0b3IoaW1hZ2VPckNvbmZpZywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHN1cGVyKGltYWdlT3JDb25maWcsIHgsIHksIHdpZHRoLCBoZWlnaHQpO1xyXG4gICAgfVxyXG59O1xyXG5TcHJpdGVfU3ByaXRlID0gU3ByaXRlX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnTGFiZWwuY2xlYXJUZXh0U2hhZG93IHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgTGFiZWwuZm9udC5zaGFkb3cnXHJcbiAgICB9KVxyXG5dLCBTcHJpdGVfU3ByaXRlKTtcclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvU3ByaXRlLnRzXG5cclxuXHJcblxyXG5cclxuY2xhc3MgU3ByaXRlIGV4dGVuZHMgR3JhcGhpYyB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLmltYWdlID0gb3B0aW9ucy5pbWFnZTtcclxuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VWaWV3ID0gKF9hID0gb3B0aW9ucy5zb3VyY2VWaWV3KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7IHg6IDAsIHk6IDAsIHdpZHRoOiB3aWR0aCAhPT0gbnVsbCAmJiB3aWR0aCAhPT0gdm9pZCAwID8gd2lkdGggOiAwLCBoZWlnaHQ6IGhlaWdodCAhPT0gbnVsbCAmJiBoZWlnaHQgIT09IHZvaWQgMCA/IGhlaWdodCA6IDAgfTtcclxuICAgICAgICB0aGlzLmRlc3RTaXplID0gKF9iID0gb3B0aW9ucy5kZXN0U2l6ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogeyB3aWR0aDogd2lkdGggIT09IG51bGwgJiYgd2lkdGggIT09IHZvaWQgMCA/IHdpZHRoIDogMCwgaGVpZ2h0OiBoZWlnaHQgIT09IG51bGwgJiYgaGVpZ2h0ICE9PSB2b2lkIDAgPyBoZWlnaHQgOiAwIH07XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlU3ByaXRlRGltZW5zaW9ucygpO1xyXG4gICAgICAgIHRoaXMuaW1hZ2UucmVhZHkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNwcml0ZURpbWVuc2lvbnMoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBmcm9tKGltYWdlKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGUoe1xyXG4gICAgICAgICAgICBpbWFnZTogaW1hZ2VcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF91cGRhdGVTcHJpdGVEaW1lbnNpb25zKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xyXG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IG5hdGl2ZVdpZHRoLCBoZWlnaHQ6IG5hdGl2ZUhlaWdodCB9ID0gdGhpcy5pbWFnZTtcclxuICAgICAgICAvLyBUaGlzIGNvZGUgdXNlcyB8fCB0byBhdm9pZCAwJ3NcclxuICAgICAgICAvLyBJZiB0aGUgc291cmNlIGlzIG5vdCBzcGVjaWZpZWQsIHVzZSB0aGUgbmF0aXZlIGRpbWVuc2lvblxyXG4gICAgICAgIHRoaXMuc291cmNlVmlldy53aWR0aCA9ICgoX2EgPSB0aGlzLnNvdXJjZVZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aWR0aCkgfHwgbmF0aXZlV2lkdGg7XHJcbiAgICAgICAgdGhpcy5zb3VyY2VWaWV3LmhlaWdodCA9ICgoX2IgPSB0aGlzLnNvdXJjZVZpZXcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQpIHx8IG5hdGl2ZUhlaWdodDtcclxuICAgICAgICAvLyBJZiB0aGUgZGVzdGluYXRpb24gaXMgbm90IHNwZWNpZmllZCwgdXNlIHRoZSBzb3VyY2UgaWYgc3BlY2lmaWVkLCB0aGVuIG5hdGl2ZVxyXG4gICAgICAgIHRoaXMuZGVzdFNpemUud2lkdGggPSAoKF9jID0gdGhpcy5kZXN0U2l6ZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLndpZHRoKSB8fCAoKF9kID0gdGhpcy5zb3VyY2VWaWV3KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Qud2lkdGgpIHx8IG5hdGl2ZVdpZHRoO1xyXG4gICAgICAgIHRoaXMuZGVzdFNpemUuaGVpZ2h0ID0gKChfZSA9IHRoaXMuZGVzdFNpemUpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5oZWlnaHQpIHx8ICgoX2YgPSB0aGlzLnNvdXJjZVZpZXcpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5oZWlnaHQpIHx8IG5hdGl2ZUhlaWdodDtcclxuICAgICAgICB0aGlzLndpZHRoID0gTWF0aC5jZWlsKHRoaXMuZGVzdFNpemUud2lkdGgpO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMuZGVzdFNpemUuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIF9wcmVEcmF3KGV4LCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2UuaXNMb2FkZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTcHJpdGVEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHN1cGVyLl9wcmVEcmF3KGV4LCB4LCB5KTtcclxuICAgIH1cclxuICAgIF9kcmF3SW1hZ2UoZXgsIHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy5pbWFnZS5pc0xvYWRlZCgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNwcml0ZURpbWVuc2lvbnMoKTtcclxuICAgICAgICAgICAgZXguZHJhd0ltYWdlKHRoaXMuaW1hZ2UuaW1hZ2UsIHRoaXMuc291cmNlVmlldy54LCB0aGlzLnNvdXJjZVZpZXcueSwgdGhpcy5zb3VyY2VWaWV3LndpZHRoLCB0aGlzLnNvdXJjZVZpZXcuaGVpZ2h0LCB4LCB5LCB0aGlzLmRlc3RTaXplLndpZHRoLCB0aGlzLmRlc3RTaXplLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBJbWFnZVNvdXJjZSBmcm9tIGxlZ2FjeSB0ZXh0dXJlXHJcbiAgICAgKiBAcGFyYW0gc3ByaXRlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tTGVnYWN5U3ByaXRlKHNwcml0ZSkge1xyXG4gICAgICAgIGNvbnN0IHRleCA9IHNwcml0ZS50ZXh0dXJlO1xyXG4gICAgICAgIGNvbnN0IGltYWdlID0gSW1hZ2VTb3VyY2UuZnJvbUxlZ2FjeVRleHR1cmUodGV4KTtcclxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZSh7XHJcbiAgICAgICAgICAgIGltYWdlLFxyXG4gICAgICAgICAgICBzb3VyY2VWaWV3OiB7XHJcbiAgICAgICAgICAgICAgICB4OiBzcHJpdGUueCxcclxuICAgICAgICAgICAgICAgIHk6IHNwcml0ZS55LFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHNwcml0ZS53aWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogc3ByaXRlLmhlaWdodFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbnZlcnRzIGEgc3ByaXRlIHRvIGEgTGVnYWN5IHNwcml0ZVxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBwYXJhbSBzcHJpdGVcclxuICAgICAqIEByZXR1cm5zIExlZ2FjeURyYXdpbmcuU3ByaXRlXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0b0xlZ2FjeVNwcml0ZShzcHJpdGUpIHtcclxuICAgICAgICBjb25zdCBpbWFnZSA9IHNwcml0ZS5pbWFnZTtcclxuICAgICAgICBjb25zdCB0ZXggPSBuZXcgVGV4dHVyZShpbWFnZS5wYXRoKTtcclxuICAgICAgICB0ZXguZGF0YSA9IGltYWdlLmltYWdlO1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlX1Nwcml0ZSh0ZXgsIHNwcml0ZS5zb3VyY2VWaWV3LngsIHNwcml0ZS5zb3VyY2VWaWV3LnksIHNwcml0ZS5zb3VyY2VWaWV3LndpZHRoLCBzcHJpdGUuc291cmNlVmlldy5oZWlnaHQpO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGUoT2JqZWN0LmFzc2lnbih7IGltYWdlOiB0aGlzLmltYWdlLCBzb3VyY2VWaWV3OiBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNvdXJjZVZpZXcpLCBkZXN0U2l6ZTogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZXN0U2l6ZSkgfSwgdGhpcy5jbG9uZUdyYXBoaWNPcHRpb25zKCkpKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0ltYWdlU291cmNlLnRzXG52YXIgSW1hZ2VTb3VyY2VfYXdhaXRlciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblxyXG5cclxuY2xhc3MgSW1hZ2VTb3VyY2Uge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcGF0aCB0byB0aGUgaW1hZ2UsIGNhbiBhbHNvIGJlIGEgZGF0YSB1cmwgbGlrZSAnZGF0YTppbWFnZS8nXHJcbiAgICAgKiBAcGFyYW0gcGF0aFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihwYXRoLCBidXN0Q2FjaGUgPSBmYWxzZSkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nIGh0bWwgaW1hZ2UgZWxtZWVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlID0gbmV3IFJlc291cmNlKHBhdGgsICdibG9iJywgYnVzdENhY2hlKTtcclxuICAgICAgICBpZiAocGF0aC5lbmRzV2l0aCgnLnN2ZycpIHx8IHBhdGguZW5kc1dpdGgoJy5naWYnKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgSW1hZ2UgdHlwZSBpcyBub3QgZnVsbHkgc3VwcG9ydGVkLCB5b3UgbWF5IGhhdmUgbWl4ZWQgcmVzdWx0cyAke3BhdGh9LiBGdWxseSBzdXBwb3J0ZWQ6IGpwZywgYm1wLCBhbmQgcG5nYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMucmVhZHkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZWRSZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yaWdpbmFsIHNpemUgb2YgdGhlIHNvdXJjZSBpbWFnZSBpbiBwaXhlbHNcclxuICAgICAqL1xyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlLm5hdHVyYWxXaWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIG9yaWdpbmFsIGhlaWdodCBvZiB0aGUgc291cmNlIGltYWdlIGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlLm5hdHVyYWxIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgVGV4dHVyZSBpcyBjb21wbGV0ZWx5IGxvYWRlZCBhbmQgaXMgcmVhZHlcclxuICAgICAqIHRvIGJlIGRyYXduLlxyXG4gICAgICovXHJcbiAgICBpc0xvYWRlZCgpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLmRhdGEuc3JjO1xyXG4gICAgfVxyXG4gICAgZ2V0IGltYWdlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJlZ2lucyBsb2FkaW5nIHRoZSBpbWFnZSBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBpbWFnZSBpcyBsb2FkZWRcclxuICAgICAqL1xyXG4gICAgbG9hZCgpIHtcclxuICAgICAgICByZXR1cm4gSW1hZ2VTb3VyY2VfYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaXNMb2FkZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gTG9hZCBiYXNlNjQgb3IgYmxvYiBpZiBuZWVkZWRcclxuICAgICAgICAgICAgICAgIGxldCB1cmw7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucGF0aC5pbmNsdWRlcygnZGF0YTppbWFnZS8nKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2IgPSB5aWVsZCB0aGlzLl9yZXNvdXJjZS5sb2FkKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHRoaXMucGF0aDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIERlY29kZSB0aGUgaW1hZ2VcclxuICAgICAgICAgICAgICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgICAgICBpbWFnZS5zcmMgPSB1cmw7XHJcbiAgICAgICAgICAgICAgICB5aWVsZCBpbWFnZS5kZWNvZGUoKTtcclxuICAgICAgICAgICAgICAgIC8vIFNldCByZXN1bHRzXHJcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBpbWFnZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IGBFcnJvciBsb2FkaW5nIEltYWdlU291cmNlIGZyb20gcGF0aCAnJHt0aGlzLnBhdGh9JyB3aXRoIGVycm9yIFske2Vycm9yLm1lc3NhZ2V9XWA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gdG9kbyBlbWl0IGNvbXBsZXRlXHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlZFJlc29sdmUodGhpcy5kYXRhKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQnVpbGQgYSBzcHJpdGUgZnJvbSB0aGlzIEltYWdlU291cmNlXHJcbiAgICAgKi9cclxuICAgIHRvU3ByaXRlKCkge1xyXG4gICAgICAgIHJldHVybiBTcHJpdGUuZnJvbSh0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgSW1hZ2VTb3VyY2UgZnJvbSBsZWdhY3kgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHRleFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZnJvbUxlZ2FjeVRleHR1cmUodGV4KSB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2VTb3VyY2UodGV4LnBhdGgpO1xyXG4gICAgICAgIGlmICh0ZXguaXNMb2FkZWQoKSkge1xyXG4gICAgICAgICAgICBpbWFnZS5kYXRhID0gdGV4LmRhdGE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0ZXgubG9hZGVkLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaW1hZ2UuZGF0YSA9IHRleC5kYXRhO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGltYWdlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbmxvYWQgaW1hZ2VzIGZyb20gbWVtb3J5XHJcbiAgICAgKi9cclxuICAgIHVubG9hZCgpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgSW1hZ2UoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0RyYXdpbmcvQW5pbWF0aW9uLnRzXG52YXIgQW5pbWF0aW9uX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogQGhpZGRlblxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgW1tBbmltYXRpb25dXVxyXG4gKi9cclxuY2xhc3MgQW5pbWF0aW9uSW1wbCB7XHJcbiAgICAvKipcclxuICAgICAqIFR5cGljYWxseSB5b3Ugd2lsbCB1c2UgYSBbW1Nwcml0ZVNoZWV0XV0gdG8gZ2VuZXJhdGUgYW4gW1tBbmltYXRpb25dXS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZW5naW5lT3JDb25maWcgIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIGVuZ2luZVxyXG4gICAgICogQHBhcmFtIHNwcml0ZXMgIEFuIGFycmF5IG9mIHNwcml0ZXMgdG8gY3JlYXRlIHRoZSBmcmFtZXMgZm9yIHRoZSBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBzcGVlZCAgIFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKiBAcGFyYW0gbG9vcCAgICBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYW5pbWF0aW9uIHNob3VsZCBsb29wIGFmdGVyIGl0IGlzIGNvbXBsZXRlZFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmVPckNvbmZpZywgc3ByaXRlcywgc3BlZWQsIGxvb3ApIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgc3ByaXRlIGZyYW1lcyB0byBwbGF5LCBpbiBvcmRlci4gU2VlIFtbU3ByaXRlU2hlZXQuZ2V0QW5pbWF0aW9uRm9yQWxsXV0gdG8gcXVpY2tseVxyXG4gICAgICAgICAqIGdlbmVyYXRlIGFuIFtbQW5pbWF0aW9uXV0uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zcHJpdGVzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBmcmFtZSBpbmRleCBiZWluZyBzaG93blxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLl90aW1lTGVmdEluRnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2lkZW1wb3RlbmN5VG9rZW4gPSAtMTtcclxuICAgICAgICB0aGlzLmFuY2hvciA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSAwLjA7XHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IFZlY3Rvci5PbmU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBzaG91bGQgbG9vcCBhZnRlciBpdCBpcyBjb21wbGV0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvb3AgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB0aGUgZnJhbWUgaW5kZXggdGhlIGFuaW1hdGlvbiBzaG91bGQgZnJlZXplIG9uIGZvciBhIG5vbi1sb29waW5nXHJcbiAgICAgICAgICogYW5pbWF0aW9uLiBCeSBkZWZhdWx0IGl0IGlzIHRoZSBsYXN0IGZyYW1lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZnJlZXplRnJhbWUgPSAtMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGbGlwIGVhY2ggZnJhbWUgdmVydGljYWxseS4gU2V0cyBbW1Nwcml0ZS5mbGlwVmVydGljYWxdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZsaXBWZXJ0aWNhbCA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZsaXAgZWFjaCBmcmFtZSBob3Jpem9udGFsbHkuIFNldHMgW1tTcHJpdGUuZmxpcEhvcml6b250YWxdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZsaXBIb3Jpem9udGFsID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kcmF3V2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuZHJhd0hlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy53aWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMuX29wYWNpdHkgPSAxO1xyXG4gICAgICAgIGxldCBlbmdpbmUgPSBlbmdpbmVPckNvbmZpZztcclxuICAgICAgICBpZiAoZW5naW5lT3JDb25maWcgJiYgIShlbmdpbmVPckNvbmZpZyBpbnN0YW5jZW9mIEVuZ2luZSkpIHtcclxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gZW5naW5lT3JDb25maWc7XHJcbiAgICAgICAgICAgIGVuZ2luZSA9IGNvbmZpZy5lbmdpbmU7XHJcbiAgICAgICAgICAgIHNwcml0ZXMgPSBjb25maWcuc3ByaXRlcztcclxuICAgICAgICAgICAgc3BlZWQgPSBjb25maWcuc3BlZWQ7XHJcbiAgICAgICAgICAgIGxvb3AgPSBjb25maWcubG9vcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zcHJpdGVzID0gc3ByaXRlcztcclxuICAgICAgICB0aGlzLnNwZWVkID0gc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuX3RpbWVMZWZ0SW5GcmFtZSA9IHRoaXMuc3BlZWQ7XHJcbiAgICAgICAgaWYgKGxvb3AgIT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aGlzLmxvb3AgPSBsb29wO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3ByaXRlcyAmJiBzcHJpdGVzWzBdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0hlaWdodCA9IHNwcml0ZXNbMF0gPyBzcHJpdGVzWzBdLmRyYXdIZWlnaHQgOiAwO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdXaWR0aCA9IHNwcml0ZXNbMF0gPyBzcHJpdGVzWzBdLmRyYXdXaWR0aCA6IDA7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSBzcHJpdGVzWzBdID8gc3ByaXRlc1swXS53aWR0aCA6IDA7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc3ByaXRlc1swXSA/IHNwcml0ZXNbMF0uaGVpZ2h0IDogMDtcclxuICAgICAgICAgICAgdGhpcy5mcmVlemVGcmFtZSA9IHNwcml0ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIG9wYWNpdHkgZWZmZWN0IHRvIGEgc3ByaXRlLCBzZXR0aW5nIHRoZSBhbHBoYSBvZiBhbGwgcGl4ZWxzIHRvIGEgZ2l2ZW4gdmFsdWVcclxuICAgICAqL1xyXG4gICAgb3BhY2l0eSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX29wYWNpdHkgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgZ3JheXNjYWxlIGVmZmVjdCB0byBhIHNwcml0ZSwgcmVtb3ZpbmcgY29sb3IgaW5mb3JtYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdyYXlzY2FsZSgpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgR3JheXNjYWxlKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIHRoZSBpbnZlcnQgZWZmZWN0IHRvIGEgc3ByaXRlLCBpbnZlcnRpbmcgdGhlIHBpeGVsIGNvbG9ycy5cclxuICAgICAqL1xyXG4gICAgaW52ZXJ0KCkge1xyXG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBJbnZlcnQoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGZpbGwgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIG5vbi10cmFuc3BhcmVudCBwaXhlbHMgdG8gbWF0Y2ggYSBnaXZlbiBjb2xvclxyXG4gICAgICovXHJcbiAgICBmaWxsKGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IEZpbGwoY29sb3IpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgY29sb3JpemUgZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2luZyB0aGUgY29sb3IgY2hhbm5lbHMgb2YgYWxsIHBpeGVscyB0byBiZSB0aGUgYXZlcmFnZSBvZiB0aGUgb3JpZ2luYWwgY29sb3IgYW5kIHRoZVxyXG4gICAgICogcHJvdmlkZWQgY29sb3IuXHJcbiAgICAgKi9cclxuICAgIGNvbG9yaXplKGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IENvbG9yaXplKGNvbG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGxpZ2h0ZW4gZWZmZWN0IHRvIGEgc3ByaXRlLCBjaGFuZ2VzIHRoZSBsaWdodG5lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBoc2xcclxuICAgICAqL1xyXG4gICAgbGlnaHRlbihmYWN0b3IgPSAwLjEpIHtcclxuICAgICAgICB0aGlzLmFkZEVmZmVjdChuZXcgTGlnaHRlbihmYWN0b3IpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgZGFya2VuIGVmZmVjdCB0byBhIHNwcml0ZSwgY2hhbmdlcyB0aGUgZGFya25lc3Mgb2YgdGhlIGNvbG9yIGFjY29yZGluZyB0byBoc2xcclxuICAgICAqL1xyXG4gICAgZGFya2VuKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBEYXJrZW4oZmFjdG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIHNhdHVyYXRlIGVmZmVjdCB0byBhIHNwcml0ZSwgc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gaHNsXHJcbiAgICAgKi9cclxuICAgIHNhdHVyYXRlKGZhY3RvciA9IDAuMSkge1xyXG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KG5ldyBTYXR1cmF0ZShmYWN0b3IpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbGllcyB0aGUgZGVzYXR1cmF0ZSBlZmZlY3QgdG8gYSBzcHJpdGUsIGRlc2F0dXJhdGVzIHRoZSBjb2xvciBhY2NvcmRpbmcgdG8gaHNsXHJcbiAgICAgKi9cclxuICAgIGRlc2F0dXJhdGUoZmFjdG9yID0gMC4xKSB7XHJcbiAgICAgICAgdGhpcy5hZGRFZmZlY3QobmV3IERlc2F0dXJhdGUoZmFjdG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIFtbU3ByaXRlRWZmZWN0XV0gbWFudWFsbHlcclxuICAgICAqL1xyXG4gICAgYWRkRWZmZWN0KGVmZmVjdCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLmFkZEVmZmVjdChlZmZlY3QpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZUVmZmVjdChwYXJhbSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnJlbW92ZUVmZmVjdChwYXJhbSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciBhbGwgc3ByaXRlIGVmZmVjdHNcclxuICAgICAqL1xyXG4gICAgY2xlYXJFZmZlY3RzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLmNsZWFyRWZmZWN0cygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZXRBbmNob3IocG9pbnQpIHtcclxuICAgICAgICAvL2lmICghdGhpcy5hbmNob3IuZXF1YWxzKHBvaW50KSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLmFuY2hvci5zZXRUbyhwb2ludC54LCBwb2ludC55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy99XHJcbiAgICB9XHJcbiAgICBfc2V0Um90YXRpb24ocmFkaWFucykge1xyXG4gICAgICAgIC8vaWYgKHRoaXMucm90YXRpb24gIT09IHJhZGlhbnMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGkgaW4gdGhpcy5zcHJpdGVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3ByaXRlc1tpXS5yb3RhdGlvbiA9IHJhZGlhbnM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vfVxyXG4gICAgfVxyXG4gICAgX3NldFNjYWxlKHNjYWxlKSB7XHJcbiAgICAgICAgLy9pZiAoIXRoaXMuc2NhbGUuZXF1YWxzKHNjYWxlKSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgaSBpbiB0aGlzLnNwcml0ZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVzW2ldLnNjYWxlID0gc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGFuaW1hdGlvbiB0byBmaXJzdCBmcmFtZS5cclxuICAgICAqL1xyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50RnJhbWUgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYW5pbWF0aW9uIGlzIGNvbXBsZXRlLCBhbmltYXRpb25zIHRoYXQgbG9vcCBhcmUgbmV2ZXIgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIGlzRG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMubG9vcCAmJiB0aGlzLmN1cnJlbnRGcmFtZSA+PSB0aGlzLnNwcml0ZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBOb3QgbWVhbnQgdG8gYmUgY2FsbGVkIGJ5IGdhbWUgZGV2ZWxvcGVycy4gVGlja3MgdGhlIGFuaW1hdGlvbiBmb3J3YXJkIGludGVybmFsbHkgYW5kXHJcbiAgICAgKiBjYWxjdWxhdGVzIHdoZXRoZXIgdG8gY2hhbmdlIHRvIHRoZSBmcmFtZS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB0aWNrKGVsYXBzZWQsIGlkZW1wb3RlbmN5VG9rZW4pIHtcclxuICAgICAgICBpZiAodGhpcy5faWRlbXBvdGVuY3lUb2tlbiA9PT0gaWRlbXBvdGVuY3lUb2tlbikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lkZW1wb3RlbmN5VG9rZW4gPSBpZGVtcG90ZW5jeVRva2VuO1xyXG4gICAgICAgIHRoaXMuX3RpbWVMZWZ0SW5GcmFtZSAtPSBlbGFwc2VkO1xyXG4gICAgICAgIGlmICh0aGlzLl90aW1lTGVmdEluRnJhbWUgPD0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IHRoaXMubG9vcCA/ICh0aGlzLmN1cnJlbnRGcmFtZSArIDEpICUgdGhpcy5zcHJpdGVzLmxlbmd0aCA6IHRoaXMuY3VycmVudEZyYW1lICsgMTtcclxuICAgICAgICAgICAgdGhpcy5fdGltZUxlZnRJbkZyYW1lID0gdGhpcy5zcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWVzKCk7XHJcbiAgICAgICAgY29uc3QgY3VycmVudCA9IHRoaXMuc3ByaXRlc1t0aGlzLmN1cnJlbnRGcmFtZV07XHJcbiAgICAgICAgaWYgKGN1cnJlbnQpIHtcclxuICAgICAgICAgICAgdGhpcy53aWR0aCA9IGN1cnJlbnQud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gY3VycmVudC5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd1dpZHRoID0gY3VycmVudC5kcmF3V2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhd0hlaWdodCA9IGN1cnJlbnQuZHJhd0hlaWdodDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfdXBkYXRlVmFsdWVzKCkge1xyXG4gICAgICAgIHRoaXMuX3NldEFuY2hvcih0aGlzLmFuY2hvcik7XHJcbiAgICAgICAgdGhpcy5fc2V0Um90YXRpb24odGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgdGhpcy5fc2V0U2NhbGUodGhpcy5zY2FsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNraXBzIGFoZWFkIGEgc3BlY2lmaWVkIG51bWJlciBvZiBmcmFtZXMgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICogQHBhcmFtIGZyYW1lcyAgRnJhbWVzIHRvIHNraXAgYWhlYWRcclxuICAgICAqL1xyXG4gICAgc2tpcChmcmFtZXMpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZSA9ICh0aGlzLmN1cnJlbnRGcmFtZSArIGZyYW1lcykgJSB0aGlzLnNwcml0ZXMubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgZHJhdyhjdHhPck9wdGlvbnMsIHgsIHkpIHtcclxuICAgICAgICBpZiAoY3R4T3JPcHRpb25zIGluc3RhbmNlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYXdXaXRoT3B0aW9ucyh7IGN0eDogY3R4T3JPcHRpb25zLCB4LCB5IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZHJhd1dpdGhPcHRpb25zKGN0eE9yT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RyYXdXaXRoT3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcclxuICAgICAgICBjb25zdCBhbmltT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgcm90YXRpb246IChfYSA9IG9wdGlvbnMucm90YXRpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucm90YXRpb24sIGRyYXdXaWR0aDogKF9iID0gb3B0aW9ucy5kcmF3V2lkdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuZHJhd1dpZHRoLCBkcmF3SGVpZ2h0OiAoX2MgPSBvcHRpb25zLmRyYXdIZWlnaHQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMuZHJhd0hlaWdodCwgZmxpcEhvcml6b250YWw6IChfZCA9IG9wdGlvbnMuZmxpcEhvcml6b250YWwpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRoaXMuZmxpcEhvcml6b250YWwsIGZsaXBWZXJ0aWNhbDogKF9lID0gb3B0aW9ucy5mbGlwVmVydGljYWwpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHRoaXMuZmxpcFZlcnRpY2FsLCBhbmNob3I6IChfZiA9IG9wdGlvbnMuYW5jaG9yKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiB0aGlzLmFuY2hvciwgb3BhY2l0eTogKChfZyA9IG9wdGlvbnMub3BhY2l0eSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogMSkgKiAoKF9oID0gdGhpcy5fb3BhY2l0eSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogMSkgfSk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlVmFsdWVzKCk7XHJcbiAgICAgICAgbGV0IGN1cnJTcHJpdGU7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEZyYW1lIDwgdGhpcy5zcHJpdGVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBjdXJyU3ByaXRlID0gdGhpcy5zcHJpdGVzW3RoaXMuY3VycmVudEZyYW1lXTtcclxuICAgICAgICAgICAgY3VyclNwcml0ZS5kcmF3KGFuaW1PcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZnJlZXplRnJhbWUgIT09IC0xICYmIHRoaXMuY3VycmVudEZyYW1lID49IHRoaXMuc3ByaXRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY3VyclNwcml0ZSA9IHRoaXMuc3ByaXRlc1tjbGFtcCh0aGlzLmZyZWV6ZUZyYW1lLCAwLCB0aGlzLnNwcml0ZXMubGVuZ3RoIC0gMSldO1xyXG4gICAgICAgICAgICBjdXJyU3ByaXRlLmRyYXcoYW5pbU9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBhZGQgdGhlIGNhbGN1bGF0ZWQgd2lkdGhcclxuICAgICAgICBpZiAoY3VyclNwcml0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdXaWR0aCA9IGN1cnJTcHJpdGUuZHJhd1dpZHRoO1xyXG4gICAgICAgICAgICB0aGlzLmRyYXdIZWlnaHQgPSBjdXJyU3ByaXRlLmRyYXdIZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGF5cyBhbiBhbmltYXRpb24gYXQgYW4gYXJiaXRyYXJ5IGxvY2F0aW9uIGluIHRoZSBnYW1lLlxyXG4gICAgICogQHBhcmFtIHggIFRoZSB4IHBvc2l0aW9uIGluIHRoZSBnYW1lIHRvIHBsYXlcclxuICAgICAqIEBwYXJhbSB5ICBUaGUgeSBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB0byBwbGF5XHJcbiAgICAgKi9cclxuICAgIHBsYXkoeCwgeSkge1xyXG4gICAgICAgIHRoaXMucmVzZXQoKTtcclxuICAgICAgICB0aGlzLl9lbmdpbmUucGxheUFuaW1hdGlvbih0aGlzLCB4LCB5KTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQW5pbWF0aW9ucyBhbGxvdyB5b3UgdG8gZGlzcGxheSBhIHNlcmllcyBvZiBpbWFnZXMgb25lIGFmdGVyIGFub3RoZXIsXHJcbiAqIGNyZWF0aW5nIHRoZSBpbGx1c2lvbiBvZiBjaGFuZ2UuIEdlbmVyYWxseSB0aGVzZSBpbWFnZXMgd2lsbCBjb21lIGZyb20gYSBbW1Nwcml0ZVNoZWV0XV0gc291cmNlLlxyXG4gKiBAZGVwcmVjYXRlZCBVc2UgW1tBbmltYXRpb25dXVxyXG4gKi9cclxubGV0IEFuaW1hdGlvbl9BbmltYXRpb24gPSBjbGFzcyBBbmltYXRpb24gZXh0ZW5kcyBDb25maWd1cmFibGUoQW5pbWF0aW9uSW1wbCkge1xyXG4gICAgY29uc3RydWN0b3IoZW5naW5lT3JDb25maWcsIGltYWdlcywgc3BlZWQsIGxvb3ApIHtcclxuICAgICAgICBzdXBlcihlbmdpbmVPckNvbmZpZywgaW1hZ2VzLCBzcGVlZCwgbG9vcCk7XHJcbiAgICB9XHJcbn07XHJcbkFuaW1hdGlvbl9BbmltYXRpb24gPSBBbmltYXRpb25fZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdBbmltYXRpb24gd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBHcmFwaGljcy5BbmltYXRpb24nXHJcbiAgICB9KVxyXG5dLCBBbmltYXRpb25fQW5pbWF0aW9uKTtcclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvRm9udENvbW1vbi50c1xuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgZm9udCBzaXplIHVuaXRzXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXNpemVcclxuICovXHJcbnZhciBGb250VW5pdDtcclxuKGZ1bmN0aW9uIChGb250VW5pdCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBFbSBpcyBhIHNjYWxhYmxlIHVuaXQsIDEgZW0gaXMgZXF1YWwgdG8gdGhlIGN1cnJlbnQgZm9udCBzaXplIG9mIHRoZSBjdXJyZW50IGVsZW1lbnQsIHBhcmVudCBlbGVtZW50cyBjYW4gZWZmZWN0IGVtIHZhbHVlc1xyXG4gICAgICovXHJcbiAgICBGb250VW5pdFtcIkVtXCJdID0gXCJlbVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW0gaXMgc2ltaWxhciB0byB0aGUgRW0sIGl0IGlzIGEgc2NhbGFibGUgdW5pdC4gMSByZW0gaXMgZXF1YWwgdG8gdGhlIGZvbnQgc2l6ZSBvZiB0aGUgcm9vdCBlbGVtZW50XHJcbiAgICAgKi9cclxuICAgIEZvbnRVbml0W1wiUmVtXCJdID0gXCJyZW1cIjtcclxuICAgIC8qKlxyXG4gICAgICogUGl4ZWwgaXMgYSB1bml0IG9mIGxlbmd0aCBpbiBzY3JlZW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIEZvbnRVbml0W1wiUHhcIl0gPSBcInB4XCI7XHJcbiAgICAvKipcclxuICAgICAqIFBvaW50IGlzIGEgcGh5c2ljYWwgdW5pdCBsZW5ndGggKDEvNzIgb2YgYW4gaW5jaClcclxuICAgICAqL1xyXG4gICAgRm9udFVuaXRbXCJQdFwiXSA9IFwicHRcIjtcclxuICAgIC8qKlxyXG4gICAgICogUGVyY2VudCBpcyBhIHNjYWxhYmxlIHVuaXQgc2ltaWxhciB0byBFbSwgdGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB0aGUgRW0gdW5pdHMgc2NhbGUgZmFzdGVyIHdoZW4gVGV4dC1TaXplIHN0dWZmXHJcbiAgICAgKi9cclxuICAgIEZvbnRVbml0W1wiUGVyY2VudFwiXSA9IFwiJVwiO1xyXG59KShGb250VW5pdCB8fCAoRm9udFVuaXQgPSB7fSkpO1xyXG4vKipcclxuICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBob3Jpem9udGFsIHRleHQgYWxpZ25tZW50c1xyXG4gKi9cclxudmFyIFRleHRBbGlnbjtcclxuKGZ1bmN0aW9uIChUZXh0QWxpZ24pIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgaXMgbGVmdC1hbGlnbmVkLlxyXG4gICAgICovXHJcbiAgICBUZXh0QWxpZ25bXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IGlzIHJpZ2h0LWFsaWduZWQuXHJcbiAgICAgKi9cclxuICAgIFRleHRBbGlnbltcIlJpZ2h0XCJdID0gXCJyaWdodFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBpcyBjZW50ZXJlZC5cclxuICAgICAqL1xyXG4gICAgVGV4dEFsaWduW1wiQ2VudGVyXCJdID0gXCJjZW50ZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgaXMgYWxpZ25lZCBhdCB0aGUgbm9ybWFsIHN0YXJ0IG9mIHRoZSBsaW5lIChsZWZ0LWFsaWduZWQgZm9yIGxlZnQtdG8tcmlnaHQgbG9jYWxlcyxcclxuICAgICAqIHJpZ2h0LWFsaWduZWQgZm9yIHJpZ2h0LXRvLWxlZnQgbG9jYWxlcykuXHJcbiAgICAgKi9cclxuICAgIFRleHRBbGlnbltcIlN0YXJ0XCJdID0gXCJzdGFydFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBpcyBhbGlnbmVkIGF0IHRoZSBub3JtYWwgZW5kIG9mIHRoZSBsaW5lIChyaWdodC1hbGlnbmVkIGZvciBsZWZ0LXRvLXJpZ2h0IGxvY2FsZXMsXHJcbiAgICAgKiBsZWZ0LWFsaWduZWQgZm9yIHJpZ2h0LXRvLWxlZnQgbG9jYWxlcykuXHJcbiAgICAgKi9cclxuICAgIFRleHRBbGlnbltcIkVuZFwiXSA9IFwiZW5kXCI7XHJcbn0pKFRleHRBbGlnbiB8fCAoVGV4dEFsaWduID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgYmFzZWxpbmUgdGV4dCBhbGlnbm1lbnRzXHJcbiAqL1xyXG52YXIgQmFzZUFsaWduO1xyXG4oZnVuY3Rpb24gKEJhc2VBbGlnbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgdG9wIG9mIHRoZSBlbSBzcXVhcmUuXHJcbiAgICAgKi9cclxuICAgIEJhc2VBbGlnbltcIlRvcFwiXSA9IFwidG9wXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0ZXh0IGJhc2VsaW5lIGlzIHRoZSBoYW5naW5nIGJhc2VsaW5lLiAgQ3VycmVudGx5IHVuc3VwcG9ydGVkOyB0aGlzIHdpbGwgYWN0IGxpa2VcclxuICAgICAqIGFscGhhYmV0aWMuXHJcbiAgICAgKi9cclxuICAgIEJhc2VBbGlnbltcIkhhbmdpbmdcIl0gPSBcImhhbmdpbmdcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIG1pZGRsZSBvZiB0aGUgZW0gc3F1YXJlLlxyXG4gICAgICovXHJcbiAgICBCYXNlQWxpZ25bXCJNaWRkbGVcIl0gPSBcIm1pZGRsZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgbm9ybWFsIGFscGhhYmV0aWMgYmFzZWxpbmUuXHJcbiAgICAgKi9cclxuICAgIEJhc2VBbGlnbltcIkFscGhhYmV0aWNcIl0gPSBcImFscGhhYmV0aWNcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgYmFzZWxpbmUgaXMgdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lOyB0aGlzIGlzIHRoZSBib3R0b20gb2ZcclxuICAgICAqIHRoZSBib2R5IG9mIHRoZSBjaGFyYWN0ZXJzLCBpZiB0aGUgbWFpbiBib2R5IG9mIGNoYXJhY3RlcnMgcHJvdHJ1ZGVzXHJcbiAgICAgKiBiZW5lYXRoIHRoZSBhbHBoYWJldGljIGJhc2VsaW5lLiAgQ3VycmVudGx5IHVuc3VwcG9ydGVkOyB0aGlzIHdpbGxcclxuICAgICAqIGFjdCBsaWtlIGFscGhhYmV0aWMuXHJcbiAgICAgKi9cclxuICAgIEJhc2VBbGlnbltcIklkZW9ncmFwaGljXCJdID0gXCJpZGVvZ3JhcGhpY1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgdGV4dCBiYXNlbGluZSBpcyB0aGUgYm90dG9tIG9mIHRoZSBib3VuZGluZyBib3guICBUaGlzIGRpZmZlcnNcclxuICAgICAqIGZyb20gdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lIGluIHRoYXQgdGhlIGlkZW9ncmFwaGljIGJhc2VsaW5lXHJcbiAgICAgKiBkb2Vzbid0IGNvbnNpZGVyIGRlc2NlbmRlcnMuXHJcbiAgICAgKi9cclxuICAgIEJhc2VBbGlnbltcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XHJcbn0pKEJhc2VBbGlnbiB8fCAoQmFzZUFsaWduID0ge30pKTtcclxuLyoqXHJcbiAqIEVudW0gcmVwcmVzZW50aW5nIHRoZSBkaWZmZXJlbnQgcG9zc2libGUgZm9udCBzdHlsZXNcclxuICovXHJcbnZhciBGb250U3R5bGU7XHJcbihmdW5jdGlvbiAoRm9udFN0eWxlKSB7XHJcbiAgICBGb250U3R5bGVbXCJOb3JtYWxcIl0gPSBcIm5vcm1hbFwiO1xyXG4gICAgRm9udFN0eWxlW1wiSXRhbGljXCJdID0gXCJpdGFsaWNcIjtcclxuICAgIEZvbnRTdHlsZVtcIk9ibGlxdWVcIl0gPSBcIm9ibGlxdWVcIjtcclxufSkoRm9udFN0eWxlIHx8IChGb250U3R5bGUgPSB7fSkpO1xyXG52YXIgRGlyZWN0aW9uO1xyXG4oZnVuY3Rpb24gKERpcmVjdGlvbikge1xyXG4gICAgRGlyZWN0aW9uW1wiTGVmdFRvUmlnaHRcIl0gPSBcImx0clwiO1xyXG4gICAgRGlyZWN0aW9uW1wiUmlnaHRUb0xlZnRcIl0gPSBcInJ0bFwiO1xyXG59KShEaXJlY3Rpb24gfHwgKERpcmVjdGlvbiA9IHt9KSk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRHJhd2luZy9TcHJpdGVTaGVldC50c1xudmFyIFNwcml0ZVNoZWV0X2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogU3ByaXRlIHNoZWV0cyBhcmUgYSB1c2VmdWwgbWVjaGFuaXNtIGZvciBzbGljaW5nIHVwIGltYWdlIHJlc291cmNlcyBpbnRvXHJcbiAqIHNlcGFyYXRlIHNwcml0ZXMgb3IgZm9yIGdlbmVyYXRpbmcgaW4gZ2FtZSBhbmltYXRpb25zLiBbW1Nwcml0ZXxTcHJpdGVzXV0gYXJlIG9yZ2FuaXplZFxyXG4gKiBpbiByb3cgbWFqb3Igb3JkZXIgaW4gdGhlIFtbU3ByaXRlU2hlZXRdXS5cclxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICovXHJcbmNsYXNzIFNwcml0ZVNoZWV0X1Nwcml0ZVNoZWV0IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGltYWdlT3JDb25maWdPclNwcml0ZXMgVGhlIGJhY2tpbmcgaW1hZ2UgdGV4dHVyZSB0byBidWlsZCB0aGUgU3ByaXRlU2hlZXQsIG9wdGlvbiBiYWcsIG9yIHNwcml0ZSBsaXN0XHJcbiAgICAgKiBAcGFyYW0gY29sdW1ucyAgIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgaW1hZ2UgdGV4dHVyZVxyXG4gICAgICogQHBhcmFtIHJvd3MgICAgICBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGltYWdlIHRleHR1cmVcclxuICAgICAqIEBwYXJhbSBzcFdpZHRoICAgVGhlIHdpZHRoIG9mIGVhY2ggaW5kaXZpZHVhbCBzcHJpdGUgaW4gcGl4ZWxzXHJcbiAgICAgKiBAcGFyYW0gc3BIZWlnaHQgIFRoZSBoZWlnaHQgb2YgZWFjaCBpbmRpdmlkdWFsIHNwcml0ZSBpbiBwaXhlbHNcclxuICAgICAqIEBwYXJhbSBzcGFjaW5nICAgVGhlIHNwYWNpbmcgYmV0d2VlbiBldmVyeSBzcHJpdGUgaW4gYSBzcHJpdGVzaGVldFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLCBjb2x1bW5zLCByb3dzLCBzcFdpZHRoLCBzcEhlaWdodCwgc3BhY2luZykge1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9pbWFnZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fY29sdW1ucyA9IDA7XHJcbiAgICAgICAgdGhpcy5fcm93cyA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3BXaWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3BIZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3NwYWNpbmcgPSAwO1xyXG4gICAgICAgIGxldCBsb2FkRnJvbUltYWdlID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGltYWdlT3JDb25maWdPclNwcml0ZXMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVzID0gaW1hZ2VPckNvbmZpZ09yU3ByaXRlcztcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpbWFnZU9yQ29uZmlnT3JTcHJpdGVzICYmICEoaW1hZ2VPckNvbmZpZ09yU3ByaXRlcyBpbnN0YW5jZW9mIFRleHR1cmUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2x1bW5zID0gaW1hZ2VPckNvbmZpZ09yU3ByaXRlcy5jb2x1bW5zO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcm93cyA9IGltYWdlT3JDb25maWdPclNwcml0ZXMucm93cztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3NwV2lkdGggPSBpbWFnZU9yQ29uZmlnT3JTcHJpdGVzLnNwV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcEhlaWdodCA9IGltYWdlT3JDb25maWdPclNwcml0ZXMuc3BIZWlnaHQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlT3JDb25maWdPclNwcml0ZXMuaW1hZ2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGFjaW5nID0gaW1hZ2VPckNvbmZpZ09yU3ByaXRlcy5zcGFjaW5nIHx8IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbWFnZSA9IGltYWdlT3JDb25maWdPclNwcml0ZXM7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb2x1bW5zID0gY29sdW1ucztcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jvd3MgPSByb3dzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BXaWR0aCA9IHNwV2lkdGg7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcEhlaWdodCA9IHNwSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3BhY2luZyA9IHNwYWNpbmcgfHwgMDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVzID0gbmV3IEFycmF5KHRoaXMuX2NvbHVtbnMgKiB0aGlzLl9yb3dzKTtcclxuICAgICAgICAgICAgbG9hZEZyb21JbWFnZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEluc3BlY3QgYWN0dWFsIGltYWdlIGRpbWVuc2lvbnMgd2l0aCBwcmVsb2FkaW5nXHJcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2UgaW5zdGFuY2VvZiBUZXh0dXJlKSB7XHJcbiAgICAgICAgICAgIGxldCBpc1dpZHRoRXJyb3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgbGV0IGlzSGVpZ2h0RXJyb3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuaW1hZ2UuaXNMb2FkZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgaXNXaWR0aEVycm9yID0gdGhpcy5zcFdpZHRoICogdGhpcy5jb2x1bW5zID4gdGhpcy5pbWFnZS5pbWFnZS5uYXR1cmFsV2lkdGg7XHJcbiAgICAgICAgICAgICAgICBpc0hlaWdodEVycm9yID0gdGhpcy5zcEhlaWdodCAqIHRoaXMucm93cyA+IHRoaXMuaW1hZ2UuaW1hZ2UubmF0dXJhbEhlaWdodDtcclxuICAgICAgICAgICAgICAgIGlmIChpc1dpZHRoRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgU3ByaXRlU2hlZXQgc3BlY2lmaWVkIGlzIHdpZGVyLCBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5jb2x1bW5zfSBjb2xzIHggJHt0aGlzLnNwV2lkdGh9IHBpeGVscyA+ICR7dGhpcy5pbWFnZS5pbWFnZS5uYXR1cmFsV2lkdGh9IGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgcGl4ZWxzIHRoYW4gaW1hZ2Ugd2lkdGhgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpc0hlaWdodEVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFNwcml0ZVNoZWV0IHNwZWNpZmllZCBpcyB0YWxsZXIsIGAgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBgJHt0aGlzLnJvd3N9IHJvd3MgeCAke3RoaXMuc3BIZWlnaHR9IHBpeGVscyA+ICR7dGhpcy5pbWFnZS5pbWFnZS5uYXR1cmFsSGVpZ2h0fSBgICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYHBpeGVscyB0aGFuIGltYWdlIGhlaWdodGApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChsb2FkRnJvbUltYWdlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNwYWNpbmcgPSB0aGlzLmdldFNwYWNpbmdEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93czsgcm93KyspIHtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sdW1uczsgY29sKyspIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGVzW2NvbCArIHJvdyAqIHRoaXMuY29sdW1uc10gPSBuZXcgU3ByaXRlX1Nwcml0ZSh0aGlzLmltYWdlLCBjb2wgKiB0aGlzLnNwV2lkdGggKyBzcGFjaW5nLm1hcmdpbiAqIGNvbCArIHNwYWNpbmcubGVmdCwgcm93ICogdGhpcy5zcEhlaWdodCArIHNwYWNpbmcubWFyZ2luICogcm93ICsgc3BhY2luZy50b3AsIHRoaXMuc3BXaWR0aCwgdGhpcy5zcEhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHJhdyBzcGFjaW5nIGRpbWVuc2lvbnMgZm9yIHRoZSBzcHJpdGVzIGluIHRoZSBzaGVldCwgd2hpY2ggY2FuIGJlIGEgZml4ZWQgbnVtYmVyIG9yIGN1c3RvbSBkaW1lbnNpb25zLlxyXG4gICAgICovXHJcbiAgICBnZXQgc3BhY2luZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3BhY2luZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGEgY29weSBvZiB0aGUgYmFja2luZyBzcHJpdGUgYXJyYXlcclxuICAgICAqL1xyXG4gICAgZ2V0IHNwcml0ZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLl9zcHJpdGVzXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGJhY2tpbmcgdGV4dHVyZSB1c2VkIGZvciB0aGUgc3ByaXRlIHNoZWV0XHJcbiAgICAgKi9cclxuICAgIGdldCBpbWFnZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2YgY29sdW1ucyBpbiB0aGUgc2hlZXRcclxuICAgICAqL1xyXG4gICAgZ2V0IGNvbHVtbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbHVtbnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBudW1iZXIgb2Ygcm93cyBpbiB0aGUgc2hlZXRcclxuICAgICAqL1xyXG4gICAgZ2V0IHJvd3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jvd3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB3aWR0aCBvZiB0aGUgaW5kaXZpZHVhbCBzcHJpdGVzXHJcbiAgICAgKi9cclxuICAgIGdldCBzcFdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zcFdpZHRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaGVpZ2h0IG9mIHRoZSBpbmRpdmlkdWFsIHNwcml0ZXNcclxuICAgICAqL1xyXG4gICAgZ2V0IHNwSGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zcEhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY2FsY3VsYXRlZCBzcGFjaW5nIGRpbWVuc2lvbnMgYmFzZWQgb24gd2hldGhlciBzcGFjaW5nXHJcbiAgICAgKiBpcyBhIGZpeGVkIG51bWJlciBvciBoYXMgZGlmZmVyZW50IHZhbHVlcyBmb3IgZWFjaCBkaW1lbnNpb25cclxuICAgICAqL1xyXG4gICAgZ2V0U3BhY2luZ0RpbWVuc2lvbnMoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNwYWNpbmcgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiB0aGlzLnNwYWNpbmcsXHJcbiAgICAgICAgICAgICAgICB0b3A6IHRoaXMuc3BhY2luZyxcclxuICAgICAgICAgICAgICAgIG1hcmdpbjogdGhpcy5zcGFjaW5nXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogKF9hID0gdGhpcy5zcGFjaW5nLmxlZnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsXHJcbiAgICAgICAgICAgICAgICB0b3A6IChfYiA9IHRoaXMuc3BhY2luZy50b3ApICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDAsXHJcbiAgICAgICAgICAgICAgICBtYXJnaW46IChfYyA9IHRoaXMuc3BhY2luZy5tYXJnaW4pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhbiBhbmltYXRpb24gZnJvbSB0aGUgdGhpcyBTcHJpdGVTaGVldCBieSBsaXN0aW5nIG91dCB0aGVcclxuICAgICAqIHNwcml0ZSBpbmRpY2VzLiBTcHJpdGVzIGFyZSBvcmdhbml6ZWQgaW4gcm93IG1ham9yIG9yZGVyIGluIHRoZSBTcHJpdGVTaGVldC5cclxuICAgICAqIEBwYXJhbSBlbmdpbmUgICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBbW0VuZ2luZV1dXHJcbiAgICAgKiBAcGFyYW0gaW5kaWNlcyAgQW4gYXJyYXkgb2Ygc3ByaXRlIGluZGljZXMgdG8gdXNlIGluIHRoZSBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSBzcGVlZCAgICBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgaW4gdGhlIGFuaW1hdGlvblxyXG4gICAgICovXHJcbiAgICBnZXRBbmltYXRpb25CeUluZGljZXMoZW5naW5lLCBpbmRpY2VzLCBzcGVlZCkge1xyXG4gICAgICAgIGxldCBpbWFnZXMgPSBpbmRpY2VzLm1hcCgoaW5kZXgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlc1tpbmRleF07XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaW1hZ2VzID0gaW1hZ2VzLm1hcChmdW5jdGlvbiAoaSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaS5jbG9uZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uX0FuaW1hdGlvbihlbmdpbmUsIGltYWdlcywgc3BlZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gYW5pbWF0aW9uIGZyb20gdGhlIHRoaXMgU3ByaXRlU2hlZXQgYnkgc3BlY2lmeWluZyB0aGUgcmFuZ2Ugb2ZcclxuICAgICAqIGltYWdlcyB3aXRoIHRoZSBiZWdpbm5pbmcgKGluY2x1c2l2ZSkgYW5kIGVuZGluZyAoZXhjbHVzaXZlKSBpbmRleFxyXG4gICAgICogRm9yIGV4YW1wbGUgYGdldEFuaW1hdGlvbkJldHdlZW4oZW5naW5lLCAwLCA1LCAyMDApYCByZXR1cm5zIGFuIGFuaW1hdGlvbiB3aXRoIDUgZnJhbWVzLlxyXG4gICAgICogQHBhcmFtIGVuZ2luZSAgICAgIFJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIEVuZ2luZVxyXG4gICAgICogQHBhcmFtIGJlZ2luSW5kZXggIFRoZSBpbmRleCB0byBzdGFydCB0YWtpbmcgZnJhbWVzIChpbmNsdXNpdmUpXHJcbiAgICAgKiBAcGFyYW0gZW5kSW5kZXggICAgVGhlIGluZGV4IHRvIHN0b3AgdGFraW5nIGZyYW1lcyAoZXhjbHVzaXZlKVxyXG4gICAgICogQHBhcmFtIHNwZWVkICAgICAgIFRoZSBudW1iZXIgaW4gbWlsbGlzZWNvbmRzIHRvIGRpc3BsYXkgZWFjaCBmcmFtZSBpbiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldEFuaW1hdGlvbkJldHdlZW4oZW5naW5lLCBiZWdpbkluZGV4LCBlbmRJbmRleCwgc3BlZWQpIHtcclxuICAgICAgICBsZXQgaW1hZ2VzID0gdGhpcy5zcHJpdGVzLnNsaWNlKGJlZ2luSW5kZXgsIGVuZEluZGV4KTtcclxuICAgICAgICBpbWFnZXMgPSBpbWFnZXMubWFwKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpLmNsb25lKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25fQW5pbWF0aW9uKGVuZ2luZSwgaW1hZ2VzLCBzcGVlZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyZWF0IHRoZSBlbnRpcmUgU3ByaXRlU2hlZXQgYXMgb25lIGFuaW1hdGlvbiwgb3JnYW5pemluZyB0aGUgZnJhbWVzIGluXHJcbiAgICAgKiByb3cgbWFqb3Igb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gZW5naW5lICBSZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgZ2FtZSBbW0VuZ2luZV1dXHJcbiAgICAgKiBAcGFyYW0gc3BlZWQgICBUaGUgbnVtYmVyIGluIG1pbGxpc2Vjb25kcyB0byBkaXNwbGF5IGVhY2ggZnJhbWUgdGhlIGFuaW1hdGlvblxyXG4gICAgICovXHJcbiAgICBnZXRBbmltYXRpb25Gb3JBbGwoZW5naW5lLCBzcGVlZCkge1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZXMgPSB0aGlzLnNwcml0ZXMubWFwKGZ1bmN0aW9uIChpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBpLmNsb25lKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBBbmltYXRpb25fQW5pbWF0aW9uKGVuZ2luZSwgc3ByaXRlcywgc3BlZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBhIHNwZWNpZmljIHNwcml0ZSBmcm9tIHRoZSBTcHJpdGVTaGVldCBieSBpdHMgaW5kZXguIFNwcml0ZXMgYXJlIG9yZ2FuaXplZFxyXG4gICAgICogaW4gcm93IG1ham9yIG9yZGVyIGluIHRoZSBTcHJpdGVTaGVldC5cclxuICAgICAqIEBwYXJhbSBpbmRleCAgVGhlIGluZGV4IG9mIHRoZSBzcHJpdGVcclxuICAgICAqL1xyXG4gICAgZ2V0U3ByaXRlKGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IDAgJiYgaW5kZXggPCB0aGlzLnNwcml0ZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwcml0ZXNbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGluZGV4OiAnICsgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFuIGFuaW1hdGlvbiB3aXRoIGJlc3Bva2Ugc3ByaXRlIGNvb3JkaW5hdGVzLiBUaGlzIGlzIHVzZWZ1bCBpZiB0aGUgU3ByaXRlU2hlZXQgaXNcclxuICAgICAqIHBhY2tlZCBhbmQgbm90IGEgdW5pZm9ybSB3aWR0aCBvciBoZWlnaHQuIFRoZSByZXN1bHRpbmcgW1tBbmltYXRpb25dXSB3aWxsIGhhdmUgdGhlIGhlaWdodCBhbmQgd2lkdGggb2YgdGhlXHJcbiAgICAgKiBsYXJnZXN0IGRpbWVuc2lvbiAod2lkdGgsIGhlaWdodCkgZnJvbSBhbW9uZyB0aGUgc3ByaXRlIGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAcGFyYW0gZW5naW5lXHJcbiAgICAgKiBAcGFyYW0gc3ByaXRlQ29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSBzcGVlZFxyXG4gICAgICovXHJcbiAgICBnZXRBbmltYXRpb25CeUNvb3JkcyhlbmdpbmUsIHNwcml0ZUNvb3JkaW5hdGVzLCBzcGVlZCkge1xyXG4gICAgICAgIGxldCBtYXhXaWR0aCA9IDA7XHJcbiAgICAgICAgbGV0IG1heEhlaWdodCA9IDA7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlcyA9IG5ldyBBcnJheShzcHJpdGVDb29yZGluYXRlcy5sZW5ndGgpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ByaXRlQ29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgY29vcmQgPSBzcHJpdGVDb29yZGluYXRlc1tpXTtcclxuICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBwYXNzIGltYWdlIGFnYWluIGlmIHVzaW5nIGEgc3ByaXRlc2hlZXRcclxuICAgICAgICAgICAgY29vcmQuaW1hZ2UgPSBjb29yZC5pbWFnZSB8fCB0aGlzLmltYWdlO1xyXG4gICAgICAgICAgICBtYXhXaWR0aCA9IE1hdGgubWF4KG1heFdpZHRoLCBjb29yZC5kcmF3V2lkdGgpO1xyXG4gICAgICAgICAgICBtYXhIZWlnaHQgPSBNYXRoLm1heChtYXhIZWlnaHQsIGNvb3JkLmRyYXdIZWlnaHQpO1xyXG4gICAgICAgICAgICBzcHJpdGVzW2ldID0gbmV3IFNwcml0ZV9TcHJpdGUoY29vcmQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBhbmltID0gbmV3IEFuaW1hdGlvbl9BbmltYXRpb24oZW5naW5lLCBzcHJpdGVzLCBzcGVlZCk7XHJcbiAgICAgICAgYW5pbS5kcmF3V2lkdGggPSBtYXhXaWR0aDtcclxuICAgICAgICBhbmltLmRyYXdIZWlnaHQgPSBtYXhIZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIGFuaW07XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFNwcml0ZSBmb250cyBhcmUgYSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggYSBbW0xhYmVsXV0gdG8gc3BlY2lmeVxyXG4gKiBhIHBhcnRpY3VsYXIgYml0bWFwIGFzIGEgZm9udC4gTm90ZSB0aGF0IHNvbWUgZm9udCBmZWF0dXJlcyBhcmUgbm90XHJcbiAqIHN1cHBvcnRlZCBieSBTcHJpdGUgZm9udHMuXHJcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbnRvIHYwLjI2LjBcclxuICovXHJcbmxldCBTcHJpdGVGb250ID0gY2xhc3MgU3ByaXRlRm9udCBleHRlbmRzIFNwcml0ZVNoZWV0X1Nwcml0ZVNoZWV0IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGltYWdlT3JDb25maWcgICBUaGUgYmFja2luZyBpbWFnZSB0ZXh0dXJlIHRvIGJ1aWxkIHRoZSBTcHJpdGVGb250IG9yIHRoZSBzcHJpdGUgZm9udCBvcHRpb24gYmFnXHJcbiAgICAgKiBAcGFyYW0gYWxwaGFiZXQgICAgICAgIEEgc3RyaW5nIHJlcHJlc2VudGluZyBhbGwgdGhlIGNoYXJhY3RlcnMgaW4gdGhlIGltYWdlLCBpbiByb3cgbWFqb3Igb3JkZXIuXHJcbiAgICAgKiBAcGFyYW0gY2FzZUluc2Vuc2l0aXZlICBJbmRpY2F0ZSB3aGV0aGVyIHRoaXMgZm9udCB0YWtlcyBjYXNlIGludG8gYWNjb3VudFxyXG4gICAgICogQHBhcmFtIGNvbHVtbnMgICAgICAgICBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgb2YgY2hhcmFjdGVycyBpbiB0aGUgaW1hZ2VcclxuICAgICAqIEBwYXJhbSByb3dzICAgICAgICAgICAgVGhlIG51bWJlciBvZiByb3dzIG9mIGNoYXJhY3RlcnMgaW4gdGhlIGltYWdlXHJcbiAgICAgKiBAcGFyYW0gc3BXaWR0aCAgICAgICAgIFRoZSB3aWR0aCBvZiBlYWNoIGNoYXJhY3RlciBpbiBwaXhlbHNcclxuICAgICAqIEBwYXJhbSBzcEhlaWdodCAgICAgICAgVGhlIGhlaWdodCBvZiBlYWNoIGNoYXJhY3RlciBpbiBwaXhlbHNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoaW1hZ2VPckNvbmZpZywgYWxwaGFiZXQsIGNhc2VJbnNlbnNpdGl2ZSwgY29sdW1ucywgcm93cywgc3BXaWR0aCwgc3BIZWlnaHQsIHNwYWNpbmcpIHtcclxuICAgICAgICBzdXBlcihpbWFnZU9yQ29uZmlnIGluc3RhbmNlb2YgVGV4dHVyZVxyXG4gICAgICAgICAgICA/IHtcclxuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZU9yQ29uZmlnLFxyXG4gICAgICAgICAgICAgICAgc3BXaWR0aDogc3BXaWR0aCxcclxuICAgICAgICAgICAgICAgIHNwSGVpZ2h0OiBzcEhlaWdodCxcclxuICAgICAgICAgICAgICAgIHJvd3M6IHJvd3MsXHJcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiBjb2x1bW5zLFxyXG4gICAgICAgICAgICAgICAgc3BhY2luZzogc3BhY2luZyB8fCAwXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgOiBpbWFnZU9yQ29uZmlnKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSBDb2xvci5CbGFjaztcclxuICAgICAgICB0aGlzLl9jdXJyZW50T3BhY2l0eSA9IDEuMDtcclxuICAgICAgICB0aGlzLl9zcHJpdGVSZWNvcmQgPSB7fTtcclxuICAgICAgICAvLyB0ZXh0IHNoYWRvd1xyXG4gICAgICAgIHRoaXMuX3RleHRTaGFkb3dPbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3RleHRTaGFkb3dEaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fdGV4dFNoYWRvd0NvbG9yID0gQ29sb3IuQmxhY2s7XHJcbiAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXMgPSB7fTtcclxuICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRYID0gNTtcclxuICAgICAgICB0aGlzLl9zaGFkb3dPZmZzZXRZID0gNTtcclxuICAgICAgICBpZiAoaW1hZ2VPckNvbmZpZyAmJiAhKGltYWdlT3JDb25maWcgaW5zdGFuY2VvZiBUZXh0dXJlKSkge1xyXG4gICAgICAgICAgICBhbHBoYWJldCA9IGltYWdlT3JDb25maWcuYWxwaGFiZXQ7XHJcbiAgICAgICAgICAgIGNhc2VJbnNlbnNpdGl2ZSA9IGltYWdlT3JDb25maWcuY2FzZUluc2Vuc2l0aXZlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFscGhhYmV0ID0gYWxwaGFiZXQ7XHJcbiAgICAgICAgdGhpcy5jYXNlSW5zZW5zaXRpdmUgPSBjYXNlSW5zZW5zaXRpdmU7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlUmVjb3JkID0gdGhpcy5nZXRUZXh0U3ByaXRlcygpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgZGljdGlvbmFyeSB0aGF0IG1hcHMgZWFjaCBjaGFyYWN0ZXIgaW4gdGhlIGFscGhhYmV0IHRvIHRoZSBhcHByb3ByaWF0ZSBbW1Nwcml0ZV1dLlxyXG4gICAgICovXHJcbiAgICBnZXRUZXh0U3ByaXRlcygpIHtcclxuICAgICAgICBjb25zdCBsb29rdXAgPSB7fTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYWxwaGFiZXQubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbGV0IGNoYXIgPSB0aGlzLmFscGhhYmV0W2ldO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jYXNlSW5zZW5zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgIGNoYXIgPSBjaGFyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbG9va3VwW2NoYXJdID0gdGhpcy5zcHJpdGVzW2ldLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb29rdXA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHRleHQgc2hhZG93IGZvciBzcHJpdGUgZm9udHNcclxuICAgICAqIEBwYXJhbSBvZmZzZXRYICAgICAgVGhlIHggb2Zmc2V0IGluIHBpeGVscyB0byBwbGFjZSB0aGUgc2hhZG93XHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0WSAgICAgIFRoZSB5IG9mZnNldCBpbiBwaXhlbHMgdG8gcGxhY2UgdGhlIHNoYWRvd1xyXG4gICAgICogQHBhcmFtIHNoYWRvd0NvbG9yICBUaGUgY29sb3Igb2YgdGhlIHRleHQgc2hhZG93XHJcbiAgICAgKi9cclxuICAgIHNldFRleHRTaGFkb3cob2Zmc2V0WCwgb2Zmc2V0WSwgc2hhZG93Q29sb3IpIHtcclxuICAgICAgICB0aGlzLl90ZXh0U2hhZG93T24gPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFggPSBvZmZzZXRYO1xyXG4gICAgICAgIHRoaXMuX3NoYWRvd09mZnNldFkgPSBvZmZzZXRZO1xyXG4gICAgICAgIHRoaXMuX3RleHRTaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgdGhpcy5fdGV4dFNoYWRvd0RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNoYXJhY3RlciBpbiB0aGlzLl9zcHJpdGVSZWNvcmQpIHtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXSA9IHRoaXMuX3Nwcml0ZVJlY29yZFtjaGFyYWN0ZXJdLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUb2dnbGVzIHRleHQgc2hhZG93cyBvbiBvciBvZmZcclxuICAgICAqL1xyXG4gICAgdXNlVGV4dFNoYWRvdyhvbikge1xyXG4gICAgICAgIHRoaXMuX3RleHRTaGFkb3dPbiA9IG9uO1xyXG4gICAgICAgIGlmIChvbikge1xyXG4gICAgICAgICAgICB0aGlzLnNldFRleHRTaGFkb3coNSwgNSwgdGhpcy5fdGV4dFNoYWRvd0NvbG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERyYXdzIHRoZSBjdXJyZW50IHNwcml0ZSBmb250XHJcbiAgICAgKi9cclxuICAgIGRyYXcoY3R4LCB0ZXh0LCB4LCB5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMuX3BhcnNlT3B0aW9ucyhvcHRpb25zKTtcclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudENvbG9yLnRvU3RyaW5nKCkgIT09IG9wdGlvbnMuY29sb3IudG9TdHJpbmcoKSB8fCB0aGlzLl9jdXJyZW50T3BhY2l0eSAhPT0gb3B0aW9ucy5vcGFjaXR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRPcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IgPSBvcHRpb25zLmNvbG9yO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoYXIgaW4gdGhpcy5fc3ByaXRlUmVjb3JkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGVSZWNvcmRbY2hhcl0uY2xlYXJFZmZlY3RzKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zcHJpdGVSZWNvcmRbY2hhcl0uZmlsbChvcHRpb25zLmNvbG9yKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZVJlY29yZFtjaGFyXS5vcGFjaXR5KG9wdGlvbnMub3BhY2l0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX3RleHRTaGFkb3dPbiAmJiB0aGlzLl90ZXh0U2hhZG93RGlydHkgJiYgdGhpcy5fdGV4dFNoYWRvd0NvbG9yKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hhcmFjdGVyU2hhZG93IGluIHRoaXMuX3RleHRTaGFkb3dTcHJpdGVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJTaGFkb3ddLmNsZWFyRWZmZWN0cygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyU2hhZG93XS5hZGRFZmZlY3QobmV3IEZpbGwodGhpcy5fdGV4dFNoYWRvd0NvbG9yLmNsb25lKCkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93RGlydHkgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudCBsZW5ndGggb2YgdGV4dCBpbiBwaXhlbHNcclxuICAgICAgICBjb25zdCBzcHJpdGUgPSB0aGlzLnNwcml0ZXNbMF07XHJcbiAgICAgICAgLy8gZmluZCB0aGUgY3VycmVudCBoZWlnaHQgZm8gdGhlIHRleHQgaW4gcGl4ZWxzXHJcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gc3ByaXRlLmhlaWdodDtcclxuICAgICAgICAvLyBjYWxjdWxhdGUgYXBwcm9wcmlhdGUgc2NhbGUgZm9yIGZvbnQgc2l6ZVxyXG4gICAgICAgIGNvbnN0IHNjYWxlID0gb3B0aW9ucy5mb250U2l6ZSAvIGhlaWdodDtcclxuICAgICAgICBjb25zdCBsZW5ndGggPSB0ZXh0Lmxlbmd0aCAqIHNwcml0ZS53aWR0aCAqIHNjYWxlICsgdGV4dC5sZW5ndGggKiBvcHRpb25zLmxldHRlclNwYWNpbmc7XHJcbiAgICAgICAgbGV0IGN1cnJYID0geDtcclxuICAgICAgICBpZiAob3B0aW9ucy50ZXh0QWxpZ24gPT09IFRleHRBbGlnbi5MZWZ0IHx8IG9wdGlvbnMudGV4dEFsaWduID09PSBUZXh0QWxpZ24uU3RhcnQpIHtcclxuICAgICAgICAgICAgY3VyclggPSB4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLnRleHRBbGlnbiA9PT0gVGV4dEFsaWduLlJpZ2h0IHx8IG9wdGlvbnMudGV4dEFsaWduID09PSBUZXh0QWxpZ24uRW5kKSB7XHJcbiAgICAgICAgICAgIGN1cnJYID0geCAtIGxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy50ZXh0QWxpZ24gPT09IFRleHRBbGlnbi5DZW50ZXIpIHtcclxuICAgICAgICAgICAgY3VyclggPSB4IC0gbGVuZ3RoIC8gMjtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGN1cnJZID0geSAtIGhlaWdodCAqIHNjYWxlO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmJhc2VBbGlnbiA9PT0gQmFzZUFsaWduLlRvcCB8fCBvcHRpb25zLmJhc2VBbGlnbiA9PT0gQmFzZUFsaWduLkhhbmdpbmcpIHtcclxuICAgICAgICAgICAgY3VyclkgPSB5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmJhc2VBbGlnbiA9PT0gQmFzZUFsaWduLklkZW9ncmFwaGljIHx8XHJcbiAgICAgICAgICAgIG9wdGlvbnMuYmFzZUFsaWduID09PSBCYXNlQWxpZ24uQm90dG9tIHx8XHJcbiAgICAgICAgICAgIG9wdGlvbnMuYmFzZUFsaWduID09PSBCYXNlQWxpZ24uQWxwaGFiZXRpYykge1xyXG4gICAgICAgICAgICBjdXJyWSA9IHkgLSBoZWlnaHQgKiBzY2FsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5iYXNlQWxpZ24gPT09IEJhc2VBbGlnbi5NaWRkbGUpIHtcclxuICAgICAgICAgICAgY3VyclkgPSB5IC0gKGhlaWdodCAqIHNjYWxlKSAvIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsZXQgY2hhcmFjdGVyID0gdGV4dFtpXTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuY2FzZUluc2Vuc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXIgPSBjaGFyYWN0ZXIudG9Mb3dlckNhc2UoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgdGV4dCBzaGFkb3dcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl90ZXh0U2hhZG93T24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJdLmRyYXdBcm91bmRBbmNob3IgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0U2hhZG93U3ByaXRlc1tjaGFyYWN0ZXJdLnNjYWxlID0gdmVjKHNjYWxlLCBzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGV4dFNoYWRvd1Nwcml0ZXNbY2hhcmFjdGVyXS5kcmF3KGN0eCwgY3VyclggKyB0aGlzLl9zaGFkb3dPZmZzZXRYLCBjdXJyWSArIHRoaXMuX3NoYWRvd09mZnNldFkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgY2hhclNwcml0ZSA9IHRoaXMuX3Nwcml0ZVJlY29yZFtjaGFyYWN0ZXJdO1xyXG4gICAgICAgICAgICAgICAgY2hhclNwcml0ZS5kcmF3QXJvdW5kQW5jaG9yID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLnNjYWxlID0gdmVjKHNjYWxlLCBzY2FsZSk7XHJcbiAgICAgICAgICAgICAgICBjaGFyU3ByaXRlLmRyYXcoY3R4LCBjdXJyWCwgY3VyclkpO1xyXG4gICAgICAgICAgICAgICAgY3VyclggKz0gY2hhclNwcml0ZS5kcmF3V2lkdGggKyBvcHRpb25zLmxldHRlclNwYWNpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKGBTcHJpdGVGb250IEVycm9yIGRyYXdpbmcgY2hhciAke2NoYXJhY3Rlcn1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wYXJzZU9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGZvbnRTaXplOiBvcHRpb25zLmZvbnRTaXplIHx8IDEwLFxyXG4gICAgICAgICAgICBsZXR0ZXJTcGFjaW5nOiBvcHRpb25zLmxldHRlclNwYWNpbmcgfHwgMCxcclxuICAgICAgICAgICAgY29sb3I6IG9wdGlvbnMuY29sb3IgfHwgQ29sb3IuQmxhY2ssXHJcbiAgICAgICAgICAgIHRleHRBbGlnbjogdHlwZW9mIG9wdGlvbnMudGV4dEFsaWduID09PSB1bmRlZmluZWQgPyBUZXh0QWxpZ24uTGVmdCA6IG9wdGlvbnMudGV4dEFsaWduLFxyXG4gICAgICAgICAgICBiYXNlQWxpZ246IHR5cGVvZiBvcHRpb25zLmJhc2VBbGlnbiA9PT0gdW5kZWZpbmVkID8gQmFzZUFsaWduLkJvdHRvbSA6IG9wdGlvbnMuYmFzZUFsaWduLFxyXG4gICAgICAgICAgICBtYXhXaWR0aDogb3B0aW9ucy5tYXhXaWR0aCB8fCAtMSxcclxuICAgICAgICAgICAgb3BhY2l0eTogb3B0aW9ucy5vcGFjaXR5IHx8IDBcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59O1xyXG5TcHJpdGVGb250ID0gU3ByaXRlU2hlZXRfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdTcHJpdGVTaGVldCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIEdyYXBoaWNzLlNwcml0ZVNoZWV0J1xyXG4gICAgfSlcclxuXSwgU3ByaXRlRm9udCk7XHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL1Nwcml0ZVNoZWV0LnRzXG5cclxuXHJcblxyXG4vKipcclxuICogUmVwcmVzZW50cyBhIGNvbGxlY3Rpb24gb2Ygc3ByaXRlcyBmcm9tIGEgc291cmNlIGltYWdlIHdpdGggc29tZSBvcmdhbml6YXRpb24gaW4gYSBncmlkXHJcbiAqL1xyXG5jbGFzcyBTcHJpdGVTaGVldCB7XHJcbiAgICAvKipcclxuICAgICAqIEJ1aWxkIGEgbmV3IHNwcml0ZSBzaGVldCBmcm9tIGEgbGlzdCBvZiBzcHJpdGVzXHJcbiAgICAgKlxyXG4gICAgICogVXNlIFtbU3ByaXRlU2hlZXQuZnJvbUltYWdlU291cmNlXV0gdG8gY3JlYXRlIGEgU3ByaXRlU2hlZXQgZnJvbSBhbiBbW0ltYWdlU291cmNlXV0gb3JnYW5pemVkIGluIGEgZ3JpZFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuc3ByaXRlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHsgc3ByaXRlcywgcm93cywgY29sdW1ucyB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLnNwcml0ZXMgPSBzcHJpdGVzO1xyXG4gICAgICAgIHRoaXMucm93cyA9IHJvd3MgIT09IG51bGwgJiYgcm93cyAhPT0gdm9pZCAwID8gcm93cyA6IDE7XHJcbiAgICAgICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucyAhPT0gbnVsbCAmJiBjb2x1bW5zICE9PSB2b2lkIDAgPyBjb2x1bW5zIDogdGhpcy5zcHJpdGVzLmxlbmd0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZCBhIHNwcml0ZSBieSB0aGVpciB4L3kgcG9zaXRpb24gaW4gdGhlIFNwcml0ZVNoZWV0LCBmb3IgZXhhbXBsZSBgZ2V0U3ByaXRlKDAsIDApYCBpcyB0aGUgW1tTcHJpdGVdXSBpbiB0aGUgdG9wLWxlZnRcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICovXHJcbiAgICBnZXRTcHJpdGUoeCwgeSkge1xyXG4gICAgICAgIGlmICh4ID49IHRoaXMuY29sdW1ucyB8fCB4IDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgTm8gc3ByaXRlIGV4aXN0cyBpbiB0aGUgU3ByaXRlU2hlZXQgYXQgKCR7eH0sICR7eX0pLCB4OiAke3h9IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5jb2x1bW5zIC0gMX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh5ID49IHRoaXMucm93cyB8fCB5IDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgTm8gc3ByaXRlIGV4aXN0cyBpbiB0aGUgU3ByaXRlU2hlZXQgYXQgKCR7eH0sICR7eX0pLCB5OiAke3l9IHNob3VsZCBiZSBiZXR3ZWVuIDAgYW5kICR7dGhpcy5yb3dzIC0gMX1gKTtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNwcml0ZUluZGV4ID0geCArIHkgKiB0aGlzLmNvbHVtbnM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ByaXRlc1tzcHJpdGVJbmRleF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRvIGEgZ3JhcGhpY3Mgc3ByaXRlIHNoZWV0IGZyb20gYSBsZWdhY3kgc3ByaXRlIHNoZWV0XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tTGVnYWN5U3ByaXRlU2hlZXQobGVnYWN5U3ByaXRlU2hlZXQpIHtcclxuICAgICAgICBjb25zdCBzcHJpdGVzID0gbGVnYWN5U3ByaXRlU2hlZXQuc3ByaXRlcy5tYXAob2xkU3ByaXRlID0+IFNwcml0ZS5mcm9tTGVnYWN5U3ByaXRlKG9sZFNwcml0ZSkpO1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlU2hlZXQoe1xyXG4gICAgICAgICAgICBzcHJpdGVzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcGFyYW0gc3ByaXRlU2hlZXRcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0b0xlZ2FjeVNwcml0ZVNoZWV0KHNwcml0ZVNoZWV0KSB7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlcyA9IHNwcml0ZVNoZWV0LnNwcml0ZXMubWFwKHNwcml0ZSA9PiBTcHJpdGUudG9MZWdhY3lTcHJpdGUoc3ByaXRlKSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGVTaGVldF9TcHJpdGVTaGVldChzcHJpdGVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgU3ByaXRlU2hlZXQgZnJvbSBhbiBbW0ltYWdlU291cmNlXV0gb3JnYW5pemVkIGluIGEgZ3JpZFxyXG4gICAgICpcclxuICAgICAqIEV4YW1wbGU6XHJcbiAgICAgKiBgYGBcclxuICAgICAqIGNvbnN0IHNwcml0ZVNoZWV0ID0gU3ByaXRlU2hlZXQuZnJvbUltYWdlU291cmNlKHtcclxuICAgICAqICAgaW1hZ2U6IGltYWdlU291cmNlLFxyXG4gICAgICogICBncmlkOiB7XHJcbiAgICAgKiAgICAgcm93czogNSxcclxuICAgICAqICAgICBjb2x1bW5zOiAyLFxyXG4gICAgICogICAgIHNwcml0ZVdpZHRoOiAzMiwgLy8gcGl4ZWxzXHJcbiAgICAgKiAgICAgc3ByaXRlSGVpZ2h0OiAzMiAvLyBwaXhlbHNcclxuICAgICAqICAgfSxcclxuICAgICAqICAgLy8gT3B0aW9uYWxseSBzcGVjaWZ5IHNwYWNpbmdcclxuICAgICAqICAgc3BhY2luZzoge1xyXG4gICAgICogICAgIC8vIHBpeGVscyBmcm9tIHRoZSB0b3AgbGVmdCB0byBzdGFydCB0aGUgc3ByaXRlIHBhcnNpbmdcclxuICAgICAqICAgICBvcmlnaW5PZmZzZXQ6IHtcclxuICAgICAqICAgICAgIHg6IDUsXHJcbiAgICAgKiAgICAgICB5OiA1XHJcbiAgICAgKiAgICAgfSxcclxuICAgICAqICAgICAvLyBwaXhlbHMgYmV0d2VlbiBlYWNoIHNwcml0ZSB3aGlsZSBwYXJzaW5nXHJcbiAgICAgKiAgICAgbWFyZ2luOiB7XHJcbiAgICAgKiAgICAgICB4OiAxLFxyXG4gICAgICogICAgICAgeTogMVxyXG4gICAgICogICAgIH1cclxuICAgICAqICAgfVxyXG4gICAgICogfSlcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tSW1hZ2VTb3VyY2Uob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCBzcHJpdGVzID0gW107XHJcbiAgICAgICAgb3B0aW9ucy5zcGFjaW5nID0gKF9hID0gb3B0aW9ucy5zcGFjaW5nKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcclxuICAgICAgICBjb25zdCB7IGltYWdlLCBncmlkOiB7IHJvd3MsIGNvbHVtbnM6IGNvbHMsIHNwcml0ZVdpZHRoLCBzcHJpdGVIZWlnaHQgfSwgc3BhY2luZzogeyBvcmlnaW5PZmZzZXQsIG1hcmdpbiB9IH0gPSBvcHRpb25zO1xyXG4gICAgICAgIGNvbnN0IG9mZnNldERlZmF1bHRzID0gT2JqZWN0LmFzc2lnbih7IHg6IDAsIHk6IDAgfSwgb3JpZ2luT2Zmc2V0KTtcclxuICAgICAgICBjb25zdCBtYXJnaW5EZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oeyB4OiAwLCB5OiAwIH0sIG1hcmdpbik7XHJcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCBjb2xzOyB4KyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCByb3dzOyB5KyspIHtcclxuICAgICAgICAgICAgICAgIHNwcml0ZXNbeCArIHkgKiBjb2xzXSA9IG5ldyBTcHJpdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZSxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VWaWV3OiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IHggKiBzcHJpdGVXaWR0aCArIG1hcmdpbkRlZmF1bHRzLnggKiB4ICsgb2Zmc2V0RGVmYXVsdHMueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogeSAqIHNwcml0ZUhlaWdodCArIG1hcmdpbkRlZmF1bHRzLnkgKiB5ICsgb2Zmc2V0RGVmYXVsdHMueSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHNwcml0ZVdpZHRoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHNwcml0ZUhlaWdodFxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgZGVzdFNpemU6IHsgaGVpZ2h0OiBzcHJpdGVIZWlnaHQsIHdpZHRoOiBzcHJpdGVXaWR0aCB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZVNoZWV0KHtcclxuICAgICAgICAgICAgc3ByaXRlczogc3ByaXRlcyxcclxuICAgICAgICAgICAgcm93czogcm93cyxcclxuICAgICAgICAgICAgY29sdW1uczogY29sc1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvU3ByaXRlRm9udC50c1xuXHJcblxyXG5cclxuXHJcbmNsYXNzIFNwcml0ZUZvbnRfU3ByaXRlRm9udCBleHRlbmRzIEdyYXBoaWMge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX3RleHQgPSAnJztcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5hbHBoYWJldCA9ICcnO1xyXG4gICAgICAgIHRoaXMuc2hhZG93ID0gbnVsbDtcclxuICAgICAgICB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3BhY2luZyA9IDA7XHJcbiAgICAgICAgdGhpcy5fbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHsgYWxwaGFiZXQsIHNwcml0ZVNoZWV0LCBjYXNlSW5zZW5zaXRpdmUsIHNwYWNpbmcsIHNoYWRvdyB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLmFscGhhYmV0ID0gYWxwaGFiZXQ7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVTaGVldCA9IHNwcml0ZVNoZWV0O1xyXG4gICAgICAgIHRoaXMuY2FzZUluc2Vuc2l0aXZlID0gY2FzZUluc2Vuc2l0aXZlICE9PSBudWxsICYmIGNhc2VJbnNlbnNpdGl2ZSAhPT0gdm9pZCAwID8gY2FzZUluc2Vuc2l0aXZlIDogdGhpcy5jYXNlSW5zZW5zaXRpdmU7XHJcbiAgICAgICAgdGhpcy5zcGFjaW5nID0gc3BhY2luZyAhPT0gbnVsbCAmJiBzcGFjaW5nICE9PSB2b2lkIDAgPyBzcGFjaW5nIDogdGhpcy5zcGFjaW5nO1xyXG4gICAgICAgIHRoaXMuc2hhZG93ID0gc2hhZG93ICE9PSBudWxsICYmIHNoYWRvdyAhPT0gdm9pZCAwID8gc2hhZG93IDogdGhpcy5zaGFkb3c7XHJcbiAgICAgICAgdGhpcy5zcHJpdGVTaGVldC5zcHJpdGVzWzBdLmltYWdlLnJlYWR5LnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVEaW1lbnNpb25zKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUxlZ2FjeVNwcml0ZUZvbnQoc3ByaXRlRm9udCkge1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZXMgPSBzcHJpdGVGb250LnNwcml0ZXMubWFwKFNwcml0ZS5mcm9tTGVnYWN5U3ByaXRlKTtcclxuICAgICAgICByZXR1cm4gbmV3IFNwcml0ZUZvbnRfU3ByaXRlRm9udCh7XHJcbiAgICAgICAgICAgIGFscGhhYmV0OiBzcHJpdGVGb250LmFscGhhYmV0LFxyXG4gICAgICAgICAgICBzcGFjaW5nOiAwLFxyXG4gICAgICAgICAgICBjYXNlSW5zZW5zaXRpdmU6IHNwcml0ZUZvbnQuY2FzZUluc2Vuc2l0aXZlLFxyXG4gICAgICAgICAgICBzcHJpdGVTaGVldDogbmV3IFNwcml0ZVNoZWV0KHtcclxuICAgICAgICAgICAgICAgIHNwcml0ZXNcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF9nZXRDaGFyYWN0ZXJTcHJpdGVzKHRleHQpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zcHJpdGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XHJcbiAgICAgICAgLy8gaGFuZGxlIGNhc2UgaW5zZW5zdGl2ZVxyXG4gICAgICAgIGNvbnN0IHRleHRUb1JlbmRlciA9IHRoaXMuY2FzZUluc2Vuc2l0aXZlID8gdGV4dC50b0xvY2FsZUxvd2VyQ2FzZSgpIDogdGV4dDtcclxuICAgICAgICBjb25zdCBhbHBoYWJldCA9IHRoaXMuY2FzZUluc2Vuc2l0aXZlID8gdGhpcy5hbHBoYWJldC50b0xvY2FsZUxvd2VyQ2FzZSgpIDogdGhpcy5hbHBoYWJldDtcclxuICAgICAgICAvLyBmb3IgZWFjaCBsZXR0ZXIgaW4gdGV4dFxyXG4gICAgICAgIGZvciAobGV0IGxldHRlckluZGV4ID0gMDsgbGV0dGVySW5kZXggPCB0ZXh0VG9SZW5kZXIubGVuZ3RoOyBsZXR0ZXJJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIHNwcml0ZSBpbmRleCBpbiBhbHBoYWJldCAsIGlmIHRoZXJlIGlzIGFuIGVycm9yIHBpY2sgdGhlIGZpcnN0XHJcbiAgICAgICAgICAgIGNvbnN0IGxldHRlciA9IHRleHRUb1JlbmRlcltsZXR0ZXJJbmRleF07XHJcbiAgICAgICAgICAgIGxldCBzcHJpdGVJbmRleCA9IGFscGhhYmV0LmluZGV4T2YobGV0dGVyKTtcclxuICAgICAgICAgICAgaWYgKHNwcml0ZUluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgc3ByaXRlSW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYFNwcml0ZUZvbnQgLSBDYW5ub3QgZmluZCBsZXR0ZXIgJyR7bGV0dGVyfScgaW4gY29uZmlndXJlZCBhbHBoYWJldCAnJHthbHBoYWJldH0nYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgbGV0dGVyU3ByaXRlID0gdGhpcy5zcHJpdGVTaGVldC5zcHJpdGVzW3Nwcml0ZUluZGV4XTtcclxuICAgICAgICAgICAgaWYgKGxldHRlclNwcml0ZSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGxldHRlclNwcml0ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIud2FybihgU3ByaXRlRm9udCAtIENhbm5vdCBmaW5kIHNwcml0ZSBmb3IgJyR7bGV0dGVyfScgYXQgaW5kZXggJyR7c3ByaXRlSW5kZXh9JyBpbiBjb25maWd1cmVkIFNwcml0ZVNoZWV0YCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX3Nwcml0ZXMgPSByZXN1bHRzKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVEaW1lbnNpb25zKCkge1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZXMgPSB0aGlzLl9nZXRDaGFyYWN0ZXJTcHJpdGVzKHRoaXMuX3RleHQpO1xyXG4gICAgICAgIGxldCB3aWR0aCA9IDA7XHJcbiAgICAgICAgbGV0IGhlaWdodCA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBzcHJpdGUgb2Ygc3ByaXRlcykge1xyXG4gICAgICAgICAgICB3aWR0aCArPSBzcHJpdGUud2lkdGggKyB0aGlzLnNwYWNpbmc7XHJcbiAgICAgICAgICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgc3ByaXRlLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgIH1cclxuICAgIHVwZGF0ZVRleHQodGV4dCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90ZXh0ICE9PSB0ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fdGV4dCA9IHRleHQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJlRHJhdyhleCwgeCwgeSkge1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcclxuICAgICAgICBzdXBlci5fcHJlRHJhdyhleCwgeCwgeSk7XHJcbiAgICB9XHJcbiAgICBfZHJhd0ltYWdlKGV4LCB4LCB5KSB7XHJcbiAgICAgICAgbGV0IGN1cnNvciA9IDA7XHJcbiAgICAgICAgZm9yIChjb25zdCBzcHJpdGUgb2YgdGhpcy5fZ2V0Q2hhcmFjdGVyU3ByaXRlcyh0aGlzLl90ZXh0KSkge1xyXG4gICAgICAgICAgICAvLyBkcmF3IGl0IGluIHRoZSByaWdodCBzcG90IGFuZCBpbmNyZWFzZSB0aGUgY3Vyc29yIGJ5IHNwcml0ZSB3aWR0aFxyXG4gICAgICAgICAgICBzcHJpdGUuZHJhdyhleCwgeCArIGN1cnNvciwgeSk7XHJcbiAgICAgICAgICAgIGN1cnNvciArPSBzcHJpdGUud2lkdGggKyB0aGlzLnNwYWNpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVuZGVyKGV4LCB0ZXh0LCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RleHQgIT09IHRleHQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2hhZG93KSB7XHJcbiAgICAgICAgICAgIGV4LnNhdmUoKTtcclxuICAgICAgICAgICAgZXgudHJhbnNsYXRlKHRoaXMuc2hhZG93Lm9mZnNldC54LCB0aGlzLnNoYWRvdy5vZmZzZXQueSk7XHJcbiAgICAgICAgICAgIHRoaXMuZHJhdyhleCwgeCwgeSk7XHJcbiAgICAgICAgICAgIGV4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5kcmF3KGV4LCB4LCB5KTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgU3ByaXRlRm9udF9TcHJpdGVGb250KHtcclxuICAgICAgICAgICAgYWxwaGFiZXQ6IHRoaXMuYWxwaGFiZXQsXHJcbiAgICAgICAgICAgIHNwcml0ZVNoZWV0OiB0aGlzLnNwcml0ZVNoZWV0LFxyXG4gICAgICAgICAgICBzcGFjaW5nOiB0aGlzLnNwYWNpbmdcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvZGVidWctZm9udC5wbmdcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgZGVidWdfZm9udCA9IChcImRhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBUUFBQUFBd0NBWUFBQUQrZjZSL0FBQUFBWE5TUjBJQXJzNGM2UUFBQmNKSlJFRlVlSnp0bmVtdTdDZ01oR0UwNy8vS21UOU5ockFGVnprUW5kUW50WFJQMy9iQ1prd0NTUWhDQ0NHRUVFSUlJWVFRUW9nL1RSejk1M0VjeC9uREdJZS92ZE5obGM5dEl6NjA1RmsvWm1XZnNPMWhuOUd4dXYxS0hidmIzaUwvVk4rZDFXT1JieXI3eVIvNWI5TTR2ak5lcWtvNmpQSkhxNXdHSFUxNTFvOUoyVWRzZTlobmRDeHV2MHJIN3JZM3lEL1dkeWYxM01yblFlRGZrWklVU0dLTTRmZjNjV044MnBFWnVUeVFHWDJJeGV5UjYzdmEvLzhWTkNZQ3ErMXlFa0x0V3lhZ1h2MVAxcjFIKzExMGdQM1B6VDRnVDh1Vy9tZFE4bVVHOEU5RHFPejRNUzlJQ0tHYlhwUzJCcG5JclJ6WWVTOTZjbGwwOElObENNbDIvZ2x6ZGNmYXp1dVBxUU8wM2xtcXJCSHNmMjcyUTZOT0RYajZ6elpJSmQvTEFIWVRnM01heXM1Z0JpN1pSMjdmT2dzMHlqOHJtMzZETE1GaVBna0FkWEhLT3dVUWVNQ1EvYWRTaC9xQlFyVC90UHhiQXdBOStET1pFSUxQQUFUU3VITWdUdjcrQXVrL2RmMmxIUENaTHZNU0xKZTM0TGtFUTlQd1hGMVNSVGxsTVlndklhZmxxeVZBakxHYnNpQ0RjT0s3NmpmbHhaK3NJTlB5Uk9jNTA3MXlLV0s1Q0pUVjNkTXA2K3RCbHlDdE5saEFxLytYYldvQkRjUk5YWUJNekQ0VnZReWdTdVBZQzJqR0dhU1NPeFhmeTNkVFVFc2FuSXZOZWVwbTM4Ti9oc3NTQUxUUFpuQVhmd0lZUkpuMmI3VUJjdzBGS1grbkRkQU1wbTJqOVdWbnhyVWE3VFhhVkFjYS9CK1RnYUFWaDZSL3JIMFAvNW0wMWR0L1JMWVZpSm4rdy9iaFZYMlA3Zi9kdXFvbTVxYjAycFJMQ0xHSU1nQlUxd0NFRU45QkFVQ0lENk1BSU1TSFVRQVE0c01vQUFqeFlSUUFoUGd3ZDF1QjBmdVo3SDNjbm4yUCs5bXIvUGU0QjgvZUIvZndQNGVSdGNpLzBmNk9mVENQdC85b0h3QzZHNnkxOVJIWkR1bXhtd3pSNGVFL3MvMlR0ZS9xLytYTGRjOURlSjE5ZGllc1FjL2o3WjhmQ2U0dEFTNEN4WjdzcDdlaUppN0hpWm1qbU9UR0pzKzkzQ2JTM25QMFhJUEgzdlc4L3F6NlFQblgyUWRzVi8xdXcvaVpZdmc4QUNlSGQyOHJwUHpmTmZoTCs3dmt3LzRPdTlzK09uaGJ2OTFlbHBLWjQ4RGw2Ynpwd3dpYkhpZ1JBcmYrUHRrOStMM1kxUTVPQjRMZ0NlU0J3MWl1QjNHZUpoMS9IclgvekYwQTlNayt1NDV6TWtjM3I0cldQb21tYTUrcC81MTRMQitabzkzTUVySjFKSHhYUHpCeUdhL2xpY1JZVkticGVRQ29RNlE4eXh1Q3dKRjlJUHNvRGtIQW8vM1R4MjZjdkE0RXRKL24wNHc4UU9xL21yUjdkZGZMQUM1QllGTmxWSS8wQ25PVlVmbE9wdkpVUU14OUFJTUlXL25XRE02Ny9xdzArOTV2OWdvQnFEOWorNzJ1L0tEOVU4OUliblFiTUlSMlpibmVoNXpVWTdIZGs3WElQM1VmZlZiK3Ird0RZQVpMcSsxbjErQzd5My9ueTJyN3A1eWVCeURFaDlIekFJUVFKd29BUW53WUJRQWhQb3dDZ0JCam9OdTNoTnhTRkFDRTZJTnVLdlBhalBaNEVGRUFFS0lOY3liR1l6T2QyNDdXRWQzVGdBMmpsbWpFeXJkK2o5aHZmVmJEMlBXUTNabUdsdTJIeU84b2c4ZUJ1TlV2TllXb0RnTVZwd0hUSm9MV2R6MVkrWllPeTV1Rjd0NlBQcnVaeEFOcnVkMWxRWGtQMGpzR3ovWXordkdHTXV5Z0Z5aFNQY0puYzFwTW5RWkVsYytjUm5vQWx4ZFR2b0R1SzdwdXFGN3VDUXkrM2Z5Rk1pQTAyL3ZKUUhoN0RRRG9nTVBUU0dGTkE1NkhUemJaOXlBZkJPYjFaeW8zcUdNM01mTVozZjc2aHVYZjZ4bG1BSGtuTWxMTlhzQkJCdmJsakl6OVV5ejVZNVR6SUJMUi9xeS9yTnlyWjgrTC8wQlowbSt0Z1hEME9LNVhaeEMvOVA3SS9nNGhWRnZ6WGYxLzZpNUE3KzNBbGlqTVBCTE1aZkN2dUFwN0E5clk1NkFwSGl0bUxRYzdjOGJPdjZmdEF4bE05WHAzNW5rRUs3bkpldEJzYU1odEFBQXVPTFFHWHdoaDJkWFFubjFyWi9hNDJCSTNkTDdMK2prRkFiUWRkd2RBOUFoMzV5TUtoZ0VnVlQ0NkVGaDVENGp6K09nYXZOS3hlQkNkMXdEU0ovOTdvUjhlb0prTGk5dDkvQkRnREhUSjVORTdEbnplY2hoOTE0T1Z2OU0xSzlQQ3FzZnFiODhYVmc5cU45bG02bkcxNzZVUHUrem4xN0dPeHVPMHZPV0VFQy9qK0xGS1RnZ2hsdkVmWUphTFMrU0EyTzBBQUFBQVNVVk9SSzVDWUlJPVwiKTtcbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvZGVidWctdGV4dC50c1xuXHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgZGVidWd0ZXh0IGhlbHBlclxyXG4gKi9cclxuY2xhc3MgRGVidWdUZXh0IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIGJhc2U2NCBmb250XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mb250U2hlZXQgPSBkZWJ1Z19mb250O1xyXG4gICAgICAgIHRoaXMuc2l6ZSA9IDE2O1xyXG4gICAgICAgIHRoaXMubG9hZCgpO1xyXG4gICAgfVxyXG4gICAgbG9hZCgpIHtcclxuICAgICAgICB0aGlzLl9pbWFnZVNvdXJjZSA9IG5ldyBJbWFnZVNvdXJjZSh0aGlzLmZvbnRTaGVldCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ltYWdlU291cmNlLmxvYWQoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlU2hlZXQgPSBTcHJpdGVTaGVldC5mcm9tSW1hZ2VTb3VyY2Uoe1xyXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHRoaXMuX2ltYWdlU291cmNlLFxyXG4gICAgICAgICAgICAgICAgZ3JpZDoge1xyXG4gICAgICAgICAgICAgICAgICAgIHJvd3M6IDMsXHJcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uczogMTYsXHJcbiAgICAgICAgICAgICAgICAgICAgc3ByaXRlV2lkdGg6IDE2LFxyXG4gICAgICAgICAgICAgICAgICAgIHNwcml0ZUhlaWdodDogMTZcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUZvbnQgPSBuZXcgU3ByaXRlRm9udF9TcHJpdGVGb250KHtcclxuICAgICAgICAgICAgICAgIGFscGhhYmV0OiAnMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaLCFcXCcmLlwiPy0oKSsgJyxcclxuICAgICAgICAgICAgICAgIGNhc2VJbnNlbnNpdGl2ZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIHNwcml0ZVNoZWV0OiB0aGlzLl9zcHJpdGVTaGVldCxcclxuICAgICAgICAgICAgICAgIHNwYWNpbmc6IC02XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXcml0ZXMgZGVidWcgdGV4dCB1c2luZyB0aGUgYnVpbHQgaW4gc3ByaW50IGZvbnRcclxuICAgICAqIEBwYXJhbSBjdHhcclxuICAgICAqIEBwYXJhbSB0ZXh0XHJcbiAgICAgKiBAcGFyYW0gcG9zXHJcbiAgICAgKi9cclxuICAgIHdyaXRlKGN0eCwgdGV4dCwgcG9zKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ltYWdlU291cmNlLmlzTG9hZGVkKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlRm9udC5yZW5kZXIoY3R4LCB0ZXh0LCBwb3MueCwgcG9zLnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0wudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dFdlYkdMRGVidWcge1xyXG4gICAgY29uc3RydWN0b3IoX3dlYmdsQ3R4KSB7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2xDdHggPSBfd2ViZ2xDdHg7XHJcbiAgICAgICAgdGhpcy5fZGVidWdUZXh0ID0gbmV3IERlYnVnVGV4dCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgZGVidWdnaW5nIHJlY3RhbmdsZSB0byB0aGUgY29udGV4dFxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKiBAcGFyYW0gd2lkdGhcclxuICAgICAqIEBwYXJhbSBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgZHJhd1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgcmVjdE9wdGlvbnMgPSB7IGNvbG9yOiBDb2xvci5CbGFjayB9KSB7XHJcbiAgICAgICAgdGhpcy5kcmF3TGluZSh2ZWMoeCwgeSksIHZlYyh4ICsgd2lkdGgsIHkpLCBPYmplY3QuYXNzaWduKHt9LCByZWN0T3B0aW9ucykpO1xyXG4gICAgICAgIHRoaXMuZHJhd0xpbmUodmVjKHggKyB3aWR0aCwgeSksIHZlYyh4ICsgd2lkdGgsIHkgKyBoZWlnaHQpLCBPYmplY3QuYXNzaWduKHt9LCByZWN0T3B0aW9ucykpO1xyXG4gICAgICAgIHRoaXMuZHJhd0xpbmUodmVjKHggKyB3aWR0aCwgeSArIGhlaWdodCksIHZlYyh4LCB5ICsgaGVpZ2h0KSwgT2JqZWN0LmFzc2lnbih7fSwgcmVjdE9wdGlvbnMpKTtcclxuICAgICAgICB0aGlzLmRyYXdMaW5lKHZlYyh4LCB5ICsgaGVpZ2h0KSwgdmVjKHgsIHkpLCBPYmplY3QuYXNzaWduKHt9LCByZWN0T3B0aW9ucykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgZGVidWdnaW5nIGxpbmUgdG8gdGhlIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBzdGFydFxyXG4gICAgICogQHBhcmFtIGVuZFxyXG4gICAgICogQHBhcmFtIGxpbmVPcHRpb25zXHJcbiAgICAgKi9cclxuICAgIGRyYXdMaW5lKHN0YXJ0LCBlbmQsIGxpbmVPcHRpb25zID0geyBjb2xvcjogQ29sb3IuQmxhY2sgfSkge1xyXG4gICAgICAgIHRoaXMuX3dlYmdsQ3R4Ll9fbGluZVJlbmRlcmVyLmFkZExpbmUoc3RhcnQsIGVuZCwgbGluZU9wdGlvbnMuY29sb3IpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3IGEgZGVidWdnaW5nIHBvaW50IHRvIHRoZSBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqIEBwYXJhbSBwb2ludE9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgZHJhd1BvaW50KHBvaW50LCBwb2ludE9wdGlvbnMgPSB7IGNvbG9yOiBDb2xvci5CbGFjaywgc2l6ZTogNSB9KSB7XHJcbiAgICAgICAgdGhpcy5fd2ViZ2xDdHguX19wb2ludFJlbmRlcmVyLmFkZFBvaW50KHBvaW50LCBwb2ludE9wdGlvbnMuY29sb3IsIHBvaW50T3B0aW9ucy5zaXplKTtcclxuICAgIH1cclxuICAgIGRyYXdUZXh0KHRleHQsIHBvcykge1xyXG4gICAgICAgIHRoaXMuX2RlYnVnVGV4dC53cml0ZSh0aGlzLl93ZWJnbEN0eCwgdGV4dCwgcG9zKTtcclxuICAgIH1cclxufVxyXG5jbGFzcyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHRXZWJHTCB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybVN0YWNrKCk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBuZXcgU3RhdGVTdGFjaygpO1xyXG4gICAgICAgIHRoaXMuc25hcFRvUGl4ZWwgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuc21vb3RoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBDb2xvci5FeGNhbGlidXJCbHVlO1xyXG4gICAgICAgIHRoaXMuZGVidWcgPSBuZXcgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0V2ViR0xEZWJ1Zyh0aGlzKTtcclxuICAgICAgICBjb25zdCB7IGNhbnZhc0VsZW1lbnQsIGVuYWJsZVRyYW5zcGFyZW5jeSwgc21vb3RoaW5nLCBzbmFwVG9QaXhlbCwgYmFja2dyb3VuZENvbG9yIH0gPSBvcHRpb25zO1xyXG4gICAgICAgIHRoaXMuX19nbCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnd2ViZ2wnLCB7XHJcbiAgICAgICAgICAgIGFudGlhbGlhczogc21vb3RoaW5nICE9PSBudWxsICYmIHNtb290aGluZyAhPT0gdm9pZCAwID8gc21vb3RoaW5nIDogdGhpcy5zbW9vdGhpbmcsXHJcbiAgICAgICAgICAgIHByZW11bHRpcGxpZWRBbHBoYTogZmFsc2UsXHJcbiAgICAgICAgICAgIGFscGhhOiBlbmFibGVUcmFuc3BhcmVuY3kgIT09IG51bGwgJiYgZW5hYmxlVHJhbnNwYXJlbmN5ICE9PSB2b2lkIDAgPyBlbmFibGVUcmFuc3BhcmVuY3kgOiB0cnVlLFxyXG4gICAgICAgICAgICBkZXB0aDogdHJ1ZSxcclxuICAgICAgICAgICAgcG93ZXJQcmVmZXJlbmNlOiAnaGlnaC1wZXJmb3JtYW5jZSdcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLnNuYXBUb1BpeGVsID0gc25hcFRvUGl4ZWwgIT09IG51bGwgJiYgc25hcFRvUGl4ZWwgIT09IHZvaWQgMCA/IHNuYXBUb1BpeGVsIDogdGhpcy5zbmFwVG9QaXhlbDtcclxuICAgICAgICB0aGlzLnNtb290aGluZyA9IHNtb290aGluZyAhPT0gbnVsbCAmJiBzbW9vdGhpbmcgIT09IHZvaWQgMCA/IHNtb290aGluZyA6IHRoaXMuc21vb3RoaW5nO1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gYmFja2dyb3VuZENvbG9yICE9PSBudWxsICYmIGJhY2tncm91bmRDb2xvciAhPT0gdm9pZCAwID8gYmFja2dyb3VuZENvbG9yIDogdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgdGhpcy5faW5pdCgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IG9wYWNpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlLmN1cnJlbnQub3BhY2l0eTtcclxuICAgIH1cclxuICAgIHNldCBvcGFjaXR5KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUuY3VycmVudC5vcGFjaXR5ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgd2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19nbC5jYW52YXMud2lkdGg7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fZ2wuY2FudmFzLmhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHRoZSB1bmRlcmx5aW5nIHdlYmdsIGltcGxlbWVudGF0aW9uIGlmIHRoZSByZXF1ZXN0ZWQgaW50ZXJuYWwgcmVzb2x1dGlvbiBpcyBzdXBwb3J0ZWRcclxuICAgICAqIEBwYXJhbSBkaW1cclxuICAgICAqL1xyXG4gICAgY2hlY2tJZlJlc29sdXRpb25TdXBwb3J0ZWQoZGltKSB7XHJcbiAgICAgICAgLy8gU2xpZ2h0IGhhY2sgYmFzZWQgb24gdGhpcyB0aHJlYWQgaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9nL3dlYmdsLWRldi1saXN0L2MvQUhPTnZ6M29RVG9cclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX19nbDtcclxuICAgICAgICAvLyBJZiBhbnkgZGltZW5zaW9uIGlzIGdyZWF0ZXIgdGhhbiBtYXggdGV4dHVyZSBzaXplIChkaXZpZGUgYnkgNCBieXRlcyBwZXIgcGl4ZWwpXHJcbiAgICAgICAgY29uc3QgbWF4RGltID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpIC8gNDtcclxuICAgICAgICBsZXQgc3VwcG9ydGVkID0gdHJ1ZTtcclxuICAgICAgICBpZiAoZGltLndpZHRoID4gbWF4RGltIHx8IGRpbS5oZWlnaHQgPiBtYXhEaW0pIHtcclxuICAgICAgICAgICAgc3VwcG9ydGVkID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdXBwb3J0ZWQ7XHJcbiAgICB9XHJcbiAgICBfaW5pdCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX19nbDtcclxuICAgICAgICAvLyBTZXR1cCB2aWV3cG9ydCBhbmQgdmlldyBtYXRyaXhcclxuICAgICAgICB0aGlzLl9vcnRobyA9IE1hdHJpeC5vcnRobygwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQsIDAsIDQwMCwgLTQwMCk7XHJcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgZ2wuY2FudmFzLndpZHRoLCBnbC5jYW52YXMuaGVpZ2h0KTtcclxuICAgICAgICAvLyBDbGVhciBiYWNrZ3JvdW5kXHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcih0aGlzLmJhY2tncm91bmRDb2xvci5yIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5nIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5iIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5hKTtcclxuICAgICAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcclxuICAgICAgICAvLyBFbmFibGUgYWxwaGEgYmxlbmRpbmdcclxuICAgICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xyXG4gICAgICAgIGdsLmJsZW5kRnVuYyhnbC5TUkNfQUxQSEEsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xyXG4gICAgICAgIHRoaXMuX19wb2ludFJlbmRlcmVyID0gbmV3IFBvaW50UmVuZGVyZXIoZ2wsIHsgbWF0cml4OiB0aGlzLl9vcnRobywgdHJhbnNmb3JtOiB0aGlzLl90cmFuc2Zvcm0sIHN0YXRlOiB0aGlzLl9zdGF0ZSB9KTtcclxuICAgICAgICB0aGlzLl9fbGluZVJlbmRlcmVyID0gbmV3IExpbmVSZW5kZXJlcihnbCwgeyBtYXRyaXg6IHRoaXMuX29ydGhvLCB0cmFuc2Zvcm06IHRoaXMuX3RyYW5zZm9ybSwgc3RhdGU6IHRoaXMuX3N0YXRlIH0pO1xyXG4gICAgICAgIHRoaXMuX19pbWFnZVJlbmRlcmVyID0gbmV3IEltYWdlUmVuZGVyZXIoZ2wsIHsgbWF0cml4OiB0aGlzLl9vcnRobywgdHJhbnNmb3JtOiB0aGlzLl90cmFuc2Zvcm0sIHN0YXRlOiB0aGlzLl9zdGF0ZSB9KTtcclxuICAgICAgICAvLyAyRCBjdHggc2hpbVxyXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IG5ldyBDYW52YXMoe1xyXG4gICAgICAgICAgICB3aWR0aDogZ2wuY2FudmFzLndpZHRoLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IGdsLmNhbnZhcy5oZWlnaHRcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9fY3R4ID0gdGhpcy5fY2FudmFzLmN0eDtcclxuICAgIH1cclxuICAgIHJlc2V0VHJhbnNmb3JtKCkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5jdXJyZW50ID0gTWF0cml4LmlkZW50aXR5KCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGVWaWV3cG9ydCgpIHtcclxuICAgICAgICBjb25zdCBnbCA9IHRoaXMuX19nbDtcclxuICAgICAgICB0aGlzLl9vcnRobyA9IHRoaXMuX29ydGhvID0gTWF0cml4Lm9ydGhvKDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCwgMCwgNDAwLCAtNDAwKTtcclxuICAgICAgICB0aGlzLl9fcG9pbnRSZW5kZXJlci5zaGFkZXIuYWRkVW5pZm9ybU1hdHJpeCgndV9tYXRyaXgnLCB0aGlzLl9vcnRoby5kYXRhKTtcclxuICAgICAgICB0aGlzLl9fbGluZVJlbmRlcmVyLnNoYWRlci5hZGRVbmlmb3JtTWF0cml4KCd1X21hdHJpeCcsIHRoaXMuX29ydGhvLmRhdGEpO1xyXG4gICAgICAgIHRoaXMuX19pbWFnZVJlbmRlcmVyLnNoYWRlci5hZGRVbmlmb3JtTWF0cml4KCd1X21hdHJpeCcsIHRoaXMuX29ydGhvLmRhdGEpO1xyXG4gICAgICAgIC8vIDJEIGN0eCBzaGltXHJcbiAgICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gZ2wuY2FudmFzLndpZHRoO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5oZWlnaHQgPSBnbC5jYW52YXMuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZHJhd0ltYWdlKGltYWdlLCBzeCwgc3ksIHN3aWR0aCwgc2hlaWdodCwgZHgsIGR5LCBkd2lkdGgsIGRoZWlnaHQpIHtcclxuICAgICAgICBpZiAoc3dpZHRoID09PSAwIHx8IHNoZWlnaHQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyB6ZXJvIGRpbWVuc2lvbiBkZXN0IGV4aXQgZWFybHlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZHdpZHRoID09PSAwIHx8IGRoZWlnaHQgPT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyB6ZXJvIGRpbWVuc2lvbiBkZXN0IGV4aXQgZWFybHlcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaW1hZ2Uud2lkdGggPT09IDAgfHwgaW1hZ2UuaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gemVybyBkaW1lbnNpb24gc291cmNlIGV4aXQgZWFybHlcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpbWFnZSkge1xyXG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdDYW5ub3QgZHJhdyBhIG51bGwgb3IgdW5kZWZpbmVkIGltYWdlJyk7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tY29uc29sZVxyXG4gICAgICAgICAgICBpZiAoY29uc29sZS50cmFjZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1jb25zb2xlXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLnRyYWNlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9faW1hZ2VSZW5kZXJlci5hZGRJbWFnZShpbWFnZSwgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQsIGR4LCBkeSwgZHdpZHRoLCBkaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGRyYXdMaW5lKHN0YXJ0LCBlbmQsIGNvbG9yLCB0aGlja25lc3MgPSAxKSB7XHJcbiAgICAgICAgdGhpcy5fX2ltYWdlUmVuZGVyZXIuYWRkTGluZShjb2xvciwgc3RhcnQsIGVuZCwgdGhpY2tuZXNzKTtcclxuICAgIH1cclxuICAgIGRyYXdSZWN0YW5nbGUocG9zLCB3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xyXG4gICAgICAgIHRoaXMuX19pbWFnZVJlbmRlcmVyLmFkZFJlY3RhbmdsZShjb2xvciwgcG9zLCB3aWR0aCwgaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGRyYXdDaXJjbGUocG9zLCByYWRpdXMsIGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5fX2ltYWdlUmVuZGVyZXIuYWRkQ2lyY2xlKHBvcywgcmFkaXVzLCBjb2xvcik7XHJcbiAgICB9XHJcbiAgICBzYXZlKCkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fc3RhdGUuc2F2ZSgpO1xyXG4gICAgfVxyXG4gICAgcmVzdG9yZSgpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0ucmVzdG9yZSgpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlLnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIHRyYW5zbGF0ZSh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnRyYW5zbGF0ZSh0aGlzLnNuYXBUb1BpeGVsID8gfn54IDogeCwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+eSA6IHkpO1xyXG4gICAgfVxyXG4gICAgcm90YXRlKGFuZ2xlKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnJvdGF0ZShhbmdsZSk7XHJcbiAgICB9XHJcbiAgICBzY2FsZSh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnNjYWxlKHgsIHkpO1xyXG4gICAgfVxyXG4gICAgdHJhbnNmb3JtKG1hdHJpeCkge1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5jdXJyZW50ID0gbWF0cml4O1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgY29uc3QgZ2wgPSB0aGlzLl9fZ2w7XHJcbiAgICAgICAgZ2wuY2xlYXJDb2xvcih0aGlzLmJhY2tncm91bmRDb2xvci5yIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5nIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5iIC8gMjU1LCB0aGlzLmJhY2tncm91bmRDb2xvci5hKTtcclxuICAgICAgICAvLyBDbGVhciB0aGUgY29udGV4dCB3aXRoIHRoZSBuZXdseSBzZXQgY29sb3IuIFRoaXMgaXNcclxuICAgICAgICAvLyB0aGUgZnVuY3Rpb24gY2FsbCB0aGF0IGFjdHVhbGx5IGRvZXMgdGhlIGRyYXdpbmcuXHJcbiAgICAgICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XHJcbiAgICAgICAgR3JhcGhpY3NEaWFnbm9zdGljcy5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGbHVzaGVzIGFsbCBiYXRjaGVkIHJlbmRlcmluZyB0byB0aGUgc2NyZWVuXHJcbiAgICAgKi9cclxuICAgIGZsdXNoKCkge1xyXG4gICAgICAgIGNvbnN0IGdsID0gdGhpcy5fX2dsO1xyXG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgdGhpcy5fX2ltYWdlUmVuZGVyZXIucmVuZGVyKCk7XHJcbiAgICAgICAgdGhpcy5fX2xpbmVSZW5kZXJlci5yZW5kZXIoKTtcclxuICAgICAgICB0aGlzLl9fcG9pbnRSZW5kZXJlci5yZW5kZXIoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1NjcmVlbi50c1xuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBkaXNwbGF5IG1vZGVzIGF2YWlsYWJsZSB0byBFeGNhbGlidXIuXHJcbiAqL1xyXG52YXIgRGlzcGxheU1vZGU7XHJcbihmdW5jdGlvbiAoRGlzcGxheU1vZGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogRGVmYXVsdCwgdXNlIGEgc3BlY2lmaWVkIHJlc29sdXRpb24gZm9yIHRoZSBnYW1lLiBMaWtlIDgwMHg2MDAgcGl4ZWxzIGZvciBleGFtcGxlLlxyXG4gICAgICovXHJcbiAgICBEaXNwbGF5TW9kZVtcIkZpeGVkXCJdID0gXCJGaXhlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaXQgdG8gc2NyZWVuIHVzaW5nIGFzIG11Y2ggc3BhY2UgYXMgcG9zc2libGUgd2hpbGUgbWFpbnRhaW5pbmcgYXNwZWN0IHJhdGlvIGFuZCByZXNvbHV0aW9uLlxyXG4gICAgICogVGhpcyBpcyBub3QgdGhlIHNhbWUgYXMgW1tTY3JlZW4uZ29GdWxsU2NyZWVuXV0gYnV0IGJlaGF2ZXMgaW4gYSBzaW1pbGFyIHdheSBtYWludGFpbmluZyBhc3BlY3QgcmF0aW8uXHJcbiAgICAgKlxyXG4gICAgICogWW91IG1heSB3YW50IHRvIGNlbnRlciB5b3VyIGdhbWUgaGVyZSBpcyBhbiBleGFtcGxlXHJcbiAgICAgKiBgYGBodG1sXHJcbiAgICAgKiA8IS0tIGh0bWwgLS0+XHJcbiAgICAgKiA8Ym9keT5cclxuICAgICAqIDxtYWluPlxyXG4gICAgICogICA8Y2FudmFzIGlkPVwiZ2FtZVwiPjwvY2FudmFzPlxyXG4gICAgICogPC9tYWluPlxyXG4gICAgICogPC9ib2R5PlxyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogYGBgY3NzXHJcbiAgICAgKiAvLyBjc3NcclxuICAgICAqIG1haW4ge1xyXG4gICAgICogICBkaXNwbGF5OiBmbGV4O1xyXG4gICAgICogICBhbGlnbi1pdGVtczogY2VudGVyO1xyXG4gICAgICogICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcclxuICAgICAqICAgaGVpZ2h0OiAxMDAlO1xyXG4gICAgICogICB3aWR0aDogMTAwJTtcclxuICAgICAqIH1cclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqL1xyXG4gICAgRGlzcGxheU1vZGVbXCJGaXRTY3JlZW5cIl0gPSBcIkZpdFNjcmVlblwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGaWxsIHRoZSBlbnRpcmUgc2NyZWVuJ3MgY3NzIHdpZHRoL2hlaWdodCBmb3IgdGhlIGdhbWUgcmVzb2x1dGlvbiBkeW5hbWljYWxseS4gVGhpcyBtZWFucyB0aGUgcmVzb2x1dGlvbiBvZiB0aGUgZ2FtZSB3aWxsXHJcbiAgICAgKiBjaGFuZ2UgZHluYW1pY2FsbHkgYXMgdGhlIHdpbmRvdyBpcyByZXNpemVkLiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBbW1NjcmVlbi5nb0Z1bGxTY3JlZW5dXVxyXG4gICAgICovXHJcbiAgICBEaXNwbGF5TW9kZVtcIkZpbGxTY3JlZW5cIl0gPSBcIkZpbGxTY3JlZW5cIjtcclxuICAgIC8qKlxyXG4gICAgICogRml0IHRvIHBhcmVudCBlbGVtZW50IHdpZHRoL2hlaWdodCB1c2luZyBhcyBtdWNoIHNwYWNlIGFzIHBvc3NpYmxlIHdoaWxlIG1haW50YWluaW5nIGFzcGVjdCByYXRpbyBhbmQgcmVzb2x1dGlvbi5cclxuICAgICAqL1xyXG4gICAgRGlzcGxheU1vZGVbXCJGaXRDb250YWluZXJcIl0gPSBcIkZpdENvbnRhaW5lclwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgdGhlIHBhcmVudCBET00gY29udGFpbmVyJ3MgY3NzIHdpZHRoL2hlaWdodCBmb3IgdGhlIGdhbWUgcmVzb2x1dGlvbiBkeW5hbWljYWxseVxyXG4gICAgICovXHJcbiAgICBEaXNwbGF5TW9kZVtcIkZpbGxDb250YWluZXJcIl0gPSBcIkZpbGxDb250YWluZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogQWxsb3cgdGhlIGdhbWUgdG8gYmUgcG9zaXRpb25lZCB3aXRoIHRoZSBbW0VuZ2luZU9wdGlvbnMucG9zaXRpb25dXSBvcHRpb25cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBDU1MgdG8gcG9zaXRpb24gdGhlIGdhbWUgY2FudmFzLCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gICAgICovXHJcbiAgICBEaXNwbGF5TW9kZVtcIlBvc2l0aW9uXCJdID0gXCJQb3NpdGlvblwiO1xyXG59KShEaXNwbGF5TW9kZSB8fCAoRGlzcGxheU1vZGUgPSB7fSkpO1xyXG4vKipcclxuICogQ29udmVuaWVuY2UgY2xhc3MgZm9yIHF1aWNrIHJlc29sdXRpb25zXHJcbiAqIE1vc3RseSBzb3VyY2VkIGZyb20gaHR0cHM6Ly9lbXVsYXRpb24uZ2FtZXRlY2h3aWtpLmNvbS9pbmRleC5waHAvUmVzb2x1dGlvblxyXG4gKi9cclxuY2xhc3MgUmVzb2x1dGlvbiB7XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgc3RhdGljIGdldCBTVkdBKCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiA4MDAsIGhlaWdodDogNjAwIH07XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgc3RhdGljIGdldCBTdGFuZGFyZCgpIHtcclxuICAgICAgICByZXR1cm4geyB3aWR0aDogMTkyMCwgaGVpZ2h0OiAxMDgwIH07XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgc3RhdGljIGdldCBBdGFyaTI2MDAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IDE2MCwgaGVpZ2h0OiAxOTIgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBzdGF0aWMgZ2V0IEdhbWVCb3koKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IDE2MCwgaGVpZ2h0OiAxNDQgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBzdGF0aWMgZ2V0IEdhbWVCb3lBZHZhbmNlKCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiAyNDAsIGhlaWdodDogMTYwIH07XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgc3RhdGljIGdldCBOaW50ZW5kb0RTKCkge1xyXG4gICAgICAgIHJldHVybiB7IHdpZHRoOiAyNTYsIGhlaWdodDogMTkyIH07XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgc3RhdGljIGdldCBORVMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IDI1NiwgaGVpZ2h0OiAyMjQgfTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBzdGF0aWMgZ2V0IFNORVMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHsgd2lkdGg6IDI1NiwgaGVpZ2h0OiAyNDQgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIFNjcmVlbiBoYW5kbGVzIGFsbCBhc3BlY3RzIG9mIGludGVyYWN0aW5nIHdpdGggdGhlIHNjcmVlbiBmb3IgRXhjYWxpYnVyLlxyXG4gKi9cclxuY2xhc3MgU2NyZWVuIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICB0aGlzLl9hbnRpYWxpYXNpbmcgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb25TdGFjayA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0U3RhY2sgPSBbXTtcclxuICAgICAgICB0aGlzLl9waXhlbFJhdGlvT3ZlcnJpZGUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2lzRnVsbFNjcmVlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLl9mdWxsc2NyZWVuQ2hhbmdlSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faXNGdWxsU2NyZWVuID0gIXRoaXMuX2lzRnVsbFNjcmVlbjtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdGdWxsc2NyZWVuIENoYW5nZScsIHRoaXMuX2lzRnVsbFNjcmVlbik7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9waXhlbFJhdGlvQ2hhbmdlSGFuZGxlciA9ICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdQaXhlbCBSYXRpbyBDaGFuZ2UnLCB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RldmljZVBpeGVsUmF0aW8gPSB0aGlzLl9jYWxjdWxhdGVEZXZpY2VQaXhlbFJhdGlvKCk7XHJcbiAgICAgICAgICAgIHRoaXMuYXBwbHlSZXNvbHV0aW9uQW5kVmlld3BvcnQoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1ZpZXcgcG9ydCByZXNpemVkJyk7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFJlc29sdXRpb25BbmRWaWV3cG9ydEJ5RGlzcGxheU1vZGUocGFyZW50KTtcclxuICAgICAgICAgICAgdGhpcy5hcHBseVJlc29sdXRpb25BbmRWaWV3cG9ydCgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gQXNraW5nIHRoZSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyBpcyBleHBlbnNpdmUgd2UgZG8gaXQgb25jZVxyXG4gICAgICAgIHRoaXMuX2RldmljZVBpeGVsUmF0aW8gPSB0aGlzLl9jYWxjdWxhdGVEZXZpY2VQaXhlbFJhdGlvKCk7XHJcbiAgICAgICAgdGhpcy5fYWxyZWFkeVdhcm5lZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQgPSBvcHRpb25zLnZpZXdwb3J0O1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IChfYSA9IG9wdGlvbnMucmVzb2x1dGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52aWV3cG9ydCk7XHJcbiAgICAgICAgdGhpcy5fZGlzcGxheU1vZGUgPSAoX2IgPSBvcHRpb25zLmRpc3BsYXlNb2RlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBEaXNwbGF5TW9kZS5GaXhlZDtcclxuICAgICAgICB0aGlzLl9jYW52YXMgPSBvcHRpb25zLmNhbnZhcztcclxuICAgICAgICB0aGlzLl9jdHggPSBvcHRpb25zLmNvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fYW50aWFsaWFzaW5nID0gKF9jID0gb3B0aW9ucy5hbnRpYWxpYXNpbmcpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMuX2FudGlhbGlhc2luZztcclxuICAgICAgICB0aGlzLl9icm93c2VyID0gb3B0aW9ucy5icm93c2VyO1xyXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbjtcclxuICAgICAgICB0aGlzLl9waXhlbFJhdGlvT3ZlcnJpZGUgPSBvcHRpb25zLnBpeGVsUmF0aW87XHJcbiAgICAgICAgdGhpcy5fYXBwbHlEaXNwbGF5TW9kZSgpO1xyXG4gICAgICAgIHRoaXMuX21lZGlhUXVlcnlMaXN0ID0gdGhpcy5fYnJvd3Nlci53aW5kb3cubmF0aXZlQ29tcG9uZW50Lm1hdGNoTWVkaWEoYChyZXNvbHV0aW9uOiAke3dpbmRvdy5kZXZpY2VQaXhlbFJhdGlvfWRwcHgpYCk7XHJcbiAgICAgICAgdGhpcy5fbWVkaWFRdWVyeUxpc3QuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fcGl4ZWxSYXRpb0NoYW5nZUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgdGhpcy5fZnVsbHNjcmVlbkNoYW5nZUhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMuYXBwbHlSZXNvbHV0aW9uQW5kVmlld3BvcnQoKTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGhhbmRsZXJzXHJcbiAgICAgICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9icm93c2VyLndpbmRvdy5vZmYoJ3Jlc2l6ZScsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcmVzaXplT2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9yZXNpemVIYW5kbGVyKTtcclxuICAgICAgICAgICAgdGhpcy5fbWVkaWFRdWVyeUxpc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdGhpcy5fcGl4ZWxSYXRpb0NoYW5nZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB0aGlzLl9jYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIHRoaXMuX2Z1bGxzY3JlZW5DaGFuZ2VIYW5kbGVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfY2FsY3VsYXRlRGV2aWNlUGl4ZWxSYXRpbygpIHtcclxuICAgICAgICBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gPCAxKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcclxuICAgICAgICByZXR1cm4gZGV2aWNlUGl4ZWxSYXRpbztcclxuICAgIH1cclxuICAgIGdldCBwaXhlbFJhdGlvKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9waXhlbFJhdGlvT3ZlcnJpZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BpeGVsUmF0aW9PdmVycmlkZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RldmljZVBpeGVsUmF0aW87XHJcbiAgICB9XHJcbiAgICBnZXQgaXNIaURwaSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5waXhlbFJhdGlvICE9PSAxO1xyXG4gICAgfVxyXG4gICAgZ2V0IGRpc3BsYXlNb2RlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kaXNwbGF5TW9kZTtcclxuICAgIH1cclxuICAgIGdldCBjYW52YXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcclxuICAgIH1cclxuICAgIGdldCBwYXJlbnQoKSB7XHJcbiAgICAgICAgcmV0dXJuICgodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuRmlsbENvbnRhaW5lciB8fCB0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5GaXRDb250YWluZXJcclxuICAgICAgICAgICAgPyB0aGlzLmNhbnZhcy5wYXJlbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHlcclxuICAgICAgICAgICAgOiB3aW5kb3cpKTtcclxuICAgIH1cclxuICAgIGdldCByZXNvbHV0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IHJlc29sdXRpb24ocmVzb2x1dGlvbikge1xyXG4gICAgICAgIHRoaXMuX3Jlc29sdXRpb24gPSByZXNvbHV0aW9uO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZpZXdwb3J0KCkge1xyXG4gICAgICAgIGlmICh0aGlzLl92aWV3cG9ydCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdmlld3BvcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IHZpZXdwb3J0KHZpZXdwb3J0KSB7XHJcbiAgICAgICAgdGhpcy5fdmlld3BvcnQgPSB2aWV3cG9ydDtcclxuICAgIH1cclxuICAgIGdldCBhc3BlY3RSYXRpbygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbi53aWR0aCAvIHRoaXMuX3Jlc29sdXRpb24uaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZ2V0IHNjYWxlZFdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uLndpZHRoICogdGhpcy5waXhlbFJhdGlvO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNjYWxlZEhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb2x1dGlvbi5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW87XHJcbiAgICB9XHJcbiAgICBzZXRDdXJyZW50Q2FtZXJhKGNhbWVyYSkge1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IGNhbWVyYTtcclxuICAgIH1cclxuICAgIHB1c2hSZXNvbHV0aW9uQW5kVmlld3BvcnQoKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzb2x1dGlvblN0YWNrLnB1c2godGhpcy5yZXNvbHV0aW9uKTtcclxuICAgICAgICB0aGlzLl92aWV3cG9ydFN0YWNrLnB1c2godGhpcy52aWV3cG9ydCk7XHJcbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5yZXNvbHV0aW9uKTtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy52aWV3cG9ydCk7XHJcbiAgICB9XHJcbiAgICBwZWVrVmlld3BvcnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZpZXdwb3J0U3RhY2tbdGhpcy5fdmlld3BvcnRTdGFjay5sZW5ndGggLSAxXTtcclxuICAgIH1cclxuICAgIHBlZWtSZXNvbHV0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHV0aW9uU3RhY2tbdGhpcy5fcmVzb2x1dGlvblN0YWNrLmxlbmd0aCAtIDFdO1xyXG4gICAgfVxyXG4gICAgcG9wUmVzb2x1dGlvbkFuZFZpZXdwb3J0KCkge1xyXG4gICAgICAgIHRoaXMucmVzb2x1dGlvbiA9IHRoaXMuX3Jlc29sdXRpb25TdGFjay5wb3AoKTtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdGhpcy5fdmlld3BvcnRTdGFjay5wb3AoKTtcclxuICAgIH1cclxuICAgIGFwcGx5UmVzb2x1dGlvbkFuZFZpZXdwb3J0KCkge1xyXG4gICAgICAgIHRoaXMuX2NhbnZhcy53aWR0aCA9IHRoaXMuc2NhbGVkV2lkdGg7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IHRoaXMuc2NhbGVkSGVpZ2h0O1xyXG4gICAgICAgIGlmICh0aGlzLl9jdHggaW5zdGFuY2VvZiBFeGNhbGlidXJHcmFwaGljc0NvbnRleHRXZWJHTCkge1xyXG4gICAgICAgICAgICBjb25zdCBzdXBwb3J0ZWQgPSB0aGlzLl9jdHguY2hlY2tJZlJlc29sdXRpb25TdXBwb3J0ZWQoe1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRoaXMuc2NhbGVkV2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRoaXMuc2NhbGVkSGVpZ2h0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRlZCAmJiAhdGhpcy5fYWxyZWFkeVdhcm5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWxyZWFkeVdhcm5lZCA9IHRydWU7IC8vIHdhcm4gb25jZVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oYFRoZSBjdXJyZW50bHkgY29uZmlndXJlZCByZXNvbHV0aW9uICgke3RoaXMucmVzb2x1dGlvbi53aWR0aH14JHt0aGlzLnJlc29sdXRpb24uaGVpZ2h0fSlgICtcclxuICAgICAgICAgICAgICAgICAgICAnIGlzIHRvbyBsYXJnZSBmb3IgdGhlIHBsYXRmb3JtIFdlYkdMIGltcGxlbWVudGF0aW9uLCB0aGlzIG1heSB3b3JrIGJ1dCBjYXVzZSBXZWJHTCByZW5kZXJpbmcgdG8gYmVoYXZlIG9kZGx5LicgK1xyXG4gICAgICAgICAgICAgICAgICAgICcgVHJ5IHJlZHVjaW5nIHRoZSByZXNvbHV0aW9uIG9yIGRpc2FibGluZyBIaSBEUEkgc2NhbGluZyB0byBhdm9pZCB0aGlzJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJyAocmVhZCBtb3JlIGhlcmUgaHR0cHM6Ly9leGNhbGlidXJqcy5jb20vZG9jcy9zY3JlZW5zI3VuZGVyc3RhbmRpbmctdmlld3BvcnQtLXJlc29sdXRpb24pLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9hbnRpYWxpYXNpbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmltYWdlUmVuZGVyaW5nID0gJ2F1dG8nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmltYWdlUmVuZGVyaW5nID0gJ3BpeGVsYXRlZCc7XHJcbiAgICAgICAgICAgIC8vIEZhbGwgYmFjayB0byAnY3Jpc3AtZWRnZXMnIGlmICdwaXhlbGF0ZWQnIGlzIG5vdCBzdXBwb3J0ZWRcclxuICAgICAgICAgICAgLy8gQ3VycmVudGx5IGZvciBmaXJlZm94IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9pbWFnZS1yZW5kZXJpbmdcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2NhbnZhcy5zdHlsZS5pbWFnZVJlbmRlcmluZyA9PT0gJycpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5pbWFnZVJlbmRlcmluZyA9ICdjcmlzcC1lZGdlcyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLndpZHRoID0gdGhpcy52aWV3cG9ydC53aWR0aCArICdweCc7XHJcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmhlaWdodCA9IHRoaXMudmlld3BvcnQuaGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICAvLyBBZnRlciBtZXNzaW5nIHdpdGggdGhlIGNhbnZhcyB3aWR0aC9oZWlnaHQgdGhlIGdyYXBoaWNzIGNvbnRleHQgaXMgaW52YWxpZGF0ZWQgYW5kIG5lZWRzIHRvIGhhdmUgc29tZSBwcm9wZXJ0aWVzIHJlc2V0XHJcbiAgICAgICAgdGhpcy5fY3R4LnVwZGF0ZVZpZXdwb3J0KCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnJlc2V0VHJhbnNmb3JtKCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LnNjYWxlKHRoaXMucGl4ZWxSYXRpbywgdGhpcy5waXhlbFJhdGlvKTtcclxuICAgICAgICB0aGlzLl9jdHguc21vb3RoaW5nID0gdGhpcy5fYW50aWFsaWFzaW5nO1xyXG4gICAgfVxyXG4gICAgZ2V0IGFudGlhbGlhc2luZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYW50aWFsaWFzaW5nO1xyXG4gICAgfVxyXG4gICAgc2V0IGFudGlhbGlhc2luZyhpc1Ntb290aCkge1xyXG4gICAgICAgIHRoaXMuX2FudGlhbGlhc2luZyA9IGlzU21vb3RoO1xyXG4gICAgICAgIHRoaXMuX2N0eC5zbW9vdGhpbmcgPSB0aGlzLl9hbnRpYWxpYXNpbmc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBleGNhbGlidXIgaXMgZnVsbHNjcmVlbmVkIHVzaW5nIHRoZSBicm93c2VyIGZ1bGxzY3JlZW4gYXBpXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0Z1bGxTY3JlZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRnVsbFNjcmVlbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdHMgdG8gZ28gZnVsbHNjcmVlbiB1c2luZyB0aGUgYnJvd3NlciBmdWxsc2NyZWVuIGFwaSwgcmVxdWlyZXMgdXNlciBpbnRlcmFjdGlvbiB0byBiZSBzdWNjZXNzZnVsLlxyXG4gICAgICogRm9yIGV4YW1wbGUsIHdpcmUgdGhpcyB0byBhIHVzZXIgY2xpY2sgaGFuZGxlci5cclxuICAgICAqL1xyXG4gICAgZ29GdWxsU2NyZWVuKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW52YXMucmVxdWVzdEZ1bGxzY3JlZW4oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVxdWVzdHMgdG8gZXhpdCBmdWxsc2NyZWVuIHVzaW5nIHRoZSBicm93c2VyIGZ1bGxzY3JlZW4gYXBpXHJcbiAgICAgKi9cclxuICAgIGV4aXRGdWxsU2NyZWVuKCkge1xyXG4gICAgICAgIHJldHVybiBkb2N1bWVudC5leGl0RnVsbHNjcmVlbigpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBhIGNvb3JkaW5hdGUgaW4gbm9ybWFsIGh0bWwgcGFnZSBzcGFjZSwgZm9yIGV4YW1wbGUgZnJvbSBhIHBvaW50ZXIgbW92ZSBldmVudCwgYW5kIHRyYW5zbGF0ZXMgaXQgdG9cclxuICAgICAqIEV4Y2FsaWJ1ciBzY3JlZW4gc3BhY2UuXHJcbiAgICAgKlxyXG4gICAgICogRXhjYWxpYnVyIHNjcmVlbiBzcGFjZSBzdGFydHMgYXQgdGhlIHRvcCBsZWZ0ICgwLCAwKSBjb3JuZXIgb2YgdGhlIHZpZXdwb3J0LCBhbmQgZXh0ZW5kcyB0byB0aGVcclxuICAgICAqIGJvdHRvbSByaWdodCBjb3JuZXIgKHJlc29sdXRpb25YLCByZXNvbHV0aW9uWSlcclxuICAgICAqIEBwYXJhbSBwb2ludFxyXG4gICAgICovXHJcbiAgICBwYWdlVG9TY3JlZW5Db29yZGluYXRlcyhwb2ludCkge1xyXG4gICAgICAgIGxldCBuZXdYID0gcG9pbnQueDtcclxuICAgICAgICBsZXQgbmV3WSA9IHBvaW50Lnk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0Z1bGxTY3JlZW4pIHtcclxuICAgICAgICAgICAgbmV3WCAtPSBnZXRQb3NpdGlvbih0aGlzLl9jYW52YXMpLng7XHJcbiAgICAgICAgICAgIG5ld1kgLT0gZ2V0UG9zaXRpb24odGhpcy5fY2FudmFzKS55O1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBmdWxsc2NyZWVuIGFwaSBvbiBpdCBjZW50ZXJzIHdpdGggYmxhY2sgYmFyc1xyXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBzY3JlZW4gdG8gd29ybGQgY29vcmRpbmF0ZXMgaW4gdGhpcyBjYXNlXHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRnVsbFNjcmVlbikge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvIDwgd2luZG93LmlubmVySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5IZWlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIHRoaXMuYXNwZWN0UmF0aW87XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JlZW5NYXJnaW5ZID0gKHdpbmRvdy5pbm5lckhlaWdodCAtIHNjcmVlbkhlaWdodCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgbmV3WSA9ICgobmV3WSAtIHNjcmVlbk1hcmdpblkpIC8gc2NyZWVuSGVpZ2h0KSAqIHRoaXMudmlld3BvcnQuaGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgbmV3WCA9IChuZXdYIC8gd2luZG93LmlubmVyV2lkdGgpICogdGhpcy52aWV3cG9ydC53aWR0aDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbldpZHRoID0gd2luZG93LmlubmVySGVpZ2h0ICogdGhpcy5hc3BlY3RSYXRpbztcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNjcmVlbk1hcmdpblggPSAod2luZG93LmlubmVyV2lkdGggLSBzY3JlZW5XaWR0aCkgLyAyO1xyXG4gICAgICAgICAgICAgICAgbmV3WCA9ICgobmV3WCAtIHNjcmVlbk1hcmdpblgpIC8gc2NyZWVuV2lkdGgpICogdGhpcy52aWV3cG9ydC53aWR0aDtcclxuICAgICAgICAgICAgICAgIG5ld1kgPSAobmV3WSAvIHdpbmRvdy5pbm5lckhlaWdodCkgKiB0aGlzLnZpZXdwb3J0LmhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBuZXdYID0gKG5ld1ggLyB0aGlzLnZpZXdwb3J0LndpZHRoKSAqIHRoaXMucmVzb2x1dGlvbi53aWR0aDtcclxuICAgICAgICBuZXdZID0gKG5ld1kgLyB0aGlzLnZpZXdwb3J0LmhlaWdodCkgKiB0aGlzLnJlc29sdXRpb24uaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG5ld1gsIG5ld1kpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBhIGNvb3JkaW5hdGUgaW4gRXhjYWxpYnVyIHNjcmVlbiBzcGFjZSwgYW5kIHRyYW5zbGF0ZXMgaXQgdG8gbm9ybWFsIGh0bWwgcGFnZSBzcGFjZS4gRm9yIGV4YW1wbGUsXHJcbiAgICAgKiB0aGlzIGlzIHdoZXJlIGh0bWwgZWxlbWVudHMgbWlnaHQgbGl2ZSBpZiB5b3Ugd2FudCB0byBwb3NpdGlvbiB0aGVtIHJlbGF0aXZlIHRvIEV4Y2FsaWJ1ci5cclxuICAgICAqXHJcbiAgICAgKiBFeGNhbGlidXIgc2NyZWVuIHNwYWNlIHN0YXJ0cyBhdCB0aGUgdG9wIGxlZnQgKDAsIDApIGNvcm5lciBvZiB0aGUgdmlld3BvcnQsIGFuZCBleHRlbmRzIHRvIHRoZVxyXG4gICAgICogYm90dG9tIHJpZ2h0IGNvcm5lciAocmVzb2x1dGlvblgsIHJlc29sdXRpb25ZKVxyXG4gICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgKi9cclxuICAgIHNjcmVlblRvUGFnZUNvb3JkaW5hdGVzKHBvaW50KSB7XHJcbiAgICAgICAgbGV0IG5ld1ggPSBwb2ludC54O1xyXG4gICAgICAgIGxldCBuZXdZID0gcG9pbnQueTtcclxuICAgICAgICBuZXdYID0gKG5ld1ggLyB0aGlzLnJlc29sdXRpb24ud2lkdGgpICogdGhpcy52aWV3cG9ydC53aWR0aDtcclxuICAgICAgICBuZXdZID0gKG5ld1kgLyB0aGlzLnJlc29sdXRpb24uaGVpZ2h0KSAqIHRoaXMudmlld3BvcnQuaGVpZ2h0O1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0Z1bGxTY3JlZW4pIHtcclxuICAgICAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIC8gdGhpcy5hc3BlY3RSYXRpbyA8IHdpbmRvdy5pbm5lckhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuSGVpZ2h0ID0gd2luZG93LmlubmVyV2lkdGggLyB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuTWFyZ2luWSA9ICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBzY3JlZW5IZWlnaHQpIC8gMjtcclxuICAgICAgICAgICAgICAgIG5ld1kgPSAobmV3WSAvIHRoaXMudmlld3BvcnQuaGVpZ2h0KSAqIHNjcmVlbkhlaWdodCArIHNjcmVlbk1hcmdpblk7XHJcbiAgICAgICAgICAgICAgICBuZXdYID0gKG5ld1ggLyB0aGlzLnZpZXdwb3J0LndpZHRoKSAqIHdpbmRvdy5pbm5lcldpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuV2lkdGggPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NyZWVuTWFyZ2luWCA9ICh3aW5kb3cuaW5uZXJXaWR0aCAtIHNjcmVlbldpZHRoKSAvIDI7XHJcbiAgICAgICAgICAgICAgICBuZXdYID0gKG5ld1ggLyB0aGlzLnZpZXdwb3J0LndpZHRoKSAqIHNjcmVlbldpZHRoICsgc2NyZWVuTWFyZ2luWDtcclxuICAgICAgICAgICAgICAgIG5ld1kgPSAobmV3WSAvIHRoaXMudmlld3BvcnQuaGVpZ2h0KSAqIHdpbmRvdy5pbm5lckhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2lzRnVsbFNjcmVlbikge1xyXG4gICAgICAgICAgICBuZXdYICs9IGdldFBvc2l0aW9uKHRoaXMuX2NhbnZhcykueDtcclxuICAgICAgICAgICAgbmV3WSArPSBnZXRQb3NpdGlvbih0aGlzLl9jYW52YXMpLnk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG5ld1gsIG5ld1kpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBhIGNvb3JkaW5hdGUgaW4gRXhjYWxpYnVyIHNjcmVlbiBzcGFjZSwgYW5kIHRyYW5zbGF0ZXMgaXQgdG8gRXhjYWxpYnVyIHdvcmxkIHNwYWNlLlxyXG4gICAgICpcclxuICAgICAqIFdvcmxkIHNwYWNlIGlzIHdoZXJlIFtbRW50aXR5fGVudGl0aWVzXV0gaW4gRXhjYWxpYnVyIGxpdmUgYnkgZGVmYXVsdCBbW0Nvb3JkUGxhbmUuV29ybGRdXVxyXG4gICAgICogYW5kIGV4dGVuZHMgaW5maW5pdGVseSBvdXQgcmVsYXRpdmUgZnJvbSB0aGUgW1tDYW1lcmFdXS5cclxuICAgICAqIEBwYXJhbSBwb2ludCAgU2NyZWVuIGNvb3JkaW5hdGUgdG8gY29udmVydFxyXG4gICAgICovXHJcbiAgICBzY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMocG9pbnQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgbGV0IG5ld1ggPSBwb2ludC54O1xyXG4gICAgICAgIGxldCBuZXdZID0gcG9pbnQueTtcclxuICAgICAgICAvLyB0cmFuc2Zvcm0gYmFjayB0byB3b3JsZCBzcGFjZVxyXG4gICAgICAgIG5ld1ggPSAobmV3WCAvIHRoaXMucmVzb2x1dGlvbi53aWR0aCkgKiB0aGlzLmRyYXdXaWR0aDtcclxuICAgICAgICBuZXdZID0gKG5ld1kgLyB0aGlzLnJlc29sdXRpb24uaGVpZ2h0KSAqIHRoaXMuZHJhd0hlaWdodDtcclxuICAgICAgICAvLyB0cmFuc2Zvcm0gYmFzZWQgb24gem9vbVxyXG4gICAgICAgIG5ld1ggPSBuZXdYIC0gdGhpcy5oYWxmRHJhd1dpZHRoO1xyXG4gICAgICAgIG5ld1kgPSBuZXdZIC0gdGhpcy5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICAvLyBzaGlmdCBieSBjYW1lcmEgZm9jdXNcclxuICAgICAgICBuZXdYICs9IChfYiA9IChfYSA9IHRoaXMuX2NhbWVyYSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLngpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XHJcbiAgICAgICAgbmV3WSArPSAoX2QgPSAoX2MgPSB0aGlzLl9jYW1lcmEpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy55KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAwO1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKG5ld1gsIG5ld1kpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUYWtlcyBhIGNvb3JkaW5hdGUgaW4gRXhjYWxpYnVyIHdvcmxkIHNwYWNlLCBhbmQgdHJhbnNsYXRlcyBpdCB0byBFeGNhbGlidXIgc2NyZWVuIHNwYWNlLlxyXG4gICAgICpcclxuICAgICAqIFNjcmVlbiBzcGFjZSBpcyB3aGVyZSBbW1NjcmVlbkVsZW1lbnR8c2NyZWVuIGVsZW1lbnRzXV0gYW5kIFtbRW50aXR5fGVudGl0aWVzXV0gd2l0aCBbW0Nvb3JkUGxhbmUuU2NyZWVuXV0gbGl2ZS5cclxuICAgICAqIEBwYXJhbSBwb2ludCAgV29ybGQgY29vcmRpbmF0ZSB0byBjb252ZXJ0XHJcbiAgICAgKi9cclxuICAgIHdvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhwb2ludCkge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICBsZXQgc2NyZWVuWCA9IHBvaW50Lng7XHJcbiAgICAgICAgbGV0IHNjcmVlblkgPSBwb2ludC55O1xyXG4gICAgICAgIC8vIHNoaWZ0IGJ5IGNhbWVyYSBmb2N1c1xyXG4gICAgICAgIHNjcmVlblggLT0gKF9iID0gKF9hID0gdGhpcy5fY2FtZXJhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EueCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgICAgICBzY3JlZW5ZIC09IChfZCA9IChfYyA9IHRoaXMuX2NhbWVyYSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDA7XHJcbiAgICAgICAgLy8gdHJhbnNmb3JtIGJhY2sgb24gem9vbVxyXG4gICAgICAgIHNjcmVlblggPSBzY3JlZW5YICsgdGhpcy5oYWxmRHJhd1dpZHRoO1xyXG4gICAgICAgIHNjcmVlblkgPSBzY3JlZW5ZICsgdGhpcy5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICAvLyB0cmFuc2Zvcm0gYmFjayB0byBzY3JlZW4gc3BhY2VcclxuICAgICAgICBzY3JlZW5YID0gKHNjcmVlblggLyB0aGlzLmRyYXdXaWR0aCkgKiB0aGlzLnJlc29sdXRpb24ud2lkdGg7XHJcbiAgICAgICAgc2NyZWVuWSA9IChzY3JlZW5ZIC8gdGhpcy5kcmF3SGVpZ2h0KSAqIHRoaXMucmVzb2x1dGlvbi5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3Ioc2NyZWVuWCwgc2NyZWVuWSk7XHJcbiAgICB9XHJcbiAgICBwYWdlVG9Xb3JsZENvb3JkaW5hdGVzKHBvaW50KSB7XHJcbiAgICAgICAgY29uc3Qgc2NyZWVuID0gdGhpcy5wYWdlVG9TY3JlZW5Db29yZGluYXRlcyhwb2ludCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKHNjcmVlbik7XHJcbiAgICB9XHJcbiAgICB3b3JsZFRvUGFnZUNvb3JkaW5hdGVzKHBvaW50KSB7XHJcbiAgICAgICAgY29uc3Qgc2NyZWVuID0gdGhpcy53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXMocG9pbnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlblRvUGFnZUNvb3JkaW5hdGVzKHNjcmVlbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBCb3VuZGluZ0JveCBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBzY3JlZW5cclxuICAgICAqIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgc2NyZWVuLlxyXG4gICAgICpcclxuICAgICAqIFdvcmxkIGJvdW5kcyBhcmUgaW4gd29ybGQgY29vcmRpbmF0ZXMsIHVzZWZ1bCBmb3IgY3VsbGluZyBvYmplY3RzIG9mZnNjcmVlblxyXG4gICAgICovXHJcbiAgICBnZXRXb3JsZEJvdW5kcygpIHtcclxuICAgICAgICBjb25zdCBsZWZ0ID0gdGhpcy5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMoVmVjdG9yLlplcm8pLng7XHJcbiAgICAgICAgY29uc3QgdG9wID0gdGhpcy5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMoVmVjdG9yLlplcm8pLnk7XHJcbiAgICAgICAgY29uc3QgcmlnaHQgPSBsZWZ0ICsgdGhpcy5kcmF3V2lkdGg7XHJcbiAgICAgICAgY29uc3QgYm90dG9tID0gdG9wICsgdGhpcy5kcmF3SGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3gobGVmdCwgdG9wLCByaWdodCwgYm90dG9tKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKHBoeXNpY2FsIHdpZHRoIGNvbXBvbmVudCBvZiB0aGVcclxuICAgICAqIHJlc29sdXRpb24gb2YgdGhlIGNhbnZhcyBlbGVtZW50KVxyXG4gICAgICovXHJcbiAgICBnZXQgY2FudmFzV2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLndpZHRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhhbGYgd2lkdGggb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscyAoaGFsZiBwaHlzaWNhbCB3aWR0aCBjb21wb25lbnQpXHJcbiAgICAgKi9cclxuICAgIGdldCBoYWxmQ2FudmFzV2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FudmFzLndpZHRoIC8gMjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgZ2FtZSBjYW52YXMgaW4gcGl4ZWxzLCAocGh5c2ljYWwgaGVpZ2h0IGNvbXBvbmVudCBvZlxyXG4gICAgICogdGhlIHJlc29sdXRpb24gb2YgdGhlIGNhbnZhcyBlbGVtZW50KVxyXG4gICAgICovXHJcbiAgICBnZXQgY2FudmFzSGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaGFsZiBoZWlnaHQgb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscyAoaGFsZiBwaHlzaWNhbCBoZWlnaHQgY29tcG9uZW50KVxyXG4gICAgICovXHJcbiAgICBnZXQgaGFsZkNhbnZhc0hlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuaGVpZ2h0IC8gMjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGVuZ2luZSdzIHZpc2libGUgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscyBpbmNsdWRpbmcgem9vbSBhbmQgZGV2aWNlIHBpeGVsIHJhdGlvLlxyXG4gICAgICovXHJcbiAgICBnZXQgZHJhd1dpZHRoKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jYW1lcmEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x1dGlvbi53aWR0aCAvIHRoaXMuX2NhbWVyYS56b29tO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLndpZHRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhhbGYgdGhlIHdpZHRoIG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhhbGZEcmF3V2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd1dpZHRoIC8gMjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyYXdIZWlnaHQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NhbWVyYSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLmhlaWdodCAvIHRoaXMuX2NhbWVyYS56b29tO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHV0aW9uLmhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBoYWxmIHRoZSBoZWlnaHQgb2YgdGhlIGVuZ2luZSdzIHZpc2libGUgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscyBpbmNsdWRpbmcgem9vbSBhbmQgZGV2aWNlIHBpeGVsIHJhdGlvLlxyXG4gICAgICovXHJcbiAgICBnZXQgaGFsZkRyYXdIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhd0hlaWdodCAvIDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgc2NyZWVuIGNlbnRlciBjb29yZGluYXRlcyBpbmNsdWRpbmcgem9vbSBhbmQgZGV2aWNlIHBpeGVsIHJhdGlvLlxyXG4gICAgICovXHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIHJldHVybiB2ZWModGhpcy5oYWxmRHJhd1dpZHRoLCB0aGlzLmhhbGZEcmF3SGVpZ2h0KTtcclxuICAgIH1cclxuICAgIF9jb21wdXRlRml0KCkge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gJzBweCc7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG4gICAgICAgIGNvbnN0IGFzcGVjdCA9IHRoaXMuYXNwZWN0UmF0aW87XHJcbiAgICAgICAgbGV0IGFkanVzdGVkV2lkdGggPSAwO1xyXG4gICAgICAgIGxldCBhZGp1c3RlZEhlaWdodCA9IDA7XHJcbiAgICAgICAgaWYgKHdpbmRvdy5pbm5lcldpZHRoIC8gYXNwZWN0IDwgd2luZG93LmlubmVySGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGFkanVzdGVkV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcclxuICAgICAgICAgICAgYWRqdXN0ZWRIZWlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aCAvIGFzcGVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFkanVzdGVkV2lkdGggPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiBhc3BlY3Q7XHJcbiAgICAgICAgICAgIGFkanVzdGVkSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogYWRqdXN0ZWRXaWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBhZGp1c3RlZEhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfY29tcHV0ZUZpdENvbnRhaW5lcigpIHtcclxuICAgICAgICBjb25zdCBhc3BlY3QgPSB0aGlzLmFzcGVjdFJhdGlvO1xyXG4gICAgICAgIGxldCBhZGp1c3RlZFdpZHRoID0gMDtcclxuICAgICAgICBsZXQgYWRqdXN0ZWRIZWlnaHQgPSAwO1xyXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuY2FudmFzLnBhcmVudEVsZW1lbnQ7XHJcbiAgICAgICAgaWYgKHBhcmVudC5jbGllbnRXaWR0aCAvIGFzcGVjdCA8IHBhcmVudC5jbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgYWRqdXN0ZWRXaWR0aCA9IHBhcmVudC5jbGllbnRXaWR0aDtcclxuICAgICAgICAgICAgYWRqdXN0ZWRIZWlnaHQgPSBwYXJlbnQuY2xpZW50V2lkdGggLyBhc3BlY3Q7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBhZGp1c3RlZFdpZHRoID0gcGFyZW50LmNsaWVudEhlaWdodCAqIGFzcGVjdDtcclxuICAgICAgICAgICAgYWRqdXN0ZWRIZWlnaHQgPSBwYXJlbnQuY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0ge1xyXG4gICAgICAgICAgICB3aWR0aDogYWRqdXN0ZWRXaWR0aCxcclxuICAgICAgICAgICAgaGVpZ2h0OiBhZGp1c3RlZEhlaWdodFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfYXBwbHlEaXNwbGF5TW9kZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZURpc3BsYXlNb2RlUG9zaXRpb24odGhpcy5fcG9zaXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0UmVzb2x1dGlvbkFuZFZpZXdwb3J0QnlEaXNwbGF5TW9kZSh0aGlzLnBhcmVudCk7XHJcbiAgICAgICAgICAgIC8vIHdhdGNoIHJlc2l6aW5nXHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCBpbnN0YW5jZW9mIFdpbmRvdykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYnJvd3Nlci53aW5kb3cub24oJ3Jlc2l6ZScsIHRoaXMuX3Jlc2l6ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZUhhbmRsZXIoKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnBhcmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5wYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fcmVzaXplSGFuZGxlcik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSByZXNvdWx0aW9uIGFuZCB2aWV3cG9ydCBiYXNlZCBvbiB0aGUgc2VsZWN0ZWQgZGlzcGxheSBtb2RlLlxyXG4gICAgICovXHJcbiAgICBfc2V0UmVzb2x1dGlvbkFuZFZpZXdwb3J0QnlEaXNwbGF5TW9kZShwYXJlbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5TW9kZSA9PT0gRGlzcGxheU1vZGUuRmlsbENvbnRhaW5lcikge1xyXG4gICAgICAgICAgICB0aGlzLnJlc29sdXRpb24gPSB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogcGFyZW50LmNsaWVudFdpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJlbnQuY2xpZW50SGVpZ2h0XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHRoaXMudmlld3BvcnQgPSB0aGlzLnJlc29sdXRpb247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5GaWxsU2NyZWVuKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUubWFyZ2luID0gJzBweCc7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgdGhpcy5yZXNvbHV0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgd2lkdGg6IHBhcmVudC5pbm5lcldpZHRoLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBwYXJlbnQuaW5uZXJIZWlnaHRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMucmVzb2x1dGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheU1vZGUgPT09IERpc3BsYXlNb2RlLkZpdFNjcmVlbikge1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wdXRlRml0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmRpc3BsYXlNb2RlID09PSBEaXNwbGF5TW9kZS5GaXRDb250YWluZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUZpdENvbnRhaW5lcigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9pbml0aWFsaXplRGlzcGxheU1vZGVQb3NpdGlvbihwb3NpdGlvbikge1xyXG4gICAgICAgIGlmICghcG9zaXRpb24pIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEaXNwbGF5TW9kZSBvZiBQb3NpdGlvbiB3YXMgc2VsZWN0ZWQgYnV0IG5vIHBvc2l0aW9uIG9wdGlvbiB3YXMgZ2l2ZW4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcG9zaXRpb24gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzcGVjaWZpZWRQb3NpdGlvbiA9IHBvc2l0aW9uLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHNwZWNpZmllZFBvc2l0aW9uWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndG9wJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYW52YXMuc3R5bGUudG9wID0gJzBweCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2JvdHRvbSc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmJvdHRvbSA9ICcwcHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtaWRkbGUnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSAnNTAlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IC10aGlzLmhhbGZEcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5tYXJnaW5Ub3AgPSBvZmZzZXRZLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQb3NpdGlvbiBHaXZlbicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNwZWNpZmllZFBvc2l0aW9uWzFdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzcGVjaWZpZWRQb3NpdGlvblsxXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdsZWZ0JzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSAnMHB4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdyaWdodCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5yaWdodCA9ICcwcHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NlbnRlcic6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gJzUwJSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXRYID0gLXRoaXMuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLm1hcmdpbkxlZnQgPSBvZmZzZXRYLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBQb3NpdGlvbiBHaXZlbicpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbi50b3ApIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcG9zaXRpb24udG9wID09PSAnbnVtYmVyJ1xyXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICh0aGlzLmNhbnZhcy5zdHlsZS50b3AgPSBwb3NpdGlvbi50b3AudG9TdHJpbmcoKSArICdweCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHRoaXMuY2FudmFzLnN0eWxlLnRvcCA9IHBvc2l0aW9uLnRvcCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24ucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlb2YgcG9zaXRpb24ucmlnaHQgPT09ICdudW1iZXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKHRoaXMuY2FudmFzLnN0eWxlLnJpZ2h0ID0gcG9zaXRpb24ucmlnaHQudG9TdHJpbmcoKSArICdweCcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKHRoaXMuY2FudmFzLnN0eWxlLnJpZ2h0ID0gcG9zaXRpb24ucmlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uLmJvdHRvbSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBwb3NpdGlvbi5ib3R0b20gPT09ICdudW1iZXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKHRoaXMuY2FudmFzLnN0eWxlLmJvdHRvbSA9IHBvc2l0aW9uLmJvdHRvbS50b1N0cmluZygpICsgJ3B4JylcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiAodGhpcy5jYW52YXMuc3R5bGUuYm90dG9tID0gcG9zaXRpb24uYm90dG9tKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbi5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIHBvc2l0aW9uLmxlZnQgPT09ICdudW1iZXInXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKHRoaXMuY2FudmFzLnN0eWxlLmxlZnQgPSBwb3NpdGlvbi5sZWZ0LnRvU3RyaW5nKCkgKyAncHgnKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICh0aGlzLmNhbnZhcy5zdHlsZS5sZWZ0ID0gcG9zaXRpb24ubGVmdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9SZXNvdXJjZXMvU291bmQvQXVkaW9Db250ZXh0LnRzXG4vKipcclxuICogSW50ZXJuYWwgY2xhc3MgdXNlZCB0byBidWlsZCBpbnN0YW5jZXMgb2YgQXVkaW9Db250ZXh0XHJcbiAqL1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5jbGFzcyBBdWRpb0NvbnRleHRGYWN0b3J5IHtcclxuICAgIHN0YXRpYyBjcmVhdGUoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9JTlNUQU5DRSkge1xyXG4gICAgICAgICAgICBpZiAod2luZG93LkF1ZGlvQ29udGV4dCB8fCB3aW5kb3cud2Via2l0QXVkaW9Db250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9JTlNUQU5DRSA9IG5ldyBBdWRpb0NvbnRleHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fSU5TVEFOQ0U7XHJcbiAgICB9XHJcbn1cclxuQXVkaW9Db250ZXh0RmFjdG9yeS5fSU5TVEFOQ0UgPSBudWxsO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvV2ViQXVkaW8udHNcblxyXG5cclxuLyoqXHJcbiAqIFBhdGNoIGZvciBkZXRlY3RpbmcgbGVnYWN5IHdlYiBhdWRpbyBpbiBicm93c2Vyc1xyXG4gKiBAaW50ZXJuYWxcclxuICogQHBhcmFtIHNvdXJjZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNMZWdhY3lXZWJBdWRpb1NvdXJjZShzb3VyY2UpIHtcclxuICAgIHJldHVybiAhIXNvdXJjZS5wbGF5YmFja1N0YXRlO1xyXG59XHJcbmNsYXNzIFdlYkF1ZGlvIHtcclxuICAgIC8qKlxyXG4gICAgICogUGxheSBhbiBlbXB0eSBzb3VuZCB0byB1bmxvY2sgU2FmYXJpIFdlYkF1ZGlvIGNvbnRleHQuIENhbGwgdGhpcyBmdW5jdGlvblxyXG4gICAgICogcmlnaHQgYWZ0ZXIgYSB1c2VyIGludGVyYWN0aW9uIGV2ZW50LlxyXG4gICAgICogQHNvdXJjZSBodHRwczovL3BhdWxiYWthdXMuY29tL3R1dG9yaWFscy9odG1sNS93ZWItYXVkaW8tb24taW9zL1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdW5sb2NrKCkge1xyXG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChXZWJBdWRpby5fVU5MT0NLRUQgfHwgIUF1ZGlvQ29udGV4dEZhY3RvcnkuY3JlYXRlKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHVubG9ja1RpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignRXhjYWxpYnVyIHdhcyB1bmFibGUgdG8gdW5sb2NrIHRoZSBhdWRpbyBjb250ZXh0LCBhdWRpbyBwcm9iYWJseSB3aWxsIG5vdCBwbGF5IGluIHRoaXMgYnJvd3Nlci4nKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xyXG4gICAgICAgICAgICB9LCAyMDApO1xyXG4gICAgICAgICAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBBdWRpb0NvbnRleHRGYWN0b3J5LmNyZWF0ZSgpO1xyXG4gICAgICAgICAgICBhdWRpb0NvbnRleHQucmVzdW1lKCkudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgZW1wdHkgYnVmZmVyIGFuZCBwbGF5IGl0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhdWRpb0NvbnRleHQuY3JlYXRlQnVmZmVyKDEsIDEsIDIyMDUwKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICAgICAgICAgIGxldCBlbmRlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgc291cmNlLmJ1ZmZlciA9IGJ1ZmZlcjtcclxuICAgICAgICAgICAgICAgIHNvdXJjZS5jb25uZWN0KGF1ZGlvQ29udGV4dC5kZXN0aW5hdGlvbik7XHJcbiAgICAgICAgICAgICAgICBzb3VyY2Uub25lbmRlZCA9ICgpID0+IChlbmRlZCA9IHRydWUpO1xyXG4gICAgICAgICAgICAgICAgc291cmNlLnN0YXJ0KDApO1xyXG4gICAgICAgICAgICAgICAgLy8gYnkgY2hlY2tpbmcgdGhlIHBsYXkgc3RhdGUgYWZ0ZXIgc29tZSB0aW1lLCB3ZSBrbm93IGlmIHdlJ3JlIHJlYWxseSB1bmxvY2tlZFxyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGVnYWN5V2ViQXVkaW9Tb3VyY2Uoc291cmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc291cmNlLnBsYXliYWNrU3RhdGUgPT09IHNvdXJjZS5QTEFZSU5HX1NUQVRFIHx8IHNvdXJjZS5wbGF5YmFja1N0YXRlID09PSBzb3VyY2UuRklOSVNIRURfU1RBVEUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdlYkF1ZGlvLl9VTkxPQ0tFRCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdWRpb0NvbnRleHQuY3VycmVudFRpbWUgPiAwIHx8IGVuZGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBXZWJBdWRpby5fVU5MT0NLRUQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodW5sb2NrVGltZW91dFRpbWVyKTtcclxuICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgICAgIH0sICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdCgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBpc1VubG9ja2VkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9VTkxPQ0tFRDtcclxuICAgIH1cclxufVxyXG5XZWJBdWRpby5fVU5MT0NLRUQgPSBmYWxzZTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9DbGFzcy50c1xuXHJcbi8qKlxyXG4gKiBFeGNhbGlidXIgYmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIGJhc2ljIGZ1bmN0aW9uYWxpdHkgc3VjaCBhcyBbW0V2ZW50RGlzcGF0Y2hlcl1dXHJcbiAqIGFuZCBleHRlbmRpbmcgYWJpbGl0aWVzIGZvciB2YW5pbGxhIEphdmFzY3JpcHQgcHJvamVjdHNcclxuICovXHJcbmNsYXNzIENsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcih0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxpYXMgZm9yIGBhZGRFdmVudExpc3RlbmVyYC4gWW91IGNhbiBsaXN0ZW4gZm9yIGEgdmFyaWV0eSBvZlxyXG4gICAgICogZXZlbnRzIG9mZiBvZiB0aGUgZW5naW5lOyBzZWUgdGhlIGV2ZW50cyBzZWN0aW9uIGJlbG93IGZvciBhIGNvbXBsZXRlIGxpc3QuXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lICBOYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gZm9yXHJcbiAgICAgKiBAcGFyYW0gaGFuZGxlciAgICBFdmVudCBoYW5kbGVyIGZvciB0aGUgdGhyb3duIGV2ZW50XHJcbiAgICAgKi9cclxuICAgIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsaWFzIGZvciBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAuIElmIG9ubHkgdGhlIGV2ZW50TmFtZSBpcyBzcGVjaWZpZWRcclxuICAgICAqIGl0IHdpbGwgcmVtb3ZlIGFsbCBoYW5kbGVycyByZWdpc3RlcmVkIGZvciB0aGF0IHNwZWNpZmljIGV2ZW50LiBJZiB0aGUgZXZlbnROYW1lXHJcbiAgICAgKiBhbmQgdGhlIGhhbmRsZXIgaW5zdGFuY2UgYXJlIHNwZWNpZmllZCBvbmx5IHRoYXQgaGFuZGxlciB3aWxsIGJlIHJlbW92ZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGV2ZW50TmFtZSAgTmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIGZvclxyXG4gICAgICogQHBhcmFtIGhhbmRsZXIgICAgRXZlbnQgaGFuZGxlciBmb3IgdGhlIHRocm93biBldmVudFxyXG4gICAgICovXHJcbiAgICBvZmYoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVtaXRzIGEgbmV3IGV2ZW50XHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lICAgTmFtZSBvZiB0aGUgZXZlbnQgdG8gZW1pdFxyXG4gICAgICogQHBhcmFtIGV2ZW50T2JqZWN0IERhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZXZlbnRcclxuICAgICAqL1xyXG4gICAgZW1pdChldmVudE5hbWUsIGV2ZW50T2JqZWN0KSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdChldmVudE5hbWUsIGV2ZW50T2JqZWN0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogT25jZSBsaXN0ZW5zIHRvIGFuIGV2ZW50IG9uZSB0aW1lLCB0aGVuIHVuc3Vic2NyaWJlcyBmcm9tIHRoYXQgZXZlbnRcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzdWJzY3JpYmUgdG8gb25jZVxyXG4gICAgICogQHBhcmFtIGhhbmRsZXIgICBUaGUgaGFuZGxlciBvZiB0aGUgZXZlbnQgdGhhdCB3aWxsIGJlIGF1dG8gdW5zdWJzY3JpYmVkXHJcbiAgICAgKi9cclxuICAgIG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIub25jZShldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9EcmF3VXRpbC50c1xuXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbi8qKlxyXG4gKiBEcmF3IGEgbGluZSBvbiBjYW52YXMgY29udGV4dFxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IFRoZSBjYW52YXMgY29udGV4dFxyXG4gKiBAcGFyYW0gY29sb3IgVGhlIGNvbG9yIG9mIHRoZSBsaW5lXHJcbiAqIEBwYXJhbSB4MSBUaGUgc3RhcnQgeCBjb29yZGluYXRlXHJcbiAqIEBwYXJhbSB5MSBUaGUgc3RhcnQgeSBjb29yZGluYXRlXHJcbiAqIEBwYXJhbSB4MiBUaGUgZW5kaW5nIHggY29vcmRpbmF0ZVxyXG4gKiBAcGFyYW0geTIgVGhlIGVuZGluZyB5IGNvb3JkaW5hdGVcclxuICogQHBhcmFtIHRoaWNrbmVzcyBUaGUgbGluZSB0aGlja25lc3NcclxuICogQHBhcmFtIGNhcCBUaGUgW1tMaW5lQ2FwU3R5bGVdXSAoYnV0dCwgcm91bmQsIG9yIHNxdWFyZSlcclxuICovXHJcbmZ1bmN0aW9uIGxpbmUoY3R4LCBjb2xvciA9IENvbG9yLlJlZCwgeDEsIHkxLCB4MiwgeTIsIHRoaWNrbmVzcyA9IDEsIGNhcCA9ICdidXR0Jykge1xyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaWNrbmVzcztcclxuICAgIGN0eC5saW5lQ2FwID0gY2FwO1xyXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgIGN0eC5tb3ZlVG8oeDEsIHkxKTtcclxuICAgIGN0eC5saW5lVG8oeDIsIHkyKTtcclxuICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIGN0eC5zdHJva2UoKTtcclxufVxyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4vKipcclxuICogRHJhdyB0aGUgdmVjdG9yIGFzIGEgcG9pbnQgb250byB0aGUgY2FudmFzLlxyXG4gKi9cclxuZnVuY3Rpb24gcG9pbnQoY3R4LCBjb2xvciA9IENvbG9yLlJlZCwgcG9pbnQpIHtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICBjdHguYXJjKHBvaW50LngsIHBvaW50LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIGN0eC5zdHJva2UoKTtcclxufVxyXG4vKipcclxuICogRHJhdyB0aGUgdmVjdG9yIGFzIGEgbGluZSBvbnRvIHRoZSBjYW52YXMgc3RhcnRpbmcgYSBvcmlnaW4gcG9pbnQuXHJcbiAqL1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4vKipcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHZlY3RvcihjdHgsIGNvbG9yLCBvcmlnaW4sIHZlY3Rvciwgc2NhbGUgPSAxLjApIHtcclxuICAgIGNvbnN0IGMgPSBjb2xvciA/IGNvbG9yLnRvU3RyaW5nKCkgOiAnYmx1ZSc7XHJcbiAgICBjb25zdCB2ID0gdmVjdG9yLnNjYWxlKHNjYWxlKTtcclxuICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgIGN0eC5zdHJva2VTdHlsZSA9IGM7XHJcbiAgICBjdHgubW92ZVRvKG9yaWdpbi54LCBvcmlnaW4ueSk7XHJcbiAgICBjdHgubGluZVRvKG9yaWdpbi54ICsgdi54LCBvcmlnaW4ueSArIHYueSk7XHJcbiAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICBjdHguc3Ryb2tlKCk7XHJcbn1cclxuLyoqXHJcbiAqIERyYXcgYSByb3VuZCByZWN0YW5nbGUgb24gYSBjYW52YXMgY29udGV4dFxyXG4gKlxyXG4gKiBAcGFyYW0gY3R4IFRoZSBjYW52YXMgY29udGV4dFxyXG4gKiBAcGFyYW0geCBUaGUgdG9wLWxlZnQgeCBjb29yZGluYXRlXHJcbiAqIEBwYXJhbSB5IFRoZSB0b3AtbGVmdCB5IGNvb3JkaW5hdGVcclxuICogQHBhcmFtIHdpZHRoIFRoZSB3aWR0aCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAqIEBwYXJhbSBoZWlnaHQgVGhlIGhlaWdodCBvZiB0aGUgcmVjdGFuZ2xlXHJcbiAqIEBwYXJhbSByYWRpdXMgVGhlIGJvcmRlciByYWRpdXMgb2YgdGhlIHJlY3RhbmdsZVxyXG4gKiBAcGFyYW0gc3Ryb2tlIFRoZSBbW0NvbG9yXV0gdG8gc3Ryb2tlIHJlY3RhbmdsZSB3aXRoXHJcbiAqIEBwYXJhbSBmaWxsIFRoZSBbW0NvbG9yXV0gdG8gZmlsbCByZWN0YW5nbGUgd2l0aFxyXG4gKi9cclxuZnVuY3Rpb24gcm91bmRSZWN0KGN0eCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzID0gNSwgc3Ryb2tlID0gQ29sb3IuV2hpdGUsIGZpbGwgPSBudWxsKSB7XHJcbiAgICBsZXQgYnI7XHJcbiAgICBpZiAodHlwZW9mIHJhZGl1cyA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBiciA9IHsgdGw6IHJhZGl1cywgdHI6IHJhZGl1cywgYnI6IHJhZGl1cywgYmw6IHJhZGl1cyB9O1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgY29uc3QgZGVmYXVsdFJhZGl1cyA9IHsgdGw6IDAsIHRyOiAwLCBicjogMCwgYmw6IDAgfTtcclxuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gZGVmYXVsdFJhZGl1cykge1xyXG4gICAgICAgICAgICBpZiAoZGVmYXVsdFJhZGl1cy5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2lkZSA9IHByb3A7XHJcbiAgICAgICAgICAgICAgICBicltzaWRlXSA9IHJhZGl1c1tzaWRlXSB8fCBkZWZhdWx0UmFkaXVzW3NpZGVdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgY3R4Lm1vdmVUbyh4ICsgYnIudGwsIHkpO1xyXG4gICAgY3R4LmxpbmVUbyh4ICsgd2lkdGggLSBici50ciwgeSk7XHJcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgd2lkdGgsIHksIHggKyB3aWR0aCwgeSArIGJyLnRyKTtcclxuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gYnIuYnIpO1xyXG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0LCB4ICsgd2lkdGggLSBici5iciwgeSArIGhlaWdodCk7XHJcbiAgICBjdHgubGluZVRvKHggKyBici5ibCwgeSArIGhlaWdodCk7XHJcbiAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gYnIuYmwpO1xyXG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgYnIudGwpO1xyXG4gICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oeCwgeSwgeCArIGJyLnRsLCB5KTtcclxuICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgIGlmIChmaWxsKSB7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGwudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgfVxyXG4gICAgaWYgKHN0cm9rZSkge1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZS50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNpcmNsZShjdHgsIHgsIHksIHJhZGl1cywgc3Ryb2tlID0gQ29sb3IuV2hpdGUsIGZpbGwgPSBudWxsKSB7XHJcbiAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICBjdHguYXJjKHgsIHksIHJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgaWYgKGZpbGwpIHtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZmlsbC50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICB9XHJcbiAgICBpZiAoc3Ryb2tlKSB7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTG9hZGVyLmxvZ28ucG5nXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIGNvbnN0IExvYWRlcl9sb2dvID0gKFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFkUUFBQUIyQ0FZQUFBQnhoR0k5QUFBQUNYQklXWE1BQUFzU0FBQUxFZ0hTM1g3OEFBQUtuVWxFUVZSNDJ1M2RQMndqU3gwSDhOOGhKSW9uSVJtSmpzcTBTQlIrQlExZGNxS2hlMGxENzdTdlN3cEtrSktHUHVscGt0ZlJJTVVkRXFLSXFWNTdycEFva000ZGJTaXlxN09OUFRQN3gzOWlmejdTRmJuRW5wM3hlcjQ3Tzd1ekgxNWZYd01BNk9ZSG1nQUFCQ29BQ0ZRQUVLZ0FnRUFGQUlFS0FBSVZBQVFxQUNCUUFVQ2dBb0JBQlFDQkNnQUlWQUFRcUFBZ1VBRkFvQUlBQWhVQUJDb0FDRlFBRUtnQWdFQ0ZMYm1PaU5lRmYyUGJBeXo2OFByNnFoVWdiUndSOTJ2Ky96d2lKcllITUVLRk1tY04vLy9VdGdjUXFGQmsxUEQvOTdVOVF4OFZDRlNndTRFbUFJRUtBQUlWQUFRcUFDQlE0WjI1am9qUDhlWCswV3ROQWdJVmFPWStJbTVqK2VLaDI0aDQxalFnVUlFeVo3RjVOYVBVN3dDQkNpd1lkL3c5Y09CK3FBbGdKM0tMTG93MEVWMTk4ODAzUld2SmZ2ZmRkeCswbGhFcUhLdTVKZ0FqVkNCdmxobUZ6alFSWFVla0h6OStUUDc5eTh1TFJqTkNoWGZ2b2VQdkFZRUt4TnRqMWU0Mi9PNUpvSUpBQmNyZFJNUlZMTStYM2tURXBhYUI5ODhjS3V6V2c5RW9iVFdkTXgwT2x5OHVONGRxaEFvQVJxZ25hTjNhckhmcXU3T3lIOEl0S0xWQi9QK0NFZk1USHlHUFkzbnB4MW04eldHREVlb0JmVWsveGR0aTU3ZHIvcjFXdjIrNkVQb3czdFo1clJkUzcyczFuZXVGOTd4dldkK1hUSDAvVitVTXR0RFdxYkkvcjJucnhmcCtqdjJ1U2pTTzdTK09YeS9BLzNsTis5eFg1VDVIeEVVUFpaMHRmQjcxK3c1N2VKL0hGdSt6K2prdjF1OTJZWDlmYkkvSGhYM0pBOXJwNU1QcjY2dFdhRzlVZlVHYnJISXppN2NMVXlZRmYvdHBUYWR5MDNFRWVMOG1VSjZpN01LWU52V05xcjRQZTJqcmFkWE82MExydlBBejJQUTVSUFg2ODRhaDhkeEQrMnphbnRuQ2dWaXBTVlYrbS90Z0I5VzJERHEyU3gvdk05NXdjSGhaaFdWSm04eXJ2NThjU2dmVGRjNzArKysvWC9yNTIyKy90VUtTRWVwQnFvK29tNFpMUGVyTWpVd3VOblFDdHgxR1dKdGVlMUZ3ZEQ1dVdkODZ4THM4VWFWdDJhTkVPMS9zYVovWjVyWU1XNHpxNnYzNHJHVjlCZzNxMmVaOVNrZU5tOXF3eVVoMzBPUElIWUZLeDVGRzAzQzd6blNPcVlCcStxVy96cFEzYW5IMDM3VE5IbHVHNmYwV1BzUGhIdmFiNFFGdHk3b2dPZXV4RFljTnkyL3p1MjIxNFdOWVd4bUJ1ck5POGJHbjk3cE5CT084eHkvOXVDb3JaWjRJMnI0QzdhSmdPN1pWOWlFNDlEbTZOdk9XeCtwV0U5Q1VxM3piZFRwOWRvejM4VGJYdHpxSDlSVDVDeVdlNDIyT2Fab1pHZVpDYWJyaFBRWTlIandzanBUdkNnNFl0bEUyK1RhL2oyYnpuOGZxckRxZ20rNnlVSE9tQXZXVWpBdEdoYk5ZdnNCa25EbnFIMVFoYzdWbXhIZ2ViL05idWRBNWovVVhsWXdpZjJwNmx1aEFjOXRldTFucGlIS25EczhpZjZ0Q203SkxYM05LcGd0dFhlOXJ1YzltSE1kN2E4M2l3ZHhGNXZ0OHR1dEFSYUNla2xSbk5LOUM4V25ORjdnZUpRNFQ0WEczSmhTblZkaWxRckcreU9ucmxWSGZzRUdZemhOQm43THU2dFM3K0hKYWZKUTRFTWlObE5xV1haOVdQdlZnblZZSEc1TTFCeURYa1Q2bGVYMkVnVHFKdHl0NDV5djdTMnFPM3NFWmpaaERMWGVSK1lLZEowWmRrOFFvY3ZIOU43MzJLck50cStGWi96eklIQUJjSnJZcGQrWHYxNGxPZDVhcDc2U2dyZHVXL1ZUUTFxY1FwcW5iZ3U0aWZadlVNTnBkOVh1b1ptdkN0UGFRMlkvQkNIVkxnYnJKVGVSUERkVmY2cGZNS0RVMmZPa0htVkZGZlhyM01zb3VMc25OdlY1a1JvZTUrczQzMVBldW9LUHFXbmF1clkvWlBCRWVxd2NlTjRsOTZpd082SDdNanE0eTdWR1BWTmUxMFZhWk16VkNQVldwSS9aNkZaYmN2NWZNcUdDVStkTGZGR3pqNThqUDgrYkNkSkNvN3l6S1R3ZE9GMGJ1OVVnN1Y0Yyt5ejdGSmZZZUdveXNVc3MwSHNzSWRWWndZTER1ak1xbEVTb0NkVHRHc1p0YkhuSkJlTmREU0pTczBqVEtkTUpOMUhOWDU0V3Y3YnZzVTlOa1ZKVmExM2RYKy93dUFyVjBYL2w1Ukh5by9sbmZGNEc2cDZEclMwa0hkdFhoeTM1VEdFckRQWVpVbjJXZldxRE9vL2xWcWRNRDJPL2hLSmhEN1Mvb2R1a3ltcTlzMDJRTjRFRVBSL3piYU91bVpjK3IxNXpLMVpxem5sOWpzZmllbVRNMVFtVjNIVXVUa2VkbGc5SElRelJiVUQ5M2RmQysydHBqMmZJSEVIMitScUNDUUgxM2dacTdoV1hUTnBWdTE5T0IxZmM5blEwQUtPS1ViNWxVMFAxa0R5T25lb1drMGxPWjljSVAweDdxdTgrMkJoQ29SMndZdTErZTdEbWFYekJTc3U1dmFYMW5lMnpycG1VUFRteGY3UE0xRG00eS92QzdueTdOaWY3K3ovOVptdE0wWjNwYW5QTHRQbXJhOWYxNmJjSzBEcGJud2s0M1ZkL1JIdHU2emZOUVR5MVFCeTNhcUcyZzluVm14bWwrQk9vSnlUM05wV21uOXhoZkZudTRidkRhKzQ0QlhocXFmZGYzdVVGOSt5ejc3QVQzMVl1ZTJtamVjWVE2Mk5MZmdrQTlnaEhxTE5FaE5lbTRIMWM2dmR5RHhoZi9icHo1bTRjb1cvYzM5d2k2VkgyYlB0SGxjYVY5Y3ZYdHMrenhDZTZyVGVxYzJuZEw3dUdkOTNRd005YkZjQXpNb1paN1NnVEJiV3grYXN1aTYxaC9pcTErUm1qcWRiblFYUTNUMUROUTYzVi9VOXVjcW0vcE16UGIxcmVQc2svMWlUT2pndmF0UjRXM0xjOFVMQjc4cEVMeXJuQWZlVGNqMU5VNTA5Lzg2bWZKMzMvOCtNZjAwYTA1VXlQVUV3N1VWQ2VXRy9XTkVpRXh5SFJNdDVsdFczMGl6VVBrMTh5dHQ3bE5mYzhpLy9EdnR2WHRvK3lTQTVCamxqc0xVRjhsUGtxTVBFdFcxSm9tRHNpR0JaOUJ5YjROQXZVSVRTTjlHdXdzSWo2dDZVVE9xazdqSlJFa216cWxpOHhJczk2dWRTTzIwc1gwSDF2VzkySUw5ZTFhOXJncVZ5ZjkxZ2JQc1R5OVVEOW45bE9rVDhrK1Jma0ZSNVBNTnF4T2NkU2YzMlBCdmczdmlsTyt6ZHhFK29reDlXbTBwaDM2WFlzUlpDcE1GOTkzR09rNXF2cUIzRGN0Nmp2c3NiNjdLdnVVTkozZnJ3OTJiaHI4L1NUU0YwSmRSUE1McFVDZ25zZ285Uzc2UFoyNDZaRmsxd1d2SzVtM3ZWb1l2VzFTejduTjkxamZYYlExWlFjN1RXNkhlYW9PYWx5cEcvOC9wL3JQMWFOQWM2Wkh6U25mZHFQVVBoZHkyUFF3Nk56OWdTVmh1aGlxdWVVSFIzdXU3eTdLM3JkRFg0dTQ2WnJQYlVhMElGQlowc2VLUTNYUVRSdDJ2bTNXL2EyRGJOS3lzKytydm0zZXA2K3kxeDJVZFAzYldVOWx6cmE0N1UxR21sY3RYL3NRMjN0K2FPbEJ5TFRoLzROQVBhQ1J4dGNkTzVITFNKLzZ2TnRDd0d4NjdWUG1QYnZXZDFxOWZyS0h0cDRrQXFSSjJIUjlqNzYySmZYM2JaLy9lbFB0ajEzUFBEeDErRDV0cWsvWGk2Tk84U0h6N01tSDE5ZFhyZEJOZlZGUDZUMlBUMVVITml0ODcvdDRtNSthUkgrblFCZHZxeWhaREtKTGZaczhoN1hQc3FkVjJaT1YrdGFuS0I4YWxuMGR5eGRBWGJWNGo0Z3Z0NG9NT3JiUDZ2YlU3M05XN1RNbGJkVG5QcldwZnFYZmg5SEtaOXZrZTdLdVRlWlJOdFhSU2U2KzFGVi8vY2UvbG41ZVhmc1hnY3FYenI2KzkyNjFNM21vT29hN0U2bnZUWlRmeTdpTnNtZmI3a2pmZ1hHc3Z4ZTB2aWhzRXRzOUhUcXVQcHQxcTF2dGFodTJUcUFpVUFFRUtqMHpod29BUnFnQXUvT25YLzQ0MldIKzl4Yy9XdnI1OHJlL1RyN2Y0MS8rWnNScWhBb0FDRlFBRUtnQWNIak1vUUpza0pzei9lcXJyNVordnZyN3Y1Zm1RRmV2QWw1bHp0UUlGUUFRcUFBZ1VBSGdJSmxEQmRoZ2RRNDFOMmVLRVNvQUlGQUJRS0FDd0ZFd2h3b0FScWdBSUZBQlFLQUNBQUlWQUFRcUFBaFVBQkNvQUlCQUJRQ0JDZ0FDRlFBRUtnQWdVQUZBb0FLQVFBVUFnUW9BQ0ZRQUVLZ0FJRkFCUUtBQ0FBSVZBQVFxQUFoVUFCQ29BSUJBQlFDQkNnQUNGUUFRcUFBZ1VBRkFvQUtBUUFVQWx2d1BjRkRuczFEc0g0c0FBQUFBU1VWT1JLNUNZSUk9XCIpO1xuLy8gRVhURVJOQUwgTU9EVUxFOiAuL0xvYWRlci5jc3NcbnZhciBMb2FkZXJfMCA9IF9fd2VicGFja19yZXF1aXJlX18oMTM4OCk7XG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Mb2FkZXIudHNcbnZhciBMb2FkZXJfYXdhaXRlciA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogUHJlLWxvYWRpbmcgYXNzZXRzXHJcbiAqXHJcbiAqIFRoZSBsb2FkZXIgcHJvdmlkZXMgYSBtZWNoYW5pc20gdG8gcHJlbG9hZCBtdWx0aXBsZSByZXNvdXJjZXMgYXRcclxuICogb25lIHRpbWUuIFRoZSBsb2FkZXIgbXVzdCBiZSBwYXNzZWQgdG8gdGhlIGVuZ2luZSBpbiBvcmRlciB0b1xyXG4gKiB0cmlnZ2VyIHRoZSBsb2FkaW5nIHByb2dyZXNzIGJhci5cclxuICpcclxuICogVGhlIFtbTG9hZGVyXV0gaXRzZWxmIGltcGxlbWVudHMgW1tMb2FkYWJsZV1dIHNvIHlvdSBjYW4gbG9hZCBsb2FkZXJzLlxyXG4gKlxyXG4gKiAjIyBFeGFtcGxlOiBQcmUtbG9hZGluZyByZXNvdXJjZXMgZm9yIGEgZ2FtZVxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiAvLyBjcmVhdGUgYSBsb2FkZXJcclxuICogdmFyIGxvYWRlciA9IG5ldyBleC5Mb2FkZXIoKTtcclxuICpcclxuICogLy8gY3JlYXRlIGEgcmVzb3VyY2UgZGljdGlvbmFyeSAoYmVzdCBwcmFjdGljZSBpcyB0byBrZWVwIGEgc2VwYXJhdGUgZmlsZSlcclxuICogdmFyIHJlc291cmNlcyA9IHtcclxuICogICBUZXh0dXJlR3JvdW5kOiBuZXcgZXguVGV4dHVyZShcIi9pbWFnZXMvdGV4dHVyZXMvZ3JvdW5kLnBuZ1wiKSxcclxuICogICBTb3VuZERlYXRoOiBuZXcgZXguU291bmQoXCIvc291bmQvZGVhdGgud2F2XCIsIFwiL3NvdW5kL2RlYXRoLm1wM1wiKVxyXG4gKiB9O1xyXG4gKlxyXG4gKiAvLyBsb29wIHRocm91Z2ggZGljdGlvbmFyeSBhbmQgYWRkIHRvIGxvYWRlclxyXG4gKiBmb3IgKHZhciBsb2FkYWJsZSBpbiByZXNvdXJjZXMpIHtcclxuICogICBpZiAocmVzb3VyY2VzLmhhc093blByb3BlcnR5KGxvYWRhYmxlKSkge1xyXG4gKiAgICAgbG9hZGVyLmFkZFJlc291cmNlKHJlc291cmNlc1tsb2FkYWJsZV0pO1xyXG4gKiAgIH1cclxuICogfVxyXG4gKlxyXG4gKiAvLyBzdGFydCBnYW1lXHJcbiAqIGdhbWUuc3RhcnQobG9hZGVyKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICogICBjb25zb2xlLmxvZyhcIkdhbWUgc3RhcnRlZCFcIik7XHJcbiAqIH0pO1xyXG4gKiBgYGBcclxuICpcclxuICogIyMgQ3VzdG9taXplIHRoZSBMb2FkZXJcclxuICpcclxuICogVGhlIGxvYWRlciBjYW4gYmUgY3VzdG9taXplZCB0byBzaG93IGRpZmZlcmVudCwgdGV4dCwgbG9nbywgYmFja2dyb3VuZCBjb2xvciwgYW5kIGJ1dHRvbi5cclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBsb2FkZXIgPSBuZXcgZXguTG9hZGVyKFtwbGF5ZXJUZXh0dXJlXSk7XHJcbiAqXHJcbiAqIC8vIFRoZSBsb2FkZXJzIGJ1dHRvbiB0ZXh0IGNhbiBzaW1wbHkgbW9kaWZpZWQgdXNpbmcgdGhpc1xyXG4gKiBsb2FkZXIucGxheUJ1dHRvblRleHQgPSAnU3RhcnQgdGhlIGJlc3QgZ2FtZSBldmVyJztcclxuICpcclxuICogLy8gVGhlIGxvZ28gY2FuIGJlIGNoYW5nZWQgYnkgaW5zZXJ0aW5nIGEgYmFzZTY0IGltYWdlIHN0cmluZyBoZXJlXHJcbiAqXHJcbiAqIGxvYWRlci5sb2dvID0gJ2RhdGE6aW1hZ2UvcG5nO2Jhc2U2NCxpVkJPUncuLi4nO1xyXG4gKiBsb2FkZXIubG9nb1dpZHRoID0gMTU7XHJcbiAqIGxvYWRlci5sb2dvSGVpZ2h0ID0gMTQ7XHJcbiAqXHJcbiAqIC8vIFRoZSBiYWNrZ3JvdW5kIGNvbG9yIGNhbiBiZSBjaGFuZ2VkIGxpa2Ugc28gYnkgc3VwcGx5aW5nIGEgdmFsaWQgQ1NTIGNvbG9yIHN0cmluZ1xyXG4gKlxyXG4gKiBsb2FkZXIuYmFja2dyb3VuZENvbG9yID0gJ3JlZCdcclxuICogbG9hZGVyLmJhY2tncm91bmRDb2xvciA9ICcjMTc2QkFBJ1xyXG4gKlxyXG4gKiAvLyBUbyBidWlsZCBhIGNvbXBsZXRlbHkgbmV3IGJ1dHRvblxyXG4gKiBsb2FkZXIuc3RhcnRCdXR0b25GYWN0b3J5ID0gKCkgPT4ge1xyXG4gKiAgICAgbGV0IG15QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XHJcbiAqICAgICBteUJ1dHRvbi50ZXh0Q29udGVudCA9ICdUaGUgYmVzdCBidXR0b24nO1xyXG4gKiAgICAgcmV0dXJuIG15QnV0dG9uO1xyXG4gKiB9O1xyXG4gKlxyXG4gKiBlbmdpbmUuc3RhcnQobG9hZGVyKS50aGVuKCgpID0+IHt9KTtcclxuICogYGBgXHJcbiAqL1xyXG5jbGFzcyBMb2FkZXIgZXh0ZW5kcyBDbGFzcyB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBsb2FkYWJsZXMgIE9wdGlvbmFsbHkgcHJvdmlkZSB0aGUgbGlzdCBvZiByZXNvdXJjZXMgeW91IHdhbnQgdG8gbG9hZCBhdCBjb25zdHJ1Y3RvciB0aW1lXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGxvYWRhYmxlcykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzKHtcclxuICAgICAgICAgICAgc21vb3RoaW5nOiB0cnVlLFxyXG4gICAgICAgICAgICBkcmF3OiB0aGlzLmRyYXcuYmluZCh0aGlzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlTGlzdCA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2luZGV4ID0gMDtcclxuICAgICAgICB0aGlzLl9wbGF5QnV0dG9uU2hvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZXNvdXJjZUNvdW50ID0gMDtcclxuICAgICAgICB0aGlzLl9udW1Mb2FkZWQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3Byb2dyZXNzQ291bnRzID0ge307XHJcbiAgICAgICAgdGhpcy5fdG90YWxDb3VudHMgPSB7fTtcclxuICAgICAgICAvLyBsb2dvIGRyYXdpbmcgc3R1ZmZcclxuICAgICAgICAvLyBiYXNlNjQgc3RyaW5nIGVuY29kaW5nIG9mIHRoZSBleGNhbGlidXIgbG9nbyAobG9nby13aGl0ZS5wbmcpXHJcbiAgICAgICAgdGhpcy5sb2dvID0gTG9hZGVyX2xvZ287XHJcbiAgICAgICAgdGhpcy5sb2dvV2lkdGggPSA0Njg7XHJcbiAgICAgICAgdGhpcy5sb2dvSGVpZ2h0ID0gMTE4O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY29sb3Igb2YgdGhlIGxvYWRpbmcgYmFyLCBkZWZhdWx0IGlzIFtbQ29sb3IuV2hpdGVdXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubG9hZGluZ0JhckNvbG9yID0gQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiYWNrZ3JvdW5kIGNvbG9yIG9mIHRoZSBsb2FkZXIgYXMgYSBoZXggc3RyaW5nXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSAnIzE3NkJBQSc7XHJcbiAgICAgICAgdGhpcy5zdXBwcmVzc1BsYXlCdXR0b24gPSBmYWxzZTtcclxuICAgICAgICAvKiogTG9hZHMgdGhlIGNzcyBmcm9tIExvYWRlci5jc3MgKi9cclxuICAgICAgICB0aGlzLl9wbGF5QnV0dG9uU3R5bGVzID0gTG9hZGVyXzAvKiBkZWZhdWx0LnRvU3RyaW5nICovLloudG9TdHJpbmcoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQvc2V0IHBsYXkgYnV0dG9uIHRleHRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBsYXlCdXR0b25UZXh0ID0gJ1BsYXkgZ2FtZSc7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJuIGEgaHRtbCBidXR0b24gZWxlbWVudCBmb3IgZXhjYWxpYnVyIHRvIHVzZSBhcyBhIHBsYXkgYnV0dG9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGFydEJ1dHRvbkZhY3RvcnkgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBidXR0b25FbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2V4Y2FsaWJ1ci1wbGF5Jyk7XHJcbiAgICAgICAgICAgIGlmICghYnV0dG9uRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgYnV0dG9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGJ1dHRvbkVsZW1lbnQuaWQgPSAnZXhjYWxpYnVyLXBsYXknO1xyXG4gICAgICAgICAgICBidXR0b25FbGVtZW50LnRleHRDb250ZW50ID0gdGhpcy5wbGF5QnV0dG9uVGV4dDtcclxuICAgICAgICAgICAgYnV0dG9uRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uRWxlbWVudDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmIChsb2FkYWJsZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRSZXNvdXJjZXMobG9hZGFibGVzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgX2ltYWdlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faW1hZ2VFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9pbWFnZUVsZW1lbnQuc3JjID0gdGhpcy5sb2dvO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5faW1hZ2VFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0IHBsYXlCdXR0b25Sb290RWxlbWVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0IHBsYXlCdXR0b25FbGVtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wbGF5QnV0dG9uRWxlbWVudDtcclxuICAgIH1cclxuICAgIGdldCBfcGxheUJ1dHRvbigpIHtcclxuICAgICAgICBjb25zdCBleGlzdGluZ1Jvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZXhjYWxpYnVyLXBsYXktcm9vdCcpO1xyXG4gICAgICAgIGlmIChleGlzdGluZ1Jvb3QpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50ID0gZXhpc3RpbmdSb290O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50LmlkID0gJ2V4Y2FsaWJ1ci1wbGF5LXJvb3QnO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fc3R5bGVCbG9jaykge1xyXG4gICAgICAgICAgICB0aGlzLl9zdHlsZUJsb2NrID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcclxuICAgICAgICAgICAgdGhpcy5fc3R5bGVCbG9jay50ZXh0Q29udGVudCA9IHRoaXMuX3BsYXlCdXR0b25TdHlsZXM7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5fc3R5bGVCbG9jayk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fcGxheUJ1dHRvbkVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvbkVsZW1lbnQgPSB0aGlzLnN0YXJ0QnV0dG9uRmFjdG9yeSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5fcGxheUJ1dHRvbkVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcGxheUJ1dHRvbkVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICB3aXJlRW5naW5lKGVuZ2luZSkge1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuX2VuZ2luZS5jYW52YXMud2lkdGg7XHJcbiAgICAgICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gdGhpcy5fZW5naW5lLmNhbnZhcy5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIHJlc291cmNlIHRvIHRoZSBsb2FkZXIgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIGxvYWRhYmxlICBSZXNvdXJjZSB0byBhZGRcclxuICAgICAqL1xyXG4gICAgYWRkUmVzb3VyY2UobG9hZGFibGUpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl9pbmRleCsrO1xyXG4gICAgICAgIHRoaXMuX3Jlc291cmNlTGlzdC5wdXNoKGxvYWRhYmxlKTtcclxuICAgICAgICB0aGlzLl9wcm9ncmVzc0NvdW50c1trZXldID0gMDtcclxuICAgICAgICB0aGlzLl90b3RhbENvdW50c1trZXldID0gMTtcclxuICAgICAgICB0aGlzLl9yZXNvdXJjZUNvdW50Kys7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIHRoZSBsb2FkZXIgdG8gbG9hZFxyXG4gICAgICogQHBhcmFtIGxvYWRhYmxlcyAgVGhlIGxpc3Qgb2YgcmVzb3VyY2VzIHRvIGxvYWRcclxuICAgICAqL1xyXG4gICAgYWRkUmVzb3VyY2VzKGxvYWRhYmxlcykge1xyXG4gICAgICAgIGxldCBpID0gMDtcclxuICAgICAgICBjb25zdCBsZW4gPSBsb2FkYWJsZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkUmVzb3VyY2UobG9hZGFibGVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbG9hZGVyIGhhcyBjb21wbGV0ZWx5IGxvYWRlZCBhbGwgcmVzb3VyY2VzXHJcbiAgICAgKi9cclxuICAgIGlzTG9hZGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9udW1Mb2FkZWQgPT09IHRoaXMuX3Jlc291cmNlQ291bnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNob3dzIHRoZSBwbGF5IGJ1dHRvbiBhbmQgcmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGNsaWNrZWRcclxuICAgICAqL1xyXG4gICAgc2hvd1BsYXlCdXR0b24oKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICh0aGlzLnN1cHByZXNzUGxheUJ1dHRvbikge1xyXG4gICAgICAgICAgICB0aGlzLmhpZGVQbGF5QnV0dG9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvblBsYXlCdXR0b24oKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuX2VuZ2luZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmJyb3dzZXIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5icm93c2VyLndpbmRvdy5vbigncmVzaXplJywgcmVzaXplSGFuZGxlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblNob3duID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvbi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIChldnQpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChldnQua2V5ID09PSAnRW50ZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvbi5jbGljaygpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydEJ1dHRvbkhhbmRsZXIgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSB3YW50IHRvIHN0b3AgcHJvcG9nYXRpb24gdG8ga2VlcCBidWJibGluZyB0byB0aGUgZW5naW5lIHBvaW50ZXIgaGFuZGxlcnNcclxuICAgICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEhpZGUgQnV0dG9uIGFmdGVyIGNsaWNrXHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUGxheUJ1dHRvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSB0aGlzLl9lbmdpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5icm93c2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5icm93c2VyLndpbmRvdy5vZmYoJ3Jlc2l6ZScsIHJlc2l6ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHN0YXJ0QnV0dG9uSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgc3RhcnRCdXR0b25IYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgc3RhcnRCdXR0b25IYW5kbGVyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGhpZGVQbGF5QnV0dG9uKCkge1xyXG4gICAgICAgIHRoaXMuX3BsYXlCdXR0b25TaG93biA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3BsYXlCdXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYW4gdXAgZ2VuZXJhdGVkIGVsZW1lbnRzIGZvciB0aGUgbG9hZGVyXHJcbiAgICAgKi9cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudC5yZW1vdmVDaGlsZCh0aGlzLl9wbGF5QnV0dG9uRWxlbWVudCk7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50KTtcclxuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZCh0aGlzLl9zdHlsZUJsb2NrKTtcclxuICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvbkVsZW1lbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLl9zdHlsZUJsb2NrID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gb3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmVnaW4gbG9hZGluZyBhbGwgb2YgdGhlIHN1cHBsaWVkIHJlc291cmNlcywgcmV0dXJuaW5nIGEgcHJvbWlzZVxyXG4gICAgICogdGhhdCByZXNvbHZlcyB3aGVuIGxvYWRpbmcgb2YgYWxsIGlzIGNvbXBsZXRlXHJcbiAgICAgKi9cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIExvYWRlcl9hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbCh0aGlzLl9yZXNvdXJjZUxpc3QubWFwKChyKSA9PiByLmxvYWQoKS5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIGNhcHR1cmUgcHJvZ3Jlc3NcclxuICAgICAgICAgICAgICAgIHRoaXMuX251bUxvYWRlZCsrO1xyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgICAgICAvLyBzaG9ydCBkZWxheSBpbiBzaG93aW5nIHRoZSBidXR0b24gZm9yIGFlc3RoZXRpY3NcclxuICAgICAgICAgICAgeWllbGQgZGVsYXkoMjAwKTtcclxuICAgICAgICAgICAgeWllbGQgdGhpcy5zaG93UGxheUJ1dHRvbigpO1xyXG4gICAgICAgICAgICAvLyBVbmxvY2sgYnJvd3NlciBBdWRpb0NvbnRleHQgaW4gYWZ0ZXIgdXNlciBnZXN0dXJlXHJcbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9pc3N1ZXMvMjYyXHJcbiAgICAgICAgICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9pc3N1ZXMvMTAzMVxyXG4gICAgICAgICAgICB5aWVsZCBXZWJBdWRpby51bmxvY2soKTtcclxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLmRhdGEgPSB0aGlzLl9yZXNvdXJjZUxpc3QpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgbWFya1Jlc291cmNlQ29tcGxldGUoKSB7XHJcbiAgICAgICAgdGhpcy5fbnVtTG9hZGVkKys7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHByb2dlc3Mgb2YgdGhlIGxvYWRlciBhcyBhIG51bWJlciBiZXR3ZWVuIFswLCAxXSBpbmNsdXNpdmUuXHJcbiAgICAgKi9cclxuICAgIGdldCBwcm9ncmVzcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2VDb3VudCA+IDAgPyBjbGFtcCh0aGlzLl9udW1Mb2FkZWQsIDAsIHRoaXMuX3Jlc291cmNlQ291bnQpIC8gdGhpcy5fcmVzb3VyY2VDb3VudCA6IDE7XHJcbiAgICB9XHJcbiAgICBfcG9zaXRpb25QbGF5QnV0dG9uKCkge1xyXG4gICAgICAgIGNvbnN0IHNjcmVlbkhlaWdodCA9IHRoaXMuX2VuZ2luZS5zY3JlZW4udmlld3BvcnQuaGVpZ2h0O1xyXG4gICAgICAgIGNvbnN0IHNjcmVlbldpZHRoID0gdGhpcy5fZW5naW5lLnNjcmVlbi52aWV3cG9ydC53aWR0aDtcclxuICAgICAgICBpZiAodGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSB0aGlzLl9lbmdpbmUuY2FudmFzLm9mZnNldExlZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHRvcCA9IHRoaXMuX2VuZ2luZS5jYW52YXMub2Zmc2V0VG9wO1xyXG4gICAgICAgICAgICBjb25zdCBidXR0b25XaWR0aCA9IHRoaXMuX3BsYXlCdXR0b24uY2xpZW50V2lkdGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ1dHRvbkhlaWdodCA9IHRoaXMuX3BsYXlCdXR0b24uY2xpZW50SGVpZ2h0O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wbGF5QnV0dG9uUG9zaXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BsYXlCdXR0b25Sb290RWxlbWVudC5zdHlsZS5sZWZ0ID0gYCR7dGhpcy5wbGF5QnV0dG9uUG9zaXRpb24ueH1weGA7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQuc3R5bGUudG9wID0gYCR7dGhpcy5wbGF5QnV0dG9uUG9zaXRpb24ueX1weGA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wbGF5QnV0dG9uUm9vdEVsZW1lbnQuc3R5bGUubGVmdCA9IGAke2xlZnQgKyBzY3JlZW5XaWR0aCAvIDIgLSBidXR0b25XaWR0aCAvIDJ9cHhgO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcGxheUJ1dHRvblJvb3RFbGVtZW50LnN0eWxlLnRvcCA9IGAke3RvcCArIHNjcmVlbkhlaWdodCAvIDIgLSBidXR0b25IZWlnaHQgLyAyICsgMTAwfXB4YDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTG9hZGVyIGRyYXcgZnVuY3Rpb24uIERyYXdzIHRoZSBkZWZhdWx0IEV4Y2FsaWJ1ciBsb2FkaW5nIHNjcmVlbi5cclxuICAgICAqIE92ZXJyaWRlIGBsb2dvYCwgYGxvZ29XaWR0aGAsIGBsb2dvSGVpZ2h0YCBhbmQgYGJhY2tncm91bmRDb2xvcmAgcHJvcGVydGllc1xyXG4gICAgICogdG8gY3VzdG9taXplIHRoZSBkcmF3aW5nLCBvciBqdXN0IG92ZXJyaWRlIGVudGlyZSBtZXRob2QuXHJcbiAgICAgKi9cclxuICAgIGRyYXcoY3R4KSB7XHJcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gdGhpcy5fZW5naW5lLmNhbnZhc0hlaWdodCAvIHRoaXMuX2VuZ2luZS5waXhlbFJhdGlvO1xyXG4gICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gdGhpcy5fZW5naW5lLmNhbnZhc1dpZHRoIC8gdGhpcy5fZW5naW5lLnBpeGVsUmF0aW87XHJcbiAgICAgICAgdGhpcy5fcG9zaXRpb25QbGF5QnV0dG9uKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IHRoaXMuYmFja2dyb3VuZENvbG9yO1xyXG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXNXaWR0aCwgY2FudmFzSGVpZ2h0KTtcclxuICAgICAgICBsZXQgbG9nb1kgPSBjYW52YXNIZWlnaHQgLyAyO1xyXG4gICAgICAgIGNvbnN0IHdpZHRoID0gTWF0aC5taW4odGhpcy5sb2dvV2lkdGgsIGNhbnZhc1dpZHRoICogMC43NSk7XHJcbiAgICAgICAgbGV0IGxvZ29YID0gY2FudmFzV2lkdGggLyAyIC0gd2lkdGggLyAyO1xyXG4gICAgICAgIGlmICh0aGlzLmxvZ29Qb3NpdGlvbikge1xyXG4gICAgICAgICAgICBsb2dvWCA9IHRoaXMubG9nb1Bvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIGxvZ29ZID0gdGhpcy5sb2dvUG9zaXRpb24ueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgaW1hZ2VIZWlnaHQgPSBNYXRoLmZsb29yKHdpZHRoICogKHRoaXMubG9nb0hlaWdodCAvIHRoaXMubG9nb1dpZHRoKSk7IC8vIE9HIGhlaWdodC93aWR0aCBmYWN0b3JcclxuICAgICAgICBjb25zdCBvbGRBbnRpYWxpYXMgPSB0aGlzLl9lbmdpbmUuZ2V0QW50aWFsaWFzaW5nKCk7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnNldEFudGlhbGlhc2luZyh0cnVlKTtcclxuICAgICAgICBpZiAoIXRoaXMubG9nb1Bvc2l0aW9uKSB7XHJcbiAgICAgICAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDAsIHRoaXMubG9nb1dpZHRoLCB0aGlzLmxvZ29IZWlnaHQsIGxvZ29YLCBsb2dvWSAtIGltYWdlSGVpZ2h0IC0gMjAsIHdpZHRoLCBpbWFnZUhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjdHguZHJhd0ltYWdlKHRoaXMuX2ltYWdlLCAwLCAwLCB0aGlzLmxvZ29XaWR0aCwgdGhpcy5sb2dvSGVpZ2h0LCBsb2dvWCwgbG9nb1ksIHdpZHRoLCBpbWFnZUhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGxvYWRpbmcgYm94XHJcbiAgICAgICAgaWYgKCF0aGlzLnN1cHByZXNzUGxheUJ1dHRvbiAmJiB0aGlzLl9wbGF5QnV0dG9uU2hvd24pIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLnNldEFudGlhbGlhc2luZyhvbGRBbnRpYWxpYXMpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBsb2FkaW5nWCA9IGxvZ29YO1xyXG4gICAgICAgIGxldCBsb2FkaW5nWSA9IGxvZ29ZO1xyXG4gICAgICAgIGlmICh0aGlzLmxvYWRpbmdCYXJQb3NpdGlvbikge1xyXG4gICAgICAgICAgICBsb2FkaW5nWCA9IHRoaXMubG9hZGluZ0JhclBvc2l0aW9uLng7XHJcbiAgICAgICAgICAgIGxvYWRpbmdZID0gdGhpcy5sb2FkaW5nQmFyUG9zaXRpb24ueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDI7XHJcbiAgICAgICAgcm91bmRSZWN0KGN0eCwgbG9hZGluZ1gsIGxvYWRpbmdZLCB3aWR0aCwgMjAsIDEwLCB0aGlzLmxvYWRpbmdCYXJDb2xvcik7XHJcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSB3aWR0aCAqIHRoaXMucHJvZ3Jlc3M7XHJcbiAgICAgICAgY29uc3QgbWFyZ2luID0gNTtcclxuICAgICAgICBjb25zdCBwcm9ncmVzc1dpZHRoID0gcHJvZ3Jlc3MgLSBtYXJnaW4gKiAyO1xyXG4gICAgICAgIGNvbnN0IGhlaWdodCA9IDIwIC0gbWFyZ2luICogMjtcclxuICAgICAgICByb3VuZFJlY3QoY3R4LCBsb2FkaW5nWCArIG1hcmdpbiwgbG9hZGluZ1kgKyBtYXJnaW4sIHByb2dyZXNzV2lkdGggPiAxMCA/IHByb2dyZXNzV2lkdGggOiAxMCwgaGVpZ2h0LCA1LCBudWxsLCB0aGlzLmxvYWRpbmdCYXJDb2xvcik7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnNldEFudGlhbGlhc2luZyhvbGRBbnRpYWxpYXMpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9EZXRlY3Rvci50c1xuXHJcbi8qKlxyXG4gKiBUaGlzIGlzIHRoZSBsaXN0IG9mIGZlYXR1cmVzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGxvZyB0aGUgc3VwcG9ydGVkXHJcbiAqIGZlYXR1cmVzIHRvIHRoZSBjb25zb2xlIHdoZW4gRGV0ZWN0b3IubG9nQnJvd3NlckZlYXR1cmVzKCkgaXMgY2FsbGVkLlxyXG4gKi9cclxuY29uc3QgUkVQT1JURURfRkVBVFVSRVMgPSB7XHJcbiAgICB3ZWJnbDogJ1dlYkdMJyxcclxuICAgIHdlYmF1ZGlvOiAnV2ViQXVkaW8nLFxyXG4gICAgZ2FtZXBhZGFwaTogJ0dhbWVwYWQgQVBJJ1xyXG59O1xyXG4vKipcclxuICogRXhjYWxpYnVyIGludGVybmFsIGZlYXR1cmUgZGV0ZWN0aW9uIGhlbHBlciBjbGFzc1xyXG4gKi9cclxuY2xhc3MgRGV0ZWN0b3Ige1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZmFpbGVkVGVzdHMgPSBbXTtcclxuICAgICAgICAvLyBjcml0aWNhbCBicm93c2VyIGZlYXR1cmVzIHJlcXVpcmVkIGZvciBleCB0byBydW5cclxuICAgICAgICB0aGlzLl9jcml0aWNhbFRlc3RzID0ge1xyXG4gICAgICAgICAgICAvLyBUZXN0IGNhbnZhcy8yZCBjb250ZXh0IHN1cHBvcnRcclxuICAgICAgICAgICAgY2FudmFzU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKGVsZW0uZ2V0Q29udGV4dCAmJiBlbGVtLmdldENvbnRleHQoJzJkJykpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBUZXN0IGFycmF5IGJ1ZmZlciBzdXBwb3J0IGV4IHVzZXMgZm9yIGRvd25sb2FkaW5nIGJpbmFyeSBkYXRhXHJcbiAgICAgICAgICAgIGFycmF5QnVmZmVyU3VwcG9ydDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XHJcbiAgICAgICAgICAgICAgICB4aHIub3BlbignR0VUJywgJy8nKTtcclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBUZXN0IGRhdGEgdXJscyBleCB1c2VzIGZvciBzcHJpdGVzXHJcbiAgICAgICAgICAgIGRhdGFVcmxTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjYW52YXMudG9EYXRhVVJMKCdpbWFnZS9wbmcnKS5pbmRleE9mKCdkYXRhOmltYWdlL3BuZycpID09PSAwO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAvLyBUZXN0IG9iamVjdCB1cmwgc3VwcG9ydCBmb3IgbG9hZGluZ1xyXG4gICAgICAgICAgICBvYmplY3RVcmxTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1VSTCcgaW4gd2luZG93ICYmICdyZXZva2VPYmplY3RVUkwnIGluIFVSTCAmJiAnY3JlYXRlT2JqZWN0VVJMJyBpbiBVUkw7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIC8vIFJHQkEgc3VwcG9ydCBmb3IgY29sb3JzXHJcbiAgICAgICAgICAgIHJnYmFTdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKS5zdHlsZTtcclxuICAgICAgICAgICAgICAgIHN0eWxlLmNzc1RleHQgPSAnYmFja2dyb3VuZC1jb2xvcjpyZ2JhKDE1MCwyNTUsMTUwLC41KSc7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gKCcnICsgc3R5bGUuYmFja2dyb3VuZENvbG9yKS5pbmRleE9mKCdyZ2JhJykgPiAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLy8gd2FybmluZ3MgZXhjYWxpYnVyIHBlcmZvcm1hbmNlIHdpbGwgYmUgZGVncmFkZWRcclxuICAgICAgICB0aGlzLl93YXJuaW5nVGVzdCA9IHtcclxuICAgICAgICAgICAgd2ViQXVkaW9TdXBwb3J0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISEod2luZG93LkF1ZGlvQ29udGV4dCB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQgfHxcclxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubW96QXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lm1zQXVkaW9Db250ZXh0IHx8XHJcbiAgICAgICAgICAgICAgICAgICAgd2luZG93Lm9BdWRpb0NvbnRleHQpO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB3ZWJnbFN1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiAhIShlbGVtLmdldENvbnRleHQgJiYgZWxlbS5nZXRDb250ZXh0KCd3ZWJnbCcpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSB0aGlzLl9sb2FkQnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBtYXAgb2YgY3VycmVudGx5IHN1cHBvcnRlZCBicm93c2VyIGZlYXR1cmVzLiBUaGlzIG1ldGhvZFxyXG4gICAgICogdHJlYXRzIHRoZSBmZWF0dXJlcyBhcyBhIHNpbmdsZXRvbiBhbmQgd2lsbCBvbmx5IGNhbGN1bGF0ZSBmZWF0dXJlXHJcbiAgICAgKiBzdXBwb3J0IGlmIGl0IGhhcyBub3QgcHJldmlvdXNseSBiZWVuIGRvbmUuXHJcbiAgICAgKi9cclxuICAgIGdldEJyb3dzZXJGZWF0dXJlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5fZmVhdHVyZXMgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5fZmVhdHVyZXMgPSB0aGlzLl9sb2FkQnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9mZWF0dXJlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVwb3J0IG9uIG5vbi1jcml0aWNhbCBicm93c2VyIHN1cHBvcnQgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlcy5cclxuICAgICAqIFVzZSBuYXRpdmUgYnJvd3NlciBjb25zb2xlIGNvbG9ycyBmb3IgdmlzaWJpbGl0eS5cclxuICAgICAqL1xyXG4gICAgbG9nQnJvd3NlckZlYXR1cmVzKCkge1xyXG4gICAgICAgIGxldCBtc2cgPSAnJWNTVVBQT1JURUQgQlJPV1NFUiBGRUFUVVJFU1xcbj09PT09PT09PT09PT09PT09PT09PT09PT09JWNcXG4nO1xyXG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbJ2ZvbnQtd2VpZ2h0OiBib2xkOyBjb2xvcjogbmF2eScsICdmb250LXdlaWdodDogbm9ybWFsOyBjb2xvcjogaW5oZXJpdCddO1xyXG4gICAgICAgIGNvbnN0IHN1cHBvcnRlZCA9IHRoaXMuZ2V0QnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBmZWF0dXJlIG9mIE9iamVjdC5rZXlzKFJFUE9SVEVEX0ZFQVRVUkVTKSkge1xyXG4gICAgICAgICAgICBpZiAoc3VwcG9ydGVkW2ZlYXR1cmVdKSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gJyglY1xcdTI3MTMlYyknOyAvLyAo4pyTKVxyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKCdmb250LXdlaWdodDogYm9sZDsgY29sb3I6IGdyZWVuJyk7XHJcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2goJ2ZvbnQtd2VpZ2h0OiBub3JtYWw7IGNvbG9yOiBpbmhlcml0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtc2cgKz0gJyglY1xcdTI3MTclYyknOyAvLyAo4pyXKVxyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKCdmb250LXdlaWdodDogYm9sZDsgY29sb3I6IHJlZCcpO1xyXG4gICAgICAgICAgICAgICAgYXJncy5wdXNoKCdmb250LXdlaWdodDogbm9ybWFsOyBjb2xvcjogaW5oZXJpdCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG1zZyArPSAnICcgKyBSRVBPUlRFRF9GRUFUVVJFU1tmZWF0dXJlXSArICdcXG4nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhcmdzLnVuc2hpZnQobXNnKTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBFeGVjdXRlcyBzZXZlcmFsIElJRkUncyB0byBnZXQgYSBjb25zdGFudCByZWZlcmVuY2UgdG8gc3VwcG9ydGVkXHJcbiAgICAgKiBmZWF0dXJlcyB3aXRoaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGNvbnRleHQuXHJcbiAgICAgKi9cclxuICAgIF9sb2FkQnJvd3NlckZlYXR1cmVzKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgY2FudmFzIHN1cHBvcnRcclxuICAgICAgICAgICAgY2FudmFzOiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyaXRpY2FsVGVzdHMuY2FudmFzU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIGFycmF5YnVmZmVyIHN1cHBvcnRcclxuICAgICAgICAgICAgYXJyYXlidWZmZXI6ICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fY3JpdGljYWxUZXN0cy5hcnJheUJ1ZmZlclN1cHBvcnQoKTtcclxuICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayBkYXRhdXJsIHN1cHBvcnRcclxuICAgICAgICAgICAgZGF0YXVybDogKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jcml0aWNhbFRlc3RzLmRhdGFVcmxTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgb2JqZWN0dXJsIHN1cHBvcnRcclxuICAgICAgICAgICAgb2JqZWN0dXJsOiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyaXRpY2FsVGVzdHMub2JqZWN0VXJsU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIHJnYmEgc3VwcG9ydFxyXG4gICAgICAgICAgICByZ2JhOiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NyaXRpY2FsVGVzdHMucmdiYVN1cHBvcnQoKTtcclxuICAgICAgICAgICAgfSkoKSxcclxuICAgICAgICAgICAgLy8gSUlGRSB0byBjaGVjayB3ZWJhdWRpbyBzdXBwb3J0XHJcbiAgICAgICAgICAgIHdlYmF1ZGlvOiAoKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dhcm5pbmdUZXN0LndlYkF1ZGlvU3VwcG9ydCgpO1xyXG4gICAgICAgICAgICB9KSgpLFxyXG4gICAgICAgICAgICAvLyBJSUZFIHRvIGNoZWNrIHdlYmdsIHN1cHBvcnRcclxuICAgICAgICAgICAgd2ViZ2w6ICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2FybmluZ1Rlc3Qud2ViZ2xTdXBwb3J0KCk7XHJcbiAgICAgICAgICAgIH0pKCksXHJcbiAgICAgICAgICAgIC8vIElJRkUgdG8gY2hlY2sgZ2FtZXBhZGFwaSBzdXBwb3J0XHJcbiAgICAgICAgICAgIGdhbWVwYWRhcGk6ICgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gISFuYXZpZ2F0b3IuZ2V0R2FtZXBhZHM7XHJcbiAgICAgICAgICAgIH0pKClcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdGVzdCgpIHtcclxuICAgICAgICAvLyBDcml0aWNhbCB0ZXN0IHdpbGwgZm9yIGV4IG5vdCB0byBydW5cclxuICAgICAgICBsZXQgZmFpbGVkQ3JpdGljYWwgPSBmYWxzZTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRlc3QgaW4gdGhpcy5fY3JpdGljYWxUZXN0cykge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NyaXRpY2FsVGVzdHNbdGVzdF0uY2FsbCh0aGlzKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsZWRUZXN0cy5wdXNoKHRlc3QpO1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0NyaXRpY2FsIGJyb3dzZXIgZmVhdHVyZSBtaXNzaW5nLCBFeGNhbGlidXIgcmVxdWlyZXM6JywgdGVzdCk7XHJcbiAgICAgICAgICAgICAgICBmYWlsZWRDcml0aWNhbCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZhaWxlZENyaXRpY2FsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2FybmluZyB0ZXN0cyBkbyBub3QgZm9yIGV4IHRvIHJldHVybiBmYWxzZSB0byBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgZm9yIChjb25zdCB3YXJuaW5nIGluIHRoaXMuX3dhcm5pbmdUZXN0KSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fd2FybmluZ1Rlc3Rbd2FybmluZ10oKSkge1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignV2FybmluZyBicm93c2VyIGZlYXR1cmUgbWlzc2luZywgRXhjYWxpYnVyIHdpbGwgaGF2ZSByZWR1Y2VkIHBlcmZvcm1hbmNlOicsIHdhcm5pbmcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpc2lvblR5cGUudHNcbi8qKlxyXG4gKiBBbiBlbnVtIHRoYXQgZGVzY3JpYmVzIHRoZSB0eXBlcyBvZiBjb2xsaXNpb25zIGJvZGllcyBjYW4gcGFydGljaXBhdGUgaW5cclxuICovXHJcbnZhciBDb2xsaXNpb25UeXBlO1xyXG4oZnVuY3Rpb24gKENvbGxpc2lvblR5cGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogQm9kaWVzIHdpdGggdGhlIGBQcmV2ZW50Q29sbGlzaW9uYCBzZXR0aW5nIGRvIG5vdCBwYXJ0aWNpcGF0ZSBpbiBhbnlcclxuICAgICAqIGNvbGxpc2lvbnMgYW5kIGRvIG5vdCByYWlzZSBjb2xsaXNpb24gZXZlbnRzLlxyXG4gICAgICovXHJcbiAgICBDb2xsaXNpb25UeXBlW1wiUHJldmVudENvbGxpc2lvblwiXSA9IFwiUHJldmVudENvbGxpc2lvblwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBCb2RpZXMgd2l0aCB0aGUgYFBhc3NpdmVgIHNldHRpbmcgb25seSByYWlzZSBjb2xsaXNpb24gZXZlbnRzLCBidXQgYXJlIG5vdFxyXG4gICAgICogaW5mbHVlbmNlZCBvciBtb3ZlZCBieSBvdGhlciBib2RpZXMgYW5kIGRvIG5vdCBpbmZsdWVuY2Ugb3IgbW92ZSBvdGhlciBib2RpZXMuXHJcbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgdXNlIGluIHRyaWdnZXIgdHlwZSBiZWhhdmlvci5cclxuICAgICAqL1xyXG4gICAgQ29sbGlzaW9uVHlwZVtcIlBhc3NpdmVcIl0gPSBcIlBhc3NpdmVcIjtcclxuICAgIC8qKlxyXG4gICAgICogQm9kaWVzIHdpdGggdGhlIGBBY3RpdmVgIHNldHRpbmcgcmFpc2UgY29sbGlzaW9uIGV2ZW50cyBhbmQgcGFydGljaXBhdGVcclxuICAgICAqIGluIGNvbGxpc2lvbnMgd2l0aCBvdGhlciBib2RpZXMgYW5kIHdpbGwgYmUgcHVzaCBvciBtb3ZlZCBieSBib2RpZXMgc2hhcmluZ1xyXG4gICAgICogdGhlIGBBY3RpdmVgIG9yIGBGaXhlZGAgc2V0dGluZy5cclxuICAgICAqL1xyXG4gICAgQ29sbGlzaW9uVHlwZVtcIkFjdGl2ZVwiXSA9IFwiQWN0aXZlXCI7XHJcbiAgICAvKipcclxuICAgICAqIEJvZGllcyB3aXRoIHRoZSBgRml4ZWRgIHNldHRpbmcgcmFpc2UgY29sbGlzaW9uIGV2ZW50cyBhbmQgcGFydGljaXBhdGUgaW5cclxuICAgICAqIGNvbGxpc2lvbnMgd2l0aCBvdGhlciBib2RpZXMuIEFjdG9ycyB3aXRoIHRoZSBgRml4ZWRgIHNldHRpbmcgd2lsbCBub3QgYmVcclxuICAgICAqIHB1c2hlZCBvciBtb3ZlZCBieSBvdGhlciBib2RpZXMgc2hhcmluZyB0aGUgYEZpeGVkYC4gVGhpbmsgb2YgRml4ZWRcclxuICAgICAqIGJvZGllcyBhcyBcImltbW92YWJsZS91bnN0b3BwYWJsZVwiIG9iamVjdHMuIElmIHR3byBgRml4ZWRgIGJvZGllcyBtZWV0IHRoZXkgd2lsbFxyXG4gICAgICogbm90IGJlIHB1c2hlZCBvciBtb3ZlZCBieSBlYWNoIG90aGVyLCB0aGV5IHdpbGwgbm90IGludGVyYWN0IGV4Y2VwdCB0byB0aHJvd1xyXG4gICAgICogY29sbGlzaW9uIGV2ZW50cy5cclxuICAgICAqL1xyXG4gICAgQ29sbGlzaW9uVHlwZVtcIkZpeGVkXCJdID0gXCJGaXhlZFwiO1xyXG59KShDb2xsaXNpb25UeXBlIHx8IChDb2xsaXNpb25UeXBlID0ge30pKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vUGh5c2ljcy50c1xudmFyIFBoeXNpY3NfZGVjb3JhdGUgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFBvc3NpYmxlIGNvbGxpc2lvbiByZXNvbHV0aW9uIHN0cmF0ZWdpZXNcclxuICpcclxuICogVGhlIGRlZmF1bHQgaXMgW1tDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQXJjYWRlXV0gd2hpY2ggcGVyZm9ybXMgc2ltcGxlIGF4aXMgYWxpZ25lZCBhcmNhZGUgc3R5bGUgcGh5c2ljcy4gVGhpcyBpcyB1c2VmdWwgZm9yIHRoaW5nc1xyXG4gKiBsaWtlIHBsYXRmb3JtZXJzIG9yIHRvcCBkb3duIGdhbWVzLlxyXG4gKlxyXG4gKiBNb3JlIGFkdmFuY2VkIHJpZ2lkIGJvZHkgcGh5c2ljcyBhcmUgZW5hYmxlZCBieSBzZXR0aW5nIFtbQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LlJlYWxpc3RpY11dIHdoaWNoIGFsbG93cyBmb3IgY29tcGxpY2F0ZWRcclxuICogc2ltdWxhdGVkIHBoeXNpY2FsIGludGVyYWN0aW9ucy5cclxuICovXHJcbnZhciBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3k7XHJcbihmdW5jdGlvbiAoQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5KSB7XHJcbiAgICBDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3lbXCJBcmNhZGVcIl0gPSBcImFyY2FkZVwiO1xyXG4gICAgQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5W1wiUmVhbGlzdGljXCJdID0gXCJyZWFsaXN0aWNcIjtcclxufSkoQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5IHx8IChDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kgPSB7fSkpO1xyXG4vKipcclxuICogUG9zc2libGUgYnJvYWRwaGFzZSBjb2xsaXNpb24gcGFpciBpZGVudGlmaWNhdGlvbiBzdHJhdGVnaWVzXHJcbiAqXHJcbiAqIFRoZSBkZWZhdWx0IHN0cmF0ZWd5IGlzIFtbQnJvYWRwaGFzZVN0cmF0ZWd5LkR5bmFtaWNBQUJCVHJlZV1dIHdoaWNoIHVzZXMgYSBiaW5hcnkgdHJlZSBvZiBheGlzLWFsaWduZWQgYm91bmRpbmcgYm94ZXMgdG8gaWRlbnRpZnlcclxuICogcG90ZW50aWFsIGNvbGxpc2lvbiBwYWlycyB3aGljaCBpcyBPKG5sb2cobikpIGZhc3Rlci5cclxuICovXHJcbnZhciBCcm9hZHBoYXNlU3RyYXRlZ3k7XHJcbihmdW5jdGlvbiAoQnJvYWRwaGFzZVN0cmF0ZWd5KSB7XHJcbiAgICBCcm9hZHBoYXNlU3RyYXRlZ3lbQnJvYWRwaGFzZVN0cmF0ZWd5W1wiRHluYW1pY0FBQkJUcmVlXCJdID0gMF0gPSBcIkR5bmFtaWNBQUJCVHJlZVwiO1xyXG59KShCcm9hZHBoYXNlU3RyYXRlZ3kgfHwgKEJyb2FkcGhhc2VTdHJhdGVneSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBQb3NzaWJsZSBudW1lcmljYWwgaW50ZWdyYXRvcnMgZm9yIHBvc2l0aW9uIGFuZCB2ZWxvY2l0eVxyXG4gKi9cclxudmFyIEludGVncmF0b3I7XHJcbihmdW5jdGlvbiAoSW50ZWdyYXRvcikge1xyXG4gICAgSW50ZWdyYXRvcltJbnRlZ3JhdG9yW1wiRXVsZXJcIl0gPSAwXSA9IFwiRXVsZXJcIjtcclxufSkoSW50ZWdyYXRvciB8fCAoSW50ZWdyYXRvciA9IHt9KSk7XHJcbi8qKlxyXG4gKiBUaGUgW1tQaHlzaWNzXV0gb2JqZWN0IGlzIHRoZSBnbG9iYWwgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGFsbCBFeGNhbGlidXIgcGh5c2ljcy5cclxuICovXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbmNsYXNzIFBoeXNpY3Mge1xyXG4gICAgc3RhdGljIGdldCBncmF2aXR5KCkge1xyXG4gICAgICAgIHJldHVybiBQaHlzaWNzLmFjYztcclxuICAgIH1cclxuICAgIHN0YXRpYyBzZXQgZ3Jhdml0eSh2KSB7XHJcbiAgICAgICAgUGh5c2ljcy5hY2MgPSB2O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDb25maWd1cmVzIEV4Y2FsaWJ1ciB0byB1c2UgXCJhcmNhZGVcIiBwaHlzaWNzLiBBcmNhZGUgcGh5c2ljcyB3aGljaCBwZXJmb3JtcyBzaW1wbGUgYXhpcyBhbGlnbmVkIGFyY2FkZSBzdHlsZSBwaHlzaWNzLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdXNlQXJjYWRlUGh5c2ljcygpIHtcclxuICAgICAgICBQaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5BcmNhZGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENvbmZpZ3VyZXMgRXhjYWxpYnVyIHRvIHVzZSByaWdpZCBib2R5IHBoeXNpY3MuIFJpZ2lkIGJvZHkgcGh5c2ljcyBhbGxvd3MgZm9yIGNvbXBsaWNhdGVkXHJcbiAgICAgKiBzaW11bGF0ZWQgcGh5c2ljYWwgaW50ZXJhY3Rpb25zLlxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgdXNlUmVhbGlzdGljUGh5c2ljcygpIHtcclxuICAgICAgICBQaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SZWFsaXN0aWM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IGR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBseWVyKCkge1xyXG4gICAgICAgIHJldHVybiBQaHlzaWNzLmR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBsaWVyO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIHNldCBkeW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbHllcih2YWx1ZSkge1xyXG4gICAgICAgIFBoeXNpY3MuZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGxpZXIgPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogR2xvYmFsIGFjY2VsZXJhdGlvbiB0aGF0IGlzIGFwcGxpZWQgdG8gYWxsIHZhbmlsbGEgYWN0b3JzIHRoYXQgaGF2ZSBhIFtbQ29sbGlzaW9uVHlwZS5BY3RpdmV8YWN0aXZlXV0gY29sbGlzaW9uIHR5cGUuXHJcbiAqIEdsb2JhbCBhY2NlbGVyYXRpb24gd29uJ3QgZWZmZWN0IFtbTGFiZWx8bGFiZWxzXV0sIFtbU2NyZWVuRWxlbWVudHx1aSBhY3RvcnNdXSwgb3IgW1tUcmlnZ2VyfHRyaWdnZXJzXV0gaW4gRXhjYWxpYnVyLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGEgZ3JlYXQgd2F5IHRvIGdsb2JhbGx5IHNpbXVsYXRlIGVmZmVjdHMgbGlrZSBncmF2aXR5LlxyXG4gKi9cclxuUGh5c2ljcy5hY2MgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4vKipcclxuICogR2xvYmFsbHkgc3dpdGNoZXMgYWxsIEV4Y2FsaWJ1ciBwaHlzaWNzIGJlaGF2aW9yIG9uIG9yIG9mZi5cclxuICovXHJcblBoeXNpY3MuZW5hYmxlZCA9IHRydWU7XHJcbi8qKlxyXG4gKiBHZXRzIG9yIHNldHMgdGhlIGJyb2FkcGhhc2UgcGFpciBpZGVudGlmaWNhdGlvbiBzdHJhdGVneS5cclxuICpcclxuICogVGhlIGRlZmF1bHQgc3RyYXRlZ3kgaXMgW1tCcm9hZHBoYXNlU3RyYXRlZ3kuRHluYW1pY0FBQkJUcmVlXV0gd2hpY2ggdXNlcyBhIGJpbmFyeSB0cmVlIG9mIGF4aXMtYWxpZ25lZCBib3VuZGluZyBib3hlcyB0byBpZGVudGlmeVxyXG4gKiBwb3RlbnRpYWwgY29sbGlzaW9uIHBhaXJzIHdoaWNoIGlzIE8obmxvZyhuKSkgZmFzdGVyLlxyXG4gKi9cclxuUGh5c2ljcy5icm9hZHBoYXNlU3RyYXRlZ3kgPSBCcm9hZHBoYXNlU3RyYXRlZ3kuRHluYW1pY0FBQkJUcmVlO1xyXG4vKipcclxuICogR2V0cyBvciBzZXRzIHRoZSBnbG9iYWwgY29sbGlzaW9uIHJlc29sdXRpb24gc3RyYXRlZ3kgKG5hcnJvd3BoYXNlKS5cclxuICpcclxuICogVGhlIGRlZmF1bHQgaXMgW1tDb2xsaXNpb25SZXNvbHV0aW9uU3RyYXRlZ3kuQXJjYWRlXV0gd2hpY2ggcGVyZm9ybXMgc2ltcGxlIGF4aXMgYWxpZ25lZCBhcmNhZGUgc3R5bGUgcGh5c2ljcy5cclxuICpcclxuICogTW9yZSBhZHZhbmNlZCByaWdpZCBib2R5IHBoeXNpY3MgYXJlIGVuYWJsZWQgYnkgc2V0dGluZyBbW0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5SZWFsaXN0aWNdXSB3aGljaCBhbGxvd3MgZm9yIGNvbXBsaWNhdGVkXHJcbiAqIHNpbXVsYXRlZCBwaHlzaWNhbCBpbnRlcmFjdGlvbnMuXHJcbiAqL1xyXG5QaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneS5BcmNhZGU7XHJcbi8qKlxyXG4gKiBUaGUgZGVmYXVsdCBtYXNzIHRvIHVzZSBpZiBub25lIGlzIHNwZWNpZmllZFxyXG4gKi9cclxuUGh5c2ljcy5kZWZhdWx0TWFzcyA9IDEwO1xyXG4vKipcclxuICogR2V0cyBvciBzZXRzIHRoZSBwb3NpdGlvbiBhbmQgdmVsb2NpdHkgcG9zaXRpb25hbCBpbnRlZ3JhdG9yLCBjdXJyZW50bHkgb25seSBFdWxlciBpcyBzdXBwb3J0ZWQuXHJcbiAqL1xyXG5QaHlzaWNzLmludGVncmF0b3IgPSBJbnRlZ3JhdG9yLkV1bGVyO1xyXG4vKipcclxuICogRmFjdG9yIHRvIGFkZCB0byB0aGUgUmlnaWRCb2R5IEJvdW5kaW5nQm94LCBib3VuZGluZyBib3ggKGRpbWVuc2lvbnMgKz0gdmVsICogZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGxpZXIpO1xyXG4gKi9cclxuUGh5c2ljcy5keW5hbWljVHJlZVZlbG9jaXR5TXVsdGlwbGllciA9IDI7XHJcbi8qKlxyXG4gKiBQYWQgUmlnaWRCb2R5IEJvdW5kaW5nQm94IGJ5IGEgY29uc3RhbnQgYW1vdW50XHJcbiAqL1xyXG5QaHlzaWNzLmJvdW5kc1BhZGRpbmcgPSA1O1xyXG4vKipcclxuICogTnVtYmVyIG9mIHBvc2l0aW9uIGl0ZXJhdGlvbnMgKG92ZXJsYXApIHRvIHJ1biBpbiB0aGUgc29sdmVyXHJcbiAqL1xyXG5QaHlzaWNzLnBvc2l0aW9uSXRlcmF0aW9ucyA9IDM7XHJcbi8qKlxyXG4gKiBOdW1iZXIgb2YgdmVsb2NpdHkgaXRlcmF0aW9uIChyZXNwb25zZSkgdG8gcnVuIGluIHRoZSBzb2x2ZXJcclxuICovXHJcblBoeXNpY3MudmVsb2NpdHlJdGVyYXRpb25zID0gODtcclxuLyoqXHJcbiAqIEFtb3VudCBvZiBvdmVybGFwIHRvIHRvbGVyYXRlIGluIHBpeGVsc1xyXG4gKi9cclxuUGh5c2ljcy5zbG9wID0gMTtcclxuLyoqXHJcbiAqIEFtb3VudCBvZiBwb3NpdGlvbmFsIG92ZXJsYXAgY29ycmVjdGlvbiB0byBhcHBseSBlYWNoIHBvc2l0aW9uIGl0ZXJhdGlvbiBvZiB0aGUgc29sdmVyXHJcbiAqIE8gLSBtZWFuaW5nIG5vIGNvcnJlY3Rpb24sIDEgLSBtZWFuaW5nIGNvcnJlY3QgYWxsIG92ZXJsYXBcclxuICovXHJcblBoeXNpY3Muc3RlZXJpbmdGYWN0b3IgPSAwLjI7XHJcbi8qKlxyXG4gKiBXYXJtIHN0YXJ0IHNldCB0byB0cnVlIHJlLXVzZXMgaW1wdWxzZXMgZnJvbSBwcmV2aW91cyBmcmFtZXMgYmFjayBpbiB0aGUgc29sdmVyXHJcbiAqL1xyXG5QaHlzaWNzLndhcm1TdGFydCA9IHRydWU7XHJcbi8qKlxyXG4gKiBCeSBkZWZhdWx0IGJvZGllcyBkbyBub3Qgc2xlZXBcclxuICovXHJcblBoeXNpY3MuYm9kaWVzQ2FuU2xlZXBCeURlZmF1bHQgPSBmYWxzZTtcclxuLyoqXHJcbiAqIFN1cmZhY2UgZXBzaWxvbiBpcyB1c2VkIHRvIGhlbHAgZGVhbCB3aXRoIHN1cmZhY2UgcGVuZXRyYXRpb25cclxuICovXHJcblBoeXNpY3Muc3VyZmFjZUVwc2lsb24gPSAwLjE7XHJcblBoeXNpY3Muc2xlZXBFcHNpbG9uID0gMC4wNztcclxuUGh5c2ljcy53YWtlVGhyZXNob2xkID0gUGh5c2ljcy5zbGVlcEVwc2lsb24gKiAzO1xyXG5QaHlzaWNzLnNsZWVwQmlhcyA9IDAuOTtcclxuLyoqXHJcbiAqIEVuYWJsZSBmYXN0IG1vdmluZyBib2R5IGNoZWNraW5nLCB0aGlzIGVuYWJsZXMgY2hlY2tpbmcgZm9yIGNvbGxpc2lvbiBwYWlycyB2aWEgcmF5Y2FzdCBmb3IgZmFzdCBtb3Zpbmcgb2JqZWN0cyB0byBwcmV2ZW50XHJcbiAqIGJvZGllcyBmcm9tIHR1bm5lbGluZyB0aHJvdWdoIG9uZSBhbm90aGVyLlxyXG4gKi9cclxuUGh5c2ljcy5jaGVja0ZvckZhc3RCb2RpZXMgPSB0cnVlO1xyXG4vKipcclxuICogRGlzYWJsZSBtaW5pbXVtIGZhc3QgbW92aW5nIGJvZHkgcmF5Y2FzdCwgYnkgZGVmYXVsdCBpZiBleC5QaHlzaWNzLmNoZWNrRm9yRmFzdEJvZGllcyA9IHRydWUgRXhjYWxpYnVyIHdpbGwgb25seSBjaGVjayBpZiB0aGVcclxuICogYm9keSBpcyBtb3ZpbmcgYXQgbGVhc3QgaGFsZiBvZiBpdHMgbWluaW11bSBkaW1lbnNpb24gaW4gYW4gdXBkYXRlLiBJZiBleC5QaHlzaWNzLmRpc2FibGVNaW5pbXVtU3BlZWRGb3JGYXN0Qm9keSBpcyBzZXQgdG8gdHJ1ZSxcclxuICogRXhjYWxpYnVyIHdpbGwgYWx3YXlzIHBlcmZvcm0gdGhlIGZhc3QgYm9keSByYXljYXN0IHJlZ2FyZGxlc3Mgb2Ygc3BlZWQuXHJcbiAqL1xyXG5QaHlzaWNzLmRpc2FibGVNaW5pbXVtU3BlZWRGb3JGYXN0Qm9keSA9IGZhbHNlO1xyXG5QaHlzaWNzX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnQWxpYXMgZm9yIGluY29ycmVjdCBzcGVsbGluZyB1c2VkIGluIG9sZGVyIHZlcnNpb25zLCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjUuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnZHluYW1pY1RyZWVWZWxvY2l0eU11bHRpcGxpZXInXHJcbiAgICB9KVxyXG5dLCBQaHlzaWNzLCBcImR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBseWVyXCIsIG51bGwpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL01hdGgvdmVjdG9yLXZpZXcudHNcblxyXG5jbGFzcyBWZWN0b3JWaWV3IGV4dGVuZHMgVmVjdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcigwLCAwKTtcclxuICAgICAgICB0aGlzLl9nZXRYID0gb3B0aW9ucy5nZXRYO1xyXG4gICAgICAgIHRoaXMuX2dldFkgPSBvcHRpb25zLmdldFk7XHJcbiAgICAgICAgdGhpcy5fc2V0WCA9IG9wdGlvbnMuc2V0WDtcclxuICAgICAgICB0aGlzLl9zZXRZID0gb3B0aW9ucy5zZXRZO1xyXG4gICAgfVxyXG4gICAgZ2V0IHgoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl94ID0gdGhpcy5fZ2V0WCgpKTtcclxuICAgIH1cclxuICAgIHNldCB4KHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3NldFgodmFsKTtcclxuICAgICAgICB0aGlzLl94ID0gdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IHkoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl95ID0gdGhpcy5fZ2V0WSgpKTtcclxuICAgIH1cclxuICAgIHNldCB5KHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3NldFkodmFsKTtcclxuICAgICAgICB0aGlzLl95ID0gdmFsO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRW50aXR5Q29tcG9uZW50U3lzdGVtL0NvbXBvbmVudC50c1xuLyoqXHJcbiAqIFR5cGUgZ3VhcmQgdG8gY2hlY2sgaWYgYSBjb21wb25lbnQgaW1wbGVtZW50cyBjbG9uZVxyXG4gKiBAcGFyYW0geFxyXG4gKi9cclxuZnVuY3Rpb24gaGFzQ2xvbmUoeCkge1xyXG4gICAgcmV0dXJuICEhKHggPT09IG51bGwgfHwgeCA9PT0gdm9pZCAwID8gdm9pZCAwIDogeC5jbG9uZSk7XHJcbn1cclxuLyoqXHJcbiAqIENvbXBvbmVudHMgYXJlIGNvbnRhaW5lcnMgZm9yIHN0YXRlIGluIEV4Y2FsaWJ1ciwgdGhlIGFyZSBtZWFudCB0byBjb252ZXkgY2FwYWJpbGl0aWVzIHRoYXQgYW4gRW50aXR5IHBvc2Vzc2VzXHJcbiAqXHJcbiAqIEltcGxlbWVudGF0aW9ucyBvZiBDb21wb25lbnQgbXVzdCBoYXZlIGEgemVyby1hcmcgY29uc3RydWN0b3IgdG8gc3VwcG9ydCBkZXBlbmRlY2llc1xyXG4gKlxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNsYXNzIE15Q29tcG9uZW50IGV4dGVuZHMgZXguQ29tcG9uZW50PCdteSc+IHtcclxuICogICBwdWJsaWMgcmVhZG9ubHkgdHlwZSA9ICdteSc7XHJcbiAqICAgLy8gemVybyBhcmcgc3VwcG9ydCByZXF1aXJlZCBpZiB5b3Ugd2FudCB0byB1c2UgY29tcG9uZW50IGRlcGVuZGVuY2llc1xyXG4gKiAgIGNvbnN0cnVjdG9yKHB1YmxpYyBvcHRpb25hbFBvcz86IGV4LlZlY3Rvcikge31cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmNsYXNzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IG93bmluZyBbW0VudGl0eV1dLCBpZiBhbnksIG9mIHRoaXMgY29tcG9uZW50LiBOdWxsIGlmIG5vdCBhZGRlZCB0byBhbnkgW1tFbnRpdHldXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub3duZXIgPSBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbG9uZXMgYW55IHByb3BlcnRpZXMgb24gdGhpcyBjb21wb25lbnQsIGlmIHRoYXQgcHJvcGVydHkgdmFsdWUgaGFzIGEgYGNsb25lKClgIG1ldGhvZCBpdCB3aWxsIGJlIGNhbGxlZFxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBjb25zdCBuZXdDb21wb25lbnQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpO1xyXG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBpbiB0aGlzKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHByb3ApKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzW3Byb3BdO1xyXG4gICAgICAgICAgICAgICAgaWYgKGhhc0Nsb25lKHZhbCkgJiYgcHJvcCAhPT0gJ293bmVyJyAmJiBwcm9wICE9PSAnY2xvbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbmV3Q29tcG9uZW50W3Byb3BdID0gdmFsLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBuZXdDb21wb25lbnRbcHJvcF0gPSB2YWw7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld0NvbXBvbmVudDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGFnIGNvbXBvbmVudHMgYXJlIGEgd2F5IG9mIHRhZ2dpbmcgYSBjb21wb25lbnQgd2l0aCBsYWJlbCBhbmQgYSBzaW1wbGUgdmFsdWVcclxuICpcclxuICogRm9yIGV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY29uc3QgaXNPZmZzY3JlZW4gPSBuZXcgVGFnQ29tcG9uZW50KCdvZmZzY3JlZW4nKTtcclxuICogZW50aXR5LmFkZENvbXBvbmVudChpc09mZnNjcmVlbik7XHJcbiAqIGVudGl0eS50YWdzLmluY2x1ZGVzXHJcbiAqIGBgYFxyXG4gKi9cclxuY2xhc3MgVGFnQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGUsIHZhbHVlKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xyXG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9Db21wb25lbnRzL1RyYW5zZm9ybUNvbXBvbmVudC50c1xuXHJcblxyXG5cclxuXHJcbmNvbnN0IGNyZWF0ZVBvc1ZpZXcgPSAobWF0cml4KSA9PiB7XHJcbiAgICBjb25zdCBzb3VyY2UgPSBtYXRyaXg7XHJcbiAgICByZXR1cm4gbmV3IFZlY3RvclZpZXcoe1xyXG4gICAgICAgIHNldFg6ICh4KSA9PiB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5kYXRhW01hdHJpeExvY2F0aW9ucy5YXSA9IHg7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRZOiAoeSkgPT4ge1xyXG4gICAgICAgICAgICBzb3VyY2UuZGF0YVtNYXRyaXhMb2NhdGlvbnMuWV0gPSB5O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0WDogKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmRhdGFbTWF0cml4TG9jYXRpb25zLlhdO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0WTogKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmRhdGFbTWF0cml4TG9jYXRpb25zLlldO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG5jb25zdCBjcmVhdGVTY2FsZVZpZXcgPSAobWF0cml4KSA9PiB7XHJcbiAgICBjb25zdCBzb3VyY2UgPSBtYXRyaXg7XHJcbiAgICByZXR1cm4gbmV3IFZlY3RvclZpZXcoe1xyXG4gICAgICAgIHNldFg6ICh4KSA9PiB7XHJcbiAgICAgICAgICAgIHNvdXJjZS5zZXRTY2FsZVgoeCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzZXRZOiAoeSkgPT4ge1xyXG4gICAgICAgICAgICBzb3VyY2Uuc2V0U2NhbGVZKHkpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0WDogKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmdldFNjYWxlWCgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZ2V0WTogKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gc291cmNlLmdldFNjYWxlWSgpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59O1xyXG4vKipcclxuICogRW51bSByZXByZXNlbnRpbmcgdGhlIGNvb3JkaW5hdGUgcGxhbmUgZm9yIHRoZSBwb3NpdGlvbiAyRCB2ZWN0b3IgaW4gdGhlIFtbVHJhbnNmb3JtQ29tcG9uZW50XV1cclxuICovXHJcbnZhciBDb29yZFBsYW5lO1xyXG4oZnVuY3Rpb24gKENvb3JkUGxhbmUpIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdvcmxkIGNvb3JkaW5hdGUgcGxhbmUgKGRlZmF1bHQpIHJlcHJlc2VudHMgd29ybGQgc3BhY2UsIGFueSBlbnRpdGllcyBkcmF3biB3aXRoIHdvcmxkXHJcbiAgICAgKiBzcGFjZSBtb3ZlIHdoZW4gdGhlIGNhbWVyYSBtb3Zlcy5cclxuICAgICAqL1xyXG4gICAgQ29vcmRQbGFuZVtcIldvcmxkXCJdID0gXCJ3b3JsZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2NyZWVuIGNvb3JkaW5hdGUgcGxhbmUgcmVwcmVzZW50cyBzY3JlZW4gc3BhY2UsIGVudGl0aWVzIGRyYXduIGluIHNjcmVlbiBzcGFjZSBhcmUgcGlubmVkXHJcbiAgICAgKiB0byBzY3JlZW4gY29vcmRpbmF0ZXMgaWdub3JpbmcgdGhlIGNhbWVyYS5cclxuICAgICAqL1xyXG4gICAgQ29vcmRQbGFuZVtcIlNjcmVlblwiXSA9IFwic2NyZWVuXCI7XHJcbn0pKENvb3JkUGxhbmUgfHwgKENvb3JkUGxhbmUgPSB7fSkpO1xyXG5jbGFzcyBUcmFuc2Zvcm1Db21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZXgudHJhbnNmb3JtJztcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMubWF0cml4ID0gTWF0cml4LmlkZW50aXR5KCkudHJhbnNsYXRlKDAsIDApLnJvdGF0ZSgwKS5zY2FsZSgxLCAxKTtcclxuICAgICAgICB0aGlzLl9wb3NpdGlvbiA9IGNyZWF0ZVBvc1ZpZXcodGhpcy5tYXRyaXgpO1xyXG4gICAgICAgIHRoaXMuX3JvdGF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLl9zY2FsZSA9IGNyZWF0ZVNjYWxlVmlldyh0aGlzLm1hdHJpeCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIFtbQ29vcmRQbGFuZXxjb29yZGluYXRlIHBsYW5lfF1dIGZvciB0aGlzIHRyYW5zZm9ybSBmb3IgdGhlIGVudGl0eS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvb3JkUGxhbmUgPSBDb29yZFBsYW5lLldvcmxkO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSB6LWluZGV4IG9yZGVyaW5nIG9mIHRoZSBlbnRpdHksIGEgaGlnaGVyIHZhbHVlcyBhcmUgZHJhd24gb24gdG9wIG9mIGxvd2VyIHZhbHVlcy5cclxuICAgICAgICAgKiBGb3IgZXhhbXBsZSB6PTk5IHdvdWxkIGJlIGRyYXduIG9uIHRvcCBvZiB6PTAuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy56ID0gMDtcclxuICAgIH1cclxuICAgIF9yZWNhbGN1bGF0ZSgpIHtcclxuICAgICAgICB0aGlzLl9yb3RhdGlvbiA9IHRoaXMubWF0cml4LmdldFJvdGF0aW9uKCk7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldEdsb2JhbE1hdHJpeCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdHJpeDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRHbG9iYWxNYXRyaXgoKS5tdWx0bSh0aGlzLm1hdHJpeCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0R2xvYmFsVHJhbnNmb3JtKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBvczogdGhpcy5nbG9iYWxQb3MsXHJcbiAgICAgICAgICAgIHNjYWxlOiB0aGlzLmdsb2JhbFNjYWxlLFxyXG4gICAgICAgICAgICByb3RhdGlvbjogdGhpcy5nbG9iYWxSb3RhdGlvbixcclxuICAgICAgICAgICAgejogdGhpcy56LFxyXG4gICAgICAgICAgICBjb29yZFBsYW5lOiB0aGlzLmNvb3JkUGxhbmVcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhcmVudCgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzID09PSBudWxsIHx8IHRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoaXMub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXJlbnQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIGVudGl0eSBpbiB3b3JsZCBzcGFjZSBvciBpbiBzY3JlZW4gc3BhY2UgZGVwZW5kaW5nIG9uIHRoZSB0aGUgW1tDb29yZFBsYW5lfGNvb3JkaW5hdGUgcGxhbmVdXS5cclxuICAgICAqXHJcbiAgICAgKiBJZiBhIHBhcmVudCBlbnRpdHkgZXhpc3RzIGNvb3JkaW5hdGVzIGFyZSBsb2NhbCB0byB0aGUgcGFyZW50LlxyXG4gICAgICovXHJcbiAgICBnZXQgcG9zKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9kaXJ0eSkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWNhbGN1bGF0ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcG9zaXRpb247XHJcbiAgICB9XHJcbiAgICBzZXQgcG9zKHZhbCkge1xyXG4gICAgICAgIHRoaXMubWF0cml4LnNldFBvc2l0aW9uKHZhbC54LCB2YWwueSk7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLy8gRGlydHkgZmxhZyBjaGVjayB1cCB0aGUgY2hhaW5cclxuICAgIGdldCBkaXJ0eSgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhcmVudCkge1xyXG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcclxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudC5kaXJ0eSB8fCB0aGlzLl9kaXJ0eTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcnR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCB3b3JsZCBwb3NpdGlvbiBjYWxjdWxhdGVkXHJcbiAgICAgKi9cclxuICAgIGdldCBnbG9iYWxQb3MoKSB7XHJcbiAgICAgICAgY29uc3Qgc291cmNlID0gdGhpcy5nZXRHbG9iYWxNYXRyaXgoKTtcclxuICAgICAgICByZXR1cm4gbmV3IFZlY3RvclZpZXcoe1xyXG4gICAgICAgICAgICBnZXRYOiAoKSA9PiBzb3VyY2UuZGF0YVtNYXRyaXhMb2NhdGlvbnMuWF0sXHJcbiAgICAgICAgICAgIGdldFk6ICgpID0+IHNvdXJjZS5kYXRhW01hdHJpeExvY2F0aW9ucy5ZXSxcclxuICAgICAgICAgICAgc2V0WDogKHgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtuZXdYXSA9IChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0R2xvYmFsTWF0cml4KCkuZ2V0QWZmaW5lSW52ZXJzZSgpLm11bHR2KFt4LCBzb3VyY2UuZGF0YVtNYXRyaXhMb2NhdGlvbnMuWV1dKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeC5kYXRhW01hdHJpeExvY2F0aW9ucy5YXSA9IG5ld1g7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeC5kYXRhW01hdHJpeExvY2F0aW9ucy5YXSA9IHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHNldFk6ICh5KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBbLCBuZXdZXSA9IChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0R2xvYmFsTWF0cml4KCkuZ2V0QWZmaW5lSW52ZXJzZSgpLm11bHR2KFtzb3VyY2UuZGF0YVtNYXRyaXhMb2NhdGlvbnMuWF0sIHldKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeC5kYXRhW01hdHJpeExvY2F0aW9ucy5ZXSA9IG5ld1k7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdHJpeC5kYXRhW01hdHJpeExvY2F0aW9ucy5ZXSA9IHk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNldCBnbG9iYWxQb3ModmFsKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50VHJhbnNmb3JtID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKCFwYXJlbnRUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnBvcyA9IHBhcmVudFRyYW5zZm9ybS5nZXRHbG9iYWxNYXRyaXgoKS5nZXRBZmZpbmVJbnZlcnNlKCkubXVsdHYodmFsKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSByb3RhdGlvbiBvZiB0aGUgZW50aXR5IGluIHJhZGlhbnMuIEZvciBleGFtcGxlIGBNYXRoLlBJYCByYWRpYW5zIGlzIHRoZSBzYW1lIGFzIDE4MCBkZWdyZWVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgcm90YXRpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlY2FsY3VsYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb3RhdGlvbjtcclxuICAgIH1cclxuICAgIHNldCByb3RhdGlvbih2YWwpIHtcclxuICAgICAgICB0aGlzLm1hdHJpeC5zZXRSb3RhdGlvbih2YWwpO1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldCBnbG9iYWxSb3RhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgoKS5nZXRSb3RhdGlvbigpO1xyXG4gICAgfVxyXG4gICAgc2V0IGdsb2JhbFJvdGF0aW9uKHZhbCkge1xyXG4gICAgICAgIGNvbnN0IHBhcmVudFRyYW5zZm9ybSA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIGlmICghcGFyZW50VHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIHRoaXMucm90YXRpb24gPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJvdGF0aW9uID0gdmFsIC0gcGFyZW50VHJhbnNmb3JtLmdsb2JhbFJvdGF0aW9uO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHNjYWxlIG9mIHRoZSBlbnRpdHkuXHJcbiAgICAgKi9cclxuICAgIGdldCBzY2FsZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fcmVjYWxjdWxhdGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjYWxlO1xyXG4gICAgfVxyXG4gICAgc2V0IHNjYWxlKHZhbCkge1xyXG4gICAgICAgIHRoaXMubWF0cml4LnNldFNjYWxlKHZhbCk7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGdsb2JhbFNjYWxlKCkge1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZ2V0R2xvYmFsTWF0cml4KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3JWaWV3KHtcclxuICAgICAgICAgICAgZ2V0WDogKCkgPT4gc291cmNlLmdldFNjYWxlWCgpLFxyXG4gICAgICAgICAgICBnZXRZOiAoKSA9PiBzb3VyY2UuZ2V0U2NhbGVZKCksXHJcbiAgICAgICAgICAgIHNldFg6ICh4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBnbG9iYWxTY2FsZVggPSB0aGlzLnBhcmVudC5nbG9iYWxTY2FsZS54O1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0cml4LnNldFNjYWxlWCh4IC8gZ2xvYmFsU2NhbGVYKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWF0cml4LnNldFNjYWxlWCh4KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2V0WTogKHkpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNjYWxlWSA9IHRoaXMucGFyZW50Lmdsb2JhbFNjYWxlLnk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRyaXguc2V0U2NhbGVZKHkgLyBnbG9iYWxTY2FsZVkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXRyaXguc2V0U2NhbGVZKHkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZXQgZ2xvYmFsU2NhbGUodmFsKSB7XHJcbiAgICAgICAgY29uc3QgcGFyZW50VHJhbnNmb3JtID0gdGhpcy5wYXJlbnQ7XHJcbiAgICAgICAgaWYgKCFwYXJlbnRUcmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgdGhpcy5zY2FsZSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2NhbGUgPSB2ZWModmFsLnggLyBwYXJlbnRUcmFuc2Zvcm0uZ2xvYmFsU2NhbGUueCwgdmFsLnkgLyBwYXJlbnRUcmFuc2Zvcm0uZ2xvYmFsU2NhbGUueSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSB0aGUgdHJhbnNmb3JtIHRvIGEgcG9pbnRcclxuICAgICAqIEBwYXJhbSBwb2ludFxyXG4gICAgICovXHJcbiAgICBhcHBseShwb2ludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1hdHJpeC5tdWx0dihwb2ludCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGx5IHRoZSBpbnZlcnNlIHRyYW5zZm9ybSB0byBhIHBvaW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgYXBwbHlJbnZlcnNlKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubWF0cml4LmdldEFmZmluZUludmVyc2UoKS5tdWx0dihwb2ludCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FbnRpdHlDb21wb25lbnRTeXN0ZW0vQ29tcG9uZW50cy9Nb3Rpb25Db21wb25lbnQudHNcblxyXG5cclxuY2xhc3MgTW90aW9uQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4Lm1vdGlvbic7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHZlbG9jaXR5IG9mIGFuIGVudGl0eSBpbiBwaXhlbHMgcGVyIHNlY29uZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmVsID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFjY2VsZXJhdGlvbiBvZiBlbnRpdHkgaW4gcGl4ZWxzIHBlciBzZWNvbmReMlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWNjID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHNjYWxlIHJhdGUgb2YgY2hhbmdlIGluIHNjYWxlIHVuaXRzIHBlciBzZWNvbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnNjYWxlRmFjdG9yID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFuZ3VsYXIgdmVsb2NpdHkgd2hpY2ggaXMgaG93IHF1aWNrbHkgdGhlIGVudGl0eSBpcyByb3RhdGluZyBpbiByYWRpYW5zIHBlciBzZWNvbmRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiB0b3JxdWUgYXBwbGllZCB0byB0aGUgZW50aXR5LCBhbmd1bGFyIGFjY2VsZXJhdGlvbiBpcyB0b3JxdWUgKiBpbmVydGlhXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50b3JxdWUgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZXJpdGEgY2FuIGJlIHRob3VnaHQgb2YgYXMgdGhlIHJlc2lzdGFuY2UgdG8gbW90aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pbmVydGlhID0gMTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Hcm91cC9Db2xsaXNpb25Hcm91cC50c1xuLyoqXHJcbiAqIENvbGxpc2lvbkdyb3VwcyBpbmRpY2F0ZSBsaWtlIG1lbWJlcnMgdGhhdCBkbyBub3QgY29sbGlkZSB3aXRoIGVhY2ggb3RoZXIuIFVzZSBbW0NvbGxpc2lvbkdyb3VwTWFuYWdlcl1dIHRvIGNyZWF0ZSBbW0NvbGxpc2lvbkdyb3VwXV1zXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlOlxyXG4gKlxyXG4gKiBQbGF5ZXJzIGhhdmUgY29sbGlzaW9uIGdyb3VwIFwicGxheWVyXCJcclxuICpcclxuICogIVtQbGF5ZXIgQ29sbGlzaW9uIEdyb3VwXSgvYXNzZXRzL2ltYWdlcy9kb2NzL0NvbGxpc2lvbkdyb3Vwc1BsYXllci5wbmcpXHJcbiAqXHJcbiAqIEVuZW1pZXMgaGF2ZSBjb2xsaXNpb24gZ3JvdXAgXCJlbmVteVwiXHJcbiAqXHJcbiAqICFbRW5lbXkgQ29sbGlzaW9uIEdyb3VwXSgvYXNzZXRzL2ltYWdlcy9kb2NzL0NvbGxpc2lvbkdyb3Vwc0VuZW15LnBuZylcclxuICpcclxuICogQmxvY2tzIGhhdmUgY29sbGlzaW9uIGdyb3VwIFwiZ3JvdW5kXCJcclxuICpcclxuICogIVtHcm91bmQgY29sbGlzaW9uIGdyb3VwXSgvYXNzZXRzL2ltYWdlcy9kb2NzL0NvbGxpc2lvbkdyb3Vwc0dyb3VuZC5wbmcpXHJcbiAqXHJcbiAqIFBsYXllcnMgZG9uJ3QgY29sbGlkZSB3aXRoIGVhY2ggb3RoZXIsIGJ1dCBlbmVtaWVzIGFuZCBibG9ja3MuIExpa2V3aXNlLCBlbmVtaWVzIGRvbid0IGNvbGxpZGUgd2l0aCBlYWNoIG90aGVyIGJ1dCBjb2xsaWRlXHJcbiAqIHdpdGggcGxheWVycyBhbmQgYmxvY2tzLlxyXG4gKlxyXG4gKiBUaGlzIGlzIGRvbmUgd2l0aCBiaXRtYXNraW5nLCBzZWUgdGhlIGZvbGxvd2luZyBwc2V1ZG8tY29kZVxyXG4gKlxyXG4gKiBQbGF5ZXJHcm91cCA9IGAwYjAwMWBcclxuICogUGxheWVyR3JvdXBNYXNrID0gYDBiMTEwYFxyXG4gKlxyXG4gKiBFbmVteUdyb3VwID0gYDBiMDEwYFxyXG4gKiBFbmVteUdyb3VwTWFzayA9IGAwYjEwMWBcclxuICpcclxuICogQmxvY2tHcm91cCA9IGAwYjEwMGBcclxuICogQmxvY2tHcm91cE1hc2sgPSBgMGIwMTFgXHJcbiAqXHJcbiAqIFNob3VsZCBQbGF5ZXJzIGNvbGxpZGU/IE5vIGJlY2F1c2UgdGhlIGJpdHdpc2UgbWFzayBldmFsdWF0ZXMgdG8gMFxyXG4gKiBgKHBsYXllcjEuZ3JvdXAgJiBwbGF5ZXIyLm1hc2spID09PSAwYFxyXG4gKiBgKDBiMDAxICYgMGIxMTApID09PSAwYFxyXG4gKlxyXG4gKiBTaG91bGQgUGxheWVycyBhbmQgRW5lbWllcyBjb2xsaWRlPyBZZXMgYmVjYXVzZSB0aGUgYml0d2lzZSBtYXNrIGlzIG5vbi16ZXJvXHJcbiAqIGAocGxheWVyMS5ncm91cCAmIGVuZW15MS5tYXNrKSA9PT0gMWBcclxuICogYCgwYjAwMSAmIDBiMTAxKSA9PT0gMWBcclxuICpcclxuICogU2hvdWxkIFBsYXllcnMgYW5kIEJsb2NrcyBjb2xsaWRlPyBZZXMgYmVjYXVzZSB0aGUgYml0d2lzZSBtYXNrIGlzIG5vbi16ZXJvXHJcbiAqIGAocGxheWVyMS5ncm91cCAmIGJsb2NrczEubWFzaykgPT09IDFgXHJcbiAqIGAoMGIwMDEgJiAwYjAxMSkgPT09IDFgXHJcbiAqL1xyXG5jbGFzcyBDb2xsaXNpb25Hcm91cCB7XHJcbiAgICAvKipcclxuICAgICAqIFNUT1AhISoqIEl0IGlzIHByZWZlcnJlZCB0aGF0IFtbQ29sbGlzaW9uR3JvdXBNYW5hZ2VyLmNyZWF0ZV1dIGlzIHVzZWQgdG8gY3JlYXRlIGNvbGxpc2lvbiBncm91cHNcclxuICAgICAqICB1bmxlc3MgeW91IGtub3cgaG93IHRvIGNvbnN0cnVjdCB0aGUgcHJvcGVyIGJpdG1hc2tzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9pc3N1ZXMvMTA5MSBmb3IgbW9yZSBpbmZvLlxyXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgY29sbGlzaW9uIGdyb3VwXHJcbiAgICAgKiBAcGFyYW0gY2F0ZWdvcnkgMzIgYml0IGNhdGVnb3J5IGZvciB0aGUgZ3JvdXAsIHNob3VsZCBiZSBhIHVuaXF1ZSBwb3dlciBvZiAyLiBGb3IgZXhhbXBsZSBgMGIwMDFgIG9yIGAwYjAxMGBcclxuICAgICAqIEBwYXJhbSBtYXNrIDMyIGJpdCBtYXNrIG9mIGNhdGVnb3J5LCBvciBgfmNhdGVnb3J5YCBnZW5lcmFsbHkuIEZvciBhIGNhdGVnb3J5IG9mIGAwYjAwMWAsIHRoZSBtYXNrIHdvdWxkIGJlIGAwYjExMGBcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IobmFtZSwgY2F0ZWdvcnksIG1hc2spIHtcclxuICAgICAgICB0aGlzLl9uYW1lID0gbmFtZTtcclxuICAgICAgICB0aGlzLl9jYXRlZ29yeSA9IGNhdGVnb3J5O1xyXG4gICAgICAgIHRoaXMuX21hc2sgPSBtYXNrO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIG5hbWUgb2YgdGhlIGNvbGxpc2lvbiBncm91cFxyXG4gICAgICovXHJcbiAgICBnZXQgbmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbmFtZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjYXRlZ29yeSBvZiB0aGUgY29sbGlzaW9uIGdyb3VwLCBhIDMyIGJpdCBudW1iZXIgd2hpY2ggc2hvdWxkIGJlIGEgdW5pcXVlIHBvd2VyIG9mIDJcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhdGVnb3J5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYXRlZ29yeTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtYXNrIGZvciB0aGlzIGNvbGxpc2lvbiBncm91cFxyXG4gICAgICovXHJcbiAgICBnZXQgbWFzaygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWFzaztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRXZhbHVhdGVzIHdoZXRoZXIgMiBjb2xsaXNpb24gZ3JvdXBzIGNhbiBjb2xsaWRlXHJcbiAgICAgKiBAcGFyYW0gb3RoZXIgIENvbGxpc2lvbkdyb3VwXHJcbiAgICAgKi9cclxuICAgIGNhbkNvbGxpZGUob3RoZXIpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuY2F0ZWdvcnkgJiBvdGhlci5tYXNrKSAhPT0gMCAmJiAob3RoZXIuY2F0ZWdvcnkgJiB0aGlzLm1hc2spICE9PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZlcnRzIHRoZSBjb2xsaXNpb24gZ3JvdXAuIEZvciBleGFtcGxlLCBpZiBiZWZvcmUgdGhlIGdyb3VwIHNwZWNpZmllZCBcInBsYXllcnNcIixcclxuICAgICAqIGludmVydGluZyB3b3VsZCBzcGVjaWZ5IGFsbCBncm91cHMgZXhjZXB0IHBsYXllcnNcclxuICAgICAqIEByZXR1cm5zIENvbGxpc2lvbkdyb3VwXHJcbiAgICAgKi9cclxuICAgIGludmVydCgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENvbGxpc2lvbkdyb3VwKCd+KCcgKyB0aGlzLm5hbWUgKyAnKScsIH50aGlzLmNhdGVnb3J5LCB+dGhpcy5tYXNrKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29tYmluZSBjb2xsaXNpb24gZ3JvdXBzIHdpdGggZWFjaCBvdGhlci4gVGhlIG5ldyBncm91cCBpbmNsdWRlcyBhbGwgb2YgdGhlIHByZXZpb3VzIGdyb3Vwcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29sbGlzaW9uR3JvdXBzXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBzdGF0aWMgY29tYmluZShjb2xsaXNpb25Hcm91cHMpIHtcclxuICAgICAgICBjb25zdCBjb21iaW5lZE5hbWUgPSBjb2xsaXNpb25Hcm91cHMubWFwKChjKSA9PiBjLm5hbWUpLmpvaW4oJysnKTtcclxuICAgICAgICBjb25zdCBjb21iaW5lZENhdGVnb3J5ID0gY29sbGlzaW9uR3JvdXBzLnJlZHVjZSgoY3VycmVudCwgZykgPT4gZy5jYXRlZ29yeSB8IGN1cnJlbnQsIDBiMCk7XHJcbiAgICAgICAgY29uc3QgY29tYmluZWRNYXNrID0gfmNvbWJpbmVkQ2F0ZWdvcnk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDb2xsaXNpb25Hcm91cChjb21iaW5lZE5hbWUsIGNvbWJpbmVkQ2F0ZWdvcnksIGNvbWJpbmVkTWFzayk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBjb2xsaXNpb24gZ3JvdXAgdGhhdCBjb2xsaWRlcyB3aXRoIHRoZSBsaXN0ZWQgZ3JvdXBzXHJcbiAgICAgKiBAcGFyYW0gY29sbGlzaW9uR3JvdXBzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjb2xsaWRlc1dpdGgoY29sbGlzaW9uR3JvdXBzKSB7XHJcbiAgICAgICAgcmV0dXJuIENvbGxpc2lvbkdyb3VwLmNvbWJpbmUoY29sbGlzaW9uR3JvdXBzKS5pbnZlcnQoKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIGBBbGxgIFtbQ29sbGlzaW9uR3JvdXBdXSBpcyBhIHNwZWNpYWwgZ3JvdXAgdGhhdCBjb2xsaWRlcyB3aXRoIGFsbCBvdGhlciBncm91cHMgaW5jbHVkaW5nIGl0c2VsZixcclxuICogaXQgaXMgdGhlIGRlZmF1bHQgY29sbGlzaW9uIGdyb3VwIG9uIGNvbGxpZGVycy5cclxuICovXHJcbkNvbGxpc2lvbkdyb3VwLkFsbCA9IG5ldyBDb2xsaXNpb25Hcm91cCgnQ29sbGlkZSB3aXRoIGFsbCBncm91cHMnLCAtMSwgLTEpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvT2JzZXJ2YWJsZS50c1xuLyoqXHJcbiAqIFNpbXBsZSBPYnNlcnZhYmxlIGltcGxlbWVuYXRpb25cclxuICogQHRlbXBsYXRlIFQgaXMgdGhlIHR5cGVzY3JpcHQgVHlwZSB0aGF0IGRlZmluZXMgdGhlIGRhdGEgYmVpbmcgb2JzZXJ2ZWRcclxuICovXHJcbmNsYXNzIE9ic2VydmFibGUge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbXTtcclxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVnaXN0ZXIgYW4gb2JzZXJ2ZXIgdG8gbGlzdGVuIHRvIHRoaXMgb2JzZXJ2YWJsZVxyXG4gICAgICogQHBhcmFtIG9ic2VydmVyXHJcbiAgICAgKi9cclxuICAgIHJlZ2lzdGVyKG9ic2VydmVyKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gbGlzdGVuIHRvIHRoaXMgb2JzZXJ2YWJsZVxyXG4gICAgICogQHBhcmFtIGZ1bmNcclxuICAgICAqL1xyXG4gICAgc3Vic2NyaWJlKGZ1bmMpIHtcclxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChmdW5jKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFuIG9ic2VydmVyIGZyb20gdGhlIG9ic2VydmFibGVcclxuICAgICAqIEBwYXJhbSBvYnNlcnZlclxyXG4gICAgICovXHJcbiAgICB1bnJlZ2lzdGVyKG9ic2VydmVyKSB7XHJcbiAgICAgICAgY29uc3QgaSA9IHRoaXMub2JzZXJ2ZXJzLmluZGV4T2Yob2JzZXJ2ZXIpO1xyXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVycy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYSBjYWxsYmFjayB0aGF0IGlzIGxpc3RlbmluZyB0byB0aGlzIG9ic2VydmFibGVcclxuICAgICAqIEBwYXJhbSBmdW5jXHJcbiAgICAgKi9cclxuICAgIHVuc3Vic2NyaWJlKGZ1bmMpIHtcclxuICAgICAgICBjb25zdCBpID0gdGhpcy5zdWJzY3JpcHRpb25zLmluZGV4T2YoZnVuYyk7XHJcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBCcm9hZGNhc3RzIGEgbWVzc2FnZSB0byBhbGwgb2JzZXJ2ZXJzIGFuZCBjYWxsYmFja3NcclxuICAgICAqIEBwYXJhbSBtZXNzYWdlXHJcbiAgICAgKi9cclxuICAgIG5vdGlmeUFsbChtZXNzYWdlKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMuZm9yRWFjaCgobykgPT4gby5ub3RpZnkobWVzc2FnZSkpO1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5mb3JFYWNoKGNiID0+IGNiKG1lc3NhZ2UpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgb2JzZXJ2ZXJzIGFuZCBjYWxsYmFja3NcclxuICAgICAqL1xyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoID0gMDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9EZXRlY3Rpb24vUGFpci50c1xuXHJcblxyXG4vKipcclxuICogTW9kZWxzIGEgcG90ZW50aWFsIGNvbGxpc2lvbiBiZXR3ZWVuIDIgY29sbGlkZXJzXHJcbiAqL1xyXG5jbGFzcyBQYWlyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNvbGxpZGVyQSwgY29sbGlkZXJCKSB7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlckEgPSBjb2xsaWRlckE7XHJcbiAgICAgICAgdGhpcy5jb2xsaWRlckIgPSBjb2xsaWRlckI7XHJcbiAgICAgICAgdGhpcy5pZCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5pZCA9IFBhaXIuY2FsY3VsYXRlUGFpckhhc2goY29sbGlkZXJBLmlkLCBjb2xsaWRlckIuaWQpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNhbkNvbGxpZGUoY29sbGlkZXJBLCBjb2xsaWRlckIpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IGJvZHlBID0gKF9hID0gY29sbGlkZXJBID09PSBudWxsIHx8IGNvbGxpZGVyQSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sbGlkZXJBLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgIGNvbnN0IGJvZHlCID0gKF9iID0gY29sbGlkZXJCID09PSBudWxsIHx8IGNvbGxpZGVyQiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgIC8vIEJvZHkncyBuZWVkZWQgZm9yIGNvbGxpc2lvbiBpbiB0aGUgY3VycmVudCBzdGF0ZVxyXG4gICAgICAgIC8vIFRPRE8gY2FuIHdlIGNvbGxpZGUgd2l0aG91dCBhIGJvZHk/XHJcbiAgICAgICAgaWYgKCFib2R5QSB8fCAhYm9keUIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBib3RoIGFyZSBpbiB0aGUgc2FtZSBjb2xsaXNpb24gZ3JvdXAgc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgIGlmICghYm9keUEuZ3JvdXAuY2FuQ29sbGlkZShib2R5Qi5ncm91cCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBpZiBib3RoIGFyZSBmaXhlZCBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuRml4ZWQgJiYgYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5GaXhlZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlmIHRoZSBlaXRoZXIgaXMgcHJldmVudCBjb2xsaXNpb24gc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgIGlmIChib2R5Qi5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb24gfHwgYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgZWl0aGVyIGlzIGRlYWQgc2hvcnQgY2lyY3VpdFxyXG4gICAgICAgIGlmICghYm9keUEuYWN0aXZlIHx8ICFib2R5Qi5hY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBwb3NzaWJsZSBmb3IgdGhlIHBhaXJzIHRvIGNvbGxpZGVcclxuICAgICAqL1xyXG4gICAgZ2V0IGNhbkNvbGxpZGUoKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJBID0gdGhpcy5jb2xsaWRlckE7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJCID0gdGhpcy5jb2xsaWRlckI7XHJcbiAgICAgICAgcmV0dXJuIFBhaXIuY2FuQ29sbGlkZShjb2xsaWRlckEsIGNvbGxpZGVyQik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdGhlIGNvbGxpc2lvbiBpbnRlcnNlY3Rpb24gbG9naWMgb24gdGhlIG1lbWJlcnMgb2YgdGhpcyBwYWlyXHJcbiAgICAgKi9cclxuICAgIGNvbGxpZGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGlkZXJBLmNvbGxpZGUodGhpcy5jb2xsaWRlckIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVjayBpZiB0aGUgY29sbGlkZXIgaXMgcGFydCBvZiB0aGUgcGFpclxyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBoYXNDb2xsaWRlcihjb2xsaWRlcikge1xyXG4gICAgICAgIHJldHVybiBjb2xsaWRlciA9PT0gdGhpcy5jb2xsaWRlckEgfHwgY29sbGlkZXIgPT09IHRoaXMuY29sbGlkZXJCO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB1bmlxdWUgcGFpciBoYXNoIGlkIGZvciB0aGlzIGNvbGxpc2lvbiBwYWlyIChvd25pbmcgaWQpXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBjYWxjdWxhdGVQYWlySGFzaChpZEEsIGlkQikge1xyXG4gICAgICAgIGlmIChpZEEudmFsdWUgPCBpZEIudmFsdWUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGAjJHtpZEEudmFsdWV9KyR7aWRCLnZhbHVlfWA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gYCMke2lkQi52YWx1ZX0rJHtpZEEudmFsdWV9YDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL3Byb2plY3Rpb24udHNcbi8qKlxyXG4gKiBBIDEgZGltZW5zaW9uYWwgcHJvamVjdGlvbiBvbiBhbiBheGlzLCB1c2VkIHRvIHRlc3Qgb3ZlcmxhcHNcclxuICovXHJcbmNsYXNzIFByb2plY3Rpb24ge1xyXG4gICAgY29uc3RydWN0b3IobWluLCBtYXgpIHtcclxuICAgICAgICB0aGlzLm1pbiA9IG1pbjtcclxuICAgICAgICB0aGlzLm1heCA9IG1heDtcclxuICAgIH1cclxuICAgIG92ZXJsYXBzKHByb2plY3Rpb24pIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYXggPiBwcm9qZWN0aW9uLm1pbiAmJiBwcm9qZWN0aW9uLm1heCA+IHRoaXMubWluO1xyXG4gICAgfVxyXG4gICAgZ2V0T3ZlcmxhcChwcm9qZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKHRoaXMub3ZlcmxhcHMocHJvamVjdGlvbikpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMubWF4ID4gcHJvamVjdGlvbi5tYXgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBwcm9qZWN0aW9uLm1heCAtIHRoaXMubWluO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWF4IC0gcHJvamVjdGlvbi5taW47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vRGV0ZWN0aW9uL0R5bmFtaWNUcmVlLnRzXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBEeW5hbWljIFRyZWUgTm9kZSB1c2VkIGZvciB0cmFja2luZyBib3VuZHMgd2l0aGluIHRoZSB0cmVlXHJcbiAqL1xyXG5jbGFzcyBUcmVlTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQpIHtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ib3VuZHMgPSBuZXcgQm91bmRpbmdCb3goKTtcclxuICAgICAgICB0aGlzLmxlZnQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMucmlnaHQgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gMDtcclxuICAgIH1cclxuICAgIGlzTGVhZigpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMubGVmdCAmJiAhdGhpcy5yaWdodDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIER5bmFtaWNUcmVlcyBwcm92aWRlcyBhIHNwYXRpYWwgcGFydGl0aW9uaW5nIGRhdGEgc3RydWN0dXJlIGZvciBxdWlja2x5IHF1ZXJ5aW5nIGZvciBvdmVybGFwcGluZyBib3VuZGluZyBib3hlcyBmb3JcclxuICogYWxsIHRyYWNrZWQgYm9kaWVzLiBUaGUgd29yc3QgY2FzZSBwZXJmb3JtYW5jZSBvZiB0aGlzIGlzIE8obipsb2cobikpIHdoZXJlIG4gaXMgdGhlIG51bWJlciBvZiBib2RpZXMgaW4gdGhlIHRyZWUuXHJcbiAqXHJcbiAqIEludGVybmFsbHkgdGhlIGJvdW5kaW5nIGJveGVzIGFyZSBvcmdhbml6ZWQgYXMgYSBiYWxhbmNlZCBiaW5hcnkgdHJlZSBvZiBib3VuZGluZyBib3hlcywgd2hlcmUgdGhlIGxlYWYgbm9kZXMgYXJlIHRyYWNrZWQgYm9kaWVzLlxyXG4gKiBFdmVyeSBub24tbGVhZiBub2RlIGlzIGEgYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgY2hpbGQgYm91bmRpbmcgYm94ZXMuXHJcbiAqL1xyXG5jbGFzcyBEeW5hbWljVHJlZSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3b3JsZEJvdW5kcyA9IG5ldyBCb3VuZGluZ0JveCgtTnVtYmVyLk1BWF9WQUxVRSwgLU51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUUpKSB7XHJcbiAgICAgICAgdGhpcy53b3JsZEJvdW5kcyA9IHdvcmxkQm91bmRzO1xyXG4gICAgICAgIHRoaXMucm9vdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5ub2RlcyA9IHt9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIGEgbm9kZSBpbnRvIHRoZSBkeW5hbWljIHRyZWVcclxuICAgICAqL1xyXG4gICAgX2luc2VydChsZWFmKSB7XHJcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG5vZGVzIGluIHRoZSB0cmVlLCBtYWtlIHRoaXMgdGhlIHJvb3QgbGVhZlxyXG4gICAgICAgIGlmICh0aGlzLnJvb3QgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgdGhpcy5yb290ID0gbGVhZjtcclxuICAgICAgICAgICAgdGhpcy5yb290LnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gU2VhcmNoIHRoZSB0cmVlIGZvciBhIG5vZGUgdGhhdCBpcyBub3QgYSBsZWFmIGFuZCBmaW5kIHRoZSBiZXN0IHBsYWNlIHRvIGluc2VydFxyXG4gICAgICAgIGNvbnN0IGxlYWZBQUJCID0gbGVhZi5ib3VuZHM7XHJcbiAgICAgICAgbGV0IGN1cnJlbnRSb290ID0gdGhpcy5yb290O1xyXG4gICAgICAgIHdoaWxlICghY3VycmVudFJvb3QuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGN1cnJlbnRSb290LmxlZnQ7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gY3VycmVudFJvb3QucmlnaHQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGFyZWEgPSBjdXJyZW50Um9vdC5ib3VuZHMuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkQUFCQiA9IGN1cnJlbnRSb290LmJvdW5kcy5jb21iaW5lKGxlYWZBQUJCKTtcclxuICAgICAgICAgICAgY29uc3QgY29tYmluZWRBcmVhID0gY29tYmluZWRBQUJCLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgY29zdCBoZXVyaXN0aWMgZm9yIGNyZWF0aW5nIGEgbmV3IHBhcmVudCBhbmQgbGVhZlxyXG4gICAgICAgICAgICBjb25zdCBjb3N0ID0gMiAqIGNvbWJpbmVkQXJlYTtcclxuICAgICAgICAgICAgLy8gTWluaW11bSBjb3N0IG9mIHB1c2hpbmcgdGhlIGxlYWYgZG93biB0aGUgdHJlZVxyXG4gICAgICAgICAgICBjb25zdCBpbmhlcml0YW5jZUNvc3QgPSAyICogKGNvbWJpbmVkQXJlYSAtIGFyZWEpO1xyXG4gICAgICAgICAgICAvLyBDb3N0IG9mIGRlc2NlbmRpbmdcclxuICAgICAgICAgICAgbGV0IGxlZnRDb3N0ID0gMDtcclxuICAgICAgICAgICAgY29uc3QgbGVmdENvbWJpbmVkID0gbGVhZkFBQkIuY29tYmluZShsZWZ0LmJvdW5kcyk7XHJcbiAgICAgICAgICAgIGxldCBuZXdBcmVhO1xyXG4gICAgICAgICAgICBsZXQgb2xkQXJlYTtcclxuICAgICAgICAgICAgaWYgKGxlZnQuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgIGxlZnRDb3N0ID0gbGVmdENvbWJpbmVkLmdldFBlcmltZXRlcigpICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgb2xkQXJlYSA9IGxlZnQuYm91bmRzLmdldFBlcmltZXRlcigpO1xyXG4gICAgICAgICAgICAgICAgbmV3QXJlYSA9IGxlZnRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgIGxlZnRDb3N0ID0gbmV3QXJlYSAtIG9sZEFyZWEgKyBpbmhlcml0YW5jZUNvc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbGV0IHJpZ2h0Q29zdCA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0Q29tYmluZWQgPSBsZWFmQUFCQi5jb21iaW5lKHJpZ2h0LmJvdW5kcyk7XHJcbiAgICAgICAgICAgIGlmIChyaWdodC5pc0xlYWYoKSkge1xyXG4gICAgICAgICAgICAgICAgcmlnaHRDb3N0ID0gcmlnaHRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKSArIGluaGVyaXRhbmNlQ29zdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG9sZEFyZWEgPSByaWdodC5ib3VuZHMuZ2V0UGVyaW1ldGVyKCk7XHJcbiAgICAgICAgICAgICAgICBuZXdBcmVhID0gcmlnaHRDb21iaW5lZC5nZXRQZXJpbWV0ZXIoKTtcclxuICAgICAgICAgICAgICAgIHJpZ2h0Q29zdCA9IG5ld0FyZWEgLSBvbGRBcmVhICsgaW5oZXJpdGFuY2VDb3N0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGNvc3QgaXMgYWNjZXB0YWJsZVxyXG4gICAgICAgICAgICBpZiAoY29zdCA8IGxlZnRDb3N0ICYmIGNvc3QgPCByaWdodENvc3QpIHtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIERlc2NlbmQgdG8gdGhlIGRlcHRoc1xyXG4gICAgICAgICAgICBpZiAobGVmdENvc3QgPCByaWdodENvc3QpIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSb290ID0gbGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRSb290ID0gcmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBuZXcgcGFyZW50IG5vZGUgYW5kIGluc2VydCBpbnRvIHRoZSB0cmVlXHJcbiAgICAgICAgY29uc3Qgb2xkUGFyZW50ID0gY3VycmVudFJvb3QucGFyZW50O1xyXG4gICAgICAgIGNvbnN0IG5ld1BhcmVudCA9IG5ldyBUcmVlTm9kZShvbGRQYXJlbnQpO1xyXG4gICAgICAgIG5ld1BhcmVudC5ib3VuZHMgPSBsZWFmQUFCQi5jb21iaW5lKGN1cnJlbnRSb290LmJvdW5kcyk7XHJcbiAgICAgICAgbmV3UGFyZW50LmhlaWdodCA9IGN1cnJlbnRSb290LmhlaWdodCArIDE7XHJcbiAgICAgICAgaWYgKG9sZFBhcmVudCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAvLyBUaGUgc2libGluZyBub2RlIHdhcyBub3QgdGhlIHJvb3RcclxuICAgICAgICAgICAgaWYgKG9sZFBhcmVudC5sZWZ0ID09PSBjdXJyZW50Um9vdCkge1xyXG4gICAgICAgICAgICAgICAgb2xkUGFyZW50LmxlZnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBvbGRQYXJlbnQucmlnaHQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgbmV3UGFyZW50LmxlZnQgPSBjdXJyZW50Um9vdDtcclxuICAgICAgICAgICAgbmV3UGFyZW50LnJpZ2h0ID0gbGVhZjtcclxuICAgICAgICAgICAgY3VycmVudFJvb3QucGFyZW50ID0gbmV3UGFyZW50O1xyXG4gICAgICAgICAgICBsZWFmLnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFRoZSBzaWJsaW5nIG5vZGUgd2FzIHRoZSByb290XHJcbiAgICAgICAgICAgIG5ld1BhcmVudC5sZWZ0ID0gY3VycmVudFJvb3Q7XHJcbiAgICAgICAgICAgIG5ld1BhcmVudC5yaWdodCA9IGxlYWY7XHJcbiAgICAgICAgICAgIGN1cnJlbnRSb290LnBhcmVudCA9IG5ld1BhcmVudDtcclxuICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSBuZXdQYXJlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG5ld1BhcmVudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gV2FsayB1cCB0aGUgdHJlZSBmaXhpbmcgaGVpZ2h0cyBhbmQgQUFCQnNcclxuICAgICAgICBsZXQgY3VycmVudE5vZGUgPSBsZWFmLnBhcmVudDtcclxuICAgICAgICB3aGlsZSAoY3VycmVudE5vZGUpIHtcclxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLl9iYWxhbmNlKGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcmVudCBvZiBjdXJyZW50IGxlYWYgY2Fubm90IGhhdmUgYSBudWxsIGxlZnQgY2hpbGQnICsgY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudE5vZGUucmlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyZW50IG9mIGN1cnJlbnQgbGVhZiBjYW5ub3QgaGF2ZSBhIG51bGwgcmlnaHQgY2hpbGQnICsgY3VycmVudE5vZGUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLmhlaWdodCA9IDEgKyBNYXRoLm1heChjdXJyZW50Tm9kZS5sZWZ0LmhlaWdodCwgY3VycmVudE5vZGUucmlnaHQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzID0gY3VycmVudE5vZGUubGVmdC5ib3VuZHMuY29tYmluZShjdXJyZW50Tm9kZS5yaWdodC5ib3VuZHMpO1xyXG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBub2RlIGZyb20gdGhlIGR5bmFtaWMgdHJlZVxyXG4gICAgICovXHJcbiAgICBfcmVtb3ZlKGxlYWYpIHtcclxuICAgICAgICBpZiAobGVhZiA9PT0gdGhpcy5yb290KSB7XHJcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IG51bGw7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbGVhZi5wYXJlbnQ7XHJcbiAgICAgICAgY29uc3QgZ3JhbmRQYXJlbnQgPSBwYXJlbnQucGFyZW50O1xyXG4gICAgICAgIGxldCBzaWJsaW5nO1xyXG4gICAgICAgIGlmIChwYXJlbnQubGVmdCA9PT0gbGVhZikge1xyXG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50LnJpZ2h0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc2libGluZyA9IHBhcmVudC5sZWZ0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZ3JhbmRQYXJlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGdyYW5kUGFyZW50LmxlZnQgPT09IHBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgZ3JhbmRQYXJlbnQubGVmdCA9IHNpYmxpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBncmFuZFBhcmVudC5yaWdodCA9IHNpYmxpbmc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2libGluZy5wYXJlbnQgPSBncmFuZFBhcmVudDtcclxuICAgICAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gZ3JhbmRQYXJlbnQ7XHJcbiAgICAgICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSB0aGlzLl9iYWxhbmNlKGN1cnJlbnROb2RlKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmJvdW5kcyA9IGN1cnJlbnROb2RlLmxlZnQuYm91bmRzLmNvbWJpbmUoY3VycmVudE5vZGUucmlnaHQuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlLmhlaWdodCA9IDEgKyBNYXRoLm1heChjdXJyZW50Tm9kZS5sZWZ0LmhlaWdodCwgY3VycmVudE5vZGUucmlnaHQuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnJvb3QgPSBzaWJsaW5nO1xyXG4gICAgICAgICAgICBzaWJsaW5nLnBhcmVudCA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFja3MgYSBib2R5IGluIHRoZSBkeW5hbWljIHRyZWVcclxuICAgICAqL1xyXG4gICAgdHJhY2tDb2xsaWRlcihjb2xsaWRlcikge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJlZU5vZGUoKTtcclxuICAgICAgICBub2RlLmRhdGEgPSBjb2xsaWRlcjtcclxuICAgICAgICBub2RlLmJvdW5kcyA9IGNvbGxpZGVyLmJvdW5kcztcclxuICAgICAgICBub2RlLmJvdW5kcy5sZWZ0IC09IDI7XHJcbiAgICAgICAgbm9kZS5ib3VuZHMudG9wIC09IDI7XHJcbiAgICAgICAgbm9kZS5ib3VuZHMucmlnaHQgKz0gMjtcclxuICAgICAgICBub2RlLmJvdW5kcy5ib3R0b20gKz0gMjtcclxuICAgICAgICB0aGlzLm5vZGVzW2NvbGxpZGVyLmlkLnZhbHVlXSA9IG5vZGU7XHJcbiAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIHRoZSBkeW5hbWljIHRyZWUgZ2l2ZW4gdGhlIGN1cnJlbnQgYm91bmRzIG9mIGVhY2ggYm9keSBiZWluZyB0cmFja2VkXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZUNvbGxpZGVyKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVzW2NvbGxpZGVyLmlkLnZhbHVlXTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBiID0gY29sbGlkZXIuYm91bmRzO1xyXG4gICAgICAgIC8vIGlmIHRoZSBib2R5IGlzIG91dHNpZGUgdGhlIHdvcmxkIG5vIGxvbmdlciB1cGRhdGUgaXRcclxuICAgICAgICBpZiAoIXRoaXMud29ybGRCb3VuZHMuY29udGFpbnMoYikpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignQ29sbGlkZXIgd2l0aCBpZCAnICsgY29sbGlkZXIuaWQudmFsdWUgKyAnIGlzIG91dHNpZGUgdGhlIHdvcmxkIGJvdW5kcyBhbmQgd2lsbCBubyBsb25nZXIgYmUgdHJhY2tlZCBmb3IgcGh5c2ljcycpO1xyXG4gICAgICAgICAgICB0aGlzLnVudHJhY2tDb2xsaWRlcihjb2xsaWRlcik7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5vZGUuYm91bmRzLmNvbnRhaW5zKGIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcmVtb3ZlKG5vZGUpO1xyXG4gICAgICAgIGIubGVmdCAtPSBQaHlzaWNzLmJvdW5kc1BhZGRpbmc7XHJcbiAgICAgICAgYi50b3AgLT0gUGh5c2ljcy5ib3VuZHNQYWRkaW5nO1xyXG4gICAgICAgIGIucmlnaHQgKz0gUGh5c2ljcy5ib3VuZHNQYWRkaW5nO1xyXG4gICAgICAgIGIuYm90dG9tICs9IFBoeXNpY3MuYm91bmRzUGFkZGluZztcclxuICAgICAgICAvLyBUSElTIElTIENBVVNJTkcgVU5FQ0VTU0FSWSBDSEVDS1NcclxuICAgICAgICBpZiAoY29sbGlkZXIub3duZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgYm9keSA9IChfYSA9IGNvbGxpZGVyLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoYm9keSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbXVsdGR4ID0gKChib2R5LnZlbC54ICogMzIpIC8gMTAwMCkgKiBQaHlzaWNzLmR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbXVsdGR5ID0gKChib2R5LnZlbC55ICogMzIpIC8gMTAwMCkgKiBQaHlzaWNzLmR5bmFtaWNUcmVlVmVsb2NpdHlNdWx0aXBsaWVyO1xyXG4gICAgICAgICAgICAgICAgaWYgKG11bHRkeCA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBiLmxlZnQgKz0gbXVsdGR4O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYi5yaWdodCArPSBtdWx0ZHg7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobXVsdGR5IDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGIudG9wICs9IG11bHRkeTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGIuYm90dG9tICs9IG11bHRkeTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBub2RlLmJvdW5kcyA9IGI7XHJcbiAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUpO1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnRyYWNrcyBhIGJvZHkgZnJvbSB0aGUgZHluYW1pYyB0cmVlXHJcbiAgICAgKi9cclxuICAgIHVudHJhY2tDb2xsaWRlcihjb2xsaWRlcikge1xyXG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVzW2NvbGxpZGVyLmlkLnZhbHVlXTtcclxuICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZW1vdmUobm9kZSk7XHJcbiAgICAgICAgdGhpcy5ub2Rlc1tjb2xsaWRlci5pZC52YWx1ZV0gPSBudWxsO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLm5vZGVzW2NvbGxpZGVyLmlkLnZhbHVlXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQmFsYW5jZXMgdGhlIHRyZWUgYWJvdXQgYSBub2RlXHJcbiAgICAgKi9cclxuICAgIF9iYWxhbmNlKG5vZGUpIHtcclxuICAgICAgICBpZiAobm9kZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBiYWxhbmNlIGF0IG51bGwgbm9kZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobm9kZS5pc0xlYWYoKSB8fCBub2RlLmhlaWdodCA8IDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGxlZnQgPSBub2RlLmxlZnQ7XHJcbiAgICAgICAgY29uc3QgcmlnaHQgPSBub2RlLnJpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGEgPSBub2RlO1xyXG4gICAgICAgIGNvbnN0IGIgPSBsZWZ0O1xyXG4gICAgICAgIGNvbnN0IGMgPSByaWdodDtcclxuICAgICAgICBjb25zdCBkID0gbGVmdC5sZWZ0O1xyXG4gICAgICAgIGNvbnN0IGUgPSBsZWZ0LnJpZ2h0O1xyXG4gICAgICAgIGNvbnN0IGYgPSByaWdodC5sZWZ0O1xyXG4gICAgICAgIGNvbnN0IGcgPSByaWdodC5yaWdodDtcclxuICAgICAgICBjb25zdCBiYWxhbmNlID0gYy5oZWlnaHQgLSBiLmhlaWdodDtcclxuICAgICAgICAvLyBSb3RhdGUgYyBub2RlIHVwXHJcbiAgICAgICAgaWYgKGJhbGFuY2UgPiAxKSB7XHJcbiAgICAgICAgICAgIC8vIFN3YXAgdGhlIHJpZ2h0IG5vZGUgd2l0aCBpdCdzIHBhcmVudFxyXG4gICAgICAgICAgICBjLmxlZnQgPSBhO1xyXG4gICAgICAgICAgICBjLnBhcmVudCA9IGEucGFyZW50O1xyXG4gICAgICAgICAgICBhLnBhcmVudCA9IGM7XHJcbiAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBub2RlJ3Mgb2xkIHBhcmVudCBzaG91bGQgcG9pbnQgdG8gdGhlIHJpZ2h0IG5vZGVcclxuICAgICAgICAgICAgLy8gdGhpcyBpcyBtZWdhIGNvbmZ1c2luZ1xyXG4gICAgICAgICAgICBpZiAoYy5wYXJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjLnBhcmVudC5sZWZ0ID09PSBhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5wYXJlbnQubGVmdCA9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjLnBhcmVudC5yaWdodCA9IGM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnJvb3QgPSBjO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFJvdGF0ZVxyXG4gICAgICAgICAgICBpZiAoZi5oZWlnaHQgPiBnLmhlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgYy5yaWdodCA9IGY7XHJcbiAgICAgICAgICAgICAgICBhLnJpZ2h0ID0gZztcclxuICAgICAgICAgICAgICAgIGcucGFyZW50ID0gYTtcclxuICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYi5ib3VuZHMuY29tYmluZShnLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBjLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZi5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYi5oZWlnaHQsIGcuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGMuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBmLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjLnJpZ2h0ID0gZztcclxuICAgICAgICAgICAgICAgIGEucmlnaHQgPSBmO1xyXG4gICAgICAgICAgICAgICAgZi5wYXJlbnQgPSBhO1xyXG4gICAgICAgICAgICAgICAgYS5ib3VuZHMgPSBiLmJvdW5kcy5jb21iaW5lKGYuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGMuYm91bmRzID0gYS5ib3VuZHMuY29tYmluZShnLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBhLmhlaWdodCA9IDEgKyBNYXRoLm1heChiLmhlaWdodCwgZi5oZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgYy5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYS5oZWlnaHQsIGcuaGVpZ2h0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUm90YXRlIGxlZnQgbm9kZSB1cFxyXG4gICAgICAgIGlmIChiYWxhbmNlIDwgLTEpIHtcclxuICAgICAgICAgICAgLy8gc3dhcFxyXG4gICAgICAgICAgICBiLmxlZnQgPSBhO1xyXG4gICAgICAgICAgICBiLnBhcmVudCA9IGEucGFyZW50O1xyXG4gICAgICAgICAgICBhLnBhcmVudCA9IGI7XHJcbiAgICAgICAgICAgIC8vIG5vZGUncyBvbGQgcGFyZW50IHNob3VsZCBwb2ludCB0byBiXHJcbiAgICAgICAgICAgIGlmIChiLnBhcmVudCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKGIucGFyZW50LmxlZnQgPT09IGEpIHtcclxuICAgICAgICAgICAgICAgICAgICBiLnBhcmVudC5sZWZ0ID0gYjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChiLnBhcmVudC5yaWdodCAhPT0gYSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnRXJyb3Igcm90YXRpbmcgRHluYW1pYyBUcmVlJztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYi5wYXJlbnQucmlnaHQgPSBiO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yb290ID0gYjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyByb3RhdGVcclxuICAgICAgICAgICAgaWYgKGQuaGVpZ2h0ID4gZS5oZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGIucmlnaHQgPSBkO1xyXG4gICAgICAgICAgICAgICAgYS5sZWZ0ID0gZTtcclxuICAgICAgICAgICAgICAgIGUucGFyZW50ID0gYTtcclxuICAgICAgICAgICAgICAgIGEuYm91bmRzID0gYy5ib3VuZHMuY29tYmluZShlLmJvdW5kcyk7XHJcbiAgICAgICAgICAgICAgICBiLmJvdW5kcyA9IGEuYm91bmRzLmNvbWJpbmUoZC5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgYS5oZWlnaHQgPSAxICsgTWF0aC5tYXgoYy5oZWlnaHQsIGUuaGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIGIuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGEuaGVpZ2h0LCBkLmhlaWdodCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBiLnJpZ2h0ID0gZTtcclxuICAgICAgICAgICAgICAgIGEubGVmdCA9IGQ7XHJcbiAgICAgICAgICAgICAgICBkLnBhcmVudCA9IGE7XHJcbiAgICAgICAgICAgICAgICBhLmJvdW5kcyA9IGMuYm91bmRzLmNvbWJpbmUoZC5ib3VuZHMpO1xyXG4gICAgICAgICAgICAgICAgYi5ib3VuZHMgPSBhLmJvdW5kcy5jb21iaW5lKGUuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGEuaGVpZ2h0ID0gMSArIE1hdGgubWF4KGMuaGVpZ2h0LCBkLmhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICBiLmhlaWdodCA9IDEgKyBNYXRoLm1heChhLmhlaWdodCwgZS5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBiO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgaGVpZ2h0IG9mIHRoZSB0cmVlLCBzaG9ydGVyIHRyZWVzIGFyZSBiZXR0ZXIuIFBlcmZvcm1hbmNlIGRyb3BzIGFzIHRoZSB0cmVlIGdyb3dzXHJcbiAgICAgKi9cclxuICAgIGdldEhlaWdodCgpIHtcclxuICAgICAgICBpZiAodGhpcy5yb290ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5yb290LmhlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUXVlcmllcyB0aGUgRHluYW1pYyBBeGlzIEFsaWduZWQgVHJlZSBmb3IgYm9kaWVzIHRoYXQgY291bGQgYmUgY29sbGlkaW5nIHdpdGggdGhlIHByb3ZpZGVkIGJvZHkuXHJcbiAgICAgKlxyXG4gICAgICogSW4gdGhlIHF1ZXJ5IGNhbGxiYWNrLCBpdCB3aWxsIGJlIHBhc3NlZCBhIHBvdGVudGlhbCBjb2xsaWRlci4gUmV0dXJuaW5nIHRydWUgZnJvbSB0aGlzIGNhbGxiYWNrIGluZGljYXRlc1xyXG4gICAgICogdGhhdCB5b3UgYXJlIGNvbXBsZXRlIHdpdGggeW91ciBxdWVyeSBhbmQgeW91IGRvIG5vdCB3YW50IHRvIGNvbnRpbnVlLiBSZXR1cm5pbmcgZmFsc2Ugd2lsbCBjb250aW51ZSBzZWFyY2hpbmdcclxuICAgICAqIHRoZSB0cmVlIHVudGlsIGFsbCBwb3NzaWJsZSBjb2xsaWRlcnMgaGF2ZSBiZWVuIHJldHVybmVkLlxyXG4gICAgICovXHJcbiAgICBxdWVyeShjb2xsaWRlciwgY2FsbGJhY2spIHtcclxuICAgICAgICBjb25zdCBib3VuZHMgPSBjb2xsaWRlci5ib3VuZHM7XHJcbiAgICAgICAgY29uc3QgaGVscGVyID0gKGN1cnJlbnROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSAmJiBjdXJyZW50Tm9kZS5ib3VuZHMuaW50ZXJzZWN0KGJvdW5kcykpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5pc0xlYWYoKSAmJiBjdXJyZW50Tm9kZS5kYXRhICE9PSBjb2xsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKGNvbGxpZGVyLCBjdXJyZW50Tm9kZS5kYXRhKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpIHx8IGhlbHBlcihjdXJyZW50Tm9kZS5yaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgaGVscGVyKHRoaXMucm9vdCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFF1ZXJpZXMgdGhlIER5bmFtaWMgQXhpcyBBbGlnbmVkIFRyZWUgZm9yIGJvZGllcyB0aGF0IGNvdWxkIGJlIGludGVyc2VjdGluZy4gQnkgZGVmYXVsdCB0aGUgcmF5Y2FzdCBxdWVyeSB1c2VzIGFuIGluZmluaXRlbHlcclxuICAgICAqIGxvbmcgcmF5IHRvIHRlc3QgdGhlIHRyZWUgc3BlY2lmaWVkIGJ5IGBtYXhgLlxyXG4gICAgICpcclxuICAgICAqIEluIHRoZSBxdWVyeSBjYWxsYmFjaywgaXQgd2lsbCBiZSBwYXNzZWQgYSBwb3RlbnRpYWwgYm9keSB0aGF0IGludGVyc2VjdHMgd2l0aCB0aGUgcmF5Y2FzdC4gUmV0dXJuaW5nIHRydWUgZnJvbSB0aGlzXHJcbiAgICAgKiBjYWxsYmFjayBpbmRpY2F0ZXMgdGhhdCB5b3VyIGFyZSBjb21wbGV0ZSB3aXRoIHlvdXIgcXVlcnkgYW5kIGRvIG5vdCB3YW50IHRvIGNvbnRpbnVlLiBSZXR1cm4gZmFsc2Ugd2lsbCBjb250aW51ZSBzZWFyY2hpbmdcclxuICAgICAqIHRoZSB0cmVlIHVudGlsIGFsbCBwb3NzaWJsZSBib2RpZXMgdGhhdCB3b3VsZCBpbnRlcnNlY3Qgd2l0aCB0aGUgcmF5IGhhdmUgYmVlbiByZXR1cm5lZC5cclxuICAgICAqL1xyXG4gICAgcmF5Q2FzdFF1ZXJ5KHJheSwgbWF4ID0gSW5maW5pdHksIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgY29uc3QgaGVscGVyID0gKGN1cnJlbnROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSAmJiBjdXJyZW50Tm9kZS5ib3VuZHMucmF5Q2FzdChyYXksIG1heCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5pc0xlYWYoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjay5jYWxsKHJheSwgY3VycmVudE5vZGUuZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmF5IGhpdCBhIGxlYWYhIHJldHVybiB0aGUgYm9keVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyByYXkgaGl0IGJ1dCBub3QgYXQgYSBsZWFmLCByZWN1cnNlIGRlZXBlclxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWxwZXIoY3VycmVudE5vZGUubGVmdCkgfHwgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJheSBtaXNzZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGhlbHBlcih0aGlzLnJvb3QpO1xyXG4gICAgfVxyXG4gICAgZ2V0Tm9kZXMoKSB7XHJcbiAgICAgICAgY29uc3QgaGVscGVyID0gKGN1cnJlbnROb2RlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjdXJyZW50Tm9kZV0uY29uY2F0KGhlbHBlcihjdXJyZW50Tm9kZS5sZWZ0KSwgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBoZWxwZXIodGhpcy5yb290KTtcclxuICAgIH1cclxuICAgIGRlYnVnKGV4KSB7XHJcbiAgICAgICAgLy8gZHJhdyBhbGwgdGhlIG5vZGVzIGluIHRoZSBEeW5hbWljIFRyZWVcclxuICAgICAgICBjb25zdCBoZWxwZXIgPSAoY3VycmVudE5vZGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vZGUuaXNMZWFmKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZS5ib3VuZHMuZHJhdyhleCwgQ29sb3IuR3JlZW4pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUuYm91bmRzLmRyYXcoZXgsIENvbG9yLldoaXRlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Tm9kZS5sZWZ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKGN1cnJlbnROb2RlLmxlZnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLnJpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaGVscGVyKGN1cnJlbnROb2RlLnJpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaGVscGVyKHRoaXMucm9vdCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL3JheS50c1xuLyoqXHJcbiAqIEEgMkQgcmF5IHRoYXQgY2FuIGJlIGNhc3QgaW50byB0aGUgc2NlbmUgdG8gZG8gY29sbGlzaW9uIGRldGVjdGlvblxyXG4gKi9cclxuY2xhc3MgUmF5IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHBvcyBUaGUgc3RhcnRpbmcgcG9zaXRpb24gZm9yIHRoZSByYXlcclxuICAgICAqIEBwYXJhbSBkaXIgVGhlIHZlY3RvciBpbmRpY2F0aW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJheVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwb3MsIGRpcikge1xyXG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xyXG4gICAgICAgIHRoaXMuZGlyID0gZGlyLm5vcm1hbGl6ZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBhIHdoZXRoZXIgdGhpcyByYXkgaW50ZXJzZWN0cyB3aXRoIGEgbGluZSBzZWdtZW50LiBSZXR1cm5zIGEgbnVtYmVyIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAwIG9uIHN1Y2Nlc3MuXHJcbiAgICAgKiBUaGlzIG51bWJlciBpbmRpY2F0ZXMgdGhlIG1hdGhlbWF0aWNhbCBpbnRlcnNlY3Rpb24gdGltZS5cclxuICAgICAqIEBwYXJhbSBsaW5lICBUaGUgbGluZSB0byB0ZXN0XHJcbiAgICAgKi9cclxuICAgIGludGVyc2VjdChsaW5lKSB7XHJcbiAgICAgICAgY29uc3QgbnVtZXJhdG9yID0gbGluZS5iZWdpbi5zdWIodGhpcy5wb3MpO1xyXG4gICAgICAgIC8vIFRlc3QgaXMgbGluZSBhbmQgcmF5IGFyZSBwYXJhbGxlbCBhbmQgbm9uIGludGVyc2VjdGluZ1xyXG4gICAgICAgIGlmICh0aGlzLmRpci5jcm9zcyhsaW5lLmdldFNsb3BlKCkpID09PSAwICYmIG51bWVyYXRvci5jcm9zcyh0aGlzLmRpcikgIT09IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBMaW5lcyBhcmUgcGFyYWxsZWxcclxuICAgICAgICBjb25zdCBkaXZpc29yID0gdGhpcy5kaXIuY3Jvc3MobGluZS5nZXRTbG9wZSgpKTtcclxuICAgICAgICBpZiAoZGl2aXNvciA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gLTE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHQgPSBudW1lcmF0b3IuY3Jvc3MobGluZS5nZXRTbG9wZSgpKSAvIGRpdmlzb3I7XHJcbiAgICAgICAgaWYgKHQgPj0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCB1ID0gbnVtZXJhdG9yLmNyb3NzKHRoaXMuZGlyKSAvIGRpdmlzb3IgLyBsaW5lLmdldExlbmd0aCgpO1xyXG4gICAgICAgICAgICBpZiAodSA+PSAwICYmIHUgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIC0xO1xyXG4gICAgfVxyXG4gICAgaW50ZXJzZWN0UG9pbnQobGluZSkge1xyXG4gICAgICAgIGNvbnN0IHRpbWUgPSB0aGlzLmludGVyc2VjdChsaW5lKTtcclxuICAgICAgICBpZiAodGltZSA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmdldFBvaW50KHRpbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBwb2ludCBvZiBpbnRlcnNlY3Rpb24gZ2l2ZW4gdGhlIGludGVyc2VjdGlvbiB0aW1lXHJcbiAgICAgKi9cclxuICAgIGdldFBvaW50KHRpbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3MuYWRkKHRoaXMuZGlyLnNjYWxlKHRpbWUpKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9EZXRlY3Rpb24vRHluYW1pY1RyZWVDb2xsaXNpb25Qcm9jZXNzb3IudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXNwb25zaWJsZSBmb3IgcGVyZm9ybWluZyB0aGUgY29sbGlzaW9uIGJyb2FkcGhhc2UgKGxvY2F0aW5nIHBvdGVudGlhbCBjb2xsbGlzaW9ucykgYW5kXHJcbiAqIHRoZSBuYXJyb3dwaGFzZSAoYWN0dWFsIGNvbGxpc2lvbiBjb250YWN0cylcclxuICovXHJcbmNsYXNzIER5bmFtaWNUcmVlQ29sbGlzaW9uUHJvY2Vzc29yIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlID0gbmV3IER5bmFtaWNUcmVlKCk7XHJcbiAgICAgICAgdGhpcy5fY29sbGlzaW9ucyA9IG5ldyBTZXQoKTtcclxuICAgICAgICB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb2xsaWRlcnMgPSBbXTtcclxuICAgIH1cclxuICAgIGdldENvbGxpZGVycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlkZXJzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFja3MgYSBwaHlzaWNzIGJvZHkgZm9yIGNvbGxpc2lvbnNcclxuICAgICAqL1xyXG4gICAgdHJhY2sodGFyZ2V0KSB7XHJcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcclxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignQ2Fubm90IHRyYWNrIG51bGwgY29sbGlkZXInKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQ29tcG9zaXRlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGFyZ2V0LmdldENvbGxpZGVycygpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjLm93bmVyID0gdGFyZ2V0Lm93bmVyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkZXJzLnB1c2goYyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS50cmFja0NvbGxpZGVyKGMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaWRlcnMucHVzaCh0YXJnZXQpO1xyXG4gICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS50cmFja0NvbGxpZGVyKHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnRyYWNrcyBhIHBoeXNpY3MgYm9keVxyXG4gICAgICovXHJcbiAgICB1bnRyYWNrKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghdGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0Nhbm5vdCB1bnRyYWNrIGEgbnVsbCBjb2xsaWRlcicpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBDb21wb3NpdGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlcnMgPSB0YXJnZXQuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYyBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fY29sbGlkZXJzLmluZGV4T2YoYyk7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9keW5hbWljQ29sbGlzaW9uVHJlZS51bnRyYWNrQ29sbGlkZXIoYyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fY29sbGlkZXJzLmluZGV4T2YodGFyZ2V0KTtcclxuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUudW50cmFja0NvbGxpZGVyKHRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3Nob3VsZEdlbmVyYXRlQ29sbGlzaW9uUGFpcihjb2xsaWRlckEsIGNvbGxpZGVyQikge1xyXG4gICAgICAgIC8vIGlmIHRoZSBjb2xsaXNpb24gcGFpciBtdXN0IGJlIDIgc2VwYXJhdGUgY29sbGlkZXJzXHJcbiAgICAgICAgLy8gQWxzbyBzZXBhcmF0ZSBvd25lcnMgZm9yIGNvbXBvc2l0ZSBjb2xsaWRlcnNcclxuICAgICAgICBpZiAoKGNvbGxpZGVyQS5pZCAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICBjb2xsaWRlckIuaWQgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgY29sbGlkZXJBLmlkID09PSBjb2xsaWRlckIuaWQpIHx8XHJcbiAgICAgICAgICAgIChjb2xsaWRlckEub3duZXIgIT09IG51bGwgJiZcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQi5vd25lciAhPT0gbnVsbCAmJlxyXG4gICAgICAgICAgICAgICAgY29sbGlkZXJBLm93bmVyID09PSBjb2xsaWRlckIub3duZXIpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIGNvbGxpc2lvbiBwYWlyIGhhcyBiZWVuIGNhbGN1bGF0ZWQgYWxyZWFkeSBzaG9ydCBjaXJjdWl0XHJcbiAgICAgICAgY29uc3QgaGFzaCA9IFBhaXIuY2FsY3VsYXRlUGFpckhhc2goY29sbGlkZXJBLmlkLCBjb2xsaWRlckIuaWQpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jb2xsaXNpb25zLmhhcyhoYXNoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHBhaXIgZXhpc3RzIGVhc3kgZXhpdCByZXR1cm4gZmFsc2VcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgdGhlIHBhaXIgaGFzIGEgbWVtYmVyIHdpdGggemVybyBkaW1lbnNpb25cclxuICAgICAgICBpZiAoY29sbGlkZXJBLmxvY2FsQm91bmRzLmhhc1plcm9EaW1lbnNpb25zKCkgfHwgY29sbGlkZXJCLmxvY2FsQm91bmRzLmhhc1plcm9EaW1lbnNpb25zKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUGFpci5jYW5Db2xsaWRlKGNvbGxpZGVyQSwgY29sbGlkZXJCKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRGV0ZWN0cyBwb3RlbnRpYWwgY29sbGlzaW9uIHBhaXJzIGluIGEgYnJvYWRwaGFzZSBhcHByb2FjaCB3aXRoIHRoZSBkeW5hbWljIGFhYmIgdHJlZSBzdHJhdGVneVxyXG4gICAgICovXHJcbiAgICBicm9hZHBoYXNlKHRhcmdldHMsIGRlbHRhLCBzdGF0cykge1xyXG4gICAgICAgIGNvbnN0IHNlY29uZHMgPSBkZWx0YSAvIDEwMDA7XHJcbiAgICAgICAgLy8gUmV0cmlldmUgdGhlIGxpc3Qgb2YgcG90ZW50aWFsIGNvbGxpZGVycywgZXhjbHVkZSBraWxsZWQsIHByZXZlbnRlZCwgYW5kIHNlbGZcclxuICAgICAgICBjb25zdCBwb3RlbnRpYWxDb2xsaWRlcnMgPSB0YXJnZXRzLmZpbHRlcigob3RoZXIpID0+IHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAgICAgY29uc3QgYm9keSA9IChfYSA9IG90aGVyLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICByZXR1cm4gKChfYiA9IG90aGVyLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWN0aXZlKSAmJiBib2R5LmNvbGxpc2lvblR5cGUgIT09IENvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBjbGVhciBvbGQgbGlzdCBvZiBjb2xsaXNpb24gcGFpcnNcclxuICAgICAgICB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb2xsaXNpb25zLmNsZWFyKCk7XHJcbiAgICAgICAgLy8gY2hlY2sgZm9yIG5vcm1hbCBjb2xsaXNpb24gcGFpcnNcclxuICAgICAgICBsZXQgY29sbGlkZXI7XHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDAsIGwgPSBwb3RlbnRpYWxDb2xsaWRlcnMubGVuZ3RoOyBqIDwgbDsgaisrKSB7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyID0gcG90ZW50aWFsQ29sbGlkZXJzW2pdO1xyXG4gICAgICAgICAgICAvLyBRdWVyeSB0aGUgY29sbGlzaW9uIHRyZWUgZm9yIHBvdGVudGlhbCBjb2xsaWRlcnNcclxuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUucXVlcnkoY29sbGlkZXIsIChvdGhlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEdlbmVyYXRlQ29sbGlzaW9uUGFpcihjb2xsaWRlciwgb3RoZXIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFpciA9IG5ldyBQYWlyKGNvbGxpZGVyLCBvdGhlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9ucy5hZGQocGFpci5pZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlLnB1c2gocGFpcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBBbHdheXMgcmV0dXJuIGZhbHNlLCB0byBxdWVyeSB3aG9sZSB0cmVlLiBSZXR1cm5pbmcgdHJ1ZSBpbiB0aGUgcXVlcnkgbWV0aG9kIHN0b3BzIHNlYXJjaGluZ1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRzKSB7XHJcbiAgICAgICAgICAgIHN0YXRzLnBoeXNpY3MucGFpcnMgPSB0aGlzLl9jb2xsaXNpb25QYWlyQ2FjaGUubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBDaGVjayBkeW5hbWljIHRyZWUgZm9yIGZhc3QgbW92aW5nIG9iamVjdHNcclxuICAgICAgICAvLyBGYXN0IG1vdmluZyBvYmplY3RzIGFyZSB0aG9zZSBtb3ZpbmcgYXQgbGVhc3QgdGhlcmUgc21hbGxlc3QgYm91bmQgcGVyIGZyYW1lXHJcbiAgICAgICAgaWYgKFBoeXNpY3MuY2hlY2tGb3JGYXN0Qm9kaWVzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29sbGlkZXIgb2YgcG90ZW50aWFsQ29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib2R5ID0gY29sbGlkZXIub3duZXIuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBub24tYWN0aXZlIG9iamVjdHMuIERvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gb3RoZXIgY29sbGlzaW9uIHR5cGVzXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keS5jb2xsaXNpb25UeXBlICE9PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gTWF4aW11bSB0cmF2ZWwgZGlzdGFuY2UgbmV4dCBmcmFtZVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdXBkYXRlRGlzdGFuY2UgPSBib2R5LnZlbC5zaXplICogc2Vjb25kcyArIC8vIHZlbG9jaXR5IHRlcm1cclxuICAgICAgICAgICAgICAgICAgICBib2R5LmFjYy5zaXplICogMC41ICogc2Vjb25kcyAqIHNlY29uZHM7IC8vIGFjYyB0ZXJtXHJcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBtaW5pbXVtIGRpbWVuc2lvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWluRGltZW5zaW9uID0gTWF0aC5taW4oY29sbGlkZXIuYm91bmRzLmhlaWdodCwgY29sbGlkZXIuYm91bmRzLndpZHRoKTtcclxuICAgICAgICAgICAgICAgIGlmIChQaHlzaWNzLmRpc2FibGVNaW5pbXVtU3BlZWRGb3JGYXN0Qm9keSB8fCB1cGRhdGVEaXN0YW5jZSA+IG1pbkRpbWVuc2lvbiAvIDIpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMucGh5c2ljcy5mYXN0Qm9kaWVzKys7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHdpdGggdGhlIG9sZFBvcyBiZWNhdXNlIHRoZSBpbnRlZ3JhdGlvbiBmb3IgYWN0b3JzIGhhcyBhbHJlYWR5IGhhcHBlbmVkXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gb2JqZWN0cyByZXN0aW5nIG9uIGEgc3VyZmFjZSBtYXkgYmUgc2xpZ2h0bHkgcGVuZXRyYXRpbmcgaW4gdGhlIGN1cnJlbnQgcG9zaXRpb25cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVWZWMgPSBib2R5LnBvcy5zdWIoYm9keS5vbGRQb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclBvaW50ID0gY29sbGlkZXIuY2VudGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1cnRoZXN0UG9pbnQgPSBjb2xsaWRlci5nZXRGdXJ0aGVzdFBvaW50KGJvZHkudmVsKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBmdXJ0aGVzdFBvaW50LnN1Yih1cGRhdGVWZWMpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJheSA9IG5ldyBSYXkob3JpZ2luLCBib2R5LnZlbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYmFjayB0aGUgcmF5IHVwIGJ5IC0yeCBzdXJmYWNlRXBzaWxvbiB0byBhY2NvdW50IGZvciBmYXN0IG1vdmluZyBvYmplY3RzIHN0YXJ0aW5nIG9uIHRoZSBzdXJmYWNlXHJcbiAgICAgICAgICAgICAgICAgICAgcmF5LnBvcyA9IHJheS5wb3MuYWRkKHJheS5kaXIuc2NhbGUoLTIgKiBQaHlzaWNzLnN1cmZhY2VFcHNpbG9uKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbkNvbGxpZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBtaW5UcmFuc2xhdGUgPSBuZXcgVmVjdG9yKEluZmluaXR5LCBJbmZpbml0eSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZHluYW1pY0NvbGxpc2lvblRyZWUucmF5Q2FzdFF1ZXJ5KHJheSwgdXBkYXRlRGlzdGFuY2UgKyBQaHlzaWNzLnN1cmZhY2VFcHNpbG9uICogMiwgKG90aGVyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaWRlciAhPT0gb3RoZXIgJiYgUGFpci5jYW5Db2xsaWRlKGNvbGxpZGVyLCBvdGhlcikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhpdFBvaW50ID0gb3RoZXIucmF5Q2FzdChyYXksIHVwZGF0ZURpc3RhbmNlICsgUGh5c2ljcy5zdXJmYWNlRXBzaWxvbiAqIDEwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoaXRQb2ludCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZSA9IGhpdFBvaW50LnN1YihvcmlnaW4pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGUuc2l6ZSA8IG1pblRyYW5zbGF0ZS5zaXplKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluQ29sbGlkZXIgPSBvdGhlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5Db2xsaWRlciAmJiBWZWN0b3IuaXNWYWxpZChtaW5UcmFuc2xhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhaXIgPSBuZXcgUGFpcihjb2xsaWRlciwgbWluQ29sbGlkZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NvbGxpc2lvbnMuaGFzKHBhaXIuaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb2xsaXNpb25zLmFkZChwYWlyLmlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbGxpc2lvblBhaXJDYWNoZS5wdXNoKHBhaXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGZhc3QgbW92aW5nIG9iamVjdCB0byB0aGUgb3RoZXIgYm9keVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHB1c2ggaW50byB0aGUgc3VyZmFjZSBieSBleC5QaHlzaWNzLnN1cmZhY2VFcHNpbG9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoaWZ0ID0gY2VudGVyUG9pbnQuc3ViKGZ1cnRoZXN0UG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5LnBvcyA9IG9yaWdpblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZChzaGlmdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hZGQobWluVHJhbnNsYXRlKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFkZChyYXkuZGlyLnNjYWxlKDEwICogUGh5c2ljcy5zdXJmYWNlRXBzaWxvbikpOyAvLyBuZWVkZWQgdG8gcHVzaCB0aGUgc2hhcGUgc2xpZ2h0bHkgaW50byBjb250YWN0XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpZGVyLnVwZGF0ZShib2R5LnRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdGF0cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHMucGh5c2ljcy5mYXN0Qm9keUNvbGxpc2lvbnMrKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXR1cm4gY2FjaGVcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29sbGlzaW9uUGFpckNhY2hlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBsaWVzIG5hcnJvdyBwaGFzZSBvbiBjb2xsaXNpb24gcGFpcnMgdG8gZmluZCBhY3R1YWwgYXJlYSBpbnRlcnNlY3Rpb25zXHJcbiAgICAgKiBBZGRzIGFjdHVhbCBjb2xsaWRpbmcgcGFpcnMgdG8gc3RhdHMnIEZyYW1lIGRhdGFcclxuICAgICAqL1xyXG4gICAgbmFycm93cGhhc2UocGFpcnMsIHN0YXRzKSB7XHJcbiAgICAgICAgbGV0IGNvbnRhY3RzID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWlycy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBuZXdDb250YWN0cyA9IHBhaXJzW2ldLmNvbGxpZGUoKTtcclxuICAgICAgICAgICAgY29udGFjdHMgPSBjb250YWN0cy5jb25jYXQobmV3Q29udGFjdHMpO1xyXG4gICAgICAgICAgICBpZiAoc3RhdHMgJiYgbmV3Q29udGFjdHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjIG9mIG5ld0NvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHMucGh5c2ljcy5jb250YWN0cy5zZXQoYy5pZCwgYyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHN0YXRzKSB7XHJcbiAgICAgICAgICAgIHN0YXRzLnBoeXNpY3MuY29sbGlzaW9ucyArPSBjb250YWN0cy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250YWN0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBkeW5hbWljIHRyZWUgcG9zaXRpb25zXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZSh0YXJnZXRzKSB7XHJcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSAwO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHRhcmdldHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLnVwZGF0ZUNvbGxpZGVyKHRhcmdldHNbaV0pKSB7XHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XHJcbiAgICB9XHJcbiAgICBkZWJ1ZyhleCkge1xyXG4gICAgICAgIHRoaXMuX2R5bmFtaWNDb2xsaXNpb25UcmVlLmRlYnVnKGV4KTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaWRlcnMvQ29sbGlkZXIudHNcblxyXG5cclxuLyoqXHJcbiAqIEEgY29sbGlzaW9uIGNvbGxpZGVyIHNwZWNpZmllcyB0aGUgZ2VvbWV0cnkgdGhhdCBjYW4gZGV0ZWN0IHdoZW4gb3RoZXIgY29sbGlzaW9uIGNvbGxpZGVycyBpbnRlcnNlY3RcclxuICogZm9yIHRoZSBwdXJwb3NlcyBvZiBjb2xsaWRpbmcgMiBvYmplY3RzIGluIGV4Y2FsaWJ1ci5cclxuICovXHJcbmNsYXNzIENvbGxpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuaWQgPSBjcmVhdGVJZCgnY29sbGlkZXInLCBDb2xsaWRlci5fSUQrKyk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMgPSBuZXcgRXZlbnREaXNwYXRjaGVyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBib2R5IGNvbGxpZGVkIHdpdGhcclxuICAgICAqIG9yIHdhcyBpbiBzdGF0aW9uYXJ5IGNvbnRhY3Qgd2l0aFxyXG4gICAgICogdGhlIGJvZHkgb2YgdGhlIG90aGVyIFtbQ29sbGlkZXJdXVxyXG4gICAgICovXHJcbiAgICB0b3VjaGluZyhvdGhlcikge1xyXG4gICAgICAgIGNvbnN0IGNvbnRhY3QgPSB0aGlzLmNvbGxpZGUob3RoZXIpO1xyXG4gICAgICAgIGlmIChjb250YWN0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuQ29sbGlkZXIuX0lEID0gMDtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQ29sbGlkZXJzL0NvbXBvc2l0ZUNvbGxpZGVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIENvbXBvc2l0ZUNvbGxpZGVyIGV4dGVuZHMgQ29sbGlkZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29sbGlkZXJzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9jb2xsaXNpb25Qcm9jZXNzb3IgPSBuZXcgRHluYW1pY1RyZWVDb2xsaXNpb25Qcm9jZXNzb3IoKTtcclxuICAgICAgICB0aGlzLl9keW5hbWljQUFCQlRyZWUgPSBuZXcgRHluYW1pY1RyZWUoKTtcclxuICAgICAgICB0aGlzLl9jb2xsaWRlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ29sbGlkZXIoYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJDb2xsaWRlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXJzID0gW107XHJcbiAgICB9XHJcbiAgICBhZGRDb2xsaWRlcihjb2xsaWRlcikge1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLndpcmUoY29sbGlkZXIuZXZlbnRzKTtcclxuICAgICAgICB0aGlzLl9jb2xsaWRlcnMucHVzaChjb2xsaWRlcik7XHJcbiAgICAgICAgdGhpcy5fY29sbGlzaW9uUHJvY2Vzc29yLnRyYWNrKGNvbGxpZGVyKTtcclxuICAgICAgICB0aGlzLl9keW5hbWljQUFCQlRyZWUudHJhY2tDb2xsaWRlcihjb2xsaWRlcik7XHJcbiAgICB9XHJcbiAgICByZW1vdmVDb2xsaWRlcihjb2xsaWRlcikge1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLnVud2lyZShjb2xsaWRlci5ldmVudHMpO1xyXG4gICAgICAgIHJlbW92ZUl0ZW1Gcm9tQXJyYXkoY29sbGlkZXIsIHRoaXMuX2NvbGxpZGVycyk7XHJcbiAgICAgICAgdGhpcy5fY29sbGlzaW9uUHJvY2Vzc29yLnVudHJhY2soY29sbGlkZXIpO1xyXG4gICAgICAgIHRoaXMuX2R5bmFtaWNBQUJCVHJlZS51bnRyYWNrQ29sbGlkZXIoY29sbGlkZXIpO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29sbGlkZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsaWRlcnM7XHJcbiAgICB9XHJcbiAgICBnZXQgd29ybGRQb3MoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICAvLyBUT0RPIHRyYW5zZm9ybSBjb21wb25lbnQgd29ybGQgcG9zXHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3RyYW5zZm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogVmVjdG9yLlplcm87XHJcbiAgICB9XHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3RyYW5zZm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogVmVjdG9yLlplcm87XHJcbiAgICB9XHJcbiAgICBnZXQgYm91bmRzKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgLy8gVE9ETyBjYWNoZSB0aGlzXHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gY29sbGlkZXJzLnJlZHVjZSgoYWNjLCBjb2xsaWRlcikgPT4gYWNjLmNvbWJpbmUoY29sbGlkZXIuYm91bmRzKSwgKF9iID0gKF9hID0gY29sbGlkZXJzWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYm91bmRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgQm91bmRpbmdCb3goKS50cmFuc2xhdGUodGhpcy53b3JsZFBvcykpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgLy8gVE9ETyBjYWNoZSB0aGlzXHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBjb25zdCByZXN1bHRzID0gY29sbGlkZXJzLnJlZHVjZSgoYWNjLCBjb2xsaWRlcikgPT4gYWNjLmNvbWJpbmUoY29sbGlkZXIubG9jYWxCb3VuZHMpLCAoX2IgPSAoX2EgPSBjb2xsaWRlcnNbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbEJvdW5kcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEJvdW5kaW5nQm94KCkpO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRzO1xyXG4gICAgfVxyXG4gICAgZ2V0IGF4ZXMoKSB7XHJcbiAgICAgICAgLy8gVE9ETyBjYWNoZSB0aGlzXHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBsZXQgYXhlcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29sbGlkZXIgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgIGF4ZXMgPSBheGVzLmNvbmNhdChjb2xsaWRlci5heGVzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF4ZXM7XHJcbiAgICB9XHJcbiAgICBnZXRGdXJ0aGVzdFBvaW50KGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgZnVydGhlc3RQb2ludHMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBmdXJ0aGVzdFBvaW50cy5wdXNoKGNvbGxpZGVyLmdldEZ1cnRoZXN0UG9pbnQoZGlyZWN0aW9uKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFBpY2sgYmVzdCBwb2ludCBmcm9tIGFsbCBjb2xsaWRlcnNcclxuICAgICAgICBsZXQgYmVzdFBvaW50ID0gZnVydGhlc3RQb2ludHNbMF07XHJcbiAgICAgICAgbGV0IG1heERpc3RhbmNlID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBmdXJ0aGVzdFBvaW50cykge1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHBvaW50LmRvdChkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgYmVzdFBvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiZXN0UG9pbnQ7XHJcbiAgICB9XHJcbiAgICBnZXRJbmVydGlhKG1hc3MpIHtcclxuICAgICAgICBjb25zdCBjb2xsaWRlcnMgPSB0aGlzLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgIGxldCB0b3RhbEluZXJ0aWEgPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29sbGlkZXIgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgIHRvdGFsSW5lcnRpYSArPSBjb2xsaWRlci5nZXRJbmVydGlhKG1hc3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdG90YWxJbmVydGlhO1xyXG4gICAgfVxyXG4gICAgY29sbGlkZShvdGhlcikge1xyXG4gICAgICAgIGxldCBvdGhlckNvbGxpZGVycyA9IFtvdGhlcl07XHJcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQ29tcG9zaXRlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgb3RoZXJDb2xsaWRlcnMgPSBvdGhlci5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygb3RoZXJDb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy5fZHluYW1pY0FBQkJUcmVlLnF1ZXJ5KGMsIChwb3RlbnRpYWxDb2xsaWRlcikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaChuZXcgUGFpcihjLCBwb3RlbnRpYWxDb2xsaWRlcikpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGNvbnRhY3RzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHBhaXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnRhY3RzID0gY29udGFjdHMuY29uY2F0KHAuY29sbGlkZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhY3RzO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2xvc2VzdExpbmVCZXR3ZWVuKG90aGVyKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBjb25zdCBsaW5lcyA9IFtdO1xyXG4gICAgICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG90aGVyQ29sbGlkZXJzID0gb3RoZXIuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29sbGlkZXJBIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2xsaWRlckIgb2Ygb3RoZXJDb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXliZUxpbmUgPSBjb2xsaWRlckEuZ2V0Q2xvc2VzdExpbmVCZXR3ZWVuKGNvbGxpZGVyQik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1heWJlTGluZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKG1heWJlTGluZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbWF5YmVMaW5lID0gb3RoZXIuZ2V0Q2xvc2VzdExpbmVCZXR3ZWVuKGNvbGxpZGVyKTtcclxuICAgICAgICAgICAgICAgIGlmIChtYXliZUxpbmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBsaW5lcy5wdXNoKG1heWJlTGluZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBsZXQgbWluTGVuZ3RoID0gbGluZXNbMF0uZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgICAgIGxldCBtaW5MaW5lID0gbGluZXNbMF07XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gbGluZS5nZXRMZW5ndGgoKTtcclxuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCBtaW5MZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICBtaW5MZW5ndGggPSBsZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluTGluZSA9IGxpbmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1pbkxpbmU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgY29udGFpbnMocG9pbnQpIHtcclxuICAgICAgICBjb25zdCBjb2xsaWRlcnMgPSB0aGlzLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29sbGlkZXIgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChjb2xsaWRlci5jb250YWlucyhwb2ludCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJheUNhc3QocmF5LCBtYXgpIHtcclxuICAgICAgICBjb25zdCBjb2xsaWRlcnMgPSB0aGlzLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29sbGlkZXIgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlYyA9IGNvbGxpZGVyLnJheUNhc3QocmF5LCBtYXgpO1xyXG4gICAgICAgICAgICBpZiAodmVjKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaCh2ZWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGxldCBtaW5Qb2ludCA9IHBvaW50c1swXTtcclxuICAgICAgICAgICAgbGV0IG1pbkRpc3RhbmNlID0gbWluUG9pbnQuZG90KHJheS5kaXIpO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIHBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSByYXkuZGlyLmRvdChwb2ludCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBtaW5EaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIG1pblBvaW50ID0gcG9pbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbWluUG9pbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgcHJvamVjdChheGlzKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBjb25zdCBwcm9qcyA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29sbGlkZXIgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2ogPSBjb2xsaWRlci5wcm9qZWN0KGF4aXMpO1xyXG4gICAgICAgICAgICBpZiAocHJvaikge1xyXG4gICAgICAgICAgICAgICAgcHJvanMucHVzaChwcm9qKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNZXJnZSBhbGwgcHJvaidzIG9uIHRoZSBzYW1lIGF4aXNcclxuICAgICAgICBpZiAocHJvanMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5ld1Byb2plY3Rpb24gPSBuZXcgUHJvamVjdGlvbihwcm9qc1swXS5taW4sIHByb2pzWzBdLm1heCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvaiBvZiBwcm9qcykge1xyXG4gICAgICAgICAgICAgICAgbmV3UHJvamVjdGlvbi5taW4gPSBNYXRoLm1pbihwcm9qLm1pbiwgbmV3UHJvamVjdGlvbi5taW4pO1xyXG4gICAgICAgICAgICAgICAgbmV3UHJvamVjdGlvbi5tYXggPSBNYXRoLm1heChwcm9qLm1heCwgbmV3UHJvamVjdGlvbi5tYXgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBuZXdQcm9qZWN0aW9uO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHVwZGF0ZSh0cmFuc2Zvcm0pIHtcclxuICAgICAgICBpZiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IHRoaXMuZ2V0Q29sbGlkZXJzKCk7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29sbGlkZXIgb2YgY29sbGlkZXJzKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlci5vd25lciA9IHRoaXMub3duZXI7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlci51cGRhdGUodHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRyYXcoY3R4LCBjb2xvciwgcG9zKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBjb2xsaWRlci5kcmF3KGN0eCwgY29sb3IsIHBvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZGVidWcoZXgsIGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBjb2xsaWRlci5kZWJ1ZyhleCwgY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGRlYnVnRHJhdyhjdHgsIGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gdGhpcy5nZXRDb2xsaWRlcnMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICBjb2xsaWRlci5kcmF3KGN0eCwgY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgQ29tcG9zaXRlQ29sbGlkZXIodGhpcy5fY29sbGlkZXJzLm1hcCgoYykgPT4gYy5jbG9uZSgpKSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL2xpbmUudHNcblxyXG4vKipcclxuICogQSAyRCBsaW5lIHNlZ21lbnRcclxuICovXHJcbmNsYXNzIExpbmUge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gYmVnaW4gIFRoZSBzdGFydGluZyBwb2ludCBvZiB0aGUgbGluZSBzZWdtZW50XHJcbiAgICAgKiBAcGFyYW0gZW5kICBUaGUgZW5kaW5nIHBvaW50IG9mIHRoZSBsaW5lIHNlZ21lbnRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIHRoaXMuYmVnaW4gPSBiZWdpbjtcclxuICAgICAgICB0aGlzLmVuZCA9IGVuZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcmF3IHNsb3BlIChtKSBvZiB0aGUgbGluZS4gV2lsbCByZXR1cm4gKCsvLSlJbmZpbml0eSBmb3IgdmVydGljYWwgbGluZXMuXHJcbiAgICAgKi9cclxuICAgIGdldCBzbG9wZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuZW5kLnkgLSB0aGlzLmJlZ2luLnkpIC8gKHRoaXMuZW5kLnggLSB0aGlzLmJlZ2luLngpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBZLWludGVyY2VwdCAoYikgb2YgdGhlIGxpbmUuIFdpbGwgcmV0dXJuICgrLy0pSW5maW5pdHkgaWYgdGhlcmUgaXMgbm8gaW50ZXJjZXB0LlxyXG4gICAgICovXHJcbiAgICBnZXQgaW50ZXJjZXB0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJlZ2luLnkgLSB0aGlzLnNsb3BlICogdGhpcy5iZWdpbi54O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBub3JtYWwgb2YgdGhlIGxpbmVcclxuICAgICAqL1xyXG4gICAgbm9ybWFsKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZC5zdWIodGhpcy5iZWdpbikubm9ybWFsKCk7XHJcbiAgICB9XHJcbiAgICBkaXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kLnN1Yih0aGlzLmJlZ2luKTtcclxuICAgIH1cclxuICAgIGdldFBvaW50cygpIHtcclxuICAgICAgICByZXR1cm4gW3RoaXMuYmVnaW4sIHRoaXMuZW5kXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgc2xvcGUgb2YgdGhlIGxpbmUgaW4gdGhlIGZvcm0gb2YgYSB2ZWN0b3Igb2YgbGVuZ3RoIDFcclxuICAgICAqL1xyXG4gICAgZ2V0U2xvcGUoKSB7XHJcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuZW5kO1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICByZXR1cm4gZW5kLnN1YihiZWdpbikuc2NhbGUoMSAvIGRpc3RhbmNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgZWRnZSBvZiB0aGUgbGluZSBhcyB2ZWN0b3IsIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvciBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBlZGdlXHJcbiAgICAgKi9cclxuICAgIGdldEVkZ2UoKSB7XHJcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuZW5kO1xyXG4gICAgICAgIHJldHVybiBlbmQuc3ViKGJlZ2luKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIGdldExlbmd0aCgpIHtcclxuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuYmVnaW47XHJcbiAgICAgICAgY29uc3QgZW5kID0gdGhpcy5lbmQ7XHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBiZWdpbi5kaXN0YW5jZShlbmQpO1xyXG4gICAgICAgIHJldHVybiBkaXN0YW5jZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbWlkcG9pbnQgb2YgdGhlIGVkZ2VcclxuICAgICAqL1xyXG4gICAgZ2V0IG1pZHBvaW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJlZ2luLmFkZCh0aGlzLmVuZCkuc2NhbGUoMC41KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmxpcHMgdGhlIGRpcmVjdGlvbiBvZiB0aGUgbGluZSBzZWdtZW50XHJcbiAgICAgKi9cclxuICAgIGZsaXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lKHRoaXMuZW5kLCB0aGlzLmJlZ2luKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgYSBnaXZlbiBwb2ludCBpcyBiZWxvdyB0aGUgbGluZSwgcG9pbnRzIGluIHRoZSBub3JtYWwgZGlyZWN0aW9uIGFib3ZlIHRoZSBsaW5lIGFyZSBjb25zaWRlcmVkIGFib3ZlLlxyXG4gICAgICogQHBhcmFtIHBvaW50XHJcbiAgICAgKi9cclxuICAgIGJlbG93KHBvaW50KSB7XHJcbiAgICAgICAgY29uc3QgYWJvdmUyID0gKHRoaXMuZW5kLnggLSB0aGlzLmJlZ2luLngpICogKHBvaW50LnkgLSB0aGlzLmJlZ2luLnkpIC0gKHRoaXMuZW5kLnkgLSB0aGlzLmJlZ2luLnkpICogKHBvaW50LnggLSB0aGlzLmJlZ2luLngpO1xyXG4gICAgICAgIHJldHVybiBhYm92ZTIgPj0gMDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2xpcCBwb2ludFxyXG4gICAgICogQHBhcmFtIHNpZGVWZWN0b3IgVmVjdG9yIHRoYXQgdHJhY2VzIHRoZSBsaW5lXHJcbiAgICAgKiBAcGFyYW0gbGVuZ3RoIExlbmd0aCB0byBjbGlwIGFsb25nIHNpZGVcclxuICAgICAqL1xyXG4gICAgY2xpcChzaWRlVmVjdG9yLCBsZW5ndGgpIHtcclxuICAgICAgICBsZXQgZGlyID0gc2lkZVZlY3RvcjtcclxuICAgICAgICBkaXIgPSBkaXIubm9ybWFsaXplKCk7XHJcbiAgICAgICAgY29uc3QgbmVhciA9IGRpci5kb3QodGhpcy5iZWdpbikgLSBsZW5ndGg7XHJcbiAgICAgICAgY29uc3QgZmFyID0gZGlyLmRvdCh0aGlzLmVuZCkgLSBsZW5ndGg7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xyXG4gICAgICAgIGlmIChuZWFyIDw9IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuYmVnaW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZmFyIDw9IDApIHtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuZW5kKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKG5lYXIgKiBmYXIgPCAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNsaXBUaW1lID0gbmVhciAvIChuZWFyIC0gZmFyKTtcclxuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMuYmVnaW4uYWRkKHRoaXMuZW5kLnN1Yih0aGlzLmJlZ2luKS5zY2FsZShjbGlwVGltZSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoICE9PSAyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbmV3IExpbmUocmVzdWx0c1swXSwgcmVzdWx0c1sxXSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIHBlcnBlbmRpY3VsYXIgZGlzdGFuY2UgZnJvbSB0aGUgbGluZSB0byBhIHBvaW50XHJcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgZGlzdGFuY2VUb1BvaW50KHBvaW50LCBzaWduZWQgPSBmYWxzZSkge1xyXG4gICAgICAgIGNvbnN0IHgwID0gcG9pbnQueDtcclxuICAgICAgICBjb25zdCB5MCA9IHBvaW50Lnk7XHJcbiAgICAgICAgY29uc3QgbCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XHJcbiAgICAgICAgY29uc3QgZHkgPSB0aGlzLmVuZC55IC0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgIGNvbnN0IGR4ID0gdGhpcy5lbmQueCAtIHRoaXMuYmVnaW4ueDtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IChkeSAqIHgwIC0gZHggKiB5MCArIHRoaXMuZW5kLnggKiB0aGlzLmJlZ2luLnkgLSB0aGlzLmVuZC55ICogdGhpcy5iZWdpbi54KSAvIGw7XHJcbiAgICAgICAgcmV0dXJuIHNpZ25lZCA/IGRpc3RhbmNlIDogTWF0aC5hYnMoZGlzdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBwZXJwZW5kaWN1bGFyIGxpbmUgZnJvbSB0aGUgbGluZSB0byBhIHBvaW50XHJcbiAgICAgKiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9mcm9tX2FfcG9pbnRfdG9fYV9saW5lXHJcbiAgICAgKiAoYSAtIHApIC0gKChhIC0gcCkgKiBuKW5cclxuICAgICAqIGEgaXMgYSBwb2ludCBvbiB0aGUgbGluZVxyXG4gICAgICogcCBpcyB0aGUgYXJiaXRyYXJ5IHBvaW50IGFib3ZlIHRoZSBsaW5lXHJcbiAgICAgKiBuIGlzIGEgdW5pdCB2ZWN0b3IgaW4gZGlyZWN0aW9uIG9mIHRoZSBsaW5lXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqL1xyXG4gICAgZmluZFZlY3RvclRvUG9pbnQocG9pbnQpIHtcclxuICAgICAgICBjb25zdCBhTWludXNQID0gdGhpcy5iZWdpbi5zdWIocG9pbnQpO1xyXG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmdldFNsb3BlKCk7XHJcbiAgICAgICAgcmV0dXJuIGFNaW51c1Auc3ViKG4uc2NhbGUoYU1pbnVzUC5kb3QobikpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgYSBwb2ludCBvbiB0aGUgbGluZSBnaXZlbiBvbmx5IGFuIFggb3IgYSBZIHZhbHVlLiBHaXZlbiBhbiBYIHZhbHVlLCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xyXG4gICAgICogYSBuZXcgcG9pbnQgd2l0aCB0aGUgY2FsY3VsYXRlZCBZIHZhbHVlIGFuZCB2aWNlLXZlcnNhLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB4IFRoZSBrbm93biBYIHZhbHVlIG9mIHRoZSB0YXJnZXQgcG9pbnRcclxuICAgICAqIEBwYXJhbSB5IFRoZSBrbm93biBZIHZhbHVlIG9mIHRoZSB0YXJnZXQgcG9pbnRcclxuICAgICAqIEByZXR1cm5zIEEgbmV3IHBvaW50IHdpdGggdGhlIG90aGVyIGNhbGN1bGF0ZWQgYXhpcyB2YWx1ZVxyXG4gICAgICovXHJcbiAgICBmaW5kUG9pbnQoeCA9IG51bGwsIHkgPSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgbSA9IHRoaXMuc2xvcGU7XHJcbiAgICAgICAgY29uc3QgYiA9IHRoaXMuaW50ZXJjZXB0O1xyXG4gICAgICAgIGlmICh4ICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHgsIG0gKiB4ICsgYik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHkgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoKHkgLSBiKSAvIG0sIHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGFuIFggb3IgYSBZIHZhbHVlJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAc2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExOTA4MTU4LzEwOTQ1OFxyXG4gICAgICovXHJcbiAgICBoYXNQb2ludCgpIHtcclxuICAgICAgICBsZXQgY3VyclBvaW50O1xyXG4gICAgICAgIGxldCB0aHJlc2hvbGQgPSAwO1xyXG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBjdXJyUG9pbnQgPSBuZXcgVmVjdG9yKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgICAgdGhyZXNob2xkID0gYXJndW1lbnRzWzJdIHx8IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICBjdXJyUG9pbnQgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgICAgIHRocmVzaG9sZCA9IGFyZ3VtZW50c1sxXSB8fCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgJ0NvdWxkIG5vdCBkZXRlcm1pbmUgdGhlIGFyZ3VtZW50cyBmb3IgVmVjdG9yLmhhc1BvaW50JztcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZHhjID0gY3VyclBvaW50LnggLSB0aGlzLmJlZ2luLng7XHJcbiAgICAgICAgY29uc3QgZHljID0gY3VyclBvaW50LnkgLSB0aGlzLmJlZ2luLnk7XHJcbiAgICAgICAgY29uc3QgZHgxID0gdGhpcy5lbmQueCAtIHRoaXMuYmVnaW4ueDtcclxuICAgICAgICBjb25zdCBkeTEgPSB0aGlzLmVuZC55IC0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgIGNvbnN0IGNyb3NzID0gZHhjICogZHkxIC0gZHljICogZHgxO1xyXG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgcG9pbnQgbGluZXMgb24gdGhlIGxpbmVcclxuICAgICAgICBpZiAoTWF0aC5hYnMoY3Jvc3MpID4gdGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2hlY2sgd2hldGhlciBwb2ludCBsaWVzIGluLWJldHdlZW4gc3RhcnQgYW5kIGVuZFxyXG4gICAgICAgIGlmIChNYXRoLmFicyhkeDEpID49IE1hdGguYWJzKGR5MSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGR4MSA+IDAgPyB0aGlzLmJlZ2luLnggPD0gY3VyclBvaW50LnggJiYgY3VyclBvaW50LnggPD0gdGhpcy5lbmQueCA6IHRoaXMuZW5kLnggPD0gY3VyclBvaW50LnggJiYgY3VyclBvaW50LnggPD0gdGhpcy5iZWdpbi54O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIGR5MSA+IDAgPyB0aGlzLmJlZ2luLnkgPD0gY3VyclBvaW50LnkgJiYgY3VyclBvaW50LnkgPD0gdGhpcy5lbmQueSA6IHRoaXMuZW5kLnkgPD0gY3VyclBvaW50LnkgJiYgY3VyclBvaW50LnkgPD0gdGhpcy5iZWdpbi55O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaWRlcnMvQ2xvc2VzdExpbmVKdW1wVGFibGUudHNcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBGaW5kcyB0aGUgY2xvc2VzIGxpbmUgYmV0d2VlbiAyIGxpbmUgc2VnbWVudHMsIHdlcmUgdGhlIG1hZ25pdHVkZSBvZiB1LCB2IGFyZSB0aGUgbGVuZ3RocyBvZiBlYWNoIHNlZ21lbnRcclxuICogTDEgPSBQKHMpID0gcDAgKyBzICogdSwgd2hlcmUgcyBpcyB0aW1lIGFuZCBwMCBpcyB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICogTDIgPSBRKHQpID0gcTAgKyB0ICogdiwgd2hlcmUgdCBpcyB0aW1lIGFuZCBxMCBpcyB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICogQHBhcmFtIHAwIFBvaW50IHdoZXJlIEwxIGJlZ2luc1xyXG4gKiBAcGFyYW0gdSBEaXJlY3Rpb24gYW5kIGxlbmd0aCBvZiBMMVxyXG4gKiBAcGFyYW0gcTAgUG9pbnQgd2VyZSBMMiBiZWdpbnNcclxuICogQHBhcmFtIHYgRGlyZWN0aW9uIGFuZCBsZW5ndGggb2YgTDJcclxuICovXHJcbmZ1bmN0aW9uIENsb3Nlc3RMaW5lKHAwLCB1LCBxMCwgdikge1xyXG4gICAgLy8gRGlzdGFuY2UgYmV0d2VlbiAyIGxpbmVzIGh0dHA6Ly9nZW9tYWxnb3JpdGhtcy5jb20vYTA3LV9kaXN0YW5jZS5odG1sXHJcbiAgICAvLyB3KHMsIHQpID0gUChzKSAtIFEodClcclxuICAgIC8vIFRoZSB3KHMsIHQpIHRoYXQgaGFzIHRoZSBtaW5pbXVtIGRpc3RhbmNlIHdlIHdpbGwgc2F5IGlzIHcoc0Nsb3Nlc3QsIHRDbG9zZXN0KSA9IHdDbG9zZXN0XHJcbiAgICAvL1xyXG4gICAgLy8gd0Nsb3Nlc3QgaXMgdGhlIHZlY3RvciB0aGF0IGlzIHVuaXF1ZWx5IHBlcnBlbmRpY3VsYXIgdG8gdGhlIDIgbGluZSBkaXJlY3Rpb25zIHUgJiB2LlxyXG4gICAgLy8gd0Nsb3Nlc3QgPSB3MCArIHNDbG9zZXN0ICogdSAtIHRDbG9zZXN0ICogdiwgd2hlcmUgdzAgaXMgcDAgLSBxMFxyXG4gICAgLy9cclxuICAgIC8vIFRoZSBjbG9zZXN0IHBvaW50IGJldHdlZW4gMiBsaW5lcyB0aGVuIHNhdGlzZmllcyB0aGlzIHBhaXIgb2YgZXF1YXRpb25zXHJcbiAgICAvLyAxOiB1ICogd0Nsb3Nlc3QgPSAwXHJcbiAgICAvLyAyOiB2ICogd0Nsb3Nlc3QgPSAwXHJcbiAgICAvL1xyXG4gICAgLy8gU3Vic3RpdHV0aW5nIHdDbG9zZXN0IGludG8gdGhlIGVxdWF0aW9ucyB3ZSBnZXRcclxuICAgIC8vXHJcbiAgICAvLyAxOiAodSAqIHUpICogc0Nsb3Nlc3QgLSAodSAqIHYpIHRDbG9zZXN0ID0gLXUgKiB3MFxyXG4gICAgLy8gMjogKHYgKiB1KSAqIHNDbG9zZXN0IC0gKHYgKiB2KSB0Q2xvc2VzdCA9IC12ICogdzBcclxuICAgIC8vIHNpbXBsaWZ5IHcwXHJcbiAgICBjb25zdCB3MCA9IHAwLnN1YihxMCk7XHJcbiAgICAvLyBzaW1wbGlmeSAodSAqIHUpO1xyXG4gICAgY29uc3QgYSA9IHUuZG90KHUpO1xyXG4gICAgLy8gc2ltcGxpZnkgKHUgKiB2KTtcclxuICAgIGNvbnN0IGIgPSB1LmRvdCh2KTtcclxuICAgIC8vIHNpbXBsaWZ5ICh2ICogdilcclxuICAgIGNvbnN0IGMgPSB2LmRvdCh2KTtcclxuICAgIC8vIHNpbXBsaWZ5ICh1ICogdzApXHJcbiAgICBjb25zdCBkID0gdS5kb3QodzApO1xyXG4gICAgLy8gc2ltcGxpZnkgKHYgKiB3MClcclxuICAgIGNvbnN0IGUgPSB2LmRvdCh3MCk7XHJcbiAgICAvLyBkZW5vbWluYXRvciBhYyAtIGJeMlxyXG4gICAgY29uc3QgZGVub20gPSBhICogYyAtIGIgKiBiO1xyXG4gICAgbGV0IHNEZW5vbSA9IGRlbm9tO1xyXG4gICAgbGV0IHREZW5vbSA9IGRlbm9tO1xyXG4gICAgLy8gaWYgZGVub20gaXMgMCB0aGV5IGFyZSBwYXJhbGxlbCwgdXNlIGFueSBwb2ludCBmcm9tIGVpdGhlciBhcyB0aGUgc3RhcnQgaW4gdGhpcyBjYXNlIHAwXHJcbiAgICBpZiAoZGVub20gPT09IDAgfHwgZGVub20gPD0gMC4wMSkge1xyXG4gICAgICAgIGNvbnN0IHRDbG9zZXN0UGFyYWxsZWwgPSBkIC8gYjtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmUocDAsIHEwLmFkZCh2LnNjYWxlKHRDbG9zZXN0UGFyYWxsZWwpKSk7XHJcbiAgICB9XHJcbiAgICAvLyBTb2x2ZSBmb3Igc0Nsb3Nlc3QgZm9yIGluZmluaXRlIGxpbmVcclxuICAgIGxldCBzQ2xvc2VzdCA9IGIgKiBlIC0gYyAqIGQ7IC8vIC8gZGVub207XHJcbiAgICAvLyBTb2x2ZSBmb3IgdENsb3Nlc3QgZm9yIGluZmluaXRlIGxpbmVcclxuICAgIGxldCB0Q2xvc2VzdCA9IGEgKiBlIC0gYiAqIGQ7IC8vIC8gZGVub207XHJcbiAgICAvLyBTb2x2ZSBmb3Igc2VnbWVudHMgY2FuZGlkYXRlIGVkZ2VzLCBpZiBzQ2xvc2VzdCBhbmQgdENsb3Nlc3QgYXJlIG91dHNpZGUgdGhlaXIgc2VnbWVudHNcclxuICAgIGlmIChzQ2xvc2VzdCA8IDApIHtcclxuICAgICAgICBzQ2xvc2VzdCA9IDA7XHJcbiAgICAgICAgdENsb3Nlc3QgPSBlO1xyXG4gICAgICAgIHREZW5vbSA9IGM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChzQ2xvc2VzdCA+IHNEZW5vbSkge1xyXG4gICAgICAgIHNDbG9zZXN0ID0gc0Rlbm9tO1xyXG4gICAgICAgIHRDbG9zZXN0ID0gZSArIGI7XHJcbiAgICAgICAgdERlbm9tID0gYztcclxuICAgIH1cclxuICAgIGlmICh0Q2xvc2VzdCA8IDApIHtcclxuICAgICAgICB0Q2xvc2VzdCA9IDA7XHJcbiAgICAgICAgaWYgKC1kIDwgMCkge1xyXG4gICAgICAgICAgICBzQ2xvc2VzdCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKC1kID4gYSkge1xyXG4gICAgICAgICAgICBzQ2xvc2VzdCA9IHNEZW5vbTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHNDbG9zZXN0ID0gLWQ7XHJcbiAgICAgICAgICAgIHNEZW5vbSA9IGE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodENsb3Nlc3QgPiB0RGVub20pIHtcclxuICAgICAgICB0Q2xvc2VzdCA9IHREZW5vbTtcclxuICAgICAgICBpZiAoLWQgKyBiIDwgMCkge1xyXG4gICAgICAgICAgICBzQ2xvc2VzdCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKC1kICsgYiA+IGEpIHtcclxuICAgICAgICAgICAgc0Nsb3Nlc3QgPSBzRGVub207XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzQ2xvc2VzdCA9IC1kICsgYjtcclxuICAgICAgICAgICAgc0Rlbm9tID0gYTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzQ2xvc2VzdCA9IE1hdGguYWJzKHNDbG9zZXN0KSA8IDAuMDAxID8gMCA6IHNDbG9zZXN0IC8gc0Rlbm9tO1xyXG4gICAgdENsb3Nlc3QgPSBNYXRoLmFicyh0Q2xvc2VzdCkgPCAwLjAwMSA/IDAgOiB0Q2xvc2VzdCAvIHREZW5vbTtcclxuICAgIHJldHVybiBuZXcgTGluZShwMC5hZGQodS5zY2FsZShzQ2xvc2VzdCkpLCBxMC5hZGQodi5zY2FsZSh0Q2xvc2VzdCkpKTtcclxufVxyXG5jb25zdCBDbG9zZXN0TGluZUp1bXBUYWJsZSA9IHtcclxuICAgIFBvbHlnb25Qb2x5Z29uQ2xvc2VzdExpbmUocG9seWdvbkEsIHBvbHlnb25CKSB7XHJcbiAgICAgICAgLy8gRmluZCB0aGUgMiBjbG9zZXN0IGZhY2VzIG9uIGVhY2ggcG9seWdvblxyXG4gICAgICAgIGNvbnN0IG90aGVyV29ybGRQb3MgPSBwb2x5Z29uQi53b3JsZFBvcztcclxuICAgICAgICBjb25zdCBvdGhlckRpcmVjdGlvbiA9IG90aGVyV29ybGRQb3Muc3ViKHBvbHlnb25BLndvcmxkUG9zKTtcclxuICAgICAgICBjb25zdCB0aGlzRGlyZWN0aW9uID0gb3RoZXJEaXJlY3Rpb24ubmVnYXRlKCk7XHJcbiAgICAgICAgY29uc3QgcmF5VG93YXJkc090aGVyID0gbmV3IFJheShwb2x5Z29uQS53b3JsZFBvcywgb3RoZXJEaXJlY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHJheVRvd2FyZHNUaGlzID0gbmV3IFJheShvdGhlcldvcmxkUG9zLCB0aGlzRGlyZWN0aW9uKTtcclxuICAgICAgICBjb25zdCB0aGlzUG9pbnQgPSBwb2x5Z29uQS5yYXlDYXN0KHJheVRvd2FyZHNPdGhlcikuYWRkKHJheVRvd2FyZHNPdGhlci5kaXIuc2NhbGUoMC4xKSk7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJQb2ludCA9IHBvbHlnb25CLnJheUNhc3QocmF5VG93YXJkc1RoaXMpLmFkZChyYXlUb3dhcmRzVGhpcy5kaXIuc2NhbGUoMC4xKSk7XHJcbiAgICAgICAgY29uc3QgdGhpc0ZhY2UgPSBwb2x5Z29uQS5nZXRDbG9zZXN0RmFjZSh0aGlzUG9pbnQpO1xyXG4gICAgICAgIGNvbnN0IG90aGVyRmFjZSA9IHBvbHlnb25CLmdldENsb3Nlc3RGYWNlKG90aGVyUG9pbnQpO1xyXG4gICAgICAgIC8vIEwxID0gUChzKSA9IHAwICsgcyAqIHUsIHdoZXJlIHMgaXMgdGltZSBhbmQgcDAgaXMgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgICAgY29uc3QgcDAgPSB0aGlzRmFjZS5mYWNlLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IHUgPSB0aGlzRmFjZS5mYWNlLmdldEVkZ2UoKTtcclxuICAgICAgICAvLyBMMiA9IFEodCkgPSBxMCArIHQgKiB2LCB3aGVyZSB0IGlzIHRpbWUgYW5kIHEwIGlzIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICAgIGNvbnN0IHEwID0gb3RoZXJGYWNlLmZhY2UuYmVnaW47XHJcbiAgICAgICAgY29uc3QgdiA9IG90aGVyRmFjZS5mYWNlLmdldEVkZ2UoKTtcclxuICAgICAgICByZXR1cm4gQ2xvc2VzdExpbmUocDAsIHUsIHEwLCB2KTtcclxuICAgIH0sXHJcbiAgICBQb2x5Z29uRWRnZUNsb3Nlc3RMaW5lKHBvbHlnb24sIGVkZ2UpIHtcclxuICAgICAgICAvLyBGaW5kIHRoZSAyIGNsb3Nlc3QgZmFjZXMgb24gZWFjaCBwb2x5Z29uXHJcbiAgICAgICAgY29uc3Qgb3RoZXJXb3JsZFBvcyA9IGVkZ2Uud29ybGRQb3M7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJEaXJlY3Rpb24gPSBvdGhlcldvcmxkUG9zLnN1Yihwb2x5Z29uLndvcmxkUG9zKTtcclxuICAgICAgICBjb25zdCByYXlUb3dhcmRzT3RoZXIgPSBuZXcgUmF5KHBvbHlnb24ud29ybGRQb3MsIG90aGVyRGlyZWN0aW9uKTtcclxuICAgICAgICBjb25zdCB0aGlzUG9pbnQgPSBwb2x5Z29uLnJheUNhc3QocmF5VG93YXJkc090aGVyKS5hZGQocmF5VG93YXJkc090aGVyLmRpci5zY2FsZSgwLjEpKTtcclxuICAgICAgICBjb25zdCB0aGlzRmFjZSA9IHBvbHlnb24uZ2V0Q2xvc2VzdEZhY2UodGhpc1BvaW50KTtcclxuICAgICAgICAvLyBMMSA9IFAocykgPSBwMCArIHMgKiB1LCB3aGVyZSBzIGlzIHRpbWUgYW5kIHAwIGlzIHRoZSBzdGFydCBvZiB0aGUgbGluZVxyXG4gICAgICAgIGNvbnN0IHAwID0gdGhpc0ZhY2UuZmFjZS5iZWdpbjtcclxuICAgICAgICBjb25zdCB1ID0gdGhpc0ZhY2UuZmFjZS5nZXRFZGdlKCk7XHJcbiAgICAgICAgLy8gTDIgPSBRKHQpID0gcTAgKyB0ICogdiwgd2hlcmUgdCBpcyB0aW1lIGFuZCBxMCBpcyB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICAgICAgICBjb25zdCBlZGdlTGluZSA9IGVkZ2UuYXNMaW5lKCk7XHJcbiAgICAgICAgY29uc3QgZWRnZVN0YXJ0ID0gZWRnZUxpbmUuYmVnaW47XHJcbiAgICAgICAgY29uc3QgZWRnZVZlY3RvciA9IGVkZ2VMaW5lLmdldEVkZ2UoKTtcclxuICAgICAgICBjb25zdCBxMCA9IGVkZ2VTdGFydDtcclxuICAgICAgICBjb25zdCB2ID0gZWRnZVZlY3RvcjtcclxuICAgICAgICByZXR1cm4gQ2xvc2VzdExpbmUocDAsIHUsIHEwLCB2KTtcclxuICAgIH0sXHJcbiAgICBQb2x5Z29uQ2lyY2xlQ2xvc2VzdExpbmUocG9seWdvbiwgY2lyY2xlKSB7XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xOTE5MTc3L2hvdy10by1maW5kLXBvaW50LW9uLWxpbmUtY2xvc2VzdC10by1zcGhlcmVcclxuICAgICAgICAvLyBGaW5kIHRoZSAyIGNsb3Nlc3QgZmFjZXMgb24gZWFjaCBwb2x5Z29uXHJcbiAgICAgICAgY29uc3Qgb3RoZXJXb3JsZFBvcyA9IGNpcmNsZS53b3JsZFBvcztcclxuICAgICAgICBjb25zdCBvdGhlckRpcmVjdGlvbiA9IG90aGVyV29ybGRQb3Muc3ViKHBvbHlnb24ud29ybGRQb3MpO1xyXG4gICAgICAgIGNvbnN0IHJheVRvd2FyZHNPdGhlciA9IG5ldyBSYXkocG9seWdvbi53b3JsZFBvcywgb3RoZXJEaXJlY3Rpb24ubm9ybWFsaXplKCkpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNQb2ludCA9IHBvbHlnb24ucmF5Q2FzdChyYXlUb3dhcmRzT3RoZXIpLmFkZChyYXlUb3dhcmRzT3RoZXIuZGlyLnNjYWxlKDAuMSkpO1xyXG4gICAgICAgIGNvbnN0IHRoaXNGYWNlID0gcG9seWdvbi5nZXRDbG9zZXN0RmFjZSh0aGlzUG9pbnQpO1xyXG4gICAgICAgIC8vIEwxID0gUChzKSA9IHAwICsgcyAqIHUsIHdoZXJlIHMgaXMgdGltZSBhbmQgcDAgaXMgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgICAgY29uc3QgcDAgPSB0aGlzRmFjZS5mYWNlLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IHUgPSB0aGlzRmFjZS5mYWNlLmdldEVkZ2UoKTtcclxuICAgICAgICAvLyBUaW1lIG9mIG1pbmltdW0gZGlzdGFuY2VcclxuICAgICAgICBsZXQgdCA9ICh1LnggKiAob3RoZXJXb3JsZFBvcy54IC0gcDAueCkgKyB1LnkgKiAob3RoZXJXb3JsZFBvcy55IC0gcDAueSkpIC8gKHUueCAqIHUueCArIHUueSAqIHUueSk7XHJcbiAgICAgICAgLy8gSWYgdGltZSBvZiBtaW5pbXVtIGlzIHBhc3QgdGhlIGVkZ2UgY2xhbXBcclxuICAgICAgICBpZiAodCA+IDEpIHtcclxuICAgICAgICAgICAgdCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHQgPCAwKSB7XHJcbiAgICAgICAgICAgIHQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNaW5pbXVtIGRpc3RhbmNlXHJcbiAgICAgICAgY29uc3QgZCA9IE1hdGguc3FydChNYXRoLnBvdyhwMC54ICsgdS54ICogdCAtIG90aGVyV29ybGRQb3MueCwgMikgKyBNYXRoLnBvdyhwMC55ICsgdS55ICogdCAtIG90aGVyV29ybGRQb3MueSwgMikpIC0gY2lyY2xlLnJhZGl1cztcclxuICAgICAgICBjb25zdCBjaXJjbGV4ID0gKChwMC54ICsgdS54ICogdCAtIG90aGVyV29ybGRQb3MueCkgKiBjaXJjbGUucmFkaXVzKSAvIChjaXJjbGUucmFkaXVzICsgZCk7XHJcbiAgICAgICAgY29uc3QgY2lyY2xleSA9ICgocDAueSArIHUueSAqIHQgLSBvdGhlcldvcmxkUG9zLnkpICogY2lyY2xlLnJhZGl1cykgLyAoY2lyY2xlLnJhZGl1cyArIGQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZSh1LnNjYWxlKHQpLmFkZChwMCksIG5ldyBWZWN0b3Iob3RoZXJXb3JsZFBvcy54ICsgY2lyY2xleCwgb3RoZXJXb3JsZFBvcy55ICsgY2lyY2xleSkpO1xyXG4gICAgfSxcclxuICAgIENpcmNsZUNpcmNsZUNsb3Nlc3RMaW5lKGNpcmNsZUEsIGNpcmNsZUIpIHtcclxuICAgICAgICAvLyBGaW5kIHRoZSAyIGNsb3Nlc3QgZmFjZXMgb24gZWFjaCBwb2x5Z29uXHJcbiAgICAgICAgY29uc3Qgb3RoZXJXb3JsZFBvcyA9IGNpcmNsZUIud29ybGRQb3M7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJEaXJlY3Rpb24gPSBvdGhlcldvcmxkUG9zLnN1YihjaXJjbGVBLndvcmxkUG9zKTtcclxuICAgICAgICBjb25zdCB0aGlzV29ybGRQb3MgPSBjaXJjbGVBLndvcmxkUG9zO1xyXG4gICAgICAgIGNvbnN0IHRoaXNEaXJlY3Rpb24gPSB0aGlzV29ybGRQb3Muc3ViKGNpcmNsZUIud29ybGRQb3MpO1xyXG4gICAgICAgIGNvbnN0IHJheVRvd2FyZHNPdGhlciA9IG5ldyBSYXkoY2lyY2xlQS53b3JsZFBvcywgb3RoZXJEaXJlY3Rpb24pO1xyXG4gICAgICAgIGNvbnN0IHJheVRvd2FyZHNUaGlzID0gbmV3IFJheShjaXJjbGVCLndvcmxkUG9zLCB0aGlzRGlyZWN0aW9uKTtcclxuICAgICAgICBjb25zdCB0aGlzUG9pbnQgPSBjaXJjbGVBLnJheUNhc3QocmF5VG93YXJkc090aGVyKTtcclxuICAgICAgICBjb25zdCBvdGhlclBvaW50ID0gY2lyY2xlQi5yYXlDYXN0KHJheVRvd2FyZHNUaGlzKTtcclxuICAgICAgICByZXR1cm4gbmV3IExpbmUodGhpc1BvaW50LCBvdGhlclBvaW50KTtcclxuICAgIH0sXHJcbiAgICBDaXJjbGVFZGdlQ2xvc2VzdExpbmUoY2lyY2xlLCBlZGdlKSB7XHJcbiAgICAgICAgLy8gaHR0cHM6Ly9tYXRoLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy8xOTE5MTc3L2hvdy10by1maW5kLXBvaW50LW9uLWxpbmUtY2xvc2VzdC10by1zcGhlcmVcclxuICAgICAgICBjb25zdCBjaXJjbGVXb3JsUG9zID0gY2lyY2xlLndvcmxkUG9zO1xyXG4gICAgICAgIC8vIEwxID0gUChzKSA9IHAwICsgcyAqIHUsIHdoZXJlIHMgaXMgdGltZSBhbmQgcDAgaXMgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgICAgY29uc3QgZWRnZUxpbmUgPSBlZGdlLmFzTGluZSgpO1xyXG4gICAgICAgIGNvbnN0IGVkZ2VTdGFydCA9IGVkZ2VMaW5lLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IGVkZ2VWZWN0b3IgPSBlZGdlTGluZS5nZXRFZGdlKCk7XHJcbiAgICAgICAgY29uc3QgcDAgPSBlZGdlU3RhcnQ7XHJcbiAgICAgICAgY29uc3QgdSA9IGVkZ2VWZWN0b3I7XHJcbiAgICAgICAgLy8gVGltZSBvZiBtaW5pbXVtIGRpc3RhbmNlXHJcbiAgICAgICAgbGV0IHQgPSAodS54ICogKGNpcmNsZVdvcmxQb3MueCAtIHAwLngpICsgdS55ICogKGNpcmNsZVdvcmxQb3MueSAtIHAwLnkpKSAvICh1LnggKiB1LnggKyB1LnkgKiB1LnkpO1xyXG4gICAgICAgIC8vIElmIHRpbWUgb2YgbWluaW11bSBpcyBwYXN0IHRoZSBlZGdlIGNsYW1wIHRvIGVkZ2VcclxuICAgICAgICBpZiAodCA+IDEpIHtcclxuICAgICAgICAgICAgdCA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHQgPCAwKSB7XHJcbiAgICAgICAgICAgIHQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNaW5pbXVtIGRpc3RhbmNlXHJcbiAgICAgICAgY29uc3QgZCA9IE1hdGguc3FydChNYXRoLnBvdyhwMC54ICsgdS54ICogdCAtIGNpcmNsZVdvcmxQb3MueCwgMikgKyBNYXRoLnBvdyhwMC55ICsgdS55ICogdCAtIGNpcmNsZVdvcmxQb3MueSwgMikpIC0gY2lyY2xlLnJhZGl1cztcclxuICAgICAgICBjb25zdCBjaXJjbGV4ID0gKChwMC54ICsgdS54ICogdCAtIGNpcmNsZVdvcmxQb3MueCkgKiBjaXJjbGUucmFkaXVzKSAvIChjaXJjbGUucmFkaXVzICsgZCk7XHJcbiAgICAgICAgY29uc3QgY2lyY2xleSA9ICgocDAueSArIHUueSAqIHQgLSBjaXJjbGVXb3JsUG9zLnkpICogY2lyY2xlLnJhZGl1cykgLyAoY2lyY2xlLnJhZGl1cyArIGQpO1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZSh1LnNjYWxlKHQpLmFkZChwMCksIG5ldyBWZWN0b3IoY2lyY2xlV29ybFBvcy54ICsgY2lyY2xleCwgY2lyY2xlV29ybFBvcy55ICsgY2lyY2xleSkpO1xyXG4gICAgfSxcclxuICAgIEVkZ2VFZGdlQ2xvc2VzdExpbmUoZWRnZUEsIGVkZ2VCKSB7XHJcbiAgICAgICAgLy8gTDEgPSBQKHMpID0gcDAgKyBzICogdSwgd2hlcmUgcyBpcyB0aW1lIGFuZCBwMCBpcyB0aGUgc3RhcnQgb2YgdGhlIGxpbmVcclxuICAgICAgICBjb25zdCBlZGdlTGluZUEgPSBlZGdlQS5hc0xpbmUoKTtcclxuICAgICAgICBjb25zdCBlZGdlU3RhcnRBID0gZWRnZUxpbmVBLmJlZ2luO1xyXG4gICAgICAgIGNvbnN0IGVkZ2VWZWN0b3JBID0gZWRnZUxpbmVBLmdldEVkZ2UoKTtcclxuICAgICAgICBjb25zdCBwMCA9IGVkZ2VTdGFydEE7XHJcbiAgICAgICAgY29uc3QgdSA9IGVkZ2VWZWN0b3JBO1xyXG4gICAgICAgIC8vIEwyID0gUSh0KSA9IHEwICsgdCAqIHYsIHdoZXJlIHQgaXMgdGltZSBhbmQgcTAgaXMgdGhlIHN0YXJ0IG9mIHRoZSBsaW5lXHJcbiAgICAgICAgY29uc3QgZWRnZUxpbmVCID0gZWRnZUIuYXNMaW5lKCk7XHJcbiAgICAgICAgY29uc3QgZWRnZVN0YXJ0QiA9IGVkZ2VMaW5lQi5iZWdpbjtcclxuICAgICAgICBjb25zdCBlZGdlVmVjdG9yQiA9IGVkZ2VMaW5lQi5nZXRFZGdlKCk7XHJcbiAgICAgICAgY29uc3QgcTAgPSBlZGdlU3RhcnRCO1xyXG4gICAgICAgIGNvbnN0IHYgPSBlZGdlVmVjdG9yQjtcclxuICAgICAgICByZXR1cm4gQ2xvc2VzdExpbmUocDAsIHUsIHEwLCB2KTtcclxuICAgIH1cclxufTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQ29sbGlkZXJzL0NpcmNsZUNvbGxpZGVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhpcyBpcyBhIGNpcmNsZSBjb2xsaWRlciBmb3IgdGhlIGV4Y2FsaWJ1ciByaWdpZCBib2R5IHBoeXNpY3Mgc2ltdWxhdGlvblxyXG4gKi9cclxuY2xhc3MgQ2lyY2xlQ29sbGlkZXIgZXh0ZW5kcyBDb2xsaWRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQb3NpdGlvbiBvZiB0aGUgY2lyY2xlIHJlbGF0aXZlIHRvIHRoZSBjb2xsaWRlciwgYnkgZGVmYXVsdCAoMCwgMCkuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLm9mZnNldCA9IG9wdGlvbnMub2Zmc2V0IHx8IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gb3B0aW9ucy5yYWRpdXMgfHwgMDtcclxuICAgIH1cclxuICAgIGdldCB3b3JsZFBvcygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiB0aGlzLm9mZnNldC5hZGQoKF9iID0gKF9hID0gdGhpcy5fdHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBWZWN0b3IuWmVybyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjbG9uZSBvZiB0aGlzIHNoYXBlLCBub3QgYXNzb2NpYXRlZCB3aXRoIGFueSBjb2xsaWRlclxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IENpcmNsZUNvbGxpZGVyKHtcclxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldC5jbG9uZSgpLFxyXG4gICAgICAgICAgICByYWRpdXM6IHRoaXMucmFkaXVzXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2VudGVyIG9mIHRoZSBjb2xsaWRlciBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0LmFkZCgoX2IgPSAoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFZlY3Rvci5aZXJvKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBjb250YWluZWQgaW4gdGhpcyBjb2xsaWRlclxyXG4gICAgICovXHJcbiAgICBjb250YWlucyhwb2ludCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgcG9zID0gKF9iID0gKF9hID0gdGhpcy5fdHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLm9mZnNldDtcclxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IHBvcy5kaXN0YW5jZShwb2ludCk7XHJcbiAgICAgICAgaWYgKGRpc3RhbmNlIDw9IHRoaXMucmFkaXVzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhc3RzIGEgcmF5IGF0IHRoZSBDaXJjbGUgY29sbGlkZXIgYW5kIHJldHVybnMgdGhlIG5lYXJlc3QgcG9pbnQgb2YgY29sbGlzaW9uXHJcbiAgICAgKiBAcGFyYW0gcmF5XHJcbiAgICAgKi9cclxuICAgIHJheUNhc3QocmF5LCBtYXggPSBJbmZpbml0eSkge1xyXG4gICAgICAgIC8vaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGluZSVFMiU4MCU5M3NwaGVyZV9pbnRlcnNlY3Rpb25cclxuICAgICAgICBjb25zdCBjID0gdGhpcy5jZW50ZXI7XHJcbiAgICAgICAgY29uc3QgZGlyID0gcmF5LmRpcjtcclxuICAgICAgICBjb25zdCBvcmlnID0gcmF5LnBvcztcclxuICAgICAgICBjb25zdCBkaXNjcmltaW5hbnQgPSBNYXRoLnNxcnQoTWF0aC5wb3coZGlyLmRvdChvcmlnLnN1YihjKSksIDIpIC0gTWF0aC5wb3cob3JpZy5zdWIoYykuZGlzdGFuY2UoKSwgMikgKyBNYXRoLnBvdyh0aGlzLnJhZGl1cywgMikpO1xyXG4gICAgICAgIGlmIChkaXNjcmltaW5hbnQgPCAwKSB7XHJcbiAgICAgICAgICAgIC8vIG5vIGludGVyc2VjdGlvblxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCB0b2kgPSAwO1xyXG4gICAgICAgICAgICBpZiAoZGlzY3JpbWluYW50ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICB0b2kgPSAtZGlyLmRvdChvcmlnLnN1YihjKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodG9pID4gMCAmJiB0b2kgPCBtYXgpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmF5LmdldFBvaW50KHRvaSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRvaTEgPSAtZGlyLmRvdChvcmlnLnN1YihjKSkgKyBkaXNjcmltaW5hbnQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0b2kyID0gLWRpci5kb3Qob3JpZy5zdWIoYykpIC0gZGlzY3JpbWluYW50O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpdmVUb2kgPSBbXTtcclxuICAgICAgICAgICAgICAgIGlmICh0b2kxID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGl2ZVRvaS5wdXNoKHRvaTEpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHRvaTIgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aXZlVG9pLnB1c2godG9pMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBtaW50b2kgPSBNYXRoLm1pbiguLi5wb3NpdGl2ZVRvaSk7XHJcbiAgICAgICAgICAgICAgICBpZiAobWludG9pIDw9IG1heCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByYXkuZ2V0UG9pbnQobWludG9pKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0Q2xvc2VzdExpbmVCZXR3ZWVuKHNoYXBlKSB7XHJcbiAgICAgICAgaWYgKHNoYXBlIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLkNpcmNsZUNpcmNsZUNsb3Nlc3RMaW5lKHRoaXMsIHNoYXBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hhcGUgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLlBvbHlnb25DaXJjbGVDbG9zZXN0TGluZShzaGFwZSwgdGhpcykuZmxpcCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzaGFwZSBpbnN0YW5jZW9mIEVkZ2VDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2xvc2VzdExpbmVKdW1wVGFibGUuQ2lyY2xlRWRnZUNsb3Nlc3RMaW5lKHRoaXMsIHNoYXBlKS5mbGlwKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvbHlnb24gY291bGQgbm90IGNvbGxpZGUgd2l0aCB1bmtub3duIENvbGxpc2lvblNoYXBlICR7dHlwZW9mIHNoYXBlfWApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGluaGVyaXRkb2NcclxuICAgICAqL1xyXG4gICAgY29sbGlkZShjb2xsaWRlcikge1xyXG4gICAgICAgIGlmIChjb2xsaWRlciBpbnN0YW5jZW9mIENpcmNsZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUNpcmNsZUNpcmNsZSh0aGlzLCBjb2xsaWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgUG9seWdvbkNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUNpcmNsZVBvbHlnb24odGhpcywgY29sbGlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2xsaWRlciBpbnN0YW5jZW9mIEVkZ2VDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVFZGdlKHRoaXMsIGNvbGxpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2lyY2xlIGNvdWxkIG5vdCBjb2xsaWRlIHdpdGggdW5rbm93biBDb2xsaXNpb25TaGFwZSAke3R5cGVvZiBjb2xsaWRlcn1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBjb2xsaWRlciBmdXJ0aGVzdCBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICovXHJcbiAgICBnZXRGdXJ0aGVzdFBvaW50KGRpcmVjdGlvbikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlci5hZGQoZGlyZWN0aW9uLm5vcm1hbGl6ZSgpLnNjYWxlKHRoaXMucmFkaXVzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGxvY2FsIHBvaW50IG9uIHRoZSBzaGFwZSBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICogQHBhcmFtIGRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBnZXRGdXJ0aGVzdExvY2FsUG9pbnQoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgZGlyID0gZGlyZWN0aW9uLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIHJldHVybiBkaXIuc2NhbGUodGhpcy5yYWRpdXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIHRoZSBjaXJjbGUgY29sbGlkZXIgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgZ2V0IGJvdW5kcygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgY29uc3QgdHggPSB0aGlzLl90cmFuc2Zvcm07XHJcbiAgICAgICAgY29uc3QgYm9keVBvcyA9IChfYSA9IHR4ID09PSBudWxsIHx8IHR4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eC5nbG9iYWxQb3MpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhpcy5vZmZzZXQueCArIGJvZHlQb3MueCAtIHRoaXMucmFkaXVzLCB0aGlzLm9mZnNldC55ICsgYm9keVBvcy55IC0gdGhpcy5yYWRpdXMsIHRoaXMub2Zmc2V0LnggKyBib2R5UG9zLnggKyB0aGlzLnJhZGl1cywgdGhpcy5vZmZzZXQueSArIGJvZHlQb3MueSArIHRoaXMucmFkaXVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBheGlzIGFsaWduZWQgYm91bmRpbmcgYm94IGZvciB0aGUgY2lyY2xlIGNvbGxpZGVyIGluIGxvY2FsIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHRoaXMub2Zmc2V0LnggLSB0aGlzLnJhZGl1cywgdGhpcy5vZmZzZXQueSAtIHRoaXMucmFkaXVzLCB0aGlzLm9mZnNldC54ICsgdGhpcy5yYWRpdXMsIHRoaXMub2Zmc2V0LnkgKyB0aGlzLnJhZGl1cyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBheGlzIG5vdCBpbXBsZW1lbnRlZCBvbiBjaXJjbGVzLCBzaW5jZSB0aGVyZSBhcmUgaW5maW5pdGUgYXhpcyBpbiBhIGNpcmNsZVxyXG4gICAgICovXHJcbiAgICBnZXQgYXhlcygpIHtcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1vbWVudCBvZiBpbmVydGlhIG9mIGEgY2lyY2xlIGdpdmVuIGl0J3MgbWFzc1xyXG4gICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcclxuICAgICAqL1xyXG4gICAgZ2V0SW5lcnRpYShtYXNzKSB7XHJcbiAgICAgICAgcmV0dXJuIChtYXNzICogdGhpcy5yYWRpdXMgKiB0aGlzLnJhZGl1cykgLyAyO1xyXG4gICAgfVxyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIHVwZGF0ZSh0cmFuc2Zvcm0pIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb2plY3QgdGhlIGNpcmNsZSBhbG9uZyBhIHNwZWNpZmllZCBheGlzXHJcbiAgICAgKi9cclxuICAgIHByb2plY3QoYXhpcykge1xyXG4gICAgICAgIGNvbnN0IHNjYWxhcnMgPSBbXTtcclxuICAgICAgICBjb25zdCBwb2ludCA9IHRoaXMuY2VudGVyO1xyXG4gICAgICAgIGNvbnN0IGRvdFByb2R1Y3QgPSBwb2ludC5kb3QoYXhpcyk7XHJcbiAgICAgICAgc2NhbGFycy5wdXNoKGRvdFByb2R1Y3QpO1xyXG4gICAgICAgIHNjYWxhcnMucHVzaChkb3RQcm9kdWN0ICsgdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgIHNjYWxhcnMucHVzaChkb3RQcm9kdWN0IC0gdGhpcy5yYWRpdXMpO1xyXG4gICAgICAgIHJldHVybiBuZXcgUHJvamVjdGlvbihNYXRoLm1pbi5hcHBseShNYXRoLCBzY2FsYXJzKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgc2NhbGFycykpO1xyXG4gICAgfVxyXG4gICAgZHJhdyhjdHgsIGNvbG9yID0gQ29sb3IuR3JlZW4sIHBvcyA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgY29uc3QgbmV3UG9zID0gcG9zLmFkZCh0aGlzLm9mZnNldCk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5hcmMobmV3UG9zLngsIG5ld1Bvcy55LCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgfVxyXG4gICAgZGVidWcoZXgsIGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgdHggPSB0aGlzLl90cmFuc2Zvcm07XHJcbiAgICAgICAgY29uc3QgcG9zID0gKHR4ID09PSBudWxsIHx8IHR4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eC5nbG9iYWxQb3MpID8gdHggPT09IG51bGwgfHwgdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR4Lmdsb2JhbFBvcy5hZGQodGhpcy5vZmZzZXQpIDogdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgZXguZHJhd0NpcmNsZShwb3MsIHRoaXMucmFkaXVzLCBjb2xvcik7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgZGVidWdEcmF3KGN0eCwgY29sb3IgPSBDb2xvci5HcmVlbikge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMuX3RyYW5zZm9ybTtcclxuICAgICAgICBjb25zdCBwb3MgPSB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0ucG9zLmFkZCh0aGlzLm9mZnNldCkgOiB0aGlzLm9mZnNldDtcclxuICAgICAgICBjb25zdCByb3RhdGlvbiA9IHRyYW5zZm9ybSA/IHRyYW5zZm9ybS5yb3RhdGlvbiA6IDA7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmFyYyhwb3MueCwgcG9zLnksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyhwb3MueCwgcG9zLnkpO1xyXG4gICAgICAgIGN0eC5saW5lVG8oTWF0aC5jb3Mocm90YXRpb24pICogdGhpcy5yYWRpdXMgKyBwb3MueCwgTWF0aC5zaW4ocm90YXRpb24pICogdGhpcy5yYWRpdXMgKyBwb3MueSk7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9EZXRlY3Rpb24vQ29sbGlzaW9uQ29udGFjdC50c1xuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb2xsaXNpb24gY29udGFjdHMgYXJlIHVzZWQgaW50ZXJuYWxseSBieSBFeGNhbGlidXIgdG8gcmVzb2x2ZSBjb2xsaXNpb24gYmV0d2VlbiBjb2xsaWRlcnMuIFRoaXNcclxuICogUGFpciBwcmV2ZW50cyBjb2xsaXNpb25zIGZyb20gYmVpbmcgZXZhbHVhdGVkIG1vcmUgdGhhbiBvbmUgdGltZVxyXG4gKi9cclxuY2xhc3MgQ29sbGlzaW9uQ29udGFjdCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xsaWRlckEsIGNvbGxpZGVyQiwgbXR2LCBub3JtYWwsIHRhbmdlbnQsIHBvaW50cywgbG9jYWxQb2ludHMsIGluZm8pIHtcclxuICAgICAgICB0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuY29sbGlkZXJBID0gY29sbGlkZXJBO1xyXG4gICAgICAgIHRoaXMuY29sbGlkZXJCID0gY29sbGlkZXJCO1xyXG4gICAgICAgIHRoaXMubXR2ID0gbXR2O1xyXG4gICAgICAgIHRoaXMubm9ybWFsID0gbm9ybWFsO1xyXG4gICAgICAgIHRoaXMudGFuZ2VudCA9IHRhbmdlbnQ7XHJcbiAgICAgICAgdGhpcy5wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgdGhpcy5sb2NhbFBvaW50cyA9IGxvY2FsUG9pbnRzO1xyXG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XHJcbiAgICAgICAgdGhpcy5pZCA9IFBhaXIuY2FsY3VsYXRlUGFpckhhc2goY29sbGlkZXJBLmlkLCBjb2xsaWRlckIuaWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNYXRjaCBjb250YWN0IGF3YWtlIHN0YXRlLCBleGNlcHQgaWYgYm9keSdzIGFyZSBGaXhlZFxyXG4gICAgICovXHJcbiAgICBtYXRjaEF3YWtlKCkge1xyXG4gICAgICAgIGNvbnN0IGJvZHlBID0gdGhpcy5jb2xsaWRlckEub3duZXIuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgIGNvbnN0IGJvZHlCID0gdGhpcy5jb2xsaWRlckIub3duZXIuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChib2R5QSAmJiBib2R5Qikge1xyXG4gICAgICAgICAgICBpZiAoYm9keUEuc2xlZXBpbmcgIT09IGJvZHlCLnNsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuc2xlZXBpbmcgJiYgYm9keUEuY29sbGlzaW9uVHlwZSAhPT0gQ29sbGlzaW9uVHlwZS5GaXhlZCAmJiBib2R5Qi5zbGVlcE1vdGlvbiA+PSBQaHlzaWNzLndha2VUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5zZXRTbGVlcGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUIuc2xlZXBpbmcgJiYgYm9keUIuY29sbGlzaW9uVHlwZSAhPT0gQ29sbGlzaW9uVHlwZS5GaXhlZCAmJiBib2R5QS5zbGVlcE1vdGlvbiA+PSBQaHlzaWNzLndha2VUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5zZXRTbGVlcGluZyhmYWxzZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NhbmNlbGVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jYW5jZWxlZDtcclxuICAgIH1cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICB0aGlzLl9jYW5jZWxlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQ29sbGlkZXJzL1NlcGFyYXRpbmdBeGlzLnRzXG5jbGFzcyBTZXBhcmF0aW5nQXhpcyB7XHJcbiAgICBzdGF0aWMgZmluZFBvbHlnb25Qb2x5Z29uU2VwYXJhdGlvbihwb2x5QSwgcG9seUIpIHtcclxuICAgICAgICBsZXQgYmVzdFNlcGFyYXRpb24gPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBsZXQgYmVzdFNpZGUgPSBudWxsO1xyXG4gICAgICAgIGxldCBiZXN0QXhpcyA9IG51bGw7XHJcbiAgICAgICAgbGV0IGJlc3RTaWRlSW5kZXggPSAtMTtcclxuICAgICAgICBsZXQgYmVzdE90aGVyUG9pbnQgPSBudWxsO1xyXG4gICAgICAgIGNvbnN0IHNpZGVzID0gcG9seUEuZ2V0U2lkZXMoKTtcclxuICAgICAgICBjb25zdCBsb2NhbFNpZGVzID0gcG9seUEuZ2V0TG9jYWxTaWRlcygpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lkZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3Qgc2lkZSA9IHNpZGVzW2ldO1xyXG4gICAgICAgICAgICBjb25zdCBheGlzID0gc2lkZS5ub3JtYWwoKTtcclxuICAgICAgICAgICAgY29uc3QgdmVydEIgPSBwb2x5Qi5nZXRGdXJ0aGVzdFBvaW50KGF4aXMubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICAvLyBTZXBhcmF0aW9uIG9uIHNpZGUgaSdzIGF4aXNcclxuICAgICAgICAgICAgLy8gV2UgYXJlIGxvb2tpbmcgZm9yIHRoZSBsYXJnZXN0IHNlcGFyYXRpb24gYmV0d2VlbiBwb2x5IEEncyBzaWRlc1xyXG4gICAgICAgICAgICBjb25zdCB2ZXJ0U2VwYXJhdGlvbiA9IHNpZGUuZGlzdGFuY2VUb1BvaW50KHZlcnRCLCB0cnVlKTtcclxuICAgICAgICAgICAgaWYgKHZlcnRTZXBhcmF0aW9uID4gYmVzdFNlcGFyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGJlc3RTZXBhcmF0aW9uID0gdmVydFNlcGFyYXRpb247XHJcbiAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IHNpZGU7XHJcbiAgICAgICAgICAgICAgICBiZXN0QXhpcyA9IGF4aXM7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2lkZUluZGV4ID0gaTtcclxuICAgICAgICAgICAgICAgIGJlc3RPdGhlclBvaW50ID0gdmVydEI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY29sbGlkZXI6IHBvbHlBLFxyXG4gICAgICAgICAgICBzZXBhcmF0aW9uOiBiZXN0QXhpcyA/IGJlc3RTZXBhcmF0aW9uIDogOTksXHJcbiAgICAgICAgICAgIGF4aXM6IGJlc3RBeGlzLFxyXG4gICAgICAgICAgICBzaWRlOiBiZXN0U2lkZSxcclxuICAgICAgICAgICAgbG9jYWxTaWRlOiBsb2NhbFNpZGVzW2Jlc3RTaWRlSW5kZXhdLFxyXG4gICAgICAgICAgICBzaWRlSWQ6IGJlc3RTaWRlSW5kZXgsXHJcbiAgICAgICAgICAgIHBvaW50OiBiZXN0T3RoZXJQb2ludCxcclxuICAgICAgICAgICAgbG9jYWxQb2ludDogYmVzdEF4aXMgPyBwb2x5Qi5nZXRGdXJ0aGVzdExvY2FsUG9pbnQoYmVzdEF4aXMubmVnYXRlKCkpIDogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZmluZENpcmNsZVBvbHlnb25TZXBhcmF0aW9uKGNpcmNsZSwgcG9seWdvbikge1xyXG4gICAgICAgIGNvbnN0IGF4ZXMgPSBwb2x5Z29uLmF4ZXM7XHJcbiAgICAgICAgY29uc3QgcGMgPSBwb2x5Z29uLmNlbnRlcjtcclxuICAgICAgICAvLyBTcGVjaWFsIFNBVCB3aXRoIGNpcmNsZXNcclxuICAgICAgICBjb25zdCBwb2x5RGlyID0gcGMuc3ViKGNpcmNsZS53b3JsZFBvcyk7XHJcbiAgICAgICAgY29uc3QgY2xvc2VzdFBvaW50T25Qb2x5ID0gcG9seWdvbi5nZXRGdXJ0aGVzdFBvaW50KHBvbHlEaXIubmVnYXRlKCkpO1xyXG4gICAgICAgIGF4ZXMucHVzaChjbG9zZXN0UG9pbnRPblBvbHkuc3ViKGNpcmNsZS53b3JsZFBvcykubm9ybWFsaXplKCkpO1xyXG4gICAgICAgIGxldCBtaW5PdmVybGFwID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBsZXQgbWluQXhpcyA9IG51bGw7XHJcbiAgICAgICAgbGV0IG1pbkluZGV4ID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBheGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByb2oxID0gcG9seWdvbi5wcm9qZWN0KGF4ZXNbaV0pO1xyXG4gICAgICAgICAgICBjb25zdCBwcm9qMiA9IGNpcmNsZS5wcm9qZWN0KGF4ZXNbaV0pO1xyXG4gICAgICAgICAgICBjb25zdCBvdmVybGFwID0gcHJvajEuZ2V0T3ZlcmxhcChwcm9qMik7XHJcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDw9IDApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXAgPCBtaW5PdmVybGFwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluT3ZlcmxhcCA9IG92ZXJsYXA7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluQXhpcyA9IGF4ZXNbaV07XHJcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSBpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChtaW5JbmRleCA8IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtaW5BeGlzLm5vcm1hbGl6ZSgpLnNjYWxlKG1pbk92ZXJsYXApO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpZGVycy9Db2xsaXNpb25KdW1wVGFibGUudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY29uc3QgQ29sbGlzaW9uSnVtcFRhYmxlID0ge1xyXG4gICAgQ29sbGlkZUNpcmNsZUNpcmNsZShjaXJjbGVBLCBjaXJjbGVCKSB7XHJcbiAgICAgICAgY29uc3QgY2lyY2xlQVBvcyA9IGNpcmNsZUEud29ybGRQb3M7XHJcbiAgICAgICAgY29uc3QgY2lyY2xlQlBvcyA9IGNpcmNsZUIud29ybGRQb3M7XHJcbiAgICAgICAgY29uc3QgY29tYmluZWRSYWRpdXMgPSBjaXJjbGVBLnJhZGl1cyArIGNpcmNsZUIucmFkaXVzO1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gY2lyY2xlQVBvcy5kaXN0YW5jZShjaXJjbGVCUG9zKTtcclxuICAgICAgICBpZiAoZGlzdGFuY2UgPiBjb21iaW5lZFJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5lZ2F0aXZlIG1lYW5zIG92ZXJsYXBcclxuICAgICAgICBjb25zdCBzZXBhcmF0aW9uID0gY29tYmluZWRSYWRpdXMgLSBkaXN0YW5jZTtcclxuICAgICAgICAvLyBOb3JtYWwgcG9pbnRzIGZyb20gQSAtPiBCXHJcbiAgICAgICAgY29uc3Qgbm9ybWFsID0gY2lyY2xlQlBvcy5zdWIoY2lyY2xlQVBvcykubm9ybWFsaXplKCk7XHJcbiAgICAgICAgY29uc3QgdGFuZ2VudCA9IG5vcm1hbC5wZXJwZW5kaWN1bGFyKCk7XHJcbiAgICAgICAgY29uc3QgbXZ0ID0gbm9ybWFsLnNjYWxlKHNlcGFyYXRpb24pO1xyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gY2lyY2xlQS5nZXRGdXJ0aGVzdFBvaW50KG5vcm1hbCk7XHJcbiAgICAgICAgY29uc3QgbG9jYWwgPSBjaXJjbGVBLmdldEZ1cnRoZXN0TG9jYWxQb2ludChub3JtYWwpO1xyXG4gICAgICAgIGNvbnN0IGluZm8gPSB7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyOiBjaXJjbGVBLFxyXG4gICAgICAgICAgICBzZXBhcmF0aW9uLFxyXG4gICAgICAgICAgICBheGlzOiBub3JtYWwsXHJcbiAgICAgICAgICAgIHBvaW50OiBwb2ludFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFtuZXcgQ29sbGlzaW9uQ29udGFjdChjaXJjbGVBLCBjaXJjbGVCLCBtdnQsIG5vcm1hbCwgdGFuZ2VudCwgW3BvaW50XSwgW2xvY2FsXSwgaW5mbyldO1xyXG4gICAgfSxcclxuICAgIENvbGxpZGVDaXJjbGVQb2x5Z29uKGNpcmNsZSwgcG9seWdvbikge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgbGV0IG1pbkF4aXMgPSBTZXBhcmF0aW5nQXhpcy5maW5kQ2lyY2xlUG9seWdvblNlcGFyYXRpb24oY2lyY2xlLCBwb2x5Z29uKTtcclxuICAgICAgICBpZiAoIW1pbkF4aXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgbWluQXhpcyBpcyBwb2ludGluZyBhd2F5IGZyb20gY2lyY2xlXHJcbiAgICAgICAgY29uc3Qgc2FtZWRpciA9IG1pbkF4aXMuZG90KHBvbHlnb24uY2VudGVyLnN1YihjaXJjbGUuY2VudGVyKSk7XHJcbiAgICAgICAgbWluQXhpcyA9IHNhbWVkaXIgPCAwID8gbWluQXhpcy5uZWdhdGUoKSA6IG1pbkF4aXM7XHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSBjaXJjbGUuZ2V0RnVydGhlc3RQb2ludChtaW5BeGlzKTtcclxuICAgICAgICBjb25zdCB4ZiA9IChfYiA9IChfYSA9IGNpcmNsZS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChUcmFuc2Zvcm1Db21wb25lbnQpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgVHJhbnNmb3JtQ29tcG9uZW50KCk7XHJcbiAgICAgICAgY29uc3QgbG9jYWwgPSB4Zi5hcHBseUludmVyc2UocG9pbnQpO1xyXG4gICAgICAgIGNvbnN0IG5vcm1hbCA9IG1pbkF4aXMubm9ybWFsaXplKCk7XHJcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcclxuICAgICAgICAgICAgY29sbGlkZXI6IGNpcmNsZSxcclxuICAgICAgICAgICAgc2VwYXJhdGlvbjogLW1pbkF4aXMuc2l6ZSxcclxuICAgICAgICAgICAgYXhpczogbm9ybWFsLFxyXG4gICAgICAgICAgICBwb2ludDogcG9pbnQsXHJcbiAgICAgICAgICAgIGxvY2FsUG9pbnQ6IGxvY2FsLFxyXG4gICAgICAgICAgICBzaWRlOiBwb2x5Z29uLmZpbmRTaWRlKG5vcm1hbC5uZWdhdGUoKSksXHJcbiAgICAgICAgICAgIGxvY2FsU2lkZTogcG9seWdvbi5maW5kTG9jYWxTaWRlKG5vcm1hbC5uZWdhdGUoKSlcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBbbmV3IENvbGxpc2lvbkNvbnRhY3QoY2lyY2xlLCBwb2x5Z29uLCBtaW5BeGlzLCBub3JtYWwsIG5vcm1hbC5wZXJwZW5kaWN1bGFyKCksIFtwb2ludF0sIFtsb2NhbF0sIGluZm8pXTtcclxuICAgIH0sXHJcbiAgICBDb2xsaWRlQ2lyY2xlRWRnZShjaXJjbGUsIGVkZ2UpIHtcclxuICAgICAgICAvLyBUT0RPIG5vdCBzdXJlIHRoaXMgYWN0dWFsbHkgYWJpZGVzIGJ5IGxvY2FsL3dvcmxkIGNvbGxpc2lvbnNcclxuICAgICAgICAvLyBBcmUgZWRnZS5iZWdpbiBhbmQgZWRnZS5lbmQgbG9jYWwgc3BhY2Ugb3Igd29ybGQgc3BhY2U/IEkgdGhpbmsgdGhleSBzaG91bGQgYmUgbG9jYWxcclxuICAgICAgICAvLyBjZW50ZXIgb2YgdGhlIGNpcmNsZSBpbiB3b3JsZCBwb3NcclxuICAgICAgICBjb25zdCBjYyA9IGNpcmNsZS5jZW50ZXI7XHJcbiAgICAgICAgLy8gdmVjdG9yIGluIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGVkZ2VcclxuICAgICAgICBjb25zdCBlZGdlV29ybGQgPSBlZGdlLmFzTGluZSgpO1xyXG4gICAgICAgIGNvbnN0IGUgPSBlZGdlV29ybGQuZW5kLnN1YihlZGdlV29ybGQuYmVnaW4pO1xyXG4gICAgICAgIC8vIGFtb3VudCBvZiBvdmVybGFwIHdpdGggdGhlIGNpcmNsZSdzIGNlbnRlciBhbG9uZyB0aGUgZWRnZSBkaXJlY3Rpb25cclxuICAgICAgICBjb25zdCB1ID0gZS5kb3QoZWRnZVdvcmxkLmVuZC5zdWIoY2MpKTtcclxuICAgICAgICBjb25zdCB2ID0gZS5kb3QoY2Muc3ViKGVkZ2VXb3JsZC5iZWdpbikpO1xyXG4gICAgICAgIGNvbnN0IHNpZGUgPSBlZGdlLmFzTGluZSgpO1xyXG4gICAgICAgIGNvbnN0IGxvY2FsU2lkZSA9IGVkZ2UuYXNMb2NhbExpbmUoKTtcclxuICAgICAgICAvLyBQb3RlbnRpYWwgcmVnaW9uIEEgY29sbGlzaW9uIChjaXJjbGUgaXMgb24gdGhlIGxlZnQgc2lkZSBvZiB0aGUgZWRnZSwgYmVmb3JlIHRoZSBiZWdpbm5pbmcpXHJcbiAgICAgICAgaWYgKHYgPD0gMCkge1xyXG4gICAgICAgICAgICBjb25zdCBkYSA9IGVkZ2VXb3JsZC5iZWdpbi5zdWIoY2MpO1xyXG4gICAgICAgICAgICBjb25zdCBkZGEgPSBkYS5kb3QoZGEpOyAvLyBxdWljayBhbmQgZGlydHkgd2F5IG9mIGNhbGMnbiBkaXN0YW5jZSBpbiByXjIgdGVybXMgc2F2ZXMgc29tZSBzcXJ0c1xyXG4gICAgICAgICAgICAvLyBzYXZlIHNvbWUgc3FydHNcclxuICAgICAgICAgICAgaWYgKGRkYSA+IGNpcmNsZS5yYWRpdXMgKiBjaXJjbGUucmFkaXVzKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gW107IC8vIG5vIGNvbGxpc2lvblxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IGRhLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBzZXBhcmF0aW9uID0gY2lyY2xlLnJhZGl1cyAtIE1hdGguc3FydChkZGEpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXI6IGNpcmNsZSxcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRpb246IHNlcGFyYXRpb24sXHJcbiAgICAgICAgICAgICAgICBheGlzOiBub3JtYWwsXHJcbiAgICAgICAgICAgICAgICBwb2ludDogc2lkZS5iZWdpbixcclxuICAgICAgICAgICAgICAgIHNpZGU6IHNpZGUsXHJcbiAgICAgICAgICAgICAgICBsb2NhbFNpZGU6IGxvY2FsU2lkZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByZXR1cm4gW1xyXG4gICAgICAgICAgICAgICAgbmV3IENvbGxpc2lvbkNvbnRhY3QoY2lyY2xlLCBlZGdlLCBub3JtYWwuc2NhbGUoc2VwYXJhdGlvbiksIG5vcm1hbCwgbm9ybWFsLnBlcnBlbmRpY3VsYXIoKSwgW3NpZGUuYmVnaW5dLCBbbG9jYWxTaWRlLmJlZ2luXSwgaW5mbylcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gUG90ZW50aWFsIHJlZ2lvbiBCIGNvbGxpc2lvbiAoY2lyY2xlIGlzIG9uIHRoZSByaWdodCBzaWRlIG9mIHRoZSBlZGdlLCBhZnRlciB0aGUgZW5kKVxyXG4gICAgICAgIGlmICh1IDw9IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZGIgPSBlZGdlV29ybGQuZW5kLnN1YihjYyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRkYiA9IGRiLmRvdChkYik7XHJcbiAgICAgICAgICAgIGlmIChkZGIgPiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IGRiLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBzZXBhcmF0aW9uID0gY2lyY2xlLnJhZGl1cyAtIE1hdGguc3FydChkZGIpO1xyXG4gICAgICAgICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXI6IGNpcmNsZSxcclxuICAgICAgICAgICAgICAgIHNlcGFyYXRpb246IHNlcGFyYXRpb24sXHJcbiAgICAgICAgICAgICAgICBheGlzOiBub3JtYWwsXHJcbiAgICAgICAgICAgICAgICBwb2ludDogc2lkZS5lbmQsXHJcbiAgICAgICAgICAgICAgICBzaWRlOiBzaWRlLFxyXG4gICAgICAgICAgICAgICAgbG9jYWxTaWRlOiBsb2NhbFNpZGVcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgICAgIG5ldyBDb2xsaXNpb25Db250YWN0KGNpcmNsZSwgZWRnZSwgbm9ybWFsLnNjYWxlKHNlcGFyYXRpb24pLCBub3JtYWwsIG5vcm1hbC5wZXJwZW5kaWN1bGFyKCksIFtzaWRlLmVuZF0sIFtsb2NhbFNpZGUuZW5kXSwgaW5mbylcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHBvdGVudGlhbCByZWdpb24gQUIgY29sbGlzaW9uIChjaXJjbGUgaXMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgZWRnZSBiZXR3ZWVuIHRoZSBiZWdpbm5pbmcgYW5kIGVuZClcclxuICAgICAgICBjb25zdCBkZW4gPSBlLmRvdChlKTtcclxuICAgICAgICBjb25zdCBwb2ludE9uRWRnZSA9IGVkZ2VXb3JsZC5iZWdpblxyXG4gICAgICAgICAgICAuc2NhbGUodSlcclxuICAgICAgICAgICAgLmFkZChlZGdlV29ybGQuZW5kLnNjYWxlKHYpKVxyXG4gICAgICAgICAgICAuc2NhbGUoMSAvIGRlbik7XHJcbiAgICAgICAgY29uc3QgZCA9IGNjLnN1Yihwb2ludE9uRWRnZSk7XHJcbiAgICAgICAgY29uc3QgZGQgPSBkLmRvdChkKTtcclxuICAgICAgICBpZiAoZGQgPiBjaXJjbGUucmFkaXVzICogY2lyY2xlLnJhZGl1cykge1xyXG4gICAgICAgICAgICByZXR1cm4gW107IC8vIG5vIGNvbGxpc2lvblxyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbm9ybWFsID0gZS5wZXJwZW5kaWN1bGFyKCk7XHJcbiAgICAgICAgLy8gZmxpcCBjb3JyZWN0IGRpcmVjdGlvblxyXG4gICAgICAgIGlmIChub3JtYWwuZG90KGNjLnN1YihlZGdlV29ybGQuYmVnaW4pKSA8IDApIHtcclxuICAgICAgICAgICAgbm9ybWFsLnggPSAtbm9ybWFsLng7XHJcbiAgICAgICAgICAgIG5vcm1hbC55ID0gLW5vcm1hbC55O1xyXG4gICAgICAgIH1cclxuICAgICAgICBub3JtYWwgPSBub3JtYWwubm9ybWFsaXplKCk7XHJcbiAgICAgICAgY29uc3Qgc2VwYXJhdGlvbiA9IGNpcmNsZS5yYWRpdXMgLSBNYXRoLnNxcnQoZGQpO1xyXG4gICAgICAgIGNvbnN0IG12dCA9IG5vcm1hbC5zY2FsZShzZXBhcmF0aW9uKTtcclxuICAgICAgICBjb25zdCBpbmZvID0ge1xyXG4gICAgICAgICAgICBjb2xsaWRlcjogY2lyY2xlLFxyXG4gICAgICAgICAgICBzZXBhcmF0aW9uOiBzZXBhcmF0aW9uLFxyXG4gICAgICAgICAgICBheGlzOiBub3JtYWwsXHJcbiAgICAgICAgICAgIHBvaW50OiBwb2ludE9uRWRnZSxcclxuICAgICAgICAgICAgc2lkZTogc2lkZSxcclxuICAgICAgICAgICAgbG9jYWxTaWRlOiBsb2NhbFNpZGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBbXHJcbiAgICAgICAgICAgIG5ldyBDb2xsaXNpb25Db250YWN0KGNpcmNsZSwgZWRnZSwgbXZ0LCBub3JtYWwubmVnYXRlKCksIG5vcm1hbC5uZWdhdGUoKS5wZXJwZW5kaWN1bGFyKCksIFtwb2ludE9uRWRnZV0sIFtwb2ludE9uRWRnZS5zdWIoZWRnZS53b3JsZFBvcyldLCBpbmZvKVxyXG4gICAgICAgIF07XHJcbiAgICB9LFxyXG4gICAgQ29sbGlkZUVkZ2VFZGdlKCkge1xyXG4gICAgICAgIC8vIEVkZ2UtZWRnZSBjb2xsaXNpb24gZG9lc24ndCBtYWtlIHNlbnNlXHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfSxcclxuICAgIENvbGxpZGVQb2x5Z29uRWRnZShwb2x5Z29uLCBlZGdlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHBjID0gcG9seWdvbi5jZW50ZXI7XHJcbiAgICAgICAgY29uc3QgZWMgPSBlZGdlLmNlbnRlcjtcclxuICAgICAgICBjb25zdCBkaXIgPSBlYy5zdWIocGMpLm5vcm1hbGl6ZSgpO1xyXG4gICAgICAgIC8vIGJ1aWxkIGEgdGVtcG9yYXJ5IHBvbHlnb24gZnJvbSB0aGUgZWRnZSB0byB1c2UgU0FUXHJcbiAgICAgICAgY29uc3QgbGluZVBvbHkgPSBuZXcgUG9seWdvbkNvbGxpZGVyKHtcclxuICAgICAgICAgICAgcG9pbnRzOiBbZWRnZS5iZWdpbiwgZWRnZS5lbmQsIGVkZ2UuZW5kLmFkZChkaXIuc2NhbGUoMTAwKSksIGVkZ2UuYmVnaW4uYWRkKGRpci5zY2FsZSgxMDApKV0sXHJcbiAgICAgICAgICAgIG9mZnNldDogZWRnZS5vZmZzZXRcclxuICAgICAgICB9KTtcclxuICAgICAgICBsaW5lUG9seS5vd25lciA9IGVkZ2Uub3duZXI7XHJcbiAgICAgICAgY29uc3QgdHggPSAoX2EgPSBlZGdlLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKHR4KSB7XHJcbiAgICAgICAgICAgIGxpbmVQb2x5LnVwZGF0ZShlZGdlLm93bmVyLmdldChUcmFuc2Zvcm1Db21wb25lbnQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gR3Jvc3MgaGFjayBidXQgcG9seS1wb2x5IHdvcmtzIHdlbGxcclxuICAgICAgICBjb25zdCBjb250YWN0ID0gdGhpcy5Db2xsaWRlUG9seWdvblBvbHlnb24ocG9seWdvbiwgbGluZVBvbHkpO1xyXG4gICAgICAgIGlmIChjb250YWN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBGdWRnZSB0aGUgY29udGFjdCBiYWNrIHRvIGVkZ2VcclxuICAgICAgICAgICAgY29udGFjdFswXS5jb2xsaWRlckIgPSBlZGdlO1xyXG4gICAgICAgICAgICBjb250YWN0WzBdLmlkID0gUGFpci5jYWxjdWxhdGVQYWlySGFzaChwb2x5Z29uLmlkLCBlZGdlLmlkKTtcclxuICAgICAgICAgICAgLy8gY29udGFjdFswXS5pbmZvLmNvbGxpZGVyXHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb250YWN0O1xyXG4gICAgfSxcclxuICAgIENvbGxpZGVQb2x5Z29uUG9seWdvbihwb2x5QSwgcG9seUIpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgLy8gTXVsdGkgY29udGFjdCBmcm9tIFNBVFxyXG4gICAgICAgIC8vIGh0dHBzOi8vZ2FtZWRldi5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvMTExMzkwL211bHRpcGxlLWNvbnRhY3RzLWZvci1zYXQtY29sbGlzaW9uLWRldGVjdGlvblxyXG4gICAgICAgIC8vIGRvIGEgU0FUIHRlc3QgdG8gZmluZCBhIG1pbiBheGlzIGlmIGl0IGV4aXN0c1xyXG4gICAgICAgIGNvbnN0IHNlcGFyYXRpb25BID0gU2VwYXJhdGluZ0F4aXMuZmluZFBvbHlnb25Qb2x5Z29uU2VwYXJhdGlvbihwb2x5QSwgcG9seUIpO1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG92ZXJsYXAgZnJvbSBib3hBJ3MgcGVyc3BlY3RpdmUgd2UgY2FuIGVuZCBlYXJseVxyXG4gICAgICAgIGlmIChzZXBhcmF0aW9uQS5zZXBhcmF0aW9uID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHNlcGFyYXRpb25CID0gU2VwYXJhdGluZ0F4aXMuZmluZFBvbHlnb25Qb2x5Z29uU2VwYXJhdGlvbihwb2x5QiwgcG9seUEpO1xyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIG92ZXJsYXAgZnJvbSBib3hCJ3MgcGVyc3BlY3RpdmUgZXhpdCBub3dcclxuICAgICAgICBpZiAoc2VwYXJhdGlvbkIuc2VwYXJhdGlvbiA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTZXBhcmF0aW9ucyBhcmUgYm90aCBuZWdhdGl2ZSwgd2Ugd2FudCB0byBwaWNrIHRoZSBsZWFzdCBuZWdhdGl2ZSAobWluaW1hbCBtb3ZlbWVudClcclxuICAgICAgICBjb25zdCBzZXBhcmF0aW9uID0gc2VwYXJhdGlvbkEuc2VwYXJhdGlvbiA+IHNlcGFyYXRpb25CLnNlcGFyYXRpb24gPyBzZXBhcmF0aW9uQSA6IHNlcGFyYXRpb25CO1xyXG4gICAgICAgIC8vIFRoZSBpbmNpZGVudCBzaWRlIGlzIHRoZSBtb3N0IG9wcG9zaXRlIGZyb20gdGhlIGF4ZXMgb2YgY29sbGlzaW9uIG9uIHRoZSBvdGhlciBjb2xsaWRlclxyXG4gICAgICAgIGNvbnN0IG90aGVyID0gc2VwYXJhdGlvbi5jb2xsaWRlciA9PT0gcG9seUEgPyBwb2x5QiA6IHBvbHlBO1xyXG4gICAgICAgIGNvbnN0IGluY2lkZW50ID0gb3RoZXIuZmluZFNpZGUoc2VwYXJhdGlvbi5heGlzLm5lZ2F0ZSgpKTtcclxuICAgICAgICAvLyBDbGlwIGluY2lkZW50IHNpZGUgYnkgdGhlIHBlcnBlbmRpY3VsYXIgbGluZXMgYXQgZWFjaCBlbmQgb2YgdGhlIHJlZmVyZW5jZSBzaWRlXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3V0aGVybGFuZCVFMiU4MCU5M0hvZGdtYW5fYWxnb3JpdGhtXHJcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlID0gc2VwYXJhdGlvbi5zaWRlO1xyXG4gICAgICAgIGNvbnN0IHJlZkRpciA9IHJlZmVyZW5jZS5kaXIoKS5ub3JtYWxpemUoKTtcclxuICAgICAgICAvLyBGaW5kIG91ciBjb250YWN0IHBvaW50cyBieSBjbGlwcGluZyB0aGUgaW5jaWRlbnQgYnkgdGhlIGNvbGxpc2lvbiBzaWRlXHJcbiAgICAgICAgY29uc3QgY2xpcFJpZ2h0ID0gaW5jaWRlbnQuY2xpcChyZWZEaXIubmVnYXRlKCksIC1yZWZEaXIuZG90KHJlZmVyZW5jZS5iZWdpbikpO1xyXG4gICAgICAgIGxldCBjbGlwTGVmdCA9IG51bGw7XHJcbiAgICAgICAgaWYgKGNsaXBSaWdodCkge1xyXG4gICAgICAgICAgICBjbGlwTGVmdCA9IGNsaXBSaWdodC5jbGlwKHJlZkRpciwgcmVmRGlyLmRvdChyZWZlcmVuY2UuZW5kKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG5vIGxlZnQgdGhlcmUgaXMgbm8gY29sbGlzaW9uXHJcbiAgICAgICAgaWYgKGNsaXBMZWZ0KSB7XHJcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgd2FudCBjbGlwIHBvaW50cyBiZWxvdyB0aGUgcmVmZXJlbmNlIGVkZ2UsIGRpc2NhcmQgdGhlIG90aGVyc1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBjbGlwTGVmdC5nZXRQb2ludHMoKS5maWx0ZXIoKHApID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZWZlcmVuY2UuYmVsb3cocCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgbm9ybWFsID0gc2VwYXJhdGlvbi5heGlzO1xyXG4gICAgICAgICAgICBsZXQgdGFuZ2VudCA9IG5vcm1hbC5wZXJwZW5kaWN1bGFyKCk7XHJcbiAgICAgICAgICAgIC8vIFBvaW50IENvbnRhY3QgQSAtPiBCXHJcbiAgICAgICAgICAgIGlmIChwb2x5Qi53b3JsZFBvcy5zdWIocG9seUEud29ybGRQb3MpLmRvdChub3JtYWwpIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgbm9ybWFsID0gbm9ybWFsLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgdGFuZ2VudCA9IG5vcm1hbC5wZXJwZW5kaWN1bGFyKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gUG9pbnRzIGFyZSBjbGlwcGVkIGZyb20gaW5jaWRlbnQgd2hpY2ggaXMgdGhlIG90aGVyIGNvbGxpZGVyXHJcbiAgICAgICAgICAgIC8vIFN0b3JlIHRob3NlIGFzIGxvY2Fsc1xyXG4gICAgICAgICAgICBsZXQgbG9jYWxQb2ludHMgPSBbXTtcclxuICAgICAgICAgICAgaWYgKHNlcGFyYXRpb24uY29sbGlkZXIgPT09IHBvbHlBKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB4ZiA9IChfYiA9IChfYSA9IHBvbHlCLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5ldyBUcmFuc2Zvcm1Db21wb25lbnQoKTtcclxuICAgICAgICAgICAgICAgIGxvY2FsUG9pbnRzID0gcG9pbnRzLm1hcCgocCkgPT4geGYuYXBwbHlJbnZlcnNlKHApKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHhmID0gKF9kID0gKF9jID0gcG9seUEub3duZXIpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogbmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpO1xyXG4gICAgICAgICAgICAgICAgbG9jYWxQb2ludHMgPSBwb2ludHMubWFwKChwKSA9PiB4Zi5hcHBseUludmVyc2UocCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbbmV3IENvbGxpc2lvbkNvbnRhY3QocG9seUEsIHBvbHlCLCBub3JtYWwuc2NhbGUoLXNlcGFyYXRpb24uc2VwYXJhdGlvbiksIG5vcm1hbCwgdGFuZ2VudCwgcG9pbnRzLCBsb2NhbFBvaW50cywgc2VwYXJhdGlvbildO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICB9LFxyXG4gICAgRmluZENvbnRhY3RTZXBhcmF0aW9uKGNvbnRhY3QsIGxvY2FsUG9pbnQpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XHJcbiAgICAgICAgY29uc3Qgc2hhcGVBID0gY29udGFjdC5jb2xsaWRlckE7XHJcbiAgICAgICAgY29uc3QgdHhBID0gKF9iID0gKF9hID0gY29udGFjdC5jb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpO1xyXG4gICAgICAgIGNvbnN0IHNoYXBlQiA9IGNvbnRhY3QuY29sbGlkZXJCO1xyXG4gICAgICAgIGNvbnN0IHR4QiA9IChfZCA9IChfYyA9IGNvbnRhY3QuY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG5ldyBUcmFuc2Zvcm1Db21wb25lbnQoKTtcclxuICAgICAgICAvLyBib3RoIGFyZSBjaXJjbGVzXHJcbiAgICAgICAgaWYgKHNoYXBlQSBpbnN0YW5jZW9mIENpcmNsZUNvbGxpZGVyICYmIHNoYXBlQiBpbnN0YW5jZW9mIENpcmNsZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkUmFkaXVzID0gc2hhcGVBLnJhZGl1cyArIHNoYXBlQi5yYWRpdXM7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdHhBLnBvcy5kaXN0YW5jZSh0eEIucG9zKTtcclxuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdGlvbiA9IGNvbWJpbmVkUmFkaXVzIC0gZGlzdGFuY2U7XHJcbiAgICAgICAgICAgIHJldHVybiAtc2VwYXJhdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gYm90aCBhcmUgcG9seWdvbnNcclxuICAgICAgICBpZiAoc2hhcGVBIGluc3RhbmNlb2YgUG9seWdvbkNvbGxpZGVyICYmIHNoYXBlQiBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlcikge1xyXG4gICAgICAgICAgICBpZiAoY29udGFjdC5pbmZvLmxvY2FsU2lkZSkge1xyXG4gICAgICAgICAgICAgICAgbGV0IHNpZGU7XHJcbiAgICAgICAgICAgICAgICBsZXQgd29ybGRQb2ludDtcclxuICAgICAgICAgICAgICAgIGlmIChjb250YWN0LmluZm8uY29sbGlkZXIgPT09IHNoYXBlQSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNpZGUgPSBuZXcgTGluZSh0eEEuYXBwbHkoY29udGFjdC5pbmZvLmxvY2FsU2lkZS5iZWdpbiksIHR4QS5hcHBseShjb250YWN0LmluZm8ubG9jYWxTaWRlLmVuZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIHdvcmxkUG9pbnQgPSB0eEIuYXBwbHkobG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBzaWRlID0gbmV3IExpbmUodHhCLmFwcGx5KGNvbnRhY3QuaW5mby5sb2NhbFNpZGUuYmVnaW4pLCB0eEIuYXBwbHkoY29udGFjdC5pbmZvLmxvY2FsU2lkZS5lbmQpKTtcclxuICAgICAgICAgICAgICAgICAgICB3b3JsZFBvaW50ID0gdHhBLmFwcGx5KGxvY2FsUG9pbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZGUuZGlzdGFuY2VUb1BvaW50KHdvcmxkUG9pbnQsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBvbHlnb24gdiBjaXJjbGVcclxuICAgICAgICBpZiAoKHNoYXBlQSBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlciAmJiBzaGFwZUIgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlcikgfHxcclxuICAgICAgICAgICAgKHNoYXBlQiBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlciAmJiBzaGFwZUEgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlcikpIHtcclxuICAgICAgICAgICAgY29uc3Qgd29ybGRQb2ludCA9IHR4QS5hcHBseShsb2NhbFBvaW50KTtcclxuICAgICAgICAgICAgaWYgKGNvbnRhY3QuaW5mby5zaWRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFjdC5pbmZvLnNpZGUuZGlzdGFuY2VUb1BvaW50KHdvcmxkUG9pbnQsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIHBvbHlnb24gdiBlZGdlXHJcbiAgICAgICAgaWYgKChzaGFwZUEgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIgJiYgc2hhcGVCIGluc3RhbmNlb2YgUG9seWdvbkNvbGxpZGVyKSB8fFxyXG4gICAgICAgICAgICAoc2hhcGVCIGluc3RhbmNlb2YgRWRnZUNvbGxpZGVyICYmIHNoYXBlQSBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlcikpIHtcclxuICAgICAgICAgICAgbGV0IHdvcmxkUG9pbnQ7XHJcbiAgICAgICAgICAgIGlmIChjb250YWN0LmluZm8uY29sbGlkZXIgPT09IHNoYXBlQSkge1xyXG4gICAgICAgICAgICAgICAgd29ybGRQb2ludCA9IHR4Qi5hcHBseShsb2NhbFBvaW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdvcmxkUG9pbnQgPSB0eEEuYXBwbHkobG9jYWxQb2ludCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNvbnRhY3QuaW5mby5zaWRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGFjdC5pbmZvLnNpZGUuZGlzdGFuY2VUb1BvaW50KHdvcmxkUG9pbnQsIHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGNpcmNsZSB2IGVkZ2VcclxuICAgICAgICBpZiAoKHNoYXBlQSBpbnN0YW5jZW9mIENpcmNsZUNvbGxpZGVyICYmIHNoYXBlQiBpbnN0YW5jZW9mIEVkZ2VDb2xsaWRlcikgfHxcclxuICAgICAgICAgICAgKHNoYXBlQiBpbnN0YW5jZW9mIENpcmNsZUNvbGxpZGVyICYmIHNoYXBlQSBpbnN0YW5jZW9mIEVkZ2VDb2xsaWRlcikpIHtcclxuICAgICAgICAgICAgLy8gTG9jYWwgcG9pbnQgaXMgYWx3YXlzIG9uIHRoZSBlZGdlIHdoaWNoIGlzIGFsd2F5cyBzaGFwZUJcclxuICAgICAgICAgICAgY29uc3Qgd29ybGRQb2ludCA9IHR4Qi5hcHBseShsb2NhbFBvaW50KTtcclxuICAgICAgICAgICAgbGV0IGNpcmNsZVBvaW50O1xyXG4gICAgICAgICAgICBpZiAoc2hhcGVBIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgIGNpcmNsZVBvaW50ID0gc2hhcGVBLmdldEZ1cnRoZXN0UG9pbnQoY29udGFjdC5ub3JtYWwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSB3b3JsZFBvaW50LmRpc3RhbmNlKGNpcmNsZVBvaW50KTtcclxuICAgICAgICAgICAgaWYgKGNvbnRhY3QuaW5mby5zaWRlKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlzdCA+IDAgPyAtZGlzdCA6IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbn07XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpZGVycy9FZGdlQ29sbGlkZXIudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogRWRnZSBpcyBhIHNpbmdsZSBsaW5lIGNvbGxpZGVyIHRvIGNyZWF0ZSBjb2xsaXNpb25zIHdpdGggYSBzaW5nbGUgbGluZS5cclxuICovXHJcbmNsYXNzIEVkZ2VDb2xsaWRlciBleHRlbmRzIENvbGxpZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmJlZ2luID0gb3B0aW9ucy5iZWdpbiB8fCBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLmVuZCA9IG9wdGlvbnMuZW5kIHx8IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gKF9hID0gb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFZlY3Rvci5aZXJvO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgY2xvbmUgb2YgdGhpcyBFZGdlLCBub3QgYXNzb2NpYXRlZCB3aXRoIGFueSBjb2xsaWRlclxyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEVkZ2VDb2xsaWRlcih7XHJcbiAgICAgICAgICAgIGJlZ2luOiB0aGlzLmJlZ2luLmNsb25lKCksXHJcbiAgICAgICAgICAgIGVuZDogdGhpcy5lbmQuY2xvbmUoKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdvcmxkUG9zKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBjb25zdCB0eCA9IHRoaXMuX3RyYW5zZm9ybTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdHggPT09IG51bGwgfHwgdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR4Lmdsb2JhbFBvcy5hZGQodGhpcy5vZmZzZXQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLm9mZnNldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBjZW50ZXIgb2YgdGhlIGNvbGxpc2lvbiBhcmVhIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGdldCBjZW50ZXIoKSB7XHJcbiAgICAgICAgY29uc3QgcG9zID0gdGhpcy5iZWdpbi5hdmVyYWdlKHRoaXMuZW5kKS5hZGQodGhpcy5fZ2V0Qm9keVBvcygpKTtcclxuICAgICAgICByZXR1cm4gcG9zO1xyXG4gICAgfVxyXG4gICAgX2dldEJvZHlQb3MoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy5fdHJhbnNmb3JtO1xyXG4gICAgICAgIGNvbnN0IGJvZHlQb3MgPSAoX2EgPSB0eCA9PT0gbnVsbCB8fCB0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHguZ2xvYmFsUG9zKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWZWN0b3IuWmVybztcclxuICAgICAgICByZXR1cm4gYm9keVBvcztcclxuICAgIH1cclxuICAgIF9nZXRUcmFuc2Zvcm1lZEJlZ2luKCkge1xyXG4gICAgICAgIGNvbnN0IHR4ID0gdGhpcy5fdHJhbnNmb3JtO1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gdHggPyB0eC5nbG9iYWxSb3RhdGlvbiA6IDA7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVnaW4ucm90YXRlKGFuZ2xlKS5hZGQodGhpcy5fZ2V0Qm9keVBvcygpKTtcclxuICAgIH1cclxuICAgIF9nZXRUcmFuc2Zvcm1lZEVuZCgpIHtcclxuICAgICAgICBjb25zdCB0eCA9IHRoaXMuX3RyYW5zZm9ybTtcclxuICAgICAgICBjb25zdCBhbmdsZSA9IHR4ID8gdHguZ2xvYmFsUm90YXRpb24gOiAwO1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZC5yb3RhdGUoYW5nbGUpLmFkZCh0aGlzLl9nZXRCb2R5UG9zKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBzbG9wZSBvZiB0aGUgbGluZSBpbiB0aGUgZm9ybSBvZiBhIHZlY3RvclxyXG4gICAgICovXHJcbiAgICBnZXRTbG9wZSgpIHtcclxuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICByZXR1cm4gZW5kLnN1YihiZWdpbikuc2NhbGUoMSAvIGRpc3RhbmNlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIHNlZ21lbnQgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIGdldExlbmd0aCgpIHtcclxuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gYmVnaW4uZGlzdGFuY2UoZW5kKTtcclxuICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGEgcG9pbnQgaXMgY29udGFpbmVkIGluIHRoaXMgY29sbGlzaW9uIGFyZWFcclxuICAgICAqL1xyXG4gICAgY29udGFpbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICovXHJcbiAgICByYXlDYXN0KHJheSwgbWF4ID0gSW5maW5pdHkpIHtcclxuICAgICAgICBjb25zdCBudW1lcmF0b3IgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCkuc3ViKHJheS5wb3MpO1xyXG4gICAgICAgIC8vIFRlc3QgaXMgbGluZSBhbmQgcmF5IGFyZSBwYXJhbGxlbCBhbmQgbm9uIGludGVyc2VjdGluZ1xyXG4gICAgICAgIGlmIChyYXkuZGlyLmNyb3NzKHRoaXMuZ2V0U2xvcGUoKSkgPT09IDAgJiYgbnVtZXJhdG9yLmNyb3NzKHJheS5kaXIpICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBMaW5lcyBhcmUgcGFyYWxsZWxcclxuICAgICAgICBjb25zdCBkaXZpc29yID0gcmF5LmRpci5jcm9zcyh0aGlzLmdldFNsb3BlKCkpO1xyXG4gICAgICAgIGlmIChkaXZpc29yID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB0ID0gbnVtZXJhdG9yLmNyb3NzKHRoaXMuZ2V0U2xvcGUoKSkgLyBkaXZpc29yO1xyXG4gICAgICAgIGlmICh0ID49IDAgJiYgdCA8PSBtYXgpIHtcclxuICAgICAgICAgICAgY29uc3QgdSA9IG51bWVyYXRvci5jcm9zcyhyYXkuZGlyKSAvIGRpdmlzb3IgLyB0aGlzLmdldExlbmd0aCgpO1xyXG4gICAgICAgICAgICBpZiAodSA+PSAwICYmIHUgPD0gMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludCh0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY2xvc2VzIGxpbmUgYmV0d2VlbiB0aGlzIGFuZCBhbm90aGVyIGNvbGxpZGVyLCBmcm9tIHRoaXMgLT4gY29sbGlkZXJcclxuICAgICAqIEBwYXJhbSBzaGFwZVxyXG4gICAgICovXHJcbiAgICBnZXRDbG9zZXN0TGluZUJldHdlZW4oc2hhcGUpIHtcclxuICAgICAgICBpZiAoc2hhcGUgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ2xvc2VzdExpbmVKdW1wVGFibGUuQ2lyY2xlRWRnZUNsb3Nlc3RMaW5lKHNoYXBlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hhcGUgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLlBvbHlnb25FZGdlQ2xvc2VzdExpbmUoc2hhcGUsIHRoaXMpLmZsaXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hhcGUgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLkVkZ2VFZGdlQ2xvc2VzdExpbmUodGhpcywgc2hhcGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2x5Z29uIGNvdWxkIG5vdCBjb2xsaWRlIHdpdGggdW5rbm93biBDb2xsaXNpb25TaGFwZSAke3R5cGVvZiBzaGFwZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbmhlcml0ZG9jXHJcbiAgICAgKi9cclxuICAgIGNvbGxpZGUoc2hhcGUpIHtcclxuICAgICAgICBpZiAoc2hhcGUgaW5zdGFuY2VvZiBDaXJjbGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVDaXJjbGVFZGdlKHNoYXBlLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoc2hhcGUgaW5zdGFuY2VvZiBQb2x5Z29uQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENvbGxpc2lvbkp1bXBUYWJsZS5Db2xsaWRlUG9seWdvbkVkZ2Uoc2hhcGUsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChzaGFwZSBpbnN0YW5jZW9mIEVkZ2VDb2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVFZGdlRWRnZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFZGdlIGNvdWxkIG5vdCBjb2xsaWRlIHdpdGggdW5rbm93biBDb2xsaXNpb25TaGFwZSAke3R5cGVvZiBzaGFwZX1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIHBvaW50IG9uIHRoZSBjb2xsaWRlciBmdXJ0aGVzdCBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICovXHJcbiAgICBnZXRGdXJ0aGVzdFBvaW50KGRpcmVjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkQmVnaW4gPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCk7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRFbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb24uZG90KHRyYW5zZm9ybWVkQmVnaW4pID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRCZWdpbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZEVuZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfYm91bmRzRnJvbUJlZ2luRW5kKGJlZ2luLCBlbmQsIHBhZGRpbmcgPSAxMCkge1xyXG4gICAgICAgIC8vIEEgcGVyZmVjdGx5IHZlcnRpY2FsIG9yIGhvcml6b250YWwgZWRnZSB3b3VsZCBoYXZlIGEgYm91bmRzIDAgd2lkdGggb3IgaGVpZ2h0XHJcbiAgICAgICAgLy8gdGhpcyBjYXVzZXMgcHJvYmxlbXMgZm9yIHRoZSBjb2xsaXNpb24gc3lzdGVtIHNvIHdlIGdpdmUgdGhlbSBzb21lIHBhZGRpbmdcclxuICAgICAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KE1hdGgubWluKGJlZ2luLngsIGVuZC54KSAtIHBhZGRpbmcsIE1hdGgubWluKGJlZ2luLnksIGVuZC55KSAtIHBhZGRpbmcsIE1hdGgubWF4KGJlZ2luLngsIGVuZC54KSArIHBhZGRpbmcsIE1hdGgubWF4KGJlZ2luLnksIGVuZC55KSArIHBhZGRpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGF4aXMgYWxpZ25lZCBib3VuZGluZyBib3ggZm9yIHRoZSBlZGdlIGNvbGxpZGVyIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIGdldCBib3VuZHMoKSB7XHJcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRCZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZEVuZCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kc0Zyb21CZWdpbkVuZCh0cmFuc2Zvcm1lZEJlZ2luLCB0cmFuc2Zvcm1lZEVuZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIGVkZ2UgY29sbGlkZXIgaW4gbG9jYWwgc3BhY2VcclxuICAgICAqL1xyXG4gICAgZ2V0IGxvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHNGcm9tQmVnaW5FbmQodGhpcy5iZWdpbiwgdGhpcy5lbmQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoaXMgZWRnZSByZXByZXNlbnRlZCBhcyBhIGxpbmUgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgYXNMaW5lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZSh0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCksIHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhpcyBlZGdlIGFzIGEgbGluZSBpbiBsb2NhbCBsaW5lIGNvb3JkaW5hdGVzIChyZWxhdGl2ZSB0byB0aGUgcG9zaXRpb24pXHJcbiAgICAgKi9cclxuICAgIGFzTG9jYWxMaW5lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgTGluZSh0aGlzLmJlZ2luLCB0aGlzLmVuZCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXhpcyBhc3NvY2lhdGVkIHdpdGggdGhlIGVkZ2VcclxuICAgICAqL1xyXG4gICAgZ2V0IGF4ZXMoKSB7XHJcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCkuc3ViKHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKSk7XHJcbiAgICAgICAgY29uc3QgZWRnZU5vcm1hbCA9IGUubm9ybWFsKCk7XHJcbiAgICAgICAgY29uc3QgYXhlcyA9IFtdO1xyXG4gICAgICAgIGF4ZXMucHVzaChlZGdlTm9ybWFsKTtcclxuICAgICAgICBheGVzLnB1c2goZWRnZU5vcm1hbC5uZWdhdGUoKSk7XHJcbiAgICAgICAgYXhlcy5wdXNoKGVkZ2VOb3JtYWwubm9ybWFsKCkpO1xyXG4gICAgICAgIGF4ZXMucHVzaChlZGdlTm9ybWFsLm5vcm1hbCgpLm5lZ2F0ZSgpKTtcclxuICAgICAgICByZXR1cm4gYXhlcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtb21lbnQgb2YgaW5lcnRpYSBmb3IgYW4gZWRnZVxyXG4gICAgICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9tb21lbnRzX29mX2luZXJ0aWFcclxuICAgICAqL1xyXG4gICAgZ2V0SW5lcnRpYShtYXNzKSB7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdGhpcy5lbmQuc3ViKHRoaXMuYmVnaW4pLmRpc3RhbmNlKCkgLyAyO1xyXG4gICAgICAgIHJldHVybiBtYXNzICogbGVuZ3RoICogbGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5oZXJpdGRvY1xyXG4gICAgICovXHJcbiAgICB1cGRhdGUodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtID0gdHJhbnNmb3JtO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm9qZWN0IHRoZSBlZGdlIGFsb25nIGEgc3BlY2lmaWVkIGF4aXNcclxuICAgICAqL1xyXG4gICAgcHJvamVjdChheGlzKSB7XHJcbiAgICAgICAgY29uc3Qgc2NhbGFycyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFt0aGlzLl9nZXRUcmFuc2Zvcm1lZEJlZ2luKCksIHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCldO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBzY2FsYXJzLnB1c2gocG9pbnRzW2ldLmRvdChheGlzKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgUHJvamVjdGlvbihNYXRoLm1pbi5hcHBseShNYXRoLCBzY2FsYXJzKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgc2NhbGFycykpO1xyXG4gICAgfVxyXG4gICAgZHJhdyhjdHgsIGNvbG9yID0gQ29sb3IuR3JlZW4sIHBvcyA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLmJlZ2luLmFkZChwb3MpO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuZW5kLmFkZChwb3MpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8oYmVnaW4ueCwgYmVnaW4ueSk7XHJcbiAgICAgICAgY3R4LmxpbmVUbyhlbmQueCwgZW5kLnkpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbiAgICBkZWJ1ZyhleCwgY29sb3IpIHtcclxuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuX2dldFRyYW5zZm9ybWVkQmVnaW4oKTtcclxuICAgICAgICBjb25zdCBlbmQgPSB0aGlzLl9nZXRUcmFuc2Zvcm1lZEVuZCgpO1xyXG4gICAgICAgIGV4LmRyYXdMaW5lKGJlZ2luLCBlbmQsIGNvbG9yLCAyKTtcclxuICAgICAgICBleC5kcmF3Q2lyY2xlKGJlZ2luLCAyLCBjb2xvcik7XHJcbiAgICAgICAgZXguZHJhd0NpcmNsZShlbmQsIDIsIGNvbG9yKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBkZWJ1Z0RyYXcoY3R4LCBjb2xvciA9IENvbG9yLlJlZCkge1xyXG4gICAgICAgIGNvbnN0IGJlZ2luID0gdGhpcy5fZ2V0VHJhbnNmb3JtZWRCZWdpbigpO1xyXG4gICAgICAgIGNvbnN0IGVuZCA9IHRoaXMuX2dldFRyYW5zZm9ybWVkRW5kKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyhiZWdpbi54LCBiZWdpbi55KTtcclxuICAgICAgICBjdHgubGluZVRvKGVuZC54LCBlbmQueSk7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Db2xsaWRlcnMvUG9seWdvbkNvbGxpZGVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBQb2x5Z29uIGNvbGxpZGVyIGZvciBkZXRlY3RpbmcgY29sbGlzaW9uc1xyXG4gKi9cclxuY2xhc3MgUG9seWdvbkNvbGxpZGVyIGV4dGVuZHMgQ29sbGlkZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzID0gW107XHJcbiAgICAgICAgdGhpcy5fYXhlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3NpZGVzID0gW107XHJcbiAgICAgICAgdGhpcy5fbG9jYWxTaWRlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gKF9hID0gb3B0aW9ucy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIGNvbnN0IHdpbmRpbmcgPSAhIW9wdGlvbnMuY2xvY2t3aXNlV2luZGluZztcclxuICAgICAgICB0aGlzLnBvaW50cyA9ICh3aW5kaW5nID8gb3B0aW9ucy5wb2ludHMucmV2ZXJzZSgpIDogb3B0aW9ucy5wb2ludHMpIHx8IFtdO1xyXG4gICAgICAgIC8vIGNhbGN1bGF0ZSBpbml0aWFsIHRyYW5zZm9ybWF0aW9uXHJcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlVHJhbnNmb3JtYXRpb24oKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIGNsb25lIG9mIHRoaXMgQ29udmV4UG9seWdvbiwgbm90IGFzc29jaWF0ZWQgd2l0aCBhbnkgY29sbGlkZXJcclxuICAgICAqL1xyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQ29sbGlkZXIoe1xyXG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LmNsb25lKCksXHJcbiAgICAgICAgICAgIHBvaW50czogdGhpcy5wb2ludHMubWFwKChwKSA9PiBwLmNsb25lKCkpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHdvcmxkIHBvc2l0aW9uIG9mIHRoZSBjb2xsaWRlciwgd2hpY2ggaXMgdGhlIGN1cnJlbnQgYm9keSB0cmFuc2Zvcm0gcGx1cyBhbnkgZGVmaW5lZCBvZmZzZXRcclxuICAgICAqL1xyXG4gICAgZ2V0IHdvcmxkUG9zKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybS5wb3MuYWRkKHRoaXMub2Zmc2V0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNlbnRlciBvZiB0aGUgY29sbGlkZXIgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgZ2V0IGNlbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHMuY2VudGVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxjdWxhdGVzIHRoZSB1bmRlcmx5aW5nIHRyYW5zZm9ybWF0aW9uIGZyb20gdGhlIGJvZHkgcmVsYXRpdmUgc3BhY2UgdG8gd29ybGQgc3BhY2VcclxuICAgICAqL1xyXG4gICAgX2NhbGN1bGF0ZVRyYW5zZm9ybWF0aW9uKCkge1xyXG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMuX3RyYW5zZm9ybTtcclxuICAgICAgICBjb25zdCBwb3MgPSB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0uZ2xvYmFsUG9zLmFkZCh0aGlzLm9mZnNldCkgOiB0aGlzLm9mZnNldDtcclxuICAgICAgICBjb25zdCBhbmdsZSA9IHRyYW5zZm9ybSA/IHRyYW5zZm9ybS5nbG9iYWxSb3RhdGlvbiA6IDA7XHJcbiAgICAgICAgY29uc3Qgc2NhbGUgPSB0cmFuc2Zvcm0gPyB0cmFuc2Zvcm0uZ2xvYmFsU2NhbGUgOiBWZWN0b3IuT25lO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMucG9pbnRzLmxlbmd0aDtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lZFBvaW50cy5sZW5ndGggPSAwOyAvLyBjbGVhciBvdXQgb2xkIHRyYW5zZm9ybVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtZWRQb2ludHNbaV0gPSB0aGlzLnBvaW50c1tpXS5zY2FsZShzY2FsZSkucm90YXRlKGFuZ2xlKS5hZGQocG9zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvaW50cyB0aGF0IG1ha2UgdXAgdGhlIHBvbHlnb24gaW4gd29ybGQgc3BhY2UsIGZyb20gYWN0b3IgcmVsYXRpdmUgc3BhY2UgKGlmIHNwZWNpZmllZClcclxuICAgICAqL1xyXG4gICAgZ2V0VHJhbnNmb3JtZWRQb2ludHMoKSB7XHJcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlVHJhbnNmb3JtYXRpb24oKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtZWRQb2ludHM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHNpZGVzIG9mIHRoZSBwb2x5Z29uIGluIHdvcmxkIHNwYWNlXHJcbiAgICAgKi9cclxuICAgIGdldFNpZGVzKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zaWRlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NpZGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsaW5lcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKTtcclxuICAgICAgICBjb25zdCBsZW4gPSBwb2ludHMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgLy8gVGhpcyB3aW5kaW5nIGlzIGltcG9ydGFudFxyXG4gICAgICAgICAgICBsaW5lcy5wdXNoKG5ldyBMaW5lKHBvaW50c1tpXSwgcG9pbnRzWyhpICsgMSkgJSBsZW5dKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3NpZGVzID0gbGluZXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpZGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbCBjb29yZGluYXRlIHNwYWNlIHNpZGVzXHJcbiAgICAgKi9cclxuICAgIGdldExvY2FsU2lkZXMoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2xvY2FsU2lkZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFNpZGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBsaW5lcyA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHdpbmRpbmcgaXMgaW1wb3J0YW50XHJcbiAgICAgICAgICAgIGxpbmVzLnB1c2gobmV3IExpbmUocG9pbnRzW2ldLCBwb2ludHNbKGkgKyAxKSAlIGxlbl0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbG9jYWxTaWRlcyA9IGxpbmVzO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbFNpZGVzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHaXZlbiBhIGRpcmVjdGlvbiB2ZWN0b3IgZmluZCB0aGUgd29ybGQgc3BhY2Ugc2lkZSB0aGF0IGlzIG1vc3QgaW4gdGhhdCBkaXJlY3Rpb25cclxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgZmluZFNpZGUoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3Qgc2lkZXMgPSB0aGlzLmdldFNpZGVzKCk7XHJcbiAgICAgICAgbGV0IGJlc3RTaWRlID0gc2lkZXNbMF07XHJcbiAgICAgICAgbGV0IG1heERpc3RhbmNlID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgZm9yIChsZXQgc2lkZSA9IDA7IHNpZGUgPCBzaWRlcy5sZW5ndGg7IHNpZGUrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U2lkZSA9IHNpZGVzW3NpZGVdO1xyXG4gICAgICAgICAgICBjb25zdCBzaWRlTm9ybWFsID0gY3VycmVudFNpZGUubm9ybWFsKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IG1vc3REaXJlY3Rpb24gPSBzaWRlTm9ybWFsLmRvdChkaXJlY3Rpb24pO1xyXG4gICAgICAgICAgICBpZiAobW9zdERpcmVjdGlvbiA+IG1heERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0U2lkZSA9IGN1cnJlbnRTaWRlO1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBtb3N0RGlyZWN0aW9uO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBiZXN0U2lkZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2l2ZW4gYSBkaXJlY3Rpb24gdmVjdG9yIGZpbmQgdGhlIGxvY2FsIHNwYWNlIHNpZGUgdGhhdCBpcyBtb3N0IGluIHRoYXQgZGlyZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGZpbmRMb2NhbFNpZGUoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3Qgc2lkZXMgPSB0aGlzLmdldExvY2FsU2lkZXMoKTtcclxuICAgICAgICBsZXQgYmVzdFNpZGUgPSBzaWRlc1swXTtcclxuICAgICAgICBsZXQgbWF4RGlzdGFuY2UgPSAtTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBmb3IgKGxldCBzaWRlID0gMDsgc2lkZSA8IHNpZGVzLmxlbmd0aDsgc2lkZSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTaWRlID0gc2lkZXNbc2lkZV07XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZGVOb3JtYWwgPSBjdXJyZW50U2lkZS5ub3JtYWwoKTtcclxuICAgICAgICAgICAgY29uc3QgbW9zdERpcmVjdGlvbiA9IHNpZGVOb3JtYWwuZG90KGRpcmVjdGlvbik7XHJcbiAgICAgICAgICAgIGlmIChtb3N0RGlyZWN0aW9uID4gbWF4RGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RTaWRlID0gY3VycmVudFNpZGU7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZSA9IG1vc3REaXJlY3Rpb247XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJlc3RTaWRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGF4aXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb252ZXggcG9seWdvblxyXG4gICAgICovXHJcbiAgICBnZXQgYXhlcygpIHtcclxuICAgICAgICBpZiAodGhpcy5fYXhlcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2F4ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGF4ZXMgPSB0aGlzLmdldFNpZGVzKCkubWFwKChzKSA9PiBzLm5vcm1hbCgpKTtcclxuICAgICAgICB0aGlzLl9heGVzID0gYXhlcztcclxuICAgICAgICByZXR1cm4gdGhpcy5fYXhlcztcclxuICAgIH1cclxuICAgIHVwZGF0ZSh0cmFuc2Zvcm0pIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XHJcbiAgICAgICAgdGhpcy5fc2lkZXMubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9sb2NhbFNpZGVzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fYXhlcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVkUG9pbnRzLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpO1xyXG4gICAgICAgIHRoaXMuZ2V0U2lkZXMoKTtcclxuICAgICAgICB0aGlzLmdldExvY2FsU2lkZXMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgYSBwb2ludCBpcyBjb250YWluZWQgaW4gdGhpcyBjb2xsaWRlciBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICovXHJcbiAgICBjb250YWlucyhwb2ludCkge1xyXG4gICAgICAgIC8vIEFsd2F5cyBjYXN0IHRvIHRoZSByaWdodCwgYXMgbG9uZyBhcyB3ZSBjYXN0IGluIGEgY29uc2lzdGVudCBmaXhlZCBkaXJlY3Rpb24gd2VcclxuICAgICAgICAvLyB3aWxsIGJlIGZpbmVcclxuICAgICAgICBjb25zdCB0ZXN0UmF5ID0gbmV3IFJheShwb2ludCwgbmV3IFZlY3RvcigxLCAwKSk7XHJcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0Q291bnQgPSB0aGlzLmdldFNpZGVzKCkucmVkdWNlKGZ1bmN0aW9uIChhY2N1bSwgc2lkZSkge1xyXG4gICAgICAgICAgICBpZiAodGVzdFJheS5pbnRlcnNlY3Qoc2lkZSkgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtICsgMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgaWYgKGludGVyc2VjdENvdW50ICUgMiA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgZ2V0Q2xvc2VzdExpbmVCZXR3ZWVuKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgQ2lyY2xlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLlBvbHlnb25DaXJjbGVDbG9zZXN0TGluZSh0aGlzLCBjb2xsaWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgUG9seWdvbkNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDbG9zZXN0TGluZUp1bXBUYWJsZS5Qb2x5Z29uUG9seWdvbkNsb3Nlc3RMaW5lKHRoaXMsIGNvbGxpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoY29sbGlkZXIgaW5zdGFuY2VvZiBFZGdlQ29sbGlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIENsb3Nlc3RMaW5lSnVtcFRhYmxlLlBvbHlnb25FZGdlQ2xvc2VzdExpbmUodGhpcywgY29sbGlkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQb2x5Z29uIGNvdWxkIG5vdCBjb2xsaWRlIHdpdGggdW5rbm93biBDb2xsaXNpb25TaGFwZSAke3R5cGVvZiBjb2xsaWRlcn1gKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBjb2xsaXNpb24gY29udGFjdCBpZiB0aGUgMiBjb2xsaWRlcnMgY29sbGlkZSwgb3RoZXJ3aXNlIGNvbGxpZGUgd2lsbFxyXG4gICAgICogcmV0dXJuIG51bGwuXHJcbiAgICAgKiBAcGFyYW0gY29sbGlkZXJcclxuICAgICAqL1xyXG4gICAgY29sbGlkZShjb2xsaWRlcikge1xyXG4gICAgICAgIGlmIChjb2xsaWRlciBpbnN0YW5jZW9mIENpcmNsZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZUNpcmNsZVBvbHlnb24oY29sbGlkZXIsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2xsaWRlciBpbnN0YW5jZW9mIFBvbHlnb25Db2xsaWRlcikge1xyXG4gICAgICAgICAgICByZXR1cm4gQ29sbGlzaW9uSnVtcFRhYmxlLkNvbGxpZGVQb2x5Z29uUG9seWdvbih0aGlzLCBjb2xsaWRlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbGxpZGVyIGluc3RhbmNlb2YgRWRnZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBDb2xsaXNpb25KdW1wVGFibGUuQ29sbGlkZVBvbHlnb25FZGdlKHRoaXMsIGNvbGxpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9seWdvbiBjb3VsZCBub3QgY29sbGlkZSB3aXRoIHVua25vd24gQ29sbGlzaW9uU2hhcGUgJHt0eXBlb2YgY29sbGlkZXJ9YCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBGaW5kIHRoZSBwb2ludCBvbiB0aGUgY29sbGlkZXIgZnVydGhlc3QgaW4gdGhlIGRpcmVjdGlvbiBzcGVjaWZpZWRcclxuICAgICAqL1xyXG4gICAgZ2V0RnVydGhlc3RQb2ludChkaXJlY3Rpb24pIHtcclxuICAgICAgICBjb25zdCBwdHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgbGV0IGZ1cnRoZXN0UG9pbnQgPSBudWxsO1xyXG4gICAgICAgIGxldCBtYXhEaXN0YW5jZSA9IC1OdW1iZXIuTUFYX1ZBTFVFO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gZGlyZWN0aW9uLmRvdChwdHNbaV0pO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xyXG4gICAgICAgICAgICAgICAgbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgIGZ1cnRoZXN0UG9pbnQgPSBwdHNbaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1cnRoZXN0UG9pbnQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZpbmQgdGhlIGxvY2FsIHBvaW50IG9uIHRoZSBjb2xsaWRlciBmdXJ0aGVzdCBpbiB0aGUgZGlyZWN0aW9uIHNwZWNpZmllZFxyXG4gICAgICogQHBhcmFtIGRpcmVjdGlvblxyXG4gICAgICovXHJcbiAgICBnZXRGdXJ0aGVzdExvY2FsUG9pbnQoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgcHRzID0gdGhpcy5wb2ludHM7XHJcbiAgICAgICAgbGV0IGZ1cnRoZXN0UG9pbnQgPSBwdHNbMF07XHJcbiAgICAgICAgbGV0IG1heERpc3RhbmNlID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBkaXJlY3Rpb24uZG90KHB0c1tpXSk7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IG1heERpc3RhbmNlKSB7XHJcbiAgICAgICAgICAgICAgICBtYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgZnVydGhlc3RQb2ludCA9IHB0c1tpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVydGhlc3RQb2ludDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluZHMgdGhlIGNsb3NlcyBmYWNlIHRvIHRoZSBwb2ludCB1c2luZyBwZXJwZW5kaWN1bGFyIGRpc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gcG9pbnQgcG9pbnQgdG8gdGVzdCBhZ2FpbnN0IHBvbHlnb25cclxuICAgICAqL1xyXG4gICAgZ2V0Q2xvc2VzdEZhY2UocG9pbnQpIHtcclxuICAgICAgICBjb25zdCBzaWRlcyA9IHRoaXMuZ2V0U2lkZXMoKTtcclxuICAgICAgICBsZXQgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xyXG4gICAgICAgIGxldCBmYWNlSW5kZXggPSAtMTtcclxuICAgICAgICBsZXQgZGlzdGFuY2UgPSAtMTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3QgPSBzaWRlc1tpXS5kaXN0YW5jZVRvUG9pbnQocG9pbnQpO1xyXG4gICAgICAgICAgICBpZiAoZGlzdCA8IG1pbikge1xyXG4gICAgICAgICAgICAgICAgbWluID0gZGlzdDtcclxuICAgICAgICAgICAgICAgIGZhY2VJbmRleCA9IGk7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IGRpc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZhY2VJbmRleCAhPT0gLTEpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBzaWRlc1tmYWNlSW5kZXhdLm5vcm1hbCgpLnNjYWxlKGRpc3RhbmNlKSxcclxuICAgICAgICAgICAgICAgIGZhY2U6IHNpZGVzW2ZhY2VJbmRleF1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIHBvbHlnb24gY29sbGlkZXIgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgZ2V0IGJvdW5kcygpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBjb25zdCB0eCA9IHRoaXMuX3RyYW5zZm9ybTtcclxuICAgICAgICBjb25zdCBzY2FsZSA9IChfYSA9IHR4ID09PSBudWxsIHx8IHR4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eC5nbG9iYWxTY2FsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogVmVjdG9yLk9uZTtcclxuICAgICAgICBjb25zdCByb3RhdGlvbiA9IChfYiA9IHR4ID09PSBudWxsIHx8IHR4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0eC5nbG9iYWxSb3RhdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcclxuICAgICAgICBjb25zdCBwb3MgPSAoKF9jID0gdHggPT09IG51bGwgfHwgdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IHR4Lmdsb2JhbFBvcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogVmVjdG9yLlplcm8pLmFkZCh0aGlzLm9mZnNldCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxCb3VuZHMuc2NhbGUoc2NhbGUpLnJvdGF0ZShyb3RhdGlvbikudHJhbnNsYXRlKHBvcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgYXhpcyBhbGlnbmVkIGJvdW5kaW5nIGJveCBmb3IgdGhlIHBvbHlnb24gY29sbGlkZXIgaW4gbG9jYWwgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgZ2V0IGxvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiBCb3VuZGluZ0JveC5mcm9tUG9pbnRzKHRoaXMucG9pbnRzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtb21lbnQgb2YgaW5lcnRpYSBmb3IgYW4gYXJiaXRyYXJ5IHBvbHlnb25cclxuICAgICAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfbW9tZW50c19vZl9pbmVydGlhXHJcbiAgICAgKi9cclxuICAgIGdldEluZXJ0aWEobWFzcykge1xyXG4gICAgICAgIGxldCBudW1lcmF0b3IgPSAwO1xyXG4gICAgICAgIGxldCBkZW5vbWluYXRvciA9IDA7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBvaW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBpcGx1c29uZSA9IChpICsgMSkgJSB0aGlzLnBvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgICAgIGNvbnN0IGNyb3NzVGVybSA9IHRoaXMucG9pbnRzW2lwbHVzb25lXS5jcm9zcyh0aGlzLnBvaW50c1tpXSk7XHJcbiAgICAgICAgICAgIG51bWVyYXRvciArPVxyXG4gICAgICAgICAgICAgICAgY3Jvc3NUZXJtICpcclxuICAgICAgICAgICAgICAgICAgICAodGhpcy5wb2ludHNbaV0uZG90KHRoaXMucG9pbnRzW2ldKSArIHRoaXMucG9pbnRzW2ldLmRvdCh0aGlzLnBvaW50c1tpcGx1c29uZV0pICsgdGhpcy5wb2ludHNbaXBsdXNvbmVdLmRvdCh0aGlzLnBvaW50c1tpcGx1c29uZV0pKTtcclxuICAgICAgICAgICAgZGVub21pbmF0b3IgKz0gY3Jvc3NUZXJtO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKG1hc3MgLyA2KSAqIChudW1lcmF0b3IgLyBkZW5vbWluYXRvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhc3RzIGEgcmF5IGludG8gdGhlIHBvbHlnb24gYW5kIHJldHVybnMgYSB2ZWN0b3IgcmVwcmVzZW50aW5nIHRoZSBwb2ludCBvZiBjb250YWN0IChpbiB3b3JsZCBzcGFjZSkgb3IgbnVsbCBpZiBubyBjb2xsaXNpb24uXHJcbiAgICAgKi9cclxuICAgIHJheUNhc3QocmF5LCBtYXggPSBJbmZpbml0eSkge1xyXG4gICAgICAgIC8vIGZpbmQgdGhlIG1pbmltdW0gY29udGFjdCB0aW1lIGdyZWF0ZXIgdGhhbiAwXHJcbiAgICAgICAgLy8gY29udGFjdCB0aW1lcyBsZXNzIHRoYW4gMCBhcmUgYmVoaW5kIHRoZSByYXkgYW5kIHdlIGRvbid0IHdhbnQgdGhvc2VcclxuICAgICAgICBjb25zdCBzaWRlcyA9IHRoaXMuZ2V0U2lkZXMoKTtcclxuICAgICAgICBjb25zdCBsZW4gPSBzaWRlcy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IG1pbkNvbnRhY3RUaW1lID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBsZXQgY29udGFjdEluZGV4ID0gLTE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBjb250YWN0VGltZSA9IHJheS5pbnRlcnNlY3Qoc2lkZXNbaV0pO1xyXG4gICAgICAgICAgICBpZiAoY29udGFjdFRpbWUgPj0gMCAmJiBjb250YWN0VGltZSA8IG1pbkNvbnRhY3RUaW1lICYmIGNvbnRhY3RUaW1lIDw9IG1heCkge1xyXG4gICAgICAgICAgICAgICAgbWluQ29udGFjdFRpbWUgPSBjb250YWN0VGltZTtcclxuICAgICAgICAgICAgICAgIGNvbnRhY3RJbmRleCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29udGFjdCB3YXMgZm91bmRcclxuICAgICAgICBpZiAoY29udGFjdEluZGV4ID49IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJheS5nZXRQb2ludChtaW5Db250YWN0VGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG5vIGNvbnRhY3QgZm91bmRcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJvamVjdCB0aGUgZWRnZXMgb2YgdGhlIHBvbHlnb24gYWxvbmcgYSBzcGVjaWZpZWQgYXhpc1xyXG4gICAgICovXHJcbiAgICBwcm9qZWN0KGF4aXMpIHtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnRzKCk7XHJcbiAgICAgICAgY29uc3QgbGVuID0gcG9pbnRzLmxlbmd0aDtcclxuICAgICAgICBsZXQgbWluID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgICAgICBsZXQgbWF4ID0gLU51bWJlci5NQVhfVkFMVUU7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBzY2FsYXIgPSBwb2ludHNbaV0uZG90KGF4aXMpO1xyXG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHNjYWxhcik7XHJcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgc2NhbGFyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9qZWN0aW9uKG1pbiwgbWF4KTtcclxuICAgIH1cclxuICAgIGRyYXcoY3R4LCBjb2xvciA9IENvbG9yLkdyZWVuLCBwb3MgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZU9mZnNldCA9IHBvcy5hZGQodGhpcy5vZmZzZXQpO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gdGhpcy5wb2ludHNbMF0uYWRkKGVmZmVjdGl2ZU9mZnNldCk7XHJcbiAgICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgLy8gUG9pbnRzIGFyZSByZWxhdGl2ZVxyXG4gICAgICAgIHRoaXMucG9pbnRzXHJcbiAgICAgICAgICAgIC5tYXAoKHApID0+IHAuYWRkKGVmZmVjdGl2ZU9mZnNldCkpXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgfVxyXG4gICAgZGVidWcoZXgsIGNvbG9yKSB7XHJcbiAgICAgICAgY29uc3QgZmlyc3RQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKVswXTtcclxuICAgICAgICBjb25zdCBwb2ludHMgPSBbZmlyc3RQb2ludCwgLi4udGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpLCBmaXJzdFBvaW50XTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcclxuICAgICAgICAgICAgZXguZHJhd0xpbmUocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdLCBjb2xvciwgMik7XHJcbiAgICAgICAgICAgIGV4LmRyYXdDaXJjbGUocG9pbnRzW2ldLCAyLCBjb2xvcik7XHJcbiAgICAgICAgICAgIGV4LmRyYXdDaXJjbGUocG9pbnRzW2kgKyAxXSwgMiwgY29sb3IpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBkZWJ1Z0RyYXcoY3R4LCBjb2xvciA9IENvbG9yLlJlZCkge1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgc3VwcGxpZWQgcG9pbnRzIGFuZCBjb25zdHJ1Y3QgYSAncG9seWdvbidcclxuICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gdGhpcy5nZXRUcmFuc2Zvcm1lZFBvaW50cygpWzBdO1xyXG4gICAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xyXG4gICAgICAgIHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludHMoKS5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGN0eC5saW5lVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQ29sbGlkZXJzL1NoYXBlLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEV4Y2FsaWJ1ciBoZWxwZXIgZm9yIGRlZmluaW5nIGNvbGxpZGVycyBxdWlja2x5XHJcbiAqL1xyXG5jbGFzcyBTaGFwZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBib3ggY29sbGlkZXIsIHVuZGVyIHRoZSBob29kIGRlZmluZXMgYSBbW1BvbHlnb25Db2xsaWRlcl1dIGNvbGxpZGVyXHJcbiAgICAgKiBAcGFyYW0gd2lkdGggV2lkdGggb2YgdGhlIGJveFxyXG4gICAgICogQHBhcmFtIGhlaWdodCBIZWlnaHQgb2YgdGhlIGJveFxyXG4gICAgICogQHBhcmFtIGFuY2hvciBBbmNob3Igb2YgdGhlIGJveCAoZGVmYXVsdCAoLjUsIC41KSkgd2hpY2ggcG9zaXRpb25zIHRoZSBib3ggcmVsYXRpdmUgdG8gdGhlIGNlbnRlciBvZiB0aGUgY29sbGlkZXIncyBwb3NpdGlvblxyXG4gICAgICogQHBhcmFtIG9mZnNldCBPcHRpb25hbCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhlIGNvbGxpZGVyIGluIGxvY2FsIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBCb3god2lkdGgsIGhlaWdodCwgYW5jaG9yID0gVmVjdG9yLkhhbGYsIG9mZnNldCA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQ29sbGlkZXIoe1xyXG4gICAgICAgICAgICBwb2ludHM6IG5ldyBCb3VuZGluZ0JveCgtd2lkdGggKiBhbmNob3IueCwgLWhlaWdodCAqIGFuY2hvci55LCB3aWR0aCAtIHdpZHRoICogYW5jaG9yLngsIGhlaWdodCAtIGhlaWdodCAqIGFuY2hvci55KS5nZXRQb2ludHMoKSxcclxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXRcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBbW1BvbHlnb25Db2xsaWRlcnxhcmJpdHJhcnkgcG9seWdvbl1dIGNvbGxpZGVyXHJcbiAgICAgKlxyXG4gICAgICogUG9seWdvbkNvbGxpZGVycyBhcmUgdXNlZnVsIGZvciBjcmVhdGluZyBjb252ZXggcG9seWdvbiBzaGFwZXNcclxuICAgICAqIEBwYXJhbSBwb2ludHMgUG9pbnRzIHNwZWNpZmllZCBpbiBjb3VudGVyIGNsb2Nrd2lzZVxyXG4gICAgICogQHBhcmFtIGNsb2Nrd2lzZVdpbmRpbmcgT3B0aW9uYWxseSBjaGFuZ2VkIHRoZSB3aW5kaW5nIG9mIHBvaW50cywgYnkgZGVmYXVsdCBmYWxzZSBtZWFuaW5nIGNvdW50ZXItY2xvY2t3aXNlIHdpbmRpbmcuXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9wdGlvbmFsIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgY29sbGlkZXIgaW4gbG9jYWwgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIFBvbHlnb24ocG9pbnRzLCBjbG9ja3dpc2VXaW5kaW5nID0gZmFsc2UsIG9mZnNldCA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBQb2x5Z29uQ29sbGlkZXIoe1xyXG4gICAgICAgICAgICBwb2ludHM6IHBvaW50cyxcclxuICAgICAgICAgICAgb2Zmc2V0OiBvZmZzZXQsXHJcbiAgICAgICAgICAgIGNsb2Nrd2lzZVdpbmRpbmc6IGNsb2Nrd2lzZVdpbmRpbmdcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBbW0NpcmNsZUNvbGxpZGVyfGNpcmNsZV1dIGNvbGxpZGVyXHJcbiAgICAgKlxyXG4gICAgICogQ2lyY2xlIGNvbGxpZGVycyBhcmUgdXNlZnVsIGZvciBiYWxscywgb3IgdG8gbWFrZSBjb2xsaXNpb25zIG1vcmUgZm9yZ2l2aW5nIG9uIHNoYXJwIGVkZ2VzXHJcbiAgICAgKiBAcGFyYW0gcmFkaXVzIFJhZGl1cyBvZiB0aGUgY2lyY2xlIGNvbGxpZGVyXHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9wdGlvbmFsIG9mZnNldCByZWxhdGl2ZSB0byB0aGUgY29sbGlkZXIgaW4gbG9jYWwgY29vcmRpbmF0ZXNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIENpcmNsZShyYWRpdXMsIG9mZnNldCA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVDb2xsaWRlcih7XHJcbiAgICAgICAgICAgIHJhZGl1czogcmFkaXVzLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFtbRWRnZUNvbGxpZGVyfGVkZ2VdXSBjb2xsaWRlclxyXG4gICAgICpcclxuICAgICAqIEVkZ2UgY29sbGlkZXJzIGFyZSB1c2VmdWwgZm9yICBmbG9vcnMsIHdhbGxzLCBhbmQgb3RoZXIgYmFycmllcnNcclxuICAgICAqIEBwYXJhbSBiZWdpbiBCZWdpbm5pbmcgb2YgdGhlIGVkZ2UgaW4gbG9jYWwgY29vcmRpbmF0ZXMgdG8gdGhlIGNvbGxpZGVyXHJcbiAgICAgKiBAcGFyYW0gZW5kIEVuZGluZyBvZiB0aGUgZWRnZSBpbiBsb2NhbCBjb29yZGluYXRlcyB0byB0aGUgY29sbGlkZXJcclxuICAgICAqL1xyXG4gICAgc3RhdGljIEVkZ2UoYmVnaW4sIGVuZCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRWRnZUNvbGxpZGVyKHtcclxuICAgICAgICAgICAgYmVnaW46IGJlZ2luLFxyXG4gICAgICAgICAgICBlbmQ6IGVuZFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNhcHN1bGUgc2hhcGVkIFtbQ29tcG9zaXRlQ29sbGlkZXJdXSB1c2luZyAyIGNpcmNsZXMgYW5kIGEgYm94XHJcbiAgICAgKlxyXG4gICAgICogQ2Fwc3VsZSBjb2xsaWRlcnMgYXJlIHVzZWZ1bCBmb3IgcGxhdGZvcm1lcnMgd2l0aCBpbmNsaW5lIG9yIGphZ2dlZCBmbG9vcnMgdG8gaGF2ZSBhIHNtb290aFxyXG4gICAgICogcGxheWVyIGV4cGVyaWVuY2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHdpZHRoXHJcbiAgICAgKiBAcGFyYW0gaGVpZ2h0XHJcbiAgICAgKiBAcGFyYW0gb2Zmc2V0IE9wdGlvbmFsIG9mZnNldFxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgQ2Fwc3VsZSh3aWR0aCwgaGVpZ2h0LCBvZmZzZXQgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIGNvbnN0IGxvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIGlmICh3aWR0aCA9PT0gaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdBIGNhcHN1bGUgY29sbGlkZXIgd2l0aCBlcXVhbCB3aWR0aCBhbmQgaGVpZ2h0IGlzIGEgY2lyY2xlLCBjb25zaWRlciB1c2luZyBhIGV4LlNoYXBlLkNpcmNsZSBvciBleC5DaXJjbGVDb2xsaWRlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCB2ZXJ0aWNhbCA9IGhlaWdodCA+PSB3aWR0aDtcclxuICAgICAgICBpZiAodmVydGljYWwpIHtcclxuICAgICAgICAgICAgLy8gaGVpZ2h0ID4gd2lkdGgsIGlmIGVxdWFsIG1heWJlIHVzZSBhIGNpcmNsZVxyXG4gICAgICAgICAgICBjb25zdCBjYXBzdWxlID0gbmV3IENvbXBvc2l0ZUNvbGxpZGVyKFtcclxuICAgICAgICAgICAgICAgIFNoYXBlLkNpcmNsZSh3aWR0aCAvIDIsIHZlYygwLCAtaGVpZ2h0IC8gMiArIHdpZHRoIC8gMikuYWRkKG9mZnNldCkpLFxyXG4gICAgICAgICAgICAgICAgU2hhcGUuQm94KHdpZHRoLCBoZWlnaHQgLSB3aWR0aCwgVmVjdG9yLkhhbGYsIG9mZnNldCksXHJcbiAgICAgICAgICAgICAgICBTaGFwZS5DaXJjbGUod2lkdGggLyAyLCB2ZWMoMCwgaGVpZ2h0IC8gMiAtIHdpZHRoIC8gMikuYWRkKG9mZnNldCkpXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICByZXR1cm4gY2Fwc3VsZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHdpZHRoID4gaGVpZ2h0LCBpZiBlcXVhbCBtYXliZSB1c2UgYSBjaXJjbGVcclxuICAgICAgICAgICAgY29uc3QgY2Fwc3VsZSA9IG5ldyBDb21wb3NpdGVDb2xsaWRlcihbXHJcbiAgICAgICAgICAgICAgICBTaGFwZS5DaXJjbGUoaGVpZ2h0IC8gMiwgdmVjKC13aWR0aCAvIDIgKyBoZWlnaHQgLyAyLCAwKS5hZGQob2Zmc2V0KSksXHJcbiAgICAgICAgICAgICAgICBTaGFwZS5Cb3god2lkdGggLSBoZWlnaHQsIGhlaWdodCwgVmVjdG9yLkhhbGYsIG9mZnNldCksXHJcbiAgICAgICAgICAgICAgICBTaGFwZS5DaXJjbGUoaGVpZ2h0IC8gMiwgdmVjKHdpZHRoIC8gMiAtIGhlaWdodCAvIDIsIDApLmFkZChvZmZzZXQpKVxyXG4gICAgICAgICAgICBdKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNhcHN1bGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpZGVyQ29tcG9uZW50LnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBDb2xsaWRlckNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb2xsaWRlcikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4LmNvbGxpZGVyJztcclxuICAgICAgICB0aGlzLmV2ZW50cyA9IG5ldyBFdmVudERpc3BhdGNoZXIodGhpcyk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogT2JzZXJ2YWJsZSB0aGF0IG5vdGlmaWVzIHdoZW4gYSBjb2xsaWRlciBpcyBhZGRlZCB0byB0aGUgYm9keVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuJGNvbGxpZGVyQWRkZWQgPSBuZXcgT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE9ic2VydmFibGUgdGhhdCBub3RpZmllcyB3aGVuIGEgY29sbGlkZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSBib2R5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy4kY29sbGlkZXJSZW1vdmVkID0gbmV3IE9ic2VydmFibGUoKTtcclxuICAgICAgICB0aGlzLnNldChjb2xsaWRlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb2xsaWRlciBnZW9tZXRyeVxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgZ2V0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xsaWRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjb2xsaWRlciBnZW9tZXRyeVxyXG4gICAgICogQHBhcmFtIGNvbGxpZGVyXHJcbiAgICAgKiBAcmV0dXJucyB0aGUgY29sbGlkZXIgeW91IHNldFxyXG4gICAgICovXHJcbiAgICBzZXQoY29sbGlkZXIpIHtcclxuICAgICAgICB0aGlzLmNsZWFyKCk7XHJcbiAgICAgICAgaWYgKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyID0gY29sbGlkZXI7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyLm93bmVyID0gdGhpcy5vd25lcjtcclxuICAgICAgICAgICAgdGhpcy5ldmVudHMud2lyZShjb2xsaWRlci5ldmVudHMpO1xyXG4gICAgICAgICAgICB0aGlzLiRjb2xsaWRlckFkZGVkLm5vdGlmeUFsbChjb2xsaWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjb2xsaWRlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGNvbGxpZGVyIGdlb21ldHJ5IGZyb20gY29sbGlkZXIgY29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb2xsaWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLmV2ZW50cy51bndpcmUodGhpcy5fY29sbGlkZXIuZXZlbnRzKTtcclxuICAgICAgICAgICAgdGhpcy4kY29sbGlkZXJSZW1vdmVkLm5vdGlmeUFsbCh0aGlzLl9jb2xsaWRlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbGxpZGVyLm93bmVyID0gbnVsbDtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlkZXIgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHdvcmxkIHNwYWNlIGJvdW5kc1xyXG4gICAgICovXHJcbiAgICBnZXQgYm91bmRzKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX2NvbGxpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYm91bmRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXcgQm91bmRpbmdCb3goKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGxvY2FsIHNwYWNlIGJvdW5kc1xyXG4gICAgICovXHJcbiAgICBnZXQgbG9jYWxCb3VuZHMoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fY29sbGlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbEJvdW5kcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3IEJvdW5kaW5nQm94KCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgY29sbGlkZXIncyB0cmFuc2Zvcm1lZCBnZW9tZXRyeVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGNvbnN0IHR4ID0gKF9hID0gdGhpcy5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIGlmICh0aGlzLl9jb2xsaWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9jb2xsaWRlci5vd25lciA9IHRoaXMub3duZXI7XHJcbiAgICAgICAgICAgIGlmICh0eCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29sbGlkZXIudXBkYXRlKHR4KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29sbGlkZSBjb21wb25lbnQgd2l0aCBhbm90aGVyXHJcbiAgICAgKiBAcGFyYW0gb3RoZXJcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIGNvbGxpZGUob3RoZXIpIHtcclxuICAgICAgICBsZXQgY29sbGlkZXJBID0gdGhpcy5fY29sbGlkZXI7XHJcbiAgICAgICAgbGV0IGNvbGxpZGVyQiA9IG90aGVyLl9jb2xsaWRlcjtcclxuICAgICAgICBpZiAoIWNvbGxpZGVyQSB8fCAhY29sbGlkZXJCKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNvbXBvc2l0ZSBsZWZ0aGFuZCBzaWRlIDooXHJcbiAgICAgICAgLy8gTWlnaHQgYml0ZSB1cywgYnV0IHRvIGF2b2lkIHVwZGF0aW5nIGFsbCB0aGUgaGFuZGxlcnMgbWFrZSBjb21wb3NpdGUgYWx3YXlzIGxlZnQgc2lkZVxyXG4gICAgICAgIGxldCBmbGlwcGVkID0gZmFsc2U7XHJcbiAgICAgICAgaWYgKGNvbGxpZGVyQiBpbnN0YW5jZW9mIENvbXBvc2l0ZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyQSA9IGNvbGxpZGVyQjtcclxuICAgICAgICAgICAgY29sbGlkZXJCID0gdGhpcy5fY29sbGlkZXI7XHJcbiAgICAgICAgICAgIGZsaXBwZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgY29uc3QgY29udGFjdHMgPSBjb2xsaWRlckEuY29sbGlkZShjb2xsaWRlckIpO1xyXG4gICAgICAgICAgICBpZiAoY29udGFjdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmbGlwcGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdHMuZm9yRWFjaCgoY29udGFjdCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm10diA9IGNvbnRhY3QubXR2Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0Lm5vcm1hbCA9IGNvbnRhY3Qubm9ybWFsLm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0LnRhbmdlbnQgPSBjb250YWN0Lm5vcm1hbC5wZXJwZW5kaWN1bGFyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJBID0gdGhpcy5fY29sbGlkZXI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJCID0gb3RoZXIuX2NvbGxpZGVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRhY3RzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgb25BZGQoZW50aXR5KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdpcmUgdXAgdGhlIGNvbGxpZGVyIGV2ZW50cyB0byB0aGUgb3duaW5nIGVudGl0eVxyXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdwcmVjb2xsaXNpb24nLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHByZWNvbGxpc2lvbiA9IGV2dDtcclxuICAgICAgICAgICAgZW50aXR5LmV2ZW50cy5lbWl0KCdwcmVjb2xsaXNpb24nLCBuZXcgUHJlQ29sbGlzaW9uRXZlbnQocHJlY29sbGlzaW9uLnRhcmdldC5vd25lciwgcHJlY29sbGlzaW9uLm90aGVyLm93bmVyLCBwcmVjb2xsaXNpb24uc2lkZSwgcHJlY29sbGlzaW9uLmludGVyc2VjdGlvbikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzLm9uKCdwb3N0Y29sbGlzaW9uJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb3N0Y29sbGlzaW9uID0gZXZ0O1xyXG4gICAgICAgICAgICBlbnRpdHkuZXZlbnRzLmVtaXQoJ3Bvc3Rjb2xsaXNpb24nLCBuZXcgUG9zdENvbGxpc2lvbkV2ZW50KHBvc3Rjb2xsaXNpb24udGFyZ2V0Lm93bmVyLCBwb3N0Y29sbGlzaW9uLm90aGVyLm93bmVyLCBwb3N0Y29sbGlzaW9uLnNpZGUsIHBvc3Rjb2xsaXNpb24uaW50ZXJzZWN0aW9uKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5ldmVudHMub24oJ2NvbGxpc2lvbnN0YXJ0JywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGV2dDtcclxuICAgICAgICAgICAgZW50aXR5LmV2ZW50cy5lbWl0KCdjb2xsaXNpb25zdGFydCcsIG5ldyBDb2xsaXNpb25TdGFydEV2ZW50KHN0YXJ0LnRhcmdldC5vd25lciwgc3RhcnQub3RoZXIub3duZXIsIHN0YXJ0LmNvbnRhY3QpKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmV2ZW50cy5vbignY29sbGlzaW9uZW5kJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBlbmQgPSBldnQ7XHJcbiAgICAgICAgICAgIGVudGl0eS5ldmVudHMuZW1pdCgnY29sbGlzaW9uZW5kJywgbmV3IENvbGxpc2lvbkVuZEV2ZW50KGVuZC50YXJnZXQub3duZXIsIGVuZC5vdGhlci5vd25lcikpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgb25SZW1vdmUoKSB7XHJcbiAgICAgICAgdGhpcy5ldmVudHMuY2xlYXIoKTtcclxuICAgICAgICB0aGlzLiRjb2xsaWRlclJlbW92ZWQubm90aWZ5QWxsKHRoaXMuX2NvbGxpZGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB1cCBhIGJveCBnZW9tZXRyeSBiYXNlZCBvbiB0aGUgY3VycmVudCBib3VuZHMgb2YgdGhlIGFzc29jaWF0ZWQgYWN0b3Igb2YgdGhpcyBwaHlzaWNzIGJvZHkuXHJcbiAgICAgKlxyXG4gICAgICogSWYgbm8gd2lkdGgvaGVpZ2h0IGFyZSBzcGVjaWZpZWQgdGhlIGJvZHkgd2lsbCBhdHRlbXB0IHRvIHVzZSB0aGUgYXNzb2NpYXRlZCBhY3RvcidzIHdpZHRoL2hlaWdodC5cclxuICAgICAqXHJcbiAgICAgKiBCeSBkZWZhdWx0LCB0aGUgYm94IGlzIGNlbnRlciBpcyBhdCAoMCwgMCkgd2hpY2ggbWVhbnMgaXQgaXMgY2VudGVyZWQgYXJvdW5kIHRoZSBhY3RvcnMgYW5jaG9yLlxyXG4gICAgICovXHJcbiAgICB1c2VCb3hDb2xsaWRlcih3aWR0aCwgaGVpZ2h0LCBhbmNob3IgPSBWZWN0b3IuSGFsZiwgY2VudGVyID0gVmVjdG9yLlplcm8pIHtcclxuICAgICAgICBjb25zdCBjb2xsaWRlciA9IFNoYXBlLkJveCh3aWR0aCwgaGVpZ2h0LCBhbmNob3IsIGNlbnRlcik7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNldChjb2xsaWRlcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHVwIGEgW1tQb2x5Z29uQ29sbGlkZXJ8cG9seWdvbl1dIGNvbGxpc2lvbiBnZW9tZXRyeSBiYXNlZCBvbiBhIGxpc3Qgb2Ygb2YgcG9pbnRzIHJlbGF0aXZlXHJcbiAgICAgKiAgdG8gdGhlIGFuY2hvciBvZiB0aGUgYXNzb2NpYXRlZCBhY3RvclxyXG4gICAgICogb2YgdGhpcyBwaHlzaWNzIGJvZHkuXHJcbiAgICAgKlxyXG4gICAgICogT25seSBbY29udmV4IHBvbHlnb25dKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbnZleF9wb2x5Z29uKSBkZWZpbml0aW9ucyBhcmUgc3VwcG9ydGVkLlxyXG4gICAgICpcclxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBib3ggaXMgY2VudGVyIGlzIGF0ICgwLCAwKSB3aGljaCBtZWFucyBpdCBpcyBjZW50ZXJlZCBhcm91bmQgdGhlIGFjdG9ycyBhbmNob3IuXHJcbiAgICAgKi9cclxuICAgIHVzZVBvbHlnb25Db2xsaWRlcihwb2ludHMsIGNlbnRlciA9IFZlY3Rvci5aZXJvKSB7XHJcbiAgICAgICAgY29uc3QgcG9seSA9IFNoYXBlLlBvbHlnb24ocG9pbnRzLCBmYWxzZSwgY2VudGVyKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc2V0KHBvbHkpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB1cCBhIFtbQ2lyY2xlfGNpcmNsZSBjb2xsaXNpb24gZ2VvbWV0cnldXSBhcyB0aGUgb25seSBjb2xsaWRlciB3aXRoIGEgc3BlY2lmaWVkIHJhZGl1cyBpbiBwaXhlbHMuXHJcbiAgICAgKlxyXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIGJveCBpcyBjZW50ZXIgaXMgYXQgKDAsIDApIHdoaWNoIG1lYW5zIGl0IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYWN0b3JzIGFuY2hvci5cclxuICAgICAqL1xyXG4gICAgdXNlQ2lyY2xlQ29sbGlkZXIocmFkaXVzLCBjZW50ZXIgPSBWZWN0b3IuWmVybykge1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVyID0gU2hhcGUuQ2lyY2xlKHJhZGl1cywgY2VudGVyKTtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc2V0KGNvbGxpZGVyKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdXAgYW4gW1tFZGdlfGVkZ2UgY29sbGlzaW9uIGdlb21ldHJ5XV0gd2l0aCBhIHN0YXJ0IHBvaW50IGFuZCBhbiBlbmQgcG9pbnQgcmVsYXRpdmUgdG8gdGhlIGFuY2hvciBvZiB0aGUgYXNzb2NpYXRlZCBhY3RvclxyXG4gICAgICogb2YgdGhpcyBwaHlzaWNzIGJvZHkuXHJcbiAgICAgKlxyXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIGJveCBpcyBjZW50ZXIgaXMgYXQgKDAsIDApIHdoaWNoIG1lYW5zIGl0IGlzIGNlbnRlcmVkIGFyb3VuZCB0aGUgYWN0b3JzIGFuY2hvci5cclxuICAgICAqL1xyXG4gICAgdXNlRWRnZUNvbGxpZGVyKGJlZ2luLCBlbmQpIHtcclxuICAgICAgICBjb25zdCBjb2xsaWRlciA9IFNoYXBlLkVkZ2UoYmVnaW4sIGVuZCk7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLnNldChjb2xsaWRlcikpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXR1cHMgdXAgYSBbW0NvbXBvc2l0ZUNvbGxpZGVyXV0gd2hpY2ggY2FuIGRlZmluZSBhbnkgYXJiaXRyYXJ5IHNldCBvZiBleGNhbGlidXIgY29sbGlkZXJzXHJcbiAgICAgKiBAcGFyYW0gY29sbGlkZXJzXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICB1c2VDb21wb3NpdGVDb2xsaWRlcihjb2xsaWRlcnMpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuc2V0KG5ldyBDb21wb3NpdGVDb2xsaWRlcihjb2xsaWRlcnMpKSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9Db2xsaXNpb24vQm9keUNvbXBvbmVudC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgRGVncmVlT2ZGcmVlZG9tO1xyXG4oZnVuY3Rpb24gKERlZ3JlZU9mRnJlZWRvbSkge1xyXG4gICAgRGVncmVlT2ZGcmVlZG9tW1wiUm90YXRpb25cIl0gPSBcInJvdGF0aW9uXCI7XHJcbiAgICBEZWdyZWVPZkZyZWVkb21bXCJYXCJdID0gXCJ4XCI7XHJcbiAgICBEZWdyZWVPZkZyZWVkb21bXCJZXCJdID0gXCJ5XCI7XHJcbn0pKERlZ3JlZU9mRnJlZWRvbSB8fCAoRGVncmVlT2ZGcmVlZG9tID0ge30pKTtcclxuLyoqXHJcbiAqIEJvZHkgZGVzY3JpYmVzIGFsbCB0aGUgcGh5c2ljYWwgcHJvcGVydGllcyBwb3MsIHZlbCwgYWNjLCByb3RhdGlvbiwgYW5ndWxhciB2ZWxvY2l0eSBmb3IgdGhlIHB1cnBvc2Ugb2ZcclxuICogb2YgcGh5c2ljcyBzaW11bGF0aW9uLlxyXG4gKi9cclxuY2xhc3MgQm9keUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZXguYm9keSc7XHJcbiAgICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbVHJhbnNmb3JtQ29tcG9uZW50LCBNb3Rpb25Db21wb25lbnRdO1xyXG4gICAgICAgIHRoaXMuaWQgPSBjcmVhdGVJZCgnYm9keScsIEJvZHlDb21wb25lbnQuX0lEKyspO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcih0aGlzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsaXNpb24gdHlwZSBmb3IgdGhlIHJpZ2lkYm9keSBwaHlzaWNzIHNpbXVsYXRpb24sIGJ5IGRlZmF1bHQgW1tDb2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb25dXVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29sbGlzaW9uVHlwZSA9IENvbGxpc2lvblR5cGUuUHJldmVudENvbGxpc2lvbjtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgY29sbGlzaW9uIGdyb3VwIGZvciB0aGUgYm9keSdzIGNvbGxpZGVycywgYnkgZGVmYXVsdCBib2R5IGNvbGxpZGVycyBjb2xsaWRlIHdpdGggZXZlcnl0aGluZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ3JvdXAgPSBDb2xsaXNpb25Hcm91cC5BbGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFtb3VudCBvZiBtYXNzIHRoZSBib2R5IGhhc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWFzcyA9IFBoeXNpY3MuZGVmYXVsdE1hc3M7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW1vdW50IG9mIFwibW90aW9uXCIgdGhlIGJvZHkgaGFzIGJlZm9yZSBzbGVlcGluZy4gSWYgYmVsb3cgW1tQaHlzaWNzLnNsZWVwRXBzaWxvbl1dIGl0IGdvZXMgdG8gXCJzbGVlcFwiXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zbGVlcE1vdGlvbiA9IFBoeXNpY3Muc2xlZXBFcHNpbG9uICogNTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW4gdGhpcyBib2R5IHNsZWVwLCBieSBkZWZhdWx0IGJvZGllcyBkbyBub3Qgc2xlZXBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhblNsZWVwID0gUGh5c2ljcy5ib2RpZXNDYW5TbGVlcEJ5RGVmYXVsdDtcclxuICAgICAgICB0aGlzLl9zbGVlcGluZyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBhbHNvIGtub3duIGFzIGNvZWZmaWNpZW50IG9mIHJlc3RpdHV0aW9uIG9mIHRoaXMgYWN0b3IsIHJlcHJlc2VudHMgdGhlIGFtb3VudCBvZiBlbmVyZ3kgcHJlc2VydmVkIGFmdGVyIGNvbGxpc2lvbiBvciB0aGVcclxuICAgICAgICAgKiBib3VuY2luZXNzLiBJZiAxLCBpdCBpcyAxMDAlIGJvdW5jeSwgMCBpdCBjb21wbGV0ZWx5IGFic29yYnMuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ib3VuY2luZXNzID0gMC4yO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBjb2VmZmljaWVudCBvZiBmcmljdGlvbiBvbiB0aGlzIGFjdG9yXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5mcmljdGlvbiA9IDAuOTk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2hvdWxkIHVzZSBnbG9iYWwgZ3Jhdml0eSBbW1BoeXNpY3MuZ3Jhdml0eV1dIGluIGl0J3MgcGh5c2ljcyBzaW11bGF0aW9uLCBkZWZhdWx0IGlzIHRydWVcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnVzZUdyYXZpdHkgPSB0cnVlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERlZ3JlZXMgb2YgZnJlZWRvbSB0byBsaW1pdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGltaXREZWdyZWVPZkZyZWVkb20gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgcG9zaXRpb24gb2YgdGhlIGFjdG9yIGxhc3QgZnJhbWUgKHgsIHkpIGluIHBpeGVsc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2xkUG9zID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGxhc3QgZnJhbWUgKHZ4LCB2eSkgaW4gcGl4ZWxzL3NlY29uZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2xkVmVsID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzL3NldHMgdGhlIGFjY2VsZXJhdGlvbiBvZiB0aGUgYWN0b3IgZnJvbSB0aGUgbGFzdCBmcmFtZS4gVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSBnbG9iYWwgYWNjIFtbUGh5c2ljcy5hY2NdXS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9sZEFjYyA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMvc2V0cyB0aGUgcm90YXRpb24gb2YgdGhlIGJvZHkgZnJvbSB0aGUgbGFzdCBmcmFtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9sZFJvdGF0aW9uID0gMDsgLy8gcmFkaWFuc1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzY2FsZSBvZiB0aGUgYWN0b3IgbGFzdCBmcmFtZVxyXG4gICAgICAgICAqIEBkZXByZWNhdGVkIGV4LkJvZHkuc2NhbGUgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI1LjBcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm9sZFNjYWxlID0gVmVjdG9yLk9uZTtcclxuICAgICAgICBpZiAob3B0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLmNvbGxpc2lvblR5cGUgPSAoX2EgPSBvcHRpb25zLnR5cGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuY29sbGlzaW9uVHlwZTtcclxuICAgICAgICAgICAgdGhpcy5ncm91cCA9IChfYiA9IG9wdGlvbnMuZ3JvdXApICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuZ3JvdXA7XHJcbiAgICAgICAgICAgIHRoaXMudXNlR3Jhdml0eSA9IChfYyA9IG9wdGlvbnMudXNlR3Jhdml0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdGhpcy51c2VHcmF2aXR5O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGludmVyc2UgbWFzcyAoMS9tYXNzKSBvZiB0aGUgYm9keS4gSWYgW1tDb2xsaXNpb25UeXBlLkZpeGVkXV0gdGhpcyBpcyAwLCBtZWFuaW5nIFwiaW5maW5pdGVcIiBtYXNzXHJcbiAgICAgKi9cclxuICAgIGdldCBpbnZlcnNlTWFzcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLkZpeGVkID8gMCA6IDEgLyB0aGlzLm1hc3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgdGhpcyBib2R5IGlzIHNsZWVwaW5nIG9yIG5vdFxyXG4gICAgICovXHJcbiAgICBnZXQgc2xlZXBpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsZWVwaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIHNsZWVwIHN0YXRlIG9mIHRoZSBib2R5XHJcbiAgICAgKiBAcGFyYW0gc2xlZXBpbmdcclxuICAgICAqL1xyXG4gICAgc2V0U2xlZXBpbmcoc2xlZXBpbmcpIHtcclxuICAgICAgICB0aGlzLl9zbGVlcGluZyA9IHNsZWVwaW5nO1xyXG4gICAgICAgIGlmICghc2xlZXBpbmcpIHtcclxuICAgICAgICAgICAgLy8gR2l2ZSBpdCBhIGtpY2sgdG8ga2VlcCBpdCBmcm9tIGZhbGxpbmcgYXNsZWVwIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgIHRoaXMuc2xlZXBNb3Rpb24gPSBQaHlzaWNzLnNsZWVwRXBzaWxvbiAqIDU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnZlbCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgICAgICB0aGlzLmFjYyA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuc2xlZXBNb3Rpb24gPSAwO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIGJvZHkncyBbW0JvZHlDb21wb25lbnQuc2xlZXBNb3Rpb25dXSBmb3IgdGhlIHB1cnBvc2Ugb2Ygc2xlZXBpbmdcclxuICAgICAqL1xyXG4gICAgdXBkYXRlTW90aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zbGVlcGluZykge1xyXG4gICAgICAgICAgICB0aGlzLnNldFNsZWVwaW5nKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjdXJyZW50TW90aW9uID0gdGhpcy52ZWwuc2l6ZSAqIHRoaXMudmVsLnNpemUgKyBNYXRoLmFicyh0aGlzLmFuZ3VsYXJWZWxvY2l0eSAqIHRoaXMuYW5ndWxhclZlbG9jaXR5KTtcclxuICAgICAgICBjb25zdCBiaWFzID0gUGh5c2ljcy5zbGVlcEJpYXM7XHJcbiAgICAgICAgdGhpcy5zbGVlcE1vdGlvbiA9IGJpYXMgKiB0aGlzLnNsZWVwTW90aW9uICsgKDEgLSBiaWFzKSAqIGN1cnJlbnRNb3Rpb247XHJcbiAgICAgICAgdGhpcy5zbGVlcE1vdGlvbiA9IGNsYW1wKHRoaXMuc2xlZXBNb3Rpb24sIDAsIDEwICogUGh5c2ljcy5zbGVlcEVwc2lsb24pO1xyXG4gICAgICAgIGlmICh0aGlzLmNhblNsZWVwICYmIHRoaXMuc2xlZXBNb3Rpb24gPCBQaHlzaWNzLnNsZWVwRXBzaWxvbikge1xyXG4gICAgICAgICAgICB0aGlzLnNldFNsZWVwaW5nKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBtb21lbnQgb2YgaW5lcnRpYSBmcm9tIHRoZSBbW0NvbGxpZGVyQ29tcG9uZW50XV1cclxuICAgICAqL1xyXG4gICAgZ2V0IGluZXJ0aWEoKSB7XHJcbiAgICAgICAgLy8gSW5lcnRpYSBpcyBhIHByb3BlcnR5IG9mIHRoZSBnZW9tZXRyeSwgc28gdGhpcyBpcyBhIGxpdHRsZSBnb29meSBidXQgc2VlbXMgdG8gYmUgb2theT9cclxuICAgICAgICBjb25zdCBjb2xsaWRlciA9IHRoaXMub3duZXIuZ2V0KENvbGxpZGVyQ29tcG9uZW50KTtcclxuICAgICAgICBpZiAoY29sbGlkZXIgPT09IG51bGwgfHwgY29sbGlkZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbGxpZGVyLmdldCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb2xsaWRlci5nZXQoKS5nZXRJbmVydGlhKHRoaXMubWFzcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGludmVyc2UgbW9tZW50IG9mIGluZXJ0aWFsIGZyb20gdGhlIFtbQ29sbGlkZXJDb21wb25lbnRdXS4gSWYgW1tDb2xsaXNpb25UeXBlLkZpeGVkXV0gdGhpcyBpcyAwLCBtZWFuaW5nIFwiaW5maW5pdGVcIiBtYXNzXHJcbiAgICAgKi9cclxuICAgIGdldCBpbnZlcnNlSW5lcnRpYSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLkZpeGVkID8gMCA6IDEgLyB0aGlzLmluZXJ0aWE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaWYgdGhlIG93bmVyIGlzIGFjdGl2ZVxyXG4gICAgICovXHJcbiAgICBnZXQgYWN0aXZlKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gISEoKF9hID0gdGhpcy5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZSk7XHJcbiAgICB9XHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvcztcclxuICAgIH1cclxuICAgIGdldCB0cmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBnZXQgbW90aW9uKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgKHgsIHkpIHBvc2l0aW9uIG9mIHRoZSBhY3RvciB0aGlzIHdpbGwgYmUgaW4gdGhlIG1pZGRsZSBvZiB0aGUgYWN0b3IgaWYgdGhlXHJcbiAgICAgKiBbW0FjdG9yLmFuY2hvcl1dIGlzIHNldCB0byAoMC41LCAwLjUpIHdoaWNoIGlzIGRlZmF1bHQuXHJcbiAgICAgKiBJZiB5b3Ugd2FudCB0aGUgKHgsIHkpIHBvc2l0aW9uIHRvIGJlIHRoZSB0b3AgbGVmdCBvZiB0aGUgYWN0b3Igc3BlY2lmeSBhbiBhbmNob3Igb2YgKDAsIDApLlxyXG4gICAgICovXHJcbiAgICBnZXQgcG9zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5nbG9iYWxQb3M7XHJcbiAgICB9XHJcbiAgICBzZXQgcG9zKHZhbCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmdsb2JhbFBvcyA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgdmVsb2NpdHkgdmVjdG9yICh2eCwgdnkpIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kXHJcbiAgICAgKi9cclxuICAgIGdldCB2ZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLnZlbDtcclxuICAgIH1cclxuICAgIHNldCB2ZWwodmFsKSB7XHJcbiAgICAgICAgdGhpcy5tb3Rpb24udmVsID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY3VycmVudCBhY2NlbGVyYXRpb24gdmVjdG9yIChheCwgYXkpIG9mIHRoZSBhY3RvciBpbiBwaXhlbHMvc2Vjb25kL3NlY29uZC4gQW4gYWNjZWxlcmF0aW9uIHBvaW50aW5nIGRvd24gc3VjaCBhcyAoMCwgMTAwKSBtYXlcclxuICAgICAqIGJlIHVzZWZ1bCB0byBzaW11bGF0ZSBhIGdyYXZpdGF0aW9uYWwgZWZmZWN0LlxyXG4gICAgICovXHJcbiAgICBnZXQgYWNjKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm1vdGlvbi5hY2M7XHJcbiAgICB9XHJcbiAgICBzZXQgYWNjKHZhbCkge1xyXG4gICAgICAgIHRoaXMubW90aW9uLmFjYyA9IHZhbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGN1cnJlbnQgdG9ycXVlIGFwcGxpZWQgdG8gdGhlIGFjdG9yXHJcbiAgICAgKi9cclxuICAgIGdldCB0b3JxdWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLnRvcnF1ZTtcclxuICAgIH1cclxuICAgIHNldCB0b3JxdWUodmFsKSB7XHJcbiAgICAgICAgdGhpcy5tb3Rpb24udG9ycXVlID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcm90YXRpb24gb2YgdGhlIGJvZHkgaW4gcmFkaWFuc1xyXG4gICAgICovXHJcbiAgICBnZXQgcm90YXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmdsb2JhbFJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgc2V0IHJvdGF0aW9uKHZhbCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmdsb2JhbFJvdGF0aW9uID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgc2NhbGUgdmVjdG9yIG9mIHRoZSBhY3RvclxyXG4gICAgICogQGRlcHJlY2F0ZWQgZXguQm9keS5zY2FsZSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjUuMCwgVXNlIGV4LlRyYW5zZm9ybS5zY2FsZVxyXG4gICAgICovXHJcbiAgICBnZXQgc2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLmdsb2JhbFNjYWxlO1xyXG4gICAgfVxyXG4gICAgc2V0IHNjYWxlKHZhbCkge1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmdsb2JhbFNjYWxlID0gdmFsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgeCBzY2FsYXIgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHNjYWxlL3NlY29uZFxyXG4gICAgICogQGRlcHJlY2F0ZWQgZXguQm9keS5zY2FsZSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjUuMFxyXG4gICAgICovXHJcbiAgICBnZXQgc3goKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLnNjYWxlRmFjdG9yLng7XHJcbiAgICB9XHJcbiAgICBzZXQgc3goeEZhY3Rvcikge1xyXG4gICAgICAgIHRoaXMubW90aW9uLnNjYWxlRmFjdG9yLnggPSB4RmFjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgeSBzY2FsYXIgdmVsb2NpdHkgb2YgdGhlIGFjdG9yIGluIHNjYWxlL3NlY29uZFxyXG4gICAgICogQGRlcHJlY2F0ZWQgZXguQm9keS5zY2FsZSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjUuMFxyXG4gICAgICovXHJcbiAgICBnZXQgc3koKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubW90aW9uLnNjYWxlRmFjdG9yLnk7XHJcbiAgICB9XHJcbiAgICBzZXQgc3koeUZhY3Rvcikge1xyXG4gICAgICAgIHRoaXMubW90aW9uLnNjYWxlRmFjdG9yLnkgPSB5RmFjdG9yO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy9zZWNvbmRcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIGdldCByeCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb3Rpb24uYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy9zZWNvbmRcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIHNldCByeCh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMubW90aW9uLmFuZ3VsYXJWZWxvY2l0eSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgaW4gcmFkaWFucy9zZWNvbmRcclxuICAgICAqL1xyXG4gICAgZ2V0IGFuZ3VsYXJWZWxvY2l0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb3Rpb24uYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXQgdGhlIGFuZ3VsYXIgdmVsb2NpdHkgaW4gcmFkaWFucy9zZWNvbmRcclxuICAgICAqL1xyXG4gICAgc2V0IGFuZ3VsYXJWZWxvY2l0eSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMubW90aW9uLmFuZ3VsYXJWZWxvY2l0eSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBhIHNwZWNpZmljIGltcHVsc2UgdG8gdGhlIGJvZHlcclxuICAgICAqIEBwYXJhbSBwb2ludFxyXG4gICAgICogQHBhcmFtIGltcHVsc2VcclxuICAgICAqL1xyXG4gICAgYXBwbHlJbXB1bHNlKHBvaW50LCBpbXB1bHNlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29sbGlzaW9uVHlwZSAhPT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuOyAvLyBvbmx5IGFjdGl2ZSBvYmplY3RzIHBhcnRpY2lwYXRlIGluIHRoZSBzaW11bGF0aW9uXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpbmFsSW1wdWxzZSA9IGltcHVsc2Uuc2NhbGUodGhpcy5pbnZlcnNlTWFzcyk7XHJcbiAgICAgICAgaWYgKHRoaXMubGltaXREZWdyZWVPZkZyZWVkb20uaW5jbHVkZXMoRGVncmVlT2ZGcmVlZG9tLlgpKSB7XHJcbiAgICAgICAgICAgIGZpbmFsSW1wdWxzZS54ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMubGltaXREZWdyZWVPZkZyZWVkb20uaW5jbHVkZXMoRGVncmVlT2ZGcmVlZG9tLlkpKSB7XHJcbiAgICAgICAgICAgIGZpbmFsSW1wdWxzZS55ID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52ZWwuYWRkRXF1YWwoZmluYWxJbXB1bHNlKTtcclxuICAgICAgICBpZiAoIXRoaXMubGltaXREZWdyZWVPZkZyZWVkb20uaW5jbHVkZXMoRGVncmVlT2ZGcmVlZG9tLlJvdGF0aW9uKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZUZyb21DZW50ZXIgPSBwb2ludC5zdWIodGhpcy5wb3MpO1xyXG4gICAgICAgICAgICB0aGlzLmFuZ3VsYXJWZWxvY2l0eSArPSB0aGlzLmludmVyc2VJbmVydGlhICogZGlzdGFuY2VGcm9tQ2VudGVyLmNyb3NzKGltcHVsc2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXBwbHkgb25seSBsaW5lYXIgaW1wdWxzZSB0byB0aGUgYm9keVxyXG4gICAgICogQHBhcmFtIGltcHVsc2VcclxuICAgICAqL1xyXG4gICAgYXBwbHlMaW5lYXJJbXB1bHNlKGltcHVsc2UpIHtcclxuICAgICAgICBpZiAodGhpcy5jb2xsaXNpb25UeXBlICE9PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIG9ubHkgYWN0aXZlIG9iamVjdHMgcGFydGljaXBhdGUgaW4gdGhlIHNpbXVsYXRpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZmluYWxJbXB1bHNlID0gaW1wdWxzZS5zY2FsZSh0aGlzLmludmVyc2VNYXNzKTtcclxuICAgICAgICBpZiAodGhpcy5saW1pdERlZ3JlZU9mRnJlZWRvbS5pbmNsdWRlcyhEZWdyZWVPZkZyZWVkb20uWCkpIHtcclxuICAgICAgICAgICAgZmluYWxJbXB1bHNlLnggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5saW1pdERlZ3JlZU9mRnJlZWRvbS5pbmNsdWRlcyhEZWdyZWVPZkZyZWVkb20uWSkpIHtcclxuICAgICAgICAgICAgZmluYWxJbXB1bHNlLnkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnZlbCA9IHRoaXMudmVsLmFkZChmaW5hbEltcHVsc2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBseSBvbmx5IGFuZ3VsYXIgaW1wdXNlIHRvIHRoZSBib2R5XHJcbiAgICAgKiBAcGFyYW0gcG9pbnRcclxuICAgICAqIEBwYXJhbSBpbXB1bHNlXHJcbiAgICAgKi9cclxuICAgIGFwcGx5QW5ndWxhckltcHVsc2UocG9pbnQsIGltcHVsc2UpIHtcclxuICAgICAgICBpZiAodGhpcy5jb2xsaXNpb25UeXBlICE9PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIG9ubHkgYWN0aXZlIG9iamVjdHMgcGFydGljaXBhdGUgaW4gdGhlIHNpbXVsYXRpb25cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLmxpbWl0RGVncmVlT2ZGcmVlZG9tLmluY2x1ZGVzKERlZ3JlZU9mRnJlZWRvbS5Sb3RhdGlvbikpIHtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VGcm9tQ2VudGVyID0gcG9pbnQuc3ViKHRoaXMucG9zKTtcclxuICAgICAgICAgICAgdGhpcy5hbmd1bGFyVmVsb2NpdHkgKz0gdGhpcy5pbnZlcnNlSW5lcnRpYSAqIGRpc3RhbmNlRnJvbUNlbnRlci5jcm9zcyhpbXB1bHNlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIG9sZCB2ZXJzaW9ucyBvZiBwb3MsIHZlbCwgYWNjLCBhbmQgc2NhbGUuXHJcbiAgICAgKi9cclxuICAgIGNhcHR1cmVPbGRUcmFuc2Zvcm0oKSB7XHJcbiAgICAgICAgLy8gQ2FwdHVyZSBvbGQgdmFsdWVzIGJlZm9yZSBpbnRlZ3JhdGlvbiBzdGVwIHVwZGF0ZXMgdGhlbVxyXG4gICAgICAgIHRoaXMub2xkVmVsLnNldFRvKHRoaXMudmVsLngsIHRoaXMudmVsLnkpO1xyXG4gICAgICAgIHRoaXMub2xkUG9zLnNldFRvKHRoaXMucG9zLngsIHRoaXMucG9zLnkpO1xyXG4gICAgICAgIHRoaXMub2xkQWNjLnNldFRvKHRoaXMuYWNjLngsIHRoaXMuYWNjLnkpO1xyXG4gICAgICAgIHRoaXMub2xkU2NhbGUuc2V0VG8odGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gICAgICAgIHRoaXMub2xkUm90YXRpb24gPSB0aGlzLnJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgZGVidWdEcmF3KF9jdHgpIHtcclxuICAgICAgICAvLyBwYXNzXHJcbiAgICB9XHJcbn1cclxuQm9keUNvbXBvbmVudC5fSUQgPSAwO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvQ3VsbGluZ0JveC50c1xuXHJcblxyXG4vKipcclxuICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIDAuMjYuMFxyXG4gKi9cclxuY2xhc3MgQ3VsbGluZ0JveCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl90b3BMZWZ0ID0gbmV3IFZlY3RvcigwLCAwKTtcclxuICAgICAgICB0aGlzLl90b3BSaWdodCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fYm90dG9tTGVmdCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fYm90dG9tUmlnaHQgPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgfVxyXG4gICAgaXNTcHJpdGVPZmZTY3JlZW4oYWN0b3IsIGVuZ2luZSkge1xyXG4gICAgICAgIGNvbnN0IGRyYXdpbmdXaWR0aCA9IGFjdG9yLmN1cnJlbnREcmF3aW5nLmRyYXdXaWR0aDtcclxuICAgICAgICBjb25zdCBkcmF3aW5nSGVpZ2h0ID0gYWN0b3IuY3VycmVudERyYXdpbmcuZHJhd0hlaWdodDtcclxuICAgICAgICBjb25zdCByb3RhdGlvbiA9IGFjdG9yLnJvdGF0aW9uO1xyXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGFjdG9yLmNlbnRlcjtcclxuICAgICAgICBjb25zdCB3b3JsZFBvcyA9IGFjdG9yLmdldEdsb2JhbFBvcygpO1xyXG4gICAgICAgIHRoaXMuX3RvcExlZnQgPSB2ZWMod29ybGRQb3MueCAtIGRyYXdpbmdXaWR0aCAvIDIsIHdvcmxkUG9zLnkgLSBkcmF3aW5nSGVpZ2h0IC8gMik7XHJcbiAgICAgICAgdGhpcy5fdG9wTGVmdCA9IHRoaXMuX3RvcExlZnQucm90YXRlKHJvdGF0aW9uLCBhbmNob3IpO1xyXG4gICAgICAgIHRoaXMuX3RvcFJpZ2h0ID0gdmVjKHdvcmxkUG9zLnggKyBkcmF3aW5nV2lkdGggLyAyLCB3b3JsZFBvcy55IC0gZHJhd2luZ0hlaWdodCAvIDIpO1xyXG4gICAgICAgIHRoaXMuX3RvcFJpZ2h0ID0gdGhpcy5fdG9wUmlnaHQucm90YXRlKHJvdGF0aW9uLCBhbmNob3IpO1xyXG4gICAgICAgIHRoaXMuX2JvdHRvbUxlZnQgPSB2ZWMod29ybGRQb3MueCAtIGRyYXdpbmdXaWR0aCAvIDIsIHdvcmxkUG9zLnkgKyBkcmF3aW5nSGVpZ2h0IC8gMik7XHJcbiAgICAgICAgdGhpcy5fYm90dG9tTGVmdCA9IHRoaXMuX2JvdHRvbUxlZnQucm90YXRlKHJvdGF0aW9uLCBhbmNob3IpO1xyXG4gICAgICAgIHRoaXMuX2JvdHRvbVJpZ2h0ID0gdmVjKHdvcmxkUG9zLnggKyBkcmF3aW5nV2lkdGggLyAyLCB3b3JsZFBvcy55ICsgZHJhd2luZ0hlaWdodCAvIDIpO1xyXG4gICAgICAgIHRoaXMuX2JvdHRvbVJpZ2h0ID0gdGhpcy5fYm90dG9tUmlnaHQucm90YXRlKHJvdGF0aW9uLCBhbmNob3IpO1xyXG4gICAgICAgIGNvbnN0IHRvcExlZnRTY3JlZW4gPSBlbmdpbmUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKHRoaXMuX3RvcExlZnQpO1xyXG4gICAgICAgIGNvbnN0IHRvcFJpZ2h0U2NyZWVuID0gZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyh0aGlzLl90b3BSaWdodCk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tTGVmdFNjcmVlbiA9IGVuZ2luZS53b3JsZFRvU2NyZWVuQ29vcmRpbmF0ZXModGhpcy5fYm90dG9tTGVmdCk7XHJcbiAgICAgICAgY29uc3QgYm90dG9tUmlnaHRTY3JlZW4gPSBlbmdpbmUud29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKHRoaXMuX2JvdHRvbVJpZ2h0KTtcclxuICAgICAgICB0aGlzLl94Q29vcmRzID0gW107XHJcbiAgICAgICAgdGhpcy5feUNvb3JkcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3hDb29yZHMucHVzaCh0b3BMZWZ0U2NyZWVuLngsIHRvcFJpZ2h0U2NyZWVuLngsIGJvdHRvbUxlZnRTY3JlZW4ueCwgYm90dG9tUmlnaHRTY3JlZW4ueCk7XHJcbiAgICAgICAgdGhpcy5feUNvb3Jkcy5wdXNoKHRvcExlZnRTY3JlZW4ueSwgdG9wUmlnaHRTY3JlZW4ueSwgYm90dG9tTGVmdFNjcmVlbi55LCBib3R0b21SaWdodFNjcmVlbi55KTtcclxuICAgICAgICB0aGlzLl94TWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgdGhpcy5feENvb3Jkcyk7XHJcbiAgICAgICAgdGhpcy5feU1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIHRoaXMuX3lDb29yZHMpO1xyXG4gICAgICAgIHRoaXMuX3hNYXggPSBNYXRoLm1heC5hcHBseShudWxsLCB0aGlzLl94Q29vcmRzKTtcclxuICAgICAgICB0aGlzLl95TWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgdGhpcy5feUNvb3Jkcyk7XHJcbiAgICAgICAgY29uc3QgbWluV29ybGQgPSBlbmdpbmUuc2NyZWVuVG9Xb3JsZENvb3JkaW5hdGVzKG5ldyBWZWN0b3IodGhpcy5feE1pbiwgdGhpcy5feU1pbikpO1xyXG4gICAgICAgIGNvbnN0IG1heFdvcmxkID0gZW5naW5lLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhuZXcgVmVjdG9yKHRoaXMuX3hNYXgsIHRoaXMuX3lNYXgpKTtcclxuICAgICAgICB0aGlzLl94TWluV29ybGQgPSBtaW5Xb3JsZC54O1xyXG4gICAgICAgIHRoaXMuX3lNaW5Xb3JsZCA9IG1pbldvcmxkLnk7XHJcbiAgICAgICAgdGhpcy5feE1heFdvcmxkID0gbWF4V29ybGQueDtcclxuICAgICAgICB0aGlzLl95TWF4V29ybGQgPSBtYXhXb3JsZC55O1xyXG4gICAgICAgIGNvbnN0IGJvdW5kaW5nUG9pbnRzID0gW1xyXG4gICAgICAgICAgICBuZXcgVmVjdG9yKHRoaXMuX3hNaW4sIHRoaXMuX3lNaW4pLFxyXG4gICAgICAgICAgICBuZXcgVmVjdG9yKHRoaXMuX3hNYXgsIHRoaXMuX3lNaW4pLFxyXG4gICAgICAgICAgICBuZXcgVmVjdG9yKHRoaXMuX3hNaW4sIHRoaXMuX3lNYXgpLFxyXG4gICAgICAgICAgICBuZXcgVmVjdG9yKHRoaXMuX3hNYXgsIHRoaXMuX3lNYXgpIC8vIGJvdHRvbSByaWdodFxyXG4gICAgICAgIF07XHJcbiAgICAgICAgLy8gc3ByaXRlIGNhbiBiZSB3aWRlciB0aGFuIGNhbnZhcyBzY3JlZW4gKGFuZCBzdGlsbCB2aXNpYmxlIHdpdGhpbiBjYW52YXMpXHJcbiAgICAgICAgLy8gdG9wIG9yIGJvdHRvbSBvZiBzcHJpdGUgbXVzdCBiZSB3aXRoaW4gY2FudmFzXHJcbiAgICAgICAgaWYgKGJvdW5kaW5nUG9pbnRzWzBdLnggPCAwICYmXHJcbiAgICAgICAgICAgIGJvdW5kaW5nUG9pbnRzWzFdLnggPiBlbmdpbmUuY2FudmFzLmNsaWVudFdpZHRoICYmXHJcbiAgICAgICAgICAgIChib3VuZGluZ1BvaW50c1swXS55ID4gMCB8fCBib3VuZGluZ1BvaW50c1syXS55IDwgZW5naW5lLmNhbnZhcy5jbGllbnRIZWlnaHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gc3ByaXRlIGNhbiBiZSB0YWxsZXIgdGhhbiBjYW52YXMgc2NyZWVuIChhbmQgc3RpbGwgdmlzaWJsZSB3aXRoaW4gY2FudmFzKVxyXG4gICAgICAgIC8vIGxlZnQgb3IgcmlnaHQgb2Ygc3ByaXRlIG11c3QgYmUgd2l0aGluIGNhbnZhc1xyXG4gICAgICAgIGlmIChib3VuZGluZ1BvaW50c1swXS55IDwgMCAmJlxyXG4gICAgICAgICAgICBib3VuZGluZ1BvaW50c1syXS55ID4gZW5naW5lLmNhbnZhcy5jbGllbnRIZWlnaHQgJiZcclxuICAgICAgICAgICAgKGJvdW5kaW5nUG9pbnRzWzFdLnggPiAwIHx8IGJvdW5kaW5nUG9pbnRzWzBdLnggPCBlbmdpbmUuY2FudmFzLmNsaWVudFdpZHRoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIG90aGVyd2lzZSBpZiBhbnkgY29ybmVyIGlzIHZpc2libGUsIHdlJ3JlIG5vdCBvZmZzY3JlZW5cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJvdW5kaW5nUG9pbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChib3VuZGluZ1BvaW50c1tpXS54ID4gMCAmJlxyXG4gICAgICAgICAgICAgICAgYm91bmRpbmdQb2ludHNbaV0ueSA+IDAgJiZcclxuICAgICAgICAgICAgICAgIGJvdW5kaW5nUG9pbnRzW2ldLnggPCBlbmdpbmUuY2FudmFzLmNsaWVudFdpZHRoICYmXHJcbiAgICAgICAgICAgICAgICBib3VuZGluZ1BvaW50c1tpXS55IDwgZW5naW5lLmNhbnZhcy5jbGllbnRIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGRlYnVnRHJhdyhjdHgpIHtcclxuICAgICAgICAvLyBib3VuZGluZyByZWN0YW5nbGVcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gQ29sb3IuV2hpdGUudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHgucmVjdCh0aGlzLl94TWluV29ybGQsIHRoaXMuX3lNaW5Xb3JsZCwgdGhpcy5feE1heFdvcmxkIC0gdGhpcy5feE1pbldvcmxkLCB0aGlzLl95TWF4V29ybGQgLSB0aGlzLl95TWluV29ybGQpO1xyXG4gICAgICAgIGN0eC5zdHJva2UoKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3IuUmVkLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5hcmModGhpcy5fdG9wTGVmdC54LCB0aGlzLl90b3BMZWZ0LnksIDUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gQ29sb3IuR3JlZW4udG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LmFyYyh0aGlzLl90b3BSaWdodC54LCB0aGlzLl90b3BSaWdodC55LCA1LCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIGN0eC5maWxsKCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yLkJsdWUudG9TdHJpbmcoKTtcclxuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgY3R4LmFyYyh0aGlzLl9ib3R0b21MZWZ0LngsIHRoaXMuX2JvdHRvbUxlZnQueSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBDb2xvci5NYWdlbnRhLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5hcmModGhpcy5fYm90dG9tUmlnaHQueCwgdGhpcy5fYm90dG9tUmlnaHQueSwgNSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVHJhaXRzL09mZnNjcmVlbkN1bGxpbmcudHNcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCB3aWxsIGJlIHJlbW92ZWQgaW4gMC4yNi4wXHJcbiAqL1xyXG5jbGFzcyBPZmZzY3JlZW5DdWxsaW5nIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY3VsbGluZ0JveCA9IG5ldyBDdWxsaW5nQm94KCk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoYWN0b3IsIGVuZ2luZSkge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IGFjdG9yLmV2ZW50RGlzcGF0Y2hlcjtcclxuICAgICAgICBsZXQgaXNTcHJpdGVPZmZTY3JlZW4gPSB0cnVlO1xyXG4gICAgICAgIGlmIChhY3Rvci5jdXJyZW50RHJhd2luZyAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIGlzU3ByaXRlT2ZmU2NyZWVuID0gdGhpcy5jdWxsaW5nQm94LmlzU3ByaXRlT2ZmU2NyZWVuKGFjdG9yLCBlbmdpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgYWN0b3JCb3VuZHNPZmZzY3JlZW4gPSBmYWxzZTtcclxuICAgICAgICBpZiAoZW5naW5lICYmIGVuZ2luZS5jdXJyZW50U2NlbmUgJiYgZW5naW5lLmN1cnJlbnRTY2VuZS5jYW1lcmEgJiYgZW5naW5lLmN1cnJlbnRTY2VuZS5jYW1lcmEudmlld3BvcnQgJiYgIWFjdG9yLnBhcmVudCkge1xyXG4gICAgICAgICAgICBhY3RvckJvdW5kc09mZnNjcmVlbiA9ICFlbmdpbmUuY3VycmVudFNjZW5lLmNhbWVyYS52aWV3cG9ydC5pbnRlcnNlY3QoYWN0b3IuY29sbGlkZXIuYm91bmRzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhY3Rvci5pc09mZlNjcmVlbikge1xyXG4gICAgICAgICAgICBpZiAoYWN0b3JCb3VuZHNPZmZzY3JlZW4gJiYgaXNTcHJpdGVPZmZTY3JlZW4pIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50cy5lbWl0KCdleGl0dmlld3BvcnQnLCBuZXcgRXhpdFZpZXdQb3J0RXZlbnQoYWN0b3IpKTtcclxuICAgICAgICAgICAgICAgIGFjdG9yLmFkZENvbXBvbmVudChuZXcgVGFnQ29tcG9uZW50KCdvZmZzY3JlZW4nKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghYWN0b3JCb3VuZHNPZmZzY3JlZW4gfHwgIWlzU3ByaXRlT2ZmU2NyZWVuKSB7XHJcbiAgICAgICAgICAgICAgICBldmVudHMuZW1pdCgnZW50ZXJ2aWV3cG9ydCcsIG5ldyBFbnRlclZpZXdQb3J0RXZlbnQoYWN0b3IpKTtcclxuICAgICAgICAgICAgICAgIGFjdG9yLnJlbW92ZUNvbXBvbmVudCgnb2Zmc2NyZWVuJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9UcmFpdHMvQ2FwdHVyZVBvaW50ZXIudHNcbi8qKlxyXG4gKiBSZXZpc2VzIHBvaW50ZXIgZXZlbnRzIHBhdGggYWNjb3JkaW5nbHkgdG8gdGhlIGFjdG9yXHJcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiAwLjI2LjBcclxuICovXHJcbmNsYXNzIENhcHR1cmVQb2ludGVyIHtcclxuICAgIHVwZGF0ZShhY3RvciwgZW5naW5lKSB7XHJcbiAgICAgICAgaWYgKCFhY3Rvci5lbmFibGVDYXB0dXJlUG9pbnRlcikge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhY3Rvci5pc0tpbGxlZCgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5naW5lLmlucHV0LnBvaW50ZXJzLmNoZWNrQW5kVXBkYXRlQWN0b3JVbmRlclBvaW50ZXIoYWN0b3IpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRW50aXR5Q29tcG9uZW50U3lzdGVtL0VudGl0eS50c1xuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogQWRkZWRDb21wb25lbnQgbWVzc2FnZVxyXG4gKi9cclxuY2xhc3MgQWRkZWRDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0NvbXBvbmVudCBBZGRlZCc7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFR5cGUgZ3VhcmQgdG8ga25vdyBpZiBtZXNzYWdlIGlzIGYgYW4gQWRkZWQgQ29tcG9uZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0FkZGVkQ29tcG9uZW50KHgpIHtcclxuICAgIHJldHVybiAhIXggJiYgeC50eXBlID09PSAnQ29tcG9uZW50IEFkZGVkJztcclxufVxyXG4vKipcclxuICogUmVtb3ZlZENvbXBvbmVudCBtZXNzYWdlXHJcbiAqL1xyXG5jbGFzcyBSZW1vdmVkQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdDb21wb25lbnQgUmVtb3ZlZCc7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFR5cGUgZ3VhcmQgdG8ga25vdyBpZiBtZXNzYWdlIGlzIGZvciBhIFJlbW92ZWQgQ29tcG9uZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1JlbW92ZWRDb21wb25lbnQoeCkge1xyXG4gICAgcmV0dXJuICEheCAmJiB4LnR5cGUgPT09ICdDb21wb25lbnQgUmVtb3ZlZCc7XHJcbn1cclxuLyoqXHJcbiAqIEFuIEVudGl0eSBpcyB0aGUgYmFzZSB0eXBlIG9mIGFueXRoaW5nIHRoYXQgY2FuIGhhdmUgYmVoYXZpb3IgaW4gRXhjYWxpYnVyLCB0aGV5IGFyZSBwYXJ0IG9mIHRoZSBidWlsdCBpbiBlbnRpdHkgY29tcG9uZW50IHN5c3RlbVxyXG4gKlxyXG4gKiBFbnRpdGllcyBjYW4gYmUgc3Ryb25nbHkgdHlwZWQgd2l0aCB0aGUgY29tcG9uZW50cyB0aGV5IGNvbnRhaW5cclxuICpcclxuICogYGBgdHlwZXNjcmlwdFxyXG4gKiBjb25zdCBlbnRpdHkgPSBuZXcgRW50aXR5PENvbXBvbmVudEEgfCBDb21wb25lbnRCPigpO1xyXG4gKiBlbnRpdHkuY29tcG9uZW50cy5hOyAvLyBUeXBlIENvbXBvbmVudEFcclxuICogZW50aXR5LmNvbXBvbmVudHMuYjsgLy8gVHlwZSBDb21wb25lbnRCXHJcbiAqIGBgYFxyXG4gKi9cclxuY2xhc3MgRW50aXR5IGV4dGVuZHMgQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoY29tcG9uZW50cywgbmFtZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgZW50aXR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5pZCA9IEVudGl0eS5fSUQrKztcclxuICAgICAgICB0aGlzLl9uYW1lID0gJ2Fub255bW91cyc7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciB0aGlzIGVudGl0eSBpcyBhY3RpdmUsIGlmIHNldCB0byBmYWxzZSBpdCB3aWxsIGJlIHJlY2xhaW1lZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCdWNrZXQgdG8gaG9sZCBvbiB0byBkZWZlcnJlZCByZW1vdmFsc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudHNUb1JlbW92ZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFR5cGVUb0luc3RhbmNlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFN0cmluZ1RvSW5zdGFuY2UgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fdGFnc01lbW8gPSBbXTtcclxuICAgICAgICB0aGlzLl90eXBlc01lbW8gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPYnNlcnZhYmxlIHRoYXQga2VlcHMgdHJhY2sgb2YgY29tcG9uZW50IGFkZCBvciByZW1vdmUgY2hhbmdlcyBvbiB0aGUgZW50aXR5XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRBZGRlZCQgPSBuZXcgT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVtb3ZlZCQgPSBuZXcgT2JzZXJ2YWJsZSgpO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlbkFkZGVkJCA9IG5ldyBPYnNlcnZhYmxlKCk7XHJcbiAgICAgICAgdGhpcy5jaGlsZHJlblJlbW92ZWQkID0gbmV3IE9ic2VydmFibGUoKTtcclxuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zZXROYW1lKG5hbWUpO1xyXG4gICAgICAgIGlmIChjb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29tcG9uZW50IG9mIGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfc2V0TmFtZShuYW1lKSB7XHJcbiAgICAgICAgaWYgKG5hbWUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbmFtZSA9IG5hbWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IG5hbWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgZXZlbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmV2ZW50RGlzcGF0Y2hlcjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogS2lsbCB0aGUgZW50aXR5LCBtZWFucyBpdCB3aWxsIG5vIGxvbmdlciBiZSB1cGRhdGVkLiBLaWxscyBhcmUgZGVmZXJyZWQgdG8gdGhlIGVuZCBvZiB0aGUgdXBkYXRlLlxyXG4gICAgICovXHJcbiAgICBraWxsKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpc0tpbGxlZCgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuYWN0aXZlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTcGVjaWZpY2FsbHkgZ2V0IHRoZSB0YWdzIG9uIHRoZSBlbnRpdHkgZnJvbSBbW1RhZ0NvbXBvbmVudF1dXHJcbiAgICAgKi9cclxuICAgIGdldCB0YWdzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90YWdzTWVtbztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2sgaWYgYSB0YWcgZXhpc3RzIG9uIHRoZSBlbnRpdHlcclxuICAgICAqIEBwYXJhbSB0YWcgbmFtZSB0byBjaGVjayBmb3JcclxuICAgICAqL1xyXG4gICAgaGFzVGFnKHRhZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3MuaW5jbHVkZXModGFnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIHRhZyB0byBhbiBlbnRpdHlcclxuICAgICAqIEBwYXJhbSB0YWdcclxuICAgICAqIEByZXR1cm5zIEVudGl0eVxyXG4gICAgICovXHJcbiAgICBhZGRUYWcodGFnKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBUYWdDb21wb25lbnQodGFnKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSB0YWcgb24gdGhlIGVudGl0eVxyXG4gICAgICpcclxuICAgICAqIFJlbW92YWxzIGFyZSBkZWZlcnJlZCB1bnRpbCB0aGUgZW5kIG9mIHVwZGF0ZVxyXG4gICAgICogQHBhcmFtIHRhZ1xyXG4gICAgICogQHBhcmFtIGZvcmNlIFJlbW92ZSBjb21wb25lbnQgaW1tZWRpYXRlbHksIG5vIGRlZmVycmVkXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZVRhZyh0YWcsIGZvcmNlID0gZmFsc2UpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVDb21wb25lbnQodGFnLCBmb3JjZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0eXBlcyBvZiB0aGUgY29tcG9uZW50cyBvbiB0aGUgRW50aXR5XHJcbiAgICAgKi9cclxuICAgIGdldCB0eXBlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHlwZXNNZW1vO1xyXG4gICAgfVxyXG4gICAgX3JlYnVpbGRNZW1vcygpIHtcclxuICAgICAgICB0aGlzLl90YWdzTWVtbyA9IEFycmF5LmZyb20odGhpcy5fY29tcG9uZW50U3RyaW5nVG9JbnN0YW5jZS52YWx1ZXMoKSlcclxuICAgICAgICAgICAgLmZpbHRlcigoYykgPT4gYyBpbnN0YW5jZW9mIFRhZ0NvbXBvbmVudClcclxuICAgICAgICAgICAgLm1hcCgoYykgPT4gYy50eXBlKTtcclxuICAgICAgICB0aGlzLl90eXBlc01lbW8gPSBBcnJheS5mcm9tKHRoaXMuX2NvbXBvbmVudFN0cmluZ1RvSW5zdGFuY2Uua2V5cygpKTtcclxuICAgIH1cclxuICAgIGdldENvbXBvbmVudHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5fY29tcG9uZW50U3RyaW5nVG9JbnN0YW5jZS52YWx1ZXMoKSk7XHJcbiAgICB9XHJcbiAgICBfbm90aWZ5QWRkQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIHRoaXMuX3JlYnVpbGRNZW1vcygpO1xyXG4gICAgICAgIGNvbnN0IGFkZGVkID0gbmV3IEFkZGVkQ29tcG9uZW50KHtcclxuICAgICAgICAgICAgY29tcG9uZW50LFxyXG4gICAgICAgICAgICBlbnRpdHk6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmNvbXBvbmVudEFkZGVkJC5ub3RpZnlBbGwoYWRkZWQpO1xyXG4gICAgfVxyXG4gICAgX25vdGlmeVJlbW92ZUNvbXBvbmVudChjb21wb25lbnQpIHtcclxuICAgICAgICBjb25zdCByZW1vdmVkID0gbmV3IFJlbW92ZWRDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBjb21wb25lbnQsXHJcbiAgICAgICAgICAgIGVudGl0eTogdGhpc1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50UmVtb3ZlZCQubm90aWZ5QWxsKHJlbW92ZWQpO1xyXG4gICAgICAgIHRoaXMuX3JlYnVpbGRNZW1vcygpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBhcmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRpcmVjdCBjaGlsZHJlbiBvZiB0aGlzIGVudGl0eVxyXG4gICAgICovXHJcbiAgICBnZXQgY2hpbGRyZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnBhcmVudHMgdGhpcyBlbnRpdHksIGlmIHRoZXJlIGlzIGEgcGFyZW50LiBPdGhlcndpc2UgaXQgZG9lcyBub3RoaW5nLlxyXG4gICAgICovXHJcbiAgICB1bnBhcmVudCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fcGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5fcGFyZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZW50aXR5IHRvIGJlIGEgY2hpbGQgb2YgdGhpcyBlbnRpdHlcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgYWRkQ2hpbGQoZW50aXR5KSB7XHJcbiAgICAgICAgaWYgKGVudGl0eS5wYXJlbnQgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0QW5jZXN0b3JzKCkuaW5jbHVkZXMoZW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDeWNsZSBkZXRlY3RlZCwgY2Fubm90IGFkZCBlbnRpdHknKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9jaGlsZHJlbi5wdXNoKGVudGl0eSk7XHJcbiAgICAgICAgICAgIGVudGl0eS5fcGFyZW50ID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbkFkZGVkJC5ub3RpZnlBbGwoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW50aXR5IGFscmVhZHkgaGFzIGEgcGFyZW50LCBjYW5ub3QgYWRkIHdpdGhvdXQgdW5wYXJlbnRpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZSBhbiBlbnRpdHkgZnJvbSBjaGlsZHJlbiBpZiBpdCBleGlzdHNcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlQ2hpbGQoZW50aXR5KSB7XHJcbiAgICAgICAgaWYgKGVudGl0eS5wYXJlbnQgPT09IHRoaXMpIHtcclxuICAgICAgICAgICAgcmVtb3ZlSXRlbUZyb21BcnJheShlbnRpdHksIHRoaXMuX2NoaWxkcmVuKTtcclxuICAgICAgICAgICAgZW50aXR5Ll9wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuUmVtb3ZlZCQubm90aWZ5QWxsKGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBjaGlsZHJlbiBmcm9tIHRoaXMgZW50aXR5XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUFsbENoaWxkcmVuKCkge1xyXG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgoYykgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNoaWxkKGMpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBwYXJlbnQgZW50aXRpZXMgc3RhcnRpbmcgd2l0aCB0aGUgdG9wbW9zdCBwYXJlbnQuIEluY2x1ZGVzIHRoZSBjdXJyZW50IGVudGl0eS5cclxuICAgICAqL1xyXG4gICAgZ2V0QW5jZXN0b3JzKCkge1xyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFt0aGlzXTtcclxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMucGFyZW50O1xyXG4gICAgICAgIHdoaWxlIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdGhlIGVudGl0aWVzIHRoYXQgZGVzY2VuZCBmcm9tIHRoaXMgZW50aXR5LiBJbmNsdWRlcyB0aGUgY3VycmVudCBlbnRpdHkuXHJcbiAgICAgKi9cclxuICAgIGdldERlc2NlbmRhbnRzKCkge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBbdGhpc107XHJcbiAgICAgICAgbGV0IHF1ZXVlID0gW3RoaXNdO1xyXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBxdWV1ZS5wb3AoKTtcclxuICAgICAgICAgICAgcXVldWUgPSBxdWV1ZS5jb25jYXQoY3Vyci5jaGlsZHJlbik7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoY3Vyci5jaGlsZHJlbik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBkZWVwIGNvcHkgb2YgdGhlIGVudGl0eSBhbmQgYSBjb3B5IG9mIGFsbCBpdHMgY29tcG9uZW50c1xyXG4gICAgICovXHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICBjb25zdCBuZXdFbnRpdHkgPSBuZXcgRW50aXR5KCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMudHlwZXMpIHtcclxuICAgICAgICAgICAgbmV3RW50aXR5LmFkZENvbXBvbmVudCh0aGlzLmdldChjKS5jbG9uZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIG5ld0VudGl0eS5hZGRDaGlsZChjaGlsZC5jbG9uZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ld0VudGl0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGNvcHkgb2YgYWxsIHRoZSBjb21wb25lbnRzIGZyb20gYW5vdGhlciB0ZW1wbGF0ZSBlbnRpdHkgYXMgYSBcInByZWZhYlwiXHJcbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVFbnRpdHkgRW50aXR5IHRvIHVzZSBhcyBhIHRlbXBsYXRlXHJcbiAgICAgKiBAcGFyYW0gZm9yY2UgRm9yY2UgY29tcG9uZW50IHJlcGxhY2VtZW50IGlmIGl0IGFsZWFkeSBleGlzdHMgb24gdGhlIHRhcmdldCBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgYWRkVGVtcGxhdGUodGVtcGxhdGVFbnRpdHksIGZvcmNlID0gZmFsc2UpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgdGVtcGxhdGVFbnRpdHkuZ2V0Q29tcG9uZW50cygpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KGMuY2xvbmUoKSwgZm9yY2UpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRlbXBsYXRlRW50aXR5LmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGQoY2hpbGQuY2xvbmUoKS5hZGRUZW1wbGF0ZShjaGlsZCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIGNvbXBvbmVudCB0byB0aGUgZW50aXR5XHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IENvbXBvbmVudCBvciBFbnRpdHkgdG8gYWRkIGNvcHkgb2YgY29tcG9uZW50cyBmcm9tXHJcbiAgICAgKiBAcGFyYW0gZm9yY2UgT3B0aW9uYWxseSBvdmVyd3JpdGUgYW55IGV4aXN0aW5nIGNvbXBvbmVudHMgb2YgdGhlIHNhbWUgdHlwZVxyXG4gICAgICovXHJcbiAgICBhZGRDb21wb25lbnQoY29tcG9uZW50LCBmb3JjZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgLy8gaWYgY29tcG9uZW50IGFscmVhZHkgZXhpc3RzLCBza2lwIGlmIG5vdCBmb3JjZWRcclxuICAgICAgICBpZiAodGhpcy5oYXMoY29tcG9uZW50LnR5cGUpKSB7XHJcbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIGNvbXBvbmVudCB0eXBlIGlmIGV4aXN0cyB3aGVuIGZvcmNlZFxyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVDb21wb25lbnQoY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIC8vIGVhcmx5IGV4aXQgY29tcG9uZW50IGV4aXNzXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBUT0RPIGNpcmN1bGFyIGRlcGVuZGVuY2llcyB3aWxsIGJlIGEgcHJvYmxlbVxyXG4gICAgICAgIGlmIChjb21wb25lbnQuZGVwZW5kZW5jaWVzICYmIGNvbXBvbmVudC5kZXBlbmRlbmNpZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3RvciBvZiBjb21wb25lbnQuZGVwZW5kZW5jaWVzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgY3RvcigpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBjb21wb25lbnQub3duZXIgPSB0aGlzO1xyXG4gICAgICAgIGNvbnN0IGNvbnN0dWN0b3JUeXBlID0gY29tcG9uZW50LmNvbnN0cnVjdG9yO1xyXG4gICAgICAgIHRoaXMuX2NvbXBvbmVudFR5cGVUb0luc3RhbmNlLnNldChjb25zdHVjdG9yVHlwZSwgY29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9jb21wb25lbnRTdHJpbmdUb0luc3RhbmNlLnNldChjb21wb25lbnQudHlwZSwgY29tcG9uZW50KTtcclxuICAgICAgICBpZiAoY29tcG9uZW50Lm9uQWRkKSB7XHJcbiAgICAgICAgICAgIGNvbXBvbmVudC5vbkFkZCh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbm90aWZ5QWRkQ29tcG9uZW50KGNvbXBvbmVudCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBjb21wb25lbnQgZnJvbSB0aGUgZW50aXR5LCBieSBkZWZhdWx0IHJlbW92YWxzIGFyZSBkZWZlcnJlZCB0byB0aGUgZW5kIG9mIGVudGl0eSB1cGRhdGUgdG8gYXZvaWQgY29uc2lzdGVuY3kgaXNzdWVzXHJcbiAgICAgKlxyXG4gICAgICogQ29tcG9uZW50cyBjYW4gYmUgZm9yY2UgcmVtb3ZlZCB3aXRoIHRoZSBgZm9yY2VgIGZsYWcsIHRoZSByZW1vdmFsIGlzIG5vdCBkZWZlcnJlZCBhbmQgaGFwcGVucyBpbW1lZGlhdGVseVxyXG4gICAgICogQHBhcmFtIGNvbXBvbmVudE9yVHlwZVxyXG4gICAgICogQHBhcmFtIGZvcmNlXHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUNvbXBvbmVudChjb21wb25lbnRPclR5cGUsIGZvcmNlID0gZmFsc2UpIHtcclxuICAgICAgICBpZiAoZm9yY2UpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnRPclR5cGUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVDb21wb25lbnRCeVR5cGUoY29tcG9uZW50T3JUeXBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb25lbnRPclR5cGUgaW5zdGFuY2VvZiBDb21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZUNvbXBvbmVudEJ5VHlwZShjb21wb25lbnRPclR5cGUudHlwZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbXBvbmVudHNUb1JlbW92ZS5wdXNoKGNvbXBvbmVudE9yVHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgX3JlbW92ZUNvbXBvbmVudEJ5VHlwZSh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMuZ2V0KHR5cGUpO1xyXG4gICAgICAgICAgICBjb21wb25lbnQub3duZXIgPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Lm9uUmVtb3ZlKSB7XHJcbiAgICAgICAgICAgICAgICBjb21wb25lbnQub25SZW1vdmUodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgY3RvciA9IGNvbXBvbmVudC5jb25zdHJ1Y3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fY29tcG9uZW50VHlwZVRvSW5zdGFuY2UuZGVsZXRlKGN0b3IpO1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wb25lbnRTdHJpbmdUb0luc3RhbmNlLmRlbGV0ZShjb21wb25lbnQudHlwZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeVJlbW92ZUNvbXBvbmVudChjb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGhpZGRlblxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHByb2Nlc3NDb21wb25lbnRSZW1vdmFsKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgY29tcG9uZW50T3JUeXBlIG9mIHRoaXMuX2NvbXBvbmVudHNUb1JlbW92ZSkge1xyXG4gICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZW9mIGNvbXBvbmVudE9yVHlwZSA9PT0gJ3N0cmluZycgPyBjb21wb25lbnRPclR5cGUgOiBjb21wb25lbnRPclR5cGUudHlwZTtcclxuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlQ29tcG9uZW50QnlUeXBlKHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jb21wb25lbnRzVG9SZW1vdmUubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIGhhcyh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50U3RyaW5nVG9JbnN0YW5jZS5oYXModHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50VHlwZVRvSW5zdGFuY2UuaGFzKHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCh0eXBlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50U3RyaW5nVG9JbnN0YW5jZS5nZXQodHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50VHlwZVRvSW5zdGFuY2UuZ2V0KHR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBhY3RvciBpcyBJbml0aWFsaXplZFxyXG4gICAgICovXHJcbiAgICBnZXQgaXNJbml0aWFsaXplZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhpcyBlbnRpdHksIG1lYW50IHRvIGJlIGNhbGxlZCBieSB0aGUgU2NlbmUgYmVmb3JlIGZpcnN0IHVwZGF0ZSBub3QgYnkgdXNlcnMgb2YgRXhjYWxpYnVyLlxyXG4gICAgICpcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX2luaXRpYWxpemUoZW5naW5lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkluaXRpYWxpemUoZW5naW5lKTtcclxuICAgICAgICAgICAgc3VwZXIuZW1pdCgnaW5pdGlhbGl6ZScsIG5ldyBJbml0aWFsaXplRXZlbnQoZW5naW5lLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wcmV1cGRhdGUgaGFuZGxlciBmb3IgW1tvblByZVVwZGF0ZV1dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wcmV1cGRhdGUoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncHJldXBkYXRlJywgbmV3IFByZVVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUHJlVXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3ByZXVwZGF0ZSBoYW5kbGVyIGZvciBbW29uUG9zdFVwZGF0ZV1dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wb3N0dXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3Bvc3R1cGRhdGUnLCBuZXcgUG9zdFVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUG9zdFVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogYG9uSW5pdGlhbGl6ZWAgaXMgY2FsbGVkIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlIG9mIHRoZSBlbnRpdHkuIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlXHJcbiAgICAgKiBvdmVycmlkZGVuLlxyXG4gICAgICpcclxuICAgICAqIFN5bm9ueW1vdXMgd2l0aCB0aGUgZXZlbnQgaGFuZGxlciBgLm9uKCdpbml0aWFsaXplJywgKGV2dCkgPT4gey4uLn0pYFxyXG4gICAgICovXHJcbiAgICBvbkluaXRpYWxpemUoX2VuZ2luZSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25QcmVVcGRhdGUgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwcmV1cGRhdGUnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25QcmVVcGRhdGVgIGlzIGNhbGxlZCBkaXJlY3RseSBiZWZvcmUgYW4gZW50aXR5IGlzIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIG9uUHJlVXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25Qb3N0VXBkYXRlIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncG9zdHVwZGF0ZScsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblBvc3RVcGRhdGVgIGlzIGNhbGxlZCBkaXJlY3RseSBhZnRlciBhbiBlbnRpdHkgaXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgb25Qb3N0VXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBFbnRpdHkgdXBkYXRlIGxpZmVjeWNsZSwgY2FsbGVkIGludGVybmFsbHlcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBwYXJhbSBlbmdpbmVcclxuICAgICAqIEBwYXJhbSBkZWx0YVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemUoZW5naW5lKTtcclxuICAgICAgICB0aGlzLl9wcmV1cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGNoaWxkLnVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcG9zdHVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxufVxyXG5FbnRpdHkuX0lEID0gMDtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9EcmF3aW5nL0NhbnZhc0RyYXdDb21wb25lbnQudHNcblxyXG4vKipcclxuICogU2hpbSB0byBkcmF3IHRvIHRoZSBjYW52YXMgd2hlbiBpbiBMZWdhY3lEcmF3aW5nIG1vZGVcclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbmNsYXNzIENhbnZhc0RyYXdDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoZHJhdykge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuZHJhdyA9IGRyYXc7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4LmNhbnZhcyc7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxyXG4gICAgICAgIHRoaXMuZHJhdyA9IChfYSA9IHRoaXMuZHJhdykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKCgpID0+IHsgfSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9HcmFwaGljc0NvbXBvbmVudC50c1xuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogVHlwZSBndWFyZCBmb3IgY2hlY2tpbmcgaWYgYSBHcmFwaGljIEhhc1RpY2sgKHVzZWQgZm9yIGdyYXBoaWNzIHRoYXQgY2hhbmdlIG92ZXIgdGltZSBsaWtlIGFuaW1hdGlvbnMpXHJcbiAqIEBwYXJhbSBncmFwaGljXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNHcmFwaGljc1RpY2soZ3JhcGhpYykge1xyXG4gICAgcmV0dXJuICEhZ3JhcGhpYy50aWNrO1xyXG59XHJcbmNsYXNzIEdyYXBoaWNzTGF5ZXIge1xyXG4gICAgY29uc3RydWN0b3IoX29wdGlvbnMsIF9ncmFwaGljcykge1xyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBfb3B0aW9ucztcclxuICAgICAgICB0aGlzLl9ncmFwaGljcyA9IF9ncmFwaGljcztcclxuICAgICAgICB0aGlzLmdyYXBoaWNzID0gW107XHJcbiAgICB9XHJcbiAgICBnZXQgbmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5uYW1lO1xyXG4gICAgfVxyXG4gICAgaGlkZShuYW1lT3JHcmFwaGljKSB7XHJcbiAgICAgICAgaWYgKCFuYW1lT3JHcmFwaGljKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MubGVuZ3RoID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGxldCBnZnggPSBudWxsO1xyXG4gICAgICAgICAgICBpZiAobmFtZU9yR3JhcGhpYyBpbnN0YW5jZW9mIEdyYXBoaWMpIHtcclxuICAgICAgICAgICAgICAgIGdmeCA9IG5hbWVPckdyYXBoaWM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBnZnggPSB0aGlzLl9ncmFwaGljcy5nZXRHcmFwaGljKG5hbWVPckdyYXBoaWMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MgPSB0aGlzLmdyYXBoaWNzLmZpbHRlcigoZykgPT4gZy5ncmFwaGljICE9PSBnZngpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBhIGdyYXBoaWMgYnkgbmFtZSBvciBpbnN0YW5jZSBhdCBhbiBvZmZzZXQsIGdyYXBoaWNzIGFyZSBzaG93biBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggYHNob3coKWAgaXMgY2FsbGVkLlxyXG4gICAgICpcclxuICAgICAqIElmIGBzaG93KClgIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWUgZ3JhcGhpYyBpdCB3aWxsIGJlIHNob3duIG11bHRpcGxlIHRpbWVzLlxyXG4gICAgICogQHBhcmFtIG5hbWVPckdyYXBoaWNcclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHNob3cobmFtZU9yR3JhcGhpYywgb3B0aW9ucykge1xyXG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcclxuICAgICAgICBsZXQgZ2Z4O1xyXG4gICAgICAgIGlmIChuYW1lT3JHcmFwaGljIGluc3RhbmNlb2YgR3JhcGhpYykge1xyXG4gICAgICAgICAgICBnZnggPSB0aGlzLl9ncmFwaGljcy5jb3B5R3JhcGhpY3MgPyBuYW1lT3JHcmFwaGljLmNsb25lKCkgOiBuYW1lT3JHcmFwaGljO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZ2Z4ID0gdGhpcy5fZ3JhcGhpY3MuZ2V0R3JhcGhpYyhuYW1lT3JHcmFwaGljKTtcclxuICAgICAgICAgICAgaWYgKCFnZngpIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKGBObyBzdWNoIGdyYXBoaWMgYWRkZWQgdG8gY29tcG9uZW50IG5hbWVkICR7bmFtZU9yR3JhcGhpY30uIFRoZXNlIG5hbWVkIGdyYXBoaWNzIGFyZSBhdmFpbGFibGU6IGAsIHRoaXMuX2dyYXBoaWNzLmdldE5hbWVzKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChnZngpIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5wdXNoKHsgZ3JhcGhpYzogZ2Z4LCBvcHRpb25zIH0pO1xyXG4gICAgICAgICAgICByZXR1cm4gZ2Z4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgYSBzcGVjaWZpYyBncmFwaGljLCBzd2FwIG91dCBhbnkgY3VycmVudCBncmFwaGljcyBiZWluZyBzaG93blxyXG4gICAgICogQHBhcmFtIG5hbWVPckdyYXBoaWNcclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHVzZShuYW1lT3JHcmFwaGljLCBvcHRpb25zKSB7XHJcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNob3cobmFtZU9yR3JhcGhpYywgb3B0aW9ucyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEN1cnJlbnQgb3JkZXIgb2YgdGhlIGxheWVyLCBoaWdoZXIgbnVtYmVycyBhcmUgb24gdG9wLCBsb3dlciBudW1iZXJzIGFyZSBvbiB0aGUgYm90dG9tLlxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlIGEgbGF5ZXIgd2l0aCBgb3JkZXIgPSAtMWAgd291bGQgYmUgdW5kZXIgYSBsYXllciBvZiBgb3JkZXIgPSAxYFxyXG4gICAgICovXHJcbiAgICBnZXQgb3JkZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMub3JkZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldCB0aGUgb3JkZXIgb2YgdGhlIGxheWVyLCBoaWdoZXIgbnVtYmVycyBhcmUgb24gdG9wLCBsb3dlciBudW1iZXJzIGFyZSBvbiB0aGUgYm90dG9tLlxyXG4gICAgICpcclxuICAgICAqIEZvciBleGFtcGxlIGEgbGF5ZXIgd2l0aCBgb3JkZXIgPSAtMWAgd291bGQgYmUgdW5kZXIgYSBsYXllciBvZiBgb3JkZXIgPSAxYFxyXG4gICAgICovXHJcbiAgICBzZXQgb3JkZXIob3JkZXIpIHtcclxuICAgICAgICB0aGlzLl9vcHRpb25zLm9yZGVyID0gb3JkZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIHBpeGVsIG9mZnNldCBmcm9tIHRoZSBsYXllciBhbmNob3IgZm9yIGFsbCBncmFwaGljcyBpbiB0aGUgbGF5ZXJcclxuICAgICAqL1xyXG4gICAgZ2V0IG9mZnNldCgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX29wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBWZWN0b3IuWmVybztcclxuICAgIH1cclxuICAgIHNldCBvZmZzZXQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9vcHRpb25zLm9mZnNldCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGN1cnJlbnRLZXlzKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnYW5vbnltb3VzJztcclxuICAgIH1cclxufVxyXG5jbGFzcyBHcmFwaGljc0xheWVycyB7XHJcbiAgICBjb25zdHJ1Y3RvcihfY29tcG9uZW50KSB7XHJcbiAgICAgICAgdGhpcy5fY29tcG9uZW50ID0gX2NvbXBvbmVudDtcclxuICAgICAgICB0aGlzLl9sYXllcnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9sYXllck1hcCA9IHt9O1xyXG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IG5ldyBHcmFwaGljc0xheWVyKHsgbmFtZTogJ2RlZmF1bHQnLCBvcmRlcjogMCB9LCBfY29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tYXliZUFkZExheWVyKHRoaXMuZGVmYXVsdCk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGUob3B0aW9ucykge1xyXG4gICAgICAgIGNvbnN0IGxheWVyID0gbmV3IEdyYXBoaWNzTGF5ZXIob3B0aW9ucywgdGhpcy5fY29tcG9uZW50KTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbWF5YmVBZGRMYXllcihsYXllcik7XHJcbiAgICB9XHJcbiAgICBnZXQobmFtZSkge1xyXG4gICAgICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRMYXllcihuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xheWVycztcclxuICAgIH1cclxuICAgIGN1cnJlbnRLZXlzKCkge1xyXG4gICAgICAgIGNvbnN0IGdyYXBoaWNzTGF5ZXJLZXlzID0gW107XHJcbiAgICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLl9sYXllcnMpIHtcclxuICAgICAgICAgICAgZ3JhcGhpY3NMYXllcktleXMucHVzaChsYXllci5jdXJyZW50S2V5cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBncmFwaGljc0xheWVyS2V5cztcclxuICAgIH1cclxuICAgIGhhcyhuYW1lKSB7XHJcbiAgICAgICAgcmV0dXJuIG5hbWUgaW4gdGhpcy5fbGF5ZXJNYXA7XHJcbiAgICB9XHJcbiAgICBfbWF5YmVBZGRMYXllcihsYXllcikge1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXllck1hcFtsYXllci5uYW1lXSkge1xyXG4gICAgICAgICAgICAvLyB0b2RvIGxvZyB3YXJuaW5nXHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sYXllck1hcFtsYXllci5uYW1lXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJNYXBbbGF5ZXIubmFtZV0gPSBsYXllcjtcclxuICAgICAgICB0aGlzLl9sYXllcnMucHVzaChsYXllcik7XHJcbiAgICAgICAgdGhpcy5fbGF5ZXJzLnNvcnQoKGEsIGIpID0+IGEub3JkZXIgLSBiLm9yZGVyKTtcclxuICAgICAgICByZXR1cm4gbGF5ZXI7XHJcbiAgICB9XHJcbiAgICBfZ2V0TGF5ZXIobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllck1hcFtuYW1lXTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ29tcG9uZW50IHRvIG1hbmFnZSBkcmF3aW5ncywgdXNpbmcgd2l0aCB0aGUgcG9zaXRpb24gY29tcG9uZW50XHJcbiAqL1xyXG5jbGFzcyBHcmFwaGljc0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnR5cGUgPSAnZXguZ3JhcGhpY3MnO1xyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHdldGhlciBhbnkgZHJhd2luZyBzaG91bGQgYmUgdmlzaWJsZSBpbiB0aGlzIGNvbXBvbmVudFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0cyBvciBnZXRzIHdpdGhlciBhbGwgZHJhd2luZ3Mgc2hvdWxkIGhhdmUgYW4gb3BhY2l0eSBhcHBsaWVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBPZmZzZXQgdG8gYXBwbHkgdG8gZ3JhcGhpY3MgYnkgZGVmYXVsdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQW5jaG9yIHRvIGFwcGx5IHRvIGdyYXBoaWNzIGJ5IGRlZmF1bHRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFuY2hvciA9IFZlY3Rvci5IYWxmO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIElmIHNldCB0byB0cnVlIGdyYXBoaWNzIGFkZGVkIHRvIHRoZSBjb21wb25lbnQgd2lsbCBiZSBjb3BpZWQuIFRoaXMgY2FuIGFmZmVjdCBwZXJmb3JtYW5jZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29weUdyYXBoaWNzID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYm91bmRzID0gbnVsbDtcclxuICAgICAgICAvLyBEZWZhdWx0c1xyXG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgdmlzaWJsZTogdGhpcy52aXNpYmxlIH0sIG9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IHsgY3VycmVudCwgYW5jaG9yLCBvcGFjaXR5LCB2aXNpYmxlLCBncmFwaGljcywgb2Zmc2V0LCBjb3B5R3JhcGhpY3MsIG9uUHJlRHJhdywgb25Qb3N0RHJhdyB9ID0gb3B0aW9ucztcclxuICAgICAgICB0aGlzLl9ncmFwaGljcyA9IGdyYXBoaWNzIHx8IHt9O1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0ICE9PSBudWxsICYmIG9mZnNldCAhPT0gdm9pZCAwID8gb2Zmc2V0IDogdGhpcy5vZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eSAhPT0gbnVsbCAmJiBvcGFjaXR5ICE9PSB2b2lkIDAgPyBvcGFjaXR5IDogdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yICE9PSBudWxsICYmIGFuY2hvciAhPT0gdm9pZCAwID8gYW5jaG9yIDogdGhpcy5hbmNob3I7XHJcbiAgICAgICAgdGhpcy5jb3B5R3JhcGhpY3MgPSBjb3B5R3JhcGhpY3MgIT09IG51bGwgJiYgY29weUdyYXBoaWNzICE9PSB2b2lkIDAgPyBjb3B5R3JhcGhpY3MgOiB0aGlzLmNvcHlHcmFwaGljcztcclxuICAgICAgICB0aGlzLm9uUHJlRHJhdyA9IG9uUHJlRHJhdyAhPT0gbnVsbCAmJiBvblByZURyYXcgIT09IHZvaWQgMCA/IG9uUHJlRHJhdyA6IHRoaXMub25QcmVEcmF3O1xyXG4gICAgICAgIHRoaXMub25Qb3N0RHJhdyA9IG9uUG9zdERyYXcgIT09IG51bGwgJiYgb25Qb3N0RHJhdyAhPT0gdm9pZCAwID8gb25Qb3N0RHJhdyA6IHRoaXMub25Qb3N0RHJhdztcclxuICAgICAgICB0aGlzLnZpc2libGUgPSAhIXZpc2libGU7XHJcbiAgICAgICAgdGhpcy5sYXllcnMgPSBuZXcgR3JhcGhpY3NMYXllcnModGhpcyk7XHJcbiAgICAgICAgaWYgKGN1cnJlbnQgJiYgdGhpcy5fZ3JhcGhpY3NbY3VycmVudF0pIHtcclxuICAgICAgICAgICAgdGhpcy5zaG93KHRoaXMuX2dyYXBoaWNzW2N1cnJlbnRdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXRHcmFwaGljKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY3NbbmFtZV07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCByZWdpc3RlcmVkIGdyYXBoaWNzIG5hbWVzXHJcbiAgICAgKi9cclxuICAgIGdldE5hbWVzKCkge1xyXG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9ncmFwaGljcyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgZ3JhcGhpY3MgYW5kIHRoZWlyIG9mZnNldHMsIGVtcHR5IGFycmF5IGlmIGhpZGRlblxyXG4gICAgICovXHJcbiAgICBnZXQgY3VycmVudCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYXllcnMuZGVmYXVsdC5ncmFwaGljcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgZ3JhcGhpY3MgYXNzb2NpYXRlZCB3aXRoIHRoaXMgY29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIGdldCBncmFwaGljcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZ3JhcGhpY3M7XHJcbiAgICB9XHJcbiAgICBhZGQobmFtZU9yR3JhcGhpYywgZ3JhcGhpYykge1xyXG4gICAgICAgIGxldCBuYW1lID0gJ2RlZmF1bHQnO1xyXG4gICAgICAgIGxldCBncmFwaGljVG9TZXQgPSBudWxsO1xyXG4gICAgICAgIGlmICh0eXBlb2YgbmFtZU9yR3JhcGhpYyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgbmFtZSA9IG5hbWVPckdyYXBoaWM7XHJcbiAgICAgICAgICAgIGdyYXBoaWNUb1NldCA9IGdyYXBoaWM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBncmFwaGljVG9TZXQgPSBuYW1lT3JHcmFwaGljO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ncmFwaGljc1tuYW1lXSA9IHRoaXMuY29weUdyYXBoaWNzID8gZ3JhcGhpY1RvU2V0LmNsb25lKCkgOiBncmFwaGljVG9TZXQ7XHJcbiAgICAgICAgaWYgKG5hbWUgPT09ICdkZWZhdWx0Jykge1xyXG4gICAgICAgICAgICB0aGlzLnNob3coJ2RlZmF1bHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdyYXBoaWNUb1NldDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2hvdyBhIGdyYXBoaWMgYnkgbmFtZSBvbiB0aGUgKipkZWZhdWx0KiogbGF5ZXIsIHJldHVybnMgdGhlIG5ldyBbW0dyYXBoaWNdXVxyXG4gICAgICovXHJcbiAgICBzaG93KG5hbWVPckdyYXBoaWMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5sYXllcnMuZGVmYXVsdC5zaG93KG5hbWVPckdyYXBoaWMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2UgYSBncmFwaGljIG9ubHksIHN3YXAgb3V0IGFueSBncmFwaGljcyBvbiB0aGUgKipkZWZhdWx0KiogbGF5ZXIsIHJldHVybnMgdGhlIG5ldyBbW0dyYXBoaWNdXVxyXG4gICAgICogQHBhcmFtIG5hbWVPckdyYXBoaWNcclxuICAgICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICAgKi9cclxuICAgIHVzZShuYW1lT3JHcmFwaGljLCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzLmRlZmF1bHQudXNlKG5hbWVPckdyYXBoaWMsIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgaGlkZShuYW1lT3JHcmFwaGljKSB7XHJcbiAgICAgICAgdGhpcy5sYXllcnMuZGVmYXVsdC5oaWRlKG5hbWVPckdyYXBoaWMpO1xyXG4gICAgfVxyXG4gICAgc2V0IGxvY2FsQm91bmRzKGJvdW5kcykge1xyXG4gICAgICAgIHRoaXMuX2JvdW5kcyA9IGJvdW5kcztcclxuICAgIH1cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICBpZiAodGhpcy5fYm91bmRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ib3VuZHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBiYiA9IG5ldyBCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMuZ2V0KCkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB7IGdyYXBoaWMsIG9wdGlvbnMgfSBvZiBsYXllci5ncmFwaGljcykge1xyXG4gICAgICAgICAgICAgICAgbGV0IGFuY2hvciA9IHRoaXMuYW5jaG9yO1xyXG4gICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IHRoaXMub2Zmc2V0O1xyXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hbmNob3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBvcHRpb25zLmFuY2hvcjtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMub2Zmc2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjb25zdCBib3VuZHMgPSBncmFwaGljLmxvY2FsQm91bmRzO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IC1ib3VuZHMud2lkdGggKiBncmFwaGljLnNjYWxlLnggKiBhbmNob3IueCArIG9mZnNldC54O1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IC1ib3VuZHMuaGVpZ2h0ICogZ3JhcGhpYy5zY2FsZS55ICogYW5jaG9yLnkgKyBvZmZzZXQueTtcclxuICAgICAgICAgICAgICAgIGJiID0gZ3JhcGhpYyA9PT0gbnVsbCB8fCBncmFwaGljID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncmFwaGljLmxvY2FsQm91bmRzLnRyYW5zbGF0ZSh2ZWMob2Zmc2V0WCArIGxheWVyLm9mZnNldC54LCBvZmZzZXRZICsgbGF5ZXIub2Zmc2V0LnkpKS5jb21iaW5lKGJiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB1bmRlcmx5aW5nIGdyYXBoaWNzIGlmIG5lY2VzYXJ5LCBjYWxsZWQgaW50ZXJuYWxseVxyXG4gICAgICogQHBhcmFtIGVsYXBzZWRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoZWxhcHNlZCwgaWRlbXBvdGVuY3lUb2tlbiA9IDApIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzLmdldCgpKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBncmFwaGljIH0gb2YgbGF5ZXIuZ3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChoYXNHcmFwaGljc1RpY2soZ3JhcGhpYykpIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaGljID09PSBudWxsIHx8IGdyYXBoaWMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdyYXBoaWMudGljayhlbGFwc2VkLCBpZGVtcG90ZW5jeVRva2VuKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL1JlY3RhbmdsZS50c1xuXHJcbi8qKlxyXG4gKiBBIFJlY3RhbmdsZSBbW0dyYXBoaWNdXSBmb3IgZHJhd2luZyByZWN0YW5nbGVzIHRvIHRoZSBbW0V4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dF1dXHJcbiAqL1xyXG5jbGFzcyBSZWN0YW5nbGUgZXh0ZW5kcyBSYXN0ZXIge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSBvcHRpb25zLndpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gb3B0aW9ucy5oZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5yYXN0ZXJpemUoKTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHdpZHRoOiB0aGlzLndpZHRoLCBoZWlnaHQ6IHRoaXMuaGVpZ2h0IH0sIHRoaXMuY2xvbmVHcmFwaGljT3B0aW9ucygpKSwgdGhpcy5jbG9uZVJhc3Rlck9wdGlvbnMoKSkpO1xyXG4gICAgfVxyXG4gICAgZXhlY3V0ZShjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zdHJva2VDb2xvcikge1xyXG4gICAgICAgICAgICBjdHguc3Ryb2tlUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQ2lyY2xlLnRzXG5cclxuLyoqXHJcbiAqIEEgY2lyY2xlIFtbR3JhcGhpY11dIGZvciBkcmF3aW5nIGNpcmNsZXMgdG8gdGhlIFtbRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0XV1cclxuICovXHJcbmNsYXNzIENpcmNsZSBleHRlbmRzIFJhc3RlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IDA7XHJcbiAgICAgICAgdGhpcy5wYWRkaW5nID0gKF9hID0gb3B0aW9ucy5wYWRkaW5nKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAyOyAvLyBkZWZhdWx0IDIgcGFkZGluZyBmb3IgY2lyY2xlcyBsb29rcyBuaWNlXHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSBvcHRpb25zLnJhZGl1cztcclxuICAgICAgICB0aGlzLnJhc3Rlcml6ZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJhZGl1cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcmFkaXVzO1xyXG4gICAgfVxyXG4gICAgc2V0IHJhZGl1cyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3JhZGl1cyA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9yYWRpdXMgKiAyO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5fcmFkaXVzICogMjtcclxuICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgcmFkaXVzOiB0aGlzLnJhZGl1cyB9LCB0aGlzLmNsb25lR3JhcGhpY09wdGlvbnMoKSksIHRoaXMuY2xvbmVSYXN0ZXJPcHRpb25zKCkpKTtcclxuICAgIH1cclxuICAgIGV4ZWN1dGUoY3R4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMucmFkaXVzID4gMCkge1xyXG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgICAgIGN0eC5hcmModGhpcy5yYWRpdXMsIHRoaXMucmFkaXVzLCB0aGlzLnJhZGl1cywgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zdHJva2VDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9FYXNpbmdGdW5jdGlvbnMudHNcbnZhciBFYXNpbmdGdW5jdGlvbnNfZGVjb3JhdGUgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFN0YW5kYXJkIGVhc2luZyBmdW5jdGlvbnMgZm9yIG1vdGlvbiBpbiBFeGNhbGlidXIsIGRlZmluZWQgb24gYSBkb21haW4gb2YgWzAsIGR1cmF0aW9uXSBhbmQgYSByYW5nZSBmcm9tIFsrc3RhcnRWYWx1ZSwrZW5kVmFsdWVdXHJcbiAqIEdpdmVuIGEgdGltZSwgdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIGEgdmFsdWUgZnJvbSBwb3NpdGl2ZSBzdGFydFZhbHVlIHRvIHBvc2l0aXZlIGVuZFZhbHVlLlxyXG4gKlxyXG4gKiBgYGBqc1xyXG4gKiBmdW5jdGlvbiBMaW5lYXIgKHQpIHtcclxuICogICAgcmV0dXJuIHQgKiB0O1xyXG4gKiB9XHJcbiAqXHJcbiAqIC8vIGFjY2VsZXJhdGluZyBmcm9tIHplcm8gdmVsb2NpdHlcclxuICogZnVuY3Rpb24gRWFzZUluUXVhZCAodCkge1xyXG4gKiAgICByZXR1cm4gdCAqIHQ7XHJcbiAqIH1cclxuICpcclxuICogLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcclxuICogZnVuY3Rpb24gRWFzZU91dFF1YWQgKHQpIHtcclxuICogICAgcmV0dXJuIHQgKiAoMiAtIHQpO1xyXG4gKiB9XHJcbiAqXHJcbiAqIC8vIGFjY2VsZXJhdGlvbiB1bnRpbCBoYWxmd2F5LCB0aGVuIGRlY2VsZXJhdGlvblxyXG4gKiBmdW5jdGlvbiBFYXNlSW5PdXRRdWFkICh0KSB7XHJcbiAqICAgIHJldHVybiB0IDwgLjUgPyAyICogdCAqIHQgOiAtMSArICg0IC0gMiAqIHQpICogdDtcclxuICogfVxyXG4gKlxyXG4gKiAvLyBhY2NlbGVyYXRpbmcgZnJvbSB6ZXJvIHZlbG9jaXR5XHJcbiAqIGZ1bmN0aW9uIEVhc2VJbkN1YmljICh0KSB7XHJcbiAqICAgIHJldHVybiB0ICogdCAqIHQ7XHJcbiAqIH1cclxuICpcclxuICogLy8gZGVjZWxlcmF0aW5nIHRvIHplcm8gdmVsb2NpdHlcclxuICogZnVuY3Rpb24gRWFzZU91dEN1YmljICh0KSB7XHJcbiAqICAgIHJldHVybiAoLS10KSAqIHQgKiB0ICsgMTtcclxuICogfVxyXG4gKlxyXG4gKiAvLyBhY2NlbGVyYXRpb24gdW50aWwgaGFsZndheSwgdGhlbiBkZWNlbGVyYXRpb25cclxuICogZnVuY3Rpb24gRWFzZUluT3V0Q3ViaWMgKHQpIHtcclxuICogICAgcmV0dXJuIHQgPCAuNSA/IDQgKiB0ICogdCAqIHQgOiAodCAtIDEpICogKDIgKiB0IC0gMikgKiAoMiAqIHQgLSAyKSArIDE7XHJcbiAqIH1cclxuICogYGBgXHJcbiAqL1xyXG5jbGFzcyBFYXNpbmdGdW5jdGlvbnMge1xyXG4gICAgc3RhdGljIENyZWF0ZVJldmVyc2libGVFYXNpbmdGdW5jdGlvbihlYXNpbmcpIHtcclxuICAgICAgICByZXR1cm4gKHRpbWUsIHN0YXJ0LCBlbmQsIGR1cmF0aW9uKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlbmQgPCBzdGFydCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXJ0IC0gKGVhc2luZyh0aW1lLCBlbmQsIHN0YXJ0LCBkdXJhdGlvbikgLSBlbmQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVhc2luZyh0aW1lLCBzdGFydCwgZW5kLCBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIENyZWF0ZVJldmVyc2FibGVFYXNpbmdGdW5jdGlvbihlYXNpbmcpIHtcclxuICAgICAgICByZXR1cm4gRWFzaW5nRnVuY3Rpb25zLkNyZWF0ZVJldmVyc2libGVFYXNpbmdGdW5jdGlvbihlYXNpbmcpO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIENyZWF0ZVZlY3RvckVhc2luZ0Z1bmN0aW9uKGVhc2luZykge1xyXG4gICAgICAgIHJldHVybiAodGltZSwgc3RhcnQsIGVuZCwgZHVyYXRpb24pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoZWFzaW5nKHRpbWUsIHN0YXJ0LngsIGVuZC54LCBkdXJhdGlvbiksIGVhc2luZyh0aW1lLCBzdGFydC55LCBlbmQueSwgZHVyYXRpb24pKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbkVhc2luZ0Z1bmN0aW9ucy5MaW5lYXIgPSBFYXNpbmdGdW5jdGlvbnMuQ3JlYXRlUmV2ZXJzaWJsZUVhc2luZ0Z1bmN0aW9uKChjdXJyZW50VGltZSwgc3RhcnRWYWx1ZSwgZW5kVmFsdWUsIGR1cmF0aW9uKSA9PiB7XHJcbiAgICBlbmRWYWx1ZSA9IGVuZFZhbHVlIC0gc3RhcnRWYWx1ZTtcclxuICAgIHJldHVybiAoZW5kVmFsdWUgKiBjdXJyZW50VGltZSkgLyBkdXJhdGlvbiArIHN0YXJ0VmFsdWU7XHJcbn0pO1xyXG5FYXNpbmdGdW5jdGlvbnMuRWFzZUluUXVhZCA9IEVhc2luZ0Z1bmN0aW9ucy5DcmVhdGVSZXZlcnNpYmxlRWFzaW5nRnVuY3Rpb24oKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pID0+IHtcclxuICAgIGVuZFZhbHVlID0gZW5kVmFsdWUgLSBzdGFydFZhbHVlO1xyXG4gICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XHJcbiAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICsgc3RhcnRWYWx1ZTtcclxufSk7XHJcbkVhc2luZ0Z1bmN0aW9ucy5FYXNlT3V0UXVhZCA9IEVhc2luZ0Z1bmN0aW9ucy5DcmVhdGVSZXZlcnNpYmxlRWFzaW5nRnVuY3Rpb24oKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pID0+IHtcclxuICAgIGVuZFZhbHVlID0gZW5kVmFsdWUgLSBzdGFydFZhbHVlO1xyXG4gICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XHJcbiAgICByZXR1cm4gLWVuZFZhbHVlICogY3VycmVudFRpbWUgKiAoY3VycmVudFRpbWUgLSAyKSArIHN0YXJ0VmFsdWU7XHJcbn0pO1xyXG5FYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0UXVhZCA9IEVhc2luZ0Z1bmN0aW9ucy5DcmVhdGVSZXZlcnNpYmxlRWFzaW5nRnVuY3Rpb24oKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pID0+IHtcclxuICAgIGVuZFZhbHVlID0gZW5kVmFsdWUgLSBzdGFydFZhbHVlO1xyXG4gICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb24gLyAyO1xyXG4gICAgaWYgKGN1cnJlbnRUaW1lIDwgMSkge1xyXG4gICAgICAgIHJldHVybiAoZW5kVmFsdWUgLyAyKSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xyXG4gICAgfVxyXG4gICAgY3VycmVudFRpbWUtLTtcclxuICAgIHJldHVybiAoLWVuZFZhbHVlIC8gMikgKiAoY3VycmVudFRpbWUgKiAoY3VycmVudFRpbWUgLSAyKSAtIDEpICsgc3RhcnRWYWx1ZTtcclxufSk7XHJcbkVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5DdWJpYyA9IEVhc2luZ0Z1bmN0aW9ucy5DcmVhdGVSZXZlcnNpYmxlRWFzaW5nRnVuY3Rpb24oKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pID0+IHtcclxuICAgIGVuZFZhbHVlID0gZW5kVmFsdWUgLSBzdGFydFZhbHVlO1xyXG4gICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XHJcbiAgICByZXR1cm4gZW5kVmFsdWUgKiBjdXJyZW50VGltZSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKyBzdGFydFZhbHVlO1xyXG59KTtcclxuRWFzaW5nRnVuY3Rpb25zLkVhc2VPdXRDdWJpYyA9IEVhc2luZ0Z1bmN0aW9ucy5DcmVhdGVSZXZlcnNpYmxlRWFzaW5nRnVuY3Rpb24oKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pID0+IHtcclxuICAgIGVuZFZhbHVlID0gZW5kVmFsdWUgLSBzdGFydFZhbHVlO1xyXG4gICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb247XHJcbiAgICBjdXJyZW50VGltZS0tO1xyXG4gICAgcmV0dXJuIGVuZFZhbHVlICogKGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIDEpICsgc3RhcnRWYWx1ZTtcclxufSk7XHJcbkVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYyA9IEVhc2luZ0Z1bmN0aW9ucy5DcmVhdGVSZXZlcnNpYmxlRWFzaW5nRnVuY3Rpb24oKGN1cnJlbnRUaW1lLCBzdGFydFZhbHVlLCBlbmRWYWx1ZSwgZHVyYXRpb24pID0+IHtcclxuICAgIGVuZFZhbHVlID0gZW5kVmFsdWUgLSBzdGFydFZhbHVlO1xyXG4gICAgY3VycmVudFRpbWUgLz0gZHVyYXRpb24gLyAyO1xyXG4gICAgaWYgKGN1cnJlbnRUaW1lIDwgMSkge1xyXG4gICAgICAgIHJldHVybiAoZW5kVmFsdWUgLyAyKSAqIGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIHN0YXJ0VmFsdWU7XHJcbiAgICB9XHJcbiAgICBjdXJyZW50VGltZSAtPSAyO1xyXG4gICAgcmV0dXJuIChlbmRWYWx1ZSAvIDIpICogKGN1cnJlbnRUaW1lICogY3VycmVudFRpbWUgKiBjdXJyZW50VGltZSArIDIpICsgc3RhcnRWYWx1ZTtcclxufSk7XHJcbkVhc2luZ0Z1bmN0aW9uc19kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0FsaWFzIGZvciBpbmNvcnJlY3Qgc3BlbGxpbmcgdXNlZCBpbiBvbGRlciB2ZXJzaW9ucywgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI1LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ0NyZWF0ZVJldmVyc2libGVFYXNpbmdGdW5jdGlvbidcclxuICAgIH0pXHJcbl0sIEVhc2luZ0Z1bmN0aW9ucywgXCJDcmVhdGVSZXZlcnNhYmxlRWFzaW5nRnVuY3Rpb25cIiwgbnVsbCk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb25RdWV1ZS50c1xuLyoqXHJcbiAqIEFjdGlvbiBRdWV1ZXMgcmVwcmVzZW50IGFuIG9yZGVyZWQgc2VxdWVuY2Ugb2YgYWN0aW9uc1xyXG4gKlxyXG4gKiBBY3Rpb24gcXVldWVzIGFyZSBwYXJ0IG9mIHRoZSBbW0FjdGlvbkNvbnRleHR8QWN0aW9uIEFQSV1dIGFuZFxyXG4gKiBzdG9yZSB0aGUgbGlzdCBvZiBhY3Rpb25zIHRvIGJlIGV4ZWN1dGVkIGZvciBhbiBbW0FjdG9yXV0uXHJcbiAqXHJcbiAqIEFjdG9ycyBpbXBsZW1lbnQgW1tBY3Rvci5hY3Rpb25zXV0gd2hpY2ggY2FuIGJlIG1hbmlwdWxhdGVkIGJ5XHJcbiAqIGFkdmFuY2VkIHVzZXJzIHRvIGFkanVzdCB0aGUgYWN0aW9ucyBjdXJyZW50bHkgYmVpbmcgZXhlY3V0ZWQgaW4gdGhlXHJcbiAqIHF1ZXVlLlxyXG4gKi9cclxuY2xhc3MgQWN0aW9uUXVldWUge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5KSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMgPSBbXTtcclxuICAgICAgICB0aGlzLl9lbnRpdHkgPSBlbnRpdHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBhY3Rpb24gdG8gdGhlIHNlcXVlbmNlXHJcbiAgICAgKiBAcGFyYW0gYWN0aW9uXHJcbiAgICAgKi9cclxuICAgIGFkZChhY3Rpb24pIHtcclxuICAgICAgICB0aGlzLl9hY3Rpb25zLnB1c2goYWN0aW9uKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlIGFuIGFjdGlvbiBieSByZWZlcmVuY2UgZnJvbSB0aGUgc2VxdWVuY2VcclxuICAgICAqIEBwYXJhbSBhY3Rpb25cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlKGFjdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fYWN0aW9ucy5pbmRleE9mKGFjdGlvbik7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9ucy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGFsbCBhY3Rpb25zIGZyb20gdGhpcyBzZXF1ZW5jZVxyXG4gICAgICovXHJcbiAgICBjbGVhckFjdGlvbnMoKSB7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9ucy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMubGVuZ3RoID0gMDtcclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudEFjdGlvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50QWN0aW9uLnN0b3AoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG90YWwgbGlzdCBvZiBhY3Rpb25zIGluIHRoaXMgc2VxdWVuY2UgY29tcGxldGUgb3Igbm90XHJcbiAgICAgKi9cclxuICAgIGdldEFjdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMuY29uY2F0KHRoaXMuX2NvbXBsZXRlZEFjdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIHRoZXJlIGFyZSBtb3JlIGFjdGlvbnMgdG8gcHJvY2VzcyBpbiB0aGUgc2VxdWVuY2VcclxuICAgICAqL1xyXG4gICAgaGFzTmV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0aW9ucy5sZW5ndGggPiAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGN1cnJlbnQgc2VxdWVuY2Ugb2YgYWN0aW9ucyBpcyBkb25lXHJcbiAgICAgKi9cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdGlvbnMubGVuZ3RoID09PSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIHNlcXVlbmNlIG9mIGFjdGlvbnMsIHRoaXMgaXMgdXNlZCB0byByZXN0YXJ0IGEgc2VxdWVuY2UgZnJvbSB0aGUgYmVnaW5uaW5nXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX2FjdGlvbnMgPSB0aGlzLmdldEFjdGlvbnMoKTtcclxuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLl9hY3Rpb25zLmxlbmd0aDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvbnNbaV0ucmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucyA9IFtdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIHF1ZXVlIHdoaWNoIHVwZGF0ZXMgYWN0aW9ucyBhbmQgaGFuZGxlcyBjb21wbGV0aW5nIGFjdGlvbnNcclxuICAgICAqIEBwYXJhbSBlbGFwc2VkTXNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKGVsYXBzZWRNcykge1xyXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudEFjdGlvbiA9IHRoaXMuX2FjdGlvbnNbMF07XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRBY3Rpb24udXBkYXRlKGVsYXBzZWRNcyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50QWN0aW9uLmlzQ29tcGxldGUodGhpcy5fZW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcGxldGVkQWN0aW9ucy5wdXNoKHRoaXMuX2FjdGlvbnMuc2hpZnQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9SZXBlYXQudHNcblxyXG5jbGFzcyBSZXBlYXQge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCByZXBlYXRCdWlsZGVyLCByZXBlYXQpIHtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0QnVpbGRlciA9IHJlcGVhdEJ1aWxkZXI7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0Q29udGV4dCA9IG5ldyBBY3Rpb25Db250ZXh0KGVudGl0eSk7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUgPSB0aGlzLl9yZXBlYXRDb250ZXh0LmdldFF1ZXVlKCk7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0ID0gcmVwZWF0O1xyXG4gICAgICAgIHRoaXMuX29yaWdpbmFsUmVwZWF0ID0gcmVwZWF0O1xyXG4gICAgICAgIHRoaXMuX3JlcGVhdEJ1aWxkZXIodGhpcy5fcmVwZWF0Q29udGV4dCk7XHJcbiAgICAgICAgdGhpcy5fcmVwZWF0LS07IC8vIGN1cnJlbnQgZXhlY3V0aW9uIGlzIHRoZSBmaXJzdCByZXBlYXRcclxuICAgIH1cclxuICAgIHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9hY3Rpb25RdWV1ZS5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUuY2xlYXJBY3Rpb25zKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGVhdEJ1aWxkZXIodGhpcy5fcmVwZWF0Q29udGV4dCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlcGVhdC0tO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS51cGRhdGUoZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCAodGhpcy5fcmVwZWF0IDw9IDAgJiYgdGhpcy5fYWN0aW9uUXVldWUuaXNDb21wbGV0ZSgpKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9yZXBlYXQgPSB0aGlzLl9vcmlnaW5hbFJlcGVhdDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL1JlcGVhdEZvcmV2ZXIudHNcblxyXG4vKipcclxuICogUmVwZWF0Rm9yZXZlciBBY3Rpb24gaW1wbGVtZW50YXRpb24sIGl0IGlzIHJlY29tbWVuZGVkIHlvdSB1c2UgdGhlIGZsdWVudCBhY3Rpb25cclxuICogY29udGV4dCBBUEkuXHJcbiAqXHJcbiAqXHJcbiAqL1xyXG5jbGFzcyBSZXBlYXRGb3JldmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgcmVwZWF0QnVpbGRlcikge1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9yZXBlYXRCdWlsZGVyID0gcmVwZWF0QnVpbGRlcjtcclxuICAgICAgICB0aGlzLl9yZXBlYXRDb250ZXh0ID0gbmV3IEFjdGlvbkNvbnRleHQoZW50aXR5KTtcclxuICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZSA9IHRoaXMuX3JlcGVhdENvbnRleHQuZ2V0UXVldWUoKTtcclxuICAgICAgICB0aGlzLl9yZXBlYXRCdWlsZGVyKHRoaXMuX3JlcGVhdENvbnRleHQpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGRlbHRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0b3BwZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fYWN0aW9uUXVldWUuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdGlvblF1ZXVlLmNsZWFyQWN0aW9ucygpO1xyXG4gICAgICAgICAgICB0aGlzLl9yZXBlYXRCdWlsZGVyKHRoaXMuX3JlcGVhdENvbnRleHQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9hY3Rpb25RdWV1ZS51cGRhdGUoZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZDtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fYWN0aW9uUXVldWUuY2xlYXJBY3Rpb25zKCk7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9Nb3ZlQnkudHNcblxyXG5cclxuXHJcblxyXG5jbGFzcyBNb3ZlQnkge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCBvZmZzZXRYLCBvZmZzZXRZLCBzcGVlZCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZW50aXR5ID0gZW50aXR5O1xyXG4gICAgICAgIHRoaXMuX3R4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IGVudGl0eS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9zcGVlZCA9IHNwZWVkO1xyXG4gICAgICAgIHRoaXMuX29mZnNldCA9IG5ldyBWZWN0b3Iob2Zmc2V0WCwgb2Zmc2V0WSk7XHJcbiAgICAgICAgaWYgKHNwZWVkIDw9IDApIHtcclxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0F0dGVtcHRlZCB0byBtb3ZlQnkgd2l0aCBzcGVlZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gemVybyA6ICcgKyBzcGVlZCk7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3BlZWQgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCBwaXhlbHMgcGVyIHNlY29uZCcpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZShfZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gbmV3IFZlY3Rvcih0aGlzLl90eC5wb3MueCwgdGhpcy5fdHgucG9zLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmQgPSB0aGlzLl9zdGFydC5hZGQodGhpcy5fb2Zmc2V0KTtcclxuICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9vZmZzZXQuc2l6ZTtcclxuICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9zdGFydCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5fZW50aXR5KSkge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5wb3MgPSB2ZWModGhpcy5fZW5kLngsIHRoaXMuX2VuZC55KTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB0aGlzLl9kaXIuc2NhbGUodGhpcy5fc3BlZWQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoZW50aXR5KSB7XHJcbiAgICAgICAgY29uc3QgdHggPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgdHgucG9zLmRpc3RhbmNlKHRoaXMuX3N0YXJ0KSA+PSB0aGlzLl9kaXN0YW5jZTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL01vdmVUby50c1xuXHJcblxyXG5cclxuY2xhc3MgTW92ZVRvIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgZGVzdHgsIGRlc3R5LCBzcGVlZCkge1xyXG4gICAgICAgIHRoaXMuZW50aXR5ID0gZW50aXR5O1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdHggPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uID0gZW50aXR5LmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2VuZCA9IG5ldyBWZWN0b3IoZGVzdHgsIGRlc3R5KTtcclxuICAgICAgICB0aGlzLl9zcGVlZCA9IHNwZWVkO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9kZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnQgPSBuZXcgVmVjdG9yKHRoaXMuX3R4LnBvcy54LCB0aGlzLl90eC5wb3MueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc3RhcnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9zdGFydCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG0gPSB0aGlzLl9kaXIuc2NhbGUodGhpcy5fc3BlZWQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMobS54LCBtLnkpO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUodGhpcy5lbnRpdHkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R4LnBvcyA9IHZlYyh0aGlzLl9lbmQueCwgdGhpcy5fZW5kLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoZW50aXR5KSB7XHJcbiAgICAgICAgY29uc3QgdHggPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgbmV3IFZlY3Rvcih0eC5wb3MueCwgdHgucG9zLnkpLmRpc3RhbmNlKHRoaXMuX3N0YXJ0KSA+PSB0aGlzLl9kaXN0YW5jZTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvUm90YXRpb25UeXBlLnRzXG4vKipcclxuICogQW4gZW51bSB0aGF0IGRlc2NyaWJlcyB0aGUgc3RyYXRlZ2llcyB0aGF0IHJvdGF0aW9uIGFjdGlvbnMgY2FuIHVzZVxyXG4gKi9cclxudmFyIFJvdGF0aW9uVHlwZTtcclxuKGZ1bmN0aW9uIChSb3RhdGlvblR5cGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogUm90YXRpb24gdmlhIGBTaG9ydGVzdFBhdGhgIHdpbGwgdXNlIHRoZSBzbWFsbGVzdCBhbmdsZVxyXG4gICAgICogYmV0d2VlbiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMuIFRoaXMgc3RyYXRlZ3kgaXMgdGhlIGRlZmF1bHQgYmVoYXZpb3IuXHJcbiAgICAgKi9cclxuICAgIFJvdGF0aW9uVHlwZVtSb3RhdGlvblR5cGVbXCJTaG9ydGVzdFBhdGhcIl0gPSAwXSA9IFwiU2hvcnRlc3RQYXRoXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0aW9uIHZpYSBgTG9uZ2VzdFBhdGhgIHdpbGwgdXNlIHRoZSBsYXJnZXN0IGFuZ2xlXHJcbiAgICAgKiBiZXR3ZWVuIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cy5cclxuICAgICAqL1xyXG4gICAgUm90YXRpb25UeXBlW1JvdGF0aW9uVHlwZVtcIkxvbmdlc3RQYXRoXCJdID0gMV0gPSBcIkxvbmdlc3RQYXRoXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJvdGF0aW9uIHZpYSBgQ2xvY2t3aXNlYCB3aWxsIHRyYXZlbCBpbiBhIGNsb2Nrd2lzZSBkaXJlY3Rpb24sXHJcbiAgICAgKiByZWdhcmRsZXNzIG9mIHRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHBvaW50cy5cclxuICAgICAqL1xyXG4gICAgUm90YXRpb25UeXBlW1JvdGF0aW9uVHlwZVtcIkNsb2Nrd2lzZVwiXSA9IDJdID0gXCJDbG9ja3dpc2VcIjtcclxuICAgIC8qKlxyXG4gICAgICogUm90YXRpb24gdmlhIGBDb3VudGVyQ2xvY2t3aXNlYCB3aWxsIHRyYXZlbCBpbiBhIGNvdW50ZXJjbG9ja3dpc2UgZGlyZWN0aW9uLFxyXG4gICAgICogcmVnYXJkbGVzcyBvZiB0aGUgc3RhcnRpbmcgYW5kIGVuZGluZyBwb2ludHMuXHJcbiAgICAgKi9cclxuICAgIFJvdGF0aW9uVHlwZVtSb3RhdGlvblR5cGVbXCJDb3VudGVyQ2xvY2t3aXNlXCJdID0gM10gPSBcIkNvdW50ZXJDbG9ja3dpc2VcIjtcclxufSkoUm90YXRpb25UeXBlIHx8IChSb3RhdGlvblR5cGUgPSB7fSkpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL1JvdGF0ZVRvLnRzXG5cclxuXHJcblxyXG5cclxuY2xhc3MgUm90YXRlVG8ge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCBhbmdsZVJhZGlhbnMsIHNwZWVkLCByb3RhdGlvblR5cGUpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3R4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IGVudGl0eS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9lbmQgPSBhbmdsZVJhZGlhbnM7XHJcbiAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcclxuICAgICAgICB0aGlzLl9yb3RhdGlvblR5cGUgPSByb3RhdGlvblR5cGUgfHwgUm90YXRpb25UeXBlLlNob3J0ZXN0UGF0aDtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ID0gdGhpcy5fdHgucm90YXRpb247XHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnROb25DYW5ub25BbmdsZSA9IHRoaXMuX3R4LnJvdGF0aW9uO1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZTEgPSBNYXRoLmFicyh0aGlzLl9lbmQgLSB0aGlzLl9zdGFydCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlMiA9IFR3b1BJIC0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UxID4gZGlzdGFuY2UyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydERpc3RhbmNlID0gZGlzdGFuY2UyO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ0Rpc3RhbmNlID0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnREaXN0YW5jZSA9IGRpc3RhbmNlMTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdEaXN0YW5jZSA9IGRpc3RhbmNlMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlID0gKHRoaXMuX3N0YXJ0IC0gdGhpcy5fZW5kICsgVHdvUEkpICUgVHdvUEkgPj0gTWF0aC5QSTtcclxuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9yb3RhdGlvblR5cGUpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlLlNob3J0ZXN0UGF0aDpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlLkxvbmdlc3RQYXRoOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydGVzdFBhdGhJc1Bvc2l0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZS5DbG9ja3dpc2U6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIFJvdGF0aW9uVHlwZS5Db3VudGVyQ2xvY2t3aXNlOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IC0xO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX3Nob3J0RGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2xvbmdEaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLmFuZ3VsYXJWZWxvY2l0eSA9IHRoaXMuX2RpcmVjdGlvbiAqIHRoaXMuX3NwZWVkO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnROb25DYW5ub25BbmdsZSArPSB0aGlzLl9kaXJlY3Rpb24gKiB0aGlzLl9zcGVlZCAqIChfZGVsdGEgLyAxMDAwKTtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHgucm90YXRpb24gPSB0aGlzLl9lbmQ7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi5hbmd1bGFyVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIGNvbnN0IGRpc3RhbmNlVHJhdmVsbGVkID0gTWF0aC5hYnModGhpcy5fY3VycmVudE5vbkNhbm5vbkFuZ2xlIC0gdGhpcy5fc3RhcnQpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IGRpc3RhbmNlVHJhdmVsbGVkID49IE1hdGguYWJzKHRoaXMuX2Rpc3RhbmNlKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9Sb3RhdGVCeS50c1xuXHJcblxyXG5cclxuXHJcbmNsYXNzIFJvdGF0ZUJ5IHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgYW5nbGVSYWRpYW5zT2Zmc2V0LCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl90eCA9IGVudGl0eS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24gPSBlbnRpdHkuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcclxuICAgICAgICB0aGlzLl9vZmZzZXQgPSBhbmdsZVJhZGlhbnNPZmZzZXQ7XHJcbiAgICAgICAgdGhpcy5fcm90YXRpb25UeXBlID0gcm90YXRpb25UeXBlIHx8IFJvdGF0aW9uVHlwZS5TaG9ydGVzdFBhdGg7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2RlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydCA9IHRoaXMuX3R4LnJvdGF0aW9uO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Tm9uQ2Fubm9uQW5nbGUgPSB0aGlzLl90eC5yb3RhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fZW5kID0gdGhpcy5fc3RhcnQgKyB0aGlzLl9vZmZzZXQ7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlMSA9IE1hdGguYWJzKHRoaXMuX2VuZCAtIHRoaXMuX3N0YXJ0KTtcclxuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UyID0gVHdvUEkgLSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgIGlmIChkaXN0YW5jZTEgPiBkaXN0YW5jZTIpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nob3J0RGlzdGFuY2UgPSBkaXN0YW5jZTI7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nRGlzdGFuY2UgPSBkaXN0YW5jZTE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydERpc3RhbmNlID0gZGlzdGFuY2UxO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbG9uZ0Rpc3RhbmNlID0gZGlzdGFuY2UyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUgPSAodGhpcy5fc3RhcnQgLSB0aGlzLl9lbmQgKyBUd29QSSkgJSBUd29QSSA+PSBNYXRoLlBJO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3JvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGUuU2hvcnRlc3RQYXRoOlxyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnRlc3RQYXRoSXNQb3NpdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGUuTG9uZ2VzdFBhdGg6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3Nob3J0ZXN0UGF0aElzUG9zaXRpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gLTE7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgUm90YXRpb25UeXBlLkNsb2Nrd2lzZTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zaG9ydERpc3RhbmNlID49IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9zaG9ydERpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9sb25nRGlzdGFuY2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSBSb3RhdGlvblR5cGUuQ291bnRlckNsb2Nrd2lzZTpcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2hvcnREaXN0YW5jZSA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fc2hvcnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbG9uZ0Rpc3RhbmNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tb3Rpb24uYW5ndWxhclZlbG9jaXR5ID0gdGhpcy5fZGlyZWN0aW9uICogdGhpcy5fc3BlZWQ7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudE5vbkNhbm5vbkFuZ2xlICs9IHRoaXMuX2RpcmVjdGlvbiAqIHRoaXMuX3NwZWVkICogKF9kZWx0YSAvIDEwMDApO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5yb3RhdGlvbiA9IHRoaXMuX2VuZDtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLmFuZ3VsYXJWZWxvY2l0eSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgY29uc3QgZGlzdGFuY2VUcmF2ZWxsZWQgPSBNYXRoLmFicyh0aGlzLl9jdXJyZW50Tm9uQ2Fubm9uQW5nbGUgLSB0aGlzLl9zdGFydCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgZGlzdGFuY2VUcmF2ZWxsZWQgPj0gTWF0aC5hYnModGhpcy5fZGlzdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9tb3Rpb24uYW5ndWxhclZlbG9jaXR5ID0gMDtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL1NjYWxlVG8udHNcblxyXG5cclxuXHJcbmNsYXNzIFNjYWxlVG8ge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCBzY2FsZVgsIHNjYWxlWSwgc3BlZWRYLCBzcGVlZFkpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3R4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IGVudGl0eS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9lbmRYID0gc2NhbGVYO1xyXG4gICAgICAgIHRoaXMuX2VuZFkgPSBzY2FsZVk7XHJcbiAgICAgICAgdGhpcy5fc3BlZWRYID0gc3BlZWRYO1xyXG4gICAgICAgIHRoaXMuX3NwZWVkWSA9IHNwZWVkWTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IHRoaXMuX3R4LnNjYWxlLng7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IHRoaXMuX3R4LnNjYWxlLnk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlWCA9IE1hdGguYWJzKHRoaXMuX2VuZFggLSB0aGlzLl9zdGFydFgpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZVkgPSBNYXRoLmFicyh0aGlzLl9lbmRZIC0gdGhpcy5fc3RhcnRZKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCEoTWF0aC5hYnModGhpcy5fdHguc2NhbGUueCAtIHRoaXMuX3N0YXJ0WCkgPj0gdGhpcy5fZGlzdGFuY2VYKSkge1xyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb25YID0gdGhpcy5fZW5kWSA8IHRoaXMuX3N0YXJ0WSA/IC0xIDogMTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnggPSB0aGlzLl9zcGVlZFggKiBkaXJlY3Rpb25YO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnggPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIShNYXRoLmFicyh0aGlzLl90eC5zY2FsZS55IC0gdGhpcy5fc3RhcnRZKSA+PSB0aGlzLl9kaXN0YW5jZVkpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvblkgPSB0aGlzLl9lbmRZIDwgdGhpcy5fc3RhcnRZID8gLTEgOiAxO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueSA9IHRoaXMuX3NwZWVkWSAqIGRpcmVjdGlvblk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5zY2FsZSA9IHZlYyh0aGlzLl9lbmRYLCB0aGlzLl9lbmRZKTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnggPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gKHRoaXMuX3N0b3BwZWQgfHxcclxuICAgICAgICAgICAgKE1hdGguYWJzKHRoaXMuX3R4LnNjYWxlLnkgLSB0aGlzLl9zdGFydFgpID49IHRoaXMuX2Rpc3RhbmNlWCAmJiBNYXRoLmFicyh0aGlzLl90eC5zY2FsZS55IC0gdGhpcy5fc3RhcnRZKSA+PSB0aGlzLl9kaXN0YW5jZVkpKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnggPSAwO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci55ID0gMDtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL1NjYWxlQnkudHNcblxyXG5cclxuXHJcbmNsYXNzIFNjYWxlQnkge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5LCBzY2FsZU9mZnNldFgsIHNjYWxlT2Zmc2V0WSwgc3BlZWQpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3R4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IGVudGl0eS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9vZmZzZXQgPSBuZXcgVmVjdG9yKHNjYWxlT2Zmc2V0WCwgc2NhbGVPZmZzZXRZKTtcclxuICAgICAgICB0aGlzLl9zcGVlZFggPSB0aGlzLl9zcGVlZFkgPSBzcGVlZDtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0U2NhbGUgPSB0aGlzLl90eC5zY2FsZS5jbG9uZSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmRTY2FsZSA9IHRoaXMuX3N0YXJ0U2NhbGUuYWRkKHRoaXMuX29mZnNldCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlWCA9IE1hdGguYWJzKHRoaXMuX2VuZFNjYWxlLnggLSB0aGlzLl9zdGFydFNjYWxlLngpO1xyXG4gICAgICAgICAgICB0aGlzLl9kaXN0YW5jZVkgPSBNYXRoLmFicyh0aGlzLl9lbmRTY2FsZS55IC0gdGhpcy5fc3RhcnRTY2FsZS55KTtcclxuICAgICAgICAgICAgdGhpcy5fZGlyZWN0aW9uWCA9IHRoaXMuX2VuZFNjYWxlLnggPCB0aGlzLl9zdGFydFNjYWxlLnggPyAtMSA6IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvblkgPSB0aGlzLl9lbmRTY2FsZS55IDwgdGhpcy5fc3RhcnRTY2FsZS55ID8gLTEgOiAxO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueCA9IHRoaXMuX3NwZWVkWCAqIHRoaXMuX2RpcmVjdGlvblg7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnkgPSB0aGlzLl9zcGVlZFkgKiB0aGlzLl9kaXJlY3Rpb25ZO1xyXG4gICAgICAgIGlmICh0aGlzLmlzQ29tcGxldGUoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl90eC5zY2FsZSA9IHRoaXMuX2VuZFNjYWxlO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24uc2NhbGVGYWN0b3IueCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci55ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiAodGhpcy5fc3RvcHBlZCB8fFxyXG4gICAgICAgICAgICAoTWF0aC5hYnModGhpcy5fdHguc2NhbGUueCAtIHRoaXMuX3N0YXJ0U2NhbGUueCkgPj0gdGhpcy5fZGlzdGFuY2VYICYmXHJcbiAgICAgICAgICAgICAgICBNYXRoLmFicyh0aGlzLl90eC5zY2FsZS55IC0gdGhpcy5fc3RhcnRTY2FsZS55KSA+PSB0aGlzLl9kaXN0YW5jZVkpKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnNjYWxlRmFjdG9yLnggPSAwO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi5zY2FsZUZhY3Rvci55ID0gMDtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uL0NhbGxNZXRob2QudHNcbmNsYXNzIENhbGxNZXRob2Qge1xyXG4gICAgY29uc3RydWN0b3IobWV0aG9kKSB7XHJcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9oYXNCZWVuQ2FsbGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fbWV0aG9kID0gbWV0aG9kO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9kZWx0YSkge1xyXG4gICAgICAgIHRoaXMuX21ldGhvZCgpO1xyXG4gICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faGFzQmVlbkNhbGxlZDtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX2hhc0JlZW5DYWxsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5faGFzQmVlbkNhbGxlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9FYXNlVG8udHNcblxyXG5cclxuXHJcbmNsYXNzIEVhc2VUbyB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pIHtcclxuICAgICAgICB0aGlzLmVhc2luZ0ZjbiA9IGVhc2luZ0ZjbjtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IDEgKiAxMDAwOyAvLyAxIHNlY29uZFxyXG4gICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fbGVycEVuZCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgPSAwO1xyXG4gICAgICAgIHRoaXMuX3R4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IGVudGl0eS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB0aGlzLl9sZXJwRW5kID0gbmV3IFZlY3Rvcih4LCB5KTtcclxuICAgIH1cclxuICAgIF9pbml0aWFsaXplKCkge1xyXG4gICAgICAgIHRoaXMuX2xlcnBTdGFydCA9IG5ldyBWZWN0b3IodGhpcy5fdHgucG9zLngsIHRoaXMuX3R4LnBvcy55KTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2Rpc3RhbmNlID0gdGhpcy5fbGVycFN0YXJ0LmRpc3RhbmNlKHRoaXMuX2xlcnBFbmQpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGRlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0aWFsaXplKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gTmVlZCB0byB1cGRhdGUgbGVycCB0aW1lIGZpcnN0LCBvdGhlcndpc2UgdGhlIGZpcnN0IHVwZGF0ZSB3aWxsIGFsd2F5cyBiZSB6ZXJvXHJcbiAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgIGxldCBuZXdYID0gdGhpcy5fdHgucG9zLng7XHJcbiAgICAgICAgbGV0IG5ld1kgPSB0aGlzLl90eC5wb3MueTtcclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudExlcnBUaW1lIDwgdGhpcy5fbGVycER1cmF0aW9uKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9sZXJwRW5kLnggPCB0aGlzLl9sZXJwU3RhcnQueCkge1xyXG4gICAgICAgICAgICAgICAgbmV3WCA9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0LnggLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5lYXNpbmdGY24odGhpcy5fY3VycmVudExlcnBUaW1lLCB0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBTdGFydC54LCB0aGlzLl9sZXJwRHVyYXRpb24pIC0gdGhpcy5fbGVycEVuZC54KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG5ld1ggPSB0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydC54LCB0aGlzLl9sZXJwRW5kLngsIHRoaXMuX2xlcnBEdXJhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX2xlcnBFbmQueSA8IHRoaXMuX2xlcnBTdGFydC55KSB7XHJcbiAgICAgICAgICAgICAgICBuZXdZID1cclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sZXJwU3RhcnQueSAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLmVhc2luZ0Zjbih0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBEdXJhdGlvbikgLSB0aGlzLl9sZXJwRW5kLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgbmV3WSA9IHRoaXMuZWFzaW5nRmNuKHRoaXMuX2N1cnJlbnRMZXJwVGltZSwgdGhpcy5fbGVycFN0YXJ0LnksIHRoaXMuX2xlcnBFbmQueSwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBHaXZlbiB0aGUgbGVycCBwb3NpdGlvbiBmaWd1cmUgb3V0IHRoZSB2ZWxvY2l0eSBpbiBwaXhlbHMgcGVyIHNlY29uZFxyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKChuZXdYIC0gdGhpcy5fdHgucG9zLngpIC8gKGRlbHRhIC8gMTAwMCksIChuZXdZIC0gdGhpcy5fdHgucG9zLnkpIC8gKGRlbHRhIC8gMTAwMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdHgucG9zID0gdmVjKHRoaXMuX2xlcnBFbmQueCwgdGhpcy5fbGVycEVuZC55KTtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoYWN0b3IpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCBuZXcgVmVjdG9yKGFjdG9yLnBvcy54LCBhY3Rvci5wb3MueSkuZGlzdGFuY2UodGhpcy5fbGVycFN0YXJ0KSA+PSB0aGlzLl9kaXN0YW5jZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9CbGluay50c1xuXHJcbmNsYXNzIEJsaW5rIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgdGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MgPSAxKSB7XHJcbiAgICAgICAgdGhpcy5fdGltZVZpc2libGUgPSAwO1xyXG4gICAgICAgIHRoaXMuX3RpbWVOb3RWaXNpYmxlID0gMDtcclxuICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fdG90YWxUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzID0gZW50aXR5LmdldChHcmFwaGljc0NvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fdGltZVZpc2libGUgPSB0aW1lVmlzaWJsZTtcclxuICAgICAgICB0aGlzLl90aW1lTm90VmlzaWJsZSA9IHRpbWVOb3RWaXNpYmxlO1xyXG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gKHRpbWVWaXNpYmxlICsgdGltZU5vdFZpc2libGUpICogbnVtQmxpbmtzO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGRlbHRhKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9zdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2dyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gZGVsdGE7XHJcbiAgICAgICAgdGhpcy5fdG90YWxUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgIGlmICh0aGlzLl9ncmFwaGljcy52aXNpYmxlICYmIHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuX3RpbWVWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzLnZpc2libGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2dyYXBoaWNzLnZpc2libGUgJiYgdGhpcy5fZWxhcHNlZFRpbWUgPj0gdGhpcy5fdGltZU5vdFZpc2libGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3MudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzLnZpc2libGUgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQgfHwgdGhpcy5fdG90YWxUaW1lID49IHRoaXMuX2R1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICBpZiAodGhpcy5fZ3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3MudmlzaWJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl90b3RhbFRpbWUgPSAwO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vRmFkZS50c1xuXHJcblxyXG5jbGFzcyBGYWRlIHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSwgZW5kT3BhY2l0eSwgc3BlZWQpIHtcclxuICAgICAgICB0aGlzLl9tdWx0aXBsaWVyID0gMTtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzID0gZW50aXR5LmdldChHcmFwaGljc0NvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fZW5kT3BhY2l0eSA9IGVuZE9wYWNpdHk7XHJcbiAgICAgICAgdGhpcy5fc3BlZWQgPSBzcGVlZDtcclxuICAgIH1cclxuICAgIHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fZ3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIC8vIGRldGVybWluZSBkaXJlY3Rpb24gd2hlbiB3ZSBzdGFydFxyXG4gICAgICAgICAgICBpZiAodGhpcy5fZW5kT3BhY2l0eSA8IHRoaXMuX2dyYXBoaWNzLm9wYWNpdHkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSAtMTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9zcGVlZCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3Mub3BhY2l0eSArPSAodGhpcy5fbXVsdGlwbGllciAqXHJcbiAgICAgICAgICAgICAgICAoTWF0aC5hYnModGhpcy5fZ3JhcGhpY3Mub3BhY2l0eSAtIHRoaXMuX2VuZE9wYWNpdHkpICogZGVsdGEpKSAvIHRoaXMuX3NwZWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zcGVlZCAtPSBkZWx0YTtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3Mub3BhY2l0eSA9IHRoaXMuX2VuZE9wYWNpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdbQWN0aW9uIGZhZGVdIEFjdG9yIG9wYWNpdHk6JywgdGhpcy5fZ3JhcGhpY3Mub3BhY2l0eSk7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IE1hdGguYWJzKHRoaXMuX2dyYXBoaWNzLm9wYWNpdHkgLSB0aGlzLl9lbmRPcGFjaXR5KSA8IDAuMDU7XHJcbiAgICB9XHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIHRoaXMuX3N0b3BwZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQWN0aW9ucy9BY3Rpb24vRGVsYXkudHNcbmNsYXNzIERlbGF5IHtcclxuICAgIGNvbnN0cnVjdG9yKGRlbGF5KSB7XHJcbiAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGVsYXkgPSBkZWxheTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3RhcnRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgKz0gZGVsdGE7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkIHx8IHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuX2RlbGF5O1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9EaWUudHNcblxyXG5jbGFzcyBEaWUge1xyXG4gICAgY29uc3RydWN0b3IoZW50aXR5KSB7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eSA9IGVudGl0eTtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZGVsdGEpIHtcclxuICAgICAgICB0aGlzLl9lbnRpdHkuZ2V0KEFjdGlvbnNDb21wb25lbnQpLmNsZWFyQWN0aW9ucygpO1xyXG4gICAgICAgIHRoaXMuX2VudGl0eS5raWxsKCk7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBpc0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdG9wcGVkO1xyXG4gICAgfVxyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9Gb2xsb3cudHNcblxyXG5cclxuXHJcbmNsYXNzIEZvbGxvdyB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbnRpdHksIGVudGl0eVRvRm9sbG93LCBmb2xsb3dEaXN0YW5jZSkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdHggPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uID0gZW50aXR5LmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX2ZvbGxvd1R4ID0gZW50aXR5VG9Gb2xsb3cuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fZm9sbG93TW90aW9uID0gZW50aXR5VG9Gb2xsb3cuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IG5ldyBWZWN0b3IodGhpcy5fdHgucG9zLngsIHRoaXMuX3R4LnBvcy55KTtcclxuICAgICAgICB0aGlzLl9lbmQgPSBuZXcgVmVjdG9yKHRoaXMuX2ZvbGxvd1R4LnBvcy54LCB0aGlzLl9mb2xsb3dUeC5wb3MueSk7XHJcbiAgICAgICAgdGhpcy5fbWF4aW11bURpc3RhbmNlID0gZm9sbG93RGlzdGFuY2UgIT09IHVuZGVmaW5lZCA/IGZvbGxvd0Rpc3RhbmNlIDogdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgIHRoaXMuX3NwZWVkID0gMDtcclxuICAgIH1cclxuICAgIHVwZGF0ZShfZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA9IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9jdXJyZW50KS5ub3JtYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWN0b3JUb0ZvbGxvd1NwZWVkID0gTWF0aC5zcXJ0KE1hdGgucG93KHRoaXMuX2ZvbGxvd01vdGlvbi52ZWwueCwgMikgKyBNYXRoLnBvdyh0aGlzLl9mb2xsb3dNb3Rpb24udmVsLnksIDIpKTtcclxuICAgICAgICBpZiAoYWN0b3JUb0ZvbGxvd1NwZWVkICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NwZWVkID0gYWN0b3JUb0ZvbGxvd1NwZWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jdXJyZW50ID0gdmVjKHRoaXMuX3R4LnBvcy54LCB0aGlzLl90eC5wb3MueSk7XHJcbiAgICAgICAgdGhpcy5fZW5kID0gdmVjKHRoaXMuX2ZvbGxvd1R4LnBvcy54LCB0aGlzLl9mb2xsb3dUeC5wb3MueSk7XHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2VCZXR3ZWVuID0gdGhpcy5fY3VycmVudC5kaXN0YW5jZSh0aGlzLl9lbmQpO1xyXG4gICAgICAgIHRoaXMuX2RpciA9IHRoaXMuX2VuZC5zdWIodGhpcy5fY3VycmVudCkubm9ybWFsaXplKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA+PSB0aGlzLl9tYXhpbXVtRGlzdGFuY2UpIHtcclxuICAgICAgICAgICAgY29uc3QgbSA9IHRoaXMuX2Rpci5zY2FsZSh0aGlzLl9zcGVlZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMobS54LCBtLnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuaXNDb21wbGV0ZSgpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3R4LnBvcyA9IHZlYyh0aGlzLl9lbmQueCwgdGhpcy5fZW5kLnkpO1xyXG4gICAgICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlzQ29tcGxldGUoKSB7XHJcbiAgICAgICAgLy8gdGhlIGFjdG9yIGZvbGxvd2luZyBzaG91bGQgbmV2ZXIgc3RvcCB1bmxlc3Mgc3BlY2lmaWVkIHRvIGRvIHNvXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3BwZWQ7XHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbi9NZWV0LnRzXG5cclxuXHJcblxyXG5jbGFzcyBNZWV0IHtcclxuICAgIGNvbnN0cnVjdG9yKGFjdG9yLCBhY3RvclRvTWVldCwgc3BlZWQpIHtcclxuICAgICAgICB0aGlzLl9zdGFydGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc3RvcHBlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3NwZWVkV2FzU3BlY2lmaWVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdHggPSBhY3Rvci5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24gPSBhY3Rvci5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tZWV0VHggPSBhY3RvclRvTWVldC5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KTtcclxuICAgICAgICB0aGlzLl9tZWV0TW90aW9uID0gYWN0b3JUb01lZXQuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudCA9IG5ldyBWZWN0b3IodGhpcy5fdHgucG9zLngsIHRoaXMuX3R4LnBvcy55KTtcclxuICAgICAgICB0aGlzLl9lbmQgPSBuZXcgVmVjdG9yKHRoaXMuX21lZXRUeC5wb3MueCwgdGhpcy5fbWVldFR4LnBvcy55KTtcclxuICAgICAgICB0aGlzLl9zcGVlZCA9IHNwZWVkIHx8IDA7XHJcbiAgICAgICAgaWYgKHNwZWVkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZShfZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc3RhbmNlQmV0d2VlbiA9IHRoaXMuX2N1cnJlbnQuZGlzdGFuY2UodGhpcy5fZW5kKTtcclxuICAgICAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9jdXJyZW50KS5ub3JtYWxpemUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYWN0b3JUb01lZXRTcGVlZCA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLl9tZWV0TW90aW9uLnZlbC54LCAyKSArIE1hdGgucG93KHRoaXMuX21lZXRNb3Rpb24udmVsLnksIDIpKTtcclxuICAgICAgICBpZiAoYWN0b3JUb01lZXRTcGVlZCAhPT0gMCAmJiAhdGhpcy5fc3BlZWRXYXNTcGVjaWZpZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3BlZWQgPSBhY3RvclRvTWVldFNwZWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jdXJyZW50ID0gdmVjKHRoaXMuX3R4LnBvcy54LCB0aGlzLl90eC5wb3MueSk7XHJcbiAgICAgICAgdGhpcy5fZW5kID0gdmVjKHRoaXMuX21lZXRUeC5wb3MueCwgdGhpcy5fbWVldFR4LnBvcy55KTtcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZUJldHdlZW4gPSB0aGlzLl9jdXJyZW50LmRpc3RhbmNlKHRoaXMuX2VuZCk7XHJcbiAgICAgICAgdGhpcy5fZGlyID0gdGhpcy5fZW5kLnN1Yih0aGlzLl9jdXJyZW50KS5ub3JtYWxpemUoKTtcclxuICAgICAgICBjb25zdCBtID0gdGhpcy5fZGlyLnNjYWxlKHRoaXMuX3NwZWVkKTtcclxuICAgICAgICB0aGlzLl9tb3Rpb24udmVsID0gdmVjKG0ueCwgbS55KTtcclxuICAgICAgICBpZiAodGhpcy5pc0NvbXBsZXRlKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHgucG9zID0gdmVjKHRoaXMuX2VuZC54LCB0aGlzLl9lbmQueSk7XHJcbiAgICAgICAgICAgIHRoaXMuX21vdGlvbi52ZWwgPSB2ZWMoMCwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaXNDb21wbGV0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RvcHBlZCB8fCB0aGlzLl9kaXN0YW5jZUJldHdlZW4gPD0gMTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZlYygwLCAwKTtcclxuICAgICAgICB0aGlzLl9zdG9wcGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uQ29udGV4dC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBUaGUgZmx1ZW50IEFjdGlvbiBBUEkgYWxsb3dzIHlvdSB0byBwZXJmb3JtIFwiYWN0aW9uc1wiIG9uXHJcbiAqIFtbQWN0b3J8QWN0b3JzXV0gc3VjaCBhcyBmb2xsb3dpbmcsIG1vdmluZywgcm90YXRpbmcsIGFuZFxyXG4gKiBtb3JlLiBZb3UgY2FuIGltcGxlbWVudCB5b3VyIG93biBhY3Rpb25zIGJ5IGltcGxlbWVudGluZ1xyXG4gKiB0aGUgW1tBY3Rpb25dXSBpbnRlcmZhY2UuXHJcbiAqL1xyXG5jbGFzcyBBY3Rpb25Db250ZXh0IHtcclxuICAgIGNvbnN0cnVjdG9yKGVudGl0eSkge1xyXG4gICAgICAgIHRoaXMuX2VudGl0eSA9IGVudGl0eTtcclxuICAgICAgICB0aGlzLl9xdWV1ZSA9IG5ldyBBY3Rpb25RdWV1ZShlbnRpdHkpO1xyXG4gICAgfVxyXG4gICAgZ2V0UXVldWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXVlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGVsYXBzZWRNcykge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLnVwZGF0ZShlbGFwc2VkTXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYWxsIHF1ZXVlZCBhY3Rpb25zIGZyb20gdGhlIEFjdG9yXHJcbiAgICAgKi9cclxuICAgIGNsZWFyQWN0aW9ucygpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5jbGVhckFjdGlvbnMoKTtcclxuICAgIH1cclxuICAgIGVhc2VUbyguLi5hcmdzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgbGV0IHkgPSAwO1xyXG4gICAgICAgIGxldCBkdXJhdGlvbiA9IDA7XHJcbiAgICAgICAgbGV0IGVhc2luZ0ZjbiA9IEVhc2luZ0Z1bmN0aW9ucy5MaW5lYXI7XHJcbiAgICAgICAgaWYgKGFyZ3NbMF0gaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgeCA9IGFyZ3NbMF0ueDtcclxuICAgICAgICAgICAgeSA9IGFyZ3NbMF0ueTtcclxuICAgICAgICAgICAgZHVyYXRpb24gPSBhcmdzWzFdO1xyXG4gICAgICAgICAgICBlYXNpbmdGY24gPSAoX2EgPSBhcmdzWzJdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlYXNpbmdGY247XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB4ID0gYXJnc1swXTtcclxuICAgICAgICAgICAgeSA9IGFyZ3NbMV07XHJcbiAgICAgICAgICAgIGR1cmF0aW9uID0gYXJnc1syXTtcclxuICAgICAgICAgICAgZWFzaW5nRmNuID0gKF9iID0gYXJnc1szXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZWFzaW5nRmNuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IEVhc2VUbyh0aGlzLl9lbnRpdHksIHgsIHksIGR1cmF0aW9uLCBlYXNpbmdGY24pKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIG1vdmVUbyh4T3JQb3MsIHlPclNwZWVkLCBzcGVlZE9yVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgIGxldCB5ID0gMDtcclxuICAgICAgICBsZXQgc3BlZWQgPSAwO1xyXG4gICAgICAgIGlmICh4T3JQb3MgaW5zdGFuY2VvZiBWZWN0b3IpIHtcclxuICAgICAgICAgICAgeCA9IHhPclBvcy54O1xyXG4gICAgICAgICAgICB5ID0geE9yUG9zLnk7XHJcbiAgICAgICAgICAgIHNwZWVkID0geU9yU3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB4ID0geE9yUG9zO1xyXG4gICAgICAgICAgICB5ID0geU9yU3BlZWQ7XHJcbiAgICAgICAgICAgIHNwZWVkID0gc3BlZWRPclVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBNb3ZlVG8odGhpcy5fZW50aXR5LCB4LCB5LCBzcGVlZCkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgbW92ZUJ5KHhPZmZzZXRPclZlY3RvciwgeU9mZnNldE9yU3BlZWQsIHNwZWVkT3JVbmRlZmluZWQpIHtcclxuICAgICAgICBsZXQgeE9mZnNldCA9IDA7XHJcbiAgICAgICAgbGV0IHlPZmZzZXQgPSAwO1xyXG4gICAgICAgIGxldCBzcGVlZCA9IDA7XHJcbiAgICAgICAgaWYgKHhPZmZzZXRPclZlY3RvciBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICB4T2Zmc2V0ID0geE9mZnNldE9yVmVjdG9yLng7XHJcbiAgICAgICAgICAgIHlPZmZzZXQgPSB4T2Zmc2V0T3JWZWN0b3IueTtcclxuICAgICAgICAgICAgc3BlZWQgPSB5T2Zmc2V0T3JTcGVlZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHhPZmZzZXQgPSB4T2Zmc2V0T3JWZWN0b3I7XHJcbiAgICAgICAgICAgIHlPZmZzZXQgPSB5T2Zmc2V0T3JTcGVlZDtcclxuICAgICAgICAgICAgc3BlZWQgPSBzcGVlZE9yVW5kZWZpbmVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IE1vdmVCeSh0aGlzLl9lbnRpdHksIHhPZmZzZXQsIHlPZmZzZXQsIHNwZWVkKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcm90YXRlIGFuIGFjdG9yIHRvIHRoZSBzcGVjaWZpZWQgYW5nbGUgYXQgdGhlIHNwZWVkXHJcbiAgICAgKiBzcGVjaWZpZWQgKGluIHJhZGlhbnMgcGVyIHNlY29uZCkgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpc1xyXG4gICAgICogbWV0aG9kIGlzIHBhcnQgb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICogQHBhcmFtIGFuZ2xlUmFkaWFucyAgVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0byBpbiByYWRpYW5zXHJcbiAgICAgKiBAcGFyYW0gc3BlZWQgICAgICAgICBUaGUgYW5ndWxhciB2ZWxvY2l0eSBvZiB0aGUgcm90YXRpb24gc3BlY2lmaWVkIGluIHJhZGlhbnMgcGVyIHNlY29uZFxyXG4gICAgICogQHBhcmFtIHJvdGF0aW9uVHlwZSAgVGhlIFtbUm90YXRpb25UeXBlXV0gdG8gdXNlIGZvciB0aGlzIHJvdGF0aW9uXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZVRvKGFuZ2xlUmFkaWFucywgc3BlZWQsIHJvdGF0aW9uVHlwZSkge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgUm90YXRlVG8odGhpcy5fZW50aXR5LCBhbmdsZVJhZGlhbnMsIHNwZWVkLCByb3RhdGlvblR5cGUpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCByb3RhdGUgYW4gYWN0b3IgYnkgdGhlIHNwZWNpZmllZCBhbmdsZSBvZmZzZXQsIGZyb20gaXQncyBjdXJyZW50IHJvdGF0aW9uIGdpdmVuIGEgY2VydGFpbiBzcGVlZFxyXG4gICAgICogaW4gcmFkaWFucy9zZWMgYW5kIHJldHVybiBiYWNrIHRoZSBhY3Rvci4gVGhpcyBtZXRob2QgaXMgcGFydFxyXG4gICAgICogb2YgdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICogQHBhcmFtIGFuZ2xlUmFkaWFuc09mZnNldCAgVGhlIGFuZ2xlIHRvIHJvdGF0ZSB0byBpbiByYWRpYW5zIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHJvdGF0aW9uXHJcbiAgICAgKiBAcGFyYW0gc3BlZWQgICAgICAgICAgVGhlIHNwZWVkIGluIHJhZGlhbnMvc2VjIHRoZSBhY3RvciBzaG91bGQgcm90YXRlIGF0XHJcbiAgICAgKiBAcGFyYW0gcm90YXRpb25UeXBlICBUaGUgW1tSb3RhdGlvblR5cGVdXSB0byB1c2UgZm9yIHRoaXMgcm90YXRpb24sIGRlZmF1bHQgaXMgc2hvcnRlc3QgcGF0aFxyXG4gICAgICovXHJcbiAgICByb3RhdGVCeShhbmdsZVJhZGlhbnNPZmZzZXQsIHNwZWVkLCByb3RhdGlvblR5cGUpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IFJvdGF0ZUJ5KHRoaXMuX2VudGl0eSwgYW5nbGVSYWRpYW5zT2Zmc2V0LCBzcGVlZCwgcm90YXRpb25UeXBlKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBzY2FsZVRvKHNpemVYT3JWZWN0b3IsIHNpemVZT3JTcGVlZCwgc3BlZWRYT3JVbmRlZmluZWQsIHNwZWVkWU9yVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgbGV0IHNpemVYID0gMTtcclxuICAgICAgICBsZXQgc2l6ZVkgPSAxO1xyXG4gICAgICAgIGxldCBzcGVlZFggPSAwO1xyXG4gICAgICAgIGxldCBzcGVlZFkgPSAwO1xyXG4gICAgICAgIGlmIChzaXplWE9yVmVjdG9yIGluc3RhbmNlb2YgVmVjdG9yICYmIHNpemVZT3JTcGVlZCBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICBzaXplWCA9IHNpemVYT3JWZWN0b3IueDtcclxuICAgICAgICAgICAgc2l6ZVkgPSBzaXplWE9yVmVjdG9yLnk7XHJcbiAgICAgICAgICAgIHNwZWVkWCA9IHNpemVZT3JTcGVlZC54O1xyXG4gICAgICAgICAgICBzcGVlZFkgPSBzaXplWU9yU3BlZWQueTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBzaXplWE9yVmVjdG9yID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2l6ZVlPclNwZWVkID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICBzaXplWCA9IHNpemVYT3JWZWN0b3I7XHJcbiAgICAgICAgICAgIHNpemVZID0gc2l6ZVlPclNwZWVkO1xyXG4gICAgICAgICAgICBzcGVlZFggPSBzcGVlZFhPclVuZGVmaW5lZDtcclxuICAgICAgICAgICAgc3BlZWRZID0gc3BlZWRZT3JVbmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgU2NhbGVUbyh0aGlzLl9lbnRpdHksIHNpemVYLCBzaXplWSwgc3BlZWRYLCBzcGVlZFkpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHNjYWxlQnkoc2l6ZU9mZnNldFhPclZlY3Rvciwgc2l6ZU9mZnNldFlPclNwZWVkLCBzcGVlZCkge1xyXG4gICAgICAgIGxldCBzaXplT2Zmc2V0WCA9IDE7XHJcbiAgICAgICAgbGV0IHNpemVPZmZzZXRZID0gMTtcclxuICAgICAgICBpZiAoc2l6ZU9mZnNldFhPclZlY3RvciBpbnN0YW5jZW9mIFZlY3Rvcikge1xyXG4gICAgICAgICAgICBzaXplT2Zmc2V0WCA9IHNpemVPZmZzZXRYT3JWZWN0b3IueDtcclxuICAgICAgICAgICAgc2l6ZU9mZnNldFkgPSBzaXplT2Zmc2V0WE9yVmVjdG9yLnk7XHJcbiAgICAgICAgICAgIHNwZWVkID0gc2l6ZU9mZnNldFlPclNwZWVkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIHNpemVPZmZzZXRYT3JWZWN0b3IgPT09ICdudW1iZXInICYmIHR5cGVvZiBzaXplT2Zmc2V0WU9yU3BlZWQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHNpemVPZmZzZXRYID0gc2l6ZU9mZnNldFhPclZlY3RvcjtcclxuICAgICAgICAgICAgc2l6ZU9mZnNldFkgPSBzaXplT2Zmc2V0WU9yU3BlZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgU2NhbGVCeSh0aGlzLl9lbnRpdHksIHNpemVPZmZzZXRYLCBzaXplT2Zmc2V0WSwgc3BlZWQpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSBhbiBhY3RvciB0byBibGluayAoYmVjb21lIHZpc2libGUgYW5kIG5vdFxyXG4gICAgICogdmlzaWJsZSkuIE9wdGlvbmFsbHksIHlvdSBtYXkgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIGJsaW5rcy4gU3BlY2lmeSB0aGUgYW1vdW50IG9mIHRpbWVcclxuICAgICAqIHRoZSBhY3RvciBzaG91bGQgYmUgdmlzaWJsZSBwZXIgYmxpbmssIGFuZCB0aGUgYW1vdW50IG9mIHRpbWUgbm90IHZpc2libGUuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSB0aW1lVmlzaWJsZSAgICAgVGhlIGFtb3VudCBvZiB0aW1lIHRvIHN0YXkgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKiBAcGFyYW0gdGltZU5vdFZpc2libGUgIFRoZSBhbW91bnQgb2YgdGltZSB0byBzdGF5IG5vdCB2aXNpYmxlIHBlciBibGluayBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEBwYXJhbSBudW1CbGlua3MgICAgICAgVGhlIG51bWJlciBvZiB0aW1lcyB0byBibGlua1xyXG4gICAgICovXHJcbiAgICBibGluayh0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcyA9IDEpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IEJsaW5rKHRoaXMuX2VudGl0eSwgdGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSBhbiBhY3RvcidzIG9wYWNpdHkgdG8gY2hhbmdlIGZyb20gaXRzIGN1cnJlbnQgdmFsdWVcclxuICAgICAqIHRvIHRoZSBwcm92aWRlZCB2YWx1ZSBieSBhIHNwZWNpZmllZCB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpc1xyXG4gICAgICogcGFydCBvZiB0aGUgYWN0b3IgJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gb3BhY2l0eSAgVGhlIGVuZGluZyBvcGFjaXR5XHJcbiAgICAgKiBAcGFyYW0gdGltZSAgICAgVGhlIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gZmFkZSB0aGUgYWN0b3IgKGluIG1pbGxpc2Vjb25kcylcclxuICAgICAqL1xyXG4gICAgZmFkZShvcGFjaXR5LCB0aW1lKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBGYWRlKHRoaXMuX2VudGl0eSwgb3BhY2l0eSwgdGltZSkpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGRlbGF5IHRoZSBuZXh0IGFjdGlvbiBmcm9tIGV4ZWN1dGluZyBmb3IgYSBjZXJ0YWluXHJcbiAgICAgKiBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKS4gVGhpcyBtZXRob2QgaXMgcGFydCBvZiB0aGUgYWN0b3JcclxuICAgICAqICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nLlxyXG4gICAgICogQHBhcmFtIHRpbWUgIFRoZSBhbW91bnQgb2YgdGltZSB0byBkZWxheSB0aGUgbmV4dCBhY3Rpb24gaW4gdGhlIHF1ZXVlIGZyb20gZXhlY3V0aW5nIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICovXHJcbiAgICBkZWxheSh0aW1lKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBEZWxheSh0aW1lKSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYWRkIGFuIGFjdGlvbiB0byB0aGUgcXVldWUgdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWN0b3IgZnJvbSB0aGVcclxuICAgICAqIHNjZW5lIG9uY2UgaXQgaGFzIGNvbXBsZXRlZCBpdHMgcHJldmlvdXMgIEFueSBhY3Rpb25zIG9uIHRoZVxyXG4gICAgICogYWN0aW9uIHF1ZXVlIGFmdGVyIHRoaXMgYWN0aW9uIHdpbGwgbm90IGJlIGV4ZWN1dGVkLlxyXG4gICAgICovXHJcbiAgICBkaWUoKSB7XHJcbiAgICAgICAgdGhpcy5fcXVldWUuYWRkKG5ldyBEaWUodGhpcy5fZW50aXR5KSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gY2FsbCBhbiBhcmJpdHJhcnkgbWV0aG9kIGFzIHRoZSBuZXh0IGFjdGlvbiBpbiB0aGVcclxuICAgICAqIGFjdGlvbiBxdWV1ZS4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gZXhlY3V0ZSBjb2RlIGluIGFmdGVyIGEgc3BlY2lmaWNcclxuICAgICAqIGFjdGlvbiwgaS5lIEFuIGFjdG9yIGFycml2ZXMgYXQgYSBkZXN0aW5hdGlvbiBhZnRlciB0cmF2ZXJzaW5nIGEgcGF0aFxyXG4gICAgICovXHJcbiAgICBjYWxsTWV0aG9kKG1ldGhvZCkge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgQ2FsbE1ldGhvZChtZXRob2QpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gcmVwZWF0IGFsbCBvZiB0aGUgYWN0aW9ucyBidWlsdCBpblxyXG4gICAgICogdGhlIGByZXBlYXRCdWlsZGVyYCBjYWxsYmFjay4gSWYgdGhlIG51bWJlciBvZiByZXBlYXRzXHJcbiAgICAgKiBpcyBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgcmVwZWF0IGZvcmV2ZXIuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2ZcclxuICAgICAqIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZ1xyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIC8vIE1vdmUgdXAgaW4gYSB6aWctemFnIGJ5IHJlcGVhdGVkIG1vdmVCeSdzXHJcbiAgICAgKiBhY3Rvci5hY3Rpb25zLnJlcGVhdChyZXBlYXRDdHggPT4ge1xyXG4gICAgICogIHJlcGVhdEN0eC5tb3ZlQnkoMTAsIDAsIDEwKTtcclxuICAgICAqICByZXBlYXRDdHgubW92ZUJ5KDAsIDEwLCAxMCk7XHJcbiAgICAgKiB9LCA1KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXBlYXRCdWlsZGVyIFRoZSBidWlsZGVyIHRvIHNwZWNpZnkgdGhlIHJlcGVhdGFibGUgbGlzdCBvZiBhY3Rpb25zXHJcbiAgICAgKiBAcGFyYW0gdGltZXMgIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGFsbCB0aGUgcHJldmlvdXMgYWN0aW9ucyBpbiB0aGUgYWN0aW9uIHF1ZXVlLiBJZiBub3RoaW5nIGlzIHNwZWNpZmllZCB0aGUgYWN0aW9uc1xyXG4gICAgICogd2lsbCByZXBlYXQgZm9yZXZlclxyXG4gICAgICovXHJcbiAgICByZXBlYXQocmVwZWF0QnVpbGRlciwgdGltZXMpIHtcclxuICAgICAgICBpZiAoIXRpbWVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVwZWF0Rm9yZXZlcihyZXBlYXRCdWlsZGVyKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgUmVwZWF0KHRoaXMuX2VudGl0eSwgcmVwZWF0QnVpbGRlciwgdGltZXMpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gcmVwZWF0IGFsbCBvZiB0aGUgYWN0aW9ucyBidWlsdCBpblxyXG4gICAgICogdGhlIGByZXBlYXRCdWlsZGVyYCBjYWxsYmFjay4gSWYgdGhlIG51bWJlciBvZiByZXBlYXRzXHJcbiAgICAgKiBpcyBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgcmVwZWF0IGZvcmV2ZXIuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2ZcclxuICAgICAqIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZ1xyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIC8vIE1vdmUgdXAgaW4gYSB6aWctemFnIGJ5IHJlcGVhdGVkIG1vdmVCeSdzXHJcbiAgICAgKiBhY3Rvci5hY3Rpb25zLnJlcGVhdChyZXBlYXRDdHggPT4ge1xyXG4gICAgICogIHJlcGVhdEN0eC5tb3ZlQnkoMTAsIDAsIDEwKTtcclxuICAgICAqICByZXBlYXRDdHgubW92ZUJ5KDAsIDEwLCAxMCk7XHJcbiAgICAgKiB9LCA1KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXBlYXRCdWlsZGVyIFRoZSBidWlsZGVyIHRvIHNwZWNpZnkgdGhlIHJlcGVhdGFibGUgbGlzdCBvZiBhY3Rpb25zXHJcbiAgICAgKi9cclxuICAgIHJlcGVhdEZvcmV2ZXIocmVwZWF0QnVpbGRlcikge1xyXG4gICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgUmVwZWF0Rm9yZXZlcih0aGlzLl9lbnRpdHksIHJlcGVhdEJ1aWxkZXIpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgZW50aXR5IHRvIGZvbGxvdyBhbm90aGVyIGF0IGEgc3BlY2lmaWVkIGRpc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5ICAgICAgICAgICBUaGUgZW50aXR5IHRvIGZvbGxvd1xyXG4gICAgICogQHBhcmFtIGZvbGxvd0Rpc3RhbmNlICBUaGUgZGlzdGFuY2UgdG8gbWFpbnRhaW4gd2hlbiBmb2xsb3dpbmcsIGlmIG5vdCBzcGVjaWZpZWQgdGhlIGFjdG9yIHdpbGwgZm9sbG93IGF0IHRoZSBjdXJyZW50IGRpc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBmb2xsb3coZW50aXR5LCBmb2xsb3dEaXN0YW5jZSkge1xyXG4gICAgICAgIGlmIChmb2xsb3dEaXN0YW5jZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgRm9sbG93KHRoaXMuX2VudGl0eSwgZW50aXR5KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IEZvbGxvdyh0aGlzLl9lbnRpdHksIGVudGl0eSwgZm9sbG93RGlzdGFuY2UpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgY2F1c2UgdGhlIGVudGl0eSB0byBtb3ZlIHRvd2FyZHMgYW5vdGhlciB1bnRpbCB0aGV5XHJcbiAgICAgKiBjb2xsaWRlIFwibWVldFwiIGF0IGEgc3BlY2lmaWVkIHNwZWVkLlxyXG4gICAgICogQHBhcmFtIGVudGl0eSAgVGhlIGVudGl0eSB0byBtZWV0XHJcbiAgICAgKiBAcGFyYW0gc3BlZWQgIFRoZSBzcGVlZCBpbiBwaXhlbHMgcGVyIHNlY29uZCB0byBtb3ZlLCBpZiBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgbWF0Y2ggdGhlIHNwZWVkIG9mIHRoZSBvdGhlciBhY3RvclxyXG4gICAgICovXHJcbiAgICBtZWV0KGVudGl0eSwgc3BlZWQpIHtcclxuICAgICAgICBpZiAoc3BlZWQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9xdWV1ZS5hZGQobmV3IE1lZXQodGhpcy5fZW50aXR5LCBlbnRpdHkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgTWVldCh0aGlzLl9lbnRpdHksIGVudGl0eSwgc3BlZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY3VycmVudCBhY3Rpb24gcXVldWUgdXAgdG8gbm93XHJcbiAgICAgKiBpcyBmaW5pc2hlZC5cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBgdG9Qcm9taXNlKClgIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAgICAgKi9cclxuICAgIGFzUHJvbWlzZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50b1Byb21pc2UoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBjdXJyZW50IGFjdGlvbiBxdWV1ZSB1cCB0byBub3dcclxuICAgICAqIGlzIGZpbmlzaGVkLlxyXG4gICAgICovXHJcbiAgICB0b1Byb21pc2UoKSB7XHJcbiAgICAgICAgY29uc3QgdGVtcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmFkZChuZXcgQ2FsbE1ldGhvZCgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gdGVtcDtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0FjdGlvbnMvQWN0aW9uc0NvbXBvbmVudC50c1xuXHJcblxyXG5cclxuXHJcbjtcclxuY2xhc3MgQWN0aW9uc0NvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdleC5hY3Rpb25zJztcclxuICAgICAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtUcmFuc2Zvcm1Db21wb25lbnQsIE1vdGlvbkNvbXBvbmVudF07XHJcbiAgICB9XHJcbiAgICBvbkFkZChlbnRpdHkpIHtcclxuICAgICAgICB0aGlzLl9jdHggPSBuZXcgQWN0aW9uQ29udGV4dChlbnRpdHkpO1xyXG4gICAgfVxyXG4gICAgb25SZW1vdmUoKSB7XHJcbiAgICAgICAgdGhpcy5fY3R4ID0gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaW50ZXJuYWwgYWN0aW9uIHF1ZXVlXHJcbiAgICAgKiBAcmV0dXJucyBhY3Rpb24gcXVldVxyXG4gICAgICovXHJcbiAgICBnZXRRdWV1ZSgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2N0eCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFF1ZXVlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGludGVybmFsIGFjdGlvbiBjb250ZXh0LCBwZXJmb3JtaW5nIGFjdGlvbiBhbmQgbW92aW5nIHRocm91Z2ggdGhlIGludGVybmFsIHF1ZXVlXHJcbiAgICAgKiBAcGFyYW0gZWxhcHNlZE1zXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShlbGFwc2VkTXMpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuX2N0eCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZShlbGFwc2VkTXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYWxsIHF1ZXVlZCBhY3Rpb25zIGZyb20gdGhlIEFjdG9yXHJcbiAgICAgKi9cclxuICAgIGNsZWFyQWN0aW9ucygpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5fY3R4KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYXJBY3Rpb25zKCk7XHJcbiAgICB9XHJcbiAgICBlYXNlVG8oLi4uYXJncykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguZWFzZVRvLmFwcGx5KHRoaXMuX2N0eCwgYXJncyk7XHJcbiAgICB9XHJcbiAgICBtb3ZlVG8oeE9yUG9zLCB5T3JTcGVlZCwgc3BlZWRPclVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgubW92ZVRvLmFwcGx5KHRoaXMuX2N0eCwgW3hPclBvcywgeU9yU3BlZWQsIHNwZWVkT3JVbmRlZmluZWRdKTtcclxuICAgIH1cclxuICAgIG1vdmVCeSh4T2Zmc2V0T3JWZWN0b3IsIHlPZmZzZXRPclNwZWVkLCBzcGVlZE9yVW5kZWZpbmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC5tb3ZlQnkuYXBwbHkodGhpcy5fY3R4LCBbeE9mZnNldE9yVmVjdG9yLCB5T2Zmc2V0T3JTcGVlZCwgc3BlZWRPclVuZGVmaW5lZF0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHJvdGF0ZSBhbiBhY3RvciB0byB0aGUgc3BlY2lmaWVkIGFuZ2xlIGF0IHRoZSBzcGVlZFxyXG4gICAgICogc3BlY2lmaWVkIChpbiByYWRpYW5zIHBlciBzZWNvbmQpIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXNcclxuICAgICAqIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSBhbmdsZVJhZGlhbnMgIFRoZSBhbmdsZSB0byByb3RhdGUgdG8gaW4gcmFkaWFuc1xyXG4gICAgICogQHBhcmFtIHNwZWVkICAgICAgICAgVGhlIGFuZ3VsYXIgdmVsb2NpdHkgb2YgdGhlIHJvdGF0aW9uIHNwZWNpZmllZCBpbiByYWRpYW5zIHBlciBzZWNvbmRcclxuICAgICAqIEBwYXJhbSByb3RhdGlvblR5cGUgIFRoZSBbW1JvdGF0aW9uVHlwZV1dIHRvIHVzZSBmb3IgdGhpcyByb3RhdGlvblxyXG4gICAgICovXHJcbiAgICByb3RhdGVUbyhhbmdsZVJhZGlhbnMsIHNwZWVkLCByb3RhdGlvblR5cGUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LnJvdGF0ZVRvKGFuZ2xlUmFkaWFucywgc3BlZWQsIHJvdGF0aW9uVHlwZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgcm90YXRlIGFuIGFjdG9yIGJ5IHRoZSBzcGVjaWZpZWQgYW5nbGUgb2Zmc2V0LCBmcm9tIGl0J3MgY3VycmVudCByb3RhdGlvbiBnaXZlbiBhIGNlcnRhaW4gc3BlZWRcclxuICAgICAqIGluIHJhZGlhbnMvc2VjIGFuZCByZXR1cm4gYmFjayB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIHBhcnRcclxuICAgICAqIG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSBhbmdsZVJhZGlhbnNPZmZzZXQgIFRoZSBhbmdsZSB0byByb3RhdGUgdG8gaW4gcmFkaWFucyByZWxhdGl2ZSB0byB0aGUgY3VycmVudCByb3RhdGlvblxyXG4gICAgICogQHBhcmFtIHNwZWVkICAgICAgICAgIFRoZSBzcGVlZCBpbiByYWRpYW5zL3NlYyB0aGUgYWN0b3Igc2hvdWxkIHJvdGF0ZSBhdFxyXG4gICAgICogQHBhcmFtIHJvdGF0aW9uVHlwZSAgVGhlIFtbUm90YXRpb25UeXBlXV0gdG8gdXNlIGZvciB0aGlzIHJvdGF0aW9uLCBkZWZhdWx0IGlzIHNob3J0ZXN0IHBhdGhcclxuICAgICAqL1xyXG4gICAgcm90YXRlQnkoYW5nbGVSYWRpYW5zT2Zmc2V0LCBzcGVlZCwgcm90YXRpb25UeXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC5yb3RhdGVCeShhbmdsZVJhZGlhbnNPZmZzZXQsIHNwZWVkLCByb3RhdGlvblR5cGUpO1xyXG4gICAgfVxyXG4gICAgc2NhbGVUbyhzaXplWE9yVmVjdG9yLCBzaXplWU9yU3BlZWQsIHNwZWVkWE9yVW5kZWZpbmVkLCBzcGVlZFlPclVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguc2NhbGVUby5hcHBseSh0aGlzLl9jdHgsIFtzaXplWE9yVmVjdG9yLCBzaXplWU9yU3BlZWQsIHNwZWVkWE9yVW5kZWZpbmVkLCBzcGVlZFlPclVuZGVmaW5lZF0pO1xyXG4gICAgfVxyXG4gICAgc2NhbGVCeShzaXplT2Zmc2V0WE9yVmVjdG9yLCBzaXplT2Zmc2V0WU9yU3BlZWQsIHNwZWVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC5zY2FsZUJ5LmFwcGx5KHRoaXMuX2N0eCwgW3NpemVPZmZzZXRYT3JWZWN0b3IsIHNpemVPZmZzZXRZT3JTcGVlZCwgc3BlZWRdKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSBhbiBhY3RvciB0byBibGluayAoYmVjb21lIHZpc2libGUgYW5kIG5vdFxyXG4gICAgICogdmlzaWJsZSkuIE9wdGlvbmFsbHksIHlvdSBtYXkgc3BlY2lmeSB0aGUgbnVtYmVyIG9mIGJsaW5rcy4gU3BlY2lmeSB0aGUgYW1vdW50IG9mIHRpbWVcclxuICAgICAqIHRoZSBhY3RvciBzaG91bGQgYmUgdmlzaWJsZSBwZXIgYmxpbmssIGFuZCB0aGUgYW1vdW50IG9mIHRpbWUgbm90IHZpc2libGUuXHJcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSB0aW1lVmlzaWJsZSAgICAgVGhlIGFtb3VudCBvZiB0aW1lIHRvIHN0YXkgdmlzaWJsZSBwZXIgYmxpbmsgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKiBAcGFyYW0gdGltZU5vdFZpc2libGUgIFRoZSBhbW91bnQgb2YgdGltZSB0byBzdGF5IG5vdCB2aXNpYmxlIHBlciBibGluayBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqIEBwYXJhbSBudW1CbGlua3MgICAgICAgVGhlIG51bWJlciBvZiB0aW1lcyB0byBibGlua1xyXG4gICAgICovXHJcbiAgICBibGluayh0aW1lVmlzaWJsZSwgdGltZU5vdFZpc2libGUsIG51bUJsaW5rcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguYmxpbmsodGltZVZpc2libGUsIHRpbWVOb3RWaXNpYmxlLCBudW1CbGlua3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGFuIGFjdG9yJ3Mgb3BhY2l0eSB0byBjaGFuZ2UgZnJvbSBpdHMgY3VycmVudCB2YWx1ZVxyXG4gICAgICogdG8gdGhlIHByb3ZpZGVkIHZhbHVlIGJ5IGEgc3BlY2lmaWVkIHRpbWUgKGluIG1pbGxpc2Vjb25kcykuIFRoaXMgbWV0aG9kIGlzXHJcbiAgICAgKiBwYXJ0IG9mIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZy5cclxuICAgICAqIEBwYXJhbSBvcGFjaXR5ICBUaGUgZW5kaW5nIG9wYWNpdHlcclxuICAgICAqIEBwYXJhbSB0aW1lICAgICBUaGUgdGltZSBpdCBzaG91bGQgdGFrZSB0byBmYWRlIHRoZSBhY3RvciAoaW4gbWlsbGlzZWNvbmRzKVxyXG4gICAgICovXHJcbiAgICBmYWRlKG9wYWNpdHksIHRpbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LmZhZGUob3BhY2l0eSwgdGltZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgZGVsYXkgdGhlIG5leHQgYWN0aW9uIGZyb20gZXhlY3V0aW5nIGZvciBhIGNlcnRhaW5cclxuICAgICAqIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpLiBUaGlzIG1ldGhvZCBpcyBwYXJ0IG9mIHRoZSBhY3RvclxyXG4gICAgICogJ0FjdGlvbicgZmx1ZW50IEFQSSBhbGxvd2luZyBhY3Rpb24gY2hhaW5pbmcuXHJcbiAgICAgKiBAcGFyYW0gdGltZSAgVGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IHRoZSBuZXh0IGFjdGlvbiBpbiB0aGUgcXVldWUgZnJvbSBleGVjdXRpbmcgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIGRlbGF5KHRpbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3R4LmRlbGF5KHRpbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGFkZCBhbiBhY3Rpb24gdG8gdGhlIHF1ZXVlIHRoYXQgd2lsbCByZW1vdmUgdGhlIGFjdG9yIGZyb20gdGhlXHJcbiAgICAgKiBzY2VuZSBvbmNlIGl0IGhhcyBjb21wbGV0ZWQgaXRzIHByZXZpb3VzICBBbnkgYWN0aW9ucyBvbiB0aGVcclxuICAgICAqIGFjdGlvbiBxdWV1ZSBhZnRlciB0aGlzIGFjdGlvbiB3aWxsIG5vdCBiZSBleGVjdXRlZC5cclxuICAgICAqL1xyXG4gICAgZGllKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguZGllKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWV0aG9kIGFsbG93cyB5b3UgdG8gY2FsbCBhbiBhcmJpdHJhcnkgbWV0aG9kIGFzIHRoZSBuZXh0IGFjdGlvbiBpbiB0aGVcclxuICAgICAqIGFjdGlvbiBxdWV1ZS4gVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gZXhlY3V0ZSBjb2RlIGluIGFmdGVyIGEgc3BlY2lmaWNcclxuICAgICAqIGFjdGlvbiwgaS5lIEFuIGFjdG9yIGFycml2ZXMgYXQgYSBkZXN0aW5hdGlvbiBhZnRlciB0cmF2ZXJzaW5nIGEgcGF0aFxyXG4gICAgICovXHJcbiAgICBjYWxsTWV0aG9kKG1ldGhvZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguY2FsbE1ldGhvZChtZXRob2QpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBhY3RvciB0byByZXBlYXQgYWxsIG9mIHRoZSBhY3Rpb25zIGJ1aWx0IGluXHJcbiAgICAgKiB0aGUgYHJlcGVhdEJ1aWxkZXJgIGNhbGxiYWNrLiBJZiB0aGUgbnVtYmVyIG9mIHJlcGVhdHNcclxuICAgICAqIGlzIG5vdCBzcGVjaWZpZWQgaXQgd2lsbCByZXBlYXQgZm9yZXZlci4gVGhpcyBtZXRob2QgaXMgcGFydCBvZlxyXG4gICAgICogdGhlIGFjdG9yICdBY3Rpb24nIGZsdWVudCBBUEkgYWxsb3dpbmcgYWN0aW9uIGNoYWluaW5nXHJcbiAgICAgKlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogLy8gTW92ZSB1cCBpbiBhIHppZy16YWcgYnkgcmVwZWF0ZWQgbW92ZUJ5J3NcclxuICAgICAqIGFjdG9yLmFjdGlvbnMucmVwZWF0KHJlcGVhdEN0eCA9PiB7XHJcbiAgICAgKiAgcmVwZWF0Q3R4Lm1vdmVCeSgxMCwgMCwgMTApO1xyXG4gICAgICogIHJlcGVhdEN0eC5tb3ZlQnkoMCwgMTAsIDEwKTtcclxuICAgICAqIH0sIDUpO1xyXG4gICAgICogYGBgXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJlcGVhdEJ1aWxkZXIgVGhlIGJ1aWxkZXIgdG8gc3BlY2lmeSB0aGUgcmVwZWF0YWJsZSBsaXN0IG9mIGFjdGlvbnNcclxuICAgICAqIEBwYXJhbSB0aW1lcyAgVGhlIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgYWxsIHRoZSBwcmV2aW91cyBhY3Rpb25zIGluIHRoZSBhY3Rpb24gcXVldWUuIElmIG5vdGhpbmcgaXMgc3BlY2lmaWVkIHRoZSBhY3Rpb25zXHJcbiAgICAgKiB3aWxsIHJlcGVhdCBmb3JldmVyXHJcbiAgICAgKi9cclxuICAgIHJlcGVhdChyZXBlYXRCdWlsZGVyLCB0aW1lcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgucmVwZWF0KHJlcGVhdEJ1aWxkZXIsIHRpbWVzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgYWN0b3IgdG8gcmVwZWF0IGFsbCBvZiB0aGUgYWN0aW9ucyBidWlsdCBpblxyXG4gICAgICogdGhlIGByZXBlYXRCdWlsZGVyYCBjYWxsYmFjay4gSWYgdGhlIG51bWJlciBvZiByZXBlYXRzXHJcbiAgICAgKiBpcyBub3Qgc3BlY2lmaWVkIGl0IHdpbGwgcmVwZWF0IGZvcmV2ZXIuIFRoaXMgbWV0aG9kIGlzIHBhcnQgb2ZcclxuICAgICAqIHRoZSBhY3RvciAnQWN0aW9uJyBmbHVlbnQgQVBJIGFsbG93aW5nIGFjdGlvbiBjaGFpbmluZ1xyXG4gICAgICpcclxuICAgICAqIGBgYHR5cGVzY3JpcHRcclxuICAgICAqIC8vIE1vdmUgdXAgaW4gYSB6aWctemFnIGJ5IHJlcGVhdGVkIG1vdmVCeSdzXHJcbiAgICAgKiBhY3Rvci5hY3Rpb25zLnJlcGVhdChyZXBlYXRDdHggPT4ge1xyXG4gICAgICogIHJlcGVhdEN0eC5tb3ZlQnkoMTAsIDAsIDEwKTtcclxuICAgICAqICByZXBlYXRDdHgubW92ZUJ5KDAsIDEwLCAxMCk7XHJcbiAgICAgKiB9LCA1KTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXBlYXRCdWlsZGVyIFRoZSBidWlsZGVyIHRvIHNwZWNpZnkgdGhlIHJlcGVhdGFibGUgbGlzdCBvZiBhY3Rpb25zXHJcbiAgICAgKi9cclxuICAgIHJlcGVhdEZvcmV2ZXIocmVwZWF0QnVpbGRlcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgucmVwZWF0Rm9yZXZlcihyZXBlYXRCdWlsZGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSB0aGUgZW50aXR5IHRvIGZvbGxvdyBhbm90aGVyIGF0IGEgc3BlY2lmaWVkIGRpc3RhbmNlXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5ICAgICAgICAgICBUaGUgZW50aXR5IHRvIGZvbGxvd1xyXG4gICAgICogQHBhcmFtIGZvbGxvd0Rpc3RhbmNlICBUaGUgZGlzdGFuY2UgdG8gbWFpbnRhaW4gd2hlbiBmb2xsb3dpbmcsIGlmIG5vdCBzcGVjaWZpZWQgdGhlIGFjdG9yIHdpbGwgZm9sbG93IGF0IHRoZSBjdXJyZW50IGRpc3RhbmNlLlxyXG4gICAgICovXHJcbiAgICBmb2xsb3coZW50aXR5LCBmb2xsb3dEaXN0YW5jZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHguZm9sbG93KGVudGl0eSwgZm9sbG93RGlzdGFuY2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIHRoZSBlbnRpdHkgdG8gbW92ZSB0b3dhcmRzIGFub3RoZXIgdW50aWwgdGhleVxyXG4gICAgICogY29sbGlkZSBcIm1lZXRcIiBhdCBhIHNwZWNpZmllZCBzcGVlZC5cclxuICAgICAqIEBwYXJhbSBlbnRpdHkgIFRoZSBlbnRpdHkgdG8gbWVldFxyXG4gICAgICogQHBhcmFtIHNwZWVkICBUaGUgc3BlZWQgaW4gcGl4ZWxzIHBlciBzZWNvbmQgdG8gbW92ZSwgaWYgbm90IHNwZWNpZmllZCBpdCB3aWxsIG1hdGNoIHRoZSBzcGVlZCBvZiB0aGUgb3RoZXIgYWN0b3JcclxuICAgICAqL1xyXG4gICAgbWVldChlbnRpdHksIHNwZWVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2N0eC5tZWV0KGVudGl0eSwgc3BlZWQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGN1cnJlbnQgYWN0aW9uIHF1ZXVlIHVwIHRvIG5vd1xyXG4gICAgICogaXMgZmluaXNoZWQuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYHRvUHJvbWlzZSgpYCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gICAgICovXHJcbiAgICBhc1Byb21pc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudG9Qcm9taXNlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY3VycmVudCBhY3Rpb24gcXVldWUgdXAgdG8gbm93XHJcbiAgICAgKiBpcyBmaW5pc2hlZC5cclxuICAgICAqL1xyXG4gICAgdG9Qcm9taXNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdHgudG9Qcm9taXNlKCk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rvci50c1xudmFyIEFjdG9yX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFR5cGUgZ3VhcmQgZm9yIGNoZWNraW5nIGlmIHNvbWV0aGluZyBpcyBhbiBBY3RvclxyXG4gKiBAcGFyYW0geFxyXG4gKi9cclxuZnVuY3Rpb24gaXNBY3Rvcih4KSB7XHJcbiAgICByZXR1cm4geCBpbnN0YW5jZW9mIEFjdG9yO1xyXG59XHJcbi8qKlxyXG4gKiBUaGUgbW9zdCBpbXBvcnRhbnQgcHJpbWl0aXZlIGluIEV4Y2FsaWJ1ciBpcyBhbiBgQWN0b3JgLiBBbnl0aGluZyB0aGF0XHJcbiAqIGNhbiBtb3ZlIG9uIHRoZSBzY3JlZW4sIGNvbGxpZGUgd2l0aCBhbm90aGVyIGBBY3RvcmAsIHJlc3BvbmQgdG8gZXZlbnRzLFxyXG4gKiBvciBpbnRlcmFjdCB3aXRoIHRoZSBjdXJyZW50IHNjZW5lLCBtdXN0IGJlIGFuIGFjdG9yLiBBbiBgQWN0b3JgICoqbXVzdCoqXHJcbiAqIGJlIHBhcnQgb2YgYSBbW1NjZW5lXV0gZm9yIGl0IHRvIGJlIGRyYXduIHRvIHRoZSBzY3JlZW4uXHJcbiAqL1xyXG5jbGFzcyBBY3RvciBleHRlbmRzIEVudGl0eSB7XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFuY2hvciB0byBhcHBseSBhbGwgYWN0b3IgcmVsYXRlZCB0cmFuc2Zvcm1hdGlvbnMgbGlrZSByb3RhdGlvbixcclxuICAgICAgICAgKiB0cmFuc2xhdGlvbiwgYW5kIHNjYWxpbmcuIEJ5IGRlZmF1bHQgdGhlIGFuY2hvciBpcyBpbiB0aGUgY2VudGVyIG9mXHJcbiAgICAgICAgICogdGhlIGFjdG9yLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0aGUgY2VudGVyIG9mIHRoZSBhY3RvciAoLjUsIC41KVxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQW4gYW5jaG9yIG9mICguNSwgLjUpIHdpbGwgZW5zdXJlIHRoYXQgZHJhd2luZ3MgYXJlIGNlbnRlcmVkLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogVXNlIGBhbmNob3Iuc2V0VG9gIHRvIHNldCB0aGUgYW5jaG9yIHRvIGEgZGlmZmVyZW50IHBvaW50IHVzaW5nXHJcbiAgICAgICAgICogdmFsdWVzIGJldHdlZW4gMCBhbmQgMS4gRm9yIGV4YW1wbGUsIGFuY2hvcmluZyB0byB0aGUgdG9wLWxlZnQgd291bGQgYmVcclxuICAgICAgICAgKiBgQWN0b3IuYW5jaG9yLnNldFRvKDAsIDApYCBhbmQgdG9wLXJpZ2h0IHdvdWxkIGJlIGBBY3Rvci5hbmNob3Iuc2V0VG8oMCwgMSlgLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuX2FuY2hvciA9IHdhdGNoKFZlY3Rvci5IYWxmLCAodikgPT4gdGhpcy5faGFuZGxlQW5jaG9yQ2hhbmdlKHYpKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb252ZW5pZW5jZSByZWZlcmVuY2UgdG8gdGhlIGdsb2JhbCBsb2dnZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBzY2VuZSB0aGF0IHRoZSBhY3RvciBpcyBpblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2NlbmUgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWNjZXNzIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcgZm9yIHRoZSBhY3RvciwgdGhpcyBjYW4gYmVcclxuICAgICAgICAgKiBhbiBbW0FuaW1hdGlvbl1dLCBbW1Nwcml0ZV1dLCBvciBbW1BvbHlnb25dXS5cclxuICAgICAgICAgKiBTZXQgZHJhd2luZ3Mgd2l0aCBbW3NldERyYXdpbmddXS5cclxuICAgICAgICAgKiBAZGVwcmVjYXRlZFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIERyYWdnYWJsZSBoZWxwZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9kcmFnZ2FibGUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9kcmFnZ2luZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJEcmFnU3RhcnRIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9wb2ludGVyRHJhZ0VuZEhhbmRsZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYWdnaW5nID0gZmFsc2U7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9wb2ludGVyRHJhZ01vdmVIYW5kbGVyID0gKHBlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9kcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBwZS5wb2ludGVyLmxhc3RXb3JsZFBvcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlckRyYWdMZWF2ZUhhbmRsZXIgPSAocGUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYWdnaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBvcyA9IHBlLnBvaW50ZXIubGFzdFdvcmxkUG9zO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBNb2RpZnkgdGhlIGN1cnJlbnQgYWN0b3IgdXBkYXRlIHBpcGVsaW5lLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudHJhaXRzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gZW5hYmxlIHRoZSBbW1RyYWl0cy5DYXB0dXJlUG9pbnRlcl1dIHRyYWl0IHRoYXQgcHJvcGFnYXRlc1xyXG4gICAgICAgICAqIHBvaW50ZXIgZXZlbnRzIHRvIHRoaXMgYWN0b3JcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ29uZmlndXJhdGlvbiBmb3IgW1tUcmFpdHMuQ2FwdHVyZVBvaW50ZXJdXSB0cmFpdFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FwdHVyZVBvaW50ZXIgPSB7XHJcbiAgICAgICAgICAgIGNhcHR1cmVNb3ZlRXZlbnRzOiBmYWxzZSxcclxuICAgICAgICAgICAgY2FwdHVyZURyYWdFdmVudHM6IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyAjcmVnaW9uIEV2ZW50c1xyXG4gICAgICAgIHRoaXMuX2NhcHR1cmVQb2ludGVyRXZlbnRzID0gW1xyXG4gICAgICAgICAgICAncG9pbnRlcnVwJyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJkb3duJyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJtb3ZlJyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJlbnRlcicsXHJcbiAgICAgICAgICAgICdwb2ludGVybGVhdmUnLFxyXG4gICAgICAgICAgICAncG9pbnRlcmRyYWdzdGFydCcsXHJcbiAgICAgICAgICAgICdwb2ludGVyZHJhZ2VuZCcsXHJcbiAgICAgICAgICAgICdwb2ludGVyZHJhZ21vdmUnLFxyXG4gICAgICAgICAgICAncG9pbnRlcmRyYWdlbnRlcicsXHJcbiAgICAgICAgICAgICdwb2ludGVyZHJhZ2xlYXZlJ1xyXG4gICAgICAgIF07XHJcbiAgICAgICAgdGhpcy5fY2FwdHVyZU1vdmVFdmVudHMgPSBbXHJcbiAgICAgICAgICAgICdwb2ludGVybW92ZScsXHJcbiAgICAgICAgICAgICdwb2ludGVyZW50ZXInLFxyXG4gICAgICAgICAgICAncG9pbnRlcmxlYXZlJyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJkcmFnbW92ZScsXHJcbiAgICAgICAgICAgICdwb2ludGVyZHJhZ2VudGVyJyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJkcmFnbGVhdmUnXHJcbiAgICAgICAgXTtcclxuICAgICAgICB0aGlzLl9jYXB0dXJlRHJhZ0V2ZW50cyA9IFtcclxuICAgICAgICAgICAgJ3BvaW50ZXJkcmFnc3RhcnQnLFxyXG4gICAgICAgICAgICAncG9pbnRlcmRyYWdlbmQnLFxyXG4gICAgICAgICAgICAncG9pbnRlcmRyYWdtb3ZlJyxcclxuICAgICAgICAgICAgJ3BvaW50ZXJkcmFnZW50ZXInLFxyXG4gICAgICAgICAgICAncG9pbnRlcmRyYWdsZWF2ZSdcclxuICAgICAgICBdO1xyXG4gICAgICAgIGNvbnN0IHsgbmFtZSwgeCwgeSwgcG9zLCBzY2FsZSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzLCBjb2xsaWRlciwgdmVsLCBhY2MsIHJvdGF0aW9uLCBhbmd1bGFyVmVsb2NpdHksIHosIGNvbG9yLCB2aXNpYmxlLCBhbmNob3IsIGNvbGxpc2lvblR5cGUsIGNvbGxpc2lvbkdyb3VwIH0gPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpO1xyXG4gICAgICAgIHRoaXMuX3NldE5hbWUobmFtZSk7XHJcbiAgICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3IgIT09IG51bGwgJiYgYW5jaG9yICE9PSB2b2lkIDAgPyBhbmNob3IgOiBBY3Rvci5kZWZhdWx0cy5hbmNob3IuY2xvbmUoKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgVHJhbnNmb3JtQ29tcG9uZW50KCkpO1xyXG4gICAgICAgIHRoaXMucG9zID0gcG9zICE9PSBudWxsICYmIHBvcyAhPT0gdm9pZCAwID8gcG9zIDogdmVjKHggIT09IG51bGwgJiYgeCAhPT0gdm9pZCAwID8geCA6IDAsIHkgIT09IG51bGwgJiYgeSAhPT0gdm9pZCAwID8geSA6IDApO1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbiAhPT0gbnVsbCAmJiByb3RhdGlvbiAhPT0gdm9pZCAwID8gcm90YXRpb24gOiAwO1xyXG4gICAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZSAhPT0gbnVsbCAmJiBzY2FsZSAhPT0gdm9pZCAwID8gc2NhbGUgOiB2ZWMoMSwgMSk7XHJcbiAgICAgICAgdGhpcy56ID0geiAhPT0gbnVsbCAmJiB6ICE9PSB2b2lkIDAgPyB6IDogMDtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgR3JhcGhpY3NDb21wb25lbnQoKSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IENhbnZhc0RyYXdDb21wb25lbnQoKGN0eCwgZGVsdGEpID0+IHRoaXMuZHJhdyhjdHgsIGRlbHRhKSkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBNb3Rpb25Db21wb25lbnQoKSk7XHJcbiAgICAgICAgdGhpcy52ZWwgPSB2ZWwgIT09IG51bGwgJiYgdmVsICE9PSB2b2lkIDAgPyB2ZWwgOiBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLmFjYyA9IGFjYyAhPT0gbnVsbCAmJiBhY2MgIT09IHZvaWQgMCA/IGFjYyA6IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIHRoaXMuYW5ndWxhclZlbG9jaXR5ID0gYW5ndWxhclZlbG9jaXR5ICE9PSBudWxsICYmIGFuZ3VsYXJWZWxvY2l0eSAhPT0gdm9pZCAwID8gYW5ndWxhclZlbG9jaXR5IDogMDtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgQWN0aW9uc0NvbXBvbmVudCgpKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgQm9keUNvbXBvbmVudCgpKTtcclxuICAgICAgICB0aGlzLmJvZHkuY29sbGlzaW9uVHlwZSA9IGNvbGxpc2lvblR5cGUgIT09IG51bGwgJiYgY29sbGlzaW9uVHlwZSAhPT0gdm9pZCAwID8gY29sbGlzaW9uVHlwZSA6IENvbGxpc2lvblR5cGUuUGFzc2l2ZTtcclxuICAgICAgICBpZiAoY29sbGlzaW9uR3JvdXApIHtcclxuICAgICAgICAgICAgdGhpcy5ib2R5Lmdyb3VwID0gY29sbGlzaW9uR3JvdXA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2xsaWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgQ29sbGlkZXJDb21wb25lbnQoY29sbGlkZXIpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAocmFkaXVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBDb2xsaWRlckNvbXBvbmVudChTaGFwZS5DaXJjbGUocmFkaXVzLCB0aGlzLmFuY2hvcikpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IENvbGxpZGVyQ29tcG9uZW50KFNoYXBlLkJveCh3aWR0aCwgaGVpZ2h0LCB0aGlzLmFuY2hvcikpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBDb2xsaWRlckNvbXBvbmVudCgpKTsgLy8gbm8gY29sbGlkZXJcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyYXBoaWNzLnZpc2libGUgPSB2aXNpYmxlICE9PSBudWxsICYmIHZpc2libGUgIT09IHZvaWQgMCA/IHZpc2libGUgOiB0cnVlO1xyXG4gICAgICAgIGlmIChjb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XHJcbiAgICAgICAgICAgIGlmICh3aWR0aCAmJiBoZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYWRkKG5ldyBSZWN0YW5nbGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgICAgICAgICB3aWR0aCxcclxuICAgICAgICAgICAgICAgICAgICBoZWlnaHRcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChyYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYWRkKG5ldyBDaXJjbGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvcixcclxuICAgICAgICAgICAgICAgICAgICByYWRpdXNcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBCdWlsZCBkZWZhdWx0IHBpcGVsaW5lXHJcbiAgICAgICAgaWYgKEZsYWdzLmlzRW5hYmxlZChMZWdhY3kuTGVnYWN5RHJhd2luZykpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgb2Zmc2NyZWVuIHRyYWl0IGFmdGVyIGxlZ2FjeSBkcmF3aW5nIHJlbW92ZWRcclxuICAgICAgICAgICAgdGhpcy50cmFpdHMucHVzaChuZXcgT2Zmc2NyZWVuQ3VsbGluZygpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50cmFpdHMucHVzaChuZXcgQ2FwdHVyZVBvaW50ZXIoKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBwaHlzaWNzIGJvZHkgdGhlIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGFjdG9yLiBUaGUgYm9keSBpcyB0aGUgY29udGFpbmVyIGZvciBhbGwgcGh5c2ljYWwgcHJvcGVydGllcywgbGlrZSBwb3NpdGlvbiwgdmVsb2NpdHksXHJcbiAgICAgKiBhY2NlbGVyYXRpb24sIG1hc3MsIGluZXJ0aWEsIGV0Yy5cclxuICAgICAqL1xyXG4gICAgZ2V0IGJvZHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2Nlc3MgdGhlIEFjdG9yJ3MgYnVpbHQgaW4gW1tUcmFuc2Zvcm1Db21wb25lbnRdXVxyXG4gICAgICovXHJcbiAgICBnZXQgdHJhbnNmb3JtKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2Nlc3MgdGhlIEFjdG9yJ3MgYnVpbHQgaW4gW1tNb3Rpb25Db21wb25lbnRdXVxyXG4gICAgICovXHJcbiAgICBnZXQgbW90aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2Nlc3MgdG8gdGhlIEFjdG9yJ3MgYnVpbHQgaW4gW1tHcmFwaGljc0NvbXBvbmVudF1dXHJcbiAgICAgKi9cclxuICAgIGdldCBncmFwaGljcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoR3JhcGhpY3NDb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY2Nlc3MgdG8gdGhlIEFjdG9yJ3MgYnVpbHQgaW4gW1tDb2xsaWRlckNvbXBvbmVudF1dXHJcbiAgICAgKi9cclxuICAgIGdldCBjb2xsaWRlcigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VmdWwgZm9yIHF1aWNrbHkgc2NyaXB0aW5nIGFjdG9yIGJlaGF2aW9yLCBsaWtlIG1vdmluZyB0byBhIHBsYWNlLCBwYXRyb2xpbmcgYmFjayBhbmQgZm9ydGgsIGJsaW5raW5nLCBldGMuXHJcbiAgICAgKlxyXG4gICAgICogIEFjY2VzcyB0byB0aGUgQWN0b3IncyBidWlsdCBpbiBbW0FjdGlvbnNDb21wb25lbnRdXSB3aGljaCBmb3J3YXJkcyB0byB0aGVcclxuICAgICAqIFtbQWN0aW9uQ29udGV4dHxBY3Rpb24gY29udGV4dF1dIG9mIHRoZSBhY3Rvci5cclxuICAgICAqL1xyXG4gICAgZ2V0IGFjdGlvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KEFjdGlvbnNDb21wb25lbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBwb3NpdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVsc1xyXG4gICAgICovXHJcbiAgICBnZXQgcG9zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybS5wb3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHBvc2l0aW9uIHZlY3RvciBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzXHJcbiAgICAgKi9cclxuICAgIHNldCBwb3ModGhlUG9zKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9zID0gdGhlUG9zLmNsb25lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHBvc2l0aW9uIHZlY3RvciBvZiB0aGUgYWN0b3IgZnJvbSB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBnZXQgb2xkUG9zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmJvZHkub2xkUG9zO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBwb3NpdGlvbiB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHRoZSBsYXN0IGZyYW1lXHJcbiAgICAgKi9cclxuICAgIHNldCBvbGRQb3ModGhlUG9zKSB7XHJcbiAgICAgICAgdGhpcy5ib2R5Lm9sZFBvcy5zZXRUbyh0aGVQb3MueCwgdGhlUG9zLnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNcclxuICAgICAqL1xyXG4gICAgZ2V0IHZlbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb3Rpb24udmVsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSB2ZWxvY2l0eSB2ZWN0b3Igb2YgdGhlIGFjdG9yIGluIHBpeGVscy9zZWNcclxuICAgICAqL1xyXG4gICAgc2V0IHZlbCh0aGVWZWwpIHtcclxuICAgICAgICB0aGlzLm1vdGlvbi52ZWwgPSB0aGVWZWwuY2xvbmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgdmVsb2NpdHkgdmVjdG9yIG9mIHRoZSBhY3RvciBmcm9tIHRoZSBsYXN0IGZyYW1lXHJcbiAgICAgKi9cclxuICAgIGdldCBvbGRWZWwoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5vbGRWZWw7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIHZlbG9jaXR5IHZlY3RvciBvZiB0aGUgYWN0b3IgZnJvbSB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBzZXQgb2xkVmVsKHRoZVZlbCkge1xyXG4gICAgICAgIHRoaXMuYm9keS5vbGRWZWwuc2V0VG8odGhlVmVsLngsIHRoZVZlbC55KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYWNjZWxlcmF0aW9uIHZlY3RvciBvZiB0aGUgYWN0b3IgaW4gcGl4ZWxzL3NlY29uZC9zZWNvbmQuIEFuIGFjY2VsZXJhdGlvbiBwb2ludGluZyBkb3duIHN1Y2ggYXMgKDAsIDEwMCkgbWF5IGJlXHJcbiAgICAgKiB1c2VmdWwgdG8gc2ltdWxhdGUgYSBncmF2aXRhdGlvbmFsIGVmZmVjdC5cclxuICAgICAqL1xyXG4gICAgZ2V0IGFjYygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb3Rpb24uYWNjO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBhY2NlbGVyYXRpb24gdmVjdG9yIG9mIHRlaCBhY3RvciBpbiBwaXhlbHMvc2Vjb25kL3NlY29uZFxyXG4gICAgICovXHJcbiAgICBzZXQgYWNjKHRoZUFjYykge1xyXG4gICAgICAgIHRoaXMubW90aW9uLmFjYyA9IHRoZUFjYy5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBhY2NlbGVyYXRpb24gb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWUuIFRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgZ2xvYmFsIGFjYyBbW1BoeXNpY3MuYWNjXV0uXHJcbiAgICAgKi9cclxuICAgIHNldCBvbGRBY2ModGhlQWNjKSB7XHJcbiAgICAgICAgdGhpcy5ib2R5Lm9sZEFjYy5zZXRUbyh0aGVBY2MueCwgdGhlQWNjLnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBhY2NlbGVyYXRpb24gb2YgdGhlIGFjdG9yIGZyb20gdGhlIGxhc3QgZnJhbWUuIFRoaXMgZG9lcyBub3QgaW5jbHVkZSB0aGUgZ2xvYmFsIGFjYyBbW1BoeXNpY3MuYWNjXV0uXHJcbiAgICAgKi9cclxuICAgIGdldCBvbGRBY2MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYm9keS5vbGRBY2M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIHJvdGF0aW9uIG9mIHRoZSBhY3RvciBpbiByYWRpYW5zLiAxIHJhZGlhbiA9IDE4MC9QSSBEZWdyZWVzLlxyXG4gICAgICovXHJcbiAgICBnZXQgcm90YXRpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSByb3RhdGlvbiBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy4gMSByYWRpYW4gPSAxODAvUEkgRGVncmVlcy5cclxuICAgICAqL1xyXG4gICAgc2V0IHJvdGF0aW9uKHRoZUFuZ2xlKSB7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24gPSB0aGVBbmdsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgcm90YXRpb25hbCB2ZWxvY2l0eSBvZiB0aGUgYWN0b3IgaW4gcmFkaWFucy9zZWNvbmRcclxuICAgICAqL1xyXG4gICAgZ2V0IGFuZ3VsYXJWZWxvY2l0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5tb3Rpb24uYW5ndWxhclZlbG9jaXR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSByb3RhdGlvbmFsIHZlbG9jaXR5IG9mIHRoZSBhY3RvciBpbiByYWRpYW5zL3NlY1xyXG4gICAgICovXHJcbiAgICBzZXQgYW5ndWxhclZlbG9jaXR5KGFuZ3VsYXJWZWxvY2l0eSkge1xyXG4gICAgICAgIHRoaXMubW90aW9uLmFuZ3VsYXJWZWxvY2l0eSA9IGFuZ3VsYXJWZWxvY2l0eTtcclxuICAgIH1cclxuICAgIGdldCBzY2FsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS5zY2FsZTtcclxuICAgIH1cclxuICAgIHNldCBzY2FsZShzY2FsZSkge1xyXG4gICAgICAgIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkuc2NhbGUgPSBzY2FsZTtcclxuICAgIH1cclxuICAgIGdldCBhbmNob3IoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuY2hvcjtcclxuICAgIH1cclxuICAgIHNldCBhbmNob3IodmVjKSB7XHJcbiAgICAgICAgdGhpcy5fYW5jaG9yID0gd2F0Y2godmVjLCAodikgPT4gdGhpcy5faGFuZGxlQW5jaG9yQ2hhbmdlKHYpKTtcclxuICAgICAgICB0aGlzLl9oYW5kbGVBbmNob3JDaGFuZ2UodmVjKTtcclxuICAgIH1cclxuICAgIF9oYW5kbGVBbmNob3JDaGFuZ2Uodikge1xyXG4gICAgICAgIGlmICh0aGlzLmdyYXBoaWNzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuYW5jaG9yID0gdjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBhY3RvciBpcyBwaHlzaWNhbGx5IGluIHRoZSB2aWV3cG9ydFxyXG4gICAgICovXHJcbiAgICBnZXQgaXNPZmZTY3JlZW4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzVGFnKCdvZmZzY3JlZW4nKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHZpc2liaWxpdHkgb2YgYW4gYWN0b3JcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW0dyYXBoaWNzQ29tcG9uZW50LnZpc2libGV8QWN0b3IuZ3JhcGhpY3MudmlzaWJsZV1dLCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gICAgICovXHJcbiAgICBnZXQgdmlzaWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5ncmFwaGljcy52aXNpYmxlO1xyXG4gICAgfVxyXG4gICAgc2V0IHZpc2libGUoaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgdGhpcy5ncmFwaGljcy52aXNpYmxlID0gaXNWaXNpYmxlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgb3BhY2l0eSBvZiBhbiBhY3Rvci5cclxuICAgICAqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBBY3Rvci5vcGFjaXR5IHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wLCB1c2UgW1tHcmFwaGljc0NvbXBvbmVudC5vcGFjaXR5fEFjdG9yLmdyYXBoaWNzLm9wYWNpdHldXS5cclxuICAgICAqL1xyXG4gICAgZ2V0IG9wYWNpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGhpY3Mub3BhY2l0eTtcclxuICAgIH1cclxuICAgIHNldCBvcGFjaXR5KG9wYWNpdHkpIHtcclxuICAgICAgICB0aGlzLmdyYXBoaWNzLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgZ2V0IGRyYWdnYWJsZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZHJhZ2dhYmxlO1xyXG4gICAgfVxyXG4gICAgc2V0IGRyYWdnYWJsZShpc0RyYWdnYWJsZSkge1xyXG4gICAgICAgIGlmIChpc0RyYWdnYWJsZSkge1xyXG4gICAgICAgICAgICBpZiAoaXNEcmFnZ2FibGUgJiYgIXRoaXMuX2RyYWdnYWJsZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbigncG9pbnRlcmRyYWdzdGFydCcsIHRoaXMuX3BvaW50ZXJEcmFnU3RhcnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub24oJ3BvaW50ZXJkcmFnZW5kJywgdGhpcy5fcG9pbnRlckRyYWdFbmRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub24oJ3BvaW50ZXJkcmFnbW92ZScsIHRoaXMuX3BvaW50ZXJEcmFnTW92ZUhhbmRsZXIpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5vbigncG9pbnRlcmRyYWdsZWF2ZScsIHRoaXMuX3BvaW50ZXJEcmFnTGVhdmVIYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICghaXNEcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZigncG9pbnRlcmRyYWdzdGFydCcsIHRoaXMuX3BvaW50ZXJEcmFnU3RhcnRIYW5kbGVyKTtcclxuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdwb2ludGVyZHJhZ2VuZCcsIHRoaXMuX3BvaW50ZXJEcmFnRW5kSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZigncG9pbnRlcmRyYWdtb3ZlJywgdGhpcy5fcG9pbnRlckRyYWdNb3ZlSGFuZGxlcik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9mZigncG9pbnRlcmRyYWdsZWF2ZScsIHRoaXMuX3BvaW50ZXJEcmFnTGVhdmVIYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9kcmFnZ2FibGUgPSBpc0RyYWdnYWJsZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNvbG9yIG9mIHRoZSBhY3Rvci4gQSByZWN0YW5nbGUgb2YgdGhpcyBjb2xvciB3aWxsIGJlXHJcbiAgICAgKiBkcmF3biBpZiBubyBbW0RyYXdhYmxlXV0gaXMgc3BlY2lmaWVkIGFzIHRoZSBhY3RvcnMgZHJhd2luZy5cclxuICAgICAqXHJcbiAgICAgKiBUaGUgZGVmYXVsdCBpcyBgbnVsbGAgd2hpY2ggcHJldmVudHMgYSByZWN0YW5nbGUgZnJvbSBiZWluZyBkcmF3bi5cclxuICAgICAqL1xyXG4gICAgZ2V0IGNvbG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jb2xvcjtcclxuICAgIH1cclxuICAgIHNldCBjb2xvcih2KSB7XHJcbiAgICAgICAgdGhpcy5fY29sb3IgPSB2LmNsb25lKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIGBvbkluaXRpYWxpemVgIGlzIGNhbGxlZCBiZWZvcmUgdGhlIGZpcnN0IHVwZGF0ZSBvZiB0aGUgYWN0b3IuIFRoaXMgbWV0aG9kIGlzIG1lYW50IHRvIGJlXHJcbiAgICAgKiBvdmVycmlkZGVuLiBUaGlzIGlzIHdoZXJlIGluaXRpYWxpemF0aW9uIG9mIGNoaWxkIGFjdG9ycyBzaG91bGQgdGFrZSBwbGFjZS5cclxuICAgICAqXHJcbiAgICAgKiBTeW5vbnltb3VzIHdpdGggdGhlIGV2ZW50IGhhbmRsZXIgYC5vbignaW5pdGlhbGl6ZScsIChldnQpID0+IHsuLi59KWBcclxuICAgICAqL1xyXG4gICAgb25Jbml0aWFsaXplKF9lbmdpbmUpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyB0aGlzIGFjdG9yIGFuZCBhbGwgaXQncyBjaGlsZCBhY3RvcnMsIG1lYW50IHRvIGJlIGNhbGxlZCBieSB0aGUgU2NlbmUgYmVmb3JlIGZpcnN0IHVwZGF0ZSBub3QgYnkgdXNlcnMgb2YgRXhjYWxpYnVyLlxyXG4gICAgICpcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9pbml0aWFsaXplKGVuZ2luZSkge1xyXG4gICAgICAgIHN1cGVyLl9pbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiB0aGlzLmNoaWxkcmVuKSB7XHJcbiAgICAgICAgICAgIGNoaWxkLl9pbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NoZWNrRm9yUG9pbnRlck9wdEluKGV2ZW50TmFtZSkge1xyXG4gICAgICAgIGlmIChldmVudE5hbWUpIHtcclxuICAgICAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2FwdHVyZVBvaW50ZXJFdmVudHMuaW5kZXhPZihub3JtYWxpemVkKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlQ2FwdHVyZVBvaW50ZXIgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NhcHR1cmVNb3ZlRXZlbnRzLmluZGV4T2Yobm9ybWFsaXplZCkgIT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlUG9pbnRlci5jYXB0dXJlTW92ZUV2ZW50cyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FwdHVyZURyYWdFdmVudHMuaW5kZXhPZihub3JtYWxpemVkKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVEcmFnRXZlbnRzID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuX2NoZWNrRm9yUG9pbnRlck9wdEluKGV2ZW50TmFtZSk7XHJcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9uY2UoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JQb2ludGVyT3B0SW4oZXZlbnROYW1lKTtcclxuICAgICAgICBzdXBlci5vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBvZmYoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3ByZWtpbGwgaGFuZGxlciBmb3IgW1tvblByZUtpbGxdXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcHJla2lsbChfc2NlbmUpIHtcclxuICAgICAgICBzdXBlci5lbWl0KCdwcmVraWxsJywgbmV3IFByZUtpbGxFdmVudCh0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblByZUtpbGwoX3NjZW5lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblByZUtpbGwgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwcmVraWxsJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUHJlS2lsbGAgaXMgY2FsbGVkIGRpcmVjdGx5IGJlZm9yZSBhbiBhY3RvciBpcyBraWxsZWQgYW5kIHJlbW92ZWQgZnJvbSBpdHMgY3VycmVudCBbW1NjZW5lXV0uXHJcbiAgICAgKi9cclxuICAgIG9uUHJlS2lsbChfc2NlbmUpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wcmVraWxsIGhhbmRsZXIgZm9yIFtbb25Qb3N0S2lsbF1dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wb3N0a2lsbChfc2NlbmUpIHtcclxuICAgICAgICBzdXBlci5lbWl0KCdwb3N0a2lsbCcsIG5ldyBQb3N0S2lsbEV2ZW50KHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUG9zdEtpbGwoX3NjZW5lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblBvc3RLaWxsIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncG9zdGtpbGwnLCAoZXZ0KSA9PiB7Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUG9zdEtpbGxgIGlzIGNhbGxlZCBkaXJlY3RseSBhZnRlciBhbiBhY3RvciBpcyBraWxsZWQgYW5kIHJlbW92ZSBmcm9tIGl0cyBjdXJyZW50IFtbU2NlbmVdXS5cclxuICAgICAqL1xyXG4gICAgb25Qb3N0S2lsbChfc2NlbmUpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB0aGUgY3VycmVudCBhY3RvciBpcyBhIG1lbWJlciBvZiB0aGUgc2NlbmUsIHRoaXMgd2lsbCByZW1vdmVcclxuICAgICAqIGl0IGZyb20gdGhlIHNjZW5lIGdyYXBoLiBJdCB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBraWxsKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnNjZW5lKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZWtpbGwodGhpcy5zY2VuZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgna2lsbCcsIG5ldyBLaWxsRXZlbnQodGhpcykpO1xyXG4gICAgICAgICAgICBzdXBlci5raWxsKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Bvc3RraWxsKHRoaXMuc2NlbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignQ2Fubm90IGtpbGwgYWN0b3IsIGl0IHdhcyBuZXZlciBhZGRlZCB0byB0aGUgU2NlbmUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBjdXJyZW50IGFjdG9yIGlzIGtpbGxlZCwgaXQgd2lsbCBub3cgbm90IGJlIGtpbGxlZC5cclxuICAgICAqL1xyXG4gICAgdW5raWxsKCkge1xyXG4gICAgICAgIHRoaXMuYWN0aXZlID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHdldGhlciB0aGUgYWN0b3IgaGFzIGJlZW4ga2lsbGVkLlxyXG4gICAgICovXHJcbiAgICBpc0tpbGxlZCgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuYWN0aXZlO1xyXG4gICAgfVxyXG4gICAgc2V0RHJhd2luZyhrZXkpIHtcclxuICAgICAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcclxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhd2luZyAhPT0gdGhpcy5mcmFtZXNba2V5XSkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5mcmFtZXNba2V5XSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmZyYW1lc1trZXldLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nID0gdGhpcy5mcmFtZXNba2V5XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKGB0aGUgc3BlY2lmaWVkIGRyYXdpbmcga2V5ICR7a2V5fSBkb2VzIG5vdCBleGlzdGApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmF3aW5nICYmIHRoaXMuY3VycmVudERyYXdpbmcgaW5zdGFuY2VvZiBBbmltYXRpb25fQW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudERyYXdpbmcudGljaygwKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGREcmF3aW5nKCkge1xyXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZnJhbWVzW2FyZ3VtZW50c1swXV0gPSBhcmd1bWVudHNbMV07XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50RHJhd2luZykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhd2luZyA9IGFyZ3VtZW50c1sxXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFNwcml0ZV9TcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRHJhd2luZygnZGVmYXVsdCcsIGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSBpbnN0YW5jZW9mIFRleHR1cmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRHJhd2luZygnZGVmYXVsdCcsIGFyZ3VtZW50c1swXS5hc1Nwcml0ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgei1pbmRleCBvZiBhbiBhY3Rvci4gVGhlIHotaW5kZXggZGV0ZXJtaW5lcyB0aGUgcmVsYXRpdmUgb3JkZXIgYW4gYWN0b3IgaXMgZHJhd24gaW4uXHJcbiAgICAgKiBBY3RvcnMgd2l0aCBhIGhpZ2hlciB6LWluZGV4IGFyZSBkcmF3biBvbiB0b3Agb2YgYWN0b3JzIHdpdGggYSBsb3dlciB6LWluZGV4XHJcbiAgICAgKi9cclxuICAgIGdldCB6KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLno7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW0FjdG9yLnpdXVxyXG4gICAgICovXHJcbiAgICBnZXRaSW5kZXgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkuejtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgei1pbmRleCBvZiBhbiBhY3RvciBhbmQgdXBkYXRlcyBpdCBpbiB0aGUgZHJhd2luZyBsaXN0IGZvciB0aGUgc2NlbmUuXHJcbiAgICAgKiBUaGUgei1pbmRleCBkZXRlcm1pbmVzIHRoZSByZWxhdGl2ZSBvcmRlciBhbiBhY3RvciBpcyBkcmF3biBpbi5cclxuICAgICAqIEFjdG9ycyB3aXRoIGEgaGlnaGVyIHotaW5kZXggYXJlIGRyYXduIG9uIHRvcCBvZiBhY3RvcnMgd2l0aCBhIGxvd2VyIHotaW5kZXhcclxuICAgICAqIEBwYXJhbSBuZXdaIG5ldyB6LWluZGV4IHRvIGFzc2lnblxyXG4gICAgICovXHJcbiAgICBzZXQgeihuZXdaKSB7XHJcbiAgICAgICAgdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS56ID0gbmV3WjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIG5ld0luZGV4IG5ldyB6LWluZGV4IHRvIGFzc2lnblxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbQWN0b3Iuel1dXHJcbiAgICAgKi9cclxuICAgIHNldFpJbmRleChuZXdJbmRleCkge1xyXG4gICAgICAgIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkueiA9IG5ld0luZGV4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGNlbnRlciBwb2ludCBvZiBhbiBhY3RvclxyXG4gICAgICovXHJcbiAgICBnZXQgY2VudGVyKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgVmVjdG9yKHRoaXMucG9zLnggKyB0aGlzLndpZHRoIC8gMiAtIHRoaXMuYW5jaG9yLnggKiB0aGlzLndpZHRoLCB0aGlzLnBvcy55ICsgdGhpcy5oZWlnaHQgLyAyIC0gdGhpcy5hbmNob3IueSAqIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlci5sb2NhbEJvdW5kcy53aWR0aCAqIHRoaXMuZ2V0R2xvYmFsU2NhbGUoKS54O1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsaWRlci5sb2NhbEJvdW5kcy5oZWlnaHQgKiB0aGlzLmdldEdsb2JhbFNjYWxlKCkueTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGlzIGFjdG9yJ3Mgcm90YXRpb24gdGFraW5nIGludG8gYWNjb3VudCBhbnkgcGFyZW50IHJlbGF0aW9uc2hpcHNcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBSb3RhdGlvbiBhbmdsZSBpbiByYWRpYW5zXHJcbiAgICAgKi9cclxuICAgIGdldEdsb2JhbFJvdGF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLmdsb2JhbFJvdGF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGFuIGFjdG9yJ3Mgd29ybGQgcG9zaXRpb24gdGFraW5nIGludG8gYWNjb3VudCBwYXJlbnQgcmVsYXRpb25zaGlwcywgc2NhbGluZywgcm90YXRpb24sIGFuZCB0cmFuc2xhdGlvblxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFBvc2l0aW9uIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGdldEdsb2JhbFBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS5nbG9iYWxQb3M7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGdsb2JhbCBzY2FsZSBvZiB0aGUgQWN0b3JcclxuICAgICAqL1xyXG4gICAgZ2V0R2xvYmFsU2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkuZ2xvYmFsU2NhbGU7XHJcbiAgICB9XHJcbiAgICAvLyAjcmVnaW9uIENvbGxpc2lvblxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyB3aGV0aGVyIHRoZSB4L3kgc3BlY2lmaWVkIGFyZSBjb250YWluZWQgaW4gdGhlIGFjdG9yXHJcbiAgICAgKiBAcGFyYW0geCAgWCBjb29yZGluYXRlIHRvIHRlc3QgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxyXG4gICAgICogQHBhcmFtIHkgIFkgY29vcmRpbmF0ZSB0byB0ZXN0IChpbiB3b3JsZCBjb29yZGluYXRlcylcclxuICAgICAqIEBwYXJhbSByZWN1cnNlIGNoZWNrcyB3aGV0aGVyIHRoZSB4L3kgYXJlIGNvbnRhaW5lZCBpbiBhbnkgY2hpbGQgYWN0b3JzIChpZiB0aGV5IGV4aXN0KS5cclxuICAgICAqL1xyXG4gICAgY29udGFpbnMoeCwgeSwgcmVjdXJzZSA9IGZhbHNlKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnQgPSB2ZWMoeCwgeSk7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXIgPSB0aGlzLmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgY29sbGlkZXIudXBkYXRlKCk7XHJcbiAgICAgICAgY29uc3QgZ2VvbSA9IGNvbGxpZGVyLmdldCgpO1xyXG4gICAgICAgIGlmICghZ2VvbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNvbnRhaW5tZW50ID0gZ2VvbS5jb250YWlucyhwb2ludCk7XHJcbiAgICAgICAgaWYgKHJlY3Vyc2UpIHtcclxuICAgICAgICAgICAgcmV0dXJuIChjb250YWlubWVudCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zb21lKChjaGlsZCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5jb250YWlucyh4LCB5LCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5tZW50O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBhY3Rvci5jb2xsaWRlcidzIHN1cmZhY2VzIGFyZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIGRpc3RhbmNlIHNwZWNpZmllZCBmcm9tIGVhY2ggb3RoZXJcclxuICAgICAqIEBwYXJhbSBhY3RvciAgICAgQWN0b3IgdG8gdGVzdFxyXG4gICAgICogQHBhcmFtIGRpc3RhbmNlICBEaXN0YW5jZSBpbiBwaXhlbHMgdG8gdGVzdFxyXG4gICAgICovXHJcbiAgICB3aXRoaW4oYWN0b3IsIGRpc3RhbmNlKSB7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXIgPSB0aGlzLmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uc3Qgb3RoZXJDb2xsaWRlciA9IGFjdG9yLmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uc3QgbWUgPSBjb2xsaWRlci5nZXQoKTtcclxuICAgICAgICBjb25zdCBvdGhlciA9IG90aGVyQ29sbGlkZXIuZ2V0KCk7XHJcbiAgICAgICAgaWYgKG1lICYmIG90aGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZS5nZXRDbG9zZXN0TGluZUJldHdlZW4ob3RoZXIpLmdldExlbmd0aCgpIDw9IGRpc3RhbmNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvLyAjZW5kcmVnaW9uXHJcbiAgICAvLyAjcmVnaW9uIFVwZGF0ZVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYnkgdGhlIEVuZ2luZSwgdXBkYXRlcyB0aGUgc3RhdGUgb2YgdGhlIGFjdG9yXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqIEBwYXJhbSBlbmdpbmUgVGhlIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBnYW1lIGVuZ2luZVxyXG4gICAgICogQHBhcmFtIGRlbHRhICBUaGUgdGltZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZSBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICAgICAgdGhpcy5fcHJldXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgIC8vIFRpY2sgYW5pbWF0aW9uc1xyXG4gICAgICAgIGNvbnN0IGRyYXdpbmcgPSB0aGlzLmN1cnJlbnREcmF3aW5nO1xyXG4gICAgICAgIGlmIChkcmF3aW5nICYmIGRyYXdpbmcgaW5zdGFuY2VvZiBBbmltYXRpb25fQW5pbWF0aW9uKSB7XHJcbiAgICAgICAgICAgIGRyYXdpbmcudGljayhkZWx0YSwgZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5pZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSBhY3RvciBwaXBlbGluZSAobW92ZW1lbnQsIGNvbGxpc2lvbiBkZXRlY3Rpb24sIGV2ZW50IHByb3BhZ2F0aW9uLCBvZmZzY3JlZW4gY3VsbGluZylcclxuICAgICAgICBmb3IgKGNvbnN0IHRyYWl0IG9mIHRoaXMudHJhaXRzKSB7XHJcbiAgICAgICAgICAgIHRyYWl0LnVwZGF0ZSh0aGlzLCBlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcG9zdHVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblByZVVwZGF0ZSBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3ByZXVwZGF0ZScsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblByZVVwZGF0ZWAgaXMgY2FsbGVkIGRpcmVjdGx5IGJlZm9yZSBhbiBhY3RvciBpcyB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBvblByZVVwZGF0ZShfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUG9zdFVwZGF0ZSBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3Bvc3R1cGRhdGUnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25Qb3N0VXBkYXRlYCBpcyBjYWxsZWQgZGlyZWN0bHkgYWZ0ZXIgYW4gYWN0b3IgaXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgb25Qb3N0VXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3ByZXVwZGF0ZSBoYW5kbGVyIGZvciBbW29uUHJlVXBkYXRlXV0gbGlmZWN5Y2xlIGV2ZW50XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3ByZXVwZGF0ZShlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmV1cGRhdGUnLCBuZXcgUHJlVXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25QcmVVcGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3ByZXVwZGF0ZSBoYW5kbGVyIGZvciBbW29uUG9zdFVwZGF0ZV1dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wb3N0dXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3Bvc3R1cGRhdGUnLCBuZXcgUHJlVXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25Qb3N0VXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLy8gZW5kcmVnaW9uXHJcbiAgICAvLyAjcmVnaW9uIERyYXdpbmdcclxuICAgIC8qKlxyXG4gICAgICogQ2FsbGVkIGJ5IHRoZSBFbmdpbmUsIGRyYXdzIHRoZSBhY3RvciB0byB0aGUgc2NyZWVuXHJcbiAgICAgKiBAcGFyYW0gY3R4ICAgVGhlIHJlbmRlcmluZyBjb250ZXh0XHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgVGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgZHJhdyBpbiBtaWxsaXNlY29uZHNcclxuICAgICAqXHJcbiAgICAgKiAqKldhcm5pbmcqKiBvbmx5IHdvcmtzIHdpdGggRmxhZ3MudXNlTGVnYWN5RHJhd2luZygpIGVuYWJsZWRcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBBY3Rvci5ncmFwaGljcywgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICAgICAqL1xyXG4gICAgZHJhdyhjdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIC8vIHRyYW5zbGF0ZSBjYW52YXMgYnkgYW5jaG9yIG9mZnNldFxyXG4gICAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYXdpbmcpIHtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgtKHRoaXMud2lkdGggKiB0aGlzLmFuY2hvci54KSwgLSh0aGlzLmhlaWdodCAqIHRoaXMuYW5jaG9yLnkpKTtcclxuICAgICAgICAgICAgdGhpcy5fcHJlZHJhdyhjdHgsIGRlbHRhKTtcclxuICAgICAgICAgICAgY29uc3QgZHJhd2luZyA9IHRoaXMuY3VycmVudERyYXdpbmc7XHJcbiAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyL3B1bGwvNjE5IGZvciBkaXNjdXNzaW9uIG9uIHRoaXMgZm9ybXVsYVxyXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRYID0gKHRoaXMud2lkdGggLSBkcmF3aW5nLndpZHRoICogZHJhd2luZy5zY2FsZS54KSAqIHRoaXMuYW5jaG9yLng7XHJcbiAgICAgICAgICAgIGNvbnN0IG9mZnNldFkgPSAodGhpcy5oZWlnaHQgLSBkcmF3aW5nLmhlaWdodCAqIGRyYXdpbmcuc2NhbGUueSkgKiB0aGlzLmFuY2hvci55O1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREcmF3aW5nLmRyYXcoeyBjdHgsIHg6IG9mZnNldFgsIHk6IG9mZnNldFksIG9wYWNpdHk6IHRoaXMuZ3JhcGhpY3Mub3BhY2l0eSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ByZWRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbG9yICYmIHRoaXMuY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgIC8vIHVwZGF0ZSBjb2xsaWRlciBnZW9tZXRyeSBiYXNlZCBvbiB0cmFuc2Zvcm1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyID0gdGhpcy5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXIudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sbGlkZXIgJiYgIWNvbGxpZGVyLmJvdW5kcy5oYXNaZXJvRGltZW5zaW9ucygpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29sbGlkZXJzIGFyZSBhbHJlYWR5IHNoaWZ0ZWQgYnkgYW5jaG9yLCB1bnNoaWZ0XHJcbiAgICAgICAgICAgICAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5ncmFwaGljcy5vcGFjaXR5O1xyXG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGNvbGxpZGVyLmdldCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZHJhdyhjdHgsIHRoaXMuY29sb3IsIHZlYygwLCAwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB0aGlzLl9wb3N0ZHJhdyhjdHgsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblByZURyYXcgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwcmVkcmF3JywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUHJlRHJhd2AgaXMgY2FsbGVkIGRpcmVjdGx5IGJlZm9yZSBhbiBhY3RvciBpcyBkcmF3biwgYnV0IGFmdGVyIGxvY2FsIHRyYW5zZm9ybXMgYXJlIG1hZGUuXHJcbiAgICAgKlxyXG4gICAgICogKipXYXJuaW5nKiogb25seSB3b3JrcyB3aXRoIEZsYWdzLnVzZUxlZ2FjeURyYXdpbmcoKSBlbmFibGVkXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgQWN0b3IuZ3JhcGhpY3Mub25Qb3N0RHJhdywgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICAgICAqL1xyXG4gICAgb25QcmVEcmF3KF9jdHgsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25Qb3N0RHJhdyBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3Bvc3RkcmF3JywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUG9zdERyYXdgIGlzIGNhbGxlZCBkaXJlY3RseSBhZnRlciBhbiBhY3RvciBpcyBkcmF3biwgYW5kIGJlZm9yZSBsb2NhbCB0cmFuc2Zvcm1zIGFyZSByZW1vdmVkLlxyXG4gICAgICpcclxuICAgICAqICoqV2FybmluZyoqIG9ubHkgd29ya3Mgd2l0aCBGbGFncy51c2VMZWdhY3lEcmF3aW5nKCkgZW5hYmxlZFxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIEFjdG9yLmdyYXBoaWNzLm9uUG9zdERyYXcsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAgICAgKi9cclxuICAgIG9uUG9zdERyYXcoX2N0eCwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSXQgaXMgbm90IHJlY29tbWVuZGVkIHRoYXQgaW50ZXJuYWwgZXhjYWxpYnVyIG1ldGhvZHMgYmUgb3ZlcnJpZGRlbiwgZG8gc28gYXQgeW91ciBvd24gcmlzay5cclxuICAgICAqXHJcbiAgICAgKiBJbnRlcm5hbCBfcHJlZHJhdyBoYW5kbGVyIGZvciBbW29uUHJlRHJhd11dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICpcclxuICAgICAqICoqV2FybmluZyoqIG9ubHkgd29ya3Mgd2l0aCBGbGFncy51c2VMZWdhY3lEcmF3aW5nKCkgZW5hYmxlZFxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIEFjdG9yLmdyYXBoaWNzLm9uUHJlRHJhdywgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcHJlZHJhdyhjdHgsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVkcmF3JywgbmV3IFByZURyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblByZURyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3Bvc3RkcmF3IGhhbmRsZXIgZm9yIFtbb25Qb3N0RHJhd11dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICpcclxuICAgICAqICoqV2FybmluZyoqIG9ubHkgd29ya3Mgd2l0aCBGbGFncy51c2VMZWdhY3lEcmF3aW5nKCkgZW5hYmxlZFxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIEFjdG9yLmdyYXBoaWNzLm9uUG9zdERyYXcsIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3Bvc3RkcmF3KGN0eCwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3Bvc3RkcmF3JywgbmV3IFByZURyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblBvc3REcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYWxsZWQgYnkgdGhlIEVuZ2luZSwgZHJhd3MgdGhlIGFjdG9ycyBkZWJ1Z2dpbmcgdG8gdGhlIHNjcmVlblxyXG4gICAgICogQHBhcmFtIGN0eCBUaGUgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAqXHJcbiAgICAgKlxyXG4gICAgICogKipXYXJuaW5nKiogb25seSB3b3JrcyB3aXRoIEZsYWdzLnVzZUxlZ2FjeURyYXdpbmcoKSBlbmFibGVkXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgQWN0b3IuZ3JhcGhpY3Mub25Qb3N0RHJhdywgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgZGVidWdEcmF3KF9jdHgpIHtcclxuICAgICAgICAvLyBwYXNzXHJcbiAgICB9XHJcbn1cclxuLy8gI3JlZ2lvbiBQcm9wZXJ0aWVzXHJcbi8qKlxyXG4gKiBTZXQgZGVmYXVsdHMgZm9yIGFsbCBBY3RvcnNcclxuICovXHJcbkFjdG9yLmRlZmF1bHRzID0ge1xyXG4gICAgYW5jaG9yOiBWZWN0b3IuSGFsZlxyXG59O1xyXG5BY3Rvcl9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7IG1lc3NhZ2U6ICdBY3Rvci52aXNpYmxlIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJywgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIEFjdG9yLmdyYXBoaWNzLnZpc2libGUnIH0pXHJcbl0sIEFjdG9yLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIG51bGwpO1xyXG5BY3Rvcl9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0FjdG9yLm9wYWNpdHkgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBBY3Rvci5ncmFwaGljcy5vcGFjaXR5J1xyXG4gICAgfSlcclxuXSwgQWN0b3IucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgbnVsbCk7XHJcbkFjdG9yX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnQWN0b3Iuc2V0RHJhd2luZyB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIEFjdG9yLmdyYXBoaWNzLnNob3coKSBvciBBY3Rvci5ncmFwaGljcy51c2UoKSdcclxuICAgIH0pXHJcbl0sIEFjdG9yLnByb3RvdHlwZSwgXCJzZXREcmF3aW5nXCIsIG51bGwpO1xyXG5BY3Rvcl9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0FjdG9yLmFkZERyYXdpbmcgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBBY3Rvci5ncmFwaGljcy5hZGQoKSdcclxuICAgIH0pXHJcbl0sIEFjdG9yLnByb3RvdHlwZSwgXCJhZGREcmF3aW5nXCIsIG51bGwpO1xyXG5BY3Rvcl9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0FjdG9yLmdldFpJbmRleCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIEFjdG9yLnRyYW5zZm9ybS56IG9yIEFjdG9yLnonXHJcbiAgICB9KVxyXG5dLCBBY3Rvci5wcm90b3R5cGUsIFwiZ2V0WkluZGV4XCIsIG51bGwpO1xyXG5BY3Rvcl9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0FjdG9yLnNldFpJbmRleCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIEFjdG9yLnRyYW5zZm9ybS56IG9yIEFjdG9yLnonXHJcbiAgICB9KVxyXG5dLCBBY3Rvci5wcm90b3R5cGUsIFwic2V0WkluZGV4XCIsIG51bGwpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1NjcmVlbkVsZW1lbnQudHNcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEhlbHBlciBbW0FjdG9yXV0gcHJpbWl0aXZlIGZvciBkcmF3aW5nIFVJJ3MsIG9wdGltaXplZCBmb3IgVUkgZHJhd2luZy4gRG9lc1xyXG4gKiBub3QgcGFydGljaXBhdGUgaW4gY29sbGlzaW9ucy4gRHJhd24gb24gdG9wIG9mIGFsbCBvdGhlciBhY3RvcnMuXHJcbiAqL1xyXG5jbGFzcyBTY3JlZW5FbGVtZW50X1NjcmVlbkVsZW1lbnQgZXh0ZW5kcyBBY3RvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHt9LCBjb25maWcpKTtcclxuICAgICAgICB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpLmNvb3JkUGxhbmUgPSBDb29yZFBsYW5lLlNjcmVlbjtcclxuICAgICAgICB0aGlzLnRyYWl0cyA9IFtdO1xyXG4gICAgICAgIHRoaXMudHJhaXRzLnB1c2gobmV3IENhcHR1cmVQb2ludGVyKCkpO1xyXG4gICAgICAgIHRoaXMuYW5jaG9yID0gdmVjKDAsIDApO1xyXG4gICAgICAgIHRoaXMuYm9keS5jb2xsaXNpb25UeXBlID0gQ29sbGlzaW9uVHlwZS5QcmV2ZW50Q29sbGlzaW9uO1xyXG4gICAgICAgIHRoaXMuY29sbGlkZXIudXNlQm94Q29sbGlkZXIodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuYW5jaG9yKTtcclxuICAgICAgICB0aGlzLmVuYWJsZUNhcHR1cmVQb2ludGVyID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9pbml0aWFsaXplKGVuZ2luZSkge1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgfVxyXG4gICAgY29udGFpbnMoeCwgeSwgdXNlV29ybGQgPSB0cnVlKSB7XHJcbiAgICAgICAgaWYgKHVzZVdvcmxkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdXBlci5jb250YWlucyh4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY29vcmRzID0gdGhpcy5fZW5naW5lLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhuZXcgVmVjdG9yKHgsIHkpKTtcclxuICAgICAgICByZXR1cm4gc3VwZXIuY29udGFpbnMoY29vcmRzLngsIGNvb3Jkcy55KTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1RpbWVyLnRzXG52YXIgVGltZXJfZGVjb3JhdGUgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBFeGNhbGlidXIgdGltZXIgaG9va3MgaW50byB0aGUgaW50ZXJuYWwgdGltZXIgYW5kIGZpcmVzIGNhbGxiYWNrcyxcclxuICogYWZ0ZXIgYSBjZXJ0YWluIGludGVydmFsLCBvcHRpb25hbGx5IHJlcGVhdGluZy5cclxuICovXHJcbmNsYXNzIFRpbWVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGZjbiwgaW50ZXJ2YWwsIHJlcGVhdHMsIG51bWJlck9mUmVwZWF0cykge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuaWQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl90b3RhbFRpbWVBbGl2ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mVGlja3MgPSAwO1xyXG4gICAgICAgIHRoaXMuaW50ZXJ2YWwgPSAxMDtcclxuICAgICAgICB0aGlzLnJlcGVhdHMgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLm1heE51bWJlck9mUmVwZWF0cyA9IC0xO1xyXG4gICAgICAgIHRoaXMuX2NvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5zY2VuZSA9IG51bGw7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmY24gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IGZjbjtcclxuICAgICAgICAgICAgZmNuID0gb3B0aW9ucy5mY247XHJcbiAgICAgICAgICAgIGludGVydmFsID0gb3B0aW9ucy5pbnRlcnZhbDtcclxuICAgICAgICAgICAgcmVwZWF0cyA9IG9wdGlvbnMucmVwZWF0cztcclxuICAgICAgICAgICAgbnVtYmVyT2ZSZXBlYXRzID0gb3B0aW9ucy5udW1iZXJPZlJlcGVhdHM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghIW51bWJlck9mUmVwZWF0cyAmJiBudW1iZXJPZlJlcGVhdHMgPj0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLm1heE51bWJlck9mUmVwZWF0cyA9IG51bWJlck9mUmVwZWF0cztcclxuICAgICAgICAgICAgaWYgKCFyZXBlYXRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlcGVhdHMgbXVzdCBiZSBzZXQgdG8gdHJ1ZSBpZiBudW1iZXJPZlJlcGVhdHMgaXMgc2V0Jyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5pZCA9IFRpbWVyLl9NQVhfSUQrKztcclxuICAgICAgICB0aGlzLmludGVydmFsID0gaW50ZXJ2YWwgfHwgdGhpcy5pbnRlcnZhbDtcclxuICAgICAgICB0aGlzLnJlcGVhdHMgPSByZXBlYXRzIHx8IHRoaXMucmVwZWF0cztcclxuICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBbXTtcclxuICAgICAgICBpZiAoZmNuKSB7XHJcbiAgICAgICAgICAgIHRoaXMub24oZmNuKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgY29tcGxldGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBsZXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgbmV3IGNhbGxiYWNrIHRvIGJlIGZpcmVkIGFmdGVyIHRoZSBpbnRlcnZhbCBpcyBjb21wbGV0ZVxyXG4gICAgICogQHBhcmFtIGZjbiBUaGUgY2FsbGJhY2sgdG8gYmUgYWRkZWQgdG8gdGhlIGNhbGxiYWNrIGxpc3QsIHRvIGJlIGZpcmVkIGFmdGVyIHRoZSBpbnRlcnZhbCBpcyBjb21wbGV0ZS5cclxuICAgICAqL1xyXG4gICAgb24oZmNuKSB7XHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnB1c2goZmNuKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhIGNhbGxiYWNrIGZyb20gdGhlIGNhbGxiYWNrIGxpc3QgdG8gYmUgZmlyZWQgYWZ0ZXIgdGhlIGludGVydmFsIGlzIGNvbXBsZXRlLlxyXG4gICAgICogQHBhcmFtIGZjbiBUaGUgY2FsbGJhY2sgdG8gYmUgcmVtb3ZlZCBmcm9tIHRoZSBjYWxsYmFjayBsaXN0LCB0byBiZSBmaXJlZCBhZnRlciB0aGUgaW50ZXJ2YWwgaXMgY29tcGxldGUuXHJcbiAgICAgKi9cclxuICAgIG9mZihmY24pIHtcclxuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NhbGxiYWNrcy5pbmRleE9mKGZjbik7XHJcbiAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIHRpbWVyIGFmdGVyIGEgY2VydGFpbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZC4gVGhpcyBpcyB1c2VkIGludGVybmFsbHkgYnkgdGhlIGVuZ2luZS5cclxuICAgICAqIEBwYXJhbSBkZWx0YSAgTnVtYmVyIG9mIGVsYXBzZWQgbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cclxuICAgICAqL1xyXG4gICAgdXBkYXRlKGRlbHRhKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5fdG90YWxUaW1lQWxpdmUgKz0gZGVsdGE7XHJcbiAgICAgICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5tYXhOdW1iZXJPZlJlcGVhdHMgPiAtMSAmJiB0aGlzLl9udW1iZXJPZlRpY2tzID49IHRoaXMubWF4TnVtYmVyT2ZSZXBlYXRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ydW5uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBsZXRlICYmIHRoaXMuX2VsYXBzZWRUaW1lID49IHRoaXMuaW50ZXJ2YWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5mb3JFYWNoKChjKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYy5jYWxsKHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9udW1iZXJPZlRpY2tzKys7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXBlYXRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbGFwc2VkVGltZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgdGltZXIgc28gdGhhdCBpdCBjYW4gYmUgcmV1c2VkLCBhbmQgb3B0aW9uYWxseSByZWNvbmZpZ3VyZSB0aGUgdGltZXJzIGludGVydmFsLlxyXG4gICAgICpcclxuICAgICAqIFdhcm5pbmcqKiB5b3UgbWF5IG5lZWQgdG8gY2FsbCBgdGltZXIuc3RhcnQoKWAgYWdhaW4gaWYgdGhlIHRpbWVyIGhhZCBjb21wbGV0ZWRcclxuICAgICAqIEBwYXJhbSBuZXdJbnRlcnZhbCBJZiBzcGVjaWZpZWQsIHNldHMgYSBuZXcgbm9uLW5lZ2F0aXZlIGludGVydmFsIGluIG1pbGxpc2Vjb25kcyB0byByZWZpcmUgdGhlIGNhbGxiYWNrXHJcbiAgICAgKiBAcGFyYW0gbmV3TnVtYmVyT2ZSZXBlYXRzIElmIHNwZWNpZmllZCwgc2V0cyBhIG5ldyBub24tbmVnYXRpdmUgdXBwZXIgbGltaXQgdG8gdGhlIG51bWJlciBvZiB0aW1lIHRoaXMgdGltZXIgZXhlY3V0ZXNcclxuICAgICAqL1xyXG4gICAgcmVzZXQobmV3SW50ZXJ2YWwsIG5ld051bWJlck9mUmVwZWF0cykge1xyXG4gICAgICAgIGlmICghIW5ld0ludGVydmFsICYmIG5ld0ludGVydmFsID49IDApIHtcclxuICAgICAgICAgICAgdGhpcy5pbnRlcnZhbCA9IG5ld0ludGVydmFsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoISF0aGlzLm1heE51bWJlck9mUmVwZWF0cyAmJiB0aGlzLm1heE51bWJlck9mUmVwZWF0cyA+PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMubWF4TnVtYmVyT2ZSZXBlYXRzID0gbmV3TnVtYmVyT2ZSZXBlYXRzO1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMucmVwZWF0cykge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXBlYXRzIG11c3QgYmUgc2V0IHRvIHRydWUgaWYgbnVtYmVyT2ZSZXBlYXRzIGlzIHNldCcpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX251bWJlck9mVGlja3MgPSAwO1xyXG4gICAgfVxyXG4gICAgZ2V0IHRpbWVzUmVwZWF0ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX251bWJlck9mVGlja3M7XHJcbiAgICB9XHJcbiAgICBnZXRUaW1lUnVubmluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxUaW1lQWxpdmU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIG1pbGxpc2Vjb25kcyB1bnRpbCB0aGUgbmV4dCBhY3Rpb24gY2FsbGJhY2ssIGlmIGNvbXBsZXRlIHdpbGwgcmV0dXJuIDBcclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbWVUb05leHRBY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLmludGVydmFsIC0gdGhpcy5fZWxhcHNlZFRpbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm5zIG1pbGxpc2Vjb25kcyBlbGFwc2VkIHRvd2FyZCB0aGUgbmV4dCBhY3Rpb25cclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbWVFbGFwc2VkVG93YXJkTmV4dEFjdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZWxhcHNlZFRpbWU7XHJcbiAgICB9XHJcbiAgICBnZXQgaXNSdW5uaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ydW5uaW5nO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXVzZXMgdGhlIHRpbWVyLCB0aW1lIHdpbGwgbm8gbG9uZ2VyIGluY3JlbWVudCB0b3dhcmRzIHRoZSBuZXh0IGNhbGxcclxuICAgICAqL1xyXG4gICAgcGF1c2UoKSB7XHJcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVbnBhdXNlcyB0aGUgdGltZXIuIFRpbWUgd2lsbCBub3cgaW5jcmVtZW50IHRvd2FyZHMgdGhlIG5leHQgY2FsbFxyXG4gICAgICogQGRlcHJlY2F0ZWQgV2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjBcclxuICAgICAqL1xyXG4gICAgdW5wYXVzZSgpIHtcclxuICAgICAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzdW1lcyB0aGUgdGltZXIsIHRpbWUgd2lsbCBub3cgaW5jcmVtZW50IHRvd2FyZHMgdGhlIG5leHQgY2FsbC5cclxuICAgICAqL1xyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIHRoaXMuX3J1bm5pbmcgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgdGhlIHRpbWVyLCBpZiB0aGUgdGltZXIgd2FzIGNvbXBsZXRlIGl0IHdpbGwgcmVzdGFydCB0aGUgdGltZXIgYW5kIHJlc2V0IHRoZSBlbGFwc2VkIHRpbWUgY291bnRlclxyXG4gICAgICovXHJcbiAgICBzdGFydCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc2NlbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oJ0Nhbm5vdCBzdGFydCBhIHRpbWVyIG5vdCBwYXJ0IG9mIGEgc2NlbmUsIHRpbWVyIHdvbnQgc3RhcnQgdW50aWwgYWRkZWQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IHRydWU7XHJcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcGxldGUgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl9udW1iZXJPZlRpY2tzID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIHRoZSB0aW1lciBhbmQgcmVzZXRzIHRoZSBlbGFwc2VkIHRpbWUgY291bnRlciB0b3dhcmRzIHRoZSBuZXh0IGFjdGlvbiBpbnZvY2F0aW9uXHJcbiAgICAgKi9cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRUaW1lID0gMDtcclxuICAgICAgICB0aGlzLl9udW1iZXJPZlRpY2tzID0gMDtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VscyB0aGUgdGltZXIsIHByZXZlbnRpbmcgYW55IGZ1cnRoZXIgZXhlY3V0aW9ucy5cclxuICAgICAqL1xyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIHRoaXMucGF1c2UoKTtcclxuICAgICAgICBpZiAodGhpcy5zY2VuZSkge1xyXG4gICAgICAgICAgICB0aGlzLnNjZW5lLmNhbmNlbFRpbWVyKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5UaW1lci5fTUFYX0lEID0gMDtcclxuVGltZXJfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnV2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLCBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgVGltZXIucmVzdW1lKCknIH0pXHJcbl0sIFRpbWVyLnByb3RvdHlwZSwgXCJ1bnBhdXNlXCIsIG51bGwpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1RpbGVNYXAudHNcbnZhciBUaWxlTWFwX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogQGhpZGRlblxyXG4gKi9cclxuY2xhc3MgVGlsZU1hcEltcGwgZXh0ZW5kcyBFbnRpdHkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0geE9yQ29uZmlnICAgICBUaGUgeCBjb29yZGluYXRlIHRvIGFuY2hvciB0aGUgVGlsZU1hcCdzIHVwcGVyIGxlZnQgY29ybmVyIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpIG9yIFRpbGVNYXAgb3B0aW9uIGJhZ1xyXG4gICAgICogQHBhcmFtIHkgICAgICAgICAgICAgVGhlIHkgY29vcmRpbmF0ZSB0byBhbmNob3IgdGhlIFRpbGVNYXAncyB1cHBlciBsZWZ0IGNvcm5lciAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxyXG4gICAgICogQHBhcmFtIGNlbGxXaWR0aCAgICAgVGhlIGluZGl2aWR1YWwgd2lkdGggb2YgZWFjaCBjZWxsIChpbiBwaXhlbHMpIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgKiBAcGFyYW0gY2VsbEhlaWdodCAgICBUaGUgaW5kaXZpZHVhbCBoZWlnaHQgb2YgZWFjaCBjZWxsIChpbiBwaXhlbHMpIChzaG91bGQgbm90IGJlIGNoYW5nZWQgb25jZSBzZXQpXHJcbiAgICAgKiBAcGFyYW0gcm93cyAgICAgICAgICBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIFRpbGVNYXAgKHNob3VsZCBub3QgYmUgY2hhbmdlZCBvbmNlIHNldClcclxuICAgICAqIEBwYXJhbSBjb2xzICAgICAgICAgIFRoZSBudW1iZXIgb2YgY29scyBpbiB0aGUgVGlsZU1hcCAoc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIG9uY2Ugc2V0KVxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih4T3JDb25maWcsIHksIGNlbGxXaWR0aCwgY2VsbEhlaWdodCwgcm93cywgY29scykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5fdG9rZW4gPSAwO1xyXG4gICAgICAgIHRoaXMuX29uU2NyZWVuWFN0YXJ0ID0gMDtcclxuICAgICAgICB0aGlzLl9vblNjcmVlblhFbmQgPSA5OTk5O1xyXG4gICAgICAgIHRoaXMuX29uU2NyZWVuWVN0YXJ0ID0gMDtcclxuICAgICAgICB0aGlzLl9vblNjcmVlbllFbmQgPSA5OTk5O1xyXG4gICAgICAgIHRoaXMuX3Nwcml0ZVNoZWV0cyA9IHt9O1xyXG4gICAgICAgIHRoaXMuX2xlZ2FjeVNwcml0ZU1hcCA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLmxvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3Jvd3MgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb2xzID0gW107XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzT2Zmc2NyZWVuID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIGlmICh4T3JDb25maWcgJiYgdHlwZW9mIHhPckNvbmZpZyA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0geE9yQ29uZmlnO1xyXG4gICAgICAgICAgICB4T3JDb25maWcgPSBjb25maWcueDtcclxuICAgICAgICAgICAgeSA9IGNvbmZpZy55O1xyXG4gICAgICAgICAgICBjZWxsV2lkdGggPSBjb25maWcuY2VsbFdpZHRoO1xyXG4gICAgICAgICAgICBjZWxsSGVpZ2h0ID0gY29uZmlnLmNlbGxIZWlnaHQ7XHJcbiAgICAgICAgICAgIHJvd3MgPSBjb25maWcucm93cztcclxuICAgICAgICAgICAgY29scyA9IGNvbmZpZy5jb2xzO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgVHJhbnNmb3JtQ29tcG9uZW50KCkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBNb3Rpb25Db21wb25lbnQoKSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IEJvZHlDb21wb25lbnQoe1xyXG4gICAgICAgICAgICB0eXBlOiBDb2xsaXNpb25UeXBlLkZpeGVkXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBDYW52YXNEcmF3Q29tcG9uZW50KChjdHgsIGRlbHRhKSA9PiB0aGlzLmRyYXcoY3R4LCBkZWx0YSkpKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudChuZXcgR3JhcGhpY3NDb21wb25lbnQoe1xyXG4gICAgICAgICAgICBvblBvc3REcmF3OiAoY3R4LCBkZWx0YSkgPT4gdGhpcy5kcmF3KGN0eCwgZGVsdGEpXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KG5ldyBDb2xsaWRlckNvbXBvbmVudCgpKTtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0gPSB0aGlzLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgIHRoaXMuX21vdGlvbiA9IHRoaXMuZ2V0KE1vdGlvbkNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXIgPSB0aGlzLmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlID0gdGhpcy5fY29sbGlkZXIudXNlQ29tcG9zaXRlQ29sbGlkZXIoW10pO1xyXG4gICAgICAgIHRoaXMueCA9IHhPckNvbmZpZztcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMuY2VsbFdpZHRoID0gY2VsbFdpZHRoO1xyXG4gICAgICAgIHRoaXMuY2VsbEhlaWdodCA9IGNlbGxIZWlnaHQ7XHJcbiAgICAgICAgdGhpcy5yb3dzID0gcm93cztcclxuICAgICAgICB0aGlzLmNvbHMgPSBjb2xzO1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBBcnJheShyb3dzICogY29scyk7XHJcbiAgICAgICAgdGhpcy5fcm93cyA9IG5ldyBBcnJheShyb3dzKTtcclxuICAgICAgICB0aGlzLl9jb2xzID0gbmV3IEFycmF5KGNvbHMpO1xyXG4gICAgICAgIGxldCBjdXJyZW50Q29sID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xzOyBpKyspIHtcclxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByb3dzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNkID0gbmV3IENlbGwoaSAqIGNlbGxXaWR0aCArIHhPckNvbmZpZywgaiAqIGNlbGxIZWlnaHQgKyB5LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIGkgKyBqICogY29scyk7XHJcbiAgICAgICAgICAgICAgICBjZC5tYXAgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2kgKyBqICogY29sc10gPSBjZDtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRDb2wucHVzaChjZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3Jvd3Nbal0pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yb3dzW2pdID0gW107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yb3dzW2pdLnB1c2goY2QpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbHNbaV0gPSBjdXJyZW50Q29sO1xyXG4gICAgICAgICAgICBjdXJyZW50Q29sID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZ2V0KEdyYXBoaWNzQ29tcG9uZW50KS5sb2NhbEJvdW5kcyA9IG5ldyBCb3VuZGluZ0JveCh7XHJcbiAgICAgICAgICAgIGxlZnQ6IDAsXHJcbiAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgcmlnaHQ6IHRoaXMuY29scyAqIHRoaXMuY2VsbFdpZHRoLFxyXG4gICAgICAgICAgICBib3R0b206IHRoaXMucm93cyAqIHRoaXMuY2VsbEhlaWdodFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgZmxhZ0RpcnR5KCkge1xyXG4gICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIGdldCB4KCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5fdHJhbnNmb3JtLnBvcy54KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xyXG4gICAgfVxyXG4gICAgc2V0IHgodmFsKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3MpIHtcclxuICAgICAgICAgICAgdGhpcy5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS5wb3MgPSB2ZWModmFsLCB0aGlzLnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCB5KCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3RyYW5zZm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBvcy55KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xyXG4gICAgfVxyXG4gICAgc2V0IHkodmFsKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3MpIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnBvcyA9IHZlYyh0aGlzLngsIHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHooKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl90cmFuc2Zvcm0ueikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcclxuICAgIH1cclxuICAgIHNldCB6KHZhbCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnogPSB2YWw7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0IHJvdGF0aW9uKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3RyYW5zZm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvdGF0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xyXG4gICAgfVxyXG4gICAgc2V0IHJvdGF0aW9uKHZhbCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBpZiAoKF9hID0gdGhpcy5fdHJhbnNmb3JtKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eucm90YXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNmb3JtLnJvdGF0aW9uID0gdmFsO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBzY2FsZSgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl90cmFuc2Zvcm0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY2FsZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogVmVjdG9yLk9uZTtcclxuICAgIH1cclxuICAgIHNldCBzY2FsZSh2YWwpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgaWYgKChfYSA9IHRoaXMuX3RyYW5zZm9ybSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNjYWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zZm9ybS5zY2FsZSA9IHZhbDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgcG9zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm0ucG9zO1xyXG4gICAgfVxyXG4gICAgc2V0IHBvcyh2YWwpIHtcclxuICAgICAgICB0aGlzLl90cmFuc2Zvcm0ucG9zID0gdmFsO1xyXG4gICAgfVxyXG4gICAgZ2V0IHZlbCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbW90aW9uLnZlbDtcclxuICAgIH1cclxuICAgIHNldCB2ZWwodmFsKSB7XHJcbiAgICAgICAgdGhpcy5fbW90aW9uLnZlbCA9IHZhbDtcclxuICAgIH1cclxuICAgIG9uKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9uKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZShlbmdpbmUpIHtcclxuICAgICAgICBzdXBlci5faW5pdGlhbGl6ZShlbmdpbmUpO1xyXG4gICAgfVxyXG4gICAgcmVnaXN0ZXJTcHJpdGVTaGVldChrZXksIHNwcml0ZVNoZWV0KSB7XHJcbiAgICAgICAgaWYgKHNwcml0ZVNoZWV0IGluc3RhbmNlb2YgU3ByaXRlU2hlZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3ByaXRlU2hlZXRzW2tleV0gPSBzcHJpdGVTaGVldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZVNoZWV0c1trZXldID0gU3ByaXRlU2hlZXQuZnJvbUxlZ2FjeVNwcml0ZVNoZWV0KHNwcml0ZVNoZWV0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRpbGVzIGNvbGxpZGVycyBiYXNlZCBvbiB0aGUgc29saWQgdGlsZXMgaW4gdGhlIHRpbGVtYXAuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGVDb2xsaWRlcnMoKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlLmNsZWFyQ29sbGlkZXJzKCk7XHJcbiAgICAgICAgY29uc3QgY29sbGlkZXJzID0gW107XHJcbiAgICAgICAgbGV0IGN1cnJlbnQ7XHJcbiAgICAgICAgLy8gQmFkIHNxdWFyZSB0ZXNzYWxhdGlvbiBhbGdvXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHM7IGkrKykge1xyXG4gICAgICAgICAgICAvLyBTY2FuIGNvbHVtbiBmb3IgY29sbGlkZXJzXHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5yb3dzOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIC8vIENvbHVtbnMgc3RhcnQgd2l0aCBhIG5ldyBjb2xsaWRlclxyXG4gICAgICAgICAgICAgICAgaWYgKGogPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHRpbGUgPSB0aGlzLmRhdGFbaSArIGogKiB0aGlzLmNvbHNdO1xyXG4gICAgICAgICAgICAgICAgLy8gQ3VycmVudCB0aWxlIGluIGNvbHVtbiBpcyBzb2xpZCBidWlsZCB1cCBjdXJyZW50IGNvbGxpZGVyXHJcbiAgICAgICAgICAgICAgICBpZiAodGlsZS5zb2xpZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGlsZS5ib3VuZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jb21iaW5lKHRpbGUuYm91bmRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgc29saWQgc2tpcCBhbmQgY3V0IG9mZiB0aGUgY3VycmVudCBjb2xsaWRlclxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxpZGVycy5wdXNoKGN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBZnRlciBhIGNvbHVtbiBpcyBjb21wbGV0ZSBjaGVjayB0byBzZWUgaWYgaXQgY2FuIGJlIG1lcmdlZCBpbnRvIHRoZSBsYXN0IG9uZVxyXG4gICAgICAgICAgICBpZiAoY3VycmVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gaWYgcHJldmlvdXMgaXMgdGhlIHNhbWUgY29tYmluZSBpdFxyXG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGNvbGxpZGVyc1tjb2xsaWRlcnMubGVuZ3RoIC0gMV07XHJcbiAgICAgICAgICAgICAgICBpZiAocHJldiAmJiBwcmV2LnRvcCA9PT0gY3VycmVudC50b3AgJiYgcHJldi5ib3R0b20gPT09IGN1cnJlbnQuYm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlkZXJzW2NvbGxpZGVycy5sZW5ndGggLSAxXSA9IHByZXYuY29tYmluZShjdXJyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGVsc2UgbmV3IGNvbGxpZGVyXHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlkZXJzLnB1c2goY3VycmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29tcG9zaXRlID0gdGhpcy5fY29sbGlkZXIudXNlQ29tcG9zaXRlQ29sbGlkZXIoW10pO1xyXG4gICAgICAgIGZvciAoY29uc3QgYyBvZiBjb2xsaWRlcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXIgPSBTaGFwZS5Cb3goYy53aWR0aCwgYy5oZWlnaHQsIFZlY3Rvci5aZXJvLCB2ZWMoYy5sZWZ0IC0gdGhpcy5wb3MueCwgYy50b3AgLSB0aGlzLnBvcy55KSk7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyLm93bmVyID0gdGhpcztcclxuICAgICAgICAgICAgdGhpcy5fY29tcG9zaXRlLmFkZENvbGxpZGVyKGNvbGxpZGVyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29sbGlkZXIudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFtbQ2VsbF1dIGJ5IGluZGV4IChyb3cgbWFqb3Igb3JkZXIpXHJcbiAgICAgKi9cclxuICAgIGdldENlbGxCeUluZGV4KGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtpbmRleF07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFtbQ2VsbF1dIGJ5IGl0cyB4IGFuZCB5IGNvb3JkaW5hdGVzXHJcbiAgICAgKi9cclxuICAgIGdldENlbGwoeCwgeSkge1xyXG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCB8fCB4ID49IHRoaXMuY29scyB8fCB5ID49IHRoaXMucm93cykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt4ICsgeSAqIHRoaXMuY29sc107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIFtbQ2VsbF1dIGJ5IHRlc3RpbmcgYSBwb2ludCBpbiBnbG9iYWwgY29vcmRpbmF0ZXMsXHJcbiAgICAgKiByZXR1cm5zIGBudWxsYCBpZiBubyBjZWxsIHdhcyBmb3VuZC5cclxuICAgICAqL1xyXG4gICAgZ2V0Q2VsbEJ5UG9pbnQoeCwgeSkge1xyXG4gICAgICAgIHggPSBNYXRoLmZsb29yKCh4IC0gdGhpcy5wb3MueCkgLyB0aGlzLmNlbGxXaWR0aCk7XHJcbiAgICAgICAgeSA9IE1hdGguZmxvb3IoKHkgLSB0aGlzLnBvcy55KSAvIHRoaXMuY2VsbEhlaWdodCk7XHJcbiAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0Q2VsbCh4LCB5KTtcclxuICAgICAgICBpZiAoeCA+PSAwICYmIHkgPj0gMCAmJiB4IDwgdGhpcy5jb2xzICYmIHkgPCB0aGlzLnJvd3MgJiYgY2VsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2VsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBnZXRSb3dzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yb3dzO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29sdW1ucygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29scztcclxuICAgIH1cclxuICAgIG9uUHJlVXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICBvblBvc3RVcGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIHVwZGF0ZShlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5vblByZVVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZXVwZGF0ZScsIG5ldyBQcmVVcGRhdGVFdmVudChlbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbGxpZGVycygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90b2tlbisrO1xyXG4gICAgICAgIGNvbnN0IHdvcmxkQm91bmRzID0gZW5naW5lLmdldFdvcmxkQm91bmRzKCk7XHJcbiAgICAgICAgY29uc3Qgd29ybGRDb29yZHNVcHBlckxlZnQgPSB2ZWMod29ybGRCb3VuZHMubGVmdCwgd29ybGRCb3VuZHMudG9wKTtcclxuICAgICAgICBjb25zdCB3b3JsZENvb3Jkc0xvd2VyUmlnaHQgPSB2ZWMod29ybGRCb3VuZHMucmlnaHQsIHdvcmxkQm91bmRzLmJvdHRvbSk7XHJcbiAgICAgICAgdGhpcy5fb25TY3JlZW5YU3RhcnQgPSBNYXRoLm1heChNYXRoLmZsb29yKCh3b3JsZENvb3Jkc1VwcGVyTGVmdC54IC0gdGhpcy54KSAvIHRoaXMuY2VsbFdpZHRoKSAtIDIsIDApO1xyXG4gICAgICAgIHRoaXMuX29uU2NyZWVuWVN0YXJ0ID0gTWF0aC5tYXgoTWF0aC5mbG9vcigod29ybGRDb29yZHNVcHBlckxlZnQueSAtIHRoaXMueSkgLyB0aGlzLmNlbGxIZWlnaHQpIC0gMiwgMCk7XHJcbiAgICAgICAgdGhpcy5fb25TY3JlZW5YRW5kID0gTWF0aC5tYXgoTWF0aC5mbG9vcigod29ybGRDb29yZHNMb3dlclJpZ2h0LnggLSB0aGlzLngpIC8gdGhpcy5jZWxsV2lkdGgpICsgMiwgMCk7XHJcbiAgICAgICAgdGhpcy5fb25TY3JlZW5ZRW5kID0gTWF0aC5tYXgoTWF0aC5mbG9vcigod29ybGRDb29yZHNMb3dlclJpZ2h0LnkgLSB0aGlzLnkpIC8gdGhpcy5jZWxsSGVpZ2h0KSArIDIsIDApO1xyXG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybS5wb3MgPSB2ZWModGhpcy54LCB0aGlzLnkpO1xyXG4gICAgICAgIHRoaXMub25Qb3N0VXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBQb3N0VXBkYXRlRXZlbnQoZW5naW5lLCBkZWx0YSwgdGhpcykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyB0aGUgdGlsZSBtYXAgdG8gdGhlIHNjcmVlbi4gQ2FsbGVkIGJ5IHRoZSBbW1NjZW5lXV0uXHJcbiAgICAgKiBAcGFyYW0gY3R4IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCBvciBFeGNhbGlidXJHcmFwaGljc0NvbnRleHRcclxuICAgICAqIEBwYXJhbSBkZWx0YSAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgZHJhd1xyXG4gICAgICovXHJcbiAgICBkcmF3KGN0eCwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZWRyYXcnLCBuZXcgUHJlRHJhd0V2ZW50KGN0eCwgZGVsdGEsIHRoaXMpKTsgLy8gVE9ETyBmaXggZXZlbnRcclxuICAgICAgICBsZXQgeCA9IHRoaXMuX29uU2NyZWVuWFN0YXJ0O1xyXG4gICAgICAgIGNvbnN0IHhFbmQgPSBNYXRoLm1pbih0aGlzLl9vblNjcmVlblhFbmQsIHRoaXMuY29scyk7XHJcbiAgICAgICAgbGV0IHkgPSB0aGlzLl9vblNjcmVlbllTdGFydDtcclxuICAgICAgICBjb25zdCB5RW5kID0gTWF0aC5taW4odGhpcy5fb25TY3JlZW5ZRW5kLCB0aGlzLnJvd3MpO1xyXG4gICAgICAgIGxldCBncmFwaGljcywgZ3JhcGhpY3NJbmRleCwgZ3JhcGhpY3NMZW47XHJcbiAgICAgICAgZm9yICh4OyB4IDwgeEVuZDsgeCsrKSB7XHJcbiAgICAgICAgICAgIGZvciAoeTsgeSA8IHlFbmQ7IHkrKykge1xyXG4gICAgICAgICAgICAgICAgLy8gZ2V0IG5vbi1uZWdhdGl2ZSB0aWxlIHNwcml0ZXNcclxuICAgICAgICAgICAgICAgIGdyYXBoaWNzID0gdGhpcy5nZXRDZWxsKHgsIHkpLmdyYXBoaWNzO1xyXG4gICAgICAgICAgICAgICAgZm9yIChncmFwaGljc0luZGV4ID0gMCwgZ3JhcGhpY3NMZW4gPSBncmFwaGljcy5sZW5ndGg7IGdyYXBoaWNzSW5kZXggPCBncmFwaGljc0xlbjsgZ3JhcGhpY3NJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gZHJhdyBzcHJpdGUsIHdhcm5pbmcgaWYgc3ByaXRlIGRvZXNuJ3QgZXhpc3RcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBncmFwaGljID0gZ3JhcGhpY3NbZ3JhcGhpY3NJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYXBoaWMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY3R4IGluc3RhbmNlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0dyYXBoaWNzVGljayhncmFwaGljKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWMgPT09IG51bGwgfHwgZ3JhcGhpYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JhcGhpYy50aWNrKGRlbHRhLCB0aGlzLl90b2tlbik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaGljLmRyYXcoY3R4LCB4ICogdGhpcy5jZWxsV2lkdGgsIHkgKiB0aGlzLmNlbGxIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGdyYXBoaWMgaW5zdGFuY2VvZiBTcHJpdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gbGVnYWN5IGRyYXdpbmcgbW9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9sZWdhY3lTcHJpdGVNYXAuaGFzKGdyYXBoaWMpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVnYWN5U3ByaXRlTWFwLnNldChncmFwaGljLCBTcHJpdGUudG9MZWdhY3lTcHJpdGUoZ3JhcGhpYykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGVnYWN5U3ByaXRlTWFwLmdldChncmFwaGljKS5kcmF3KGN0eCwgeCAqIHRoaXMuY2VsbFdpZHRoLCB5ICogdGhpcy5jZWxsSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB5ID0gdGhpcy5fb25TY3JlZW5ZU3RhcnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdGRyYXcnLCBuZXcgUG9zdERyYXdFdmVudChjdHgsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICB9XHJcbn1cclxuVGlsZU1hcF9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7IG1lc3NhZ2U6ICdObyBsb25nZXIgdXNlZCwgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnIH0pXHJcbl0sIFRpbGVNYXBJbXBsLnByb3RvdHlwZSwgXCJyZWdpc3RlclNwcml0ZVNoZWV0XCIsIG51bGwpO1xyXG4vKipcclxuICogVGhlIFtbVGlsZU1hcF1dIGNsYXNzIHByb3ZpZGVzIGEgbGlnaHR3ZWlnaHQgd2F5IHRvIGRvIGxhcmdlIGNvbXBsZXggc2NlbmVzIHdpdGggY29sbGlzaW9uXHJcbiAqIHdpdGhvdXQgdGhlIG92ZXJoZWFkIG9mIGFjdG9ycy5cclxuICovXHJcbmNsYXNzIFRpbGVNYXAgZXh0ZW5kcyBDb25maWd1cmFibGUoVGlsZU1hcEltcGwpIHtcclxuICAgIGNvbnN0cnVjdG9yKHhPckNvbmZpZywgeSwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCByb3dzLCBjb2xzKSB7XHJcbiAgICAgICAgc3VwZXIoeE9yQ29uZmlnLCB5LCBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIHJvd3MsIGNvbHMpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG5jbGFzcyBDZWxsSW1wbCBleHRlbmRzIEVudGl0eSB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB4T3JDb25maWcgR2V0cyBvciBzZXRzIHggY29vcmRpbmF0ZSBvZiB0aGUgY2VsbCBpbiB3b3JsZCBjb29yZGluYXRlcyBvciBjZWxsIG9wdGlvbiBiYWdcclxuICAgICAqIEBwYXJhbSB5ICAgICAgIEdldHMgb3Igc2V0cyB5IGNvb3JkaW5hdGUgb2YgdGhlIGNlbGwgaW4gd29ybGQgY29vcmRpbmF0ZXNcclxuICAgICAqIEBwYXJhbSB3aWR0aCAgIEdldHMgb3Igc2V0cyB0aGUgd2lkdGggb2YgdGhlIGNlbGxcclxuICAgICAqIEBwYXJhbSBoZWlnaHQgIEdldHMgb3Igc2V0cyB0aGUgaGVpZ2h0IG9mIHRoZSBjZWxsXHJcbiAgICAgKiBAcGFyYW0gaW5kZXggICBUaGUgaW5kZXggb2YgdGhlIGNlbGwgaW4gcm93IG1ham9yIG9yZGVyXHJcbiAgICAgKiBAcGFyYW0gc29saWQgICBHZXRzIG9yIHNldHMgd2hldGhlciB0aGlzIGNlbGwgaXMgc29saWRcclxuICAgICAqIEBwYXJhbSBncmFwaGljcyBUaGUgbGlzdCBvZiB0aWxlIGdyYXBoaWNzIHRvIHVzZSB0byBkcmF3IGluIHRoaXMgY2VsbCAoaW4gb3JkZXIpXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCwgaW5kZXgsIHNvbGlkID0gZmFsc2UsIGdyYXBoaWNzID0gW10pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3NvbGlkID0gZmFsc2U7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ3VycmVudCBsaXN0IG9mIGdyYXBoaWNzIGZvciB0aGlzIGNlbGxcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmdyYXBoaWNzID0gW107XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQWJpdHJhcnkgZGF0YSBzdG9yYWdlIHBlciBjZWxsLCB1c2VmdWwgZm9yIGFueSBnYW1lIHNwZWNpZmljIGRhdGFcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgaWYgKHhPckNvbmZpZyAmJiB0eXBlb2YgeE9yQ29uZmlnID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB4T3JDb25maWc7XHJcbiAgICAgICAgICAgIHhPckNvbmZpZyA9IGNvbmZpZy54O1xyXG4gICAgICAgICAgICB5ID0gY29uZmlnLnk7XHJcbiAgICAgICAgICAgIHdpZHRoID0gY29uZmlnLndpZHRoO1xyXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xyXG4gICAgICAgICAgICBpbmRleCA9IGNvbmZpZy5pbmRleDtcclxuICAgICAgICAgICAgc29saWQgPSBjb25maWcuc29saWQ7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzID0gY29uZmlnLnNwcml0ZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMueCA9IHhPckNvbmZpZztcclxuICAgICAgICB0aGlzLnkgPSB5O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5zb2xpZCA9IHNvbGlkO1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MgPSBncmFwaGljcztcclxuICAgICAgICB0aGlzLl9ib3VuZHMgPSBuZXcgQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnksIHRoaXMueCArIHRoaXMud2lkdGgsIHRoaXMueSArIHRoaXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2V0aGVyIHRoaXMgY2VsbCBzaG91bGQgYmUgdHJlYXRlZCBhcyBzb2xpZCBieSB0aGUgdGlsZW1hcFxyXG4gICAgICovXHJcbiAgICBnZXQgc29saWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NvbGlkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXZXRoZXIgdGhpcyBjZWxsIHNob3VsZCBiZSB0cmVhdGVkIGFzIHNvbGlkIGJ5IHRoZSB0aWxlbWFwXHJcbiAgICAgKi9cclxuICAgIHNldCBzb2xpZCh2YWwpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgKF9hID0gdGhpcy5tYXApID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mbGFnRGlydHkoKTtcclxuICAgICAgICB0aGlzLl9zb2xpZCA9IHZhbDtcclxuICAgIH1cclxuICAgIGdldCBib3VuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcclxuICAgIH1cclxuICAgIGdldCBjZW50ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IodGhpcy54ICsgdGhpcy53aWR0aCAvIDIsIHRoaXMueSArIHRoaXMuaGVpZ2h0IC8gMik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbm90aGVyIFtbU3ByaXRlXV0gdG8gdGhpcyBjZWxsXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYWRkU3ByaXRlLCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gICAgICovXHJcbiAgICBwdXNoU3ByaXRlKHNwcml0ZSkge1xyXG4gICAgICAgIHRoaXMuYWRkR3JhcGhpYyhzcHJpdGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgYW5vdGhlciBbW0dyYXBoaWNdXSB0byB0aGlzIFRpbGVNYXAgY2VsbFxyXG4gICAgICogQHBhcmFtIGdyYXBoaWNcclxuICAgICAqL1xyXG4gICAgYWRkR3JhcGhpYyhncmFwaGljKSB7XHJcbiAgICAgICAgaWYgKGdyYXBoaWMgaW5zdGFuY2VvZiBTcHJpdGVfU3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MucHVzaChTcHJpdGUuZnJvbUxlZ2FjeVNwcml0ZShncmFwaGljKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzLnB1c2goZ3JhcGhpYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmUgYW4gaW5zdGFuY2Ugb2YgYSBbW0dyYXBoaWNdXSBmcm9tIHRoaXMgY2VsbFxyXG4gICAgICovXHJcbiAgICByZW1vdmVHcmFwaGljKGdyYXBoaWMpIHtcclxuICAgICAgICByZW1vdmVJdGVtRnJvbUFycmF5KGdyYXBoaWMsIHRoaXMuZ3JhcGhpY3MpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhciBhbGwgZ3JhcGhpcyBmcm9tIHRoaXMgY2VsbFxyXG4gICAgICovXHJcbiAgICBjbGVhckdyYXBoaWNzKCkge1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MubGVuZ3RoID0gMDtcclxuICAgIH1cclxufVxyXG5UaWxlTWFwX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHsgbWVzc2FnZTogJ1dpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJywgYWx0ZXJuYXRlTWV0aG9kOiAnYWRkU3ByaXRlJyB9KVxyXG5dLCBDZWxsSW1wbC5wcm90b3R5cGUsIFwicHVzaFNwcml0ZVwiLCBudWxsKTtcclxuLyoqXHJcbiAqIFRpbGVNYXAgQ2VsbFxyXG4gKlxyXG4gKiBBIGxpZ2h0LXdlaWdodCBvYmplY3QgdGhhdCBvY2N1cGllcyBhIHNwYWNlIGluIGEgY29sbGlzaW9uIG1hcC4gR2VuZXJhbGx5XHJcbiAqIGNyZWF0ZWQgYnkgYSBbW1RpbGVNYXBdXS5cclxuICpcclxuICogQ2VsbHMgY2FuIGRyYXcgbXVsdGlwbGUgc3ByaXRlcy4gTm90ZSB0aGF0IHRoZSBvcmRlciBvZiBkcmF3aW5nIGlzIHRoZSBvcmRlclxyXG4gKiBvZiB0aGUgc3ByaXRlcyBpbiB0aGUgYXJyYXkgc28gdGhlIGxhc3Qgb25lIHdpbGwgYmUgZHJhd24gb24gdG9wLiBZb3UgY2FuXHJcbiAqIHVzZSB0cmFuc3BhcmVuY3kgdG8gY3JlYXRlIGxheWVycyB0aGlzIHdheS5cclxuICovXHJcbmNsYXNzIENlbGwgZXh0ZW5kcyBDb25maWd1cmFibGUoQ2VsbEltcGwpIHtcclxuICAgIGNvbnN0cnVjdG9yKHhPckNvbmZpZywgeSwgd2lkdGgsIGhlaWdodCwgaW5kZXgsIHNvbGlkLCBzcHJpdGVzKSB7XHJcbiAgICAgICAgc3VwZXIoeE9yQ29uZmlnLCB5LCB3aWR0aCwgaGVpZ2h0LCBpbmRleCwgc29saWQsIHNwcml0ZXMpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ2FtZXJhLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBDb250YWluZXIgdG8gaG91c2UgY29udmVuaWVuY2Ugc3RyYXRlZ3kgbWV0aG9kc1xyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmNsYXNzIFN0cmF0ZWd5Q29udGFpbmVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGNhbWVyYSkge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW0xvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmEuXHJcbiAgICAgKiBAcGFyYW0gYWN0b3IgVGhlIGFjdG9yIHRvIGxvY2sgdGhlIGNhbWVyYSB0b1xyXG4gICAgICovXHJcbiAgICBsb2NrVG9BY3RvcihhY3Rvcikge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBMb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5KGFjdG9yKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgdGhlIFtbTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmFcclxuICAgICAqIEBwYXJhbSBhY3RvciBUaGUgYWN0b3IgdG8gbG9jayB0aGUgY2FtZXJhIHRvXHJcbiAgICAgKiBAcGFyYW0gYXhpcyBUaGUgYXhpcyB0byBmb2xsb3cgdGhlIGFjdG9yIG9uXHJcbiAgICAgKi9cclxuICAgIGxvY2tUb0FjdG9yQXhpcyhhY3RvciwgYXhpcykge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBMb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneShhY3RvciwgYXhpcykpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGFuZCBhZGRzIHRoZSBbW0VsYXN0aWNUb0FjdG9yU3RyYXRlZ3ldXSBvbiB0aGUgY3VycmVudCBjYW1lcmFcclxuICAgICAqIElmIGNhbWVyYUVsYXN0aWNpdHkgPCBjYW1lcmFGcmljdGlvbiA8IDEuMCwgdGhlIGJlaGF2aW9yIHdpbGwgYmUgYSBkYW1wZW5lZCBzcHJpbmcgdGhhdCB3aWxsIHNsb3dseSBlbmQgYXQgdGhlIHRhcmdldCB3aXRob3V0IGJvdW5jaW5nXHJcbiAgICAgKiBJZiBjYW1lcmFGcmljdGlvbiA8IGNhbWVyYUVsYXN0aWNpdHkgPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGFuIG9zY2lsbGF0aW5nIHNwcmluZyB0aGF0IHdpbGwgb3ZlclxyXG4gICAgICogY29ycmVjdCBhbmQgYm91bmNlIGFyb3VuZCB0aGUgdGFyZ2V0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFjdG9yIFRhcmdldCBhY3RvciB0byBlbGFzdGljYWxseSBmb2xsb3dcclxuICAgICAqIEBwYXJhbSBjYW1lcmFFbGFzdGljaXR5IFswIC0gMS4wXSBUaGUgaGlnaGVyIHRoZSBlbGFzdGljaXR5IHRoZSBtb3JlIGZvcmNlIHRoYXQgd2lsbCBkcml2ZSB0aGUgY2FtZXJhIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgICogQHBhcmFtIGNhbWVyYUZyaWN0aW9uIFswIC0gMS4wXSBUaGUgaGlnaGVyIHRoZSBmcmljdGlvbiB0aGUgbW9yZSB0aGF0IHRoZSBjYW1lcmEgd2lsbCByZXNpc3QgbW90aW9uIHRvd2FyZHMgdGhlIHRhcmdldFxyXG4gICAgICovXHJcbiAgICBlbGFzdGljVG9BY3RvcihhY3RvciwgY2FtZXJhRWxhc3RpY2l0eSwgY2FtZXJhRnJpY3Rpb24pIHtcclxuICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgRWxhc3RpY1RvQWN0b3JTdHJhdGVneShhY3RvciwgY2FtZXJhRWxhc3RpY2l0eSwgY2FtZXJhRnJpY3Rpb24pKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhbmQgYWRkcyB0aGUgW1tSYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5XV0gb24gdGhlIGN1cnJlbnQgY2FtZXJhXHJcbiAgICAgKiBAcGFyYW0gYWN0b3IgVGFyZ2V0IGFjdG9yIHRvIGZvbGxvdyB3aGVuIGl0IGlzIFwicmFkaXVzXCIgcGl4ZWxzIGF3YXlcclxuICAgICAqIEBwYXJhbSByYWRpdXMgTnVtYmVyIG9mIHBpeGVscyBhd2F5IGJlZm9yZSB0aGUgY2FtZXJhIHdpbGwgZm9sbG93XHJcbiAgICAgKi9cclxuICAgIHJhZGl1c0Fyb3VuZEFjdG9yKGFjdG9yLCByYWRpdXMpIHtcclxuICAgICAgICB0aGlzLmNhbWVyYS5hZGRTdHJhdGVneShuZXcgUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneShhY3RvciwgcmFkaXVzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW5kIGFkZHMgdGhlIFtbTGltaXRDYW1lcmFCb3VuZHNTdHJhdGVneV1dIG9uIHRoZSBjdXJyZW50IGNhbWVyYVxyXG4gICAgICogQHBhcmFtIGJveCBUaGUgYm91bmRpbmcgYm94IHRvIGxpbWl0IHRoZSBjYW1lcmEgdG8uXHJcbiAgICAgKi9cclxuICAgIGxpbWl0Q2FtZXJhQm91bmRzKGJveCkge1xyXG4gICAgICAgIHRoaXMuY2FtZXJhLmFkZFN0cmF0ZWd5KG5ldyBMaW1pdENhbWVyYUJvdW5kc1N0cmF0ZWd5KGJveCkpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBDYW1lcmEgYXhpcyBlbnVtXHJcbiAqL1xyXG52YXIgQXhpcztcclxuKGZ1bmN0aW9uIChBeGlzKSB7XHJcbiAgICBBeGlzW0F4aXNbXCJYXCJdID0gMF0gPSBcIlhcIjtcclxuICAgIEF4aXNbQXhpc1tcIllcIl0gPSAxXSA9IFwiWVwiO1xyXG59KShBeGlzIHx8IChBeGlzID0ge30pKTtcclxuLyoqXHJcbiAqIExvY2sgYSBjYW1lcmEgdG8gdGhlIGV4YWN0IHgveSBwb3NpdGlvbiBvZiBhbiBhY3Rvci5cclxuICovXHJcbmNsYXNzIExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3kge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgdGhpcy5hY3Rpb24gPSAodGFyZ2V0LCBfY2FtLCBfZW5nLCBfZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyID0gdGFyZ2V0LmNlbnRlcjtcclxuICAgICAgICAgICAgcmV0dXJuIGNlbnRlcjtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBMb2NrIGEgY2FtZXJhIHRvIGEgc3BlY2lmaWMgYXhpcyBhcm91bmQgYW4gYWN0b3IuXHJcbiAqL1xyXG5jbGFzcyBMb2NrQ2FtZXJhVG9BY3RvckF4aXNTdHJhdGVneSB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGF4aXMpIHtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLmF4aXMgPSBheGlzO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2VudGVyID0gdGFyZ2V0LmNlbnRlcjtcclxuICAgICAgICAgICAgY29uc3QgY3VycmVudEZvY3VzID0gY2FtLmdldEZvY3VzKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmF4aXMgPT09IEF4aXMuWCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBWZWN0b3IoY2VudGVyLngsIGN1cnJlbnRGb2N1cy55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVmVjdG9yKGN1cnJlbnRGb2N1cy54LCBjZW50ZXIueSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBVc2luZyBbSG9vaydzIGxhd10oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9va2Unc19sYXcpLCBlbGFzdGljYWxseSBtb3ZlIHRoZSBjYW1lcmEgdG93YXJkcyB0aGUgdGFyZ2V0IGFjdG9yLlxyXG4gKi9cclxuY2xhc3MgRWxhc3RpY1RvQWN0b3JTdHJhdGVneSB7XHJcbiAgICAvKipcclxuICAgICAqIElmIGNhbWVyYUVsYXN0aWNpdHkgPCBjYW1lcmFGcmljdGlvbiA8IDEuMCwgdGhlIGJlaGF2aW9yIHdpbGwgYmUgYSBkYW1wZW5lZCBzcHJpbmcgdGhhdCB3aWxsIHNsb3dseSBlbmQgYXQgdGhlIHRhcmdldCB3aXRob3V0IGJvdW5jaW5nXHJcbiAgICAgKiBJZiBjYW1lcmFGcmljdGlvbiA8IGNhbWVyYUVsYXN0aWNpdHkgPCAxLjAsIHRoZSBiZWhhdmlvciB3aWxsIGJlIGFuIG9zY2lsbGF0aW5nIHNwcmluZyB0aGF0IHdpbGwgb3ZlclxyXG4gICAgICogY29ycmVjdCBhbmQgYm91bmNlIGFyb3VuZCB0aGUgdGFyZ2V0XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgYWN0b3IgdG8gZWxhc3RpY2FsbHkgZm9sbG93XHJcbiAgICAgKiBAcGFyYW0gY2FtZXJhRWxhc3RpY2l0eSBbMCAtIDEuMF0gVGhlIGhpZ2hlciB0aGUgZWxhc3RpY2l0eSB0aGUgbW9yZSBmb3JjZSB0aGF0IHdpbGwgZHJpdmUgdGhlIGNhbWVyYSB0b3dhcmRzIHRoZSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSBjYW1lcmFGcmljdGlvbiBbMCAtIDEuMF0gVGhlIGhpZ2hlciB0aGUgZnJpY3Rpb24gdGhlIG1vcmUgdGhhdCB0aGUgY2FtZXJhIHdpbGwgcmVzaXN0IG1vdGlvbiB0b3dhcmRzIHRoZSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBjYW1lcmFFbGFzdGljaXR5LCBjYW1lcmFGcmljdGlvbikge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuY2FtZXJhRWxhc3RpY2l0eSA9IGNhbWVyYUVsYXN0aWNpdHk7XHJcbiAgICAgICAgdGhpcy5jYW1lcmFGcmljdGlvbiA9IGNhbWVyYUZyaWN0aW9uO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0YXJnZXQuY2VudGVyO1xyXG4gICAgICAgICAgICBsZXQgZm9jdXMgPSBjYW0uZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgbGV0IGNhbWVyYVZlbCA9IGNhbS52ZWwuY2xvbmUoKTtcclxuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBzdHJldGNoIHZlY3RvciwgdXNpbmcgdGhlIHNwcmluZyBlcXVhdGlvblxyXG4gICAgICAgICAgICAvLyBGID0ga1hcclxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSG9va2Unc19sYXdcclxuICAgICAgICAgICAgLy8gQXBwbHkgdG8gdGhlIGN1cnJlbnQgY2FtZXJhIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGNvbnN0IHN0cmV0Y2ggPSBwb3NpdGlvbi5zdWIoZm9jdXMpLnNjYWxlKHRoaXMuY2FtZXJhRWxhc3RpY2l0eSk7IC8vIHN0cmV0Y2ggaXMgWFxyXG4gICAgICAgICAgICBjYW1lcmFWZWwgPSBjYW1lcmFWZWwuYWRkKHN0cmV0Y2gpO1xyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGZyaWN0aW9uICgtMSB0byBhcHBseSBhIGZvcmNlIGluIHRoZSBvcHBvc2l0aW9uIG9mIG1vdGlvbilcclxuICAgICAgICAgICAgLy8gQXBwbHkgdG8gdGhlIGN1cnJlbnQgY2FtZXJhIHZlbG9jaXR5XHJcbiAgICAgICAgICAgIGNvbnN0IGZyaWN0aW9uID0gY2FtZXJhVmVsLnNjYWxlKC0xKS5zY2FsZSh0aGlzLmNhbWVyYUZyaWN0aW9uKTtcclxuICAgICAgICAgICAgY2FtZXJhVmVsID0gY2FtZXJhVmVsLmFkZChmcmljdGlvbik7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBwb3NpdGlvbiBieSB2ZWxvY2l0eSBkZWx0YXNcclxuICAgICAgICAgICAgZm9jdXMgPSBmb2N1cy5hZGQoY2FtZXJhVmVsKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZvY3VzO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUmFkaXVzQXJvdW5kQWN0b3JTdHJhdGVneSB7XHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFyZ2V0IFRhcmdldCBhY3RvciB0byBmb2xsb3cgd2hlbiBpdCBpcyBcInJhZGl1c1wiIHBpeGVscyBhd2F5XHJcbiAgICAgKiBAcGFyYW0gcmFkaXVzIE51bWJlciBvZiBwaXhlbHMgYXdheSBiZWZvcmUgdGhlIGNhbWVyYSB3aWxsIGZvbGxvd1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHJhZGl1cykge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzO1xyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0YXJnZXQuY2VudGVyO1xyXG4gICAgICAgICAgICBjb25zdCBmb2N1cyA9IGNhbS5nZXRGb2N1cygpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBwb3NpdGlvbi5zdWIoZm9jdXMpO1xyXG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IGRpcmVjdGlvbi5zaXplO1xyXG4gICAgICAgICAgICBpZiAoZGlzdGFuY2UgPj0gdGhpcy5yYWRpdXMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IGRpc3RhbmNlIC0gdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9jdXMuYWRkKGRpcmVjdGlvbi5ub3JtYWxpemUoKS5zY2FsZShvZmZzZXQpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZm9jdXM7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUHJldmVudCBhIGNhbWVyYSBmcm9tIGdvaW5nIGJleW9uZCB0aGUgZ2l2ZW4gY2FtZXJhIGRpbWVuc2lvbnMuXHJcbiAqL1xyXG5jbGFzcyBMaW1pdENhbWVyYUJvdW5kc1N0cmF0ZWd5IHtcclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xyXG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFVzZWZ1bCBmb3IgbGltaXRpbmcgdGhlIGNhbWVyYSB0byBhIFtbVGlsZU1hcF1dJ3MgZGltZW5zaW9ucywgb3IgYSBzcGVjaWZpYyBhcmVhIGluc2lkZSB0aGUgbWFwLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogTm90ZSB0aGF0IHRoaXMgc3RyYXRlZ3kgZG9lcyBub3QgcGVyZm9ybSBhbnkgbW92ZW1lbnQgYnkgaXRzZWxmLlxyXG4gICAgICAgICAqIEl0IG9ubHkgc2V0cyB0aGUgY2FtZXJhIHBvc2l0aW9uIHRvIHdpdGhpbiB0aGUgZ2l2ZW4gYm91bmRzIHdoZW4gdGhlIGNhbWVyYSBoYXMgZ29uZSBiZXlvbmQgdGhlbS5cclxuICAgICAgICAgKiBUaHVzLCBpdCBpcyBhIGdvb2QgaWRlYSB0byBjb21iaW5lIGl0IHdpdGggb3RoZXIgY2FtZXJhIHN0cmF0ZWdpZXMgYW5kIHNldCB0aGlzIHN0cmF0ZWd5IGFzIHRoZSBsYXN0IG9uZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIE1ha2Ugc3VyZSB0aGF0IHRoZSBjYW1lcmEgYm91bmRzIGFyZSBhdCBsZWFzdCBhcyBsYXJnZSBhcyB0aGUgdmlld3BvcnQgc2l6ZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwYXJhbSB0YXJnZXQgVGhlIGJvdW5kaW5nIGJveCB0byBsaW1pdCB0aGUgY2FtZXJhIHRvXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ib3VuZFNpemVDaGVja2VkID0gZmFsc2U7IC8vIENoZWNrIGFuZCB3YXJuIG9ubHkgb25jZVxyXG4gICAgICAgIHRoaXMuYWN0aW9uID0gKHRhcmdldCwgY2FtLCBfZW5nLCBfZGVsdGEpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZm9jdXMgPSBjYW0uZ2V0Rm9jdXMoKTtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLmJvdW5kU2l6ZUNoZWNrZWQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQuYm90dG9tIC0gdGFyZ2V0LnRvcCA8IF9lbmcuZHJhd0hlaWdodCB8fCB0YXJnZXQucmlnaHQgLSB0YXJnZXQubGVmdCA8IF9lbmcuZHJhd1dpZHRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignQ2FtZXJhIGJvdW5kcyBzaG91bGQgbm90IGJlIHNtYWxsZXIgdGhhbiB0aGUgZW5naW5lIHZpZXdwb3J0Jyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLmJvdW5kU2l6ZUNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBmb2N1c1ggPSBmb2N1cy54O1xyXG4gICAgICAgICAgICBsZXQgZm9jdXNZID0gZm9jdXMueTtcclxuICAgICAgICAgICAgaWYgKGZvY3VzLnggPCB0YXJnZXQubGVmdCArIF9lbmcuaGFsZkRyYXdXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgZm9jdXNYID0gdGFyZ2V0LmxlZnQgKyBfZW5nLmhhbGZEcmF3V2lkdGg7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZm9jdXMueCA+IHRhcmdldC5yaWdodCAtIF9lbmcuaGFsZkRyYXdXaWR0aCkge1xyXG4gICAgICAgICAgICAgICAgZm9jdXNYID0gdGFyZ2V0LnJpZ2h0IC0gX2VuZy5oYWxmRHJhd1dpZHRoO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChmb2N1cy55IDwgdGFyZ2V0LnRvcCArIF9lbmcuaGFsZkRyYXdIZWlnaHQpIHtcclxuICAgICAgICAgICAgICAgIGZvY3VzWSA9IHRhcmdldC50b3AgKyBfZW5nLmhhbGZEcmF3SGVpZ2h0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGZvY3VzLnkgPiB0YXJnZXQuYm90dG9tIC0gX2VuZy5oYWxmRHJhd0hlaWdodCkge1xyXG4gICAgICAgICAgICAgICAgZm9jdXNZID0gdGFyZ2V0LmJvdHRvbSAtIF9lbmcuaGFsZkRyYXdIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHZlYyhmb2N1c1gsIGZvY3VzWSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQ2FtZXJhc1xyXG4gKlxyXG4gKiBbW0NhbWVyYV1dIGlzIHRoZSBiYXNlIGNsYXNzIGZvciBhbGwgRXhjYWxpYnVyIGNhbWVyYXMuIENhbWVyYXMgYXJlIHVzZWRcclxuICogdG8gbW92ZSBhcm91bmQgeW91ciBnYW1lIGFuZCBzZXQgZm9jdXMuIFRoZXkgYXJlIHVzZWQgdG8gZGV0ZXJtaW5lXHJcbiAqIHdoYXQgaXMgXCJvZmYgc2NyZWVuXCIgYW5kIGNhbiBiZSB1c2VkIHRvIHNjYWxlIHRoZSBnYW1lLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgQ2FtZXJhIGV4dGVuZHMgQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzID0gW107XHJcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IG5ldyBTdHJhdGVneUNvbnRhaW5lcih0aGlzKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgb3Igc2V0IGN1cnJlbnQgem9vbSBvZiB0aGUgY2FtZXJhLCBkZWZhdWx0cyB0byAxXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5feiA9IDE7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IG9yIHNldCByYXRlIG9mIGNoYW5nZSBpbiB6b29tLCBkZWZhdWx0cyB0byAwXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5keiA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0IG9yIHNldCB6b29tIGFjY2VsZXJhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYXogPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgcm90YXRpb24gb2YgdGhlIGNhbWVyYVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEN1cnJlbnQgYW5ndWxhciB2ZWxvY2l0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucnggPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldCBvciBzZXQgdGhlIGNhbWVyYSdzIHBvc2l0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fcG9zQ2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3BvcyA9IHdhdGNoQW55KFZlY3Rvci5aZXJvLCAoKSA9PiAodGhpcy5fcG9zQ2hhbmdlZCA9IHRydWUpKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXQgb3Igc2V0IHRoZSBjYW1lcmEncyB2ZWxvY2l0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudmVsID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR0V0IG9yIHNldCB0aGUgY2FtZXJhJ3MgYWNjZWxlcmF0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY2MgPSBWZWN0b3IuWmVybztcclxuICAgICAgICB0aGlzLl9jYW1lcmFNb3ZpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50TGVycFRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2xlcnBEdXJhdGlvbiA9IDEwMDA7IC8vIDEgc2Vjb25kXHJcbiAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9sZXJwRW5kID0gbnVsbDtcclxuICAgICAgICAvL2NhbWVyYSBlZmZlY3RzXHJcbiAgICAgICAgdGhpcy5faXNTaGFraW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fc2hha2VNYWduaXR1ZGVYID0gMDtcclxuICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVkgPSAwO1xyXG4gICAgICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gPSAwO1xyXG4gICAgICAgIHRoaXMuX2VsYXBzZWRTaGFrZVRpbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX3hTaGFrZSA9IDA7XHJcbiAgICAgICAgdGhpcy5feVNoYWtlID0gMDtcclxuICAgICAgICB0aGlzLl9pc1pvb21pbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl96b29tU3RhcnQgPSAxO1xyXG4gICAgICAgIHRoaXMuX3pvb21FbmQgPSAxO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRab29tVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fem9vbUR1cmF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLl96b29tRWFzaW5nID0gRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dEN1YmljO1xyXG4gICAgICAgIHRoaXMuX2Vhc2luZyA9IEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYztcclxuICAgICAgICB0aGlzLl9oYWxmV2lkdGggPSAwO1xyXG4gICAgICAgIHRoaXMuX2hhbGZIZWlnaHQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBnZXQgem9vbSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fejtcclxuICAgIH1cclxuICAgIHNldCB6b29tKHZhbCkge1xyXG4gICAgICAgIHRoaXMuX3ogPSB2YWw7XHJcbiAgICAgICAgaWYgKHRoaXMuX2VuZ2luZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9oYWxmV2lkdGggPSB0aGlzLl9lbmdpbmUuaGFsZkRyYXdXaWR0aDtcclxuICAgICAgICAgICAgdGhpcy5faGFsZkhlaWdodCA9IHRoaXMuX2VuZ2luZS5oYWxmRHJhd0hlaWdodDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIGNhbWVyYSdzIGFuZ3VsYXIgdmVsb2NpdHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGFuZ3VsYXJWZWxvY2l0eSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yeDtcclxuICAgIH1cclxuICAgIHNldCBhbmd1bGFyVmVsb2NpdHkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLnJ4ID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgcG9zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb3M7XHJcbiAgICB9XHJcbiAgICBzZXQgcG9zKHZlYykge1xyXG4gICAgICAgIHRoaXMuX3BvcyA9IHdhdGNoQW55KHZlYywgKCkgPT4gKHRoaXMuX3Bvc0NoYW5nZWQgPSB0cnVlKSk7XHJcbiAgICAgICAgdGhpcy5fcG9zQ2hhbmdlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2FtZXJhJ3MgeCBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBnZXQgeCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3MueDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjYW1lcmEncyB4IHBvc2l0aW9uIChjYW5ub3QgYmUgc2V0IHdoZW4gZm9sbG93aW5nIGFuIFtbQWN0b3JdXSBvciB3aGVuIG1vdmluZylcclxuICAgICAqL1xyXG4gICAgc2V0IHgodmFsdWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2ZvbGxvdyAmJiAhdGhpcy5fY2FtZXJhTW92aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gdmVjKHZhbHVlLCB0aGlzLnBvcy55KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgY2FtZXJhJ3MgeSBwb3NpdGlvblxyXG4gICAgICovXHJcbiAgICBnZXQgeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5wb3MueTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0IHRoZSBjYW1lcmEncyB5IHBvc2l0aW9uIChjYW5ub3QgYmUgc2V0IHdoZW4gZm9sbG93aW5nIGFuIFtbQWN0b3JdXSBvciB3aGVuIG1vdmluZylcclxuICAgICAqL1xyXG4gICAgc2V0IHkodmFsdWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2ZvbGxvdyAmJiAhdGhpcy5fY2FtZXJhTW92aW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMucG9zID0gdmVjKHRoaXMucG9zLngsIHZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvciBzZXQgdGhlIGNhbWVyYSdzIHggdmVsb2NpdHlcclxuICAgICAqL1xyXG4gICAgZ2V0IGR4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnZlbC54O1xyXG4gICAgfVxyXG4gICAgc2V0IGR4KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy52ZWwgPSB2ZWModmFsdWUsIHRoaXMudmVsLnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBjYW1lcmEncyB5IHZlbG9jaXR5XHJcbiAgICAgKi9cclxuICAgIGdldCBkeSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy52ZWwueTtcclxuICAgIH1cclxuICAgIHNldCBkeSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMudmVsID0gdmVjKHRoaXMudmVsLngsIHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9yIHNldCB0aGUgY2FtZXJhJ3MgeCBhY2NlbGVyYXRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0IGF4KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmFjYy54O1xyXG4gICAgfVxyXG4gICAgc2V0IGF4KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5hY2MgPSB2ZWModmFsdWUsIHRoaXMuYWNjLnkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb3Igc2V0IHRoZSBjYW1lcmEncyB5IGFjY2VsZXJhdGlvblxyXG4gICAgICovXHJcbiAgICBnZXQgYXkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWNjLnk7XHJcbiAgICB9XHJcbiAgICBzZXQgYXkodmFsdWUpIHtcclxuICAgICAgICB0aGlzLmFjYyA9IHZlYyh0aGlzLmFjYy54LCB2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGZvY2FsIHBvaW50IG9mIHRoZSBjYW1lcmEsIGEgbmV3IHBvaW50IGdpdmluZyB0aGUgeCBhbmQgeSBwb3NpdGlvbiBvZiB0aGUgY2FtZXJhXHJcbiAgICAgKi9cclxuICAgIGdldEZvY3VzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnBvcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBtb3ZlcyB0aGUgY2FtZXJhIGZvY2FsIHBvaW50IHRvIHRoZSBzcGVjaWZpZWQgcG9zaXRpb24gdXNpbmcgc3BlY2lmaWVkIGVhc2luZyBmdW5jdGlvbi4gQ2Fubm90IG1vdmUgd2hlbiBmb2xsb3dpbmcgYW4gQWN0b3IuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBvcyBUaGUgdGFyZ2V0IHBvc2l0aW9uIHRvIG1vdmUgdG9cclxuICAgICAqIEBwYXJhbSBkdXJhdGlvbiBUaGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRoZSBtb3ZlIHNob3VsZCBsYXN0XHJcbiAgICAgKiBAcGFyYW0gW2Vhc2luZ0ZuXSBBbiBvcHRpb25hbCBlYXNpbmcgZnVuY3Rpb24gKFtbZXguRWFzaW5nRnVuY3Rpb25zLkVhc2VJbk91dEN1YmljXV0gYnkgZGVmYXVsdClcclxuICAgICAqIEByZXR1cm5zIEEgW1tQcm9taXNlXV0gdGhhdCByZXNvbHZlcyB3aGVuIG1vdmVtZW50IGlzIGZpbmlzaGVkLCBpbmNsdWRpbmcgaWYgaXQncyBpbnRlcnJ1cHRlZC5cclxuICAgICAqICAgICAgICAgIFRoZSBbW1Byb21pc2VdXSB2YWx1ZSBpcyB0aGUgW1tWZWN0b3JdXSBvZiB0aGUgdGFyZ2V0IHBvc2l0aW9uLiBJdCB3aWxsIGJlIHJlamVjdGVkIGlmIGEgbW92ZSBjYW5ub3QgYmUgbWFkZS5cclxuICAgICAqL1xyXG4gICAgbW92ZShwb3MsIGR1cmF0aW9uLCBlYXNpbmdGbiA9IEVhc2luZ0Z1bmN0aW9ucy5FYXNlSW5PdXRDdWJpYykge1xyXG4gICAgICAgIGlmICh0eXBlb2YgZWFzaW5nRm4gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdGhyb3cgJ1BsZWFzZSBzcGVjaWZ5IGFuIEVhc2luZ0Z1bmN0aW9uJztcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY2Fubm90IG1vdmUgd2hlbiBmb2xsb3dpbmcgYW4gYWN0b3JcclxuICAgICAgICBpZiAodGhpcy5fZm9sbG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChwb3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyByZXNvbHZlIGV4aXN0aW5nIHByb21pc2UsIGlmIGFueVxyXG4gICAgICAgIGlmICh0aGlzLl9sZXJwUHJvbWlzZSAmJiB0aGlzLl9sZXJwUmVzb2x2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9sZXJwUmVzb2x2ZShwb3MpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sZXJwUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xlcnBSZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9sZXJwU3RhcnQgPSB0aGlzLmdldEZvY3VzKCkuY2xvbmUoKTtcclxuICAgICAgICB0aGlzLl9sZXJwRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICB0aGlzLl9sZXJwRW5kID0gcG9zO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRMZXJwVGltZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhTW92aW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9lYXNpbmcgPSBlYXNpbmdGbjtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGVycFByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGNhbWVyYSB0byBzaGFrZSBhdCB0aGUgc3BlY2lmaWVkIG1hZ25pdHVkZXMgZm9yIHRoZSBzcGVjaWZpZWQgZHVyYXRpb25cclxuICAgICAqIEBwYXJhbSBtYWduaXR1ZGVYICBUaGUgeCBtYWduaXR1ZGUgb2YgdGhlIHNoYWtlXHJcbiAgICAgKiBAcGFyYW0gbWFnbml0dWRlWSAgVGhlIHkgbWFnbml0dWRlIG9mIHRoZSBzaGFrZVxyXG4gICAgICogQHBhcmFtIGR1cmF0aW9uICAgIFRoZSBkdXJhdGlvbiBvZiB0aGUgc2hha2UgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIHNoYWtlKG1hZ25pdHVkZVgsIG1hZ25pdHVkZVksIGR1cmF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5faXNTaGFraW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9zaGFrZU1hZ25pdHVkZVggPSBtYWduaXR1ZGVYO1xyXG4gICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWSA9IG1hZ25pdHVkZVk7XHJcbiAgICAgICAgdGhpcy5fc2hha2VEdXJhdGlvbiA9IGR1cmF0aW9uO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBab29tcyB0aGUgY2FtZXJhIGluIG9yIG91dCBieSB0aGUgc3BlY2lmaWVkIHNjYWxlIG92ZXIgdGhlIHNwZWNpZmllZCBkdXJhdGlvbi5cclxuICAgICAqIElmIG5vIGR1cmF0aW9uIGlzIHNwZWNpZmllZCwgaXQgdGFrZSBlZmZlY3QgaW1tZWRpYXRlbHkuXHJcbiAgICAgKiBAcGFyYW0gc2NhbGUgICAgVGhlIHNjYWxlIG9mIHRoZSB6b29tXHJcbiAgICAgKiBAcGFyYW0gZHVyYXRpb24gVGhlIGR1cmF0aW9uIG9mIHRoZSB6b29tIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICovXHJcbiAgICB6b29tT3ZlclRpbWUoc2NhbGUsIGR1cmF0aW9uID0gMCwgZWFzaW5nRm4gPSBFYXNpbmdGdW5jdGlvbnMuRWFzZUluT3V0Q3ViaWMpIHtcclxuICAgICAgICB0aGlzLl96b29tUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3pvb21SZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoZHVyYXRpb24pIHtcclxuICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fem9vbUVhc2luZyA9IGVhc2luZ0ZuO1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50Wm9vbVRpbWUgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl96b29tRHVyYXRpb24gPSBkdXJhdGlvbjtcclxuICAgICAgICAgICAgdGhpcy5fem9vbVN0YXJ0ID0gdGhpcy56b29tO1xyXG4gICAgICAgICAgICB0aGlzLl96b29tRW5kID0gc2NhbGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1pvb21pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy56b29tID0gc2NhbGU7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl96b29tUHJvbWlzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB2aWV3cG9ydCBvZiB0aGlzIGNhbWVyYSBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICovXHJcbiAgICBnZXQgdmlld3BvcnQoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXdwb3J0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl92aWV3cG9ydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCgwLCAwLCAwLCAwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIG5ldyBjYW1lcmEgc3RyYXRlZ3kgdG8gdGhpcyBjYW1lcmFcclxuICAgICAqIEBwYXJhbSBjYW1lcmFTdHJhdGVneSBJbnN0YW5jZSBvZiBhbiBbW0NhbWVyYVN0cmF0ZWd5XV1cclxuICAgICAqL1xyXG4gICAgYWRkU3RyYXRlZ3koY2FtZXJhU3RyYXRlZ3kpIHtcclxuICAgICAgICB0aGlzLl9jYW1lcmFTdHJhdGVnaWVzLnB1c2goY2FtZXJhU3RyYXRlZ3kpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgY2FtZXJhIHN0cmF0ZWd5IGJ5IHJlZmVyZW5jZVxyXG4gICAgICogQHBhcmFtIGNhbWVyYVN0cmF0ZWd5IEluc3RhbmNlIG9mIGFuIFtbQ2FtZXJhU3RyYXRlZ3ldXVxyXG4gICAgICovXHJcbiAgICByZW1vdmVTdHJhdGVneShjYW1lcmFTdHJhdGVneSkge1xyXG4gICAgICAgIHJlbW92ZUl0ZW1Gcm9tQXJyYXkoY2FtZXJhU3RyYXRlZ3ksIHRoaXMuX2NhbWVyYVN0cmF0ZWdpZXMpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgYWxsIGNhbWVyYSBzdHJhdGVnaWVzIGZyb20gdGhlIGNhbWVyYVxyXG4gICAgICovXHJcbiAgICBjbGVhckFsbFN0cmF0ZWdpZXMoKSB7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhU3RyYXRlZ2llcy5sZW5ndGggPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wcmV1cGRhdGUgaGFuZGxlciBmb3IgW1tvblByZVVwZGF0ZV1dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wcmV1cGRhdGUoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncHJldXBkYXRlJywgbmV3IFByZVVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUHJlVXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlIHRvIG92ZXJyaWRlIG9uUHJlVXBkYXRlIGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncHJldXBkYXRlJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUHJlVXBkYXRlYCBpcyBjYWxsZWQgZGlyZWN0bHkgYmVmb3JlIGEgc2NlbmUgaXMgdXBkYXRlZC5cclxuICAgICAqL1xyXG4gICAgb25QcmVVcGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGFibGVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3ByZXVwZGF0ZSBoYW5kbGVyIGZvciBbW29uUG9zdFVwZGF0ZV1dIGxpZmVjeWNsZSBldmVudFxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wb3N0dXBkYXRlKGVuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3Bvc3R1cGRhdGUnLCBuZXcgUG9zdFVwZGF0ZUV2ZW50KGVuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUG9zdFVwZGF0ZShlbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblBvc3RVcGRhdGUgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwcmV1cGRhdGUnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25Qb3N0VXBkYXRlYCBpcyBjYWxsZWQgZGlyZWN0bHkgYWZ0ZXIgYSBzY2VuZSBpcyB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBvblBvc3RVcGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGFibGVcclxuICAgIH1cclxuICAgIGdldCBpc0luaXRpYWxpemVkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pc0luaXRpYWxpemVkO1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemUoX2VuZ2luZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZSA9IF9lbmdpbmU7XHJcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSZXMgPSB0aGlzLl9lbmdpbmUuc2NyZWVuLnJlc29sdXRpb247XHJcbiAgICAgICAgICAgIGxldCBjZW50ZXIgPSB2ZWMoY3VycmVudFJlcy53aWR0aCAvIDIsIGN1cnJlbnRSZXMuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZW5naW5lLmxvYWRpbmdDb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgbG9hZGluZyBzY3JlZW4sIHdlIHBlZWsgdGhlIGNvbmZpZ3VyZWQgcmVzb2x1dGlvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5fZW5naW5lLnNjcmVlbi5wZWVrUmVzb2x1dGlvbigpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlciA9IHZlYyhyZXMud2lkdGggLyAyLCByZXMuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faGFsZldpZHRoID0gY2VudGVyLng7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhbGZIZWlnaHQgPSBjZW50ZXIueDtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzIG5vdCBzZXQgdGhlIGNhbWVyYSBwb3MsIGFwcGx5IGRlZmF1bHQgY2VudGVyIHNjcmVlbiBwb3NpdGlvblxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX3Bvc0NoYW5nZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gY2VudGVyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMub25Jbml0aWFsaXplKF9lbmdpbmUpO1xyXG4gICAgICAgICAgICBzdXBlci5lbWl0KCdpbml0aWFsaXplJywgbmV3IEluaXRpYWxpemVFdmVudChfZW5naW5lLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblBvc3RVcGRhdGUgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwcmV1cGRhdGUnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25Qb3N0VXBkYXRlYCBpcyBjYWxsZWQgZGlyZWN0bHkgYWZ0ZXIgYSBzY2VuZSBpcyB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBvbkluaXRpYWxpemUoX2VuZ2luZSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRhYmxlXHJcbiAgICB9XHJcbiAgICBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb2ZmKGV2ZW50TmFtZSwgaGFuZGxlcikge1xyXG4gICAgICAgIHN1cGVyLm9mZihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb25jZShldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoX2VuZ2luZSwgZGVsdGEpIHtcclxuICAgICAgICB0aGlzLl9pbml0aWFsaXplKF9lbmdpbmUpO1xyXG4gICAgICAgIHRoaXMuX3ByZXVwZGF0ZShfZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgLy8gVXBkYXRlIHBsYWNlbWVudHMgYmFzZWQgb24gbGluZWFyIGFsZ2VicmFcclxuICAgICAgICB0aGlzLnBvcyA9IHRoaXMucG9zLmFkZCh0aGlzLnZlbC5zY2FsZShkZWx0YSAvIDEwMDApKTtcclxuICAgICAgICB0aGlzLnpvb20gKz0gKHRoaXMuZHogKiBkZWx0YSkgLyAxMDAwO1xyXG4gICAgICAgIHRoaXMudmVsID0gdGhpcy52ZWwuYWRkKHRoaXMuYWNjLnNjYWxlKGRlbHRhIC8gMTAwMCkpO1xyXG4gICAgICAgIHRoaXMuZHogKz0gKHRoaXMuYXogKiBkZWx0YSkgLyAxMDAwO1xyXG4gICAgICAgIHRoaXMucm90YXRpb24gKz0gKHRoaXMuYW5ndWxhclZlbG9jaXR5ICogZGVsdGEpIC8gMTAwMDtcclxuICAgICAgICBpZiAodGhpcy5faXNab29taW5nKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jdXJyZW50Wm9vbVRpbWUgPCB0aGlzLl96b29tRHVyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHpvb21FYXNpbmcgPSB0aGlzLl96b29tRWFzaW5nO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Wm9vbSA9IHpvb21FYXNpbmcodGhpcy5fY3VycmVudFpvb21UaW1lLCB0aGlzLl96b29tU3RhcnQsIHRoaXMuX3pvb21FbmQsIHRoaXMuX3pvb21EdXJhdGlvbik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20gPSBuZXdab29tO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFpvb21UaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNab29taW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnpvb20gPSB0aGlzLl96b29tRW5kO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFpvb21UaW1lID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3pvb21SZXNvbHZlKHRydWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9jYW1lcmFNb3ZpbmcpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRMZXJwVGltZSA8IHRoaXMuX2xlcnBEdXJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbW92ZUVhc2luZyA9IEVhc2luZ0Z1bmN0aW9ucy5DcmVhdGVWZWN0b3JFYXNpbmdGdW5jdGlvbih0aGlzLl9lYXNpbmcpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgbGVycFBvaW50ID0gbW92ZUVhc2luZyh0aGlzLl9jdXJyZW50TGVycFRpbWUsIHRoaXMuX2xlcnBTdGFydCwgdGhpcy5fbGVycEVuZCwgdGhpcy5fbGVycER1cmF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gbGVycFBvaW50O1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lICs9IGRlbHRhO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLl9sZXJwRW5kO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gdGhpcy5fbGVycEVuZC5jbG9uZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGVycFN0YXJ0ID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBFbmQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3VycmVudExlcnBUaW1lID0gMDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbWVyYU1vdmluZyA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgLy8gT3JkZXIgbWF0dGVycyBoZXJlLCByZXNvbHZlIHNob3VsZCBiZSBsYXN0IHNvIGFueSBjaGFpbiBwcm9taXNlcyBoYXZlIGEgY2xlYW4gc2xhdGVcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlcnBSZXNvbHZlKGVuZCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRG9uZVNoYWtpbmcoKSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1NoYWtpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFNoYWtlVGltZSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWCA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlTWFnbml0dWRlWSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuX3NoYWtlRHVyYXRpb24gPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl94U2hha2UgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLl95U2hha2UgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fZWxhcHNlZFNoYWtlVGltZSArPSBkZWx0YTtcclxuICAgICAgICAgICAgdGhpcy5feFNoYWtlID0gKChNYXRoLnJhbmRvbSgpICogdGhpcy5fc2hha2VNYWduaXR1ZGVYKSB8IDApICsgMTtcclxuICAgICAgICAgICAgdGhpcy5feVNoYWtlID0gKChNYXRoLnJhbmRvbSgpICogdGhpcy5fc2hha2VNYWduaXR1ZGVZKSB8IDApICsgMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHRoaXMuX2NhbWVyYVN0cmF0ZWdpZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5wb3MgPSBzLmFjdGlvbi5jYWxsKHMsIHMudGFyZ2V0LCB0aGlzLCBfZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3ZpZXdwb3J0ID0gbmV3IEJvdW5kaW5nQm94KHRoaXMueCAtIHRoaXMuX2hhbGZXaWR0aCwgdGhpcy55IC0gdGhpcy5faGFsZkhlaWdodCwgdGhpcy54ICsgdGhpcy5faGFsZldpZHRoLCB0aGlzLnkgKyB0aGlzLl9oYWxmSGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9wb3N0dXBkYXRlKF9lbmdpbmUsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIGRyYXcoY3R4KSB7XHJcbiAgICAgICAgbGV0IGNhbnZhc1dpZHRoID0gMDtcclxuICAgICAgICBsZXQgY2FudmFzSGVpZ2h0ID0gMDtcclxuICAgICAgICBpZiAoY3R4IGluc3RhbmNlb2YgQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKSB7XHJcbiAgICAgICAgICAgIGNhbnZhc1dpZHRoID0gY3R4LmNhbnZhcy53aWR0aDtcclxuICAgICAgICAgICAgY2FudmFzSGVpZ2h0ID0gY3R4LmNhbnZhcy5oZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjYW52YXNXaWR0aCA9IGN0eC53aWR0aDtcclxuICAgICAgICAgICAgY2FudmFzSGVpZ2h0ID0gY3R4LmhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZm9jdXMgPSB0aGlzLmdldEZvY3VzKCk7XHJcbiAgICAgICAgY29uc3QgcGl4ZWxSYXRpbyA9IHRoaXMuX2VuZ2luZSA/IHRoaXMuX2VuZ2luZS5waXhlbFJhdGlvIDogMTtcclxuICAgICAgICBjb25zdCB6b29tID0gdGhpcy56b29tO1xyXG4gICAgICAgIGNvbnN0IG5ld0NhbnZhc1dpZHRoID0gY2FudmFzV2lkdGggLyB6b29tIC8gcGl4ZWxSYXRpbztcclxuICAgICAgICBjb25zdCBuZXdDYW52YXNIZWlnaHQgPSBjYW52YXNIZWlnaHQgLyB6b29tIC8gcGl4ZWxSYXRpbztcclxuICAgICAgICBjdHguc2NhbGUoem9vbSwgem9vbSk7XHJcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtZm9jdXMueCArIG5ld0NhbnZhc1dpZHRoIC8gMiArIHRoaXMuX3hTaGFrZSwgLWZvY3VzLnkgKyBuZXdDYW52YXNIZWlnaHQgLyAyICsgdGhpcy5feVNoYWtlKTtcclxuICAgIH1cclxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICBkZWJ1Z0RyYXcoX2N0eCkge1xyXG4gICAgICAgIC8vIHBhc3NcclxuICAgIH1cclxuICAgIF9pc0RvbmVTaGFraW5nKCkge1xyXG4gICAgICAgIHJldHVybiAhdGhpcy5faXNTaGFraW5nIHx8IHRoaXMuX2VsYXBzZWRTaGFrZVRpbWUgPj0gdGhpcy5fc2hha2VEdXJhdGlvbjtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvQWN0b3JzLnRzXG5cclxuXHJcblxyXG4vKipcclxuICogVHlwZSBndWFyZCB0byBkZXRlY3QgaWYgc29tZXRoaW5nIGlzIGFuIGFjdG9yXHJcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqIEBwYXJhbSBhY3RvclxyXG4gKi9cclxuZnVuY3Rpb24gaXNWYW5pbGxhQWN0b3IoYWN0b3IpIHtcclxuICAgIHJldHVybiAhKGFjdG9yIGluc3RhbmNlb2YgU2NyZWVuRWxlbWVudCkgJiYgIShhY3RvciBpbnN0YW5jZW9mIFRyaWdnZXIpICYmICEoYWN0b3IgaW5zdGFuY2VvZiBMYWJlbCk7XHJcbn1cclxuLyoqXHJcbiAqIFR5cGUgZ3VhcmQgdG8gZGV0ZWN0IGEgc2NyZWVuIGVsZW1lbnRcclxuICogQHRvZG8gbW92ZSB0byBTY3JlZW5FbGVtZW50XHJcbiAqL1xyXG5mdW5jdGlvbiBpc1NjcmVlbkVsZW1lbnQoYWN0b3IpIHtcclxuICAgIHJldHVybiBhY3RvciBpbnN0YW5jZW9mIFNjcmVlbkVsZW1lbnRfU2NyZWVuRWxlbWVudDtcclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1RyaWdnZXIudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jb25zdCB0cmlnZ2VyRGVmYXVsdHMgPSB7XHJcbiAgICBwb3M6IFZlY3Rvci5aZXJvLFxyXG4gICAgd2lkdGg6IDEwLFxyXG4gICAgaGVpZ2h0OiAxMCxcclxuICAgIHZpc2libGU6IGZhbHNlLFxyXG4gICAgYWN0aW9uOiAoKSA9PiB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfSxcclxuICAgIGZpbHRlcjogKCkgPT4gdHJ1ZSxcclxuICAgIHJlcGVhdDogLTFcclxufTtcclxuLyoqXHJcbiAqIFRyaWdnZXJzIGFyZSBhIG1ldGhvZCBvZiBmaXJpbmcgYXJiaXRyYXJ5IGNvZGUgb24gY29sbGlzaW9uLiBUaGVzZSBhcmUgdXNlZnVsXHJcbiAqIGFzICdidXR0b25zJywgJ3N3aXRjaGVzJywgb3IgdG8gdHJpZ2dlciBlZmZlY3RzIGluIGEgZ2FtZS4gQnkgZGVmYXVsdCB0cmlnZ2Vyc1xyXG4gKiBhcmUgaW52aXNpYmxlLCBhbmQgY2FuIG9ubHkgYmUgc2VlbiB3aGVuIFtbVHJpZ2dlci52aXNpYmxlXV0gaXMgc2V0IHRvIGB0cnVlYC5cclxuICovXHJcbmNsYXNzIFRyaWdnZXJfVHJpZ2dlciBleHRlbmRzIEFjdG9yIHtcclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBvcHRzIFRyaWdnZXIgb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XHJcbiAgICAgICAgc3VwZXIoeyB4OiBvcHRzLnBvcy54LCB5OiBvcHRzLnBvcy55LCB3aWR0aDogb3B0cy53aWR0aCwgaGVpZ2h0OiBvcHRzLmhlaWdodCB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBY3Rpb24gdG8gZmlyZSB3aGVuIHRyaWdnZXJlZCBieSBjb2xsaXNpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGlvbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRmlsdGVyIHRvIGFkZCBhZGRpdGlvbmFsIGdyYW51bGFyaXR5IHRvIGFjdGlvbiBkaXNwYXRjaCwgaWYgYSBmaWx0ZXIgaXMgc3BlY2lmaWVkIHRoZSBhY3Rpb24gd2lsbCBvbmx5IGZpcmUgd2hlblxyXG4gICAgICAgICAqIGZpbHRlciByZXR1cm4gdHJ1ZSBmb3IgdGhlIGNvbGxpZGVkIGFjdG9yLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gKCkgPT4gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBOdW1iZXIgb2YgdGltZXMgdG8gcmVwZWF0IGJlZm9yZSBraWxsaW5nIHRoZSB0cmlnZ2VyLFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmVwZWF0ID0gLTE7XHJcbiAgICAgICAgb3B0cyA9IGV4dGVuZCh7fSwgdHJpZ2dlckRlZmF1bHRzLCBvcHRzKTtcclxuICAgICAgICB0aGlzLmZpbHRlciA9IG9wdHMuZmlsdGVyIHx8IHRoaXMuZmlsdGVyO1xyXG4gICAgICAgIHRoaXMucmVwZWF0ID0gb3B0cy5yZXBlYXQgfHwgdGhpcy5yZXBlYXQ7XHJcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBvcHRzLmFjdGlvbiB8fCB0aGlzLmFjdGlvbjtcclxuICAgICAgICBpZiAob3B0cy50YXJnZXQpIHtcclxuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBvcHRzLnRhcmdldDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5ncmFwaGljcy52aXNpYmxlID0gb3B0cy52aXNpYmxlO1xyXG4gICAgICAgIHRoaXMuYm9keS5jb2xsaXNpb25UeXBlID0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlO1xyXG4gICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyID0gbmV3IEV2ZW50RGlzcGF0Y2hlcih0aGlzKTtcclxuICAgICAgICB0aGlzLmV2ZW50cy5vbignY29sbGlzaW9uc3RhcnQnLCAoZXZ0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcihldnQub3RoZXIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2VudGVyJywgbmV3IEVudGVyVHJpZ2dlckV2ZW50KHRoaXMsIGV2dC5vdGhlcikpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hBY3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0cmlnZ2VyIGlmIGl0cyBkb25lLCAtMSByZXBlYXQgZm9yZXZlclxyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0ID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5raWxsKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmV2ZW50cy5vbignY29sbGlzaW9uZW5kJywgKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5maWx0ZXIoZXZ0Lm90aGVyKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdleGl0JywgbmV3IEV4aXRUcmlnZ2VyRXZlbnQodGhpcywgZXZ0Lm90aGVyKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHNldCB0YXJnZXQodGFyZ2V0KSB7XHJcbiAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gKGFjdG9yKSA9PiBhY3RvciA9PT0gdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgZ2V0IHRhcmdldCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemUoZW5naW5lKSB7XHJcbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemUoZW5naW5lKTtcclxuICAgIH1cclxuICAgIF9kaXNwYXRjaEFjdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5yZXBlYXQgIT09IDApIHtcclxuICAgICAgICAgICAgdGhpcy5hY3Rpb24uY2FsbCh0aGlzKTtcclxuICAgICAgICAgICAgdGhpcy5yZXBlYXQtLTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgZGVidWdEcmF3KGN0eCkge1xyXG4gICAgICAgIHN1cGVyLmRlYnVnRHJhdyhjdHgpO1xyXG4gICAgICAgIC8vIE1lYW50IHRvIGRyYXcgZGVidWcgaW5mb3JtYXRpb24gYWJvdXQgYWN0b3JzXHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMucG9zLngsIHRoaXMucG9zLnkpO1xyXG4gICAgICAgIGNvbnN0IGJiID0gdGhpcy5jb2xsaWRlci5ib3VuZHM7XHJcbiAgICAgICAgY29uc3Qgd3AgPSB0aGlzLmdldEdsb2JhbFBvcygpO1xyXG4gICAgICAgIGJiLmxlZnQgPSBiYi5sZWZ0IC0gd3AueDtcclxuICAgICAgICBiYi5yaWdodCA9IGJiLnJpZ2h0IC0gd3AueDtcclxuICAgICAgICBiYi50b3AgPSBiYi50b3AgLSB3cC55O1xyXG4gICAgICAgIGJiLmJvdHRvbSA9IGJiLmJvdHRvbSAtIHdwLnk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yLlZpb2xldC50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IENvbG9yLlZpb2xldC50b1N0cmluZygpO1xyXG4gICAgICAgIGN0eC5maWxsVGV4dCgnVHJpZ2dlcicsIDEwLCAxMCk7XHJcbiAgICAgICAgYmIuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9TeXN0ZW0udHNcbi8qKlxyXG4gKiBFbnVtIHRoYXQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRvIHJ1biB0aGUgc3lzdGVtIGluIHRoZSB1cGRhdGUgb3IgZHJhdyBwaGFzZVxyXG4gKi9cclxudmFyIFN5c3RlbVR5cGU7XHJcbihmdW5jdGlvbiAoU3lzdGVtVHlwZSkge1xyXG4gICAgU3lzdGVtVHlwZVtcIlVwZGF0ZVwiXSA9IFwidXBkYXRlXCI7XHJcbiAgICBTeXN0ZW1UeXBlW1wiRHJhd1wiXSA9IFwiZHJhd1wiO1xyXG59KShTeXN0ZW1UeXBlIHx8IChTeXN0ZW1UeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIEFuIEV4Y2FsaWJ1ciBbW1N5c3RlbV1dIHRoYXQgdXBkYXRlcyBlbnRpdGllcyBvZiBjZXJ0YWluIHR5cGVzLlxyXG4gKiBTeXN0ZW1zIGFyZSBzY2VuZSBzcGVjaWZpY1xyXG4gKlxyXG4gKiBFeGNhbGlidXIgU3lzdGVtcyBjdXJyZW50bHkgcmVxdWlyZSBhdCBsZWFzdCAxIENvbXBvbmVudCB0eXBlIHRvIG9wZXJhdGVkXHJcbiAqXHJcbiAqIE11bHRpcGxlIHR5cGVzIGFyZSBkZWNsYXJlZCBhcyBhIHR5cGUgdW5pb25cclxuICogRm9yIGV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYHR5cGVzY3JpcHRcclxuICogY2xhc3MgTXlTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW08Q29tcG9uZW50QSB8IENvbXBvbmVudEI+IHtcclxuICogICBwdWJsaWMgcmVhZG9ubHkgdHlwZXMgPSBbJ2EnLCAnYiddIGFzIGNvbnN0O1xyXG4gKiAgIHB1YmxpYyByZWFkb25seSBzeXN0ZW1UeXBlID0gU3lzdGVtVHlwZS5VcGRhdGU7XHJcbiAqICAgcHVibGljIHVwZGF0ZShlbnRpdGllczogRW50aXR5PENvbXBvbmVudEEgfCBDb21wb25lbnRCPikge1xyXG4gKiAgICAgIC4uLlxyXG4gKiAgIH1cclxuICogfVxyXG4gKiBgYGBcclxuICovXHJcbmNsYXNzIFN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTeXN0ZW0gY2FuIGV4ZWN1dGUgaW4gcHJpb3JpdHkgb3JkZXIsIGJ5IGRlZmF1bHQgYWxsIHN5c3RlbXMgYXJlIHByaW9yaXR5IDAuIExvd2VyIHZhbHVlcyBpbmRpY2F0ZWQgaGlnaGVyIHByaW9yaXR5LlxyXG4gICAgICAgICAqIEZvciBhIHN5c3RlbSB0byBleGVjdXRlIGJlZm9yZSBhbGwgb3RoZXIgYSBsb3dlciBwcmlvcml0eSB2YWx1ZSAoLTEgZm9yIGV4YW1wbGUpIG11c3QgYmUgc2V0LlxyXG4gICAgICAgICAqIEZvciBhIHN5c3RlbSB0byBleGVjdHVlIGFmdGVyIGFsbCBvdGhlciBhIGhpZ2hlciBwcmlvcml0eSB2YWx1ZSAoMTAgZm9yIGV4YW1wbGUpIG11c3QgYmUgc2V0LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTeXN0ZW1zIG9ic2VydmUgd2hlbiBlbnRpdGllcyBtYXRjaCB0aGVpciB0eXBlcyBvciBubyBsb25nZXIgbWF0Y2ggdGhlaXIgdHlwZXMsIG92ZXJyaWRlXHJcbiAgICAgKiBAcGFyYW0gX2VudGl0eUFkZGVkT3JSZW1vdmVkXHJcbiAgICAgKi9cclxuICAgIG5vdGlmeShfZW50aXR5QWRkZWRPclJlbW92ZWQpIHtcclxuICAgICAgICAvLyBPdmVycmlkZSBtZVxyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBbiBbW0VudGl0eV1dIHdpdGggW1tDb21wb25lbnRdXSB0eXBlcyB0aGF0IG1hdGNoZXMgYSBbW1N5c3RlbV1dIHR5cGVzIGV4aXN0cyBpbiB0aGUgY3VycmVudCBzY2VuZS5cclxuICovXHJcbmNsYXNzIEFkZGVkRW50aXR5IHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGEpIHtcclxuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xyXG4gICAgICAgIHRoaXMudHlwZSA9ICdFbnRpdHkgQWRkZWQnO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBUeXBlIGd1YXJkIHRvIGNoZWNrIGZvciBBZGRlZEVudGl0eSBtZXNzYWdlc1xyXG4gKiBAcGFyYW0geFxyXG4gKi9cclxuZnVuY3Rpb24gaXNBZGRlZFN5c3RlbUVudGl0eSh4KSB7XHJcbiAgICByZXR1cm4gISF4ICYmIHgudHlwZSA9PT0gJ0VudGl0eSBBZGRlZCc7XHJcbn1cclxuLyoqXHJcbiAqIEFuIFtbRW50aXR5XV0gd2l0aCBbW0NvbXBvbmVudF1dIHR5cGVzIHRoYXQgbm8gbG9uZ2VyIG1hdGNoZXMgYSBbW1N5c3RlbV1dIHR5cGVzIGV4aXN0cyBpbiB0aGUgY3VycmVudCBzY2VuZS5cclxuICovXHJcbmNsYXNzIFJlbW92ZWRFbnRpdHkge1xyXG4gICAgY29uc3RydWN0b3IoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XHJcbiAgICAgICAgdGhpcy50eXBlID0gJ0VudGl0eSBSZW1vdmVkJztcclxuICAgIH1cclxufVxyXG4vKipcclxuICogdHlwZSBndWFyZCB0byBjaGVjayBmb3IgdGhlIFJlbW92ZWRFbnRpdHkgbWVzc2FnZVxyXG4gKi9cclxuZnVuY3Rpb24gaXNSZW1vdmVTeXN0ZW1FbnRpdHkoeCkge1xyXG4gICAgcmV0dXJuICEheCAmJiB4LnR5cGUgPT09ICdFbnRpdHkgUmVtb3ZlZCc7XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FbnRpdHlDb21wb25lbnRTeXN0ZW0vRW50aXR5TWFuYWdlci50c1xuXHJcblxyXG4vLyBBZGQvUmVtb3ZlIGVudGl0eXMgYW5kIGNvbXBvbmVudHNcclxuY2xhc3MgRW50aXR5TWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfd29ybGQpIHtcclxuICAgICAgICB0aGlzLl93b3JsZCA9IF93b3JsZDtcclxuICAgICAgICB0aGlzLmVudGl0aWVzID0gW107XHJcbiAgICAgICAgdGhpcy5fZW50aXR5SW5kZXggPSB7fTtcclxuICAgICAgICB0aGlzLl9lbnRpdGllc1RvUmVtb3ZlID0gW107XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJ1bnMgdGhlIGVudGl0eSBsaWZlY3ljbGVcclxuICAgICAqIEBwYXJhbSBfY29udGV4dFxyXG4gICAgICovXHJcbiAgICB1cGRhdGVFbnRpdGllcyhfY29udGV4dCwgZWxhcHNlZCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBpcyB0aGlzIHJpZ2h0P1xyXG4gICAgICAgICAgICBlbnRpdHkudXBkYXRlKF9jb250ZXh0LmVuZ2luZSwgZWxhcHNlZCk7XHJcbiAgICAgICAgICAgIGlmICghZW50aXR5LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFbnRpdHkoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZpbmRFbnRpdGllc0ZvclJlbW92YWwoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5lbnRpdGllcykge1xyXG4gICAgICAgICAgICBpZiAoIWVudGl0eS5hY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVudGl0eU1hbmFnZXIgb2JzZXJ2ZXMgY2hhbmdlcyBvbiBlbnRpdGllc1xyXG4gICAgICogQHBhcmFtIG1lc3NhZ2VcclxuICAgICAqL1xyXG4gICAgbm90aWZ5KG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoaXNBZGRlZENvbXBvbmVudChtZXNzYWdlKSkge1xyXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRoZSBjb21wb25lbnQsIGl0J3MgYWxyZWFkeSBvbiB0aGUgZW50aXR5XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkLnF1ZXJ5TWFuYWdlci5hZGRFbnRpdHkobWVzc2FnZS5kYXRhLmVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1JlbW92ZWRDb21wb25lbnQobWVzc2FnZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fd29ybGQucXVlcnlNYW5hZ2VyLnJlbW92ZUNvbXBvbmVudChtZXNzYWdlLmRhdGEuZW50aXR5LCBtZXNzYWdlLmRhdGEuY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYW4gZW50aXR5IHRvIGJlIHRyYWNrZWQgYnkgdGhlIEVudGl0eU1hbmFnZXJcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgYWRkRW50aXR5KGVudGl0eSkge1xyXG4gICAgICAgIGVudGl0eS5hY3RpdmUgPSB0cnVlO1xyXG4gICAgICAgIGlmIChlbnRpdHkgJiYgIXRoaXMuX2VudGl0eUluZGV4W2VudGl0eS5pZF0pIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXR5SW5kZXhbZW50aXR5LmlkXSA9IGVudGl0eTtcclxuICAgICAgICAgICAgdGhpcy5lbnRpdGllcy5wdXNoKGVudGl0eSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3dvcmxkLnF1ZXJ5TWFuYWdlci5hZGRFbnRpdHkoZW50aXR5KTtcclxuICAgICAgICAgICAgZW50aXR5LmNvbXBvbmVudEFkZGVkJC5yZWdpc3Rlcih0aGlzKTtcclxuICAgICAgICAgICAgZW50aXR5LmNvbXBvbmVudFJlbW92ZWQkLnJlZ2lzdGVyKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyBpZiBlbnRpdHkgaGFzIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIGVudGl0eS5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB0aGlzLmFkZEVudGl0eShjKSk7XHJcbiAgICAgICAgICAgIGVudGl0eS5jaGlsZHJlbkFkZGVkJC5yZWdpc3Rlcih7XHJcbiAgICAgICAgICAgICAgICBub3RpZnk6IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRFbnRpdHkoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBlbnRpdHkuY2hpbGRyZW5SZW1vdmVkJC5yZWdpc3Rlcih7XHJcbiAgICAgICAgICAgICAgICBub3RpZnk6IChlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFbnRpdHkoZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmVFbnRpdHkoaWRPckVudGl0eSwgZGVmZXJyZWQgPSB0cnVlKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGxldCBpZCA9IDA7XHJcbiAgICAgICAgaWYgKGlkT3JFbnRpdHkgaW5zdGFuY2VvZiBFbnRpdHkpIHtcclxuICAgICAgICAgICAgaWQgPSBpZE9yRW50aXR5LmlkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWQgPSBpZE9yRW50aXR5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLl9lbnRpdHlJbmRleFtpZF07XHJcbiAgICAgICAgaWYgKGVudGl0eSAmJiBlbnRpdHkuYWN0aXZlKSB7XHJcbiAgICAgICAgICAgIGVudGl0eS5raWxsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbnRpdHkgJiYgZGVmZXJyZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW50aXRpZXNUb1JlbW92ZS5wdXNoKGVudGl0eSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGVsZXRlIHRoaXMuX2VudGl0eUluZGV4W2lkXTtcclxuICAgICAgICBpZiAoZW50aXR5KSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUl0ZW1Gcm9tQXJyYXkoZW50aXR5LCB0aGlzLmVudGl0aWVzKTtcclxuICAgICAgICAgICAgdGhpcy5fd29ybGQucXVlcnlNYW5hZ2VyLnJlbW92ZUVudGl0eShlbnRpdHkpO1xyXG4gICAgICAgICAgICBlbnRpdHkuY29tcG9uZW50QWRkZWQkLnVucmVnaXN0ZXIodGhpcyk7XHJcbiAgICAgICAgICAgIGVudGl0eS5jb21wb25lbnRSZW1vdmVkJC51bnJlZ2lzdGVyKHRoaXMpO1xyXG4gICAgICAgICAgICAvLyBpZiBlbnRpdHkgaGFzIGNoaWxkcmVuXHJcbiAgICAgICAgICAgIGVudGl0eS5jaGlsZHJlbi5mb3JFYWNoKChjKSA9PiB0aGlzLnJlbW92ZUVudGl0eShjLCBkZWZlcnJlZCkpO1xyXG4gICAgICAgICAgICBlbnRpdHkuY2hpbGRyZW5BZGRlZCQuY2xlYXIoKTtcclxuICAgICAgICAgICAgZW50aXR5LmNoaWxkcmVuUmVtb3ZlZCQuY2xlYXIoKTtcclxuICAgICAgICAgICAgLy8gc3RhdHNcclxuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMuX3dvcmxkLmNvbnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lbmdpbmUpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmxkLmNvbnRleHQuZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5hY3RvcnMua2lsbGVkKys7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBwcm9jZXNzRW50aXR5UmVtb3ZhbHMoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5fZW50aXRpZXNUb1JlbW92ZSkge1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5LmFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVFbnRpdHkoZW50aXR5LCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcHJvY2Vzc0NvbXBvbmVudFJlbW92YWxzKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIHRoaXMuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgZW50aXR5LnByb2Nlc3NDb21wb25lbnRSZW1vdmFsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0QnlJZChpZCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9lbnRpdHlJbmRleFtpZF07XHJcbiAgICB9XHJcbiAgICBnZXRCeU5hbWUobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVudGl0aWVzLmZpbHRlcihlID0+IGUubmFtZSA9PT0gbmFtZSk7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiB0aGlzLmVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRW50aXR5Q29tcG9uZW50U3lzdGVtL1V0aWwudHNcbmNvbnN0IGJ1aWxkVHlwZUtleSA9ICh0eXBlcykgPT4ge1xyXG4gICAgY29uc3Qga2V5ID0gWy4uLnR5cGVzXS5zb3J0KChhLCBiKSA9PiBhLmxvY2FsZUNvbXBhcmUoYikpLmpvaW4oJysnKTtcclxuICAgIHJldHVybiBrZXk7XHJcbn07XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRW50aXR5Q29tcG9uZW50U3lzdGVtL1F1ZXJ5LnRzXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHF1ZXJ5IGZvciBlbnRpdGllcyB0aGF0IG1hdGNoIGEgbGlzdCBvZiB0eXBlcyB0aGF0IGlzIGNhY2hlZCBhbmQgb2JzZXJ2YWJsZVxyXG4gKlxyXG4gKiBRdWVyaWVzIGNhbiBiZSBzdHJvbmdseSB0eXBlZCBieSBzdXBwbHlpbmcgYSB0eXBlIHVuaW9uIGluIHRoZSBvcHRpb25hbCB0eXBlIHBhcmFtZXRlclxyXG4gKiBgYGB0eXBlc2NyaXB0XHJcbiAqIGNvbnN0IHF1ZXJ5QUIgPSBuZXcgZXguUXVlcnk8Q29tcG9uZW50VHlwZUEgfCBDb21wb25lbnRUeXBlQj4oWydBJywgJ0InXSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuY2xhc3MgUXVlcnkgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcclxuICAgIGNvbnN0cnVjdG9yKHR5cGVzKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLl9lbnRpdGllcyA9IFtdO1xyXG4gICAgICAgIGlmICh0eXBlc1swXSBpbnN0YW5jZW9mIEZ1bmN0aW9uKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcy5tYXAoVCA9PiAobmV3IFQpLnR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy50eXBlcyA9IHR5cGVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBrZXkoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2tleSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fa2V5O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gKHRoaXMuX2tleSA9IGJ1aWxkVHlwZUtleSh0aGlzLnR5cGVzKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGVudGl0aWVzIHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNvcnQgT3B0aW9uYWwgc29ydGluZyBmdW5jdGlvbiB0byBzb3J0IGVudGl0aWVzIHJldHVybmVkIGZyb20gdGhlIHF1ZXJ5XHJcbiAgICAgKi9cclxuICAgIGdldEVudGl0aWVzKHNvcnQpIHtcclxuICAgICAgICBpZiAoc29ydCkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbnRpdGllcy5zb3J0KHNvcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fZW50aXRpZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBhbiBlbnRpdHkgdG8gdGhlIHF1ZXJ5LCB3aWxsIG9ubHkgYmUgYWRkZWQgaWYgdGhlIGVudGl0eSBtYXRjaGVzIHRoZSBxdWVyeSB0eXBlc1xyXG4gICAgICogQHBhcmFtIGVudGl0eVxyXG4gICAgICovXHJcbiAgICBhZGRFbnRpdHkoZW50aXR5KSB7XHJcbiAgICAgICAgaWYgKCFjb250YWlucyh0aGlzLl9lbnRpdGllcywgZW50aXR5KSAmJiB0aGlzLm1hdGNoZXMoZW50aXR5KSkge1xyXG4gICAgICAgICAgICB0aGlzLl9lbnRpdGllcy5wdXNoKGVudGl0eSk7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZ5QWxsKG5ldyBBZGRlZEVudGl0eShlbnRpdHkpKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElmIHRoZSBlbnRpdHkgaXMgcGFydCBvZiB0aGUgcXVlcnkgaXQgd2lsbCBiZSByZW1vdmVkIHJlZ2FyZGxlc3Mgb2YgdHlwZXNcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlRW50aXR5KGVudGl0eSkge1xyXG4gICAgICAgIGlmIChyZW1vdmVJdGVtRnJvbUFycmF5KGVudGl0eSwgdGhpcy5fZW50aXRpZXMpKSB7XHJcbiAgICAgICAgICAgIHRoaXMubm90aWZ5QWxsKG5ldyBSZW1vdmVkRW50aXR5KGVudGl0eSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbGwgZW50aXRpZXMgYW5kIG9ic2VydmVycyBmcm9tIHRoZSBxdWVyeVxyXG4gICAgICovXHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLl9lbnRpdGllcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgdGhpcy5vYnNlcnZlcnMpIHtcclxuICAgICAgICAgICAgdGhpcy51bnJlZ2lzdGVyKG9ic2VydmVyKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBtYXRjaGVzKHR5cGVzT3JFbnRpdHkpIHtcclxuICAgICAgICBsZXQgdHlwZXMgPSBbXTtcclxuICAgICAgICBpZiAodHlwZXNPckVudGl0eSBpbnN0YW5jZW9mIEVudGl0eSkge1xyXG4gICAgICAgICAgICB0eXBlcyA9IHR5cGVzT3JFbnRpdHkudHlwZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0eXBlcyA9IHR5cGVzT3JFbnRpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBtYXRjaGVzID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdGhpcy50eXBlcykge1xyXG4gICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcyAmJiB0eXBlcy5pbmRleE9mKHR5cGUpID4gLTE7XHJcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXRjaGVzO1xyXG4gICAgfVxyXG4gICAgY29udGFpbih0eXBlKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZXMuaW5kZXhPZih0eXBlKSA+IC0xO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRW50aXR5Q29tcG9uZW50U3lzdGVtL1F1ZXJ5TWFuYWdlci50c1xuXHJcblxyXG4vKipcclxuICogVGhlIHF1ZXJ5IG1hbmFnZXIgaXMgcmVzcG9uc2libGUgZm9yIHVwZGF0aW5nIGFsbCBxdWVyaWVzIHdoZW4gZW50aXRpZXMvY29tcG9uZW50cyBjaGFuZ2VcclxuICovXHJcbmNsYXNzIFF1ZXJ5TWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfd29ybGQpIHtcclxuICAgICAgICB0aGlzLl93b3JsZCA9IF93b3JsZDtcclxuICAgICAgICB0aGlzLl9xdWVyaWVzID0ge307XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBxdWVyeSB0byB0aGUgbWFuYWdlciBhbmQgcG9wdWxhdGVzIHdpdGggYW55IGVudGl0aWVzIHRoYXQgbWF0Y2hcclxuICAgICAqIEBwYXJhbSBxdWVyeVxyXG4gICAgICovXHJcbiAgICBfYWRkUXVlcnkocXVlcnkpIHtcclxuICAgICAgICB0aGlzLl9xdWVyaWVzW2J1aWxkVHlwZUtleShxdWVyeS50eXBlcyldID0gcXVlcnk7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgdGhpcy5fd29ybGQuZW50aXR5TWFuYWdlci5lbnRpdGllcykge1xyXG4gICAgICAgICAgICBxdWVyeS5hZGRFbnRpdHkoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgdGhlIHF1ZXJ5IGlmIHRoZXJlIGFyZSBubyBvYnNlcnZlcnMgbGVmdFxyXG4gICAgICogQHBhcmFtIHF1ZXJ5XHJcbiAgICAgKi9cclxuICAgIG1heWJlUmVtb3ZlUXVlcnkocXVlcnkpIHtcclxuICAgICAgICBpZiAocXVlcnkub2JzZXJ2ZXJzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICBxdWVyeS5jbGVhcigpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fcXVlcmllc1tidWlsZFR5cGVLZXkocXVlcnkudHlwZXMpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgdGhlIGVudGl0eSB0byBhbnkgbWF0Y2hpbmcgcXVlcnkgaW4gdGhlIHF1ZXJ5IG1hbmFnZVxyXG4gICAgICogQHBhcmFtIGVudGl0eVxyXG4gICAgICovXHJcbiAgICBhZGRFbnRpdHkoZW50aXR5KSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBxdWVyeVR5cGUgaW4gdGhpcy5fcXVlcmllcykge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcXVlcmllc1txdWVyeVR5cGVdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWVyaWVzW3F1ZXJ5VHlwZV0uYWRkRW50aXR5KGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gZW50aXR5IGZyb20gcXVlcmllcyBpZiB0aGUgcmVtb3ZlZCBjb21wb25lbnQgZGlzcXVhbGlmaWVzIGl0XHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUNvbXBvbmVudChlbnRpdHksIGNvbXBvbmVudCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgcXVlcnlUeXBlIGluIHRoaXMuX3F1ZXJpZXMpIHtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIGNvbXBvbmVudCBiZWluZyByZW1vdmVkIGZyb20gYW4gZW50aXR5IGlzIGEgcGFydCBvZiBhIHF1ZXJ5LFxyXG4gICAgICAgICAgICAvLyBpdCBpcyBub3cgZGlzcXVhbGlmaWVkIGZyb20gdGhhdCBxdWVyeSwgcmVtb3ZlIGl0XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9xdWVyaWVzW3F1ZXJ5VHlwZV0uY29udGFpbihjb21wb25lbnQudHlwZSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXJpZXNbcXVlcnlUeXBlXS5yZW1vdmVFbnRpdHkoZW50aXR5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVtb3ZlcyBhbiBlbnRpdHkgZnJvbSBhbGwgcXVlcmllcyBpdCBpcyBjdXJyZW50bHkgYSBwYXJ0IG9mXHJcbiAgICAgKiBAcGFyYW0gZW50aXR5XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUVudGl0eShlbnRpdHkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHF1ZXJ5VHlwZSBpbiB0aGlzLl9xdWVyaWVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3F1ZXJpZXNbcXVlcnlUeXBlXS5yZW1vdmVFbnRpdHkoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBwb3B1bGF0ZWQgcXVlcnkgYW5kIHJldHVybnMsIGlmIHRoZSBxdWVyeSBhbHJlYWR5IGV4aXN0cyB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgaW5zdGVhZCBvZiBhIG5ldyBpbnN0YW5jZVxyXG4gICAgICogQHBhcmFtIHR5cGVzXHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZVF1ZXJ5KHR5cGVzKSB7XHJcbiAgICAgICAgY29uc3QgbWF5YmVFeGlzdGluZ1F1ZXJ5ID0gdGhpcy5nZXRRdWVyeSh0eXBlcyk7XHJcbiAgICAgICAgaWYgKG1heWJlRXhpc3RpbmdRdWVyeSkge1xyXG4gICAgICAgICAgICByZXR1cm4gbWF5YmVFeGlzdGluZ1F1ZXJ5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBxdWVyeSA9IG5ldyBRdWVyeSh0eXBlcyk7XHJcbiAgICAgICAgdGhpcy5fYWRkUXVlcnkocXVlcnkpO1xyXG4gICAgICAgIHJldHVybiBxdWVyeTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0cmlldmVzIGFuIGV4aXN0aW5nIHF1ZXJ5IGJ5IHR5cGVzIGlmIGl0IGV4aXN0cyBvdGhlcndpc2UgcmV0dXJucyBudWxsXHJcbiAgICAgKiBAcGFyYW0gdHlwZXNcclxuICAgICAqL1xyXG4gICAgZ2V0UXVlcnkodHlwZXMpIHtcclxuICAgICAgICBjb25zdCBrZXkgPSBidWlsZFR5cGVLZXkodHlwZXMpO1xyXG4gICAgICAgIGlmICh0aGlzLl9xdWVyaWVzW2tleV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3F1ZXJpZXNba2V5XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9FbnRpdHlDb21wb25lbnRTeXN0ZW0vU3lzdGVtTWFuYWdlci50c1xuXHJcbi8qKlxyXG4gKiBUaGUgU3lzdGVtTWFuYWdlciBpcyByZXNwb25zaWJsZSBmb3Iga2VlcGluZyB0cmFjayBvZiBhbGwgc3lzdGVtcyBpbiBhIHNjZW5lLlxyXG4gKiBTeXN0ZW1zIGFyZSBzY2VuZSBzcGVjaWZpY1xyXG4gKi9cclxuY2xhc3MgU3lzdGVtTWFuYWdlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihfd29ybGQpIHtcclxuICAgICAgICB0aGlzLl93b3JsZCA9IF93b3JsZDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBMaXN0IG9mIHN5c3RlbXMsIHRvIGFkZCBhIG5ldyBzeXN0ZW0gY2FsbCBbW1N5c3RlbU1hbmFnZXIuYWRkU3lzdGVtXV1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN5c3RlbXMgPSBbXTtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldCBhIHN5c3RlbSByZWdpc3RlcmVkIGluIHRoZSBtYW5hZ2VyIGJ5IHR5cGVcclxuICAgICAqIEBwYXJhbSBzeXN0ZW1UeXBlXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBnZXQoc3lzdGVtVHlwZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnN5c3RlbXMuZmluZCgocykgPT4gcyBpbnN0YW5jZW9mIHN5c3RlbVR5cGUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgc3lzdGVtIHRvIHRoZSBtYW5hZ2VyLCBpdCB3aWxsIG5vdyBiZSB1cGRhdGVkIGV2ZXJ5IGZyYW1lXHJcbiAgICAgKiBAcGFyYW0gc3lzdGVtXHJcbiAgICAgKi9cclxuICAgIGFkZFN5c3RlbShzeXN0ZW0pIHtcclxuICAgICAgICAvLyB2YWxpZGF0ZSBzeXN0ZW0gaGFzIHR5cGVzXHJcbiAgICAgICAgaWYgKCFzeXN0ZW0udHlwZXMgfHwgc3lzdGVtLnR5cGVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEF0dGVtcHRlZCB0byBhZGQgYSBTeXN0ZW0gd2l0aG91dCBhbnkgdHlwZXNgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLl93b3JsZC5xdWVyeU1hbmFnZXIuY3JlYXRlUXVlcnkoc3lzdGVtLnR5cGVzKTtcclxuICAgICAgICB0aGlzLnN5c3RlbXMucHVzaChzeXN0ZW0pO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtcy5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XHJcbiAgICAgICAgcXVlcnkucmVnaXN0ZXIoc3lzdGVtKTtcclxuICAgICAgICBpZiAodGhpcy5pbml0aWFsaXplZCAmJiBzeXN0ZW0uaW5pdGlhbGl6ZSkge1xyXG4gICAgICAgICAgICBzeXN0ZW0uaW5pdGlhbGl6ZSh0aGlzLl93b3JsZC5jb250ZXh0KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBzeXN0ZW0gZnJvbSB0aGUgbWFuYWdlciwgaXQgd2lsbCBubyBsb25nZXIgYmUgdXBkYXRlZFxyXG4gICAgICogQHBhcmFtIHN5c3RlbVxyXG4gICAgICovXHJcbiAgICByZW1vdmVTeXN0ZW0oc3lzdGVtKSB7XHJcbiAgICAgICAgcmVtb3ZlSXRlbUZyb21BcnJheShzeXN0ZW0sIHRoaXMuc3lzdGVtcyk7XHJcbiAgICAgICAgY29uc3QgcXVlcnkgPSB0aGlzLl93b3JsZC5xdWVyeU1hbmFnZXIuZ2V0UXVlcnkoc3lzdGVtLnR5cGVzKTtcclxuICAgICAgICBpZiAocXVlcnkpIHtcclxuICAgICAgICAgICAgcXVlcnkudW5yZWdpc3RlcihzeXN0ZW0pO1xyXG4gICAgICAgICAgICB0aGlzLl93b3JsZC5xdWVyeU1hbmFnZXIubWF5YmVSZW1vdmVRdWVyeShxdWVyeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGVzIGFsbCBzeXN0ZW1zXHJcbiAgICAgKiBAcGFyYW0gdHlwZSB3aGV0aGVyIHRoaXMgaXMgYW4gdXBkYXRlIG9yIGRyYXcgc3lzdGVtXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCBjb250ZXh0IHJlZmVyZW5jZVxyXG4gICAgICogQHBhcmFtIGRlbHRhIHRpbWUgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZVN5c3RlbXModHlwZSwgY29udGV4dCwgZGVsdGEpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLnN5c3RlbXMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzLmluaXRpYWxpemUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzLmluaXRpYWxpemUodGhpcy5fd29ybGQuY29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgc3lzdGVtcyA9IHRoaXMuc3lzdGVtcy5maWx0ZXIoKHMpID0+IHMuc3lzdGVtVHlwZSA9PT0gdHlwZSk7XHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHN5c3RlbXMpIHtcclxuICAgICAgICAgICAgaWYgKHMucHJldXBkYXRlKSB7XHJcbiAgICAgICAgICAgICAgICBzLnByZXVwZGF0ZShjb250ZXh0LCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHN5c3RlbXMpIHtcclxuICAgICAgICAgICAgLy8gR2V0IGVudGl0aWVzIHRoYXQgbWF0Y2ggdGhlIHN5c3RlbSB0eXBlcywgcHJlLXNvcnRcclxuICAgICAgICAgICAgY29uc3QgZW50aXRpZXMgPSB0aGlzLl93b3JsZC5xdWVyeU1hbmFnZXIuZ2V0UXVlcnkocy50eXBlcykuZ2V0RW50aXRpZXMocy5zb3J0KTtcclxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSBlbnRpdGllcyBpZiBuZWVkZWRcclxuICAgICAgICAgICAgaWYgKGNvbnRleHQgaW5zdGFuY2VvZiBTY2VuZSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBlbnRpdHkuX2luaXRpYWxpemUoY29udGV4dCA9PT0gbnVsbCB8fCBjb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250ZXh0LmVuZ2luZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcy51cGRhdGUoZW50aXRpZXMsIGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHN5c3RlbXMpIHtcclxuICAgICAgICAgICAgaWYgKHMucG9zdHVwZGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgcy5wb3N0dXBkYXRlKGNvbnRleHQsIGRlbHRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIHRoaXMuc3lzdGVtcykge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVN5c3RlbShzeXN0ZW0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9Xb3JsZC50c1xuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFdvcmxkIGlzIGEgc2VsZi1jb250YWluZWQgZW50aXR5IGNvbXBvbmVudCBzeXN0ZW0gZm9yIGEgcGFydGljdWxhciBjb250ZXh0LlxyXG4gKi9cclxuY2xhc3MgV29ybGQge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgY29udGV4dCB0eXBlIGlzIHBhc3NlZCB0byB0aGUgc3lzdGVtIHVwZGF0ZXNcclxuICAgICAqIEBwYXJhbSBjb250ZXh0XHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcclxuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xyXG4gICAgICAgIHRoaXMucXVlcnlNYW5hZ2VyID0gbmV3IFF1ZXJ5TWFuYWdlcih0aGlzKTtcclxuICAgICAgICB0aGlzLmVudGl0eU1hbmFnZXIgPSBuZXcgRW50aXR5TWFuYWdlcih0aGlzKTtcclxuICAgICAgICB0aGlzLnN5c3RlbU1hbmFnZXIgPSBuZXcgU3lzdGVtTWFuYWdlcih0aGlzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHN5c3RlbXMgYnkgdHlwZSBhbmQgdGltZSBlbGFwc2VkIGluIG1pbGxpc2Vjb25kc1xyXG4gICAgICovXHJcbiAgICB1cGRhdGUodHlwZSwgZGVsdGEpIHtcclxuICAgICAgICBpZiAodHlwZSA9PT0gU3lzdGVtVHlwZS5VcGRhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyLnVwZGF0ZUVudGl0aWVzKHRoaXMuY29udGV4dCwgZGVsdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnN5c3RlbU1hbmFnZXIudXBkYXRlU3lzdGVtcyh0eXBlLCB0aGlzLmNvbnRleHQsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLmVudGl0eU1hbmFnZXIuZmluZEVudGl0aWVzRm9yUmVtb3ZhbCgpO1xyXG4gICAgICAgIHRoaXMuZW50aXR5TWFuYWdlci5wcm9jZXNzQ29tcG9uZW50UmVtb3ZhbHMoKTtcclxuICAgICAgICB0aGlzLmVudGl0eU1hbmFnZXIucHJvY2Vzc0VudGl0eVJlbW92YWxzKCk7XHJcbiAgICB9XHJcbiAgICBhZGQoZW50aXR5T3JTeXN0ZW0pIHtcclxuICAgICAgICBpZiAoZW50aXR5T3JTeXN0ZW0gaW5zdGFuY2VvZiBFbnRpdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5lbnRpdHlNYW5hZ2VyLmFkZEVudGl0eShlbnRpdHlPclN5c3RlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbnRpdHlPclN5c3RlbSBpbnN0YW5jZW9mIFN5c3RlbSkge1xyXG4gICAgICAgICAgICB0aGlzLnN5c3RlbU1hbmFnZXIuYWRkU3lzdGVtKGVudGl0eU9yU3lzdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmUoZW50aXR5T3JTeXN0ZW0sIGRlZmVycmVkID0gdHJ1ZSkge1xyXG4gICAgICAgIGlmIChlbnRpdHlPclN5c3RlbSBpbnN0YW5jZW9mIEVudGl0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmVudGl0eU1hbmFnZXIucmVtb3ZlRW50aXR5KGVudGl0eU9yU3lzdGVtLCBkZWZlcnJlZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbnRpdHlPclN5c3RlbSBpbnN0YW5jZW9mIFN5c3RlbSkge1xyXG4gICAgICAgICAgICB0aGlzLnN5c3RlbU1hbmFnZXIucmVtb3ZlU3lzdGVtKGVudGl0eU9yU3lzdGVtKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjbGVhckVudGl0aWVzKCkge1xyXG4gICAgICAgIHRoaXMuZW50aXR5TWFuYWdlci5jbGVhcigpO1xyXG4gICAgfVxyXG4gICAgY2xlYXJTeXN0ZW1zKCkge1xyXG4gICAgICAgIHRoaXMuc3lzdGVtTWFuYWdlci5jbGVhcigpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0ludGVncmF0b3IudHNcbmNsYXNzIEV1bGVySW50ZWdyYXRvciB7XHJcbiAgICBzdGF0aWMgaW50ZWdyYXRlKHRyYW5zZm9ybSwgbW90aW9uLCB0b3RhbEFjYywgZWxhcHNlZE1zKSB7XHJcbiAgICAgICAgY29uc3Qgc2Vjb25kcyA9IGVsYXBzZWRNcyAvIDEwMDA7XHJcbiAgICAgICAgbW90aW9uLnZlbC5hZGRFcXVhbCh0b3RhbEFjYy5zY2FsZShzZWNvbmRzKSk7XHJcbiAgICAgICAgdHJhbnNmb3JtLnBvcy5hZGRFcXVhbChtb3Rpb24udmVsLnNjYWxlKHNlY29uZHMpKS5hZGRFcXVhbCh0b3RhbEFjYy5zY2FsZSgwLjUgKiBzZWNvbmRzICogc2Vjb25kcykpO1xyXG4gICAgICAgIG1vdGlvbi5hbmd1bGFyVmVsb2NpdHkgKz0gbW90aW9uLnRvcnF1ZSAqICgxLjAgLyBtb3Rpb24uaW5lcnRpYSkgKiBzZWNvbmRzO1xyXG4gICAgICAgIHRyYW5zZm9ybS5yb3RhdGlvbiArPSBtb3Rpb24uYW5ndWxhclZlbG9jaXR5ICogc2Vjb25kcztcclxuICAgICAgICB0cmFuc2Zvcm0uc2NhbGUuYWRkRXF1YWwobW90aW9uLnNjYWxlRmFjdG9yLnNjYWxlKHNlY29uZHMpKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Nb3Rpb25TeXN0ZW0udHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBNb3Rpb25TeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGVzID0gWydleC50cmFuc2Zvcm0nLCAnZXgubW90aW9uJ107XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1UeXBlID0gU3lzdGVtVHlwZS5VcGRhdGU7XHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IC0xO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9lbnRpdGllcywgZWxhcHNlZE1zKSB7XHJcbiAgICAgICAgbGV0IHRyYW5zZm9ybTtcclxuICAgICAgICBsZXQgbW90aW9uO1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIF9lbnRpdGllcykge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIG1vdGlvbiA9IGVudGl0eS5nZXQoTW90aW9uQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9uYWxCb2R5ID0gZW50aXR5LmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbmFsQm9keSA9PT0gbnVsbCB8fCBvcHRpb25hbEJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbmFsQm9keS5zbGVlcGluZykge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgdG90YWxBY2MgPSBtb3Rpb24uYWNjLmNsb25lKCk7XHJcbiAgICAgICAgICAgIGlmICgob3B0aW9uYWxCb2R5ID09PSBudWxsIHx8IG9wdGlvbmFsQm9keSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uYWxCb2R5LmNvbGxpc2lvblR5cGUpID09PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSAmJiAob3B0aW9uYWxCb2R5ID09PSBudWxsIHx8IG9wdGlvbmFsQm9keSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9uYWxCb2R5LnVzZUdyYXZpdHkpKSB7XHJcbiAgICAgICAgICAgICAgICB0b3RhbEFjYy5hZGRFcXVhbChQaHlzaWNzLmdyYXZpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wdGlvbmFsQm9keSA9PT0gbnVsbCB8fCBvcHRpb25hbEJvZHkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbmFsQm9keS5jYXB0dXJlT2xkVHJhbnNmb3JtKCk7XHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0cmFuc2Zvcm0gYW5kIG1vdGlvbiBiYXNlZCBvbiBFdWxlciBsaW5lYXIgYWxnZWJyYVxyXG4gICAgICAgICAgICBFdWxlckludGVncmF0b3IuaW50ZWdyYXRlKHRyYW5zZm9ybSwgbW90aW9uLCB0b3RhbEFjYywgZWxhcHNlZE1zKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBkZWJ1Z0RyYXcoX2N0eCkge1xyXG4gICAgICAgIC8vIHBhc3NcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Tb2x2ZXIvU29sdmVyLnRzXG4vKipcclxuICogQSBjb2xsaXNpb24gc29sdmVyIGZpZ3VyZXMgb3V0IGhvdyB0byBwb3NpdGlvbiBjb2xsaWRlcnMgc3VjaCB0aGF0IHRoZXkgYXJlIG5vIGxvbmdlciBvdmVybGFwcGluZ1xyXG4gKlxyXG4gKiBTb2x2ZXJzIGFyZSBleGVjdXRlZCBpbiB0aGUgb3JkZXJcclxuICpcclxuICogMS4gcHJlU29sdmVcclxuICogMi4gc29sdmVWZWxvY2l0eVxyXG4gKiAzLiBzb2x2ZVBvc2l0aW9uXHJcbiAqIDQuIHBvc3RTb2x2ZVxyXG4gKiBAaW5oZXJpdGRvY1xyXG4gKi9cclxuY2xhc3MgQ29sbGlzaW9uU29sdmVyIHtcclxuICAgIC8qKlxyXG4gICAgICogU29sdmVzIG92ZXJsYXBwaW5nIGNvbnRhY3QgaW5cclxuICAgICAqXHJcbiAgICAgKiBTb2x2ZXJzIGFyZSBleGVjdXRlZCBpbiB0aGUgb3JkZXJcclxuICAgICAqIDEuIHByZVNvbHZlXHJcbiAgICAgKiAyLiBzb2x2ZVZlbG9jaXR5XHJcbiAgICAgKiAzLiBzb2x2ZVBvc2l0aW9uXHJcbiAgICAgKiA0LiBwb3N0U29sdmVcclxuICAgICAqIEBwYXJhbSBjb250YWN0c1xyXG4gICAgICovXHJcbiAgICBzb2x2ZShjb250YWN0cykge1xyXG4gICAgICAgIC8vIEV2ZW50cyBhbmQgaW5pdFxyXG4gICAgICAgIHRoaXMucHJlU29sdmUoY29udGFjdHMpO1xyXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgY2FuY2VsZWQgY29udGFjdHNcclxuICAgICAgICBjb250YWN0cyA9IGNvbnRhY3RzLmZpbHRlcihjID0+ICFjLmlzQ2FuY2VsZWQoKSk7XHJcbiAgICAgICAgLy8gU29sdmUgdmVsb2NpdHkgZmlyc3RcclxuICAgICAgICB0aGlzLnNvbHZlVmVsb2NpdHkoY29udGFjdHMpO1xyXG4gICAgICAgIC8vIFNvbHZlIHBvc2l0aW9uIGxhc3QgYmVjYXVzZSBub24tb3ZlcmxhcCBpcyB0aGUgbW9zdCBpbXBvcnRhbnRcclxuICAgICAgICB0aGlzLnNvbHZlUG9zaXRpb24oY29udGFjdHMpO1xyXG4gICAgICAgIC8vIEV2ZW50cyBhbmQgYW55IGNvbnRhY3QgaG91c2Uta2VlcGluZyB0aGUgc29sdmVyIG5lZWRzXHJcbiAgICAgICAgdGhpcy5wb3N0U29sdmUoY29udGFjdHMpO1xyXG4gICAgICAgIHJldHVybiBjb250YWN0cztcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Tb2x2ZXIvQXJjYWRlU29sdmVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBBcmNhZGVTb2x2ZXIgaXMgdGhlIGRlZmF1bHQgaW4gRXhjYWxpYnVyLiBJdCBzb2x2ZXMgY29sbGlzaW9ucyBzbyB0aGF0IHRoZXJlIGlzIG5vIG92ZXJsYXAgYmV0d2VlbiBjb250YWN0cyxcclxuICogYW5kIG5lZ2F0ZXMgdmVsb2NpdHkgYWxvbmcgdGhlIGNvbGxpc2lvbiBub3JtYWwuXHJcbiAqXHJcbiAqIFRoaXMgaXMgdXN1YWxseSB0aGUgdHlwZSBvZiBjb2xsaXNpb25zIHVzZWQgZm9yIDJEIGdhbWVzIHRoYXQgZG9uJ3QgbmVlZCBhIG1vcmUgcmVhbGlzdGljIGNvbGxpc2lvbiBzaW11bGF0aW9uLlxyXG4gKlxyXG4gKi9cclxuY2xhc3MgQXJjYWRlU29sdmVyIGV4dGVuZHMgQ29sbGlzaW9uU29sdmVyIHtcclxuICAgIHByZVNvbHZlKGNvbnRhY3RzKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250YWN0IG9mIGNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNpZGUgPSBTaWRlLmZyb21EaXJlY3Rpb24oY29udGFjdC5tdHYpO1xyXG4gICAgICAgICAgICBjb25zdCBtdHYgPSBjb250YWN0Lm10di5uZWdhdGUoKTtcclxuICAgICAgICAgICAgLy8gUHVibGlzaCBjb2xsaXNpb24gZXZlbnRzIG9uIGJvdGggcGFydGljaXBhbnRzXHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJBLmV2ZW50cy5lbWl0KCdwcmVjb2xsaXNpb24nLCBuZXcgUHJlQ29sbGlzaW9uRXZlbnQoY29udGFjdC5jb2xsaWRlckEsIGNvbnRhY3QuY29sbGlkZXJCLCBzaWRlLCBtdHYpKTtcclxuICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckIuZXZlbnRzLmVtaXQoJ3ByZWNvbGxpc2lvbicsIG5ldyBQcmVDb2xsaXNpb25FdmVudChjb250YWN0LmNvbGxpZGVyQiwgY29udGFjdC5jb2xsaWRlckEsIFNpZGUuZ2V0T3Bwb3NpdGUoc2lkZSksIG10di5uZWdhdGUoKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBvc3RTb2x2ZShjb250YWN0cykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250YWN0IG9mIGNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyQSA9IGNvbnRhY3QuY29sbGlkZXJBO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlckIgPSBjb250YWN0LmNvbGxpZGVyQjtcclxuICAgICAgICAgICAgY29uc3QgYm9keUEgPSAoX2EgPSBjb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvZHlCID0gKF9iID0gY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChib2R5QS5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlBhc3NpdmUgfHwgYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgc2lkZSA9IFNpZGUuZnJvbURpcmVjdGlvbihjb250YWN0Lm10dik7XHJcbiAgICAgICAgICAgIGNvbnN0IG10diA9IGNvbnRhY3QubXR2Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICAvLyBQdWJsaXNoIGNvbGxpc2lvbiBldmVudHMgb24gYm90aCBwYXJ0aWNpcGFudHNcclxuICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckEuZXZlbnRzLmVtaXQoJ3Bvc3Rjb2xsaXNpb24nLCBuZXcgUG9zdENvbGxpc2lvbkV2ZW50KGNvbnRhY3QuY29sbGlkZXJBLCBjb250YWN0LmNvbGxpZGVyQiwgc2lkZSwgbXR2KSk7XHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IFBvc3RDb2xsaXNpb25FdmVudChjb250YWN0LmNvbGxpZGVyQiwgY29udGFjdC5jb2xsaWRlckEsIFNpZGUuZ2V0T3Bwb3NpdGUoc2lkZSksIG10di5uZWdhdGUoKSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHNvbHZlUG9zaXRpb24oY29udGFjdHMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udGFjdCBvZiBjb250YWN0cykge1xyXG4gICAgICAgICAgICBsZXQgbXR2ID0gY29udGFjdC5tdHY7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyQSA9IGNvbnRhY3QuY29sbGlkZXJBO1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlckIgPSBjb250YWN0LmNvbGxpZGVyQjtcclxuICAgICAgICAgICAgY29uc3QgYm9keUEgPSAoX2EgPSBjb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvZHlCID0gKF9iID0gY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChib2R5QS5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlBhc3NpdmUgfHwgYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUgJiYgYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBzcGxpdCBvdmVybGFwcyBpZiBib3RoIGFyZSBBY3RpdmVcclxuICAgICAgICAgICAgICAgICAgICBtdHYgPSBtdHYuc2NhbGUoMC41KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgb3ZlcmxhcHNcclxuICAgICAgICAgICAgICAgIGlmIChib2R5QS5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvcy54IC09IG10di54O1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvcy55IC09IG10di55O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuQWN0aXZlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zLnggKz0gbXR2Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zLnkgKz0gbXR2Lnk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzb2x2ZVZlbG9jaXR5KGNvbnRhY3RzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJBID0gY29udGFjdC5jb2xsaWRlckE7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyQiA9IGNvbnRhY3QuY29sbGlkZXJCO1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QSA9IChfYSA9IGNvbGxpZGVyQS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgY29uc3QgYm9keUIgPSAoX2IgPSBjb2xsaWRlckIub3duZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChib2R5QSAmJiBib2R5Qikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGJvZHlBLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSB8fCBib2R5Qi5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLlBhc3NpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IGNvbnRhY3Qubm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgb3Bwb3NpdGUgPSBub3JtYWwubmVnYXRlKCk7XHJcbiAgICAgICAgICAgICAgICAvLyBDYW5jZWwgb3V0IHZlbG9jaXR5IG9wcG9zaXRlIGRpcmVjdGlvbiBvZiBjb2xsaXNpb24gbm9ybWFsXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZWxBZGogPSBub3JtYWwuc2NhbGUobm9ybWFsLmRvdChib2R5QS52ZWwubmVnYXRlKCkpKTtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS52ZWwgPSBib2R5QS52ZWwuYWRkKHZlbEFkaik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUIuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ZWxBZGogPSBvcHBvc2l0ZS5zY2FsZShvcHBvc2l0ZS5kb3QoYm9keUIudmVsLm5lZ2F0ZSgpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgYm9keUIudmVsID0gYm9keUIudmVsLmFkZCh2ZWxBZGopO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL1NvbHZlci9Db250YWN0Q29uc3RyYWludFBvaW50LnRzXG5cclxuXHJcbi8qKlxyXG4gKiBIb2xkcyBpbmZvcm1hdGlvbiBhYm91dCBjb250YWN0IHBvaW50cywgbWVhbnQgdG8gYmUgcmV1c2VkIG92ZXIgbXVsdGlwbGUgZnJhbWVzIG9mIGNvbnRhY3RcclxuICovXHJcbmNsYXNzIENvbnRhY3RDb25zdHJhaW50UG9pbnQge1xyXG4gICAgY29uc3RydWN0b3IocG9pbnQsIGxvY2FsLCBjb250YWN0KSB7XHJcbiAgICAgICAgdGhpcy5wb2ludCA9IHBvaW50O1xyXG4gICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbDtcclxuICAgICAgICB0aGlzLmNvbnRhY3QgPSBjb250YWN0O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEltcHVsc2UgYWNjdW11bGF0ZWQgb3ZlciB0aW1lIGluIG5vcm1hbCBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5vcm1hbEltcHVsc2UgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEltcHVsc2UgYWNjdW11bGF0ZWQgb3ZlciB0aW1lIGluIHRoZSB0YW5nZW50IGRpcmVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMudGFuZ2VudEltcHVsc2UgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVmZmVjdGl2ZSBtYXNzIHNlZW4gaW4gdGhlIG5vcm1hbCBkaXJlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm5vcm1hbE1hc3MgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVmZmVjdGl2ZSBtYXNzIHNlZW4gaW4gdGhlIHRhbmdlbnQgZGlyZWN0aW9uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy50YW5nZW50TWFzcyA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlyZWN0aW9uIGZyb20gY2VudGVyIG9mIG1hc3Mgb2YgYm9keUEgdG8gY29udGFjdCBwb2ludFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYVRvQ29udGFjdCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogRGlyZWN0aW9uIGZyb20gY2VudGVyIG9mIG1hc3Mgb2YgYm9keUIgdG8gY29udGFjdCBwb2ludFxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuYlRvQ29udGFjdCA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgY29udGFjdCBpbmZvcm1hdGlvblxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBjb25zdCBib2R5QSA9IChfYSA9IHRoaXMuY29udGFjdC5jb2xsaWRlckEub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgY29uc3QgYm9keUIgPSAoX2IgPSB0aGlzLmNvbnRhY3QuY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgIGlmIChib2R5QSAmJiBib2R5Qikge1xyXG4gICAgICAgICAgICBjb25zdCBub3JtYWwgPSB0aGlzLmNvbnRhY3Qubm9ybWFsO1xyXG4gICAgICAgICAgICBjb25zdCB0YW5nZW50ID0gdGhpcy5jb250YWN0LnRhbmdlbnQ7XHJcbiAgICAgICAgICAgIHRoaXMuYVRvQ29udGFjdCA9IHRoaXMucG9pbnQuc3ViKGJvZHlBLnBvcyk7XHJcbiAgICAgICAgICAgIHRoaXMuYlRvQ29udGFjdCA9IHRoaXMucG9pbnQuc3ViKGJvZHlCLnBvcyk7XHJcbiAgICAgICAgICAgIGNvbnN0IGFUb0NvbnRhY3ROb3JtYWwgPSB0aGlzLmFUb0NvbnRhY3QuY3Jvc3Mobm9ybWFsKTtcclxuICAgICAgICAgICAgY29uc3QgYlRvQ29udGFjdE5vcm1hbCA9IHRoaXMuYlRvQ29udGFjdC5jcm9zcyhub3JtYWwpO1xyXG4gICAgICAgICAgICB0aGlzLm5vcm1hbE1hc3MgPVxyXG4gICAgICAgICAgICAgICAgYm9keUEuaW52ZXJzZU1hc3MgK1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLmludmVyc2VNYXNzICtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIGFUb0NvbnRhY3ROb3JtYWwgKiBhVG9Db250YWN0Tm9ybWFsICtcclxuICAgICAgICAgICAgICAgICAgICBib2R5Qi5pbnZlcnNlSW5lcnRpYSAqIGJUb0NvbnRhY3ROb3JtYWwgKiBiVG9Db250YWN0Tm9ybWFsO1xyXG4gICAgICAgICAgICBjb25zdCBhVG9Db250YWN0VGFuZ2VudCA9IHRoaXMuYVRvQ29udGFjdC5jcm9zcyh0YW5nZW50KTtcclxuICAgICAgICAgICAgY29uc3QgYlRvQ29udGFjdFRhbmdlbnQgPSB0aGlzLmJUb0NvbnRhY3QuY3Jvc3ModGFuZ2VudCk7XHJcbiAgICAgICAgICAgIHRoaXMudGFuZ2VudE1hc3MgPVxyXG4gICAgICAgICAgICAgICAgYm9keUEuaW52ZXJzZU1hc3MgK1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLmludmVyc2VNYXNzICtcclxuICAgICAgICAgICAgICAgICAgICBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIGFUb0NvbnRhY3RUYW5nZW50ICogYVRvQ29udGFjdFRhbmdlbnQgK1xyXG4gICAgICAgICAgICAgICAgICAgIGJvZHlCLmludmVyc2VJbmVydGlhICogYlRvQ29udGFjdFRhbmdlbnQgKiBiVG9Db250YWN0VGFuZ2VudDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHJlbGF0aXZlIHZlbG9jaXR5IGJldHdlbiBib2R5QSBhbmQgYm9keUJcclxuICAgICAqL1xyXG4gICAgZ2V0UmVsYXRpdmVWZWxvY2l0eSgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGNvbnN0IGJvZHlBID0gKF9hID0gdGhpcy5jb250YWN0LmNvbGxpZGVyQS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICBjb25zdCBib2R5QiA9IChfYiA9IHRoaXMuY29udGFjdC5jb2xsaWRlckIub3duZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgaWYgKGJvZHlBICYmIGJvZHlCKSB7XHJcbiAgICAgICAgICAgIC8vIFJlbGF0aXZlIHZlbG9jaXR5IGluIGxpbmVhciB0ZXJtc1xyXG4gICAgICAgICAgICAvLyBBbmd1bGFyIHRvIGxpbmVhciB2ZWxvY2l0eSBmb3JtdWxhIC0+IG9tZWdhID0gdmVsb2NpdHkvcmFkaXVzIHNvIG9tZWdhIHggcmFkaXVzID0gdmVsb2NpdHlcclxuICAgICAgICAgICAgY29uc3QgdmVsQSA9IGJvZHlBLnZlbC5hZGQoVmVjdG9yLmNyb3NzKGJvZHlBLmFuZ3VsYXJWZWxvY2l0eSwgdGhpcy5hVG9Db250YWN0KSk7XHJcbiAgICAgICAgICAgIGNvbnN0IHZlbEIgPSBib2R5Qi52ZWwuYWRkKFZlY3Rvci5jcm9zcyhib2R5Qi5hbmd1bGFyVmVsb2NpdHksIHRoaXMuYlRvQ29udGFjdCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gdmVsQi5zdWIodmVsQSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBWZWN0b3IuWmVybztcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Tb2x2ZXIvUmVhbGlzdGljU29sdmVyLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBSZWFsaXN0aWNTb2x2ZXIgZXh0ZW5kcyBDb2xsaXNpb25Tb2x2ZXIge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLmxhc3RGcmFtZUNvbnRhY3RzID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIC8vIG1hcCBjb250YWN0IGlkIHRvIGNvbnRhY3QgcG9pbnRzXHJcbiAgICAgICAgdGhpcy5pZFRvQ29udGFjdENvbnN0cmFpbnQgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBnZXRDb250YWN0Q29uc3RyYWludHMoaWQpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuaWRUb0NvbnRhY3RDb25zdHJhaW50LmdldChpZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xyXG4gICAgfVxyXG4gICAgcHJlU29sdmUoY29udGFjdHMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgLy8gUHVibGlzaCBjb2xsaXNpb24gZXZlbnRzIG9uIGJvdGggcGFydGljaXBhbnRzXHJcbiAgICAgICAgICAgIGNvbnN0IHNpZGUgPSBTaWRlLmZyb21EaXJlY3Rpb24oY29udGFjdC5tdHYpO1xyXG4gICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQS5ldmVudHMuZW1pdCgncHJlY29sbGlzaW9uJywgbmV3IFByZUNvbGxpc2lvbkV2ZW50KGNvbnRhY3QuY29sbGlkZXJBLCBjb250YWN0LmNvbGxpZGVyQiwgc2lkZSwgY29udGFjdC5tdHYpKTtcclxuICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckEuZXZlbnRzLmVtaXQoJ2JlZm9yZWNvbGxpc2lvbnJlc29sdmUnLCBuZXcgQ29sbGlzaW9uUHJlU29sdmVFdmVudChjb250YWN0LmNvbGxpZGVyQSwgY29udGFjdC5jb2xsaWRlckIsIHNpZGUsIGNvbnRhY3QubXR2LCBjb250YWN0KSk7XHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdwcmVjb2xsaXNpb24nLCBuZXcgUHJlQ29sbGlzaW9uRXZlbnQoY29udGFjdC5jb2xsaWRlckIsIGNvbnRhY3QuY29sbGlkZXJBLCBTaWRlLmdldE9wcG9zaXRlKHNpZGUpLCBjb250YWN0Lm10di5uZWdhdGUoKSkpO1xyXG4gICAgICAgICAgICBjb250YWN0LmNvbGxpZGVyQi5ldmVudHMuZW1pdCgnYmVmb3JlY29sbGlzaW9ucmVzb2x2ZScsIG5ldyBDb2xsaXNpb25QcmVTb2x2ZUV2ZW50KGNvbnRhY3QuY29sbGlkZXJCLCBjb250YWN0LmNvbGxpZGVyQSwgU2lkZS5nZXRPcHBvc2l0ZShzaWRlKSwgY29udGFjdC5tdHYubmVnYXRlKCksIGNvbnRhY3QpKTtcclxuICAgICAgICAgICAgLy8gTWF0Y2ggYXdha2Ugc3RhdGUgZm9yIHNsZWVwaW5nXHJcbiAgICAgICAgICAgIGNvbnRhY3QubWF0Y2hBd2FrZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGNvbnRhY3RzIHRoYXQgZG9uZVxyXG4gICAgICAgIGNvbnN0IGZpbmlzaGVkQ29udGFjdElkcyA9IEFycmF5LmZyb20odGhpcy5pZFRvQ29udGFjdENvbnN0cmFpbnQua2V5cygpKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgLy8gUmVtb3ZlIGFsbCBjdXJyZW50IGNvbnRhY3RzIHRoYXQgYXJlIG5vdCBkb25lXHJcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZmluaXNoZWRDb250YWN0SWRzLmluZGV4T2YoY29udGFjdC5pZCk7XHJcbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICBmaW5pc2hlZENvbnRhY3RJZHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBjb250YWN0UG9pbnRzID0gKF9hID0gdGhpcy5pZFRvQ29udGFjdENvbnN0cmFpbnQuZ2V0KGNvbnRhY3QuaWQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXTtcclxuICAgICAgICAgICAgbGV0IHBvaW50SW5kZXggPSAwO1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QSA9IGNvbnRhY3QuY29sbGlkZXJBLm93bmVyLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgY29uc3QgYm9keUIgPSBjb250YWN0LmNvbGxpZGVyQi5vd25lci5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChib2R5QSAmJiBib2R5Qikge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBjb250YWN0LnBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbCA9IGNvbnRhY3Qubm9ybWFsO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhbmdlbnQgPSBjb250YWN0LnRhbmdlbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYVRvQ29udGFjdCA9IHBvaW50LnN1Yihib2R5QS5wb3MpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJUb0NvbnRhY3QgPSBwb2ludC5zdWIoYm9keUIucG9zKTtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhVG9Db250YWN0Tm9ybWFsID0gYVRvQ29udGFjdC5jcm9zcyhub3JtYWwpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJUb0NvbnRhY3ROb3JtYWwgPSBiVG9Db250YWN0LmNyb3NzKG5vcm1hbCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsTWFzcyA9IGJvZHlBLmludmVyc2VNYXNzICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuaW52ZXJzZU1hc3MgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5pbnZlcnNlSW5lcnRpYSAqIGFUb0NvbnRhY3ROb3JtYWwgKiBhVG9Db250YWN0Tm9ybWFsICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIuaW52ZXJzZUluZXJ0aWEgKiBiVG9Db250YWN0Tm9ybWFsICogYlRvQ29udGFjdE5vcm1hbDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhVG9Db250YWN0VGFuZ2VudCA9IGFUb0NvbnRhY3QuY3Jvc3ModGFuZ2VudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYlRvQ29udGFjdFRhbmdlbnQgPSBiVG9Db250YWN0LmNyb3NzKHRhbmdlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhbmdlbnRNYXNzID0gYm9keUEuaW52ZXJzZU1hc3MgK1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5pbnZlcnNlTWFzcyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLmludmVyc2VJbmVydGlhICogYVRvQ29udGFjdFRhbmdlbnQgKiBhVG9Db250YWN0VGFuZ2VudCArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLmludmVyc2VJbmVydGlhICogYlRvQ29udGFjdFRhbmdlbnQgKiBiVG9Db250YWN0VGFuZ2VudDtcclxuICAgICAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSBub3JtYWwvdGFuZ2VudCBpbXB1bHNlIGJ5IHJlLXVzaW5nIHRoZSBjb250YWN0IHBvaW50IGlmIGl0J3MgY2xvc2VcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGFjdFBvaW50c1twb2ludEluZGV4XSAmJiAoKF9jID0gKF9iID0gY29udGFjdFBvaW50c1twb2ludEluZGV4XSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBvaW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3F1YXJlRGlzdGFuY2UocG9pbnQpKSA8IDQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdFBvaW50c1twb2ludEluZGV4XS5wb2ludCA9IHBvaW50O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWN0UG9pbnRzW3BvaW50SW5kZXhdLmxvY2FsID0gY29udGFjdC5sb2NhbFBvaW50c1twb2ludEluZGV4XTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5ldyBjb250YWN0IGlmIGl0J3Mgbm90IGNsb3NlIG9yIGRvZXNuJ3QgZXhpc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFjdFBvaW50c1twb2ludEluZGV4XSA9IG5ldyBDb250YWN0Q29uc3RyYWludFBvaW50KHBvaW50LCBjb250YWN0LmxvY2FsUG9pbnRzW3BvaW50SW5kZXhdLCBjb250YWN0KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGNvbnRhY3QgcG9pbnQgY2FsY3VsYXRpb25zXHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdFBvaW50c1twb2ludEluZGV4XS5hVG9Db250YWN0ID0gYVRvQ29udGFjdDtcclxuICAgICAgICAgICAgICAgICAgICBjb250YWN0UG9pbnRzW3BvaW50SW5kZXhdLmJUb0NvbnRhY3QgPSBiVG9Db250YWN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhY3RQb2ludHNbcG9pbnRJbmRleF0ubm9ybWFsTWFzcyA9IG5vcm1hbE1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGFjdFBvaW50c1twb2ludEluZGV4XS50YW5nZW50TWFzcyA9IHRhbmdlbnRNYXNzO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50SW5kZXgrKztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmlkVG9Db250YWN0Q29uc3RyYWludC5zZXQoY29udGFjdC5pZCwgY29udGFjdFBvaW50cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIENsZWFuIHVwIGFueSBjb250YWN0cyB0aGF0IGRpZCBub3Qgb2NjdXIgbGFzdCBmcmFtZVxyXG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZmluaXNoZWRDb250YWN0SWRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaWRUb0NvbnRhY3RDb25zdHJhaW50LmRlbGV0ZShpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdhcm0gY29udGFjdHMgd2l0aCBhY2N1bXVsYXRlZCBpbXB1bHNlXHJcbiAgICAgICAgLy8gVXNlZnVsIGZvciB0YWxsIHN0YWNrc1xyXG4gICAgICAgIGlmIChQaHlzaWNzLndhcm1TdGFydCkge1xyXG4gICAgICAgICAgICB0aGlzLndhcm1TdGFydChjb250YWN0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNvbnRhY3Qgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhY3RQb2ludHMgPSB0aGlzLmdldENvbnRhY3RDb25zdHJhaW50cyhjb250YWN0LmlkKTtcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgY29udGFjdFBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50Lm5vcm1hbEltcHVsc2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50LnRhbmdlbnRJbXB1bHNlID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHBvc3RTb2x2ZShjb250YWN0cykge1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udGFjdCBvZiBjb250YWN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QSA9IGNvbnRhY3QuY29sbGlkZXJBLm93bmVyLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgY29uc3QgYm9keUIgPSBjb250YWN0LmNvbGxpZGVyQi5vd25lci5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmIChib2R5QSAmJiBib2R5Qikge1xyXG4gICAgICAgICAgICAgICAgLy8gU2tpcCBwb3N0IHNvbHZlIGZvciBhY3RpdmUrcGFzc2l2ZSBjb2xsaXNpb25zXHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlIHx8IGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIG1vdGlvbiB2YWx1ZXMgZm9yIHNsZWVwaW5nXHJcbiAgICAgICAgICAgICAgICBib2R5QS51cGRhdGVNb3Rpb24oKTtcclxuICAgICAgICAgICAgICAgIGJvZHlCLnVwZGF0ZU1vdGlvbigpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFB1Ymxpc2ggY29sbGlzaW9uIGV2ZW50cyBvbiBib3RoIHBhcnRpY2lwYW50c1xyXG4gICAgICAgICAgICBjb25zdCBzaWRlID0gU2lkZS5mcm9tRGlyZWN0aW9uKGNvbnRhY3QubXR2KTtcclxuICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckEuZXZlbnRzLmVtaXQoJ3Bvc3Rjb2xsaXNpb24nLCBuZXcgUG9zdENvbGxpc2lvbkV2ZW50KGNvbnRhY3QuY29sbGlkZXJBLCBjb250YWN0LmNvbGxpZGVyQiwgc2lkZSwgY29udGFjdC5tdHYpKTtcclxuICAgICAgICAgICAgY29udGFjdC5jb2xsaWRlckEuZXZlbnRzLmVtaXQoJ2FmdGVyY29sbGlzaW9ucmVzb2x2ZScsIG5ldyBDb2xsaXNpb25Qb3N0U29sdmVFdmVudChjb250YWN0LmNvbGxpZGVyQSwgY29udGFjdC5jb2xsaWRlckIsIHNpZGUsIGNvbnRhY3QubXR2LCBjb250YWN0KSk7XHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdwb3N0Y29sbGlzaW9uJywgbmV3IFBvc3RDb2xsaXNpb25FdmVudChjb250YWN0LmNvbGxpZGVyQiwgY29udGFjdC5jb2xsaWRlckEsIFNpZGUuZ2V0T3Bwb3NpdGUoc2lkZSksIGNvbnRhY3QubXR2Lm5lZ2F0ZSgpKSk7XHJcbiAgICAgICAgICAgIGNvbnRhY3QuY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdhZnRlcmNvbGxpc2lvbnJlc29sdmUnLCBuZXcgQ29sbGlzaW9uUG9zdFNvbHZlRXZlbnQoY29udGFjdC5jb2xsaWRlckIsIGNvbnRhY3QuY29sbGlkZXJBLCBTaWRlLmdldE9wcG9zaXRlKHNpZGUpLCBjb250YWN0Lm10di5uZWdhdGUoKSwgY29udGFjdCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdG9yZSBjb250YWN0c1xyXG4gICAgICAgIHRoaXMubGFzdEZyYW1lQ29udGFjdHMuY2xlYXIoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgY29udGFjdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5sYXN0RnJhbWVDb250YWN0cy5zZXQoYy5pZCwgYyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXYXJtIHVwIGJvZHkncyBiYXNlZCBvbiBwcmV2aW91cyBmcmFtZSBjb250YWN0IHBvaW50c1xyXG4gICAgICogQHBhcmFtIGNvbnRhY3RzXHJcbiAgICAgKi9cclxuICAgIHdhcm1TdGFydChjb250YWN0cykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIGZvciAoY29uc3QgY29udGFjdCBvZiBjb250YWN0cykge1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QSA9IChfYSA9IGNvbnRhY3QuY29sbGlkZXJBLm93bmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBjb25zdCBib2R5QiA9IChfYiA9IGNvbnRhY3QuY29sbGlkZXJCLm93bmVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KEJvZHlDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhY3RQb2ludHMgPSAoX2MgPSB0aGlzLmlkVG9Db250YWN0Q29uc3RyYWludC5nZXQoY29udGFjdC5pZCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBjb250YWN0UG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKFBoeXNpY3Mud2FybVN0YXJ0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbEltcHVsc2UgPSBjb250YWN0Lm5vcm1hbC5zY2FsZShwb2ludC5ub3JtYWxJbXB1bHNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFuZ2VudEltcHVsc2UgPSBjb250YWN0LnRhbmdlbnQuc2NhbGUocG9pbnQudGFuZ2VudEltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbXB1bHNlID0gbm9ybWFsSW1wdWxzZS5hZGQodGFuZ2VudEltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5hcHBseUltcHVsc2UocG9pbnQucG9pbnQsIGltcHVsc2UubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5hcHBseUltcHVsc2UocG9pbnQucG9pbnQsIGltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnQubm9ybWFsSW1wdWxzZSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnRhbmdlbnRJbXB1bHNlID0gMDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0ZXJhdGl2ZWx5IHNvbHZlIHRoZSBwb3NpdGlvbiBvdmVybGFwIGNvbnN0cmFpbnRcclxuICAgICAqIEBwYXJhbSBjb250YWN0c1xyXG4gICAgICovXHJcbiAgICBzb2x2ZVBvc2l0aW9uKGNvbnRhY3RzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQaHlzaWNzLnBvc2l0aW9uSXRlcmF0aW9uczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29udGFjdCBvZiBjb250YWN0cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm9keUEgPSAoX2EgPSBjb250YWN0LmNvbGxpZGVyQS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlCID0gKF9iID0gY29udGFjdC5jb2xsaWRlckIub3duZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHNvbHZpbmcgYWN0aXZlK3Bhc3NpdmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlIHx8IGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSAoX2MgPSB0aGlzLmlkVG9Db250YWN0Q29uc3RyYWludC5nZXQoY29udGFjdC5pZCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgY29uc3RyYWludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9ybWFsID0gY29udGFjdC5ub3JtYWw7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRpb24gPSBDb2xsaXNpb25KdW1wVGFibGUuRmluZENvbnRhY3RTZXBhcmF0aW9uKGNvbnRhY3QsIHBvaW50LmxvY2FsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlZXJpbmdDb25zdGFudCA9IFBoeXNpY3Muc3RlZXJpbmdGYWN0b3I7IC8vMC4yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhDb3JyZWN0aW9uID0gLTU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNsb3AgPSBQaHlzaWNzLnNsb3A7IC8vMTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xhbXAgdG8gYXZvaWQgb3Zlci1jb3JyZWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoYXQgd2UgYXJlIHNob290aW5nIGZvciAwIG92ZXJsYXAgaW4gdGhlIGVuZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGVlcmluZ0ZvcmNlID0gY2xhbXAoc3RlZXJpbmdDb25zdGFudCAqIChzZXBhcmF0aW9uICsgc2xvcCksIG1heENvcnJlY3Rpb24sIDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbXB1bHNlID0gbm9ybWFsLnNjYWxlKC1zdGVlcmluZ0ZvcmNlIC8gcG9pbnQubm9ybWFsTWFzcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwc2V1ZG8gaW1wdWxzZSwgbWVhbmluZyB3ZSBhcmVuJ3QgZG9pbmcgYSByZWFsIGltcHVsc2UgY2FsY3VsYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgYWRqdXN0IHBvc2l0aW9uIGFuZCByb3RhdGlvbiBpbnN0ZWFkIG9mIGRvaW5nIHRoZSB2ZWxvY2l0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5BY3RpdmUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLnBvcyA9IGJvZHlBLnBvcy5hZGQoaW1wdWxzZS5uZWdhdGUoKS5zY2FsZShib2R5QS5pbnZlcnNlTWFzcykpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keUEucm90YXRpb24gLT0gcG9pbnQuYVRvQ29udGFjdC5jcm9zcyhpbXB1bHNlKSAqIGJvZHlBLmludmVyc2VJbmVydGlhO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib2R5Qi5jb2xsaXNpb25UeXBlID09PSBDb2xsaXNpb25UeXBlLkFjdGl2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keUIucG9zID0gYm9keUIucG9zLmFkZChpbXB1bHNlLnNjYWxlKGJvZHlCLmludmVyc2VNYXNzKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5yb3RhdGlvbiArPSBwb2ludC5iVG9Db250YWN0LmNyb3NzKGltcHVsc2UpICogYm9keUIuaW52ZXJzZUluZXJ0aWE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBzb2x2ZVZlbG9jaXR5KGNvbnRhY3RzKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBQaHlzaWNzLnZlbG9jaXR5SXRlcmF0aW9uczsgaSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY29udGFjdCBvZiBjb250YWN0cykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm9keUEgPSAoX2EgPSBjb250YWN0LmNvbGxpZGVyQS5vd25lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHlCID0gKF9iID0gY29udGFjdC5jb2xsaWRlckIub3duZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXQoQm9keUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keUEgJiYgYm9keUIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIHNvbHZpbmcgYWN0aXZlK3Bhc3NpdmVcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYm9keUEuY29sbGlzaW9uVHlwZSA9PT0gQ29sbGlzaW9uVHlwZS5QYXNzaXZlIHx8IGJvZHlCLmNvbGxpc2lvblR5cGUgPT09IENvbGxpc2lvblR5cGUuUGFzc2l2ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdGl0dXRpb24gPSBib2R5QS5ib3VuY2luZXNzICogYm9keUIuYm91bmNpbmVzcztcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcmljdGlvbiA9IE1hdGgubWluKGJvZHlBLmZyaWN0aW9uLCBib2R5Qi5mcmljdGlvbik7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29uc3RyYWludHMgPSAoX2MgPSB0aGlzLmlkVG9Db250YWN0Q29uc3RyYWludC5nZXQoY29udGFjdC5pZCkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcG9pbnQgb2YgY29uc3RyYWludHMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVWZWxvY2l0eSA9IHBvaW50LmdldFJlbGF0aXZlVmVsb2NpdHkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTmVnYXRlIHZlbG9jaXR5IGluIHRhbmdlbnQgZGlyZWN0aW9uIHRvIHNpbXVsYXRlIGZyaWN0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhbmdlbnRWZWxvY2l0eSA9IC1yZWxhdGl2ZVZlbG9jaXR5LmRvdChjb250YWN0LnRhbmdlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1wdWxzZURlbHRhID0gdGFuZ2VudFZlbG9jaXR5IC8gcG9pbnQudGFuZ2VudE1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsYW1waW5nIGJhc2VkIGluIEVyaW4gQ2F0dG8ncyBHREMgMjAwNiB0YWxrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvcnJlY3QgY2xhbXBpbmcgaHR0cHM6Ly9naXRodWIuY29tL2VyaW5jYXR0by9ib3gyZC1saXRlL2Jsb2IvbWFzdGVyL2RvY3MvR0RDMjAwNl9DYXR0b19FcmluX1BoeXNpY3NUdXRvcmlhbC5wZGZcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWNjdW11bGF0ZWQgZmljdGlvbiBpbXB1bHNlIGlzIGFsd2F5cyBiZXR3ZWVuIC11TWF4RnJpY3Rpb24gPCBkVCA8IHVNYXhGcmljdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgZGVsdGFzIGNhbiB2YXJ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heEZyaWN0aW9uID0gZnJpY3Rpb24gKiBwb2ludC5ub3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJbXB1bHNlID0gY2xhbXAocG9pbnQudGFuZ2VudEltcHVsc2UgKyBpbXB1bHNlRGVsdGEsIC1tYXhGcmljdGlvbiwgbWF4RnJpY3Rpb24pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbXB1bHNlRGVsdGEgPSBuZXdJbXB1bHNlIC0gcG9pbnQudGFuZ2VudEltcHVsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50LnRhbmdlbnRJbXB1bHNlID0gbmV3SW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1wdWxzZSA9IGNvbnRhY3QudGFuZ2VudC5zY2FsZShpbXB1bHNlRGVsdGEpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5QS5hcHBseUltcHVsc2UocG9pbnQucG9pbnQsIGltcHVsc2UubmVnYXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5Qi5hcHBseUltcHVsc2UocG9pbnQucG9pbnQsIGltcHVsc2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGNvbnN0cmFpbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gcmVjYWxjIHJlbGF0aXZlIHZlbG9jaXR5IGJlY2F1c2UgdGhlIHByZXZpb3VzIHN0ZXAgY291bGQgaGF2ZSBjaGFuZ2VkIHZlbFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVZlbG9jaXR5ID0gcG9pbnQuZ2V0UmVsYXRpdmVWZWxvY2l0eSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21wdXRlIGltcHVsc2UgaW4gbm9ybWFsIGRpcmVjdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxWZWxvY2l0eSA9IHJlbGF0aXZlVmVsb2NpdHkuZG90KGNvbnRhY3Qubm9ybWFsKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbGxpc2lvbl9yZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW1wdWxzZURlbHRhID0gKC0oMSArIHJlc3RpdHV0aW9uKSAqIG5vcm1hbFZlbG9jaXR5KSAvIHBvaW50Lm5vcm1hbE1hc3M7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENsYW1waW5nIGJhc2VkIGluIEVyaW4gQ2F0dG8ncyBHREMgMjAxNCB0YWxrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFjY3VtdWxhdGVkIGltcHVsc2Ugc3RvcmVkIGluIHRoZSBjb250YWN0IGlzIGFsd2F5cyBwb3NpdGl2ZSAoZFYgPiAwKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBCdXQgZGVsdGFzIGNhbiBiZSBuZWdhdGl2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJbXB1bHNlID0gTWF0aC5tYXgocG9pbnQubm9ybWFsSW1wdWxzZSArIGltcHVsc2VEZWx0YSwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGltcHVsc2VEZWx0YSA9IG5ld0ltcHVsc2UgLSBwb2ludC5ub3JtYWxJbXB1bHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludC5ub3JtYWxJbXB1bHNlID0gbmV3SW1wdWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1wdWxzZSA9IGNvbnRhY3Qubm9ybWFsLnNjYWxlKGltcHVsc2VEZWx0YSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlBLmFwcGx5SW1wdWxzZShwb2ludC5wb2ludCwgaW1wdWxzZS5uZWdhdGUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHlCLmFwcGx5SW1wdWxzZShwb2ludC5wb2ludCwgaW1wdWxzZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0NvbGxpc2lvblN5c3RlbS50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGFzcyBDb2xsaXNpb25TeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGVzID0gWydleC50cmFuc2Zvcm0nLCAnZXgubW90aW9uJywgJ2V4LmNvbGxpZGVyJ107XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1UeXBlID0gU3lzdGVtVHlwZS5VcGRhdGU7XHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IC0xO1xyXG4gICAgICAgIHRoaXMuX3JlYWxpc3RpY1NvbHZlciA9IG5ldyBSZWFsaXN0aWNTb2x2ZXIoKTtcclxuICAgICAgICB0aGlzLl9hcmNhZGVTb2x2ZXIgPSBuZXcgQXJjYWRlU29sdmVyKCk7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc29yID0gbmV3IER5bmFtaWNUcmVlQ29sbGlzaW9uUHJvY2Vzc29yKCk7XHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lQ29udGFjdHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lQ29udGFjdHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fdHJhY2tDb2xsaWRlciA9IChjKSA9PiB0aGlzLl9wcm9jZXNzb3IudHJhY2soYyk7XHJcbiAgICAgICAgdGhpcy5fdW50cmFja0NvbGxpZGVyID0gKGMpID0+IHRoaXMuX3Byb2Nlc3Nvci51bnRyYWNrKGMpO1xyXG4gICAgfVxyXG4gICAgbm90aWZ5KG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoaXNBZGRlZFN5c3RlbUVudGl0eShtZXNzYWdlKSkge1xyXG4gICAgICAgICAgICBjb25zdCBjb2xsaWRlckNvbXBvbmVudCA9IG1lc3NhZ2UuZGF0YS5nZXQoQ29sbGlkZXJDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBjb2xsaWRlckNvbXBvbmVudC4kY29sbGlkZXJBZGRlZC5zdWJzY3JpYmUodGhpcy5fdHJhY2tDb2xsaWRlcik7XHJcbiAgICAgICAgICAgIGNvbGxpZGVyQ29tcG9uZW50LiRjb2xsaWRlclJlbW92ZWQuc3Vic2NyaWJlKHRoaXMuX3VudHJhY2tDb2xsaWRlcik7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyID0gY29sbGlkZXJDb21wb25lbnQuZ2V0KCk7XHJcbiAgICAgICAgICAgIGlmIChjb2xsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc29yLnRyYWNrKGNvbGxpZGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJDb21wb25lbnQgPSBtZXNzYWdlLmRhdGEuZ2V0KENvbGxpZGVyQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXIgPSBjb2xsaWRlckNvbXBvbmVudC5nZXQoKTtcclxuICAgICAgICAgICAgaWYgKGNvbGxpZGVyQ29tcG9uZW50ICYmIGNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9jZXNzb3IudW50cmFjayhjb2xsaWRlcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKHNjZW5lKSB7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lID0gc2NlbmUuZW5naW5lO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9lbnRpdGllcywgZWxhcHNlZE1zKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICghUGh5c2ljcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ29sbGVjdCB1cCBhbGwgdGhlIGNvbGxpZGVyc1xyXG4gICAgICAgIGxldCBjb2xsaWRlcnMgPSBbXTtcclxuICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBfZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgY29uc3QgY29sbGlkZXJDb21wID0gZW50aXR5LmdldChDb2xsaWRlckNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVyID0gY29sbGlkZXJDb21wID09PSBudWxsIHx8IGNvbGxpZGVyQ29tcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29sbGlkZXJDb21wLmdldCgpO1xyXG4gICAgICAgICAgICBpZiAoY29sbGlkZXJDb21wICYmICgoX2EgPSBjb2xsaWRlckNvbXAub3duZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmUpICYmIGNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlckNvbXAudXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sbGlkZXIgaW5zdGFuY2VvZiBDb21wb3NpdGVDb2xsaWRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxpZGVycyA9IGNvbGxpZGVycy5jb25jYXQoY29sbGlkZXIuZ2V0Q29sbGlkZXJzKCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sbGlkZXJzLnB1c2goY29sbGlkZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgc3BhdGlhbCBwYXJ0aXRpb25pbmcgZGF0YSBzdHJ1Y3R1cmVzXHJcbiAgICAgICAgLy8gVE9ETyBpZiBjb2xsaWRlciBpbnZhbGlkIGl0IHdpbGwgYnJlYWsgdGhlIHByb2Nlc3NvclxyXG4gICAgICAgIC8vIFRPRE8gcmVuYW1lIFwidXBkYXRlXCIgdG8gc29tZXRoaW5nIG1vcmUgc3BlY2lmaWNcclxuICAgICAgICB0aGlzLl9wcm9jZXNzb3IudXBkYXRlKGNvbGxpZGVycyk7XHJcbiAgICAgICAgLy8gUnVuIGJyb2FkcGhhc2Ugb24gYWxsIGNvbGxpZGVycyBhbmQgbG9jYXRlcyBwb3RlbnRpYWwgY29sbGlzaW9uc1xyXG4gICAgICAgIGNvbnN0IHBhaXJzID0gdGhpcy5fcHJvY2Vzc29yLmJyb2FkcGhhc2UoY29sbGlkZXJzLCBlbGFwc2VkTXMpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZUNvbnRhY3RzLmNsZWFyKCk7XHJcbiAgICAgICAgLy8gR2l2ZW4gcG9zc2libGUgcGFpcnMgZmluZCBhY3R1YWwgY29udGFjdHNcclxuICAgICAgICBsZXQgY29udGFjdHMgPSB0aGlzLl9wcm9jZXNzb3IubmFycm93cGhhc2UocGFpcnMsIHRoaXMuX2VuZ2luZS5kZWJ1Zy5zdGF0cy5jdXJyRnJhbWUpO1xyXG4gICAgICAgIGNvbnN0IHNvbHZlciA9IHRoaXMuZ2V0U29sdmVyKCk7XHJcbiAgICAgICAgLy8gU29sdmUsIHRoaXMgcmVzb2x2ZXMgdGhlIHBvc2l0aW9uL3ZlbG9jaXR5IHNvIGVudGl0aWVzIGFyZW50IG92ZXJsYXBwaW5nXHJcbiAgICAgICAgY29udGFjdHMgPSBzb2x2ZXIuc29sdmUoY29udGFjdHMpO1xyXG4gICAgICAgIC8vIFJlY29yZCBjb250YWN0c1xyXG4gICAgICAgIGNvbnRhY3RzLmZvckVhY2goKGMpID0+IHRoaXMuX2N1cnJlbnRGcmFtZUNvbnRhY3RzLnNldChjLmlkLCBjKSk7XHJcbiAgICAgICAgLy8gRW1pdCBjb250YWN0IHN0YXJ0L2VuZCBldmVudHNcclxuICAgICAgICB0aGlzLnJ1bkNvbnRhY3RTdGFydEVuZCgpO1xyXG4gICAgICAgIC8vIHJlc2V0IHRoZSBsYXN0IGZyYW1lIGNhY2hlXHJcbiAgICAgICAgdGhpcy5fbGFzdEZyYW1lQ29udGFjdHMuY2xlYXIoKTtcclxuICAgICAgICAvLyBLZWVwIHRyYWNrIG9mIGNvbGxpc2lvbnMgY29udGFjdHMgdGhhdCBoYXZlIHN0YXJ0ZWQgb3IgZW5kZWRcclxuICAgICAgICB0aGlzLl9sYXN0RnJhbWVDb250YWN0cyA9IG5ldyBNYXAodGhpcy5fY3VycmVudEZyYW1lQ29udGFjdHMpO1xyXG4gICAgfVxyXG4gICAgZ2V0U29sdmVyKCkge1xyXG4gICAgICAgIHJldHVybiBQaHlzaWNzLmNvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9PT0gQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5LlJlYWxpc3RpYyA/IHRoaXMuX3JlYWxpc3RpY1NvbHZlciA6IHRoaXMuX2FyY2FkZVNvbHZlcjtcclxuICAgIH1cclxuICAgIGRlYnVnKGV4KSB7XHJcbiAgICAgICAgdGhpcy5fcHJvY2Vzc29yLmRlYnVnKGV4KTtcclxuICAgIH1cclxuICAgIHJ1bkNvbnRhY3RTdGFydEVuZCgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IFtpZCwgY10gb2YgdGhpcy5fY3VycmVudEZyYW1lQ29udGFjdHMpIHtcclxuICAgICAgICAgICAgLy8gZmluZCBhbGwgbmV3IGNvbnRhY3RzXHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbGFzdEZyYW1lQ29udGFjdHMuaGFzKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGlkZXJBID0gYy5jb2xsaWRlckE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsaWRlckIgPSBjLmNvbGxpZGVyQjtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQS5ldmVudHMuZW1pdCgnY29sbGlzaW9uc3RhcnQnLCBuZXcgQ29sbGlzaW9uU3RhcnRFdmVudChjb2xsaWRlckEsIGNvbGxpZGVyQiwgYykpO1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXJBLmV2ZW50cy5lbWl0KCdjb250YWN0c3RhcnQnLCBuZXcgQ29udGFjdFN0YXJ0RXZlbnQoY29sbGlkZXJBLCBjb2xsaWRlckIsIGMpKTtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQi5ldmVudHMuZW1pdCgnY29sbGlzaW9uc3RhcnQnLCBuZXcgQ29sbGlzaW9uU3RhcnRFdmVudChjb2xsaWRlckIsIGNvbGxpZGVyQSwgYykpO1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdjb250YWN0c3RhcnQnLCBuZXcgQ29udGFjdFN0YXJ0RXZlbnQoY29sbGlkZXJCLCBjb2xsaWRlckEsIGMpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBmaW5kIGFsbCBjb250YWN0cyB0YWh0IGhhdmUgY2Vhc2VkXHJcbiAgICAgICAgZm9yIChjb25zdCBbaWQsIGNdIG9mIHRoaXMuX2xhc3RGcmFtZUNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fY3VycmVudEZyYW1lQ29udGFjdHMuaGFzKGlkKSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGlkZXJBID0gYy5jb2xsaWRlckE7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjb2xsaWRlckIgPSBjLmNvbGxpZGVyQjtcclxuICAgICAgICAgICAgICAgIGNvbGxpZGVyQS5ldmVudHMuZW1pdCgnY29sbGlzaW9uZW5kJywgbmV3IENvbGxpc2lvbkVuZEV2ZW50KGNvbGxpZGVyQSwgY29sbGlkZXJCKSk7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlckEuZXZlbnRzLmVtaXQoJ2NvbnRhY3RlbmQnLCBuZXcgQ29udGFjdEVuZEV2ZW50KGNvbGxpZGVyQSwgY29sbGlkZXJCKSk7XHJcbiAgICAgICAgICAgICAgICBjb2xsaWRlckIuZXZlbnRzLmVtaXQoJ2NvbGxpc2lvbmVuZCcsIG5ldyBDb2xsaXNpb25FbmRFdmVudChjb2xsaWRlckIsIGNvbGxpZGVyQSkpO1xyXG4gICAgICAgICAgICAgICAgY29sbGlkZXJCLmV2ZW50cy5lbWl0KCdjb250YWN0ZW5kJywgbmV3IENvbnRhY3RFbmRFdmVudChjb2xsaWRlckIsIGNvbGxpZGVyQSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvQW5pbWF0aW9uLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgQW5pbWF0aW9uRGlyZWN0aW9uO1xyXG4oZnVuY3Rpb24gKEFuaW1hdGlvbkRpcmVjdGlvbikge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbmltYXRpb24gaXMgcGxheWluZyBmb3J3YXJkc1xyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25EaXJlY3Rpb25bXCJGb3J3YXJkXCJdID0gXCJmb3J3YXJkXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFuaW1hdGlvbiBpcyBwbGF5IGJhY2t3YXJkc1xyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25EaXJlY3Rpb25bXCJCYWNrd2FyZFwiXSA9IFwiYmFja3dhcmRcIjtcclxufSkoQW5pbWF0aW9uRGlyZWN0aW9uIHx8IChBbmltYXRpb25EaXJlY3Rpb24gPSB7fSkpO1xyXG52YXIgQW5pbWF0aW9uU3RyYXRlZ3k7XHJcbihmdW5jdGlvbiAoQW5pbWF0aW9uU3RyYXRlZ3kpIHtcclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIGVuZHMgd2l0aG91dCBkaXNwbGF5aW5nIGFueXRoaW5nXHJcbiAgICAgKi9cclxuICAgIEFuaW1hdGlvblN0cmF0ZWd5W1wiRW5kXCJdID0gXCJlbmRcIjtcclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIGxvb3BzIHRvIHRoZSBmaXJzdCBmcmFtZSBhZnRlciB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25TdHJhdGVneVtcIkxvb3BcIl0gPSBcImxvb3BcIjtcclxuICAgIC8qKlxyXG4gICAgICogQW5pbWF0aW9uIHBsYXlzIHRvIHRoZSBsYXN0IGZyYW1lLCB0aGVuIGJhY2t3YXJkcyB0byB0aGUgZmlyc3QgZnJhbWUsIHRoZW4gcmVwZWF0c1xyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25TdHJhdGVneVtcIlBpbmdQb25nXCJdID0gXCJwaW5ncG9uZ1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBbmltYXRpb24gZW5kcyBzdG9wcGluZyBvbiB0aGUgbGFzdCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBBbmltYXRpb25TdHJhdGVneVtcIkZyZWV6ZVwiXSA9IFwiZnJlZXplXCI7XHJcbn0pKEFuaW1hdGlvblN0cmF0ZWd5IHx8IChBbmltYXRpb25TdHJhdGVneSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBDcmVhdGUgYW4gQW5pbWF0aW9uIGdpdmVuIGEgbGlzdCBvZiBbW0ZyYW1lfGZyYW1lc11dIGluIFtbQW5pbWF0aW9uT3B0aW9uc11dXHJcbiAqXHJcbiAqIFRvIGNyZWF0ZSBhbiBBbmltYXRpb24gZnJvbSBhIFtbU3ByaXRlU2hlZXRdXSwgdXNlIFtbQW5pbWF0aW9uLmZyb21TcHJpdGVTaGVldF1dXHJcbiAqL1xyXG5jbGFzcyBBbmltYXRpb24gZXh0ZW5kcyBHcmFwaGljIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZXZlbnRzID0gbmV3IEV2ZW50RGlzcGF0Y2hlcih0aGlzKTsgLy8gVE9ETyByZXBsYWNlIHdpdGggbmV3IEVtaXR0ZXJcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuc3RyYXRlZ3kgPSBBbmltYXRpb25TdHJhdGVneS5Mb29wO1xyXG4gICAgICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IDEwMDtcclxuICAgICAgICB0aGlzLnRpbWVTY2FsZSA9IDE7XHJcbiAgICAgICAgdGhpcy5faWRlbXBvdGVuY3lUb2tlbiA9IC0xO1xyXG4gICAgICAgIHRoaXMuX2ZpcnN0VGljayA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudEZyYW1lID0gMDtcclxuICAgICAgICB0aGlzLl90aW1lTGVmdEluRnJhbWUgPSAwO1xyXG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7IC8vIFRPRE8gb25seSB1c2VkIGluIHBpbmctcG9uZ1xyXG4gICAgICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9yZXZlcnNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzID0gb3B0aW9ucy5mcmFtZXM7XHJcbiAgICAgICAgdGhpcy5zdHJhdGVneSA9IChfYSA9IG9wdGlvbnMuc3RyYXRlZ3kpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuc3RyYXRlZ3k7XHJcbiAgICAgICAgdGhpcy5mcmFtZUR1cmF0aW9uID0gb3B0aW9ucy50b3RhbER1cmF0aW9uID8gb3B0aW9ucy50b3RhbER1cmF0aW9uIC8gdGhpcy5mcmFtZXMubGVuZ3RoIDogKF9iID0gb3B0aW9ucy5mcmFtZUR1cmF0aW9uKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLmZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgaWYgKG9wdGlvbnMucmV2ZXJzZSkge1xyXG4gICAgICAgICAgICB0aGlzLnJldmVyc2UoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5nb1RvRnJhbWUoMCk7XHJcbiAgICB9XHJcbiAgICBjbG9uZSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbihPYmplY3QuYXNzaWduKHsgZnJhbWVzOiB0aGlzLmZyYW1lcy5tYXAoKGYpID0+IChPYmplY3QuYXNzaWduKHt9LCBmKSkpLCBmcmFtZUR1cmF0aW9uOiB0aGlzLmZyYW1lRHVyYXRpb24sIHJldmVyc2U6IHRoaXMuX3JldmVyc2VkLCBzdHJhdGVneTogdGhpcy5zdHJhdGVneSB9LCB0aGlzLmNsb25lR3JhcGhpY09wdGlvbnMoKSkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW4gQW5pbWF0aW9uIGZyb20gYSBbW1Nwcml0ZVNoZWV0XV0sIGEgbGlzdCBvZiBpbmRpY2VzIGludG8gdGhlIHNwcml0ZSBzaGVldCwgYSBkdXJhdGlvbiBwZXIgZnJhbWVcclxuICAgICAqIGFuZCBvcHRpb25hbCBbW0FuaW1hdGlvblN0cmF0ZWd5XV1cclxuICAgICAqXHJcbiAgICAgKiBFeGFtcGxlOlxyXG4gICAgICogYGBgdHlwZXNjcmlwdFxyXG4gICAgICogY29uc3Qgc3ByaXRlU2hlZXQgPSBTcHJpdGVTaGVldC5mcm9tSW1hZ2VTb3VyY2Uoey4uLn0pO1xyXG4gICAgICpcclxuICAgICAqIGNvbnN0IGFuaW0gPSBBbmltYXRpb24uZnJvbVNwcml0ZVNoZWV0KHNwcml0ZVNoZWV0LCByYW5nZSgwLCA1KSwgMjAwLCBBbmltYXRpb25TdHJhdGVneS5Mb29wKTtcclxuICAgICAqIGBgYFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzcHJpdGVTaGVldFxyXG4gICAgICogQHBhcmFtIGZyYW1lSW5kaWNlc1xyXG4gICAgICogQHBhcmFtIGR1cmF0aW9uUGVyRnJhbWVNc1xyXG4gICAgICogQHBhcmFtIHN0cmF0ZWd5XHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyBmcm9tU3ByaXRlU2hlZXQoc3ByaXRlU2hlZXQsIGZyYW1lSW5kaWNlcywgZHVyYXRpb25QZXJGcmFtZU1zLCBzdHJhdGVneSA9IEFuaW1hdGlvblN0cmF0ZWd5Lkxvb3ApIHtcclxuICAgICAgICBjb25zdCBtYXhJbmRleCA9IHNwcml0ZVNoZWV0LnNwcml0ZXMubGVuZ3RoIC0gMTtcclxuICAgICAgICBjb25zdCBpbnZhbGlkSW5kaWNlcyA9IGZyYW1lSW5kaWNlcy5maWx0ZXIoKGluZGV4KSA9PiBpbmRleCA8IDAgfHwgaW5kZXggPiBtYXhJbmRleCk7XHJcbiAgICAgICAgaWYgKGludmFsaWRJbmRpY2VzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBBbmltYXRpb24uX0xPR0dFUi53YXJuKGBJbmRpY2VzIGludG8gU3ByaXRlU2hlZXQgd2VyZSBwcm92aWRlZCB0aGF0IGRvblxcJ3QgZXhpc3Q6ICR7aW52YWxpZEluZGljZXMuam9pbignLCcpfSBubyBmcmFtZSB3aWxsIGJlIHNob3duYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBuZXcgQW5pbWF0aW9uKHtcclxuICAgICAgICAgICAgZnJhbWVzOiBzcHJpdGVTaGVldC5zcHJpdGVzXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChfLCBpbmRleCkgPT4gZnJhbWVJbmRpY2VzLmluZGV4T2YoaW5kZXgpID4gLTEpXHJcbiAgICAgICAgICAgICAgICAubWFwKChmKSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgZ3JhcGhpYzogZixcclxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblBlckZyYW1lTXNcclxuICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICBzdHJhdGVneTogc3RyYXRlZ3lcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ29udmVydHMgYW4gYW5pbWF0aW9uIHRvIGEgbGVnYWN5IGFuaW1hdGlvblxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEBwYXJhbSBlbmdpbmVcclxuICAgICAqIEBwYXJhbSBhbmltYXRpb25cclxuICAgICAqIEByZXR1cm5zIExlZ2FjeURyYXdpbmcuQW5pbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyB0b0xlZ2FjeUFuaW1hdGlvbihlbmdpbmUsIGFuaW1hdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGxlZ2FjeVNwcml0ZXMgPSBhbmltYXRpb24uZnJhbWVzLm1hcChmID0+IFNwcml0ZS50b0xlZ2FjeVNwcml0ZShmLmdyYXBoaWMpKTtcclxuICAgICAgICByZXR1cm4gbmV3IEFuaW1hdGlvbl9BbmltYXRpb24oe1xyXG4gICAgICAgICAgICBzcHJpdGVzOiBsZWdhY3lTcHJpdGVzLFxyXG4gICAgICAgICAgICBsb29wOiBhbmltYXRpb24uc3RyYXRlZ3kgPT09IEFuaW1hdGlvblN0cmF0ZWd5Lkxvb3AsXHJcbiAgICAgICAgICAgIGZyZWV6ZUZyYW1lOiBhbmltYXRpb24uc3RyYXRlZ3kgPT09IEFuaW1hdGlvblN0cmF0ZWd5LkZyZWV6ZSA/IGxlZ2FjeVNwcml0ZXMubGVuZ3RoIC0gMSA6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgc3BlZWQ6IGFuaW1hdGlvbi5mcmFtZUR1cmF0aW9uLFxyXG4gICAgICAgICAgICBlbmdpbmU6IGVuZ2luZVxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IEZyYW1lIG9mIHRoZSBhbmltYXRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0IGN1cnJlbnRGcmFtZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudEZyYW1lID49IDAgJiYgdGhpcy5fY3VycmVudEZyYW1lIDwgdGhpcy5mcmFtZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZyYW1lc1t0aGlzLl9jdXJyZW50RnJhbWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgY3VycmVudCBmcmFtZSBpbmRleCBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICAgKi9cclxuICAgIGdldCBjdXJyZW50RnJhbWVJbmRleCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudEZyYW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYW5pbWF0aW9uIGlzIHBsYXlpbmdcclxuICAgICAqL1xyXG4gICAgZ2V0IGlzUGxheWluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGxheWluZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV2ZXJzZXMgdGhlIHBsYXkgZGlyZWN0aW9uIG9mIHRoZSBBbmltYXRpb24sIHRoaXMgcHJlc2VydmVzIHRoZSBjdXJyZW50IGZyYW1lXHJcbiAgICAgKi9cclxuICAgIHJldmVyc2UoKSB7XHJcbiAgICAgICAgLy8gRG9uJ3QgbXV0YXRlIHdpdGggdGhlIG9yaWdpbmFsIGZyYW1lIGxpc3QsIGNyZWF0ZSBhIGNvcHlcclxuICAgICAgICB0aGlzLmZyYW1lcyA9IHRoaXMuZnJhbWVzLnNsaWNlKCkucmV2ZXJzZSgpO1xyXG4gICAgICAgIHRoaXMuX3JldmVyc2VkID0gIXRoaXMuX3JldmVyc2VkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXkgZGlyZWN0aW9uIG9mIHRoZSBhbmltYXRpb25cclxuICAgICAqL1xyXG4gICAgZ2V0IGRpcmVjdGlvbigpIHtcclxuICAgICAgICAvLyBLZWVwIGxvZ2ljYWxseSBjb25zaXN0ZW50IHdpdGggcGluZy1wb25nIGRpcmVjdGlvblxyXG4gICAgICAgIC8vIElmIHBpbmctcG9uZyBpcyBmb3J3YXJkID0gMSBhbmQgcmV2ZXJzZWQgaXMgdHJ1ZSB0aGVuIHdlIGFyZSBsb2dpY2FsbHkgcmV2ZXJzZWRcclxuICAgICAgICBjb25zdCByZXZlcnNlZCA9ICh0aGlzLl9yZXZlcnNlZCAmJiB0aGlzLl9kaXJlY3Rpb24gPT09IDEpID8gdHJ1ZSA6IGZhbHNlO1xyXG4gICAgICAgIHJldHVybiByZXZlcnNlZCA/IEFuaW1hdGlvbkRpcmVjdGlvbi5CYWNrd2FyZCA6IEFuaW1hdGlvbkRpcmVjdGlvbi5Gb3J3YXJkO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQbGF5cyBvciByZXN1bWVzIHRoZSBhbmltYXRpb24gZnJvbSB0aGUgY3VycmVudCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBwbGF5KCkge1xyXG4gICAgICAgIHRoaXMuX3BsYXlpbmcgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQYXVzZXMgdGhlIGFuaW1hdGlvbiBvbiB0aGUgY3VycmVudCBmcmFtZVxyXG4gICAgICovXHJcbiAgICBwYXVzZSgpIHtcclxuICAgICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZmlyc3RUaWNrID0gdHJ1ZTsgLy8gZmlyc3RUaWNrIG11c3QgYmUgc2V0IHRvIGVtaXQgdGhlIHByb3BlciBmcmFtZSBldmVudFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgYW5pbWF0aW9uIGJhY2sgdG8gdGhlIGJlZ2lubmluZywgaW5jbHVkaW5nIGlmIHRoZSBhbmltYXRpb24gd2VyZSBkb25lXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9maXJzdFRpY2sgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBhbmltYXRpb24gY2FuIGVuZFxyXG4gICAgICovXHJcbiAgICBnZXQgY2FuRmluaXNoKCkge1xyXG4gICAgICAgIHN3aXRjaCAodGhpcy5zdHJhdGVneSkge1xyXG4gICAgICAgICAgICBjYXNlIEFuaW1hdGlvblN0cmF0ZWd5LkVuZDpcclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TdHJhdGVneS5GcmVlemU6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFuaW1hdGlvbiBpcyBkb25lLCBmb3IgbG9vcGluZyB0eXBlIGFuaW1hdGlvbnNcclxuICAgICAqIGBleC5BbmltYXRpb25TdHJhdGVneS5QaW5nUG9uZ2AgYW5kIGBleC5BbmltYXRpb25TdHJhdGVneS5Mb29wYCB0aGlzIHdpbGwgYWx3YXlzIHJldHVybiBgZmFsc2VgXHJcbiAgICAgKlxyXG4gICAgICogU2VlIHRoZSBgZXguQW5pbWF0aW9uLmNhbkZpbmlzaCgpYCBtZXRob2QgdG8ga25vdyBpZiBhbiBhbmltYXRpb24gdHlwZSBjYW4gZW5kXHJcbiAgICAgKi9cclxuICAgIGdldCBkb25lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kb25lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBKdW1wIHRoZSBhbmltYXRpb24gaW1tZWRpYXRlbHkgdG8gYSBzcGVjaWZpYyBmcmFtZSBpZiBpdCBleGlzdHNcclxuICAgICAqIEBwYXJhbSBmcmFtZU51bWJlclxyXG4gICAgICovXHJcbiAgICBnb1RvRnJhbWUoZnJhbWVOdW1iZXIpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRGcmFtZSA9IGZyYW1lTnVtYmVyO1xyXG4gICAgICAgIHRoaXMuX3RpbWVMZWZ0SW5GcmFtZSA9IHRoaXMuZnJhbWVEdXJhdGlvbjtcclxuICAgICAgICBjb25zdCBtYXliZUZyYW1lID0gdGhpcy5mcmFtZXNbdGhpcy5fY3VycmVudEZyYW1lXTtcclxuICAgICAgICBpZiAobWF5YmVGcmFtZSAmJiAhdGhpcy5fZG9uZSkge1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lTGVmdEluRnJhbWUgPSAobWF5YmVGcmFtZSA9PT0gbnVsbCB8fCBtYXliZUZyYW1lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtYXliZUZyYW1lLmR1cmF0aW9uKSB8fCB0aGlzLmZyYW1lRHVyYXRpb247XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAoX2EgPSBtYXliZUZyYW1lLmdyYXBoaWMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aWR0aDtcclxuICAgICAgICAgICAgdGhpcy5oZWlnaHQgPSAoX2IgPSBtYXliZUZyYW1lLmdyYXBoaWMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQ7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2ZyYW1lJywgbWF5YmVGcmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX25leHRGcmFtZSgpIHtcclxuICAgICAgICBjb25zdCBjdXJyZW50RnJhbWUgPSB0aGlzLl9jdXJyZW50RnJhbWU7XHJcbiAgICAgICAgaWYgKHRoaXMuX2RvbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRGcmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IG5leHQgPSAtMTtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TdHJhdGVneS5Mb29wOiB7XHJcbiAgICAgICAgICAgICAgICBuZXh0ID0gKGN1cnJlbnRGcmFtZSArIDEpICUgdGhpcy5mcmFtZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdsb29wJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEFuaW1hdGlvblN0cmF0ZWd5LkVuZDoge1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IGN1cnJlbnRGcmFtZSArIDE7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dCA+PSB0aGlzLmZyYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50RnJhbWUgPSB0aGlzLmZyYW1lcy5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnZW5kJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlIEFuaW1hdGlvblN0cmF0ZWd5LkZyZWV6ZToge1xyXG4gICAgICAgICAgICAgICAgbmV4dCA9IGNsYW1wKGN1cnJlbnRGcmFtZSArIDEsIDAsIHRoaXMuZnJhbWVzLmxlbmd0aCAtIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPj0gdGhpcy5mcmFtZXMubGVuZ3RoIC0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2VuZCcsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBBbmltYXRpb25TdHJhdGVneS5QaW5nUG9uZzoge1xyXG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGcmFtZSArIHRoaXMuX2RpcmVjdGlvbiA+PSB0aGlzLmZyYW1lcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5lbWl0KCdsb29wJywgdGhpcyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEZyYW1lICsgdGhpcy5fZGlyZWN0aW9uIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudHMuZW1pdCgnbG9vcCcsIHRoaXMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbmV4dCA9IGN1cnJlbnRGcmFtZSArICh0aGlzLl9kaXJlY3Rpb24gJSB0aGlzLmZyYW1lcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG5leHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxlZCBpbnRlcm5hbGx5IGJ5IEV4Y2FsaWJ1ciB0byB1cGRhdGUgdGhlIHN0YXRlIG9mIHRoZSBhbmltYXRpb24gcG90ZW50aWFsIHVwZGF0ZSB0aGUgY3VycmVudCBmcmFtZVxyXG4gICAgICogQHBhcmFtIGVsYXBzZWRNaWxsaXNlY29uZHMgTWlsbGlzZWNvbmRzIGVsYXBzZWRcclxuICAgICAqIEBwYXJhbSBpZGVtcG90ZW5jeVRva2VuIFByZXZlbnRzIGRvdWJsZSB0aWNraW5nIGluIGEgZnJhbWUgYnkgcGFzc2luZyBhIHVuaXF1ZSB0b2tlbiB0byB0aGUgZnJhbWVcclxuICAgICAqL1xyXG4gICAgdGljayhlbGFwc2VkTWlsbGlzZWNvbmRzLCBpZGVtcG90ZW5jeVRva2VuID0gMCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pZGVtcG90ZW5jeVRva2VuID09PSBpZGVtcG90ZW5jeVRva2VuKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faWRlbXBvdGVuY3lUb2tlbiA9IGlkZW1wb3RlbmN5VG9rZW47XHJcbiAgICAgICAgaWYgKCF0aGlzLl9wbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gaWYgaXQncyB0aGUgZmlyc3QgZnJhbWUgZW1pdCBmcmFtZSBldmVudFxyXG4gICAgICAgIGlmICh0aGlzLl9maXJzdFRpY2spIHtcclxuICAgICAgICAgICAgdGhpcy5fZmlyc3RUaWNrID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzLmVtaXQoJ2ZyYW1lJywgdGhpcy5jdXJyZW50RnJhbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90aW1lTGVmdEluRnJhbWUgLT0gZWxhcHNlZE1pbGxpc2Vjb25kcyAqIHRoaXMudGltZVNjYWxlO1xyXG4gICAgICAgIGlmICh0aGlzLl90aW1lTGVmdEluRnJhbWUgPD0gMCkge1xyXG4gICAgICAgICAgICB0aGlzLmdvVG9GcmFtZSh0aGlzLl9uZXh0RnJhbWUoKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVEaW1lbnNpb25zKCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEZyYW1lKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2lkdGggPSAoX2EgPSB0aGlzLmN1cnJlbnRGcmFtZS5ncmFwaGljKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGg7XHJcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gKF9iID0gdGhpcy5jdXJyZW50RnJhbWUuZ3JhcGhpYykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZHJhd0ltYWdlKGN0eCwgeCwgeSkge1xyXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRGcmFtZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRGcmFtZS5ncmFwaGljLmRyYXcoY3R4LCB4LCB5KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuQW5pbWF0aW9uLl9MT0dHRVIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9HcmFwaGljc0dyb3VwLnRzXG5cclxuXHJcblxyXG5jbGFzcyBHcmFwaGljc0dyb3VwIGV4dGVuZHMgR3JhcGhpYyB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gb3B0aW9ucy5tZW1iZXJzO1xyXG4gICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgR3JhcGhpY3NHcm91cChPYmplY3QuYXNzaWduKHsgbWVtYmVyczogWy4uLnRoaXMubWVtYmVyc10gfSwgdGhpcy5jbG9uZUdyYXBoaWNPcHRpb25zKCkpKTtcclxuICAgIH1cclxuICAgIF91cGRhdGVEaW1lbnNpb25zKCkge1xyXG4gICAgICAgIGxldCBiYiA9IG5ldyBCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBncmFwaGljLCBwb3MgfSBvZiB0aGlzLm1lbWJlcnMpIHtcclxuICAgICAgICAgICAgYmIgPSBncmFwaGljLmxvY2FsQm91bmRzLnRyYW5zbGF0ZShwb3MpLmNvbWJpbmUoYmIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndpZHRoID0gYmIud2lkdGg7XHJcbiAgICAgICAgdGhpcy5oZWlnaHQgPSBiYi5oZWlnaHQ7XHJcbiAgICAgICAgcmV0dXJuIGJiO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIGxldCBiYiA9IG5ldyBCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIGZvciAoY29uc3QgeyBncmFwaGljLCBwb3MgfSBvZiB0aGlzLm1lbWJlcnMpIHtcclxuICAgICAgICAgICAgYmIgPSBncmFwaGljLmxvY2FsQm91bmRzLnRyYW5zbGF0ZShwb3MpLmNvbWJpbmUoYmIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYmI7XHJcbiAgICB9XHJcbiAgICBfaXNBbmltYXRpb25Pckdyb3VwKGdyYXBoaWMpIHtcclxuICAgICAgICByZXR1cm4gZ3JhcGhpYyBpbnN0YW5jZW9mIEFuaW1hdGlvbiB8fCBncmFwaGljIGluc3RhbmNlb2YgR3JhcGhpY3NHcm91cDtcclxuICAgIH1cclxuICAgIHRpY2soZWxhcHNlZE1pbGxpc2Vjb25kcywgaWRlbXBvdGVuY3lUb2tlbikge1xyXG4gICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHRoaXMubWVtYmVycykge1xyXG4gICAgICAgICAgICBjb25zdCBtYXliZUFuaW1hdGlvbiA9IG1lbWJlci5ncmFwaGljO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNBbmltYXRpb25Pckdyb3VwKG1heWJlQW5pbWF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgbWF5YmVBbmltYXRpb24udGljayhlbGFwc2VkTWlsbGlzZWNvbmRzLCBpZGVtcG90ZW5jeVRva2VuKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlc2V0KCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgbWVtYmVyIG9mIHRoaXMubWVtYmVycykge1xyXG4gICAgICAgICAgICBjb25zdCBtYXliZUFuaW1hdGlvbiA9IG1lbWJlci5ncmFwaGljO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faXNBbmltYXRpb25Pckdyb3VwKG1heWJlQW5pbWF0aW9uKSkge1xyXG4gICAgICAgICAgICAgICAgbWF5YmVBbmltYXRpb24ucmVzZXQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9wcmVEcmF3KGV4LCB4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xyXG4gICAgICAgIHN1cGVyLl9wcmVEcmF3KGV4LCB4LCB5KTtcclxuICAgIH1cclxuICAgIF9kcmF3SW1hZ2UoZXgsIHgsIHkpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0aGlzLm1lbWJlcnMpIHtcclxuICAgICAgICAgICAgZXguc2F2ZSgpO1xyXG4gICAgICAgICAgICBleC50cmFuc2xhdGUoeCwgeSk7XHJcbiAgICAgICAgICAgIG1lbWJlci5ncmFwaGljLmRyYXcoZXgsIG1lbWJlci5wb3MueCwgbWVtYmVyLnBvcy55KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuc2hvd0RlYnVnKSB7XHJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICAgICAgZXguZGVidWcuZHJhd1JlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGV4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9QYXJ0aWNsZXMudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEFuIGVudW0gdGhhdCByZXByZXNlbnRzIHRoZSB0eXBlcyBvZiBlbWl0dGVyIG5venpsZXNcclxuICovXHJcbnZhciBFbWl0dGVyVHlwZTtcclxuKGZ1bmN0aW9uIChFbWl0dGVyVHlwZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25zdGFudCBmb3IgdGhlIGNpcmN1bGFyIGVtaXR0ZXIgdHlwZVxyXG4gICAgICovXHJcbiAgICBFbWl0dGVyVHlwZVtFbWl0dGVyVHlwZVtcIkNpcmNsZVwiXSA9IDBdID0gXCJDaXJjbGVcIjtcclxuICAgIC8qKlxyXG4gICAgICogQ29uc3RhbnQgZm9yIHRoZSByZWN0YW5ndWxhciBlbWl0dGVyIHR5cGVcclxuICAgICAqL1xyXG4gICAgRW1pdHRlclR5cGVbRW1pdHRlclR5cGVbXCJSZWN0YW5nbGVcIl0gPSAxXSA9IFwiUmVjdGFuZ2xlXCI7XHJcbn0pKEVtaXR0ZXJUeXBlIHx8IChFbWl0dGVyVHlwZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBAaGlkZGVuXHJcbiAqL1xyXG5jbGFzcyBQYXJ0aWNsZUltcGwgZXh0ZW5kcyBFbnRpdHkge1xyXG4gICAgY29uc3RydWN0b3IoZW1pdHRlck9yQ29uZmlnLCBsaWZlLCBvcGFjaXR5LCBiZWdpbkNvbG9yLCBlbmRDb2xvciwgcG9zaXRpb24sIHZlbG9jaXR5LCBhY2NlbGVyYXRpb24sIHN0YXJ0U2l6ZSwgZW5kU2l6ZSkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy52ZWxvY2l0eSA9IG5ldyBWZWN0b3IoMCwgMCk7XHJcbiAgICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgIHRoaXMuY3VycmVudFJvdGF0aW9uID0gMDtcclxuICAgICAgICB0aGlzLmZvY3VzID0gbnVsbDtcclxuICAgICAgICB0aGlzLmZvY3VzQWNjZWwgPSAwO1xyXG4gICAgICAgIHRoaXMub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgdGhpcy5lbmRDb2xvciA9IENvbG9yLldoaXRlO1xyXG4gICAgICAgIC8vIExpZmUgaXMgY291bnRlZCBpbiBtc1xyXG4gICAgICAgIHRoaXMubGlmZSA9IDMwMDtcclxuICAgICAgICB0aGlzLmZhZGVGbGFnID0gZmFsc2U7XHJcbiAgICAgICAgLy8gQ29sb3IgdHJhbnNpdGlvbnNcclxuICAgICAgICB0aGlzLl9yUmF0ZSA9IDE7XHJcbiAgICAgICAgdGhpcy5fZ1JhdGUgPSAxO1xyXG4gICAgICAgIHRoaXMuX2JSYXRlID0gMTtcclxuICAgICAgICB0aGlzLl9hUmF0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudENvbG9yID0gQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbnVsbDtcclxuICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IDU7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5zaXplUmF0ZSA9IDA7XHJcbiAgICAgICAgdGhpcy5lbGFwc2VkTXVsdGlwbGllciA9IDA7XHJcbiAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLmlzT2Zmc2NyZWVuID0gZmFsc2U7XHJcbiAgICAgICAgbGV0IGVtaXR0ZXIgPSBlbWl0dGVyT3JDb25maWc7XHJcbiAgICAgICAgaWYgKGVtaXR0ZXIgJiYgIShlbWl0dGVyT3JDb25maWcgaW5zdGFuY2VvZiBQYXJ0aWNsZUVtaXR0ZXIpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGVtaXR0ZXJPckNvbmZpZztcclxuICAgICAgICAgICAgZW1pdHRlciA9IGNvbmZpZy5lbWl0dGVyO1xyXG4gICAgICAgICAgICBsaWZlID0gY29uZmlnLmxpZmU7XHJcbiAgICAgICAgICAgIG9wYWNpdHkgPSBjb25maWcub3BhY2l0eTtcclxuICAgICAgICAgICAgZW5kQ29sb3IgPSBjb25maWcuZW5kQ29sb3I7XHJcbiAgICAgICAgICAgIGJlZ2luQ29sb3IgPSBjb25maWcuYmVnaW5Db2xvcjtcclxuICAgICAgICAgICAgcG9zaXRpb24gPSBjb25maWcucG9zaXRpb247XHJcbiAgICAgICAgICAgIHZlbG9jaXR5ID0gY29uZmlnLnZlbG9jaXR5O1xyXG4gICAgICAgICAgICBhY2NlbGVyYXRpb24gPSBjb25maWcuYWNjZWxlcmF0aW9uO1xyXG4gICAgICAgICAgICBzdGFydFNpemUgPSBjb25maWcuc3RhcnRTaXplO1xyXG4gICAgICAgICAgICBlbmRTaXplID0gY29uZmlnLmVuZFNpemU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XHJcbiAgICAgICAgdGhpcy5saWZlID0gbGlmZSB8fCB0aGlzLmxpZmU7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gb3BhY2l0eSB8fCB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgdGhpcy5lbmRDb2xvciA9IGVuZENvbG9yIHx8IHRoaXMuZW5kQ29sb3IuY2xvbmUoKTtcclxuICAgICAgICB0aGlzLmJlZ2luQ29sb3IgPSBiZWdpbkNvbG9yIHx8IHRoaXMuYmVnaW5Db2xvci5jbG9uZSgpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRDb2xvciA9IHRoaXMuYmVnaW5Db2xvci5jbG9uZSgpO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAocG9zaXRpb24gfHwgdGhpcy5wb3NpdGlvbikuYWRkKHRoaXMuZW1pdHRlci5wb3MpO1xyXG4gICAgICAgIHRoaXMudmVsb2NpdHkgPSB2ZWxvY2l0eSB8fCB0aGlzLnZlbG9jaXR5O1xyXG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gYWNjZWxlcmF0aW9uIHx8IHRoaXMuYWNjZWxlcmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX3JSYXRlID0gKHRoaXMuZW5kQ29sb3IuciAtIHRoaXMuYmVnaW5Db2xvci5yKSAvIHRoaXMubGlmZTtcclxuICAgICAgICB0aGlzLl9nUmF0ZSA9ICh0aGlzLmVuZENvbG9yLmcgLSB0aGlzLmJlZ2luQ29sb3IuZykgLyB0aGlzLmxpZmU7XHJcbiAgICAgICAgdGhpcy5fYlJhdGUgPSAodGhpcy5lbmRDb2xvci5iIC0gdGhpcy5iZWdpbkNvbG9yLmIpIC8gdGhpcy5saWZlO1xyXG4gICAgICAgIHRoaXMuX2FSYXRlID0gdGhpcy5vcGFjaXR5IC8gdGhpcy5saWZlO1xyXG4gICAgICAgIHRoaXMuc3RhcnRTaXplID0gc3RhcnRTaXplIHx8IDA7XHJcbiAgICAgICAgdGhpcy5lbmRTaXplID0gZW5kU2l6ZSB8fCAwO1xyXG4gICAgICAgIGlmICh0aGlzLmVuZFNpemUgPiAwICYmIHRoaXMuc3RhcnRTaXplID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnNpemVSYXRlID0gKHRoaXMuZW5kU2l6ZSAtIHRoaXMuc3RhcnRTaXplKSAvIHRoaXMubGlmZTtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNpemUgPSB0aGlzLnN0YXJ0U2l6ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQoKHRoaXMudHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybUNvbXBvbmVudCgpKSk7XHJcbiAgICAgICAgdGhpcy5hZGRDb21wb25lbnQobmV3IENhbnZhc0RyYXdDb21wb25lbnQoKGN0eCkgPT4gdGhpcy5kcmF3KGN0eCkpKTtcclxuICAgICAgICB0aGlzLmFkZENvbXBvbmVudCgodGhpcy5ncmFwaGljcyA9IG5ldyBHcmFwaGljc0NvbXBvbmVudCgpKSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0ucG9zID0gdGhpcy5wb3NpdGlvbjtcclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbiA9IHRoaXMuY3VycmVudFJvdGF0aW9uO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnNjYWxlID0gdmVjKDEsIDEpOyAvLyBUT0RPIHd1dFxyXG4gICAgICAgIGlmICh0aGlzLnBhcnRpY2xlU3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3Mub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy51c2UoU3ByaXRlLmZyb21MZWdhY3lTcHJpdGUodGhpcy5wYXJ0aWNsZVNwcml0ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5vblBvc3REcmF3ID0gKGN0eCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3Mub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRtcENvbG9yID0gdGhpcy5fY3VycmVudENvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgICAgICAgICB0bXBDb2xvci5hID0gMTtcclxuICAgICAgICAgICAgICAgIGN0eC5kZWJ1Zy5kcmF3UG9pbnQodmVjKDAsIDApLCB7IGNvbG9yOiB0bXBDb2xvciwgc2l6ZTogdGhpcy5wYXJ0aWNsZVNpemUgfSk7XHJcbiAgICAgICAgICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGtpbGwoKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0dGVyLnJlbW92ZVBhcnRpY2xlKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKF9lbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5saWZlID0gdGhpcy5saWZlIC0gZGVsdGE7XHJcbiAgICAgICAgdGhpcy5lbGFwc2VkTXVsdGlwbGllciA9IHRoaXMuZWxhcHNlZE11bHRpcGxpZXIgKyBkZWx0YTtcclxuICAgICAgICBpZiAodGhpcy5saWZlIDwgMCkge1xyXG4gICAgICAgICAgICB0aGlzLmtpbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZmFkZUZsYWcpIHtcclxuICAgICAgICAgICAgdGhpcy5vcGFjaXR5ID0gY2xhbXAodGhpcy5fYVJhdGUgKiB0aGlzLmxpZmUsIDAuMDAwMSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnN0YXJ0U2l6ZSA+IDAgJiYgdGhpcy5lbmRTaXplID4gMCkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlU2l6ZSA9IGNsYW1wKHRoaXMuc2l6ZVJhdGUgKiBkZWx0YSArIHRoaXMucGFydGljbGVTaXplLCBNYXRoLm1pbih0aGlzLnN0YXJ0U2l6ZSwgdGhpcy5lbmRTaXplKSwgTWF0aC5tYXgodGhpcy5zdGFydFNpemUsIHRoaXMuZW5kU2l6ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IuciA9IGNsYW1wKHRoaXMuX2N1cnJlbnRDb2xvci5yICsgdGhpcy5fclJhdGUgKiBkZWx0YSwgMCwgMjU1KTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IuZyA9IGNsYW1wKHRoaXMuX2N1cnJlbnRDb2xvci5nICsgdGhpcy5fZ1JhdGUgKiBkZWx0YSwgMCwgMjU1KTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IuYiA9IGNsYW1wKHRoaXMuX2N1cnJlbnRDb2xvci5iICsgdGhpcy5fYlJhdGUgKiBkZWx0YSwgMCwgMjU1KTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IuYSA9IGNsYW1wKHRoaXMub3BhY2l0eSwgMC4wMDAxLCAxKTtcclxuICAgICAgICBpZiAodGhpcy5mb2N1cykge1xyXG4gICAgICAgICAgICBjb25zdCBhY2NlbCA9IHRoaXMuZm9jdXNcclxuICAgICAgICAgICAgICAgIC5zdWIodGhpcy5wb3NpdGlvbilcclxuICAgICAgICAgICAgICAgIC5ub3JtYWxpemUoKVxyXG4gICAgICAgICAgICAgICAgLnNjYWxlKHRoaXMuZm9jdXNBY2NlbClcclxuICAgICAgICAgICAgICAgIC5zY2FsZShkZWx0YSAvIDEwMDApO1xyXG4gICAgICAgICAgICB0aGlzLnZlbG9jaXR5ID0gdGhpcy52ZWxvY2l0eS5hZGQoYWNjZWwpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy52ZWxvY2l0eSA9IHRoaXMudmVsb2NpdHkuYWRkKHRoaXMuYWNjZWxlcmF0aW9uLnNjYWxlKGRlbHRhIC8gMTAwMCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbi5hZGQodGhpcy52ZWxvY2l0eS5zY2FsZShkZWx0YSAvIDEwMDApKTtcclxuICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRSb3RhdGlvbiA9ICh0aGlzLmN1cnJlbnRSb3RhdGlvbiArICh0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ICogZGVsdGEpIC8gMTAwMCkgJSAoMiAqIE1hdGguUEkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnRyYW5zZm9ybS5wb3MgPSB0aGlzLnBvc2l0aW9uO1xyXG4gICAgICAgIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uID0gdGhpcy5jdXJyZW50Um90YXRpb247XHJcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uc2NhbGUgPSB2ZWMoMSwgMSk7IC8vIHRvZG8gd3V0XHJcbiAgICAgICAgdGhpcy5ncmFwaGljcy5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgZHJhdyhjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5wYXJ0aWNsZVNwcml0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlU3ByaXRlLm9wYWNpdHkodGhpcy5vcGFjaXR5KTtcclxuICAgICAgICAgICAgdGhpcy5wYXJ0aWNsZVNwcml0ZS5kcmF3KGN0eCwgMCwgMCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICB0aGlzLl9jdXJyZW50Q29sb3IuYSA9IGNsYW1wKHRoaXMub3BhY2l0eSwgMC4wMDAxLCAxKTtcclxuICAgICAgICBjdHguZmlsbFN0eWxlID0gdGhpcy5fY3VycmVudENvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIGN0eC5hcmMoMCwgMCwgdGhpcy5wYXJ0aWNsZVNpemUsIDAsIE1hdGguUEkgKiAyKTtcclxuICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICBjdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBQYXJ0aWNsZSBpcyB1c2VkIGluIGEgW1tQYXJ0aWNsZUVtaXR0ZXJdXVxyXG4gKi9cclxuY2xhc3MgUGFydGljbGUgZXh0ZW5kcyBDb25maWd1cmFibGUoUGFydGljbGVJbXBsKSB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbWl0dGVyT3JDb25maWcsIGxpZmUsIG9wYWNpdHksIGJlZ2luQ29sb3IsIGVuZENvbG9yLCBwb3NpdGlvbiwgdmVsb2NpdHksIGFjY2VsZXJhdGlvbiwgc3RhcnRTaXplLCBlbmRTaXplKSB7XHJcbiAgICAgICAgc3VwZXIoZW1pdHRlck9yQ29uZmlnLCBsaWZlLCBvcGFjaXR5LCBiZWdpbkNvbG9yLCBlbmRDb2xvciwgcG9zaXRpb24sIHZlbG9jaXR5LCBhY2NlbGVyYXRpb24sIHN0YXJ0U2l6ZSwgZW5kU2l6ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFVzaW5nIGEgcGFydGljbGUgZW1pdHRlciBpcyBhIGdyZWF0IHdheSB0byBjcmVhdGUgaW50ZXJlc3RpbmcgZWZmZWN0c1xyXG4gKiBpbiB5b3VyIGdhbWUsIGxpa2Ugc21va2UsIGZpcmUsIHdhdGVyLCBleHBsb3Npb25zLCBldGMuIGBQYXJ0aWNsZUVtaXR0ZXJgXHJcbiAqIGV4dGVuZCBbW0FjdG9yXV0gYWxsb3dpbmcgeW91IHRvIHVzZSBhbGwgb2YgdGhlIGZlYXR1cmVzIHRoYXQgY29tZSB3aXRoLlxyXG4gKi9cclxuY2xhc3MgUGFydGljbGVFbWl0dGVyIGV4dGVuZHMgQWN0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnIHBhcnRpY2xlIGVtaXR0ZXIgb3B0aW9ucyBiYWdcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICBzdXBlcih7IHdpZHRoOiAoX2EgPSBjb25maWcud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDAsIGhlaWdodDogKF9iID0gY29uZmlnLmhlaWdodCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMCB9KTtcclxuICAgICAgICB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgPSAwO1xyXG4gICAgICAgIHRoaXMubnVtUGFydGljbGVzID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGlzRW1pdHRpbmcgZmxhZ1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuaXNFbWl0dGluZyA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBiYWNraW5nIHBhcnRpY2xlIGNvbGxlY3Rpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhcnRpY2xlcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYmFja2luZyBkZWFkUGFydGljbGUgY29sbGVjdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZGVhZFBhcnRpY2xlcyA9IFtdO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSBwYXJ0aWNsZSB2ZWxvY2l0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubWluVmVsID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gcGFydGljbGUgdmVsb2NpdHlcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1heFZlbCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBhY2NlbGVyYXRpb24gdmVjdG9yIGZvciBhbGwgcGFydGljbGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5hY2NlbGVyYXRpb24gPSBuZXcgVmVjdG9yKDAsIDApO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgbWluaW11bSBhbmdsZSBpbiByYWRpYW5zXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5taW5BbmdsZSA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBtYXhpbXVtIGFuZ2xlIGluIHJhZGlhbnNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1heEFuZ2xlID0gMDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXNzaW9uIHJhdGUgZm9yIHBhcnRpY2xlcyAocGFydGljbGVzL3NlYylcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVtaXRSYXRlID0gMTsgLy9wYXJ0aWNsZXMvc2VjXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBsaWZlIG9mIGVhY2ggcGFydGljbGUgaW4gbWlsbGlzZWNvbmRzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZUxpZmUgPSAyMDAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZmFkZSBmbGFnIHdoaWNoIGNhdXNlcyBwYXJ0aWNsZXMgdG8gZ3JhZHVhbGx5IGZhZGUgb3V0IG92ZXIgdGhlIGNvdXJzZSBvZiB0aGVpciBsaWZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZmFkZUZsYWcgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIGZvY3VzIHdoZXJlIGFsbCBwYXJ0aWNsZXMgc2hvdWxkIGFjY2VsZXJhdGUgdG93YXJkc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZm9jdXMgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgYWNjZWxlcmF0aW9uIGZvciBmb2N1c2luZyBwYXJ0aWNsZXMgaWYgYSBmb2N1cyBoYXMgYmVlbiBzcGVjaWZpZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZvY3VzQWNjZWwgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgb3B0aW9uYWwgc3RhcnRpbmcgc2l6ZSBmb3IgdGhlIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3RhcnRTaXplID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG9wdGlvbmFsIGVuZGluZyBzaXplIGZvciB0aGUgcGFydGljbGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5lbmRTaXplID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1pbmltdW0gc2l6ZSBvZiBhbGwgcGFydGljbGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5taW5TaXplID0gNTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIG1heGltdW0gc2l6ZSBvZiBhbGwgcGFydGljbGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tYXhTaXplID0gNTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGJlZ2lubmluZyBjb2xvciBvZiBhbGwgcGFydGljbGVzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gQ29sb3IuV2hpdGU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyBvciBzZXRzIHRoZSBlbmRpbmcgY29sb3Igb2YgYWxsIHBhcnRpY2xlc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZW5kQ29sb3IgPSBDb2xvci5XaGl0ZTtcclxuICAgICAgICB0aGlzLl9vZyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fc3ByaXRlID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGVtaXR0ZXIgdHlwZSBmb3IgdGhlIHBhcnRpY2xlIGVtaXR0ZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVtaXR0ZXJUeXBlID0gRW1pdHRlclR5cGUuUmVjdGFuZ2xlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgZW1pdHRlciByYWRpdXMsIG9ubHkgdGFrZXMgZWZmZWN0IHdoZW4gdGhlIFtbZW1pdHRlclR5cGVdXSBpcyBbW0VtaXR0ZXJUeXBlLkNpcmNsZV1dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5yYWRpdXMgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgcGFydGljbGUgcm90YXRpb25hbCBzcGVlZCB2ZWxvY2l0eVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHBhcnRpY2xlcyBzaG91bGQgc3RhcnQgd2l0aCBhIHJhbmRvbSByb3RhdGlvblxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucmFuZG9tUm90YXRpb24gPSBmYWxzZTtcclxuICAgICAgICBjb25zdCB7IHgsIHksIHBvcywgaXNFbWl0dGluZywgbWluVmVsLCBtYXhWZWwsIGFjY2VsZXJhdGlvbiwgbWluQW5nbGUsIG1heEFuZ2xlLCBlbWl0UmF0ZSwgcGFydGljbGVMaWZlLCBvcGFjaXR5LCBmYWRlRmxhZywgZm9jdXMsIGZvY3VzQWNjZWwsIHN0YXJ0U2l6ZSwgZW5kU2l6ZSwgbWluU2l6ZSwgbWF4U2l6ZSwgYmVnaW5Db2xvciwgZW5kQ29sb3IsIHBhcnRpY2xlU3ByaXRlLCBlbWl0dGVyVHlwZSwgcmFkaXVzLCBwYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSwgcmFuZG9tUm90YXRpb24sIHJhbmRvbSB9ID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKTtcclxuICAgICAgICB0aGlzLnBvcyA9IHBvcyAhPT0gbnVsbCAmJiBwb3MgIT09IHZvaWQgMCA/IHBvcyA6IHZlYyh4ICE9PSBudWxsICYmIHggIT09IHZvaWQgMCA/IHggOiAwLCB5ICE9PSBudWxsICYmIHkgIT09IHZvaWQgMCA/IHkgOiAwKTtcclxuICAgICAgICB0aGlzLmlzRW1pdHRpbmcgPSBpc0VtaXR0aW5nICE9PSBudWxsICYmIGlzRW1pdHRpbmcgIT09IHZvaWQgMCA/IGlzRW1pdHRpbmcgOiB0aGlzLmlzRW1pdHRpbmc7XHJcbiAgICAgICAgdGhpcy5taW5WZWwgPSBtaW5WZWwgIT09IG51bGwgJiYgbWluVmVsICE9PSB2b2lkIDAgPyBtaW5WZWwgOiB0aGlzLm1pblZlbDtcclxuICAgICAgICB0aGlzLm1heFZlbCA9IG1heFZlbCAhPT0gbnVsbCAmJiBtYXhWZWwgIT09IHZvaWQgMCA/IG1heFZlbCA6IHRoaXMubWF4VmVsO1xyXG4gICAgICAgIHRoaXMuYWNjZWxlcmF0aW9uID0gYWNjZWxlcmF0aW9uICE9PSBudWxsICYmIGFjY2VsZXJhdGlvbiAhPT0gdm9pZCAwID8gYWNjZWxlcmF0aW9uIDogdGhpcy5hY2NlbGVyYXRpb247XHJcbiAgICAgICAgdGhpcy5taW5BbmdsZSA9IG1pbkFuZ2xlICE9PSBudWxsICYmIG1pbkFuZ2xlICE9PSB2b2lkIDAgPyBtaW5BbmdsZSA6IHRoaXMubWluQW5nbGU7XHJcbiAgICAgICAgdGhpcy5tYXhBbmdsZSA9IG1heEFuZ2xlICE9PSBudWxsICYmIG1heEFuZ2xlICE9PSB2b2lkIDAgPyBtYXhBbmdsZSA6IHRoaXMubWF4QW5nbGU7XHJcbiAgICAgICAgdGhpcy5lbWl0UmF0ZSA9IGVtaXRSYXRlICE9PSBudWxsICYmIGVtaXRSYXRlICE9PSB2b2lkIDAgPyBlbWl0UmF0ZSA6IHRoaXMuZW1pdFJhdGU7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZUxpZmUgPSBwYXJ0aWNsZUxpZmUgIT09IG51bGwgJiYgcGFydGljbGVMaWZlICE9PSB2b2lkIDAgPyBwYXJ0aWNsZUxpZmUgOiB0aGlzLnBhcnRpY2xlTGlmZTtcclxuICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5ICE9PSBudWxsICYmIG9wYWNpdHkgIT09IHZvaWQgMCA/IG9wYWNpdHkgOiB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgdGhpcy5mYWRlRmxhZyA9IGZhZGVGbGFnICE9PSBudWxsICYmIGZhZGVGbGFnICE9PSB2b2lkIDAgPyBmYWRlRmxhZyA6IHRoaXMuZmFkZUZsYWc7XHJcbiAgICAgICAgdGhpcy5mb2N1cyA9IGZvY3VzICE9PSBudWxsICYmIGZvY3VzICE9PSB2b2lkIDAgPyBmb2N1cyA6IHRoaXMuZm9jdXM7XHJcbiAgICAgICAgdGhpcy5mb2N1c0FjY2VsID0gZm9jdXNBY2NlbCAhPT0gbnVsbCAmJiBmb2N1c0FjY2VsICE9PSB2b2lkIDAgPyBmb2N1c0FjY2VsIDogdGhpcy5mb2N1c0FjY2VsO1xyXG4gICAgICAgIHRoaXMuc3RhcnRTaXplID0gc3RhcnRTaXplICE9PSBudWxsICYmIHN0YXJ0U2l6ZSAhPT0gdm9pZCAwID8gc3RhcnRTaXplIDogdGhpcy5zdGFydFNpemU7XHJcbiAgICAgICAgdGhpcy5lbmRTaXplID0gZW5kU2l6ZSAhPT0gbnVsbCAmJiBlbmRTaXplICE9PSB2b2lkIDAgPyBlbmRTaXplIDogdGhpcy5lbmRTaXplO1xyXG4gICAgICAgIHRoaXMubWluU2l6ZSA9IG1pblNpemUgIT09IG51bGwgJiYgbWluU2l6ZSAhPT0gdm9pZCAwID8gbWluU2l6ZSA6IHRoaXMubWluU2l6ZTtcclxuICAgICAgICB0aGlzLm1heFNpemUgPSBtYXhTaXplICE9PSBudWxsICYmIG1heFNpemUgIT09IHZvaWQgMCA/IG1heFNpemUgOiB0aGlzLm1heFNpemU7XHJcbiAgICAgICAgdGhpcy5iZWdpbkNvbG9yID0gYmVnaW5Db2xvciAhPT0gbnVsbCAmJiBiZWdpbkNvbG9yICE9PSB2b2lkIDAgPyBiZWdpbkNvbG9yIDogdGhpcy5iZWdpbkNvbG9yO1xyXG4gICAgICAgIHRoaXMuZW5kQ29sb3IgPSBlbmRDb2xvciAhPT0gbnVsbCAmJiBlbmRDb2xvciAhPT0gdm9pZCAwID8gZW5kQ29sb3IgOiB0aGlzLmVuZENvbG9yO1xyXG4gICAgICAgIHRoaXMucGFydGljbGVTcHJpdGUgPSBwYXJ0aWNsZVNwcml0ZSAhPT0gbnVsbCAmJiBwYXJ0aWNsZVNwcml0ZSAhPT0gdm9pZCAwID8gcGFydGljbGVTcHJpdGUgOiB0aGlzLnBhcnRpY2xlU3ByaXRlO1xyXG4gICAgICAgIHRoaXMuZW1pdHRlclR5cGUgPSBlbWl0dGVyVHlwZSAhPT0gbnVsbCAmJiBlbWl0dGVyVHlwZSAhPT0gdm9pZCAwID8gZW1pdHRlclR5cGUgOiB0aGlzLmVtaXR0ZXJUeXBlO1xyXG4gICAgICAgIHRoaXMucmFkaXVzID0gcmFkaXVzICE9PSBudWxsICYmIHJhZGl1cyAhPT0gdm9pZCAwID8gcmFkaXVzIDogdGhpcy5yYWRpdXM7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA9IHBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ICE9PSBudWxsICYmIHBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5ICE9PSB2b2lkIDAgPyBwYXJ0aWNsZVJvdGF0aW9uYWxWZWxvY2l0eSA6IHRoaXMucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHk7XHJcbiAgICAgICAgdGhpcy5yYW5kb21Sb3RhdGlvbiA9IHJhbmRvbVJvdGF0aW9uICE9PSBudWxsICYmIHJhbmRvbVJvdGF0aW9uICE9PSB2b2lkIDAgPyByYW5kb21Sb3RhdGlvbiA6IHRoaXMucmFuZG9tUm90YXRpb247XHJcbiAgICAgICAgdGhpcy5ib2R5LmNvbGxpc2lvblR5cGUgPSBDb2xsaXNpb25UeXBlLlByZXZlbnRDb2xsaXNpb247XHJcbiAgICAgICAgdGhpcy5yYW5kb20gPSByYW5kb20gIT09IG51bGwgJiYgcmFuZG9tICE9PSB2b2lkIDAgPyByYW5kb20gOiBuZXcgUmFuZG9tKCk7XHJcbiAgICAgICAgLy8gUmVtb3ZlIG9mZnNjcmVlbiBjdWxsaW5nIGZyb20gcGFydGljbGUgZW1pdHRlcnNcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudHJhaXRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWl0c1tpXSBpbnN0YW5jZW9mIE9mZnNjcmVlbkN1bGxpbmcpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudHJhaXRzLnNwbGljZShpLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgb3BhY2l0eSBvZiBlYWNoIHBhcnRpY2xlIGZyb20gMCB0byAxLjBcclxuICAgICAqL1xyXG4gICAgZ2V0IG9wYWNpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHN1cGVyLmdyYXBoaWNzLm9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIG9wYWNpdHkgb2YgZWFjaCBwYXJ0aWNsZSBmcm9tIDAgdG8gMS4wXHJcbiAgICAgKi9cclxuICAgIHNldCBvcGFjaXR5KG9wYWNpdHkpIHtcclxuICAgICAgICBzdXBlci5ncmFwaGljcy5vcGFjaXR5ID0gb3BhY2l0eTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBzcHJpdGUgdGhhdCBhIHBhcnRpY2xlIHNob3VsZCB1c2VcclxuICAgICAqL1xyXG4gICAgZ2V0IHBhcnRpY2xlU3ByaXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9vZztcclxuICAgIH1cclxuICAgIHNldCBwYXJ0aWNsZVNwcml0ZSh2YWwpIHtcclxuICAgICAgICB0aGlzLl9vZyA9IHZhbDtcclxuICAgICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Nwcml0ZSA9IFNwcml0ZS5mcm9tTGVnYWN5U3ByaXRlKHZhbCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVtb3ZlUGFydGljbGUocGFydGljbGUpIHtcclxuICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMucHVzaChwYXJ0aWNsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhdXNlcyB0aGUgZW1pdHRlciB0byBlbWl0IHBhcnRpY2xlc1xyXG4gICAgICogQHBhcmFtIHBhcnRpY2xlQ291bnQgIE51bWJlciBvZiBwYXJ0aWNsZXMgdG8gZW1pdCByaWdodCBub3dcclxuICAgICAqL1xyXG4gICAgZW1pdFBhcnRpY2xlcyhwYXJ0aWNsZUNvdW50KSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydGljbGVDb3VudDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHAgPSB0aGlzLl9jcmVhdGVQYXJ0aWNsZSgpO1xyXG4gICAgICAgICAgICB0aGlzLnBhcnRpY2xlcy5wdXNoKHApO1xyXG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcyA9PT0gbnVsbCB8fCB0aGlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGlzLnNjZW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud29ybGQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc2NlbmUud29ybGQuYWRkKHApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY2xlYXJQYXJ0aWNsZXMoKSB7XHJcbiAgICAgICAgdGhpcy5wYXJ0aWNsZXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIC8vIENyZWF0ZXMgYSBuZXcgcGFydGljbGUgZ2l2ZW4gdGhlIGNvbnN0cmFpbnRzIG9mIHRoZSBlbWl0dGVyXHJcbiAgICBfY3JlYXRlUGFydGljbGUoKSB7XHJcbiAgICAgICAgLy8gdG9kbyBpbXBsZW1lbnQgZW1pdHRlciBjb25zdHJhaW50cztcclxuICAgICAgICBsZXQgcmFuWCA9IDA7XHJcbiAgICAgICAgbGV0IHJhblkgPSAwO1xyXG4gICAgICAgIGNvbnN0IGFuZ2xlID0gcmFuZG9tSW5SYW5nZSh0aGlzLm1pbkFuZ2xlLCB0aGlzLm1heEFuZ2xlLCB0aGlzLnJhbmRvbSk7XHJcbiAgICAgICAgY29uc3QgdmVsID0gcmFuZG9tSW5SYW5nZSh0aGlzLm1pblZlbCwgdGhpcy5tYXhWZWwsIHRoaXMucmFuZG9tKTtcclxuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5zdGFydFNpemUgfHwgcmFuZG9tSW5SYW5nZSh0aGlzLm1pblNpemUsIHRoaXMubWF4U2l6ZSwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgIGNvbnN0IGR4ID0gdmVsICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgIGNvbnN0IGR5ID0gdmVsICogTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIGlmICh0aGlzLmVtaXR0ZXJUeXBlID09PSBFbWl0dGVyVHlwZS5SZWN0YW5nbGUpIHtcclxuICAgICAgICAgICAgcmFuWCA9IHJhbmRvbUluUmFuZ2UoMCwgdGhpcy53aWR0aCwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgICAgICByYW5ZID0gcmFuZG9tSW5SYW5nZSgwLCB0aGlzLmhlaWdodCwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLmVtaXR0ZXJUeXBlID09PSBFbWl0dGVyVHlwZS5DaXJjbGUpIHtcclxuICAgICAgICAgICAgY29uc3QgcmFkaXVzID0gcmFuZG9tSW5SYW5nZSgwLCB0aGlzLnJhZGl1cywgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgICAgICByYW5YID0gcmFkaXVzICogTWF0aC5jb3MoYW5nbGUpO1xyXG4gICAgICAgICAgICByYW5ZID0gcmFkaXVzICogTWF0aC5zaW4oYW5nbGUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBwID0gbmV3IFBhcnRpY2xlKHRoaXMsIHRoaXMucGFydGljbGVMaWZlLCB0aGlzLm9wYWNpdHksIHRoaXMuYmVnaW5Db2xvciwgdGhpcy5lbmRDb2xvciwgbmV3IFZlY3RvcihyYW5YLCByYW5ZKSwgbmV3IFZlY3RvcihkeCwgZHkpLCB0aGlzLmFjY2VsZXJhdGlvbiwgdGhpcy5zdGFydFNpemUsIHRoaXMuZW5kU2l6ZSk7XHJcbiAgICAgICAgcC5mYWRlRmxhZyA9IHRoaXMuZmFkZUZsYWc7XHJcbiAgICAgICAgcC5wYXJ0aWNsZVNpemUgPSBzaXplO1xyXG4gICAgICAgIGlmICh0aGlzLnBhcnRpY2xlU3ByaXRlKSB7XHJcbiAgICAgICAgICAgIHAucGFydGljbGVTcHJpdGUgPSB0aGlzLnBhcnRpY2xlU3ByaXRlO1xyXG4gICAgICAgICAgICBwLmdyYXBoaWNzLm9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgICAgIHAuZ3JhcGhpY3MudXNlKHRoaXMuX3Nwcml0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHAucGFydGljbGVSb3RhdGlvbmFsVmVsb2NpdHkgPSB0aGlzLnBhcnRpY2xlUm90YXRpb25hbFZlbG9jaXR5O1xyXG4gICAgICAgIGlmICh0aGlzLnJhbmRvbVJvdGF0aW9uKSB7XHJcbiAgICAgICAgICAgIHAuY3VycmVudFJvdGF0aW9uID0gcmFuZG9tSW5SYW5nZSgwLCBNYXRoLlBJICogMiwgdGhpcy5yYW5kb20pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5mb2N1cykge1xyXG4gICAgICAgICAgICBwLmZvY3VzID0gdGhpcy5mb2N1cy5hZGQobmV3IFZlY3Rvcih0aGlzLnBvcy54LCB0aGlzLnBvcy55KSk7XHJcbiAgICAgICAgICAgIHAuZm9jdXNBY2NlbCA9IHRoaXMuZm9jdXNBY2NlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHA7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICBzdXBlci51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNFbWl0dGluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJ0aWNsZXNUb0VtaXQgKz0gdGhpcy5lbWl0UmF0ZSAqIChkZWx0YSAvIDEwMDApO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fcGFydGljbGVzVG9FbWl0ID4gMS4wKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXRQYXJ0aWNsZXMoTWF0aC5mbG9vcih0aGlzLl9wYXJ0aWNsZXNUb0VtaXQpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRpY2xlc1RvRW1pdCA9IHRoaXMuX3BhcnRpY2xlc1RvRW1pdCAtIE1hdGguZmxvb3IodGhpcy5fcGFydGljbGVzVG9FbWl0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBkZWZlcnJlZCByZW1vdmFsXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmRlYWRQYXJ0aWNsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgcmVtb3ZlSXRlbUZyb21BcnJheSh0aGlzLmRlYWRQYXJ0aWNsZXNbaV0sIHRoaXMucGFydGljbGVzKTtcclxuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy5zY2VuZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndvcmxkKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNjZW5lLndvcmxkLnJlbW92ZSh0aGlzLmRlYWRQYXJ0aWNsZXNbaV0sIGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRlYWRQYXJ0aWNsZXMubGVuZ3RoID0gMDtcclxuICAgIH1cclxuICAgIGRyYXcoY3R4KSB7XHJcbiAgICAgICAgLy8gdG9kbyBpcyB0aGVyZSBhIG1vcmUgZWZmaWNpZW50IHRvIGRyYXdcclxuICAgICAgICAvLyBwb3NzaWJseSB1c2UgYSB3ZWJnbCBvZmZzY3JlZW4gY2FudmFzIGFuZCBzaGFkZXJzIHRvIGRvIHBhcnRpY2xlcz9cclxuICAgICAgICB0aGlzLnBhcnRpY2xlcy5mb3JFYWNoKChwKSA9PiBwLmRyYXcoY3R4KSk7XHJcbiAgICB9XHJcbiAgICBkZWJ1Z0RyYXcoY3R4KSB7XHJcbiAgICAgICAgc3VwZXIuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IENvbG9yLkJsYWNrLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgY3R4LmZpbGxUZXh0KCdQYXJ0aWNsZXM6ICcgKyB0aGlzLnBhcnRpY2xlcy5sZW5ndGgsIHRoaXMucG9zLngsIHRoaXMucG9zLnkgKyAyMCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZm9jdXMpIHtcclxuICAgICAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMuZm9jdXMueCArIHRoaXMucG9zLngsIHRoaXMuZm9jdXMueSArIHRoaXMucG9zLnksIDMsIDMpO1xyXG4gICAgICAgICAgICBsaW5lKGN0eCwgQ29sb3IuWWVsbG93LCB0aGlzLmZvY3VzLnggKyB0aGlzLnBvcy54LCB0aGlzLmZvY3VzLnkgKyB0aGlzLnBvcy55LCB0aGlzLmNlbnRlci54LCB0aGlzLmNlbnRlci55KTtcclxuICAgICAgICAgICAgY3R4LmZpbGxUZXh0KCdGb2N1cycsIHRoaXMuZm9jdXMueCArIHRoaXMucG9zLngsIHRoaXMuZm9jdXMueSArIHRoaXMucG9zLnkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0dyYXBoaWNzU3lzdGVtLnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbmNsYXNzIEdyYXBoaWNzU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlcyA9IFsnZXgudHJhbnNmb3JtJywgJ2V4LmdyYXBoaWNzJ107XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1UeXBlID0gU3lzdGVtVHlwZS5EcmF3O1xyXG4gICAgICAgIHRoaXMucHJpb3JpdHkgPSAwO1xyXG4gICAgICAgIHRoaXMuX3Rva2VuID0gMDtcclxuICAgIH1cclxuICAgIGluaXRpYWxpemUoc2NlbmUpIHtcclxuICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQgPSBzY2VuZS5lbmdpbmUuZ3JhcGhpY3NDb250ZXh0O1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYSA9IHNjZW5lLmNhbWVyYTtcclxuICAgICAgICB0aGlzLl9lbmdpbmUgPSBzY2VuZS5lbmdpbmU7XHJcbiAgICB9XHJcbiAgICBzb3J0KGEsIGIpIHtcclxuICAgICAgICByZXR1cm4gYS5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS56IC0gYi5nZXQoVHJhbnNmb3JtQ29tcG9uZW50KS56O1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKGVudGl0aWVzLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuX2NsZWFyU2NyZWVuKCk7XHJcbiAgICAgICAgdGhpcy5fdG9rZW4rKztcclxuICAgICAgICBsZXQgdHJhbnNmb3JtO1xyXG4gICAgICAgIGxldCBncmFwaGljcztcclxuICAgICAgICBmb3IgKGNvbnN0IGVudGl0eSBvZiBlbnRpdGllcykge1xyXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBlbnRpdHkuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGdyYXBoaWNzID0gZW50aXR5LmdldChHcmFwaGljc0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgaWYgZW50aXRpZXMgYXJlIG9mZnNjcmVlblxyXG4gICAgICAgICAgICBjb25zdCBlbnRpdHlPZmZzY3JlZW4gPSB0aGlzLl9pc09mZnNjcmVlbih0cmFuc2Zvcm0sIGdyYXBoaWNzKTtcclxuICAgICAgICAgICAgaWYgKGVudGl0eU9mZnNjcmVlbiAmJiAhZW50aXR5Lmhhc1RhZygnb2Zmc2NyZWVuJykpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5ldmVudERpc3BhdGNoZXIuZW1pdCgnZXhpdHZpZXdwb3J0JywgbmV3IEV4aXRWaWV3UG9ydEV2ZW50KGVudGl0eSkpO1xyXG4gICAgICAgICAgICAgICAgZW50aXR5LmFkZENvbXBvbmVudChuZXcgVGFnQ29tcG9uZW50KCdvZmZzY3JlZW4nKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFlbnRpdHlPZmZzY3JlZW4gJiYgZW50aXR5Lmhhc1RhZygnb2Zmc2NyZWVuJykpIHtcclxuICAgICAgICAgICAgICAgIGVudGl0eS5ldmVudERpc3BhdGNoZXIuZW1pdCgnZW50ZXJ2aWV3cG9ydCcsIG5ldyBFbnRlclZpZXdQb3J0RXZlbnQoZW50aXR5KSk7XHJcbiAgICAgICAgICAgICAgICBlbnRpdHkucmVtb3ZlQ29tcG9uZW50KCdvZmZzY3JlZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBTa2lwIGVudGl0aWVzIHRoYXQgaGF2ZSBncmFwaGljcyBvZmZzY3JlZW5cclxuICAgICAgICAgICAgaWYgKGVudGl0eU9mZnNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVGhpcyBvcHRpb25hbGx5IHNldHMgb3VyIGNhbWVyYSBiYXNlZCBvbiB0aGUgZW50aXR5IGNvb3JkIHBsYW4gKHdvcmxkIHZzLiBzY3JlZW4pXHJcbiAgICAgICAgICAgIHRoaXMuX3B1c2hDYW1lcmFUcmFuc2Zvcm0odHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnNhdmUoKTtcclxuICAgICAgICAgICAgLy8gVGljayBhbnkgZ3JhcGhpY3Mgc3RhdGUgKGJ1dCBvbmx5IG9uY2UpIGZvciBhbmltYXRpb25zIGFuZCBncmFwaGljcyBncm91cHNcclxuICAgICAgICAgICAgZ3JhcGhpY3MudXBkYXRlKGRlbHRhLCB0aGlzLl90b2tlbik7XHJcbiAgICAgICAgICAgIC8vIFBvc2l0aW9uIHRoZSBlbnRpdHlcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlUcmFuc2Zvcm0oZW50aXR5KTtcclxuICAgICAgICAgICAgLy8gT3B0aW9uYWxseSBydW4gdGhlIG9uUHJlRHJhdyBncmFwaGljcyBsaWZlY3ljbGUgZHJhd1xyXG4gICAgICAgICAgICBpZiAoZ3JhcGhpY3Mub25QcmVEcmF3KSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5vblByZURyYXcodGhpcy5fZ3JhcGhpY3NDb250ZXh0LCBkZWx0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhpcyBoYWNrIG9uIHRoZSBwYXJ0aWNsZSByZWRvXHJcbiAgICAgICAgICAgIGNvbnN0IHBhcnRpY2xlT3BhY2l0eSA9IChlbnRpdHkgaW5zdGFuY2VvZiBQYXJ0aWNsZSkgPyBlbnRpdHkub3BhY2l0eSA6IDE7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5vcGFjaXR5ID0gZ3JhcGhpY3Mub3BhY2l0eSAqIHBhcnRpY2xlT3BhY2l0eTtcclxuICAgICAgICAgICAgLy8gRHJhdyB0aGUgZ3JhcGhpY3MgY29tcG9uZW50XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYXdHcmFwaGljc0NvbXBvbmVudChncmFwaGljcyk7XHJcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsbHkgcnVuIHRoZSBvblBvc3REcmF3IGdyYXBoaWNzIGxpZmVjeWNsZSBkcmF3XHJcbiAgICAgICAgICAgIGlmIChncmFwaGljcy5vblBvc3REcmF3KSB7XHJcbiAgICAgICAgICAgICAgICBncmFwaGljcy5vblBvc3REcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCwgZGVsdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIC8vIFJlc2V0IHRoZSB0cmFuc2Zvcm0gYmFjayB0byB0aGUgb3JpZ2luYWxcclxuICAgICAgICAgICAgdGhpcy5fcG9wQ2FtZXJhVHJhbnNmb3JtKHRyYW5zZm9ybSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5mbHVzaCgpO1xyXG4gICAgICAgIHRoaXMuX2VuZ2luZS5zdGF0cy5jdXJyRnJhbWUuZ3JhcGhpY3MuZHJhd25JbWFnZXMgPSBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXduSW1hZ2VzQ291bnQ7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5ncmFwaGljcy5kcmF3Q2FsbHMgPSBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXdDYWxsQ291bnQ7XHJcbiAgICB9XHJcbiAgICBfY2xlYXJTY3JlZW4oKSB7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBfaXNPZmZzY3JlZW4odHJhbnNmb3JtLCBncmFwaGljcykge1xyXG4gICAgICAgIGlmICh0cmFuc2Zvcm0uY29vcmRQbGFuZSA9PT0gQ29vcmRQbGFuZS5Xb3JsZCkge1xyXG4gICAgICAgICAgICBjb25zdCBncmFwaGljc09mZnNjcmVlbiA9ICF0aGlzLl9jYW1lcmEudmlld3BvcnQuaW50ZXJzZWN0KGdyYXBoaWNzLmxvY2FsQm91bmRzLnRyYW5zZm9ybSh0cmFuc2Zvcm0uZ2V0R2xvYmFsTWF0cml4KCkpKTtcclxuICAgICAgICAgICAgcmV0dXJuIGdyYXBoaWNzT2Zmc2NyZWVuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gVE9ETyBzY2VlbiBjb29yZGluYXRlc1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RyYXdHcmFwaGljc0NvbXBvbmVudChncmFwaGljc0NvbXBvbmVudCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKGdyYXBoaWNzQ29tcG9uZW50LnZpc2libGUpIHtcclxuICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgYmUgbW92ZWQgdG8gdGhlIGdyYXBoaWNzIHN5c3RlbVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIGdyYXBoaWNzQ29tcG9uZW50LmxheWVycy5nZXQoKSkge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB7IGdyYXBoaWMsIG9wdGlvbnMgfSBvZiBsYXllci5ncmFwaGljcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBhbmNob3IgPSBncmFwaGljc0NvbXBvbmVudC5hbmNob3I7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IG9mZnNldCA9IGdyYXBoaWNzQ29tcG9uZW50Lm9mZnNldDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFuY2hvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmNob3IgPSBvcHRpb25zLmFuY2hvcjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5vZmZzZXQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXhjYWxpYnVyanMvRXhjYWxpYnVyL3B1bGwvNjE5IGZvciBkaXNjdXNzaW9uIG9uIHRoaXMgZm9ybXVsYVxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldFggPSAtZ3JhcGhpYy53aWR0aCAqIGFuY2hvci54ICsgb2Zmc2V0Lng7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IC1ncmFwaGljLmhlaWdodCAqIGFuY2hvci55ICsgb2Zmc2V0Lnk7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGhpYyA9PT0gbnVsbCB8fCBncmFwaGljID09PSB2b2lkIDAgPyB2b2lkIDAgOiBncmFwaGljLmRyYXcodGhpcy5fZ3JhcGhpY3NDb250ZXh0LCBvZmZzZXRYICsgbGF5ZXIub2Zmc2V0LngsIG9mZnNldFkgKyBsYXllci5vZmZzZXQueSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLl9lbmdpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0RlYnVnKSAmJiB0aGlzLl9lbmdpbmUuZGVidWcuZ3JhcGhpY3Muc2hvd0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB2ZWMob2Zmc2V0WCArIGxheWVyLm9mZnNldC54LCBvZmZzZXRZICsgbGF5ZXIub2Zmc2V0LnkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ3JhcGhpYyBpbnN0YW5jZW9mIEdyYXBoaWNzR3JvdXApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZyBvZiBncmFwaGljLm1lbWJlcnMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSBnLmdyYXBoaWMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sb2NhbEJvdW5kcy50cmFuc2xhdGUob2Zmc2V0LmFkZChnLnBvcykpLmRyYXcodGhpcy5fZ3JhcGhpY3NDb250ZXh0LCB0aGlzLl9lbmdpbmUuZGVidWcuZ3JhcGhpY3MuYm91bmRzQ29sb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyYXBoaWMgPT09IG51bGwgfHwgZ3JhcGhpYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JhcGhpYy5sb2NhbEJvdW5kcy50cmFuc2xhdGUob2Zmc2V0KS5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCwgdGhpcy5fZW5naW5lLmRlYnVnLmdyYXBoaWNzLmJvdW5kc0NvbG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBhcHBsaWVzIHRoZSBjdXJyZW50IGVudGl0eSB0cmFuc2Zvcm0gdG8gdGhlIGdyYXBoaWNzIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgX2FwcGx5VHJhbnNmb3JtKGVudGl0eSkge1xyXG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IGVudGl0eS5nZXRBbmNlc3RvcnMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGFuY2VzdG9yIG9mIGFuY2VzdG9ycykge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBhbmNlc3RvciA9PT0gbnVsbCB8fCBhbmNlc3RvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5jZXN0b3IuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC50cmFuc2xhdGUodHJhbnNmb3JtLnBvcy54LCB0cmFuc2Zvcm0ucG9zLnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnNjYWxlKHRyYW5zZm9ybS5zY2FsZS54LCB0cmFuc2Zvcm0uc2NhbGUueSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQucm90YXRlKHRyYW5zZm9ybS5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGN1cnJlbnQgY2FtZXJhIHRyYW5zZm9ybSBpZiBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybVxyXG4gICAgICovXHJcbiAgICBfcHVzaENhbWVyYVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcclxuICAgICAgICAvLyBFc3RhYmxpc2ggY2FtZXJhIG9mZnNldCBwZXIgZW50aXR5XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5jb29yZFBsYW5lID09PSBDb29yZFBsYW5lLldvcmxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbWVyYS5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgY3VycmVudCBjYW1lcmEgdHJhbnNmb3JtIGlmIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtXHJcbiAgICAgKi9cclxuICAgIF9wb3BDYW1lcmFUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5jb29yZFBsYW5lID09PSBDb29yZFBsYW5lLldvcmxkKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGNhbWVyYSB3b3JsZCBvZmZzZXRcclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9EcmF3aW5nL0NhbnZhc0RyYXdpbmdTeXN0ZW0udHNcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogRHJhd3MgYW55dGhpbmcgd2l0aCBhIHRyYW5zZm9ybSBhbmQgYSBcImRyYXdcIiBtZXRob2RcclxuICogQGRlcHJlY2F0ZWQgU2hpbSBmb3IgY2FudmFzIGRyYXdpbmcsIHdpbGwgYmUgcmVtb3ZlZCB2MC4yNi4wXHJcbiAqL1xyXG5jbGFzcyBDYW52YXNEcmF3aW5nU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy50eXBlcyA9IFsnZXgudHJhbnNmb3JtJywgJ2V4LmNhbnZhcyddO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtVHlwZSA9IFN5c3RlbVR5cGUuRHJhdztcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gLTE7XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKHNjZW5lKSB7XHJcbiAgICAgICAgdGhpcy5fY3R4ID0gc2NlbmUuZW5naW5lLmN0eDtcclxuICAgICAgICB0aGlzLl9lbmdpbmUgPSBzY2VuZS5lbmdpbmU7XHJcbiAgICAgICAgdGhpcy5fY2FtZXJhID0gc2NlbmUuY2FtZXJhO1xyXG4gICAgfVxyXG4gICAgc29ydChhLCBiKSB7XHJcbiAgICAgICAgcmV0dXJuIGEuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkueiAtIGIuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCkuejtcclxuICAgIH1cclxuICAgIHVwZGF0ZShlbnRpdGllcywgZGVsdGEpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICB0aGlzLl9jbGVhclNjcmVlbigpO1xyXG4gICAgICAgIGxldCB0cmFuc2Zvcm07XHJcbiAgICAgICAgbGV0IGNhbnZhc2RyYXc7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZW50aXRpZXMubGVuZ3RoO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdmlzaWJsZSA9IChfYyA9IChfYiA9IChfYSA9IGVudGl0aWVzW2ldKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ3JhcGhpY3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52aXNpYmxlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0cnVlO1xyXG4gICAgICAgICAgICBjb25zdCBvZmZzY3JlZW4gPSBlbnRpdGllc1tpXS5pc09mZlNjcmVlbjtcclxuICAgICAgICAgICAgaWYgKHZpc2libGUgJiYgIW9mZnNjcmVlbikge1xyXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtID0gZW50aXRpZXNbaV0uZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNkcmF3ID0gZW50aXRpZXNbaV0uZ2V0KENhbnZhc0RyYXdDb21wb25lbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hDYW1lcmFUcmFuc2Zvcm0odHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVRyYW5zZm9ybShlbnRpdGllc1tpXSk7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNkcmF3LmRyYXcodGhpcy5fY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fcG9wQ2FtZXJhVHJhbnNmb3JtKHRyYW5zZm9ybSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHgucmVzdG9yZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbmdpbmUuaXNEZWJ1Zykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4LnNhdmUoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3B1c2hDYW1lcmFUcmFuc2Zvcm0odHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9ICd5ZWxsb3cnO1xyXG4gICAgICAgICAgICAgICAgZW50aXRpZXNbaV0uZGVidWdEcmF3KHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3BDYW1lcmFUcmFuc2Zvcm0odHJhbnNmb3JtKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5yZXN0b3JlKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2VuZ2luZS5pc0RlYnVnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYS5kcmF3KHRoaXMuX2N0eCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYS5kZWJ1Z0RyYXcodGhpcy5fY3R4KTtcclxuICAgICAgICAgICAgdGhpcy5fY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnN0YXRzLmN1cnJGcmFtZS5ncmFwaGljcy5kcmF3bkltYWdlcyA9IEdyYXBoaWNzRGlhZ25vc3RpY3MuRHJhd25JbWFnZXNDb3VudDtcclxuICAgICAgICB0aGlzLl9lbmdpbmUuc3RhdHMuY3VyckZyYW1lLmdyYXBoaWNzLmRyYXdDYWxscyA9IEdyYXBoaWNzRGlhZ25vc3RpY3MuRHJhd0NhbGxDb3VudDtcclxuICAgIH1cclxuICAgIF9hcHBseVRyYW5zZm9ybShlbnRpdHkpIHtcclxuICAgICAgICBjb25zdCBhbmNlc3RvcnMgPSBlbnRpdHkuZ2V0QW5jZXN0b3JzKCk7XHJcbiAgICAgICAgZm9yIChjb25zdCBhbmNlc3RvciBvZiBhbmNlc3RvcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gYW5jZXN0b3IgPT09IG51bGwgfHwgYW5jZXN0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFuY2VzdG9yLmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jdHgudHJhbnNsYXRlKHRyYW5zZm9ybS5wb3MueCwgdHJhbnNmb3JtLnBvcy55KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5yb3RhdGUodHJhbnNmb3JtLnJvdGF0aW9uKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N0eC5zY2FsZSh0cmFuc2Zvcm0uc2NhbGUueCwgdHJhbnNmb3JtLnNjYWxlLnkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2NsZWFyU2NyZWVuKCkge1xyXG4gICAgICAgIHRoaXMuX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy5fY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5fY3R4LmNhbnZhcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX2N0eC5maWxsU3R5bGUgPSB0aGlzLl9lbmdpbmUuYmFja2dyb3VuZENvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5fY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMuX2N0eC5jYW52YXMud2lkdGgsIHRoaXMuX2N0eC5jYW52YXMuaGVpZ2h0KTtcclxuICAgIH1cclxuICAgIF9wdXNoQ2FtZXJhVHJhbnNmb3JtKHRyYW5zZm9ybSkge1xyXG4gICAgICAgIGlmICh0cmFuc2Zvcm0uY29vcmRQbGFuZSA9PT0gQ29vcmRQbGFuZS5Xb3JsZCkge1xyXG4gICAgICAgICAgICAvLyBBcHBseSBjYW1lcmEgdHJhbnNmb3JtIHRvIHBsYWNlIGVudGl0eSBpbiB3b3JsZCBzcGFjZVxyXG4gICAgICAgICAgICB0aGlzLl9jdHguc2F2ZSgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fY2FtZXJhKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jYW1lcmEuZHJhdyh0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3BvcENhbWVyYVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcclxuICAgICAgICBpZiAodHJhbnNmb3JtLmNvb3JkUGxhbmUgPT09IENvb3JkUGxhbmUuV29ybGQpIHtcclxuICAgICAgICAgICAgLy8gUmVzdG9yZSBiYWNrIHRvIHNjcmVlbiBzcGFjZSBmcm9tIHdvcmxkIHNwYWNlIGlmIHdlIHdlcmUgZHJhd2luZyBhbiBlbnRpdHkgdGhlcmVcclxuICAgICAgICAgICAgdGhpcy5fY3R4LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9EZWJ1Zy9EZWJ1Z1N5c3RlbS50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgRGVidWdTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLnR5cGVzID0gWydleC50cmFuc2Zvcm0nXTtcclxuICAgICAgICB0aGlzLnN5c3RlbVR5cGUgPSBTeXN0ZW1UeXBlLkRyYXc7XHJcbiAgICAgICAgdGhpcy5wcmlvcml0eSA9IDk5OTsgLy8gbG93ZXN0IHByaW9yaXR5XHJcbiAgICB9XHJcbiAgICBpbml0aWFsaXplKHNjZW5lKSB7XHJcbiAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0ID0gc2NlbmUuZW5naW5lLmdyYXBoaWNzQ29udGV4dDtcclxuICAgICAgICB0aGlzLl9jYW1lcmEgPSBzY2VuZS5jYW1lcmE7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lID0gc2NlbmUuZW5naW5lO1xyXG4gICAgICAgIHRoaXMuX2NvbGxpc2lvblN5c3RlbSA9IHNjZW5lLndvcmxkLnN5c3RlbU1hbmFnZXIuZ2V0KENvbGxpc2lvblN5c3RlbSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZW50aXRpZXMsIF9kZWx0YSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9lbmdpbmUuaXNEZWJ1Zykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGZpbHRlclNldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLmZpbHRlcjtcclxuICAgICAgICBsZXQgaWQ7XHJcbiAgICAgICAgbGV0IG5hbWU7XHJcbiAgICAgICAgY29uc3QgZW50aXR5U2V0dGluZ3MgPSB0aGlzLl9lbmdpbmUuZGVidWcuZW50aXR5O1xyXG4gICAgICAgIGxldCB0eDtcclxuICAgICAgICBjb25zdCB0eFNldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLnRyYW5zZm9ybTtcclxuICAgICAgICBsZXQgbW90aW9uO1xyXG4gICAgICAgIGNvbnN0IG1vdGlvblNldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLm1vdGlvbjtcclxuICAgICAgICBsZXQgY29sbGlkZXJDb21wO1xyXG4gICAgICAgIGNvbnN0IGNvbGxpZGVyU2V0dGluZ3MgPSB0aGlzLl9lbmdpbmUuZGVidWcuY29sbGlkZXI7XHJcbiAgICAgICAgY29uc3QgcGh5c2ljc1NldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLnBoeXNpY3M7XHJcbiAgICAgICAgbGV0IGdyYXBoaWNzO1xyXG4gICAgICAgIGNvbnN0IGdyYXBoaWNzU2V0dGluZ3MgPSB0aGlzLl9lbmdpbmUuZGVidWcuZ3JhcGhpY3M7XHJcbiAgICAgICAgbGV0IGJvZHk7XHJcbiAgICAgICAgY29uc3QgYm9keVNldHRpbmdzID0gdGhpcy5fZW5naW5lLmRlYnVnLmJvZHk7XHJcbiAgICAgICAgY29uc3QgY2FtZXJhU2V0dGluZ3MgPSB0aGlzLl9lbmdpbmUuZGVidWcuY2FtZXJhO1xyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIGVudGl0aWVzKSB7XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkuaGFzVGFnKCdvZmZzY3JlZW4nKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gc2tpcCBvZmZzY3JlZW4gZW50aXRpZXNcclxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBQYXJ0aWNsZSkge1xyXG4gICAgICAgICAgICAgICAgLy8gUGFydGljbGVzIGNydXNoIHRoZSByZW5kZXJlciA6KFxyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGZpbHRlclNldHRpbmdzLnVzZUZpbHRlcikge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYWxsSWRzID0gZmlsdGVyU2V0dGluZ3MuaWRzLmxlbmd0aCA9PT0gMDtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlkTWF0Y2ggPSBhbGxJZHMgfHwgZmlsdGVyU2V0dGluZ3MuaWRzLmluY2x1ZGVzKGVudGl0eS5pZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlkTWF0Y2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGFsbE5hbWVzID0gZmlsdGVyU2V0dGluZ3MubmFtZVF1ZXJ5ID09PSAnJztcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5hbWVNYXRjaCA9IGFsbE5hbWVzIHx8IGVudGl0eS5uYW1lLmluY2x1ZGVzKGZpbHRlclNldHRpbmdzLm5hbWVRdWVyeSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIW5hbWVNYXRjaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCBjdXJzb3IgPSBWZWN0b3IuWmVybztcclxuICAgICAgICAgICAgY29uc3QgbGluZUhlaWdodCA9IHZlYygwLCAxNik7XHJcbiAgICAgICAgICAgIGlkID0gZW50aXR5LmlkO1xyXG4gICAgICAgICAgICBuYW1lID0gZW50aXR5Lm5hbWU7XHJcbiAgICAgICAgICAgIHR4ID0gZW50aXR5LmdldChUcmFuc2Zvcm1Db21wb25lbnQpO1xyXG4gICAgICAgICAgICAvLyBUaGlzIG9wdGlvbmFsbHkgc2V0cyBvdXIgY2FtZXJhIGJhc2VkIG9uIHRoZSBlbnRpdHkgY29vcmQgcGxhbiAod29ybGQgdnMuIHNjcmVlbilcclxuICAgICAgICAgICAgdGhpcy5fcHVzaENhbWVyYVRyYW5zZm9ybSh0eCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5VHJhbnNmb3JtKGVudGl0eSk7XHJcbiAgICAgICAgICAgIGlmICh0eCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR4U2V0dGluZ3Muc2hvd0FsbCB8fCB0eFNldHRpbmdzLnNob3dQb3NpdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3UG9pbnQoVmVjdG9yLlplcm8sIHsgc2l6ZTogMiwgY29sb3I6IHR4U2V0dGluZ3MucG9zaXRpb25Db2xvciB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYHBvcyR7dHgucG9zLnRvU3RyaW5nKDIpfWAsIGN1cnNvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLmFkZChsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChlbnRpdHlTZXR0aW5ncy5zaG93QWxsIHx8IGVudGl0eVNldHRpbmdzLnNob3dJZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgaWQoJHtpZH0pICR7dHgucGFyZW50ID8gJ2NoaWxkIG9mIGlkKCcgKyAoKF9iID0gKF9hID0gdHgucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub3duZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZCkgKyAnKScgOiAnJ31gLCBjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5hZGQobGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50aXR5U2V0dGluZ3Muc2hvd0FsbCB8fCBlbnRpdHlTZXR0aW5ncy5zaG93TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgbmFtZSgke25hbWV9KWAsIGN1cnNvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLmFkZChsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0eFNldHRpbmdzLnNob3dBbGwgfHwgdHhTZXR0aW5ncy5zaG93Um90YXRpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZHJhd0xpbmUoVmVjdG9yLlplcm8sIFZlY3Rvci5mcm9tQW5nbGUodHgucm90YXRpb24pLnNjYWxlKDUwKS5hZGQoVmVjdG9yLlplcm8pLCB0eFNldHRpbmdzLnJvdGF0aW9uQ29sb3IsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgcm90IGRlZygke3RvRGVncmVlcyh0eC5yb3RhdGlvbikudG9GaXhlZCgyKX0pYCwgY3Vyc29yKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IuYWRkKGxpbmVIZWlnaHQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHR4U2V0dGluZ3Muc2hvd0FsbCB8fCB0eFNldHRpbmdzLnNob3dTY2FsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kcmF3TGluZShWZWN0b3IuWmVybywgdHguc2NhbGUuYWRkKFZlY3Rvci5aZXJvKSwgdHhTZXR0aW5ncy5zY2FsZUNvbG9yLCAyKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBncmFwaGljcyA9IGVudGl0eS5nZXQoR3JhcGhpY3NDb21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAoZ3JhcGhpY3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChncmFwaGljc1NldHRpbmdzLnNob3dBbGwgfHwgZ3JhcGhpY3NTZXR0aW5ncy5zaG93Qm91bmRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRzID0gZ3JhcGhpY3MubG9jYWxCb3VuZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgYm91bmRzLmRyYXcodGhpcy5fZ3JhcGhpY3NDb250ZXh0LCBncmFwaGljc1NldHRpbmdzLmJvdW5kc0NvbG9yKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBib2R5ID0gZW50aXR5LmdldChCb2R5Q29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKGJvZHkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChib2R5U2V0dGluZ3Muc2hvd0FsbCB8fCBib2R5U2V0dGluZ3Muc2hvd0NvbGxpc2lvbkdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGBjb2xsaXNpb24gZ3JvdXAoJHtib2R5Lmdyb3VwLm5hbWV9KWAsIGN1cnNvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLmFkZChsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChib2R5U2V0dGluZ3Muc2hvd0FsbCB8fCBib2R5U2V0dGluZ3Muc2hvd0NvbGxpc2lvblR5cGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYGNvbGxpc2lvbiB0eXBlKCR7Ym9keS5jb2xsaXNpb25UeXBlfSlgLCBjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5hZGQobGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keVNldHRpbmdzLnNob3dBbGwgfHwgYm9keVNldHRpbmdzLnNob3dNYXNzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGBtYXNzKCR7Ym9keS5tYXNzfSlgLCBjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5hZGQobGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoYm9keVNldHRpbmdzLnNob3dBbGwgfHwgYm9keVNldHRpbmdzLnNob3dNb3Rpb24pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYG1vdGlvbigke2JvZHkuc2xlZXBNb3Rpb259KWAsIGN1cnNvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gY3Vyc29yLmFkZChsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChib2R5U2V0dGluZ3Muc2hvd0FsbCB8fCBib2R5U2V0dGluZ3Muc2hvd1NsZWVwaW5nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGBzbGVlcGluZygke2JvZHkuY2FuU2xlZXAgPyBib2R5LnNsZWVwaW5nIDogJ2NhbnQgc2xlZXAnfSlgLCBjdXJzb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5hZGQobGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICAgICAgbW90aW9uID0gZW50aXR5LmdldChNb3Rpb25Db21wb25lbnQpO1xyXG4gICAgICAgICAgICBpZiAobW90aW9uKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uU2V0dGluZ3Muc2hvd0FsbCB8fCBtb3Rpb25TZXR0aW5ncy5zaG93VmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYHZlbCR7bW90aW9uLnZlbC50b1N0cmluZygyKX1gLCBjdXJzb3IuYWRkKHR4Lmdsb2JhbFBvcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kcmF3TGluZSh0eC5nbG9iYWxQb3MsIHR4Lmdsb2JhbFBvcy5hZGQobW90aW9uLnZlbCksIG1vdGlvblNldHRpbmdzLnZlbG9jaXR5Q29sb3IsIDIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IGN1cnNvci5hZGQobGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uU2V0dGluZ3Muc2hvd0FsbCB8fCBtb3Rpb25TZXR0aW5ncy5zaG93QWNjZWxlcmF0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRyYXdMaW5lKHR4Lmdsb2JhbFBvcywgdHguZ2xvYmFsUG9zLmFkZChtb3Rpb24uYWNjKSwgbW90aW9uU2V0dGluZ3MuYWNjZWxlcmF0aW9uQ29sb3IsIDIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIENvbGxpZGVycyBsaXZlIGluIHdvcmxkIHNwYWNlIGFscmVhZHkgc28gYWZ0ZXIgdGhlIHJlc3RvcmUoKVxyXG4gICAgICAgICAgICBjb2xsaWRlckNvbXAgPSBlbnRpdHkuZ2V0KENvbGxpZGVyQ29tcG9uZW50KTtcclxuICAgICAgICAgICAgaWYgKGNvbGxpZGVyQ29tcCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29sbGlkZXIgPSBjb2xsaWRlckNvbXAuZ2V0KCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoKGNvbGxpZGVyU2V0dGluZ3Muc2hvd0FsbCB8fCBjb2xsaWRlclNldHRpbmdzLnNob3dHZW9tZXRyeSkgJiYgY29sbGlkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xsaWRlci5kZWJ1Zyh0aGlzLl9ncmFwaGljc0NvbnRleHQsIGNvbGxpZGVyU2V0dGluZ3MuZ2VvbWV0cnlDb2xvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoY29sbGlkZXJTZXR0aW5ncy5zaG93QWxsIHx8IGNvbGxpZGVyU2V0dGluZ3Muc2hvd0JvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaWRlciBpbnN0YW5jZW9mIENvbXBvc2l0ZUNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbGxpZGVycyA9IGNvbGxpZGVyLmdldENvbGxpZGVycygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNvbGxpZGVyIG9mIGNvbGxpZGVycykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYm91bmRzID0gY29sbGlkZXIuYm91bmRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zID0gdmVjKGJvdW5kcy5sZWZ0LCBib3VuZHMudG9wKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3UmVjdChwb3MueCwgcG9zLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCwgeyBjb2xvcjogY29sbGlkZXJTZXR0aW5ncy5ib3VuZHNDb2xvciB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2xsaWRlclNldHRpbmdzLnNob3dBbGwgfHwgY29sbGlkZXJTZXR0aW5ncy5zaG93T3duZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1RleHQoYG93bmVyIGlkKCR7Y29sbGlkZXIub3duZXIuaWR9KWAsIHBvcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGlkZXJDb21wLmJvdW5kcy5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCwgY29sbGlkZXJTZXR0aW5ncy5ib3VuZHNDb2xvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbGxpZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kcyA9IGNvbGxpZGVyQ29tcC5ib3VuZHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvcyA9IHZlYyhib3VuZHMubGVmdCwgYm91bmRzLnRvcCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3UmVjdChwb3MueCwgcG9zLnksIGJvdW5kcy53aWR0aCwgYm91bmRzLmhlaWdodCwgeyBjb2xvcjogY29sbGlkZXJTZXR0aW5ncy5ib3VuZHNDb2xvciB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbGxpZGVyU2V0dGluZ3Muc2hvd0FsbCB8fCBjb2xsaWRlclNldHRpbmdzLnNob3dPd25lcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRlYnVnLmRyYXdUZXh0KGBvd25lciBpZCgke2NvbGxpZGVyQ29tcC5vd25lci5pZH0pYCwgcG9zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9wb3BDYW1lcmFUcmFuc2Zvcm0odHgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuc2F2ZSgpO1xyXG4gICAgICAgIHRoaXMuX2NhbWVyYS5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCk7XHJcbiAgICAgICAgaWYgKHBoeXNpY3NTZXR0aW5ncy5zaG93QWxsIHx8IHBoeXNpY3NTZXR0aW5ncy5zaG93QnJvYWRwaGFzZVNwYWNlUGFydGl0aW9uRGVidWcpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29sbGlzaW9uU3lzdGVtLmRlYnVnKHRoaXMuX2dyYXBoaWNzQ29udGV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChwaHlzaWNzU2V0dGluZ3Muc2hvd0FsbCB8fCBwaHlzaWNzU2V0dGluZ3Muc2hvd0NvbGxpc2lvbkNvbnRhY3RzIHx8IHBoeXNpY3NTZXR0aW5ncy5zaG93Q29sbGlzaW9uTm9ybWFscykge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtfLCBjb250YWN0XSBvZiB0aGlzLl9lbmdpbmUuZGVidWcuc3RhdHMuY3VyckZyYW1lLnBoeXNpY3MuY29udGFjdHMpIHtcclxuICAgICAgICAgICAgICAgIGlmIChwaHlzaWNzU2V0dGluZ3Muc2hvd0FsbCB8fCBwaHlzaWNzU2V0dGluZ3Muc2hvd0NvbGxpc2lvbkNvbnRhY3RzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBwb2ludCBvZiBjb250YWN0LnBvaW50cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZGVidWcuZHJhd1BvaW50KHBvaW50LCB7IHNpemU6IDUsIGNvbG9yOiBwaHlzaWNzU2V0dGluZ3MuY29sbGlzaW9uQ29udGFjdENvbG9yIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChwaHlzaWNzU2V0dGluZ3Muc2hvd0FsbCB8fCBwaHlzaWNzU2V0dGluZ3Muc2hvd0NvbGxpc2lvbk5vcm1hbHMpIHtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBvaW50IG9mIGNvbnRhY3QucG9pbnRzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3TGluZShwb2ludCwgY29udGFjdC5ub3JtYWwuc2NhbGUoMzApLmFkZChwb2ludCksIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBwaHlzaWNzU2V0dGluZ3MuY29sbGlzaW9uTm9ybWFsQ29sb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgICAgaWYgKGNhbWVyYVNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2NhbWVyYS5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCk7XHJcbiAgICAgICAgICAgIGlmIChjYW1lcmFTZXR0aW5ncy5zaG93QWxsIHx8IGNhbWVyYVNldHRpbmdzLnNob3dGb2N1cykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LmRyYXdDaXJjbGUodGhpcy5fY2FtZXJhLnBvcywgNCwgY2FtZXJhU2V0dGluZ3MuZm9jdXNDb2xvcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGNhbWVyYVNldHRpbmdzLnNob3dBbGwgfHwgY2FtZXJhU2V0dGluZ3Muc2hvd1pvb20pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5kZWJ1Zy5kcmF3VGV4dChgem9vbSgke3RoaXMuX2NhbWVyYS56b29tfSlgLCB0aGlzLl9jYW1lcmEucG9zKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQucmVzdG9yZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQuZmx1c2goKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBhcHBsaWVzIHRoZSBjdXJyZW50IGVudGl0eSB0cmFuc2Zvcm0gdG8gdGhlIGdyYXBoaWNzIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBlbnRpdHlcclxuICAgICAqL1xyXG4gICAgX2FwcGx5VHJhbnNmb3JtKGVudGl0eSkge1xyXG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IGVudGl0eS5nZXRBbmNlc3RvcnMoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGFuY2VzdG9yIG9mIGFuY2VzdG9ycykge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBhbmNlc3RvciA9PT0gbnVsbCB8fCBhbmNlc3RvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYW5jZXN0b3IuZ2V0KFRyYW5zZm9ybUNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC50cmFuc2xhdGUodHJhbnNmb3JtLnBvcy54LCB0cmFuc2Zvcm0ucG9zLnkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnNjYWxlKHRyYW5zZm9ybS5zY2FsZS54LCB0cmFuc2Zvcm0uc2NhbGUueSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQucm90YXRlKHRyYW5zZm9ybS5yb3RhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFwcGxpZXMgdGhlIGN1cnJlbnQgY2FtZXJhIHRyYW5zZm9ybSBpZiBpbiB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIHRyYW5zZm9ybVxyXG4gICAgICovXHJcbiAgICBfcHVzaENhbWVyYVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcclxuICAgICAgICAvLyBFc3RhYmxpc2ggY2FtZXJhIG9mZnNldCBwZXIgZW50aXR5XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5jb29yZFBsYW5lID09PSBDb29yZFBsYW5lLldvcmxkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoaWNzQ29udGV4dC5zYXZlKCk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW1lcmEpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbWVyYS5kcmF3KHRoaXMuX2dyYXBoaWNzQ29udGV4dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0cyB0aGUgY3VycmVudCBjYW1lcmEgdHJhbnNmb3JtIGlmIGluIHdvcmxkIGNvb3JkaW5hdGVzXHJcbiAgICAgKiBAcGFyYW0gdHJhbnNmb3JtXHJcbiAgICAgKi9cclxuICAgIF9wb3BDYW1lcmFUcmFuc2Zvcm0odHJhbnNmb3JtKSB7XHJcbiAgICAgICAgaWYgKHRyYW5zZm9ybS5jb29yZFBsYW5lID09PSBDb29yZFBsYW5lLldvcmxkKSB7XHJcbiAgICAgICAgICAgIC8vIEFwcGx5IGNhbWVyYSB3b3JsZCBvZmZzZXRcclxuICAgICAgICAgICAgdGhpcy5fZ3JhcGhpY3NDb250ZXh0LnJlc3RvcmUoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0FjdGlvbnNTeXN0ZW0udHNcblxyXG5cclxuY2xhc3MgQWN0aW9uc1N5c3RlbSBleHRlbmRzIFN5c3RlbSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMudHlwZXMgPSBbJ2V4LmFjdGlvbnMnXTtcclxuICAgICAgICB0aGlzLnN5c3RlbVR5cGUgPSBTeXN0ZW1UeXBlLlVwZGF0ZTtcclxuICAgICAgICB0aGlzLnByaW9yaXR5ID0gLTE7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoZW50aXRpZXMsIGRlbHRhKSB7XHJcbiAgICAgICAgbGV0IGFjdGlvbnM7XHJcbiAgICAgICAgZm9yIChjb25zdCBlbnRpdHkgb2YgZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgYWN0aW9ucyA9IGVudGl0eS5nZXQoQWN0aW9uc0NvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIGFjdGlvbnMudXBkYXRlKGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9TY2VuZS50c1xudmFyIFNjZW5lX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFtbQWN0b3J8QWN0b3JzXV0gYXJlIGNvbXBvc2VkIHRvZ2V0aGVyIGludG8gZ3JvdXBpbmdzIGNhbGxlZCBTY2VuZXMgaW5cclxuICogRXhjYWxpYnVyLiBUaGUgbWV0YXBob3IgbW9kZWxzIHRoZSBzYW1lIGlkZWEgYmVoaW5kIHJlYWwgd29ybGRcclxuICogYWN0b3JzIGluIGEgc2NlbmUuIE9ubHkgYWN0b3JzIGluIHNjZW5lcyB3aWxsIGJlIHVwZGF0ZWQgYW5kIGRyYXduLlxyXG4gKlxyXG4gKiBUeXBpY2FsIHVzYWdlcyBvZiBhIHNjZW5lIGluY2x1ZGU6IGxldmVscywgbWVudXMsIGxvYWRpbmcgc2NyZWVucywgZXRjLlxyXG4gKi9cclxuY2xhc3MgU2NlbmUgZXh0ZW5kcyBDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgb3Igc2V0cyB0aGUgY3VycmVudCBjYW1lcmEgZm9yIHRoZSBzY2VuZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FtZXJhID0gbmV3IENhbWVyYSgpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBFQ1Mgd29ybGQgZm9yIHRoZSBzY2VuZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMud29ybGQgPSBuZXcgV29ybGQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3RpbWVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlID0gW107XHJcbiAgICAgICAgLy8gVE9ETyBob3cgdG8gcGVvcGxlIGRvIHRoZXJlIG93biBzeXN0ZW1zXHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBzeXN0ZW1zXHJcbiAgICAgICAgdGhpcy53b3JsZC5hZGQobmV3IEFjdGlvbnNTeXN0ZW0oKSk7XHJcbiAgICAgICAgdGhpcy53b3JsZC5hZGQobmV3IE1vdGlvblN5c3RlbSgpKTtcclxuICAgICAgICB0aGlzLndvcmxkLmFkZChuZXcgQ29sbGlzaW9uU3lzdGVtKCkpO1xyXG4gICAgICAgIGlmIChGbGFncy5pc0VuYWJsZWQoTGVnYWN5LkxlZ2FjeURyYXdpbmcpKSB7XHJcbiAgICAgICAgICAgIHRoaXMud29ybGQuYWRkKG5ldyBDYW52YXNEcmF3aW5nU3lzdGVtKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy53b3JsZC5hZGQobmV3IEdyYXBoaWNzU3lzdGVtKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLndvcmxkLmFkZChuZXcgRGVidWdTeXN0ZW0oKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBhY3RvcnMgaW4gdGhlIGN1cnJlbnQgc2NlbmVcclxuICAgICAqL1xyXG4gICAgZ2V0IGFjdG9ycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy53b3JsZC5lbnRpdHlNYW5hZ2VyLmVudGl0aWVzLmZpbHRlcigoZSkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZSBpbnN0YW5jZW9mIEFjdG9yO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZW50aXRpZXMgaW4gdGhlIGN1cnJlbnQgc2NlbmVcclxuICAgICAqL1xyXG4gICAgZ2V0IGVudGl0aWVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkLmVudGl0eU1hbmFnZXIuZW50aXRpZXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSB0cmlnZ2VycyBpbiB0aGUgY3VycmVudCBzY2VuZVxyXG4gICAgICovXHJcbiAgICBnZXQgdHJpZ2dlcnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMud29ybGQuZW50aXR5TWFuYWdlci5lbnRpdGllcy5maWx0ZXIoKGUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGUgaW5zdGFuY2VvZiBUcmlnZ2VyX1RyaWdnZXI7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbW1RpbGVNYXBdXXMgaW4gdGhlIHNjZW5lLCBpZiBhbnlcclxuICAgICAqL1xyXG4gICAgZ2V0IHRpbGVNYXBzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLndvcmxkLmVudGl0eU1hbmFnZXIuZW50aXRpZXMuZmlsdGVyKChlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBlIGluc3RhbmNlb2YgVGlsZU1hcDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIFtbU2NyZWVuRWxlbWVudF1dcyBpbiBhIHNjZW5lLCBpZiBhbnk7IHRoZXNlIGFyZSBkcmF3biBsYXN0XHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tTY2VuZS5hY3RvcnNdXVxyXG4gICAgICovXHJcbiAgICBnZXQgc2NyZWVuRWxlbWVudHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0b3JzLmZpbHRlcigoYSkgPT4gYSBpbnN0YW5jZW9mIFNjcmVlbkVsZW1lbnRfU2NyZWVuRWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb25jZShldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBvZmYoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlIG9mIHRoZSBbW1NjZW5lXV0uIEluaXRpYWxpemVzIHNjZW5lIG1lbWJlcnMgbGlrZSB0aGUgY2FtZXJhLiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZVxyXG4gICAgICogb3ZlcnJpZGRlbi4gVGhpcyBpcyB3aGVyZSBpbml0aWFsaXphdGlvbiBvZiBjaGlsZCBhY3RvcnMgc2hvdWxkIHRha2UgcGxhY2UuXHJcbiAgICAgKi9cclxuICAgIG9uSW5pdGlhbGl6ZShfZW5naW5lKSB7XHJcbiAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhlIHNjZW5lIGlzIG1hZGUgYWN0aXZlIGFuZCBzdGFydGVkLiBJdCBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuLFxyXG4gICAgICogdGhpcyBpcyB3aGVyZSB5b3Ugc2hvdWxkIHNldHVwIGFueSBET00gVUkgb3IgZXZlbnQgaGFuZGxlcnMgbmVlZGVkIGZvciB0aGUgc2NlbmUuXHJcbiAgICAgKi9cclxuICAgIG9uQWN0aXZhdGUoX29sZFNjZW5lLCBfbmV3U2NlbmUpIHtcclxuICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGUgc2NlbmUgaXMgbWFkZSB0cmFuc2l0aW9uZWQgYXdheSBmcm9tIGFuZCBzdG9wcGVkLiBJdCBpcyBtZWFudCB0byBiZSBvdmVycmlkZGVuLFxyXG4gICAgICogdGhpcyBpcyB3aGVyZSB5b3Ugc2hvdWxkIGNsZWFudXAgYW55IERPTSBVSSBvciBldmVudCBoYW5kbGVycyBuZWVkZWQgZm9yIHRoZSBzY2VuZS5cclxuICAgICAqL1xyXG4gICAgb25EZWFjdGl2YXRlKF9vbGRTY2VuZSwgX25ld1NjZW5lKSB7XHJcbiAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25QcmVVcGRhdGUgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwcmV1cGRhdGUnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25QcmVVcGRhdGVgIGlzIGNhbGxlZCBkaXJlY3RseSBiZWZvcmUgYSBzY2VuZSBpcyB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBvblByZVVwZGF0ZShfZW5naW5lLCBfZGVsdGEpIHtcclxuICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2FmZSB0byBvdmVycmlkZSBvblBvc3RVcGRhdGUgbGlmZWN5Y2xlIGV2ZW50IGhhbmRsZXIuIFN5bm9ueW1vdXMgd2l0aCBgLm9uKCdwcmV1cGRhdGUnLCAoZXZ0KSA9PnsuLi59KWBcclxuICAgICAqXHJcbiAgICAgKiBgb25Qb3N0VXBkYXRlYCBpcyBjYWxsZWQgZGlyZWN0bHkgYWZ0ZXIgYSBzY2VuZSBpcyB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICBvblBvc3RVcGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25QcmVEcmF3IGxpZmVjeWNsZSBldmVudCBoYW5kbGVyLiBTeW5vbnltb3VzIHdpdGggYC5vbigncHJldXBkYXRlJywgKGV2dCkgPT57Li4ufSlgXHJcbiAgICAgKlxyXG4gICAgICogYG9uUHJlRHJhd2AgaXMgY2FsbGVkIGRpcmVjdGx5IGJlZm9yZSBhIHNjZW5lIGlzIGRyYXduLlxyXG4gICAgICovXHJcbiAgICBvblByZURyYXcoX2N0eCwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gd2lsbCBiZSBvdmVycmlkZGVuXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNhZmUgdG8gb3ZlcnJpZGUgb25Qb3N0RHJhdyBsaWZlY3ljbGUgZXZlbnQgaGFuZGxlci4gU3lub255bW91cyB3aXRoIGAub24oJ3ByZXVwZGF0ZScsIChldnQpID0+ey4uLn0pYFxyXG4gICAgICpcclxuICAgICAqIGBvblBvc3REcmF3YCBpcyBjYWxsZWQgZGlyZWN0bHkgYWZ0ZXIgYSBzY2VuZSBpcyBkcmF3bi5cclxuICAgICAqL1xyXG4gICAgb25Qb3N0RHJhdyhfY3R4LCBfZGVsdGEpIHtcclxuICAgICAgICAvLyB3aWxsIGJlIG92ZXJyaWRkZW5cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgYWN0b3JzIGluIHRoZSBzY2VuZVxyXG4gICAgICovXHJcbiAgICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgdGhpcy5lbnRpdGllcykge1xyXG4gICAgICAgICAgICBjaGlsZC5faW5pdGlhbGl6ZSh0aGlzLmVuZ2luZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBbW1NjZW5lXV0gaGFzIGJlZW4gaW5pdGlhbGl6ZWRcclxuICAgICAqL1xyXG4gICAgZ2V0IGlzSW5pdGlhbGl6ZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzSW5pdGlhbGl6ZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHNjZW5lIGJlZm9yZSB0aGUgZmlyc3QgdXBkYXRlLCBtZWFudCB0byBiZSBjYWxsZWQgYnkgZW5naW5lIG5vdCBieSB1c2VycyBvZlxyXG4gICAgICogRXhjYWxpYnVyXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX2luaXRpYWxpemUoZW5naW5lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgY2FtZXJhIGZpcnN0XHJcbiAgICAgICAgICAgIHRoaXMuY2FtZXJhLl9pbml0aWFsaXplKGVuZ2luZSk7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgb3JkZXIgaXMgaW1wb3J0YW50ISB3ZSB3YW50IHRvIGJlIHN1cmUgYW55IGN1c3RvbSBpbml0IHRoYXQgYWRkIGFjdG9yc1xyXG4gICAgICAgICAgICAvLyBmaXJlIGJlZm9yZSB0aGUgYWN0b3IgaW5pdFxyXG4gICAgICAgICAgICB0aGlzLm9uSW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGVuZ2luZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVDaGlsZHJlbigpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1NjZW5lLm9uSW5pdGlhbGl6ZScsIHRoaXMsIGVuZ2luZSk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2luaXRpYWxpemUnLCBuZXcgSW5pdGlhbGl6ZUV2ZW50KGVuZ2luZSwgdGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLl9pc0luaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogQWN0aXZhdGVzIHRoZSBzY2VuZSB3aXRoIHRoZSBiYXNlIGJlaGF2aW9yLCB0aGVuIGNhbGxzIHRoZSBvdmVycmlkYWJsZSBgb25BY3RpdmF0ZWAgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX2FjdGl2YXRlKG9sZFNjZW5lLCBuZXdTY2VuZSkge1xyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnU2NlbmUub25BY3RpdmF0ZScsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25BY3RpdmF0ZShvbGRTY2VuZSwgbmV3U2NlbmUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIERlYWN0aXZhdGVzIHRoZSBzY2VuZSB3aXRoIHRoZSBiYXNlIGJlaGF2aW9yLCB0aGVuIGNhbGxzIHRoZSBvdmVycmlkYWJsZSBgb25EZWFjdGl2YXRlYCBpbXBsZW1lbnRhdGlvbi5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfZGVhY3RpdmF0ZShvbGRTY2VuZSwgbmV3U2NlbmUpIHtcclxuICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1NjZW5lLm9uRGVhY3RpdmF0ZScsIHRoaXMpO1xyXG4gICAgICAgIHRoaXMub25EZWFjdGl2YXRlKG9sZFNjZW5lLCBuZXdTY2VuZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3ByZXVwZGF0ZSBoYW5kbGVyIGZvciBbW29uUHJlVXBkYXRlXV0gbGlmZWN5Y2xlIGV2ZW50XHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3ByZXVwZGF0ZShfZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncHJldXBkYXRlJywgbmV3IFByZVVwZGF0ZUV2ZW50KF9lbmdpbmUsIGRlbHRhLCB0aGlzKSk7XHJcbiAgICAgICAgdGhpcy5vblByZVVwZGF0ZShfZW5naW5lLCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqICBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wcmV1cGRhdGUgaGFuZGxlciBmb3IgW1tvblBvc3RVcGRhdGVdXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcG9zdHVwZGF0ZShfZW5naW5lLCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBQb3N0VXBkYXRlRXZlbnQoX2VuZ2luZSwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUG9zdFVwZGF0ZShfZW5naW5lLCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0aGF0IGludGVybmFsIGV4Y2FsaWJ1ciBtZXRob2RzIGJlIG92ZXJyaWRkZW4sIGRvIHNvIGF0IHlvdXIgb3duIHJpc2suXHJcbiAgICAgKlxyXG4gICAgICogSW50ZXJuYWwgX3ByZWRyYXcgaGFuZGxlciBmb3IgW1tvblByZURyYXddXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3ByZWRyYXcoX2N0eCwgX2RlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVkcmF3JywgbmV3IFByZURyYXdFdmVudChfY3R4LCBfZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUHJlRHJhdyhfY3R4LCBfZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdGhhdCBpbnRlcm5hbCBleGNhbGlidXIgbWV0aG9kcyBiZSBvdmVycmlkZGVuLCBkbyBzbyBhdCB5b3VyIG93biByaXNrLlxyXG4gICAgICpcclxuICAgICAqIEludGVybmFsIF9wb3N0ZHJhdyBoYW5kbGVyIGZvciBbW29uUG9zdERyYXddXSBsaWZlY3ljbGUgZXZlbnRcclxuICAgICAqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgX3Bvc3RkcmF3KF9jdHgsIF9kZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdGRyYXcnLCBuZXcgUG9zdERyYXdFdmVudChfY3R4LCBfZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUG9zdERyYXcoX2N0eCwgX2RlbHRhKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBhbGwgdGhlIGFjdG9ycyBhbmQgdGltZXJzIGluIHRoZSBzY2VuZS4gQ2FsbGVkIGJ5IHRoZSBbW0VuZ2luZV1dLlxyXG4gICAgICogQHBhcmFtIGVuZ2luZSAgUmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IEVuZ2luZVxyXG4gICAgICogQHBhcmFtIGRlbHRhICAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIHVwZGF0ZShlbmdpbmUsIGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5fcHJldXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgICAgIGlmICh0aGlzLmNhbWVyYSkge1xyXG4gICAgICAgICAgICB0aGlzLmNhbWVyYS51cGRhdGUoZW5naW5lLCBkZWx0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRPRE8gZGlmZmVyZWQgZW50aXR5IHJlbW92YWwgZm9yIHRpbWVyc1xyXG4gICAgICAgIGxldCBpLCBsZW47XHJcbiAgICAgICAgLy8gUmVtb3ZlIHRpbWVycyBpbiB0aGUgY2FuY2VsIHF1ZXVlIGJlZm9yZSB1cGRhdGluZyB0aGVtXHJcbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5fY2FuY2VsUXVldWUubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVUaW1lcih0aGlzLl9jYW5jZWxRdWV1ZVtpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2NhbmNlbFF1ZXVlLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgLy8gQ3ljbGUgdGhyb3VnaCB0aW1lcnMgdXBkYXRpbmcgdGltZXJzXHJcbiAgICAgICAgZm9yIChjb25zdCB0aW1lciBvZiB0aGlzLl90aW1lcnMpIHtcclxuICAgICAgICAgICAgdGltZXIudXBkYXRlKGRlbHRhKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy53b3JsZC51cGRhdGUoU3lzdGVtVHlwZS5VcGRhdGUsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLl9jb2xsZWN0QWN0b3JTdGF0cyhlbmdpbmUpO1xyXG4gICAgICAgIGVuZ2luZS5pbnB1dC5wb2ludGVycy5kaXNwYXRjaFBvaW50ZXJFdmVudHMoKTtcclxuICAgICAgICB0aGlzLl9wb3N0dXBkYXRlKGVuZ2luZSwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhbGwgdGhlIGFjdG9ycyBpbiB0aGUgU2NlbmUuIENhbGxlZCBieSB0aGUgW1tFbmdpbmVdXS5cclxuICAgICAqIEBwYXJhbSBjdHggICAgVGhlIGN1cnJlbnQgcmVuZGVyaW5nIGNvbnRleHRcclxuICAgICAqIEBwYXJhbSBkZWx0YSAgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgZHJhd1xyXG4gICAgICovXHJcbiAgICBkcmF3KGN0eCwgZGVsdGEpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgdGhpcy5fcHJlZHJhdyhjdHgsIGRlbHRhKTtcclxuICAgICAgICB0aGlzLndvcmxkLnVwZGF0ZShTeXN0ZW1UeXBlLkRyYXcsIGRlbHRhKTtcclxuICAgICAgICBpZiAoKF9hID0gdGhpcy5lbmdpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc0RlYnVnKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGVidWdEcmF3KGN0eCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX3Bvc3RkcmF3KGN0eCwgZGVsdGEpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEcmF3cyBhbGwgdGhlIGFjdG9ycycgZGVidWcgaW5mb3JtYXRpb24gaW4gdGhlIFNjZW5lLiBDYWxsZWQgYnkgdGhlIFtbRW5naW5lXV0uXHJcbiAgICAgKiBAcGFyYW0gY3R4ICBUaGUgY3VycmVudCByZW5kZXJpbmcgY29udGV4dFxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgIGRlYnVnRHJhdyhjdHgpIHtcclxuICAgICAgICB0aGlzLmVtaXQoJ3ByZWRlYnVnZHJhdycsIG5ldyBQcmVEZWJ1Z0RyYXdFdmVudChjdHgsIHRoaXMpKTtcclxuICAgICAgICAvLyBwYXNzXHJcbiAgICAgICAgdGhpcy5lbWl0KCdwb3N0ZGVidWdkcmF3JywgbmV3IFBvc3REZWJ1Z0RyYXdFdmVudChjdHgsIHRoaXMpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYW4gYWN0b3IgaXMgY29udGFpbmVkIGluIHRoaXMgc2NlbmUgb3Igbm90XHJcbiAgICAgKi9cclxuICAgIGNvbnRhaW5zKGFjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0b3JzLmluZGV4T2YoYWN0b3IpID4gLTE7XHJcbiAgICB9XHJcbiAgICBhZGQoZW50aXR5KSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdlbnRpdHlhZGRlZCcsIHsgdGFyZ2V0OiBlbnRpdHkgfSk7XHJcbiAgICAgICAgdGhpcy53b3JsZC5hZGQoZW50aXR5KTtcclxuICAgICAgICBlbnRpdHkuc2NlbmUgPSB0aGlzO1xyXG4gICAgICAgIGlmIChlbnRpdHkgaW5zdGFuY2VvZiBUaW1lcikge1xyXG4gICAgICAgICAgICBpZiAoIWNvbnRhaW5zKHRoaXMuX3RpbWVycywgZW50aXR5KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUaW1lcihlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZW1vdmUoZW50aXR5KSB7XHJcbiAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIEVudGl0eSkge1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2VudGl0eXJlbW92ZWQnLCB7IHRhcmdldDogZW50aXR5IH0pO1xyXG4gICAgICAgICAgICB0aGlzLndvcmxkLnJlbW92ZShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgVGltZXIpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVUaW1lcihlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyAoYW55KSBhY3RvciB0byBhY3QgYXMgYSBwaWVjZSBvZiBVSSwgbWVhbmluZyBpdCBpcyBhbHdheXMgcG9zaXRpb25lZFxyXG4gICAgICogaW4gc2NyZWVuIGNvb3JkaW5hdGVzLiBVSSBhY3RvcnMgZG8gbm90IHBhcnRpY2lwYXRlIGluIGNvbGxpc2lvbnMuXHJcbiAgICAgKiBAdG9kbyBTaG91bGQgdGhpcyBiZSBgU2NyZWVuRWxlbWVudGAgb25seT9cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW1NjZW5lLmFkZF1dXHJcbiAgICAgKi9cclxuICAgIGFkZFNjcmVlbkVsZW1lbnQoYWN0b3IpIHtcclxuICAgICAgICB0aGlzLmFkZChhY3Rvcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gYWN0b3IgYXMgYSBwaWVjZSBvZiBVSVxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbU2NlbmUucmVtb3ZlXV1cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlU2NyZWVuRWxlbWVudChhY3Rvcikge1xyXG4gICAgICAgIHRoaXMucmVtb3ZlKGFjdG9yKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIFtbVGlsZU1hcF1dIHRvIHRoZSBzY2VuZSwgb25jZSB0aGlzIGlzIGRvbmUgdGhlIFRpbGVNYXAgd2lsbCBiZSBkcmF3biBhbmQgdXBkYXRlZC5cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW1NjZW5lLmFkZF1dXHJcbiAgICAgKi9cclxuICAgIGFkZFRpbGVNYXAodGlsZU1hcCkge1xyXG4gICAgICAgIHRoaXMud29ybGQuYWRkKHRpbGVNYXApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgW1tUaWxlTWFwXV0gZnJvbSB0aGUgc2NlbmUsIGl0IHdpbGwgbm8gbG9uZ2VyIGJlIGRyYXduIG9yIHVwZGF0ZWQuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tTY2VuZS5yZW1vdmVdXVxyXG4gICAgICovXHJcbiAgICByZW1vdmVUaWxlTWFwKHRpbGVNYXApIHtcclxuICAgICAgICB0aGlzLndvcmxkLnJlbW92ZSh0aWxlTWFwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhIFtbVGltZXJdXSB0byB0aGUgc2NlbmVcclxuICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIGFkZFxyXG4gICAgICovXHJcbiAgICBhZGRUaW1lcih0aW1lcikge1xyXG4gICAgICAgIHRoaXMuX3RpbWVycy5wdXNoKHRpbWVyKTtcclxuICAgICAgICB0aW1lci5zY2VuZSA9IHRoaXM7XHJcbiAgICAgICAgcmV0dXJuIHRpbWVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIGEgW1tUaW1lcl1dIGZyb20gdGhlIHNjZW5lLlxyXG4gICAgICogQHdhcm5pbmcgQ2FuIGJlIGRhbmdlcm91cywgdXNlIFtbY2FuY2VsVGltZXJdXSBpbnN0ZWFkXHJcbiAgICAgKiBAcGFyYW0gdGltZXIgIFRoZSB0aW1lciB0byByZW1vdmVcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlVGltZXIodGltZXIpIHtcclxuICAgICAgICBjb25zdCBpID0gdGhpcy5fdGltZXJzLmluZGV4T2YodGltZXIpO1xyXG4gICAgICAgIGlmIChpICE9PSAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLl90aW1lcnMuc3BsaWNlKGksIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGltZXI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbmNlbHMgYSBbW1RpbWVyXV0sIHJlbW92aW5nIGl0IGZyb20gdGhlIHNjZW5lIG5pY2VseVxyXG4gICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gY2FuY2VsXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbFRpbWVyKHRpbWVyKSB7XHJcbiAgICAgICAgdGhpcy5fY2FuY2VsUXVldWUucHVzaCh0aW1lcik7XHJcbiAgICAgICAgcmV0dXJuIHRpbWVyO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyB3aGV0aGVyIGEgW1tUaW1lcl1dIGlzIGFjdGl2ZSBpbiB0aGUgc2NlbmVcclxuICAgICAqL1xyXG4gICAgaXNUaW1lckFjdGl2ZSh0aW1lcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90aW1lcnMuaW5kZXhPZih0aW1lcikgPiAtMSAmJiAhdGltZXIuY29tcGxldGU7XHJcbiAgICB9XHJcbiAgICBpc0N1cnJlbnRTY2VuZSgpIHtcclxuICAgICAgICBpZiAodGhpcy5lbmdpbmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5naW5lLmN1cnJlbnRTY2VuZSA9PT0gdGhpcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgX2NvbGxlY3RBY3RvclN0YXRzKGVuZ2luZSkge1xyXG4gICAgICAgIGNvbnN0IHNjcmVlbkVsZW1lbnRzID0gdGhpcy5hY3RvcnMuZmlsdGVyKChhKSA9PiBhIGluc3RhbmNlb2YgU2NyZWVuRWxlbWVudF9TY3JlZW5FbGVtZW50KTtcclxuICAgICAgICBmb3IgKGNvbnN0IF91aSBvZiBzY3JlZW5FbGVtZW50cykge1xyXG4gICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy51aSsrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IGFjdG9yIG9mIHRoaXMuYWN0b3JzKSB7XHJcbiAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLmFsaXZlKys7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hpbGQgb2YgYWN0b3IuY2hpbGRyZW4pIHtcclxuICAgICAgICAgICAgICAgIGlmIChpc1NjcmVlbkVsZW1lbnQoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBub3QgdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIGVuZ2luZS5zdGF0cy5jdXJyRnJhbWUuYWN0b3JzLnVpKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBlbmdpbmUuc3RhdHMuY3VyckZyYW1lLmFjdG9ycy5hbGl2ZSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblNjZW5lX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnV2lsbCBiZSByZW1vdmVkIGluIGV4Y2FsaWJ1ciB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdTY3JlZW5FbGVtZW50cyBub3cgYXJlIG5vcm1hbCBhY3RvcnMgd2l0aCBhIFRyYW5zZm9ybSBDb29yZGluYXRlIFBsYW5lIG9mIFNjcmVlbidcclxuICAgIH0pXHJcbl0sIFNjZW5lLnByb3RvdHlwZSwgXCJzY3JlZW5FbGVtZW50c1wiLCBudWxsKTtcclxuU2NlbmVfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnV2lsbCBiZSByZW1vdmVkIGluIGV4Y2FsaWJ1ciB2MC4yNi4wJywgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIFNjZW5lLmFkZCcgfSlcclxuXSwgU2NlbmUucHJvdG90eXBlLCBcImFkZFNjcmVlbkVsZW1lbnRcIiwgbnVsbCk7XHJcblNjZW5lX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHsgbWVzc2FnZTogJ1dpbGwgYmUgcmVtb3ZlZCBpbiBleGNhbGlidXIgdjAuMjYuMCcsIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBTY2VuZS5yZW1vdmUnIH0pXHJcbl0sIFNjZW5lLnByb3RvdHlwZSwgXCJyZW1vdmVTY3JlZW5FbGVtZW50XCIsIG51bGwpO1xyXG5TY2VuZV9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7IG1lc3NhZ2U6ICdXaWxsIGJlIHJlbW92ZWQgaW4gZXhjYWxpYnVyIHYwLjI2LjAnLCBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgU2NlbmUuYWRkJyB9KVxyXG5dLCBTY2VuZS5wcm90b3R5cGUsIFwiYWRkVGlsZU1hcFwiLCBudWxsKTtcclxuU2NlbmVfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnV2lsbCBiZSByZW1vdmVkIGluIGV4Y2FsaWJ1ciB2MC4yNi4wJywgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIFNjZW5lLnJlbW92ZScgfSlcclxuXSwgU2NlbmUucHJvdG90eXBlLCBcInJlbW92ZVRpbGVNYXBcIiwgbnVsbCk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUG9zdFByb2Nlc3NpbmcvQ29sb3JCbGluZENvcnJlY3Rvci50c1xuXHJcbnZhciBDb2xvckJsaW5kbmVzcztcclxuKGZ1bmN0aW9uIChDb2xvckJsaW5kbmVzcykge1xyXG4gICAgQ29sb3JCbGluZG5lc3NbQ29sb3JCbGluZG5lc3NbXCJQcm90YW5vcGVcIl0gPSAwXSA9IFwiUHJvdGFub3BlXCI7XHJcbiAgICBDb2xvckJsaW5kbmVzc1tDb2xvckJsaW5kbmVzc1tcIkRldXRlcmFub3BlXCJdID0gMV0gPSBcIkRldXRlcmFub3BlXCI7XHJcbiAgICBDb2xvckJsaW5kbmVzc1tDb2xvckJsaW5kbmVzc1tcIlRyaXRhbm9wZVwiXSA9IDJdID0gXCJUcml0YW5vcGVcIjtcclxufSkoQ29sb3JCbGluZG5lc3MgfHwgKENvbG9yQmxpbmRuZXNzID0ge30pKTtcclxuLyoqXHJcbiAqIFRoaXMgcG9zdCBwcm9jZXNzb3IgY2FuIGNvcnJlY3QgY29sb3JzIGFuZCBzaW11bGF0ZSBjb2xvciBibGluZG5lc3MuXHJcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIHVzZSB0aGlzIG9uIGV2ZXJ5IGdhbWUsIGJ1dCB0aGUgZ2FtZSdzIHBlcmZvcm1hbmNlXHJcbiAqIHdpbGwgc3VmZmVyIG1lYXN1cmFibHkuIEl0J3MgYmV0dGVyIHRvIHVzZSBpdCBhcyBhIGhlbHBmdWwgdG9vbCB3aGlsZSBkZXZlbG9waW5nIHlvdXIgZ2FtZS5cclxuICogUmVtZW1iZXIsIHRoZSBiZXN0IHByYWN0aWNlIGlzIHRvIGRlc2lnbiB3aXRoIGNvbG9yIGJsaW5kbmVzcyBpbiBtaW5kLlxyXG4gKi9cclxuY2xhc3MgQ29sb3JCbGluZENvcnJlY3RvciB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUsIHNpbXVsYXRlID0gZmFsc2UsIGNvbG9yTW9kZSA9IENvbG9yQmxpbmRuZXNzLlByb3Rhbm9wZSkge1xyXG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuc2ltdWxhdGUgPSBzaW11bGF0ZTtcclxuICAgICAgICB0aGlzLmNvbG9yTW9kZSA9IGNvbG9yTW9kZTtcclxuICAgICAgICAvKmVzbGludC1kaXNhYmxlICovXHJcbiAgICAgICAgdGhpcy5fdmVydGV4U2hhZGVyID0gJycgK1xyXG4gICAgICAgICAgICAnYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjsnICtcclxuICAgICAgICAgICAgJ2F0dHJpYnV0ZSB2ZWMyIGFfdGV4Q29vcmQ7JyArXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOycgK1xyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7JyArXHJcbiAgICAgICAgICAgICd2b2lkIG1haW4oKSB7JyArXHJcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgdGhlIHJlY3RhbmdsZSBmcm9tIHBpeGVscyB0byAwLjAgdG8gMS4wXHJcbiAgICAgICAgICAgICd2ZWMyIHplcm9Ub09uZSA9IGFfcG9zaXRpb24gLyB1X3Jlc29sdXRpb247JyArXHJcbiAgICAgICAgICAgIC8vIGNvbnZlcnQgZnJvbSAwLT4xIHRvIDAtPjJcclxuICAgICAgICAgICAgJ3ZlYzIgemVyb1RvVHdvID0gemVyb1RvT25lICogMi4wOycgK1xyXG4gICAgICAgICAgICAvLyBjb252ZXJ0IGZyb20gMC0+MiB0byAtMS0+KzEgKGNsaXBzcGFjZSlcclxuICAgICAgICAgICAgJ3ZlYzIgY2xpcFNwYWNlID0gemVyb1RvVHdvIC0gMS4wOycgK1xyXG4gICAgICAgICAgICAnZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBTcGFjZSAqIHZlYzIoMSwgLTEpLCAwLCAxKTsnICtcclxuICAgICAgICAgICAgLy8gcGFzcyB0aGUgdGV4Q29vcmQgdG8gdGhlIGZyYWdtZW50IHNoYWRlclxyXG4gICAgICAgICAgICAvLyBUaGUgR1BVIHdpbGwgaW50ZXJwb2xhdGUgdGhpcyB2YWx1ZSBiZXR3ZWVuIHBvaW50cy5cclxuICAgICAgICAgICAgJ3ZfdGV4Q29vcmQgPSBhX3RleENvb3JkOycgK1xyXG4gICAgICAgICAgICAnfSc7XHJcbiAgICAgICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSAncHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7JyArXHJcbiAgICAgICAgICAgIC8vIG91ciB0ZXh0dXJlXHJcbiAgICAgICAgICAgICd1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlOycgK1xyXG4gICAgICAgICAgICAvLyB0aGUgdGV4Q29vcmRzIHBhc3NlZCBpbiBmcm9tIHRoZSB2ZXJ0ZXggc2hhZGVyLlxyXG4gICAgICAgICAgICAndmFyeWluZyB2ZWMyIHZfdGV4Q29vcmQ7JyArXHJcbiAgICAgICAgICAgIC8vIENvbG9yIGJsaW5kIGNvbnZlcnNpb25zXHJcbiAgICAgICAgICAgIC8qJ21hdDMgbVs5XSA9JyArXHJcbiAgICAgICAgICAgJ3snICtcclxuICAgICAgICAgICAgICAnbWF0MygxLjAsIDAuMCwgMC4wLCAgMC4wLCAxLjAsIDAuMCwgIDAuMCwgMC4wLCAxLjAgICksJyArIC8vIG5vcm1hbFxyXG4gICAgICAgICAgICAgICdtYXQzKDAuNTY3LCAwLjQzMywgMC4wLCAgMC41NTgsIDAuNDQyLCAwLjAsICAwLjAsIDAuMjQyLCAwLjc1OCksJyArIC8vIHByb3Rhbm9waWFcclxuICAgICAgICAgICAgICAnbWF0MygwLjgxNywgMC4xODMsIDAuMCwgIDAuMzMzLCAwLjY2NywgMC4wLCAgMC4wLCAwLjEyNSwwLjg3NSksJyArIC8vIHByb3Rhbm9tYWx5XHJcbiAgICAgICAgICAgICAgJ21hdDMoMC42MjUsIDAuMzc1LCAwLjAsICAwLjcsIDAuMywgMC4wLCAgMC4wLCAwLjMsMC43ICApLCcgKyAvLyBkZXV0ZXJhbm9waWFcclxuICAgICAgICAgICAgICAnbWF0MygwLjgsIDAuMiwgMC4wLCAgMC4yNTgsIDAuNzQyLCAwLjAsICAwLjAsIDAuMTQyLDAuODU4KSwnICsgLy8gZGV1dGVyYW5vbWFseVxyXG4gICAgICAgICAgICAgICdtYXQzKDAuOTUsIDAuMDUsIDAuMCwgIDAuMCwgMC40MzMsIDAuNTY3LCAgMC4wLCAwLjQ3NSwwLjUyNSksJyArIC8vIHRyaXRhbm9waWFcclxuICAgICAgICAgICAgICAnbWF0MygwLjk2NywgMC4wMzMsIDAuMCwgIDAuMCwgMC43MzMsIDAuMjY3LCAgMC4wLCAwLjE4MywwLjgxNyksJyArIC8vIHRyaXRhbm9tYWx5XHJcbiAgICAgICAgICAgICAgJ21hdDMoMC4yOTksIDAuNTg3LCAwLjExNCwgIDAuMjk5LCAwLjU4NywgMC4xMTQsICAwLjI5OSwgMC41ODcsMC4xMTQpLCcgKyAvLyBhY2hyb21hdG9wc2lhXHJcbiAgICAgICAgICAgICAgJ21hdDMoMC42MTgsIDAuMzIwLCAwLjA2MiwgIDAuMTYzLCAwLjc3NSwgMC4wNjIsICAwLjE2MywgMC4zMjAsMC41MTYpJyArICAvLyBhY2hyb21hdG9tYWx5XHJcbiAgICAgICAgICAgJ307JyArKi9cclxuICAgICAgICAgICAgJ3ZvaWQgbWFpbigpIHsnICtcclxuICAgICAgICAgICAgJ3ZlYzQgbyA9ICB0ZXh0dXJlMkQodV9pbWFnZSwgdl90ZXhDb29yZCk7JyArXHJcbiAgICAgICAgICAgIC8vIFJHQiB0byBMTVMgbWF0cml4IGNvbnZlcnNpb25cclxuICAgICAgICAgICAgJ2Zsb2F0IEwgPSAoMTcuODgyNCAqIG8ucikgKyAoNDMuNTE2MSAqIG8uZykgKyAoNC4xMTkzNSAqIG8uYik7JyArXHJcbiAgICAgICAgICAgICdmbG9hdCBNID0gKDMuNDU1NjUgKiBvLnIpICsgKDI3LjE1NTQgKiBvLmcpICsgKDMuODY3MTQgKiBvLmIpOycgK1xyXG4gICAgICAgICAgICAnZmxvYXQgUyA9ICgwLjAyOTk1NjYgKiBvLnIpICsgKDAuMTg0MzA5ICogby5nKSArICgxLjQ2NzA5ICogby5iKTsnICtcclxuICAgICAgICAgICAgLy8gU2ltdWxhdGUgY29sb3IgYmxpbmRuZXNzXHJcbiAgICAgICAgICAgICcvL01PREUgQ09ERS8vJyArXHJcbiAgICAgICAgICAgIC8qIERldXRlcmFub3BlIGZvciB0ZXN0aW5nXHJcbiAgICAgICAgICAgICAgJ2Zsb2F0IGwgPSAxLjAgKiBMICsgMC4wICogTSArIDAuMCAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IG0gPSAwLjQ5NDIwNyAqIEwgKyAwLjAgKiBNICsgMS4yNDgyNyAqIFM7JyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ2Zsb2F0IHMgPSAwLjAgKiBMICsgMC4wICogTSArIDEuMCAqIFM7JyArKi9cclxuICAgICAgICAgICAgLy8gTE1TIHRvIFJHQiBtYXRyaXggY29udmVyc2lvblxyXG4gICAgICAgICAgICAndmVjNCBlcnJvcjsnICtcclxuICAgICAgICAgICAgJ2Vycm9yLnIgPSAoMC4wODA5NDQ0NDc5ICogbCkgKyAoLTAuMTMwNTA0NDA5ICogbSkgKyAoMC4xMTY3MjEwNjYgKiBzKTsnICtcclxuICAgICAgICAgICAgJ2Vycm9yLmcgPSAoLTAuMDEwMjQ4NTMzNSAqIGwpICsgKDAuMDU0MDE5MzI2NiAqIG0pICsgKC0wLjExMzYxNDcwOCAqIHMpOycgK1xyXG4gICAgICAgICAgICAnZXJyb3IuYiA9ICgtMC4wMDAzNjUyOTY5MzggKiBsKSArICgtMC4wMDQxMjE2MTQ2OSAqIG0pICsgKDAuNjkzNTExNDA1ICogcyk7JyArXHJcbiAgICAgICAgICAgICdlcnJvci5hID0gMS4wOycgK1xyXG4gICAgICAgICAgICAndmVjNCBkaWZmID0gbyAtIGVycm9yOycgK1xyXG4gICAgICAgICAgICAndmVjNCBjb3JyZWN0aW9uOycgK1xyXG4gICAgICAgICAgICAnY29ycmVjdGlvbi5yID0gMC4wOycgK1xyXG4gICAgICAgICAgICAnY29ycmVjdGlvbi5nID0gIChkaWZmLnIgKiAwLjcpICsgKGRpZmYuZyAqIDEuMCk7JyArXHJcbiAgICAgICAgICAgICdjb3JyZWN0aW9uLmIgPSAgKGRpZmYuciAqIDAuNykgKyAoZGlmZi5iICogMS4wKTsnICtcclxuICAgICAgICAgICAgJ2NvcnJlY3Rpb24gPSBvICsgY29ycmVjdGlvbjsnICtcclxuICAgICAgICAgICAgJ2NvcnJlY3Rpb24uYSA9IG8uYTsnICtcclxuICAgICAgICAgICAgJy8vU0lNVUxBVEUvLycgK1xyXG4gICAgICAgICAgICAnfSc7XHJcbiAgICAgICAgdGhpcy5faW50ZXJuYWxDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICAgICAgICB0aGlzLl9pbnRlcm5hbENhbnZhcy53aWR0aCA9IGVuZ2luZS5kcmF3V2lkdGg7XHJcbiAgICAgICAgdGhpcy5faW50ZXJuYWxDYW52YXMuaGVpZ2h0ID0gZW5naW5lLmRyYXdIZWlnaHQ7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgdGhpcy5fZ2wgPSB0aGlzLl9pbnRlcm5hbENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcsIHsgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiB0cnVlIH0pO1xyXG4gICAgICAgIHRoaXMuX3Byb2dyYW0gPSB0aGlzLl9nbC5jcmVhdGVQcm9ncmFtKCk7XHJcbiAgICAgICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSB0aGlzLl9nZXRTaGFkZXIoJ0ZyYWdtZW50JywgdGhpcy5fZ2V0RnJhZ21lbnRTaGFkZXJCeU1vZGUoY29sb3JNb2RlKSk7XHJcbiAgICAgICAgY29uc3QgdmVydGV4dFNoYWRlciA9IHRoaXMuX2dldFNoYWRlcignVmVydGV4JywgdGhpcy5fdmVydGV4U2hhZGVyKTtcclxuICAgICAgICB0aGlzLl9nbC5hdHRhY2hTaGFkZXIodGhpcy5fcHJvZ3JhbSwgdmVydGV4dFNoYWRlcik7XHJcbiAgICAgICAgdGhpcy5fZ2wuYXR0YWNoU2hhZGVyKHRoaXMuX3Byb2dyYW0sIGZyYWdtZW50U2hhZGVyKTtcclxuICAgICAgICB0aGlzLl9nbC5saW5rUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKTtcclxuICAgICAgICBpZiAoIXRoaXMuX2dsLmdldFByb2dyYW1QYXJhbWV0ZXIodGhpcy5fcHJvZ3JhbSwgdGhpcy5fZ2wuTElOS19TVEFUVVMpKSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdVbmFibGUgdG8gbGluayBzaGFkZXIgcHJvZ3JhbSEnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fZ2wudXNlUHJvZ3JhbSh0aGlzLl9wcm9ncmFtKTtcclxuICAgIH1cclxuICAgIF9nZXRGcmFnbWVudFNoYWRlckJ5TW9kZShjb2xvck1vZGUpIHtcclxuICAgICAgICBsZXQgY29kZSA9ICcnO1xyXG4gICAgICAgIGlmIChjb2xvck1vZGUgPT09IENvbG9yQmxpbmRuZXNzLlByb3Rhbm9wZSkge1xyXG4gICAgICAgICAgICBjb2RlID1cclxuICAgICAgICAgICAgICAgICdmbG9hdCBsID0gMC4wICogTCArIDIuMDIzNDQgKiBNICsgLTIuNTI1ODEgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICdmbG9hdCBtID0gMC4wICogTCArIDEuMCAqIE0gKyAwLjAgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICdmbG9hdCBzID0gMC4wICogTCArIDAuMCAqIE0gKyAxLjAgKiBTOyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGNvbG9yTW9kZSA9PT0gQ29sb3JCbGluZG5lc3MuRGV1dGVyYW5vcGUpIHtcclxuICAgICAgICAgICAgY29kZSA9XHJcbiAgICAgICAgICAgICAgICAnZmxvYXQgbCA9IDEuMCAqIEwgKyAwLjAgKiBNICsgMC4wICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAnZmxvYXQgbSA9IDAuNDk0MjA3ICogTCArIDAuMCAqIE0gKyAxLjI0ODI3ICogUzsnICtcclxuICAgICAgICAgICAgICAgICAgICAnZmxvYXQgcyA9IDAuMCAqIEwgKyAwLjAgKiBNICsgMS4wICogUzsnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb2xvck1vZGUgPT09IENvbG9yQmxpbmRuZXNzLlRyaXRhbm9wZSkge1xyXG4gICAgICAgICAgICBjb2RlID1cclxuICAgICAgICAgICAgICAgICdmbG9hdCBsID0gMS4wICogTCArIDAuMCAqIE0gKyAwLjAgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICdmbG9hdCBtID0gMC4wICogTCArIDEuMCAqIE0gKyAwLjAgKiBTOycgK1xyXG4gICAgICAgICAgICAgICAgICAgICdmbG9hdCBzID0gLTAuMzk1OTEzICogTCArIDAuODAxMTA5ICogTSArIDAuMCAqIFM7JztcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuc2ltdWxhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZnJhZ21lbnRTaGFkZXIgPSB0aGlzLl9mcmFnbWVudFNoYWRlci5yZXBsYWNlKCcvL1NJTVVMQVRFLy8nLCAnZ2xfRnJhZ0NvbG9yID0gZXJyb3IucmdiYTsnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZyYWdtZW50U2hhZGVyID0gdGhpcy5fZnJhZ21lbnRTaGFkZXIucmVwbGFjZSgnLy9TSU1VTEFURS8vJywgJ2dsX0ZyYWdDb2xvciA9IGNvcnJlY3Rpb24ucmdiYTsnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZyYWdtZW50U2hhZGVyLnJlcGxhY2UoJy8vTU9ERSBDT0RFLy8nLCBjb2RlKTtcclxuICAgIH1cclxuICAgIF9zZXRSZWN0YW5nbGUoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIGNvbnN0IHgxID0geDtcclxuICAgICAgICBjb25zdCB4MiA9IHggKyB3aWR0aDtcclxuICAgICAgICBjb25zdCB5MSA9IHk7XHJcbiAgICAgICAgY29uc3QgeTIgPSB5ICsgaGVpZ2h0O1xyXG4gICAgICAgIHRoaXMuX2dsLmJ1ZmZlckRhdGEodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFt4MSwgeTEsIHgyLCB5MSwgeDEsIHkyLCB4MSwgeTIsIHgyLCB5MSwgeDIsIHkyXSksIHRoaXMuX2dsLlNUQVRJQ19EUkFXKTtcclxuICAgIH1cclxuICAgIF9nZXRTaGFkZXIodHlwZSwgcHJvZ3JhbSkge1xyXG4gICAgICAgIGxldCBzaGFkZXI7XHJcbiAgICAgICAgaWYgKHR5cGUgPT09ICdGcmFnbWVudCcpIHtcclxuICAgICAgICAgICAgc2hhZGVyID0gdGhpcy5fZ2wuY3JlYXRlU2hhZGVyKHRoaXMuX2dsLkZSQUdNRU5UX1NIQURFUik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdWZXJ0ZXgnKSB7XHJcbiAgICAgICAgICAgIHNoYWRlciA9IHRoaXMuX2dsLmNyZWF0ZVNoYWRlcih0aGlzLl9nbC5WRVJURVhfU0hBREVSKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdFcnJvciB1bmtub3duIHNoYWRlciB0eXBlJywgdHlwZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2dsLnNoYWRlclNvdXJjZShzaGFkZXIsIHByb2dyYW0pO1xyXG4gICAgICAgIHRoaXMuX2dsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcclxuICAgICAgICBpZiAoIXRoaXMuX2dsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIHRoaXMuX2dsLkNPTVBJTEVfU1RBVFVTKSkge1xyXG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignVW5hYmxlIHRvIGNvbXBpbGUgc2hhZGVyIScsIHRoaXMuX2dsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gc2hhZGVyO1xyXG4gICAgfVxyXG4gICAgcHJvY2VzcyhpbWFnZSwgb3V0KSB7XHJcbiAgICAgICAgLy8gbG9vayB1cCB3aGVyZSB0aGUgdmVydGV4IGRhdGEgbmVlZHMgdG8gZ28uXHJcbiAgICAgICAgY29uc3QgcG9zaXRpb25Mb2NhdGlvbiA9IHRoaXMuX2dsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sICdhX3Bvc2l0aW9uJyk7XHJcbiAgICAgICAgY29uc3QgdGV4Q29vcmRMb2NhdGlvbiA9IHRoaXMuX2dsLmdldEF0dHJpYkxvY2F0aW9uKHRoaXMuX3Byb2dyYW0sICdhX3RleENvb3JkJyk7XHJcbiAgICAgICAgY29uc3QgdGV4Q29vcmRCdWZmZXIgPSB0aGlzLl9nbC5jcmVhdGVCdWZmZXIoKTtcclxuICAgICAgICB0aGlzLl9nbC5iaW5kQnVmZmVyKHRoaXMuX2dsLkFSUkFZX0JVRkZFUiwgdGV4Q29vcmRCdWZmZXIpO1xyXG4gICAgICAgIHRoaXMuX2dsLmJ1ZmZlckRhdGEodGhpcy5fZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KFswLjAsIDAuMCwgMS4wLCAwLjAsIDAuMCwgMS4wLCAwLjAsIDEuMCwgMS4wLCAwLjAsIDEuMCwgMS4wXSksIHRoaXMuX2dsLlNUQVRJQ19EUkFXKTtcclxuICAgICAgICB0aGlzLl9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0ZXhDb29yZExvY2F0aW9uKTtcclxuICAgICAgICB0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRleENvb3JkTG9jYXRpb24sIDIsIHRoaXMuX2dsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgdGV4dHVyZS5cclxuICAgICAgICBjb25zdCB0ZXh0dXJlID0gdGhpcy5fZ2wuY3JlYXRlVGV4dHVyZSgpO1xyXG4gICAgICAgIHRoaXMuX2dsLmJpbmRUZXh0dXJlKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xyXG4gICAgICAgIC8vIFNldCB0aGUgcGFyYW1ldGVycyBzbyB3ZSBjYW4gcmVuZGVyIGFueSBzaXplIGltYWdlLlxyXG4gICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuX2dsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuX2dsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgICAgIHRoaXMuX2dsLnRleFBhcmFtZXRlcmkodGhpcy5fZ2wuVEVYVFVSRV8yRCwgdGhpcy5fZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLl9nbC5ORUFSRVNUKTtcclxuICAgICAgICB0aGlzLl9nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuX2dsLlRFWFRVUkVfMkQsIHRoaXMuX2dsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5fZ2wuTkVBUkVTVCk7XHJcbiAgICAgICAgLy8gRmxpcCB0aGUgdGV4dHVyZSB3aGVuIHVucGFja2luZyBpbnRvIHRoZSBnbCBjb250ZXh0LCBnbCByZWFkcyB0ZXh0dXJlcyBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIgYXMgZXZlcnl0aGluZyBlbHNlIDovXHJcbiAgICAgICAgdGhpcy5fZ2wucGl4ZWxTdG9yZWkodGhpcy5fZ2wuVU5QQUNLX0ZMSVBfWV9XRUJHTCwgMSk7XHJcbiAgICAgICAgLy8gVXBsb2FkIHRoZSBpbWFnZSBpbnRvIHRoZSB0ZXh0dXJlLlxyXG4gICAgICAgIHRoaXMuX2dsLnRleEltYWdlMkQodGhpcy5fZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5fZ2wuUkdCQSwgdGhpcy5fZ2wuUkdCQSwgdGhpcy5fZ2wuVU5TSUdORURfQllURSwgaW1hZ2UpO1xyXG4gICAgICAgIC8vIGxvb2t1cCB1bmlmb3Jtc1xyXG4gICAgICAgIGNvbnN0IHJlc29sdXRpb25Mb2NhdGlvbiA9IHRoaXMuX2dsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLl9wcm9ncmFtLCAndV9yZXNvbHV0aW9uJyk7XHJcbiAgICAgICAgLy8gc2V0IHRoZSByZXNvbHV0aW9uXHJcbiAgICAgICAgdGhpcy5fZ2wudW5pZm9ybTJmKHJlc29sdXRpb25Mb2NhdGlvbiwgdGhpcy5faW50ZXJuYWxDYW52YXMud2lkdGgsIHRoaXMuX2ludGVybmFsQ2FudmFzLmhlaWdodCk7XHJcbiAgICAgICAgLy8gQ3JlYXRlIGEgYnVmZmVyIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIHJlY3RhbmdsZSBjb3JuZXJzLlxyXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uQnVmZmVyID0gdGhpcy5fZ2wuY3JlYXRlQnVmZmVyKCk7XHJcbiAgICAgICAgdGhpcy5fZ2wuYmluZEJ1ZmZlcih0aGlzLl9nbC5BUlJBWV9CVUZGRVIsIHBvc2l0aW9uQnVmZmVyKTtcclxuICAgICAgICB0aGlzLl9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShwb3NpdGlvbkxvY2F0aW9uKTtcclxuICAgICAgICB0aGlzLl9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uTG9jYXRpb24sIDIsIHRoaXMuX2dsLkZMT0FULCBmYWxzZSwgMCwgMCk7XHJcbiAgICAgICAgLy8gU2V0IGEgcmVjdGFuZ2xlIHRoZSBzYW1lIHNpemUgYXMgdGhlIGltYWdlLlxyXG4gICAgICAgIHRoaXMuX3NldFJlY3RhbmdsZSgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcclxuICAgICAgICAvLyBEcmF3IHRoZSByZWN0YW5nbGUuXHJcbiAgICAgICAgdGhpcy5fZ2wuZHJhd0FycmF5cyh0aGlzLl9nbC5UUklBTkdMRVMsIDAsIDYpO1xyXG4gICAgICAgIC8vIEdyYWIgdHJhbnNmb3JtZWQgaW1hZ2UgZnJvbSBpbnRlcm5hbCBjYW52YXNcclxuICAgICAgICBjb25zdCBwaXhlbERhdGEgPSBuZXcgVWludDhBcnJheShpbWFnZS53aWR0aCAqIGltYWdlLmhlaWdodCAqIDQpO1xyXG4gICAgICAgIHRoaXMuX2dsLnJlYWRQaXhlbHMoMCwgMCwgaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCwgdGhpcy5fZ2wuUkdCQSwgdGhpcy5fZ2wuVU5TSUdORURfQllURSwgcGl4ZWxEYXRhKTtcclxuICAgICAgICBpbWFnZS5kYXRhLnNldChwaXhlbERhdGEpO1xyXG4gICAgICAgIG91dC5wdXRJbWFnZURhdGEoaW1hZ2UsIDAsIDApO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRGVidWcvRGVidWdGbGFncy50c1xuXHJcbmNsYXNzIENvbG9yQmxpbmRGbGFncyB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUpIHtcclxuICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICB9XHJcbiAgICBjb3JyZWN0KGNvbG9yQmxpbmRuZXNzKSB7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnBvc3RQcm9jZXNzb3JzLnB1c2gobmV3IENvbG9yQmxpbmRDb3JyZWN0b3IodGhpcy5fZW5naW5lLCBmYWxzZSwgY29sb3JCbGluZG5lc3MpKTtcclxuICAgIH1cclxuICAgIHNpbXVsYXRlKGNvbG9yQmxpbmRuZXNzKSB7XHJcbiAgICAgICAgdGhpcy5fZW5naW5lLnBvc3RQcm9jZXNzb3JzLnB1c2gobmV3IENvbG9yQmxpbmRDb3JyZWN0b3IodGhpcy5fZW5naW5lLCB0cnVlLCBjb2xvckJsaW5kbmVzcykpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRGVidWcvRGVidWcudHNcblxyXG5cclxuLyoqXHJcbiAqIERlYnVnIHN0YXRpc3RpY3MgYW5kIGZsYWdzIGZvciBFeGNhbGlidXIuIElmIHBvbGxpbmcgdGhlc2UgdmFsdWVzLCBpdCB3b3VsZCBiZVxyXG4gKiBiZXN0IHRvIGRvIHNvIG9uIHRoZSBgcG9zdHVwZGF0ZWAgZXZlbnQgZm9yIFtbRW5naW5lXV0sIGFmdGVyIGFsbCB2YWx1ZXMgaGF2ZSBiZWVuXHJcbiAqIHVwZGF0ZWQgZHVyaW5nIGEgZnJhbWUuXHJcbiAqL1xyXG5jbGFzcyBEZWJ1ZyB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBQZXJmb3JtYW5jZSBzdGF0aXN0aWNzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5zdGF0cyA9IHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEN1cnJlbnQgZnJhbWUgc3RhdGlzdGljcy4gRW5naW5lIHJldXNlcyB0aGlzIGluc3RhbmNlLCB1c2UgW1tGcmFtZVN0YXRzLmNsb25lXV0gdG8gY29weSBmcmFtZSBzdGF0cy5cclxuICAgICAgICAgICAgICogQmVzdCBhY2Nlc3NlZCBvbiBbW3Bvc3RmcmFtZV1dIGV2ZW50LiBTZWUgW1tGcmFtZVN0YXRzXV1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGN1cnJGcmFtZTogbmV3IEZyYW1lU3RhdHMoKSxcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFByZXZpb3VzIGZyYW1lIHN0YXRpc3RpY3MuIEVuZ2luZSByZXVzZXMgdGhpcyBpbnN0YW5jZSwgdXNlIFtbRnJhbWVTdGF0cy5jbG9uZV1dIHRvIGNvcHkgZnJhbWUgc3RhdHMuXHJcbiAgICAgICAgICAgICAqIEJlc3QgYWNjZXNzZWQgb24gW1twcmVmcmFtZV1dIGV2ZW50LiBCZXN0IGluc3BlY3RlZCBvbiBlbmdpbmUgZXZlbnQgYHByZWZyYW1lYC4gU2VlIFtbRnJhbWVTdGF0c11dXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBwcmV2RnJhbWU6IG5ldyBGcmFtZVN0YXRzKClcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEZpbHRlciBkZWJ1ZyBjb250ZXh0IHRvIG5hbWVkIGVudGl0aWVzIG9yIGVudGl0eSBpZHNcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmZpbHRlciA9IHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFRvZ2dsZSBmaWx0ZXIgb24gb3Igb2ZmIChkZWZhdWx0IG9mZikgbXVzdCBiZSBvbiBmb3IgRGVidWdEcmF3IHRvIHVzZSBmaWx0ZXJzXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB1c2VGaWx0ZXI6IGZhbHNlLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUXVlcnkgZm9yIGVudGl0aWVzIGJ5IG5hbWUsIGlmIHRoZSBlbnRpdHkgbmFtZSBjb250YWlucyBgbmFtZVF1ZXJ5YCBpdCB3aWxsIGJlIGluY2x1ZGVkXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBuYW1lUXVlcnk6ICcnLFxyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogUXVlcnkgZm9yIEVudGl0eSBpZHMsIGlmIHRoZSBpZCBtYXRjaGVzIGl0IHdpbGwgYmUgaW5jbHVkZWRcclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGlkczogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEVudGl0eSBkZWJ1ZyBzZXR0aW5nc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZW50aXR5ID0ge1xyXG4gICAgICAgICAgICBzaG93QWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0lkOiB0cnVlLFxyXG4gICAgICAgICAgICBzaG93TmFtZTogZmFsc2VcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRyYW5zZm9ybSBjb21wb25lbnQgZGVidWcgc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHtcclxuICAgICAgICAgICAgc2hvd0FsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dQb3NpdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHBvc2l0aW9uQ29sb3I6IENvbG9yLlllbGxvdyxcclxuICAgICAgICAgICAgc2hvd1NjYWxlOiBmYWxzZSxcclxuICAgICAgICAgICAgc2NhbGVDb2xvcjogQ29sb3IuR3JlZW4sXHJcbiAgICAgICAgICAgIHNob3dSb3RhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIHJvdGF0aW9uQ29sb3I6IENvbG9yLkJsdWVcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdyYXBoaWNzIGNvbXBvbmVudCBkZWJ1ZyBzZXR0aW5nc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3MgPSB7XHJcbiAgICAgICAgICAgIHNob3dBbGw6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93Qm91bmRzOiB0cnVlLFxyXG4gICAgICAgICAgICBib3VuZHNDb2xvcjogQ29sb3IuWWVsbG93XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsaWRlciBjb21wb25lbnQgZGVidWcgc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNvbGxpZGVyID0ge1xyXG4gICAgICAgICAgICBzaG93QWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0JvdW5kczogdHJ1ZSxcclxuICAgICAgICAgICAgYm91bmRzQ29sb3I6IENvbG9yLkJsdWUsXHJcbiAgICAgICAgICAgIHNob3dPd25lcjogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dHZW9tZXRyeTogdHJ1ZSxcclxuICAgICAgICAgICAgZ2VvbWV0cnlDb2xvcjogQ29sb3IuR3JlZW5cclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFBoeXNpY3Mgc2ltdWxhdGlvbiBkZWJ1ZyBzZXR0aW5nc1xyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucGh5c2ljcyA9IHtcclxuICAgICAgICAgICAgc2hvd0FsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dCcm9hZHBoYXNlU3BhY2VQYXJ0aXRpb25EZWJ1ZzogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dDb2xsaXNpb25Ob3JtYWxzOiBmYWxzZSxcclxuICAgICAgICAgICAgY29sbGlzaW9uTm9ybWFsQ29sb3I6IENvbG9yLkN5YW4sXHJcbiAgICAgICAgICAgIHNob3dDb2xsaXNpb25Db250YWN0czogdHJ1ZSxcclxuICAgICAgICAgICAgY29sbGlzaW9uQ29udGFjdENvbG9yOiBDb2xvci5SZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIE1vdGlvbiBjb21wb25lbnQgZGVidWcgc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLm1vdGlvbiA9IHtcclxuICAgICAgICAgICAgc2hvd0FsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dWZWxvY2l0eTogZmFsc2UsXHJcbiAgICAgICAgICAgIHZlbG9jaXR5Q29sb3I6IENvbG9yLlllbGxvdyxcclxuICAgICAgICAgICAgc2hvd0FjY2VsZXJhdGlvbjogZmFsc2UsXHJcbiAgICAgICAgICAgIGFjY2VsZXJhdGlvbkNvbG9yOiBDb2xvci5SZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEJvZHkgY29tcG9uZW50IGRlYnVnIHNldHRpbmdzXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5ib2R5ID0ge1xyXG4gICAgICAgICAgICBzaG93QWxsOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0NvbGxpc2lvbkdyb3VwOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd0NvbGxpc2lvblR5cGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93U2xlZXBpbmc6IGZhbHNlLFxyXG4gICAgICAgICAgICBzaG93TW90aW9uOiBmYWxzZSxcclxuICAgICAgICAgICAgc2hvd01hc3M6IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYW1lcmEgZGVidWcgc2V0dGluZ3NcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmNhbWVyYSA9IHtcclxuICAgICAgICAgICAgc2hvd0FsbDogZmFsc2UsXHJcbiAgICAgICAgICAgIHNob3dGb2N1czogZmFsc2UsXHJcbiAgICAgICAgICAgIGZvY3VzQ29sb3I6IENvbG9yLlJlZCxcclxuICAgICAgICAgICAgc2hvd1pvb206IGZhbHNlXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl9lbmdpbmUgPSBlbmdpbmU7XHJcbiAgICAgICAgdGhpcy5jb2xvckJsaW5kTW9kZSA9IG5ldyBDb2xvckJsaW5kRmxhZ3ModGhpcy5fZW5naW5lKTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgYSBmcmFtZSdzIHN0YXRzLiBNZWFudCB0byBoYXZlIHZhbHVlcyBjb3BpZWQgdmlhIFtbRnJhbWVTdGF0cy5yZXNldF1dLCBhdm9pZFxyXG4gKiBjcmVhdGluZyBpbnN0YW5jZXMgb2YgdGhpcyBldmVyeSBmcmFtZS5cclxuICovXHJcbmNsYXNzIEZyYW1lU3RhdHMge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgdGhpcy5faWQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2RlbHRhID0gMDtcclxuICAgICAgICB0aGlzLl9mcHMgPSAwO1xyXG4gICAgICAgIHRoaXMuX2FjdG9yU3RhdHMgPSB7XHJcbiAgICAgICAgICAgIGFsaXZlOiAwLFxyXG4gICAgICAgICAgICBraWxsZWQ6IDAsXHJcbiAgICAgICAgICAgIHVpOiAwLFxyXG4gICAgICAgICAgICBnZXQgcmVtYWluaW5nKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWxpdmUgLSB0aGlzLmtpbGxlZDtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZ2V0IHRvdGFsKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtYWluaW5nICsgdGhpcy51aTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb25TdGF0cyA9IHtcclxuICAgICAgICAgICAgdXBkYXRlOiAwLFxyXG4gICAgICAgICAgICBkcmF3OiAwLFxyXG4gICAgICAgICAgICBnZXQgdG90YWwoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy51cGRhdGUgKyB0aGlzLmRyYXc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3BoeXNpY3NTdGF0cyA9IG5ldyBQaHlzaWNzU3RhdHMoKTtcclxuICAgICAgICB0aGlzLl9ncmFwaGljc1N0YXRzID0ge1xyXG4gICAgICAgICAgICBkcmF3Q2FsbHM6IDAsXHJcbiAgICAgICAgICAgIGRyYXduSW1hZ2VzOiAwXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogWmVybyBvdXQgdmFsdWVzIG9yIGNsb25lIG90aGVyIElGcmFtZVN0YXQgc3RhdHMuIEFsbG93cyBpbnN0YW5jZSByZXVzZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gW290aGVyU3RhdHNdIE9wdGlvbmFsIHN0YXRzIHRvIGNsb25lXHJcbiAgICAgKi9cclxuICAgIHJlc2V0KG90aGVyU3RhdHMpIHtcclxuICAgICAgICBpZiAob3RoZXJTdGF0cykge1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gb3RoZXJTdGF0cy5pZDtcclxuICAgICAgICAgICAgdGhpcy5kZWx0YSA9IG90aGVyU3RhdHMuZGVsdGE7XHJcbiAgICAgICAgICAgIHRoaXMuZnBzID0gb3RoZXJTdGF0cy5mcHM7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzLmFsaXZlID0gb3RoZXJTdGF0cy5hY3RvcnMuYWxpdmU7XHJcbiAgICAgICAgICAgIHRoaXMuYWN0b3JzLmtpbGxlZCA9IG90aGVyU3RhdHMuYWN0b3JzLmtpbGxlZDtcclxuICAgICAgICAgICAgdGhpcy5hY3RvcnMudWkgPSBvdGhlclN0YXRzLmFjdG9ycy51aTtcclxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbi51cGRhdGUgPSBvdGhlclN0YXRzLmR1cmF0aW9uLnVwZGF0ZTtcclxuICAgICAgICAgICAgdGhpcy5kdXJhdGlvbi5kcmF3ID0gb3RoZXJTdGF0cy5kdXJhdGlvbi5kcmF3O1xyXG4gICAgICAgICAgICB0aGlzLl9waHlzaWNzU3RhdHMucmVzZXQob3RoZXJTdGF0cy5waHlzaWNzKTtcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3Q2FsbHMgPSBvdGhlclN0YXRzLmdyYXBoaWNzLmRyYXdDYWxscztcclxuICAgICAgICAgICAgdGhpcy5ncmFwaGljcy5kcmF3bkltYWdlcyA9IG90aGVyU3RhdHMuZ3JhcGhpY3MuZHJhd25JbWFnZXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLmlkID0gdGhpcy5kZWx0YSA9IHRoaXMuZnBzID0gMDtcclxuICAgICAgICAgICAgdGhpcy5hY3RvcnMuYWxpdmUgPSB0aGlzLmFjdG9ycy5raWxsZWQgPSB0aGlzLmFjdG9ycy51aSA9IDA7XHJcbiAgICAgICAgICAgIHRoaXMuZHVyYXRpb24udXBkYXRlID0gdGhpcy5kdXJhdGlvbi5kcmF3ID0gMDtcclxuICAgICAgICAgICAgdGhpcy5fcGh5c2ljc1N0YXRzLnJlc2V0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3MuZHJhd25JbWFnZXMgPSB0aGlzLmdyYXBoaWNzLmRyYXdDYWxscyA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aWRlcyBhIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIGNvbnN0IGZzID0gbmV3IEZyYW1lU3RhdHMoKTtcclxuICAgICAgICBmcy5yZXNldCh0aGlzKTtcclxuICAgICAgICByZXR1cm4gZnM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgaWRcclxuICAgICAqL1xyXG4gICAgZ2V0IGlkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgZnJhbWUncyBpZFxyXG4gICAgICovXHJcbiAgICBzZXQgaWQodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9pZCA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGRlbHRhICh0aW1lIHNpbmNlIGxhc3QgZnJhbWUpXHJcbiAgICAgKi9cclxuICAgIGdldCBkZWx0YSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGVsdGE7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGZyYW1lJ3MgZGVsdGEgKHRpbWUgc2luY2UgbGFzdCBmcmFtZSkuIEludGVybmFsIHVzZSBvbmx5LlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIHNldCBkZWx0YSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2RlbHRhID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgZnJhbWVzLXBlci1zZWNvbmQgKEZQUylcclxuICAgICAqL1xyXG4gICAgZ2V0IGZwcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZnBzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBmcmFtZSdzIGZyYW1lcy1wZXItc2Vjb25kIChGUFMpLiBJbnRlcm5hbCB1c2Ugb25seS5cclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBzZXQgZnBzKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fZnBzID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGZyYW1lJ3MgYWN0b3Igc3RhdGlzdGljc1xyXG4gICAgICovXHJcbiAgICBnZXQgYWN0b3JzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RvclN0YXRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGR1cmF0aW9uIHN0YXRpc3RpY3NcclxuICAgICAqL1xyXG4gICAgZ2V0IGR1cmF0aW9uKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kdXJhdGlvblN0YXRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIHBoeXNpY3Mgc3RhdGlzdGljc1xyXG4gICAgICovXHJcbiAgICBnZXQgcGh5c2ljcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGh5c2ljc1N0YXRzO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBmcmFtZSdzIGdyYXBoaWNzIHN0YXRpc3RpY3NcclxuICAgICAqL1xyXG4gICAgZ2V0IGdyYXBoaWNzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9ncmFwaGljc1N0YXRzO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBoeXNpY3NTdGF0cyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9wYWlycyA9IDA7XHJcbiAgICAgICAgdGhpcy5fY29sbGlzaW9ucyA9IDA7XHJcbiAgICAgICAgdGhpcy5fY29udGFjdHMgPSBuZXcgTWFwKCk7XHJcbiAgICAgICAgdGhpcy5fZmFzdEJvZGllcyA9IDA7XHJcbiAgICAgICAgdGhpcy5fZmFzdEJvZHlDb2xsaXNpb25zID0gMDtcclxuICAgICAgICB0aGlzLl9icm9hZHBoYXNlID0gMDtcclxuICAgICAgICB0aGlzLl9uYXJyb3dwaGFzZSA9IDA7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFplcm8gb3V0IHZhbHVlcyBvciBjbG9uZSBvdGhlciBJUGh5c2ljc1N0YXRzIHN0YXRzLiBBbGxvd3MgaW5zdGFuY2UgcmV1c2UuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIFtvdGhlclN0YXRzXSBPcHRpb25hbCBzdGF0cyB0byBjbG9uZVxyXG4gICAgICovXHJcbiAgICByZXNldChvdGhlclN0YXRzKSB7XHJcbiAgICAgICAgaWYgKG90aGVyU3RhdHMpIHtcclxuICAgICAgICAgICAgdGhpcy5wYWlycyA9IG90aGVyU3RhdHMucGFpcnM7XHJcbiAgICAgICAgICAgIHRoaXMuY29sbGlzaW9ucyA9IG90aGVyU3RhdHMuY29sbGlzaW9ucztcclxuICAgICAgICAgICAgdGhpcy5jb250YWN0cyA9IG90aGVyU3RhdHMuY29udGFjdHM7XHJcbiAgICAgICAgICAgIHRoaXMuZmFzdEJvZGllcyA9IG90aGVyU3RhdHMuZmFzdEJvZGllcztcclxuICAgICAgICAgICAgdGhpcy5mYXN0Qm9keUNvbGxpc2lvbnMgPSBvdGhlclN0YXRzLmZhc3RCb2R5Q29sbGlzaW9ucztcclxuICAgICAgICAgICAgdGhpcy5icm9hZHBoYXNlID0gb3RoZXJTdGF0cy5icm9hZHBoYXNlO1xyXG4gICAgICAgICAgICB0aGlzLm5hcnJvd3BoYXNlID0gb3RoZXJTdGF0cy5uYXJyb3dwaGFzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucGFpcnMgPSB0aGlzLmNvbGxpc2lvbnMgPSB0aGlzLmZhc3RCb2RpZXMgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmZhc3RCb2R5Q29sbGlzaW9ucyA9IHRoaXMuYnJvYWRwaGFzZSA9IHRoaXMubmFycm93cGhhc2UgPSAwO1xyXG4gICAgICAgICAgICB0aGlzLmNvbnRhY3RzLmNsZWFyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBQcm92aWRlcyBhIGNsb25lIG9mIHRoaXMgaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIGNvbnN0IHBzID0gbmV3IFBoeXNpY3NTdGF0cygpO1xyXG4gICAgICAgIHBzLnJlc2V0KHRoaXMpO1xyXG4gICAgICAgIHJldHVybiBwcztcclxuICAgIH1cclxuICAgIGdldCBwYWlycygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fcGFpcnM7XHJcbiAgICB9XHJcbiAgICBzZXQgcGFpcnModmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9wYWlycyA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbGxpc2lvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxpc2lvbnM7XHJcbiAgICB9XHJcbiAgICBzZXQgY29sbGlzaW9ucyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2NvbGxpc2lvbnMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBjb250YWN0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFjdHM7XHJcbiAgICB9XHJcbiAgICBzZXQgY29udGFjdHMoY29udGFjdHMpIHtcclxuICAgICAgICB0aGlzLl9jb250YWN0cyA9IGNvbnRhY3RzO1xyXG4gICAgfVxyXG4gICAgZ2V0IGZhc3RCb2RpZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCb2RpZXM7XHJcbiAgICB9XHJcbiAgICBzZXQgZmFzdEJvZGllcyh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX2Zhc3RCb2RpZXMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBmYXN0Qm9keUNvbGxpc2lvbnMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Zhc3RCb2R5Q29sbGlzaW9ucztcclxuICAgIH1cclxuICAgIHNldCBmYXN0Qm9keUNvbGxpc2lvbnModmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9mYXN0Qm9keUNvbGxpc2lvbnMgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIGdldCBicm9hZHBoYXNlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9icm9hZHBoYXNlO1xyXG4gICAgfVxyXG4gICAgc2V0IGJyb2FkcGhhc2UodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9icm9hZHBoYXNlID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgbmFycm93cGhhc2UoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX25hcnJvd3BoYXNlO1xyXG4gICAgfVxyXG4gICAgc2V0IG5hcnJvd3BoYXNlKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbmFycm93cGhhc2UgPSB2YWx1ZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0lucHV0L0tleWJvYXJkLnRzXG5cclxuXHJcblxyXG4vKipcclxuICogRW51bSByZXByZXNlbnRpbmcgcGh5c2ljYWwgaW5wdXQga2V5IGNvZGVzXHJcbiAqL1xyXG52YXIgS2V5cztcclxuKGZ1bmN0aW9uIChLZXlzKSB7XHJcbiAgICAvLyBOVU1QQURcclxuICAgIEtleXNbXCJOdW0wXCJdID0gXCJOdW1wYWQwXCI7XHJcbiAgICBLZXlzW1wiTnVtMVwiXSA9IFwiTnVtcGFkMVwiO1xyXG4gICAgS2V5c1tcIk51bTJcIl0gPSBcIk51bXBhZDJcIjtcclxuICAgIEtleXNbXCJOdW0zXCJdID0gXCJOdW1wYWQzXCI7XHJcbiAgICBLZXlzW1wiTnVtNFwiXSA9IFwiTnVtcGFkNFwiO1xyXG4gICAgS2V5c1tcIk51bTVcIl0gPSBcIk51bXBhZDVcIjtcclxuICAgIEtleXNbXCJOdW02XCJdID0gXCJOdW1wYWQ2XCI7XHJcbiAgICBLZXlzW1wiTnVtN1wiXSA9IFwiTnVtcGFkN1wiO1xyXG4gICAgS2V5c1tcIk51bThcIl0gPSBcIk51bXBhZDhcIjtcclxuICAgIEtleXNbXCJOdW05XCJdID0gXCJOdW1wYWQ5XCI7XHJcbiAgICBLZXlzW1wiTnVtQWRkXCJdID0gXCJOdW1wYWRBZGRcIjtcclxuICAgIEtleXNbXCJOdW1TdWJ0cmFjdFwiXSA9IFwiTnVtcGFkU3VidHJhY3RcIjtcclxuICAgIEtleXNbXCJOdW1NdWx0aXBseVwiXSA9IFwiTnVtcGFkTXVsdGlwbHlcIjtcclxuICAgIEtleXNbXCJOdW1EaXZpZGVcIl0gPSBcIk51bXBhZERpdmlkZVwiO1xyXG4gICAgLy8gTnVtQ29tbWEgPSAnTnVtcGFkQ29tbWEnLCAvLyBub3QgeC1icm93c2VyXHJcbiAgICBLZXlzW1wiTnVtRGVjaW1hbFwiXSA9IFwiTnVtcGFkRGVjaW1hbFwiO1xyXG4gICAgS2V5c1tcIk51bXBhZDBcIl0gPSBcIk51bXBhZDBcIjtcclxuICAgIEtleXNbXCJOdW1wYWQxXCJdID0gXCJOdW1wYWQxXCI7XHJcbiAgICBLZXlzW1wiTnVtcGFkMlwiXSA9IFwiTnVtcGFkMlwiO1xyXG4gICAgS2V5c1tcIk51bXBhZDNcIl0gPSBcIk51bXBhZDNcIjtcclxuICAgIEtleXNbXCJOdW1wYWQ0XCJdID0gXCJOdW1wYWQ0XCI7XHJcbiAgICBLZXlzW1wiTnVtcGFkNVwiXSA9IFwiTnVtcGFkNVwiO1xyXG4gICAgS2V5c1tcIk51bXBhZDZcIl0gPSBcIk51bXBhZDZcIjtcclxuICAgIEtleXNbXCJOdW1wYWQ3XCJdID0gXCJOdW1wYWQ3XCI7XHJcbiAgICBLZXlzW1wiTnVtcGFkOFwiXSA9IFwiTnVtcGFkOFwiO1xyXG4gICAgS2V5c1tcIk51bXBhZDlcIl0gPSBcIk51bXBhZDlcIjtcclxuICAgIEtleXNbXCJOdW1wYWRBZGRcIl0gPSBcIk51bXBhZEFkZFwiO1xyXG4gICAgS2V5c1tcIk51bXBhZFN1YnRyYWN0XCJdID0gXCJOdW1wYWRTdWJ0cmFjdFwiO1xyXG4gICAgS2V5c1tcIk51bXBhZE11bHRpcGx5XCJdID0gXCJOdW1wYWRNdWx0aXBseVwiO1xyXG4gICAgS2V5c1tcIk51bXBhZERpdmlkZVwiXSA9IFwiTnVtcGFkRGl2aWRlXCI7XHJcbiAgICAvLyBOdW1wYWRDb21tYSA9ICdOdW1wYWRDb21tYScsIC8vIG5vdCB4LWJyb3dzZXJcclxuICAgIEtleXNbXCJOdW1wYWREZWNpbWFsXCJdID0gXCJOdW1wYWREZWNpbWFsXCI7XHJcbiAgICAvLyBNT0RJRklFUlNcclxuICAgIEtleXNbXCJOdW1Mb2NrXCJdID0gXCJOdW1Mb2NrXCI7XHJcbiAgICBLZXlzW1wiU2hpZnRMZWZ0XCJdID0gXCJTaGlmdExlZnRcIjtcclxuICAgIEtleXNbXCJTaGlmdFJpZ2h0XCJdID0gXCJTaGlmdFJpZ2h0XCI7XHJcbiAgICBLZXlzW1wiQWx0TGVmdFwiXSA9IFwiQWx0TGVmdFwiO1xyXG4gICAgS2V5c1tcIkFsdFJpZ2h0XCJdID0gXCJBbHRSaWdodFwiO1xyXG4gICAgLy8gTlVNQkVSU1xyXG4gICAgS2V5c1tcIktleTBcIl0gPSBcIkRpZ2l0MFwiO1xyXG4gICAgS2V5c1tcIktleTFcIl0gPSBcIkRpZ2l0MVwiO1xyXG4gICAgS2V5c1tcIktleTJcIl0gPSBcIkRpZ2l0MlwiO1xyXG4gICAgS2V5c1tcIktleTNcIl0gPSBcIkRpZ2l0M1wiO1xyXG4gICAgS2V5c1tcIktleTRcIl0gPSBcIkRpZ2l0NFwiO1xyXG4gICAgS2V5c1tcIktleTVcIl0gPSBcIkRpZ2l0NVwiO1xyXG4gICAgS2V5c1tcIktleTZcIl0gPSBcIkRpZ2l0NlwiO1xyXG4gICAgS2V5c1tcIktleTdcIl0gPSBcIkRpZ2l0N1wiO1xyXG4gICAgS2V5c1tcIktleThcIl0gPSBcIkRpZ2l0OFwiO1xyXG4gICAgS2V5c1tcIktleTlcIl0gPSBcIkRpZ2l0OVwiO1xyXG4gICAgS2V5c1tcIkRpZ2l0MFwiXSA9IFwiRGlnaXQwXCI7XHJcbiAgICBLZXlzW1wiRGlnaXQxXCJdID0gXCJEaWdpdDFcIjtcclxuICAgIEtleXNbXCJEaWdpdDJcIl0gPSBcIkRpZ2l0MlwiO1xyXG4gICAgS2V5c1tcIkRpZ2l0M1wiXSA9IFwiRGlnaXQzXCI7XHJcbiAgICBLZXlzW1wiRGlnaXQ0XCJdID0gXCJEaWdpdDRcIjtcclxuICAgIEtleXNbXCJEaWdpdDVcIl0gPSBcIkRpZ2l0NVwiO1xyXG4gICAgS2V5c1tcIkRpZ2l0NlwiXSA9IFwiRGlnaXQ2XCI7XHJcbiAgICBLZXlzW1wiRGlnaXQ3XCJdID0gXCJEaWdpdDdcIjtcclxuICAgIEtleXNbXCJEaWdpdDhcIl0gPSBcIkRpZ2l0OFwiO1xyXG4gICAgS2V5c1tcIkRpZ2l0OVwiXSA9IFwiRGlnaXQ5XCI7XHJcbiAgICAvLyBMRVRURVJTXHJcbiAgICBLZXlzW1wiQVwiXSA9IFwiS2V5QVwiO1xyXG4gICAgS2V5c1tcIkJcIl0gPSBcIktleUJcIjtcclxuICAgIEtleXNbXCJDXCJdID0gXCJLZXlDXCI7XHJcbiAgICBLZXlzW1wiRFwiXSA9IFwiS2V5RFwiO1xyXG4gICAgS2V5c1tcIkVcIl0gPSBcIktleUVcIjtcclxuICAgIEtleXNbXCJGXCJdID0gXCJLZXlGXCI7XHJcbiAgICBLZXlzW1wiR1wiXSA9IFwiS2V5R1wiO1xyXG4gICAgS2V5c1tcIkhcIl0gPSBcIktleUhcIjtcclxuICAgIEtleXNbXCJJXCJdID0gXCJLZXlJXCI7XHJcbiAgICBLZXlzW1wiSlwiXSA9IFwiS2V5SlwiO1xyXG4gICAgS2V5c1tcIktcIl0gPSBcIktleUtcIjtcclxuICAgIEtleXNbXCJMXCJdID0gXCJLZXlMXCI7XHJcbiAgICBLZXlzW1wiTVwiXSA9IFwiS2V5TVwiO1xyXG4gICAgS2V5c1tcIk5cIl0gPSBcIktleU5cIjtcclxuICAgIEtleXNbXCJPXCJdID0gXCJLZXlPXCI7XHJcbiAgICBLZXlzW1wiUFwiXSA9IFwiS2V5UFwiO1xyXG4gICAgS2V5c1tcIlFcIl0gPSBcIktleVFcIjtcclxuICAgIEtleXNbXCJSXCJdID0gXCJLZXlSXCI7XHJcbiAgICBLZXlzW1wiU1wiXSA9IFwiS2V5U1wiO1xyXG4gICAgS2V5c1tcIlRcIl0gPSBcIktleVRcIjtcclxuICAgIEtleXNbXCJVXCJdID0gXCJLZXlVXCI7XHJcbiAgICBLZXlzW1wiVlwiXSA9IFwiS2V5VlwiO1xyXG4gICAgS2V5c1tcIldcIl0gPSBcIktleVdcIjtcclxuICAgIEtleXNbXCJYXCJdID0gXCJLZXlYXCI7XHJcbiAgICBLZXlzW1wiWVwiXSA9IFwiS2V5WVwiO1xyXG4gICAgS2V5c1tcIlpcIl0gPSBcIktleVpcIjtcclxuICAgIEtleXNbXCJLZXlBXCJdID0gXCJLZXlBXCI7XHJcbiAgICBLZXlzW1wiS2V5QlwiXSA9IFwiS2V5QlwiO1xyXG4gICAgS2V5c1tcIktleUNcIl0gPSBcIktleUNcIjtcclxuICAgIEtleXNbXCJLZXlEXCJdID0gXCJLZXlEXCI7XHJcbiAgICBLZXlzW1wiS2V5RVwiXSA9IFwiS2V5RVwiO1xyXG4gICAgS2V5c1tcIktleUZcIl0gPSBcIktleUZcIjtcclxuICAgIEtleXNbXCJLZXlHXCJdID0gXCJLZXlHXCI7XHJcbiAgICBLZXlzW1wiS2V5SFwiXSA9IFwiS2V5SFwiO1xyXG4gICAgS2V5c1tcIktleUlcIl0gPSBcIktleUlcIjtcclxuICAgIEtleXNbXCJLZXlKXCJdID0gXCJLZXlKXCI7XHJcbiAgICBLZXlzW1wiS2V5S1wiXSA9IFwiS2V5S1wiO1xyXG4gICAgS2V5c1tcIktleUxcIl0gPSBcIktleUxcIjtcclxuICAgIEtleXNbXCJLZXlNXCJdID0gXCJLZXlNXCI7XHJcbiAgICBLZXlzW1wiS2V5TlwiXSA9IFwiS2V5TlwiO1xyXG4gICAgS2V5c1tcIktleU9cIl0gPSBcIktleU9cIjtcclxuICAgIEtleXNbXCJLZXlQXCJdID0gXCJLZXlQXCI7XHJcbiAgICBLZXlzW1wiS2V5UVwiXSA9IFwiS2V5UVwiO1xyXG4gICAgS2V5c1tcIktleVJcIl0gPSBcIktleVJcIjtcclxuICAgIEtleXNbXCJLZXlTXCJdID0gXCJLZXlTXCI7XHJcbiAgICBLZXlzW1wiS2V5VFwiXSA9IFwiS2V5VFwiO1xyXG4gICAgS2V5c1tcIktleVVcIl0gPSBcIktleVVcIjtcclxuICAgIEtleXNbXCJLZXlWXCJdID0gXCJLZXlWXCI7XHJcbiAgICBLZXlzW1wiS2V5V1wiXSA9IFwiS2V5V1wiO1xyXG4gICAgS2V5c1tcIktleVhcIl0gPSBcIktleVhcIjtcclxuICAgIEtleXNbXCJLZXlZXCJdID0gXCJLZXlZXCI7XHJcbiAgICBLZXlzW1wiS2V5WlwiXSA9IFwiS2V5WlwiO1xyXG4gICAgLy8gU1lNQk9MU1xyXG4gICAgS2V5c1tcIlNlbWljb2xvblwiXSA9IFwiU2VtaWNvbG9uXCI7XHJcbiAgICBLZXlzW1wiUXVvdGVcIl0gPSBcIlF1b3RlXCI7XHJcbiAgICBLZXlzW1wiQ29tbWFcIl0gPSBcIkNvbW1hXCI7XHJcbiAgICBLZXlzW1wiTWludXNcIl0gPSBcIk1pbnVzXCI7XHJcbiAgICBLZXlzW1wiUGVyaW9kXCJdID0gXCJQZXJpb2RcIjtcclxuICAgIEtleXNbXCJTbGFzaFwiXSA9IFwiU2xhc2hcIjtcclxuICAgIEtleXNbXCJFcXVhbFwiXSA9IFwiRXF1YWxcIjtcclxuICAgIEtleXNbXCJCcmFja2V0TGVmdFwiXSA9IFwiQnJhY2tldExlZnRcIjtcclxuICAgIEtleXNbXCJCYWNrc2xhc2hcIl0gPSBcIkJhY2tzbGFzaFwiO1xyXG4gICAgS2V5c1tcIkJyYWNrZXRSaWdodFwiXSA9IFwiQnJhY2tldFJpZ2h0XCI7XHJcbiAgICBLZXlzW1wiQmFja3F1b3RlXCJdID0gXCJCYWNrcXVvdGVcIjtcclxuICAgIC8vIERJUkVDVElPTlNcclxuICAgIEtleXNbXCJVcFwiXSA9IFwiQXJyb3dVcFwiO1xyXG4gICAgS2V5c1tcIkRvd25cIl0gPSBcIkFycm93RG93blwiO1xyXG4gICAgS2V5c1tcIkxlZnRcIl0gPSBcIkFycm93TGVmdFwiO1xyXG4gICAgS2V5c1tcIlJpZ2h0XCJdID0gXCJBcnJvd1JpZ2h0XCI7XHJcbiAgICBLZXlzW1wiQXJyb3dVcFwiXSA9IFwiQXJyb3dVcFwiO1xyXG4gICAgS2V5c1tcIkFycm93RG93blwiXSA9IFwiQXJyb3dEb3duXCI7XHJcbiAgICBLZXlzW1wiQXJyb3dMZWZ0XCJdID0gXCJBcnJvd0xlZnRcIjtcclxuICAgIEtleXNbXCJBcnJvd1JpZ2h0XCJdID0gXCJBcnJvd1JpZ2h0XCI7XHJcbiAgICAvLyBPVEhFUlxyXG4gICAgS2V5c1tcIlNwYWNlXCJdID0gXCJTcGFjZVwiO1xyXG4gICAgS2V5c1tcIkVzY1wiXSA9IFwiRXNjYXBlXCI7XHJcbiAgICBLZXlzW1wiRXNjYXBlXCJdID0gXCJFc2NhcGVcIjtcclxufSkoS2V5cyB8fCAoS2V5cyA9IHt9KSk7XHJcbi8qKlxyXG4gKiBFdmVudCB0aHJvd24gb24gYSBnYW1lIG9iamVjdCBmb3IgYSBrZXkgZXZlbnRcclxuICovXHJcbmNsYXNzIEtleUV2ZW50IGV4dGVuZHMgR2FtZUV2ZW50IHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGtleSAgVGhlIGtleSByZXNwb25zaWJsZSBmb3IgdGhyb3dpbmcgdGhlIGV2ZW50XHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIGtleSdzIHR5cGVkIHZhbHVlIHRoZSBicm93c2VyIGRldGVjdGVkXHJcbiAgICAgKiBAcGFyYW0gb3JpZ2luYWxFdmVudCBUaGUgb3JpZ2luYWwga2V5Ym9hcmQgZXZlbnQgdGhhdCBFeGNhbGlidXIgaGFuZGxlZFxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlLCBvcmlnaW5hbEV2ZW50KSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmtleSA9IGtleTtcclxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogUHJvdmlkZXMga2V5Ym9hcmQgc3VwcG9ydCBmb3IgRXhjYWxpYnVyLlxyXG4gKi9cclxuY2xhc3MgS2V5Ym9hcmQgZXh0ZW5kcyBDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2tleXMgPSBbXTtcclxuICAgICAgICB0aGlzLl9rZXlzVXAgPSBbXTtcclxuICAgICAgICB0aGlzLl9rZXlzRG93biA9IFtdO1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZSBLZXlib2FyZCBldmVudCBsaXN0ZW5lcnNcclxuICAgICAqL1xyXG4gICAgaW5pdChnbG9iYWwpIHtcclxuICAgICAgICBpZiAoIWdsb2JhbCkge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gVHJ5IGFuZCBsaXN0ZW4gdG8gZXZlbnRzIG9uIHRvcCB3aW5kb3cgZnJhbWUgaWYgd2l0aGluIGFuIGlmcmFtZS5cclxuICAgICAgICAgICAgICAgIC8vXHJcbiAgICAgICAgICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2V4Y2FsaWJ1cmpzL0V4Y2FsaWJ1ci9pc3N1ZXMvMTI5NFxyXG4gICAgICAgICAgICAgICAgLy9cclxuICAgICAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyLCB3aGljaCB0cmlnZ2VycyBhIERPTUV4Y2VwdGlvbiBvblxyXG4gICAgICAgICAgICAgICAgLy8gY3Jvc3Mtb3JpZ2luIGlmcmFtZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vb3AgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIHdpbmRvdy50b3AuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIG5vb3ApO1xyXG4gICAgICAgICAgICAgICAgd2luZG93LnRvcC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgbm9vcCk7XHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgYmUgdGhlIHNhbWUgYXMgd2luZG93IGlmIG5vdCBlbWJlZGRlZCB3aXRoaW4gYW4gaWZyYW1lXHJcbiAgICAgICAgICAgICAgICBnbG9iYWwgPSB3aW5kb3cudG9wO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xyXG4gICAgICAgICAgICAgICAgLy8gZmFsbGJhY2sgdG8gY3VycmVudCBmcmFtZVxyXG4gICAgICAgICAgICAgICAgZ2xvYmFsID0gd2luZG93O1xyXG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignRmFpbGVkIHRvIGJpbmQgdG8ga2V5Ym9hcmQgZXZlbnRzIHRvIHRvcCBmcmFtZS4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgJ0lmIHlvdSBhcmUgdHJ5aW5nIHRvIGVtYmVkIEV4Y2FsaWJ1ciBpbiBhIGNyb3NzLW9yaWdpbiBpZnJhbWUsIGtleWJvYXJkIGV2ZW50cyB3aWxsIG5vdCBmaXJlLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgKCkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9rZXlzLmxlbmd0aCA9IDA7IC8vIGVtcHRpZXMgYXJyYXkgZWZmaWNpZW50bHlcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBrZXkgdXAgaXMgb24gd2luZG93IGJlY2F1c2UgY2FudmFzIGNhbm5vdCBoYXZlIGZvY3VzXHJcbiAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgKGV2KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBldi5jb2RlO1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLl9rZXlzLmluZGV4T2YoY29kZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleXMuc3BsaWNlKGtleSwgMSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2tleXNVcC5wdXNoKGNvZGUpO1xyXG4gICAgICAgICAgICBjb25zdCBrZXlFdmVudCA9IG5ldyBLZXlFdmVudChjb2RlLCBldi5rZXksIGV2KTtcclxuICAgICAgICAgICAgLy8gYWxpYXMgdGhlIG9sZCBhcGksIHdlIG1heSB3YW50IHRvIGRlcHJlY2F0ZSB0aGlzIGluIHRoZSBmdXR1cmVcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgndXAnLCBrZXlFdmVudCk7XHJcbiAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3JlbGVhc2UnLCBrZXlFdmVudCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8ga2V5IGRvd24gaXMgb24gd2luZG93IGJlY2F1c2UgY2FudmFzIGNhbm5vdCBoYXZlIGZvY3VzXHJcbiAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCAoZXYpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY29kZSA9IGV2LmNvZGU7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9rZXlzLmluZGV4T2YoY29kZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLnB1c2goY29kZSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzRG93bi5wdXNoKGNvZGUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3Qga2V5RXZlbnQgPSBuZXcgS2V5RXZlbnQoY29kZSwgZXYua2V5LCBldik7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdkb3duJywga2V5RXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgncHJlc3MnLCBrZXlFdmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHVwZGF0ZSgpIHtcclxuICAgICAgICAvLyBSZXNldCBrZXlzRG93biBhbmQga2V5c1VwIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZVxyXG4gICAgICAgIHRoaXMuX2tleXNEb3duLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fa2V5c1VwLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgLy8gRW1pdCBzeW50aGV0aWMgXCJob2xkXCIgZXZlbnRcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2tleXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnaG9sZCcsIG5ldyBLZXlFdmVudCh0aGlzLl9rZXlzW2ldKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIGxpc3Qgb2Yga2V5cyBiZWluZyBwcmVzc2VkIGRvd25cclxuICAgICAqL1xyXG4gICAgZ2V0S2V5cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgYSBjZXJ0YWluIGtleSB3YXMganVzdCBwcmVzc2VkIHRoaXMgZnJhbWUuIFRoaXMgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIHRoZSB1cGRhdGUgZnJhbWUuXHJcbiAgICAgKiBAcGFyYW0ga2V5IFRlc3Qgd2hldGhlciBhIGtleSB3YXMganVzdCBwcmVzc2VkXHJcbiAgICAgKi9cclxuICAgIHdhc1ByZXNzZWQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2tleXNEb3duLmluZGV4T2Yoa2V5KSA+IC0xO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUZXN0cyBpZiBhIGNlcnRhaW4ga2V5IGlzIGhlbGQgZG93bi4gVGhpcyBpcyBwZXJzaXN0ZWQgYmV0d2VlbiBmcmFtZXMuXHJcbiAgICAgKiBAcGFyYW0ga2V5ICBUZXN0IHdoZXRoZXIgYSBrZXkgaXMgaGVsZCBkb3duXHJcbiAgICAgKi9cclxuICAgIGlzSGVsZChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5cy5pbmRleE9mKGtleSkgPiAtMTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgaWYgYSBjZXJ0YWluIGtleSB3YXMganVzdCByZWxlYXNlZCB0aGlzIGZyYW1lLiBUaGlzIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiB0aGUgdXBkYXRlIGZyYW1lLlxyXG4gICAgICogQHBhcmFtIGtleSAgVGVzdCB3aGV0aGVyIGEga2V5IHdhcyBqdXN0IHJlbGVhc2VkXHJcbiAgICAgKi9cclxuICAgIHdhc1JlbGVhc2VkKGtleSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlzVXAuaW5kZXhPZihrZXkpID4gLTE7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnB1dC9Qb2ludGVyLnRzXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSB0eXBlIG9mIHBvaW50ZXIgZm9yIGEgW1tQb2ludGVyRXZlbnRdXS5cclxuICovXHJcbnZhciBQb2ludGVyVHlwZTtcclxuKGZ1bmN0aW9uIChQb2ludGVyVHlwZSkge1xyXG4gICAgUG9pbnRlclR5cGVbXCJUb3VjaFwiXSA9IFwiVG91Y2hcIjtcclxuICAgIFBvaW50ZXJUeXBlW1wiTW91c2VcIl0gPSBcIk1vdXNlXCI7XHJcbiAgICBQb2ludGVyVHlwZVtcIlBlblwiXSA9IFwiUGVuXCI7XHJcbiAgICBQb2ludGVyVHlwZVtcIlVua25vd25cIl0gPSBcIlVua25vd25cIjtcclxufSkoUG9pbnRlclR5cGUgfHwgKFBvaW50ZXJUeXBlID0ge30pKTtcclxuLyoqXHJcbiAqIERldGVybWluZXMgdGhlIHNjb3BlIG9mIGhhbmRsaW5nIG1vdXNlL3RvdWNoIGV2ZW50cy4gU2VlIFtbUG9pbnRlcnNdXSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cclxuICovXHJcbnZhciBQb2ludGVyU2NvcGU7XHJcbihmdW5jdGlvbiAoUG9pbnRlclNjb3BlKSB7XHJcbiAgICAvKipcclxuICAgICAqIEhhbmRsZSBldmVudHMgb24gdGhlIGBjYW52YXNgIGVsZW1lbnQgb25seS4gRXZlbnRzIG9yaWdpbmF0aW5nIG91dHNpZGUgdGhlXHJcbiAgICAgKiBgY2FudmFzYCB3aWxsIG5vdCBiZSBoYW5kbGVkLlxyXG4gICAgICovXHJcbiAgICBQb2ludGVyU2NvcGVbXCJDYW52YXNcIl0gPSBcIkNhbnZhc1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGVzIGV2ZW50cyBvbiB0aGUgZW50aXJlIGRvY3VtZW50LiBBbGwgZXZlbnRzIHdpbGwgYmUgaGFuZGxlZCBieSBFeGNhbGlidXIuXHJcbiAgICAgKi9cclxuICAgIFBvaW50ZXJTY29wZVtcIkRvY3VtZW50XCJdID0gXCJEb2N1bWVudFwiO1xyXG59KShQb2ludGVyU2NvcGUgfHwgKFBvaW50ZXJTY29wZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBDYXB0dXJlcyBhbmQgZGlzcGF0Y2hlcyBQb2ludGVyRXZlbnRzXHJcbiAqL1xyXG5jbGFzcyBQb2ludGVyIGV4dGVuZHMgQ2xhc3Mge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLmlkID0gUG9pbnRlci5fTUFYX0lEKys7XHJcbiAgICAgICAgdGhpcy5faXNEb3duID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fd2FzRG93biA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2FjdG9yc1VuZGVyUG9pbnRlciA9IHsgbGVuZ3RoOiAwIH07XHJcbiAgICAgICAgdGhpcy5fYWN0b3JzID0gW107XHJcbiAgICAgICAgdGhpcy5fYWN0b3JzTGFzdEZyYW1lID0gW107XHJcbiAgICAgICAgdGhpcy5fYWN0b3JzTm9Mb25nZXJVbmRlclBvaW50ZXIgPSBbXTtcclxuICAgICAgICB0aGlzLl9hY3RvclNvcnRpbmdGY24gPSAoYSwgYikgPT4ge1xyXG4gICAgICAgICAgICBpZiAoYS56ID09PSBiLnopIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBiLmlkIC0gYS5pZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gYi56IC0gYS56O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGxhc3QgcG9zaXRpb24gb24gdGhlIGRvY3VtZW50IHRoaXMgcG9pbnRlciB3YXMgYXQuIENhbiBiZSBgbnVsbGAgaWYgcG9pbnRlciB3YXMgbmV2ZXIgYWN0aXZlLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubGFzdFBhZ2VQb3MgPSBudWxsO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRoZSBsYXN0IHBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gdGhpcyBwb2ludGVyIHdhcyBhdC4gQ2FuIGJlIGBudWxsYCBpZiBwb2ludGVyIHdhcyBuZXZlciBhY3RpdmUuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sYXN0U2NyZWVuUG9zID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgbGFzdCBwb3NpdGlvbiBpbiB0aGUgZ2FtZSB3b3JsZCBjb29yZGluYXRlcyB0aGlzIHBvaW50ZXIgd2FzIGF0LiBDYW4gYmUgYG51bGxgIGlmIHBvaW50ZXIgd2FzIG5ldmVyIGFjdGl2ZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmxhc3RXb3JsZFBvcyA9IG51bGw7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmV0dXJucyB0aGUgY3VycmVudGx5IGRyYWdnaW5nIHRhcmdldCBvciBudWxsIGlmIGl0IGlzbid0IGV4aXN0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5kcmFnVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICB0aGlzLm9uKCdtb3ZlJywgdGhpcy5fb25Qb2ludGVyTW92ZSk7XHJcbiAgICAgICAgdGhpcy5vbignZG93bicsIHRoaXMuX29uUG9pbnRlckRvd24pO1xyXG4gICAgICAgIHRoaXMub24oJ3VwJywgdGhpcy5fb25Qb2ludGVyVXApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBQb2ludGVyIGlzIGN1cnJlbnRseSBkcmFnZ2luZy5cclxuICAgICAqL1xyXG4gICAgZ2V0IGlzRHJhZ2dpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRG93bjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogV2hldGhlciB0aGUgUG9pbnRlciBqdXN0IHN0YXJ0ZWQgZHJhZ2dpbmcuXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0RyYWdTdGFydCgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuX3dhc0Rvd24gJiYgdGhpcy5faXNEb3duO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGV0aGVyIHRoZSBQb2ludGVyIGp1c3QgZW5kZWQgZHJhZ2dpbmcuXHJcbiAgICAgKi9cclxuICAgIGdldCBpc0RyYWdFbmQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhc0Rvd24gJiYgIXRoaXMuX2lzRG93bjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHBvaW50ZXIgaGFzIGFueSBhY3RvcnMgdW5kZXJcclxuICAgICAqL1xyXG4gICAgZ2V0IGhhc0FjdG9yc1VuZGVyUG9pbnRlcigpIHtcclxuICAgICAgICByZXR1cm4gISF0aGlzLl9hY3RvcnNVbmRlclBvaW50ZXIubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vbihldmVudCwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBvbmNlKGV2ZW50LCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub25jZShldmVudCwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBvZmYoZXZlbnQsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vZmYoZXZlbnQsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIHN0YXRlIG9mIGN1cnJlbnQgcG9pbnRlciwgbWVhbnQgdG8gYmUgY2FsbGVkIGEgdGhlIGVuZCBvZiBmcmFtZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3dhc0Rvd24gJiYgIXRoaXMuX2lzRG93bikge1xyXG4gICAgICAgICAgICB0aGlzLl93YXNEb3duID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl93YXNEb3duICYmIHRoaXMuX2lzRG93bikge1xyXG4gICAgICAgICAgICB0aGlzLl93YXNEb3duID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fYWN0b3JzTGFzdEZyYW1lID0gWy4uLnRoaXMuX2FjdG9yc107XHJcbiAgICAgICAgdGhpcy5fYWN0b3JzTm9Mb25nZXJVbmRlclBvaW50ZXIgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkcyBhbiBBY3RvciB0byBhY3RvcnNVbmRlclBvaW50ZXIgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGFjdG9yIEFuIEFjdG9yIHRvIGJlIGFkZGVkO1xyXG4gICAgICovXHJcbiAgICBhZGRBY3RvclVuZGVyUG9pbnRlcihhY3Rvcikge1xyXG4gICAgICAgIGlmICghdGhpcy5pc0FjdG9yQWxpdmVVbmRlclBvaW50ZXIoYWN0b3IpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FjdG9yc1VuZGVyUG9pbnRlclthY3Rvci5pZF0gPSBhY3RvcjtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3JzVW5kZXJQb2ludGVyLmxlbmd0aCArPSAxO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvcnMucHVzaChhY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFjdG9ycyBhcmUgcHJvY2Vzc2VkIGluIHotb3JkZXIgaGlnaGVzdCB6IHRvIGxvd2VzdFxyXG4gICAgICAgIC8vIHRpZXMgYXJlIGJyb2tlbiBieSBpZCBoaWdoZXN0IGlkIChuZXdlc3QpIHRvIGxvd2VzdCBpZCAob2xkZXN0KVxyXG4gICAgICAgIHRoaXMuX2FjdG9ycy5zb3J0KHRoaXMuX2FjdG9yU29ydGluZ0Zjbik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYW4gQWN0b3IgZnJvbSBhY3RvcnNVbmRlclBvaW50ZXIgb2JqZWN0LlxyXG4gICAgICogQHBhcmFtIGFjdG9yIEFuIEFjdG9yIHRvIGJlIHJlbW92ZWQ7XHJcbiAgICAgKi9cclxuICAgIHJlbW92ZUFjdG9yVW5kZXJQb2ludGVyKGFjdG9yKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RvckFsaXZlVW5kZXJQb2ludGVyKGFjdG9yKSkge1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYWN0b3JzVW5kZXJQb2ludGVyW2FjdG9yLmlkXTtcclxuICAgICAgICAgICAgdGhpcy5fYWN0b3JzVW5kZXJQb2ludGVyLmxlbmd0aCAtPSAxO1xyXG4gICAgICAgICAgICByZW1vdmVJdGVtRnJvbUFycmF5KGFjdG9yLCB0aGlzLl9hY3RvcnMpO1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RvcnNOb0xvbmdlclVuZGVyUG9pbnRlci5wdXNoKGFjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYWxsIGFjdG9ycyB1bmRlciB0aGlzIHBvaW50ZXIgdGhpcyBmcmFtZVxyXG4gICAgICovXHJcbiAgICBnZXRBY3RvcnNVbmRlclBvaW50ZXIoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdG9ycztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBhbGwgYWN0b3JzIHRoYXQgYXJlIG5vIGxvbmdlciB1bmRlciB0aGUgcG9pbnRlciB0aGlzIGZyYW1lXHJcbiAgICAgKi9cclxuICAgIGdldEFjdG9yc1VuZGVyUG9pbnRlckxhc3RGcmFtZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYWN0b3JzTGFzdEZyYW1lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGFsbCBhY3RvcnMgcmVsZXZhbnQgZm9yIGV2ZW50cyB0byBwb2ludGVyIHRoaXMgZnJhbWVcclxuICAgICAqL1xyXG4gICAgZ2V0QWN0b3JzRm9yRXZlbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9hY3RvcnNcclxuICAgICAgICAgICAgLmNvbmNhdCh0aGlzLl9hY3RvcnNMYXN0RnJhbWUpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGFjdG9yLCBpLCBzZWxmKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmluZGV4T2YoYWN0b3IpID09PSBpOyAvLyBkZS1kdXBcclxuICAgICAgICB9KVxyXG4gICAgICAgICAgICAuc29ydCh0aGlzLl9hY3RvclNvcnRpbmdGY24pOyAvLyBzb3J0IGJ5IHpcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hlY2tzIGlmIFBvaW50ZXIgbG9jYXRpb24gaGFzIGEgc3BlY2lmaWMgQWN0b3IgYm91bmRzIGNvbnRhaW5lZCB1bmRlcm5lYXRoLlxyXG4gICAgICogQHBhcmFtIGFjdG9yIEFuIEFjdG9yIGZvciBjaGVjaztcclxuICAgICAqL1xyXG4gICAgY2hlY2tBY3RvclVuZGVyUG9pbnRlcihhY3Rvcikge1xyXG4gICAgICAgIGlmICh0aGlzLmxhc3RXb3JsZFBvcykge1xyXG4gICAgICAgICAgICByZXR1cm4gYWN0b3IuY29udGFpbnModGhpcy5sYXN0V29ybGRQb3MueCwgdGhpcy5sYXN0V29ybGRQb3MueSwgIWlzU2NyZWVuRWxlbWVudChhY3RvcikpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiBhbiBhY3RvciB3YXMgdW5kZXIgdGhlIHBvaW50ZXIgbGFzdCBmcmFtZVxyXG4gICAgICogQHBhcmFtIGFjdG9yXHJcbiAgICAgKi9cclxuICAgIHdhc0FjdG9yVW5kZXJQb2ludGVyKGFjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FjdG9yc0xhc3RGcmFtZS5pbmRleE9mKGFjdG9yKSA+IC0xO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgUG9pbnRlciBoYXMgYSBzcGVjaWZpYyBBY3RvciBpbiBBY3RvcnNVbmRlclBvaW50ZXIgbGlzdC5cclxuICAgICAqIEBwYXJhbSBhY3RvciBBbiBBY3RvciBmb3IgY2hlY2s7XHJcbiAgICAgKi9cclxuICAgIGlzQWN0b3JBbGl2ZVVuZGVyUG9pbnRlcihhY3Rvcikge1xyXG4gICAgICAgIHJldHVybiAhISghYWN0b3IuaXNLaWxsZWQoKSAmJiBhY3Rvci5zY2VuZSAmJiB0aGlzLl9hY3RvcnNVbmRlclBvaW50ZXIuaGFzT3duUHJvcGVydHkoYWN0b3IuaWQudG9TdHJpbmcoKSkpO1xyXG4gICAgfVxyXG4gICAgX29uUG9pbnRlck1vdmUoZXYpIHtcclxuICAgICAgICB0aGlzLmxhc3RQYWdlUG9zID0gbmV3IFZlY3Rvcihldi5wYWdlUG9zLngsIGV2LnBhZ2VQb3MueSk7XHJcbiAgICAgICAgdGhpcy5sYXN0U2NyZWVuUG9zID0gbmV3IFZlY3Rvcihldi5zY3JlZW5Qb3MueCwgZXYuc2NyZWVuUG9zLnkpO1xyXG4gICAgICAgIHRoaXMubGFzdFdvcmxkUG9zID0gbmV3IFZlY3Rvcihldi53b3JsZFBvcy54LCBldi53b3JsZFBvcy55KTtcclxuICAgIH1cclxuICAgIF9vblBvaW50ZXJEb3duKGV2KSB7XHJcbiAgICAgICAgdGhpcy5sYXN0UGFnZVBvcyA9IG5ldyBWZWN0b3IoZXYucGFnZVBvcy54LCBldi5wYWdlUG9zLnkpO1xyXG4gICAgICAgIHRoaXMubGFzdFNjcmVlblBvcyA9IG5ldyBWZWN0b3IoZXYuc2NyZWVuUG9zLngsIGV2LnNjcmVlblBvcy55KTtcclxuICAgICAgICB0aGlzLmxhc3RXb3JsZFBvcyA9IG5ldyBWZWN0b3IoZXYud29ybGRQb3MueCwgZXYud29ybGRQb3MueSk7XHJcbiAgICAgICAgdGhpcy5faXNEb3duID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIF9vblBvaW50ZXJVcChfZXYpIHtcclxuICAgICAgICB0aGlzLl9pc0Rvd24gPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmRyYWdUYXJnZXQgPSBudWxsO1xyXG4gICAgfVxyXG59XHJcblBvaW50ZXIuX01BWF9JRCA9IDA7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vSW5wdXQvUG9pbnRlckV2ZW50cy50c1xuXHJcbi8qKlxyXG4gKiBOYXRpdmUgYnJvd3NlciBidXR0b24gZW51bWVyYXRpb25cclxuICovXHJcbnZhciBOYXRpdmVQb2ludGVyQnV0dG9uO1xyXG4oZnVuY3Rpb24gKE5hdGl2ZVBvaW50ZXJCdXR0b24pIHtcclxuICAgIE5hdGl2ZVBvaW50ZXJCdXR0b25bTmF0aXZlUG9pbnRlckJ1dHRvbltcIk5vQnV0dG9uXCJdID0gLTFdID0gXCJOb0J1dHRvblwiO1xyXG4gICAgTmF0aXZlUG9pbnRlckJ1dHRvbltOYXRpdmVQb2ludGVyQnV0dG9uW1wiTGVmdFwiXSA9IDBdID0gXCJMZWZ0XCI7XHJcbiAgICBOYXRpdmVQb2ludGVyQnV0dG9uW05hdGl2ZVBvaW50ZXJCdXR0b25bXCJNaWRkbGVcIl0gPSAxXSA9IFwiTWlkZGxlXCI7XHJcbiAgICBOYXRpdmVQb2ludGVyQnV0dG9uW05hdGl2ZVBvaW50ZXJCdXR0b25bXCJSaWdodFwiXSA9IDJdID0gXCJSaWdodFwiO1xyXG4gICAgTmF0aXZlUG9pbnRlckJ1dHRvbltOYXRpdmVQb2ludGVyQnV0dG9uW1wiVW5rbm93blwiXSA9IDNdID0gXCJVbmtub3duXCI7XHJcbn0pKE5hdGl2ZVBvaW50ZXJCdXR0b24gfHwgKE5hdGl2ZVBvaW50ZXJCdXR0b24gPSB7fSkpO1xyXG4vKipcclxuICogVGhlIG1vdXNlIGJ1dHRvbiBiZWluZyBwcmVzc2VkLlxyXG4gKi9cclxudmFyIFBvaW50ZXJCdXR0b247XHJcbihmdW5jdGlvbiAoUG9pbnRlckJ1dHRvbikge1xyXG4gICAgUG9pbnRlckJ1dHRvbltcIkxlZnRcIl0gPSBcIkxlZnRcIjtcclxuICAgIFBvaW50ZXJCdXR0b25bXCJNaWRkbGVcIl0gPSBcIk1pZGRsZVwiO1xyXG4gICAgUG9pbnRlckJ1dHRvbltcIlJpZ2h0XCJdID0gXCJSaWdodFwiO1xyXG4gICAgUG9pbnRlckJ1dHRvbltcIlVua25vd25cIl0gPSBcIlVua25vd25cIjtcclxuICAgIFBvaW50ZXJCdXR0b25bXCJOb0J1dHRvblwiXSA9IFwiTm9CdXR0b25cIjtcclxufSkoUG9pbnRlckJ1dHRvbiB8fCAoUG9pbnRlckJ1dHRvbiA9IHt9KSk7XHJcbnZhciBXaGVlbERlbHRhTW9kZTtcclxuKGZ1bmN0aW9uIChXaGVlbERlbHRhTW9kZSkge1xyXG4gICAgV2hlZWxEZWx0YU1vZGVbXCJQaXhlbFwiXSA9IFwiUGl4ZWxcIjtcclxuICAgIFdoZWVsRGVsdGFNb2RlW1wiTGluZVwiXSA9IFwiTGluZVwiO1xyXG4gICAgV2hlZWxEZWx0YU1vZGVbXCJQYWdlXCJdID0gXCJQYWdlXCI7XHJcbn0pKFdoZWVsRGVsdGFNb2RlIHx8IChXaGVlbERlbHRhTW9kZSA9IHt9KSk7XHJcbi8qKlxyXG4gKiBQb2ludGVyIGV2ZW50c1xyXG4gKlxyXG4gKiBSZXByZXNlbnRzIGEgbW91c2UsIHRvdWNoLCBvciBzdHlsdXMgZXZlbnQuIFNlZSBbW1BvaW50ZXJzXV0gZm9yIG1vcmUgaW5mb3JtYXRpb24gb25cclxuICogaGFuZGxpbmcgcG9pbnRlciBpbnB1dC5cclxuICpcclxuICogRm9yIG1vdXNlLWJhc2VkIGV2ZW50cywgeW91IGNhbiBpbnNwZWN0IFtbUG9pbnRlckV2ZW50LmJ1dHRvbl1dIHRvIHNlZSB3aGF0IGJ1dHRvbiB3YXMgcHJlc3NlZC5cclxuICovXHJcbmNsYXNzIFBvaW50ZXJFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBjb29yZGluYXRlcyAgICAgICAgIFRoZSBbW0dsb2JhbENvb3JkaW5hdGVzXV0gb2YgdGhlIGV2ZW50XHJcbiAgICAgKiBAcGFyYW0gcG9pbnRlciAgICAgICAgICAgICBUaGUgW1tQb2ludGVyXV0gb2YgdGhlIGV2ZW50XHJcbiAgICAgKiBAcGFyYW0gaW5kZXggICAgICAgICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHBvaW50ZXIgKHplcm8tYmFzZWQpXHJcbiAgICAgKiBAcGFyYW0gcG9pbnRlclR5cGUgICAgICAgICBUaGUgdHlwZSBvZiBwb2ludGVyXHJcbiAgICAgKiBAcGFyYW0gYnV0dG9uICAgICAgICAgICAgICBUaGUgYnV0dG9uIHByZXNzZWQgKGlmIFtbUG9pbnRlclR5cGUuTW91c2VdXSlcclxuICAgICAqIEBwYXJhbSBldiAgICAgICAgICAgICAgICAgIFRoZSByYXcgRE9NIGV2ZW50IGJlaW5nIGhhbmRsZWRcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3IoY29vcmRpbmF0ZXMsIHBvaW50ZXIsIGluZGV4LCBwb2ludGVyVHlwZSwgYnV0dG9uLCBldikge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5jb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzO1xyXG4gICAgICAgIHRoaXMucG9pbnRlciA9IHBvaW50ZXI7XHJcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xyXG4gICAgICAgIHRoaXMucG9pbnRlclR5cGUgPSBwb2ludGVyVHlwZTtcclxuICAgICAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcclxuICAgICAgICB0aGlzLmV2ID0gZXY7XHJcbiAgICAgICAgdGhpcy5fY2FuY2VsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGdldCBuYW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xyXG4gICAgfVxyXG4gICAgLyoqIFRoZSB3b3JsZCBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnQuICovXHJcbiAgICBnZXQgd29ybGRQb3MoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29vcmRpbmF0ZXMud29ybGRQb3MuY2xvbmUoKTtcclxuICAgIH1cclxuICAgIC8qKiBUaGUgcGFnZSBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnQuICovXHJcbiAgICBnZXQgcGFnZVBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlcy5wYWdlUG9zLmNsb25lKCk7XHJcbiAgICB9XHJcbiAgICAvKiogVGhlIHNjcmVlbiBjb29yZGluYXRlcyBvZiB0aGUgZXZlbnQuICovXHJcbiAgICBnZXQgc2NyZWVuUG9zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvb3JkaW5hdGVzLnNjcmVlblBvcy5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHBvcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb29yZGluYXRlcy53b3JsZFBvcy5jbG9uZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDYW5jZWxzIHBvaW50ZXIgZXZlbnQgcHJvcG9nYXRpb24sIGV2ZW50IHdpbGwgbm90IGJlIHRyYW5zbWl0dGVkIHRvIGFueSBvdGhlciBhY3RvcnNcclxuICAgICAqL1xyXG4gICAgY2FuY2VsKCkge1xyXG4gICAgICAgIHRoaXMuX2NhbmNlbGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIElmIHRoZSBldmVudCBpcyBjYW5jZWxlZCBpdCB3aWxsIG5vIGxvbmdlciBiZSB0cmFuc21pdHRlZCB0byBhbnkgb3RoZXIgYWN0b3JzXHJcbiAgICAgKi9cclxuICAgIGlzQ2FuY2VsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbmNlbGVkO1xyXG4gICAgfVxyXG4gICAgcHJvcGFnYXRlKGFjdG9yKSB7XHJcbiAgICAgICAgdGhpcy5kb0FjdGlvbihhY3Rvcik7XHJcbiAgICAgICAgaWYgKHRoaXMuYnViYmxlcyAmJiAhdGhpcy5pc0NhbmNlbGVkKCkgJiYgYWN0b3IucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcGFnYXRlKGFjdG9yLnBhcmVudCk7IC8vIFRPRE8gbm90IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFjdGlvbiwgdGhhdCBjYWxscyB3aGVuIGV2ZW50IGhhcHBlbnNcclxuICAgICAqL1xyXG4gICAgZG9BY3Rpb24oYWN0b3IpIHtcclxuICAgICAgICBpZiAoYWN0b3IpIHtcclxuICAgICAgICAgICAgdGhpcy5fb25BY3Rpb25TdGFydChhY3Rvcik7XHJcbiAgICAgICAgICAgIGFjdG9yLmVtaXQodGhpcy5fbmFtZSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX29uQWN0aW9uRW5kKGFjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25BY3Rpb25TdGFydChfYWN0b3IpIHtcclxuICAgICAgICAvLyB0byBiZSByZXdyaXR0ZW5cclxuICAgIH1cclxuICAgIF9vbkFjdGlvbkVuZChfYWN0b3IpIHtcclxuICAgICAgICAvLyB0byBiZSByZXdyaXR0ZW5cclxuICAgIH1cclxufVxyXG5jbGFzcyBQb2ludGVyRXZlbnRGYWN0b3J5IHtcclxuICAgIGNvbnN0cnVjdG9yKF9wb2ludGVyRXZlbnRUeXBlKSB7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlckV2ZW50VHlwZSA9IF9wb2ludGVyRXZlbnRUeXBlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgc3BlY2lmaWMgUG9pbnRlckV2ZW50XHJcbiAgICAgKi9cclxuICAgIGNyZWF0ZShjb29yZGluYXRlcywgcG9pbnRlciwgaW5kZXgsIHBvaW50ZXJUeXBlLCBidXR0b24sIGV2KSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLl9wb2ludGVyRXZlbnRUeXBlKGNvb3JkaW5hdGVzLCBwb2ludGVyLCBpbmRleCwgcG9pbnRlclR5cGUsIGJ1dHRvbiwgZXYpO1xyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBvaW50ZXJEcmFnRXZlbnQgZXh0ZW5kcyBQb2ludGVyRXZlbnQge1xyXG59XHJcbmNsYXNzIFBvaW50ZXJVcEV2ZW50IGV4dGVuZHMgUG9pbnRlckV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9ICdwb2ludGVydXAnO1xyXG4gICAgfVxyXG4gICAgX29uQWN0aW9uRW5kKGFjdG9yKSB7XHJcbiAgICAgICAgY29uc3QgcG9pbnRlciA9IHRoaXMucG9pbnRlcjtcclxuICAgICAgICBpZiAocG9pbnRlci5pc0RyYWdFbmQgJiYgYWN0b3IuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZURyYWdFdmVudHMpIHtcclxuICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3BvaW50ZXJkcmFnZW5kJywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBvaW50ZXJEb3duRXZlbnQgZXh0ZW5kcyBQb2ludGVyRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gJ3BvaW50ZXJkb3duJztcclxuICAgIH1cclxuICAgIF9vbkFjdGlvbkVuZChhY3Rvcikge1xyXG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXIuaXNEcmFnU3RhcnQgJiYgYWN0b3IuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZURyYWdFdmVudHMpIHtcclxuICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3BvaW50ZXJkcmFnc3RhcnQnLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUG9pbnRlck1vdmVFdmVudCBleHRlbmRzIFBvaW50ZXJFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuX25hbWUgPSAncG9pbnRlcm1vdmUnO1xyXG4gICAgICAgIC8vIHByaXZhdGUgX29uQWN0b3JFbnRlcihhY3RvcjogQWN0b3IpIHtcclxuICAgICAgICAvLyAgIGNvbnN0IHBlID0gY3JlYXRlUG9pbnRlckV2ZW50QnlOYW1lKCdlbnRlcicsIHRoaXMuY29vcmRpbmF0ZXMsIHRoaXMucG9pbnRlciwgdGhpcy5pbmRleCwgdGhpcy5wb2ludGVyVHlwZSwgdGhpcy5idXR0b24sIHRoaXMuZXYpO1xyXG4gICAgICAgIC8vICAgcGUucHJvcGFnYXRlKGFjdG9yKTtcclxuICAgICAgICAvLyAgIHRoaXMucG9pbnRlci5hZGRBY3RvclVuZGVyUG9pbnRlcihhY3Rvcik7XHJcbiAgICAgICAgLy8gICBpZiAodGhpcy5wb2ludGVyLmlzRHJhZ2dpbmcpIHtcclxuICAgICAgICAvLyAgICAgdGhpcy5wb2ludGVyLmRyYWdUYXJnZXQgPSBhY3RvcjtcclxuICAgICAgICAvLyAgIH1cclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gcHJpdmF0ZSBfb25BY3RvckxlYXZlKGFjdG9yOiBBY3Rvcikge1xyXG4gICAgICAgIC8vICAgY29uc3QgcGUgPSBjcmVhdGVQb2ludGVyRXZlbnRCeU5hbWUoJ2xlYXZlJywgdGhpcy5jb29yZGluYXRlcywgdGhpcy5wb2ludGVyLCB0aGlzLmluZGV4LCB0aGlzLnBvaW50ZXJUeXBlLCB0aGlzLmJ1dHRvbiwgdGhpcy5ldik7XHJcbiAgICAgICAgLy8gICBwZS5wcm9wYWdhdGUoYWN0b3IpO1xyXG4gICAgICAgIC8vICAgdGhpcy5wb2ludGVyLnJlbW92ZUFjdG9yVW5kZXJQb2ludGVyKGFjdG9yKTtcclxuICAgICAgICAvLyB9XHJcbiAgICB9XHJcbiAgICBwcm9wYWdhdGUoYWN0b3IpIHtcclxuICAgICAgICAvLyBJZiB0aGUgYWN0b3Igd2FzIHVuZGVyIHRoZSBwb2ludGVyIGxhc3QgZnJhbWUsIGJ1dCBub3QgdGhpcyBvbmUgaXQgbGVmdFxyXG4gICAgICAgIC8vIGlmICh0aGlzLnBvaW50ZXIud2FzQWN0b3JVbmRlclBvaW50ZXIoYWN0b3IpICYmICF0aGlzLnBvaW50ZXIuaXNBY3RvclVuZGVyUG9pbnRlcihhY3RvcikpIHtcclxuICAgICAgICAvLyAgIHRoaXMuX29uQWN0b3JMZWF2ZShhY3Rvcik7XHJcbiAgICAgICAgLy8gICByZXR1cm47XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXIuaXNBY3RvckFsaXZlVW5kZXJQb2ludGVyKGFjdG9yKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRvQWN0aW9uKGFjdG9yKTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuYnViYmxlcyAmJiAhdGhpcy5pc0NhbmNlbGVkKCkgJiYgYWN0b3IucGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BhZ2F0ZShhY3Rvci5wYXJlbnQpOyAvLyBUT0RPIG5vdCB0cnVlXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25BY3Rpb25TdGFydChhY3Rvcikge1xyXG4gICAgICAgIGlmICghYWN0b3IuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZU1vdmVFdmVudHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJbiB0aGUgY2FzZSB0aGlzIGlzIG5ld1xyXG4gICAgICAgIC8vIGlmICh0aGlzLnBvaW50ZXIuY2hlY2tBY3RvclVuZGVyUG9pbnRlcihhY3RvcikgJiYgIXRoaXMucG9pbnRlci53YXNBY3RvclVuZGVyUG9pbnRlcihhY3RvcikpIHtcclxuICAgICAgICAvLyAgIHRoaXMuX29uQWN0b3JFbnRlcihhY3Rvcik7XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXIuaXNEcmFnZ2luZyAmJiBhY3Rvci5jYXB0dXJlUG9pbnRlci5jYXB0dXJlRHJhZ0V2ZW50cykge1xyXG4gICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIuZW1pdCgncG9pbnRlcmRyYWdtb3ZlJywgdGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIFBvaW50ZXJFbnRlckV2ZW50IGV4dGVuZHMgUG9pbnRlckV2ZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5fbmFtZSA9ICdwb2ludGVyZW50ZXInO1xyXG4gICAgfVxyXG4gICAgX29uQWN0aW9uU3RhcnQoYWN0b3IpIHtcclxuICAgICAgICBpZiAoIWFjdG9yLmNhcHR1cmVQb2ludGVyLmNhcHR1cmVNb3ZlRXZlbnRzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfb25BY3Rpb25FbmQoYWN0b3IpIHtcclxuICAgICAgICBjb25zdCBwb2ludGVyID0gdGhpcy5wb2ludGVyO1xyXG4gICAgICAgIGlmIChwb2ludGVyLmlzRHJhZ2dpbmcgJiYgYWN0b3IuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZURyYWdFdmVudHMpIHtcclxuICAgICAgICAgICAgYWN0b3IuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3BvaW50ZXJkcmFnZW50ZXInLCB0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgUG9pbnRlckxlYXZlRXZlbnQgZXh0ZW5kcyBQb2ludGVyRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gJ3BvaW50ZXJsZWF2ZSc7XHJcbiAgICB9XHJcbiAgICBfb25BY3Rpb25TdGFydChhY3Rvcikge1xyXG4gICAgICAgIGlmICghYWN0b3IuY2FwdHVyZVBvaW50ZXIuY2FwdHVyZU1vdmVFdmVudHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9vbkFjdGlvbkVuZChhY3Rvcikge1xyXG4gICAgICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLnBvaW50ZXI7XHJcbiAgICAgICAgaWYgKHBvaW50ZXIuaXNEcmFnZ2luZyAmJiBhY3Rvci5jYXB0dXJlUG9pbnRlci5jYXB0dXJlRHJhZ0V2ZW50cykge1xyXG4gICAgICAgICAgICBhY3Rvci5ldmVudERpc3BhdGNoZXIuZW1pdCgncG9pbnRlcmRyYWdsZWF2ZScsIHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5jbGFzcyBQb2ludGVyQ2FuY2VsRXZlbnQgZXh0ZW5kcyBQb2ludGVyRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLl9uYW1lID0gJ3BvaW50ZXJjYW5jZWwnO1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBXaGVlbCBFdmVudHNcclxuICpcclxuICogUmVwcmVzZW50cyBhIG1vdXNlIHdoZWVsIGV2ZW50LiBTZWUgW1tQb2ludGVyc11dIGZvciBtb3JlIGluZm9ybWF0aW9uIG9uXHJcbiAqIGhhbmRsaW5nIHBvaW50IGlucHV0LlxyXG4gKi9cclxuY2xhc3MgV2hlZWxFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB4ICAgICAgICAgICAgVGhlIGB4YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gd29ybGQgY29vcmRpbmF0ZXMpXHJcbiAgICAgKiBAcGFyYW0geSAgICAgICAgICAgIFRoZSBgeWAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIHdvcmxkIGNvb3JkaW5hdGVzKVxyXG4gICAgICogQHBhcmFtIHBhZ2VYICAgICAgICBUaGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIGV2ZW50IChpbiBkb2N1bWVudCBjb29yZGluYXRlcylcclxuICAgICAqIEBwYXJhbSBwYWdlWSAgICAgICAgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gZG9jdW1lbnQgY29vcmRpbmF0ZXMpXHJcbiAgICAgKiBAcGFyYW0gc2NyZWVuWCAgICAgIFRoZSBgeGAgY29vcmRpbmF0ZSBvZiB0aGUgZXZlbnQgKGluIHNjcmVlbiBjb29yZGluYXRlcylcclxuICAgICAqIEBwYXJhbSBzY3JlZW5ZICAgICAgVGhlIGB5YCBjb29yZGluYXRlIG9mIHRoZSBldmVudCAoaW4gc2NyZWVuIGNvb3JkaW5hdGVzKVxyXG4gICAgICogQHBhcmFtIGluZGV4ICAgICAgICBUaGUgaW5kZXggb2YgdGhlIHBvaW50ZXIgKHplcm8tYmFzZWQpXHJcbiAgICAgKiBAcGFyYW0gZGVsdGFYICAgICAgIFRoZSB0eXBlIG9mIHBvaW50ZXJcclxuICAgICAqIEBwYXJhbSBkZWx0YVkgICAgICAgVGhlIHR5cGUgb2YgcG9pbnRlclxyXG4gICAgICogQHBhcmFtIGRlbHRhWiAgICAgICBUaGUgdHlwZSBvZiBwb2ludGVyXHJcbiAgICAgKiBAcGFyYW0gZGVsdGFNb2RlICAgIFRoZSB0eXBlIG9mIG1vdmVtZW50IFtbV2hlZWxEZWx0YU1vZGVdXVxyXG4gICAgICogQHBhcmFtIGV2ICAgICAgICAgICBUaGUgcmF3IERPTSBldmVudCBiZWluZyBoYW5kbGVkXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHgsIHksIHBhZ2VYLCBwYWdlWSwgc2NyZWVuWCwgc2NyZWVuWSwgaW5kZXgsIGRlbHRhWCwgZGVsdGFZLCBkZWx0YVosIGRlbHRhTW9kZSwgZXYpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMueCA9IHg7XHJcbiAgICAgICAgdGhpcy55ID0geTtcclxuICAgICAgICB0aGlzLnBhZ2VYID0gcGFnZVg7XHJcbiAgICAgICAgdGhpcy5wYWdlWSA9IHBhZ2VZO1xyXG4gICAgICAgIHRoaXMuc2NyZWVuWCA9IHNjcmVlblg7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5ZID0gc2NyZWVuWTtcclxuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XHJcbiAgICAgICAgdGhpcy5kZWx0YVggPSBkZWx0YVg7XHJcbiAgICAgICAgdGhpcy5kZWx0YVkgPSBkZWx0YVk7XHJcbiAgICAgICAgdGhpcy5kZWx0YVogPSBkZWx0YVo7XHJcbiAgICAgICAgdGhpcy5kZWx0YU1vZGUgPSBkZWx0YU1vZGU7XHJcbiAgICAgICAgdGhpcy5ldiA9IGV2O1xyXG4gICAgICAgIHRoaXMuX2lzQ2FuY2VsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VscyBwb2ludGVyIGV2ZW50IHByb3BvZ2F0aW9uLCBldmVudCB3aWxsIG5vdCBiZSB0cmFuc21pdHRlZCB0byBhbnkgb3RoZXIgYWN0b3JzXHJcbiAgICAgKi9cclxuICAgIGNhbmNlbCgpIHtcclxuICAgICAgICB0aGlzLl9pc0NhbmNlbGVkID0gdHJ1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIElmIHRoZSBldmVudCBpcyBjYW5jZWxlZCBpdCB3aWxsIG5vIGxvbmdlciBiZSB0cmFuc21pdHRlZCB0byBhbnkgb3RoZXIgYWN0b3JzXHJcbiAgICAgKi9cclxuICAgIGlzQ2FuY2VsZWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2FuY2VsZWQ7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVQb2ludGVyRXZlbnRCeU5hbWUoZXZlbnROYW1lLCBjb29yZGluYXRlcywgcG9pbnRlciwgaW5kZXgsIHBvaW50ZXJUeXBlLCBidXR0b24sIGV2KSB7XHJcbiAgICBsZXQgZmFjdG9yeTtcclxuICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgY2FzZSAndXAnOlxyXG4gICAgICAgICAgICBmYWN0b3J5ID0gbmV3IFBvaW50ZXJFdmVudEZhY3RvcnkoUG9pbnRlclVwRXZlbnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdkb3duJzpcclxuICAgICAgICAgICAgZmFjdG9yeSA9IG5ldyBQb2ludGVyRXZlbnRGYWN0b3J5KFBvaW50ZXJEb3duRXZlbnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdtb3ZlJzpcclxuICAgICAgICAgICAgZmFjdG9yeSA9IG5ldyBQb2ludGVyRXZlbnRGYWN0b3J5KFBvaW50ZXJNb3ZlRXZlbnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdjYW5jZWwnOlxyXG4gICAgICAgICAgICBmYWN0b3J5ID0gbmV3IFBvaW50ZXJFdmVudEZhY3RvcnkoUG9pbnRlckNhbmNlbEV2ZW50KTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnZW50ZXInOlxyXG4gICAgICAgICAgICBmYWN0b3J5ID0gbmV3IFBvaW50ZXJFdmVudEZhY3RvcnkoUG9pbnRlckVudGVyRXZlbnQpO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICdsZWF2ZSc6XHJcbiAgICAgICAgICAgIGZhY3RvcnkgPSBuZXcgUG9pbnRlckV2ZW50RmFjdG9yeShQb2ludGVyTGVhdmVFdmVudCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhY3RvcnkuY3JlYXRlKGNvb3JkaW5hdGVzLCBwb2ludGVyLCBpbmRleCwgcG9pbnRlclR5cGUsIGJ1dHRvbiwgZXYpO1xyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTWF0aC9nbG9iYWwtY29vcmRpbmF0ZXMudHNcblxyXG5jbGFzcyBHbG9iYWxDb29yZGluYXRlcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3b3JsZFBvcywgcGFnZVBvcywgc2NyZWVuUG9zKSB7XHJcbiAgICAgICAgdGhpcy53b3JsZFBvcyA9IHdvcmxkUG9zO1xyXG4gICAgICAgIHRoaXMucGFnZVBvcyA9IHBhZ2VQb3M7XHJcbiAgICAgICAgdGhpcy5zY3JlZW5Qb3MgPSBzY3JlZW5Qb3M7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbVBhZ2VQb3NpdGlvbih4T3JQb3MsIHlPckVuZ2luZSwgZW5naW5lT3JVbmRlZmluZWQpIHtcclxuICAgICAgICBsZXQgcGFnZVg7XHJcbiAgICAgICAgbGV0IHBhZ2VZO1xyXG4gICAgICAgIGxldCBwYWdlUG9zO1xyXG4gICAgICAgIGxldCBlbmdpbmU7XHJcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcclxuICAgICAgICAgICAgcGFnZVggPSB4T3JQb3M7XHJcbiAgICAgICAgICAgIHBhZ2VZID0geU9yRW5naW5lO1xyXG4gICAgICAgICAgICBwYWdlUG9zID0gbmV3IFZlY3RvcihwYWdlWCwgcGFnZVkpO1xyXG4gICAgICAgICAgICBlbmdpbmUgPSBlbmdpbmVPclVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHBhZ2VQb3MgPSB4T3JQb3M7XHJcbiAgICAgICAgICAgIHBhZ2VYID0gcGFnZVBvcy54O1xyXG4gICAgICAgICAgICBwYWdlWSA9IHBhZ2VQb3MueTtcclxuICAgICAgICAgICAgZW5naW5lID0geU9yRW5naW5lO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBzY3JlZW5Qb3MgPSBlbmdpbmUuc2NyZWVuLnBhZ2VUb1NjcmVlbkNvb3JkaW5hdGVzKHBhZ2VQb3MpO1xyXG4gICAgICAgIGNvbnN0IHdvcmxkUG9zID0gZW5naW5lLnNjcmVlbi5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMoc2NyZWVuUG9zKTtcclxuICAgICAgICByZXR1cm4gbmV3IEdsb2JhbENvb3JkaW5hdGVzKHdvcmxkUG9zLCBwYWdlUG9zLCBzY3JlZW5Qb3MpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vSW5wdXQvUG9pbnRlcnMudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIEEgY29uc3RhbnQgdXNlZCB0byBub3JtYWxpemUgd2hlZWwgZXZlbnRzIGFjcm9zcyBkaWZmZXJlbnQgYnJvd3NlcnNcclxuICpcclxuICogVGhpcyBub3JtYWxpemF0aW9uIGZhY3RvciBpcyBwdWxsZWQgZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9FdmVudHMvd2hlZWwjTGlzdGVuaW5nX3RvX3RoaXNfZXZlbnRfYWNyb3NzX2Jyb3dzZXJcclxuICovXHJcbmNvbnN0IFNjcm9sbFdoZWVsTm9ybWFsaXphdGlvbkZhY3RvciA9IC0xIC8gNDA7XHJcbi8qKlxyXG4gKiBIYW5kbGVzIHBvaW50ZXIgZXZlbnRzIChtb3VzZSwgdG91Y2gsIHN0eWx1cywgZXRjLikgYW5kIG5vcm1hbGl6ZXMgdG9cclxuICogW1czQyBQb2ludGVyIEV2ZW50c10oaHR0cDovL3d3dy53My5vcmcvVFIvcG9pbnRlcmV2ZW50cy8pLlxyXG4gKi9cclxuY2xhc3MgUG9pbnRlcnMgZXh0ZW5kcyBDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJEb3duID0gW107XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlclVwID0gW107XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlck1vdmUgPSBbXTtcclxuICAgICAgICB0aGlzLl9wb2ludGVyQ2FuY2VsID0gW107XHJcbiAgICAgICAgdGhpcy5fd2hlZWwgPSBbXTtcclxuICAgICAgICB0aGlzLl9wb2ludGVycyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FjdGl2ZVBvaW50ZXJzID0gW107XHJcbiAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJzLnB1c2gobmV3IFBvaW50ZXIoKSk7XHJcbiAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnMgPSBbLTFdO1xyXG4gICAgICAgIHRoaXMucHJpbWFyeSA9IHRoaXMuX3BvaW50ZXJzWzBdO1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5pdGlhbGl6ZXMgcG9pbnRlciBldmVudCBsaXN0ZW5lcnNcclxuICAgICAqL1xyXG4gICAgaW5pdCh0YXJnZXQpIHtcclxuICAgICAgICB0YXJnZXQgPSB0YXJnZXQgfHwgdGhpcy5fZW5naW5lLmNhbnZhcztcclxuICAgICAgICAvLyBUb3VjaCBFdmVudHNcclxuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoJ2Rvd24nLCB0aGlzLl9wb2ludGVyRG93bikpO1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoJ3VwJywgdGhpcy5fcG9pbnRlclVwKSk7XHJcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoJ21vdmUnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGNhbmNlbCcsIHRoaXMuX2hhbmRsZVRvdWNoRXZlbnQoJ2NhbmNlbCcsIHRoaXMuX3BvaW50ZXJDYW5jZWwpKTtcclxuICAgICAgICAvLyBXM0MgUG9pbnRlciBFdmVudHNcclxuICAgICAgICAvLyBDdXJyZW50OiBJRTExLCBJRTEwXHJcbiAgICAgICAgaWYgKHdpbmRvdy5Qb2ludGVyRXZlbnQpIHtcclxuICAgICAgICAgICAgLy8gSUUxMVxyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUuY2FudmFzLnN0eWxlLnRvdWNoQWN0aW9uID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ2Rvd24nLCB0aGlzLl9wb2ludGVyRG93bikpO1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCd1cCcsIHRoaXMuX3BvaW50ZXJVcCkpO1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ21vdmUnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmNhbmNlbCcsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgnY2FuY2VsJywgdGhpcy5fcG9pbnRlckNhbmNlbCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh3aW5kb3cuTVNQb2ludGVyRXZlbnQpIHtcclxuICAgICAgICAgICAgLy8gSUUxMFxyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUuY2FudmFzLnN0eWxlLm1zVG91Y2hBY3Rpb24gPSAnbm9uZSc7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJEb3duJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCdkb3duJywgdGhpcy5fcG9pbnRlckRvd24pKTtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ01TUG9pbnRlclVwJywgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KCd1cCcsIHRoaXMuX3BvaW50ZXJVcCkpO1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignTVNQb2ludGVyTW92ZScsIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudCgnbW92ZScsIHRoaXMuX3BvaW50ZXJNb3ZlKSk7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdNU1BvaW50ZXJDYW5jZWwnLCB0aGlzLl9oYW5kbGVQb2ludGVyRXZlbnQoJ2NhbmNlbCcsIHRoaXMuX3BvaW50ZXJDYW5jZWwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE1vdXNlIEV2ZW50c1xyXG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5faGFuZGxlTW91c2VFdmVudCgnZG93bicsIHRoaXMuX3BvaW50ZXJEb3duKSk7XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5faGFuZGxlTW91c2VFdmVudCgndXAnLCB0aGlzLl9wb2ludGVyVXApKTtcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZU1vdXNlRXZlbnQoJ21vdmUnLCB0aGlzLl9wb2ludGVyTW92ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBNRE4gTW91c2VXaGVlbEV2ZW50XHJcbiAgICAgICAgY29uc3Qgd2hlZWxPcHRpb25zID0ge1xyXG4gICAgICAgICAgICBwYXNzaXZlOiAhKHRoaXMuX2VuZ2luZS5wYWdlU2Nyb2xsUHJldmVudGlvbk1vZGUgPT09IFNjcm9sbFByZXZlbnRpb25Nb2RlLkFsbCB8fFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZW5naW5lLnBhZ2VTY3JvbGxQcmV2ZW50aW9uTW9kZSA9PT0gU2Nyb2xsUHJldmVudGlvbk1vZGUuQ2FudmFzKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCdvbndoZWVsJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSkge1xyXG4gICAgICAgICAgICAvLyBNb2Rlcm4gQnJvd3NlcnNcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5faGFuZGxlV2hlZWxFdmVudCgnd2hlZWwnLCB0aGlzLl93aGVlbCksIHdoZWVsT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGRvY3VtZW50Lm9ubW91c2V3aGVlbCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIC8vIFdlYmtpdCBhbmQgSUVcclxuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNld2hlZWwnLCB0aGlzLl9oYW5kbGVXaGVlbEV2ZW50KCd3aGVlbCcsIHRoaXMuX3doZWVsKSwgd2hlZWxPcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIFJlbWFpbmluZyBicm93c2VyIGFuZCBvbGRlciBGaXJlZm94XHJcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgdGhpcy5faGFuZGxlV2hlZWxFdmVudCgnd2hlZWwnLCB0aGlzLl93aGVlbCksIHdoZWVsT3B0aW9ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTeW50aGVzaXplIGEgcG9pbnRlciBldmVudCB0aGF0IGxvb2tzIGxpa2UgYSByZWFsIGJyb3dzZXIgZXZlbnQgdG8gZXhjYWxpYnVyXHJcbiAgICAgKiBAcGFyYW0gZXZlbnROYW1lXHJcbiAgICAgKiBAcGFyYW0gcG9zXHJcbiAgICAgKi9cclxuICAgIHRyaWdnZXJFdmVudChldmVudE5hbWUsIHBvcywgYnV0dG9uID0gTmF0aXZlUG9pbnRlckJ1dHRvbi5MZWZ0LCBwb2ludGVyVHlwZSA9ICdtb3VzZScsIHBvaW50ZXJJZCA9IDApIHtcclxuICAgICAgICBsZXQgeCA9IDA7XHJcbiAgICAgICAgbGV0IHkgPSAwO1xyXG4gICAgICAgIGxldCBjb29yZHM7XHJcbiAgICAgICAgaWYgKHBvcyBpbnN0YW5jZW9mIEdsb2JhbENvb3JkaW5hdGVzKSB7XHJcbiAgICAgICAgICAgIHggPSBwb3MucGFnZVBvcy54O1xyXG4gICAgICAgICAgICB5ID0gcG9zLnBhZ2VQb3MueTtcclxuICAgICAgICAgICAgY29vcmRzID0gcG9zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgeCA9IHBvcy54O1xyXG4gICAgICAgICAgICB5ID0gcG9zLnk7XHJcbiAgICAgICAgICAgIGNvb3JkcyA9IG5ldyBHbG9iYWxDb29yZGluYXRlcyhwb3MuY2xvbmUoKSwgcG9zLmNsb25lKCksIHBvcy5jbG9uZSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZXZlbnRpc2ggPSB7XHJcbiAgICAgICAgICAgIHBhZ2VYOiB4LFxyXG4gICAgICAgICAgICBwYWdlWTogeSxcclxuICAgICAgICAgICAgcG9pbnRlcklkOiBwb2ludGVySWQsXHJcbiAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBwb2ludGVyVHlwZSxcclxuICAgICAgICAgICAgYnV0dG9uOiBidXR0b24sXHJcbiAgICAgICAgICAgIHByZXZlbnREZWZhdWx0OiAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvKiBkbyBub3RoaW5nICovXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHN3aXRjaCAoZXZlbnROYW1lKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdmUnOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KGV2ZW50TmFtZSwgdGhpcy5fcG9pbnRlck1vdmUsIGNvb3JkcykoZXZlbnRpc2gpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ2Rvd24nOlxyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUG9pbnRlckV2ZW50KGV2ZW50TmFtZSwgdGhpcy5fcG9pbnRlckRvd24sIGNvb3JkcykoZXZlbnRpc2gpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgJ3VwJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChldmVudE5hbWUsIHRoaXMuX3BvaW50ZXJVcCwgY29vcmRzKShldmVudGlzaCk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAnY2FuY2VsJzpcclxuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZVBvaW50ZXJFdmVudChldmVudE5hbWUsIHRoaXMuX3BvaW50ZXJDYW5jZWwsIGNvb3JkcykoZXZlbnRpc2gpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgYWN0b3Igb2YgdGhpcy5fZW5naW5lLmN1cnJlbnRTY2VuZS5hY3RvcnMpIHtcclxuICAgICAgICAgICAgY29uc3QgY2FwdHVyZVBvaW50ZXIgPSBhY3Rvci50cmFpdHMuZmlsdGVyKCh0KSA9PiB0IGluc3RhbmNlb2YgQ2FwdHVyZVBvaW50ZXIpWzBdO1xyXG4gICAgICAgICAgICBpZiAoY2FwdHVyZVBvaW50ZXIpIHtcclxuICAgICAgICAgICAgICAgIGNhcHR1cmVQb2ludGVyLnVwZGF0ZShhY3RvciwgdGhpcy5fZW5naW5lLCAxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmRpc3BhdGNoUG9pbnRlckV2ZW50cygpO1xyXG4gICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhbGwgcG9pbnRlciBldmVudHMgYW5kIHBvaW50ZXJzLCBtZWFudCB0byBiZSBjYWxsZWQgYXQgdGhlIGVuZCBvZiBmcmFtZVxyXG4gICAgICovXHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlclVwLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fcG9pbnRlckRvd24ubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl9wb2ludGVyTW92ZS5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMuX3BvaW50ZXJDYW5jZWwubGVuZ3RoID0gMDtcclxuICAgICAgICB0aGlzLl93aGVlbC5sZW5ndGggPSAwO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fcG9pbnRlcnNbaV0udXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlbHkgZ2V0cyBhIFBvaW50ZXIgYXQgYSBzcGVjaWZpYyBpbmRleCBhbmQgaW5pdGlhbGl6ZXMgb25lIGlmIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XHJcbiAgICAgKiBAcGFyYW0gaW5kZXggIFRoZSBwb2ludGVyIGluZGV4IHRvIHJldHJpZXZlXHJcbiAgICAgKi9cclxuICAgIGF0KGluZGV4KSB7XHJcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX3BvaW50ZXJzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlcmUgaXMgYSBwb2ludGVyIHRvIHJldHJpZXZlXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9wb2ludGVycy5sZW5ndGggLSAxLCBtYXggPSBpbmRleDsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb2ludGVycy5wdXNoKG5ldyBQb2ludGVyKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnMucHVzaCgtMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50ZXJzW2luZGV4XTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG51bWJlciBvZiBwb2ludGVycyBiZWluZyB3YXRjaGVkXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludGVycy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICBjaGVja0FuZFVwZGF0ZUFjdG9yVW5kZXJQb2ludGVyKGFjdG9yKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBwb2ludGVyIG9mIHRoaXMuX3BvaW50ZXJzKSB7XHJcbiAgICAgICAgICAgIGlmIChwb2ludGVyLmNoZWNrQWN0b3JVbmRlclBvaW50ZXIoYWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLmFkZEFjdG9yVW5kZXJQb2ludGVyKGFjdG9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHBvaW50ZXIucmVtb3ZlQWN0b3JVbmRlclBvaW50ZXIoYWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2Rpc3BhdGNoV2l0aEJ1YmJsZShldmVudHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGV2dCBvZiBldmVudHMpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBhY3RvciBvZiBldnQucG9pbnRlci5nZXRBY3RvcnNGb3JFdmVudHMoKSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFldnQuaXNDYW5jZWxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnByb3BhZ2F0ZShhY3Rvcik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWV2dC5idWJibGVzIHx8IGV2dC5pc0NhbmNlbGVkKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB0aGUgZXZlbnQgc3RvcHMgYnViYmxpbmcgcGFydCB3YXkgc3RvcCBwcm9jZXNzaW5nXHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfZGlzcGF0Y2hQb2ludGVyTGVhdmVFdmVudHMoKSB7XHJcbiAgICAgICAgY29uc3QgbGFzdE1vdmVFdmVudFBlclBvaW50ZXJQZXJBY3RvciA9IHt9O1xyXG4gICAgICAgIGNvbnN0IHBvaW50ZXJMZWF2ZSA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgZXZ0IG9mIHRoaXMuX3BvaW50ZXJNb3ZlKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWN0b3Igb2YgZXZ0LnBvaW50ZXIuZ2V0QWN0b3JzRm9yRXZlbnRzKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhY3RvciB3YXMgdW5kZXIgdGhlIHBvaW50ZXIgbGFzdCBmcmFtZSwgYnV0IG5vdCB0aGlzIHRoaXMgZnJhbWUsIHBvaW50ZXIgbGVmdFxyXG4gICAgICAgICAgICAgICAgaWYgKCFsYXN0TW92ZUV2ZW50UGVyUG9pbnRlclBlckFjdG9yW2V2dC5wb2ludGVyLmlkICsgJysnICsgYWN0b3IuaWRdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZXZ0LnBvaW50ZXIud2FzQWN0b3JVbmRlclBvaW50ZXIoYWN0b3IpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWV2dC5wb2ludGVyLmlzQWN0b3JBbGl2ZVVuZGVyUG9pbnRlcihhY3RvcikgJiZcclxuICAgICAgICAgICAgICAgICAgICAhZXZ0LmlzQ2FuY2VsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb3ZlRXZlbnRQZXJQb2ludGVyUGVyQWN0b3JbZXZ0LnBvaW50ZXIuaWQgKyAnKycgKyBhY3Rvci5pZF0gPSBldnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGUgPSBjcmVhdGVQb2ludGVyRXZlbnRCeU5hbWUoJ2xlYXZlJywgbmV3IEdsb2JhbENvb3JkaW5hdGVzKGV2dC53b3JsZFBvcywgZXZ0LnBhZ2VQb3MsIGV2dC5zY3JlZW5Qb3MpLCBldnQucG9pbnRlciwgZXZ0LmluZGV4LCBldnQucG9pbnRlclR5cGUsIGV2dC5idXR0b24sIGV2dC5ldik7XHJcbiAgICAgICAgICAgICAgICAgICAgcGUucHJvcGFnYXRlKGFjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICBwb2ludGVyTGVhdmUucHVzaChwZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvaW50ZXJMZWF2ZTtcclxuICAgIH1cclxuICAgIF9kaXNwYXRjaFBvaW50ZXJFbnRlckV2ZW50cygpIHtcclxuICAgICAgICBjb25zdCBsYXN0TW92ZUV2ZW50UGVyUG9pbnRlciA9IHt9O1xyXG4gICAgICAgIGNvbnN0IHBvaW50ZXJFbnRlciA9IFtdO1xyXG4gICAgICAgIGZvciAoY29uc3QgZXZ0IG9mIHRoaXMuX3BvaW50ZXJNb3ZlKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgYWN0b3Igb2YgZXZ0LnBvaW50ZXIuZ2V0QWN0b3JzRm9yRXZlbnRzKCkpIHtcclxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhY3RvciB3YXMgbm90IHVuZGVyIHRoZSBwb2ludGVyIGxhc3QgZnJhbWUsIGJ1dCBpdCBpcyB0aGlzIGZyYW1lLCBwb2ludGVyIGVudGVyZWRcclxuICAgICAgICAgICAgICAgIGlmICghbGFzdE1vdmVFdmVudFBlclBvaW50ZXJbZXZ0LnBvaW50ZXIuaWRdICYmXHJcbiAgICAgICAgICAgICAgICAgICAgIWV2dC5wb2ludGVyLndhc0FjdG9yVW5kZXJQb2ludGVyKGFjdG9yKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGV2dC5wb2ludGVyLmlzQWN0b3JBbGl2ZVVuZGVyUG9pbnRlcihhY3RvcikgJiZcclxuICAgICAgICAgICAgICAgICAgICAhZXZ0LmlzQ2FuY2VsZWQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGxhc3RNb3ZlRXZlbnRQZXJQb2ludGVyW2V2dC5wb2ludGVyLmlkXSA9IGV2dDtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwZSA9IGNyZWF0ZVBvaW50ZXJFdmVudEJ5TmFtZSgnZW50ZXInLCBuZXcgR2xvYmFsQ29vcmRpbmF0ZXMoZXZ0LndvcmxkUG9zLCBldnQucGFnZVBvcywgZXZ0LnNjcmVlblBvcyksIGV2dC5wb2ludGVyLCBldnQuaW5kZXgsIGV2dC5wb2ludGVyVHlwZSwgZXZ0LmJ1dHRvbiwgZXZ0LmV2KTtcclxuICAgICAgICAgICAgICAgICAgICBwZS5wcm9wYWdhdGUoYWN0b3IpO1xyXG4gICAgICAgICAgICAgICAgICAgIHBvaW50ZXJFbnRlci5wdXNoKHBlKTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBpZiBwb2ludGVyIGlzIGRyYWdnaW5nIHNldCB0aGUgZHJhZyB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0LnBvaW50ZXIuaXNEcmFnZ2luZykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBldnQucG9pbnRlci5kcmFnVGFyZ2V0ID0gYWN0b3I7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBwb2ludGVyRW50ZXI7XHJcbiAgICB9XHJcbiAgICBkaXNwYXRjaFBvaW50ZXJFdmVudHMoKSB7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hXaXRoQnViYmxlKHRoaXMuX3BvaW50ZXJEb3duKTtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaFdpdGhCdWJibGUodGhpcy5fcG9pbnRlclVwKTtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaFdpdGhCdWJibGUodGhpcy5fcG9pbnRlck1vdmUpO1xyXG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUG9pbnRlckxlYXZlRXZlbnRzKCk7XHJcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hQb2ludGVyRW50ZXJFdmVudHMoKTtcclxuICAgICAgICB0aGlzLl9kaXNwYXRjaFdpdGhCdWJibGUodGhpcy5fcG9pbnRlckNhbmNlbCk7XHJcbiAgICAgICAgLy8gVE9ETyBzb21lIGR1cGxpY2F0aW9uIGhlcmVcclxuICAgICAgICBmb3IgKGNvbnN0IGV2dCBvZiB0aGlzLl93aGVlbCkge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGFjdG9yIG9mIHRoaXMuX3BvaW50ZXJzW2V2dC5pbmRleF0uZ2V0QWN0b3JzVW5kZXJQb2ludGVyKCkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb3BhZ2F0ZVdoZWVsUG9pbnRlckV2ZW50KGFjdG9yLCBldnQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCFldnQuYnViYmxlcyB8fCBldnQuaXNDYW5jZWxlZCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGV2ZW50IHN0b3BzIGJ1YmJsaW5nIHBhcnQgd2F5IHN0b3AgcHJvY2Vzc2luZ1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3Byb3BhZ2F0ZVdoZWVsUG9pbnRlckV2ZW50KGFjdG9yLCB3aGVlbEV2ZW50KSB7XHJcbiAgICAgICAgYWN0b3IuZW1pdCgncG9pbnRlcndoZWVsJywgd2hlZWxFdmVudCk7XHJcbiAgICAgICAgLy8gUmVjdXJzZSBhbmQgcHJvcGFnYXRlXHJcbiAgICAgICAgaWYgKHdoZWVsRXZlbnQuYnViYmxlcyAmJiAhd2hlZWxFdmVudC5pc0NhbmNlbGVkKCkgJiYgYWN0b3IucGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Byb3BhZ2F0ZVdoZWVsUG9pbnRlckV2ZW50KGFjdG9yLnBhcmVudCwgd2hlZWxFdmVudCk7IC8vIFRPRE8gbm90IHRydWVcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlTW91c2VFdmVudChldmVudE5hbWUsIGV2ZW50QXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgY29uc3QgcG9pbnRlciA9IHRoaXMuYXQoMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gR2xvYmFsQ29vcmRpbmF0ZXMuZnJvbVBhZ2VQb3NpdGlvbihlLnBhZ2VYLCBlLnBhZ2VZLCB0aGlzLl9lbmdpbmUpO1xyXG4gICAgICAgICAgICBjb25zdCBwZSA9IGNyZWF0ZVBvaW50ZXJFdmVudEJ5TmFtZShldmVudE5hbWUsIGNvb3JkaW5hdGVzLCBwb2ludGVyLCAwLCBQb2ludGVyVHlwZS5Nb3VzZSwgdGhpcy5fbmF0aXZlQnV0dG9uVG9Qb2ludGVyQnV0dG9uKGUuYnV0dG9uKSwgZSk7XHJcbiAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xyXG4gICAgICAgICAgICBwb2ludGVyLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgcGUpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlVG91Y2hFdmVudChldmVudE5hbWUsIGV2ZW50QXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIChlKSA9PiB7XHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGUuY2hhbmdlZFRvdWNoZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fcG9pbnRlcnMubGVuZ3RoID4gMSA/IHRoaXMuX2dldFBvaW50ZXJJbmRleChlLmNoYW5nZWRUb3VjaGVzW2ldLmlkZW50aWZpZXIpIDogMDtcclxuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLmF0KGluZGV4KTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNvb3JkaW5hdGVzID0gR2xvYmFsQ29vcmRpbmF0ZXMuZnJvbVBhZ2VQb3NpdGlvbihlLmNoYW5nZWRUb3VjaGVzW2ldLnBhZ2VYLCBlLmNoYW5nZWRUb3VjaGVzW2ldLnBhZ2VZLCB0aGlzLl9lbmdpbmUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGUgPSBjcmVhdGVQb2ludGVyRXZlbnRCeU5hbWUoZXZlbnROYW1lLCBjb29yZGluYXRlcywgcG9pbnRlciwgaW5kZXgsIFBvaW50ZXJUeXBlLlRvdWNoLCBQb2ludGVyQnV0dG9uLlVua25vd24sIGUpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnRBcnIucHVzaChwZSk7XHJcbiAgICAgICAgICAgICAgICBwb2ludGVyLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgcGUpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50TmFtZSwgcGUpO1xyXG4gICAgICAgICAgICAgICAgLy8gb25seSB3aXRoIG11bHRpLXBvaW50ZXJcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9wb2ludGVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gJ3VwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgcG9pbnRlciBJRCBmcm9tIHBvb2wgd2hlbiBwb2ludGVyIGlzIGxpZnRlZFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSAtMTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnROYW1lID09PSAnZG93bicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBvaW50ZXIgSUQgdG8gZ2l2ZW4gaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlUG9pbnRlcnNbaW5kZXhdID0gZS5jaGFuZ2VkVG91Y2hlc1tpXS5pZGVudGlmaWVyO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlUG9pbnRlckV2ZW50KGV2ZW50TmFtZSwgZXZlbnRBcnIsIGNvb3Jkcykge1xyXG4gICAgICAgIHJldHVybiAoZSkgPT4ge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIC8vIGdldCB0aGUgaW5kZXggZm9yIHRoaXMgcG9pbnRlciBJRCBpZiBtdWx0aS1wb2ludGVyIGlzIGFza2VkIGZvclxyXG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX3BvaW50ZXJzLmxlbmd0aCA+IDEgPyB0aGlzLl9nZXRQb2ludGVySW5kZXgoZS5wb2ludGVySWQpIDogMDtcclxuICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXIgPSB0aGlzLmF0KGluZGV4KTtcclxuICAgICAgICAgICAgY29uc3QgY29vcmRpbmF0ZXMgPSBjb29yZHMgfHwgR2xvYmFsQ29vcmRpbmF0ZXMuZnJvbVBhZ2VQb3NpdGlvbihlLnBhZ2VYLCBlLnBhZ2VZLCB0aGlzLl9lbmdpbmUpO1xyXG4gICAgICAgICAgICBjb25zdCBwZSA9IGNyZWF0ZVBvaW50ZXJFdmVudEJ5TmFtZShldmVudE5hbWUsIGNvb3JkaW5hdGVzLCBwb2ludGVyLCBpbmRleCwgdGhpcy5fc3RyaW5nVG9Qb2ludGVyVHlwZShlLnBvaW50ZXJUeXBlKSwgdGhpcy5fbmF0aXZlQnV0dG9uVG9Qb2ludGVyQnV0dG9uKGUuYnV0dG9uKSwgZSk7XHJcbiAgICAgICAgICAgIGV2ZW50QXJyLnB1c2gocGUpO1xyXG4gICAgICAgICAgICBwb2ludGVyLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgcGUpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnROYW1lLCBwZSk7XHJcbiAgICAgICAgICAgIC8vIG9ubHkgd2l0aCBtdWx0aS1wb2ludGVyXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2ludGVycy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSAndXAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHBvaW50ZXIgSUQgZnJvbSBwb29sIHdoZW4gcG9pbnRlciBpcyBsaWZ0ZWRcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSAtMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2Rvd24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHBvaW50ZXIgSUQgdG8gZ2l2ZW4gaW5kZXhcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVQb2ludGVyc1tpbmRleF0gPSBlLnBvaW50ZXJJZDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlV2hlZWxFdmVudChldmVudE5hbWUsIGV2ZW50QXJyKSB7XHJcbiAgICAgICAgcmV0dXJuIChlKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFNob3VsZCB3ZSBwcmV2ZW50IHBhZ2Ugc2Nyb2xsIGJlY2F1c2Ugb2YgdGhpcyBldmVudFxyXG4gICAgICAgICAgICBpZiAodGhpcy5fZW5naW5lLnBhZ2VTY3JvbGxQcmV2ZW50aW9uTW9kZSA9PT0gU2Nyb2xsUHJldmVudGlvbk1vZGUuQWxsIHx8XHJcbiAgICAgICAgICAgICAgICAodGhpcy5fZW5naW5lLnBhZ2VTY3JvbGxQcmV2ZW50aW9uTW9kZSA9PT0gU2Nyb2xsUHJldmVudGlvbk1vZGUuQ2FudmFzICYmIGUudGFyZ2V0ID09PSB0aGlzLl9lbmdpbmUuY2FudmFzKSkge1xyXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHNjcmVlbiA9IHRoaXMuX2VuZ2luZS5zY3JlZW4ucGFnZVRvU2NyZWVuQ29vcmRpbmF0ZXModmVjKGUucGFnZVgsIGUucGFnZVkpKTtcclxuICAgICAgICAgICAgY29uc3Qgd29ybGQgPSB0aGlzLl9lbmdpbmUuc2NyZWVuLnNjcmVlblRvV29ybGRDb29yZGluYXRlcyhzY3JlZW4pO1xyXG4gICAgICAgICAgICAvLyBkZWx0YVgsIGRlbHRhWSwgYW5kIGRlbHRhWiBhcmUgdGhlIHN0YW5kYXJkIG1vZGVybiBwcm9wZXJ0aWVzXHJcbiAgICAgICAgICAgIC8vIHdoZWVsRGVsdGFYLCB3aGVlbERlbHRhWSwgYXJlIGxlZ2FjeSBwcm9wZXJ0aWVzIGluIHdlYmtpdCBicm93c2VycyBhbmQgb2xkZXIgSUVcclxuICAgICAgICAgICAgLy8gZS5kZXRhaWwgaXMgb25seSB1c2VkIGluIG9wZXJhXHJcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IGUuZGVsdGFYIHx8IGUud2hlZWxEZWx0YVggKiBTY3JvbGxXaGVlbE5vcm1hbGl6YXRpb25GYWN0b3IgfHwgMDtcclxuICAgICAgICAgICAgY29uc3QgZGVsdGFZID0gZS5kZWx0YVkgfHwgZS53aGVlbERlbHRhWSAqIFNjcm9sbFdoZWVsTm9ybWFsaXphdGlvbkZhY3RvciB8fCBlLndoZWVsRGVsdGEgKiBTY3JvbGxXaGVlbE5vcm1hbGl6YXRpb25GYWN0b3IgfHwgZS5kZXRhaWwgfHwgMDtcclxuICAgICAgICAgICAgY29uc3QgZGVsdGFaID0gZS5kZWx0YVogfHwgMDtcclxuICAgICAgICAgICAgbGV0IGRlbHRhTW9kZSA9IFdoZWVsRGVsdGFNb2RlLlBpeGVsO1xyXG4gICAgICAgICAgICBpZiAoZS5kZWx0YU1vZGUpIHtcclxuICAgICAgICAgICAgICAgIGlmIChlLmRlbHRhTW9kZSA9PT0gMSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhTW9kZSA9IFdoZWVsRGVsdGFNb2RlLkxpbmU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlLmRlbHRhTW9kZSA9PT0gMikge1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhTW9kZSA9IFdoZWVsRGVsdGFNb2RlLlBhZ2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3Qgd2UgPSBuZXcgV2hlZWxFdmVudCh3b3JsZC54LCB3b3JsZC55LCBlLnBhZ2VYLCBlLnBhZ2VZLCBzY3JlZW4ueCwgc2NyZWVuLnksIDAsIGRlbHRhWCwgZGVsdGFZLCBkZWx0YVosIGRlbHRhTW9kZSwgZSk7XHJcbiAgICAgICAgICAgIGV2ZW50QXJyLnB1c2god2UpO1xyXG4gICAgICAgICAgICB0aGlzLmF0KDApLmV2ZW50RGlzcGF0Y2hlci5lbWl0KGV2ZW50TmFtZSwgd2UpO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoZXZlbnROYW1lLCB3ZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgaW5kZXggb2YgdGhlIHBvaW50ZXIgc3BlY2lmaWVkIGZvciB0aGUgZ2l2ZW4gcG9pbnRlciBJRCBvciBmaW5kcyB0aGUgbmV4dCBlbXB0eSBwb2ludGVyIHNsb3QgYXZhaWxhYmxlLlxyXG4gICAgICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIElFMTAvMTEgdXNlcyBpbmNyZW1lbnRpbmcgcG9pbnRlciBJRHMgc28gd2UgbmVlZCB0byBzdG9yZSBhIG1hcHBpbmcgb2YgSUQgPT4gaWR4XHJcbiAgICAgKi9cclxuICAgIF9nZXRQb2ludGVySW5kZXgocG9pbnRlcklkKSB7XHJcbiAgICAgICAgbGV0IGlkeDtcclxuICAgICAgICBpZiAoKGlkeCA9IHRoaXMuX2FjdGl2ZVBvaW50ZXJzLmluZGV4T2YocG9pbnRlcklkKSkgPiAtMSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaWR4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2FjdGl2ZVBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9hY3RpdmVQb2ludGVyc1tpXSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIGlnbm9yZSBwb2ludGVyIGJlY2F1c2UgZ2FtZSBpc24ndCB3YXRjaGluZ1xyXG4gICAgICAgIHJldHVybiAtMTtcclxuICAgIH1cclxuICAgIF9uYXRpdmVCdXR0b25Ub1BvaW50ZXJCdXR0b24ocykge1xyXG4gICAgICAgIHN3aXRjaCAocykge1xyXG4gICAgICAgICAgICBjYXNlIE5hdGl2ZVBvaW50ZXJCdXR0b24uTm9CdXR0b246XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlckJ1dHRvbi5Ob0J1dHRvbjtcclxuICAgICAgICAgICAgY2FzZSBOYXRpdmVQb2ludGVyQnV0dG9uLkxlZnQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlckJ1dHRvbi5MZWZ0O1xyXG4gICAgICAgICAgICBjYXNlIE5hdGl2ZVBvaW50ZXJCdXR0b24uTWlkZGxlOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50ZXJCdXR0b24uTWlkZGxlO1xyXG4gICAgICAgICAgICBjYXNlIE5hdGl2ZVBvaW50ZXJCdXR0b24uUmlnaHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlckJ1dHRvbi5SaWdodDtcclxuICAgICAgICAgICAgY2FzZSBOYXRpdmVQb2ludGVyQnV0dG9uLlVua25vd246XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlckJ1dHRvbi5Vbmtub3duO1xyXG4gICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhaWwocyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3N0cmluZ1RvUG9pbnRlclR5cGUocykge1xyXG4gICAgICAgIHN3aXRjaCAocykge1xyXG4gICAgICAgICAgICBjYXNlICd0b3VjaCc6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlclR5cGUuVG91Y2g7XHJcbiAgICAgICAgICAgIGNhc2UgJ21vdXNlJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyVHlwZS5Nb3VzZTtcclxuICAgICAgICAgICAgY2FzZSAncGVuJzpcclxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludGVyVHlwZS5QZW47XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnRlclR5cGUuVW5rbm93bjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnB1dC9HYW1lcGFkLnRzXG5cclxuXHJcbi8qKlxyXG4gKiBFeGNhbGlidXIgbGV2ZXJhZ2VzIHRoZSBIVE1MNSBHYW1lcGFkIEFQSSBbd2hlcmUgaXQgaXMgc3VwcG9ydGVkXShodHRwOi8vY2FuaXVzZS5jb20vI2ZlYXQ9Z2FtZXBhZClcclxuICogdG8gcHJvdmlkZSBjb250cm9sbGVyIHN1cHBvcnQgZm9yIHlvdXIgZ2FtZXMuXHJcbiAqL1xyXG5jbGFzcyBHYW1lcGFkcyBleHRlbmRzIENsYXNzIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogV2hldGhlciBvciBub3QgdG8gcG9sbCBmb3IgR2FtZXBhZCBpbnB1dCAoZGVmYXVsdDogYGZhbHNlYClcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGV0aGVyIG9yIG5vdCBHYW1lcGFkIEFQSSBpcyBzdXBwb3J0ZWRcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnN1cHBvcnRlZCA9ICEhbmF2aWdhdG9yLmdldEdhbWVwYWRzO1xyXG4gICAgICAgIHRoaXMuX2dhbWVQYWRUaW1lU3RhbXBzID0gWzAsIDAsIDAsIDBdO1xyXG4gICAgICAgIHRoaXMuX29sZFBhZHMgPSBbXTtcclxuICAgICAgICB0aGlzLl9wYWRzID0gW107XHJcbiAgICAgICAgdGhpcy5faW5pdFN1Y2Nlc3MgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9uYXZpZ2F0b3IgPSBuYXZpZ2F0b3I7XHJcbiAgICAgICAgdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgaW5pdCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2luaXRTdWNjZXNzKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gSW4gQ2hyb21lLCB0aGlzIHdpbGwgcmV0dXJuIDQgdW5kZWZpbmVkIGl0ZW1zIHVudGlsIGEgYnV0dG9uIGlzIHByZXNzZWRcclxuICAgICAgICAvLyBJbiBGRiwgdGhpcyB3aWxsIG5vdCByZXR1cm4gYW55IGl0ZW1zIHVudGlsIGEgYnV0dG9uIGlzIHByZXNzZWRcclxuICAgICAgICB0aGlzLl9vbGRQYWRzID0gdGhpcy5fY2xvbmVQYWRzKHRoaXMuX25hdmlnYXRvci5nZXRHYW1lcGFkcygpKTtcclxuICAgICAgICBpZiAodGhpcy5fb2xkUGFkcy5sZW5ndGggJiYgdGhpcy5fb2xkUGFkc1swXSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbml0U3VjY2VzcyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBtaW5pbXVtIGdhbWVwYWQgY29uZmlndXJhdGlvbiwgZm9yIGV4YW1wbGUge2F4aXM6IDQsIGJ1dHRvbnM6IDR9IG1lYW5zXHJcbiAgICAgKiB0aGlzIGdhbWUgcmVxdWlyZXMgYXQgbWluaW11bSA0IGF4aXMgaW5wdXRzIGFuZCA0IGJ1dHRvbnMsIHRoaXMgaXMgbm90IHJlc3RyaWN0aXZlXHJcbiAgICAgKiBhbGwgb3RoZXIgY29udHJvbGxlcnMgd2l0aCBtb3JlIGF4aXMgb3IgYnV0dG9ucyBhcmUgdmFsaWQgYXMgd2VsbC4gSWYgbm8gbWluaW11bVxyXG4gICAgICogY29uZmlndXJhdGlvbiBpcyBzZXQgYWxsIHBhZHMgYXJlIHZhbGlkLlxyXG4gICAgICovXHJcbiAgICBzZXRNaW5pbXVtR2FtZXBhZENvbmZpZ3VyYXRpb24oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7IC8vIGlmIGNvbmZpZyBpcyB1c2VkLCBpbXBsaWNpdGx5IGVuYWJsZVxyXG4gICAgICAgIHRoaXMuX21pbmltdW1Db25maWd1cmF0aW9uID0gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBXaGVuIGltcGxpY2l0bHkgZW5hYmxlZCwgc2V0IHRoZSBlbmFibGVkIGZsYWcgYW5kIHJ1biBhbiB1cGRhdGUgc28gaW5mb3JtYXRpb24gaXMgdXBkYXRlZFxyXG4gICAgICovXHJcbiAgICBfZW5hYmxlQW5kVXBkYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgYSBuYXZpZ2F0b3IgZ2FtZXBhZCBhZ2FpbnN0IHRoZSBtaW5pbXVtIGNvbmZpZ3VyYXRpb24gaWYgcHJlc2VudC5cclxuICAgICAqL1xyXG4gICAgX2lzR2FtZXBhZFZhbGlkKHBhZCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcGFkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgYXhlc0xlbmd0aCA9IHBhZC5heGVzLmZpbHRlcigodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xyXG4gICAgICAgIH0pLmxlbmd0aDtcclxuICAgICAgICBjb25zdCBidXR0b25MZW5ndGggPSBwYWQuYnV0dG9ucy5maWx0ZXIoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IHVuZGVmaW5lZDtcclxuICAgICAgICB9KS5sZW5ndGg7XHJcbiAgICAgICAgcmV0dXJuIGF4ZXNMZW5ndGggPj0gdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24uYXhpcyAmJiBidXR0b25MZW5ndGggPj0gdGhpcy5fbWluaW11bUNvbmZpZ3VyYXRpb24uYnV0dG9ucyAmJiBwYWQuY29ubmVjdGVkO1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7IC8vIGltcGxpY2l0bHkgZW5hYmxlXHJcbiAgICAgICAgc3VwZXIub24oZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICB0aGlzLl9lbmFibGVBbmRVcGRhdGUoKTsgLy8gaW1wbGljaXRseSBlbmFibGVcclxuICAgICAgICBzdXBlci5vZmYoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyBHYW1lcGFkIHN0YXRlIGFuZCBwdWJsaXNoZXMgR2FtZXBhZCBldmVudHNcclxuICAgICAqL1xyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLnN1cHBvcnRlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuaW5pdCgpO1xyXG4gICAgICAgIGNvbnN0IGdhbWVwYWRzID0gdGhpcy5fbmF2aWdhdG9yLmdldEdhbWVwYWRzKCk7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBnYW1lcGFkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIWdhbWVwYWRzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBnYW1lcGFkID0gdGhpcy5hdChpKTtcclxuICAgICAgICAgICAgICAgIC8vIElmIHdhcyBjb25uZWN0ZWQsIGJ1dCBub3cgaXNuJ3QgZW1pdCB0aGUgZGlzY29ubmVjdCBldmVudFxyXG4gICAgICAgICAgICAgICAgaWYgKGdhbWVwYWQuY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudERpc3BhdGNoZXIuZW1pdCgnZGlzY29ubmVjdCcsIG5ldyBHYW1lcGFkRGlzY29ubmVjdEV2ZW50KGksIGdhbWVwYWQpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8vIFJlc2V0IGNvbm5lY3Rpb24gc3RhdHVzXHJcbiAgICAgICAgICAgICAgICBnYW1lcGFkLmNvbm5lY3RlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuYXQoaSkuY29ubmVjdGVkICYmIHRoaXMuX2lzR2FtZXBhZFZhbGlkKGdhbWVwYWRzW2ldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2Nvbm5lY3QnLCBuZXcgR2FtZXBhZENvbm5lY3RFdmVudChpLCB0aGlzLmF0KGkpKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBTZXQgY29ubmVjdGlvbiBzdGF0dXNcclxuICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkuY29ubmVjdGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBPbmx5IHN1cHBvcnRlZCBpbiBDaHJvbWVcclxuICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLnRpbWVzdGFtcCAmJiBnYW1lcGFkc1tpXS50aW1lc3RhbXAgPT09IHRoaXMuX2dhbWVQYWRUaW1lU3RhbXBzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9nYW1lUGFkVGltZVN0YW1wc1tpXSA9IGdhbWVwYWRzW2ldLnRpbWVzdGFtcDtcclxuICAgICAgICAgICAgLy8gQWRkIHJlZmVyZW5jZSB0byBuYXZpZ2F0b3IgZ2FtZXBhZFxyXG4gICAgICAgICAgICB0aGlzLmF0KGkpLm5hdmlnYXRvckdhbWVwYWQgPSBnYW1lcGFkc1tpXTtcclxuICAgICAgICAgICAgLy8gQnV0dG9uc1xyXG4gICAgICAgICAgICBsZXQgYiwgYmksIGEsIGFpLCB2YWx1ZTtcclxuICAgICAgICAgICAgZm9yIChiIGluIEJ1dHRvbnMpIHtcclxuICAgICAgICAgICAgICAgIGJpID0gQnV0dG9uc1tiXTtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYmkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVwYWRzW2ldLmJ1dHRvbnNbYmldKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2FtZXBhZHNbaV0uYnV0dG9uc1tiaV0udmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcy5fb2xkUGFkc1tpXS5nZXRCdXR0b24oYmkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2FtZXBhZHNbaV0uYnV0dG9uc1tiaV0ucHJlc3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQnV0dG9uKGJpLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hdChpKS5ldmVudERpc3BhdGNoZXIuZW1pdCgnYnV0dG9uJywgbmV3IEdhbWVwYWRCdXR0b25FdmVudChiaSwgdmFsdWUsIHRoaXMuYXQoaSkpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQnV0dG9uKGJpLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBeGVzXHJcbiAgICAgICAgICAgIGZvciAoYSBpbiBBeGVzKSB7XHJcbiAgICAgICAgICAgICAgICBhaSA9IEF4ZXNbYV07XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFpID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2FtZXBhZHNbaV0uYXhlc1thaV07XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSB0aGlzLl9vbGRQYWRzW2ldLmdldEF4ZXMoYWkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXQoaSkudXBkYXRlQXhlcyhhaSwgdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmF0KGkpLmV2ZW50RGlzcGF0Y2hlci5lbWl0KCdheGlzJywgbmV3IEdhbWVwYWRBeGlzRXZlbnQoYWksIHZhbHVlLCB0aGlzLmF0KGkpKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX29sZFBhZHNbaV0gPSB0aGlzLl9jbG9uZVBhZChnYW1lcGFkc1tpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTYWZlbHkgcmV0cmlldmVzIGEgR2FtZXBhZCBhdCBhIHNwZWNpZmljIGluZGV4IGFuZCBjcmVhdGVzIG9uZSBpZiBpdCBkb2Vzbid0IHlldCBleGlzdFxyXG4gICAgICovXHJcbiAgICBhdChpbmRleCkge1xyXG4gICAgICAgIHRoaXMuX2VuYWJsZUFuZFVwZGF0ZSgpOyAvLyBpbXBsaWNpdGx5IGVuYWJsZSBnYW1lcGFkcyB3aGVuIGF0KCkgaXMgY2FsbGVkXHJcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuX3BhZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGVyZSBpcyBhIHBhZCB0byByZXRyaWV2ZVxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fcGFkcy5sZW5ndGggLSAxLCBtYXggPSBpbmRleDsgaSA8IG1heDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWRzLnB1c2gobmV3IEdhbWVwYWQoKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vbGRQYWRzLnB1c2gobmV3IEdhbWVwYWQoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhZHNbaW5kZXhdO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhbGwgdmFsaWQgZ2FtZXBhZHMgdGhhdCBtZWV0IHRoZSBtaW5pbXVtIGNvbmZpZ3VyYXRpb24gcmVxdWlyZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIGdldFZhbGlkR2FtZXBhZHMoKSB7XHJcbiAgICAgICAgdGhpcy5fZW5hYmxlQW5kVXBkYXRlKCk7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9wYWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0dhbWVwYWRWYWxpZCh0aGlzLmF0KGkpLm5hdmlnYXRvckdhbWVwYWQpICYmIHRoaXMuYXQoaSkuY29ubmVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmF0KGkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBudW1iZXIgb2YgY29ubmVjdGVkIGdhbWVwYWRzXHJcbiAgICAgKi9cclxuICAgIGNvdW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYWRzLmZpbHRlcigocCkgPT4gcC5jb25uZWN0ZWQpLmxlbmd0aDtcclxuICAgIH1cclxuICAgIF9jbG9uZVBhZHMocGFkcykge1xyXG4gICAgICAgIGNvbnN0IGFyciA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwYWRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGFyci5wdXNoKHRoaXMuX2Nsb25lUGFkKHBhZHNbaV0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFycjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmFzdGVzdCB3YXkgdG8gY2xvbmUgYSBrbm93biBvYmplY3QgaXMgdG8gZG8gaXQgeW91cnNlbGZcclxuICAgICAqL1xyXG4gICAgX2Nsb25lUGFkKHBhZCkge1xyXG4gICAgICAgIGxldCBpLCBsZW47XHJcbiAgICAgICAgY29uc3QgY2xvbmVkUGFkID0gbmV3IEdhbWVwYWQoKTtcclxuICAgICAgICBpZiAoIXBhZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkUGFkO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBwYWQuYnV0dG9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICBpZiAocGFkLmJ1dHRvbnNbaV0pIHtcclxuICAgICAgICAgICAgICAgIGNsb25lZFBhZC51cGRhdGVCdXR0b24oaSwgcGFkLmJ1dHRvbnNbaV0udmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IHBhZC5heGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNsb25lZFBhZC51cGRhdGVBeGVzKGksIHBhZC5heGVzW2ldKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNsb25lZFBhZDtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogVGhlIG1pbmltdW0gdmFsdWUgYW4gYXhpcyBoYXMgdG8gbW92ZSBiZWZvcmUgY29uc2lkZXJpbmcgaXQgYSBjaGFuZ2VcclxuICovXHJcbkdhbWVwYWRzLk1pbkF4aXNNb3ZlVGhyZXNob2xkID0gMC4wNTtcclxuLyoqXHJcbiAqIEdhbWVwYWQgaG9sZHMgc3RhdGUgaW5mb3JtYXRpb24gZm9yIGEgY29ubmVjdGVkIGNvbnRyb2xsZXIuIFNlZSBbW0dhbWVwYWRzXV1cclxuICogZm9yIG1vcmUgaW5mb3JtYXRpb24gb24gaGFuZGxpbmcgY29udHJvbGxlciBpbnB1dC5cclxuICovXHJcbmNsYXNzIEdhbWVwYWQgZXh0ZW5kcyBDbGFzcyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYnV0dG9ucyA9IG5ldyBBcnJheSgxNik7XHJcbiAgICAgICAgdGhpcy5fYXhlcyA9IG5ldyBBcnJheSg0KTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1dHRvbnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fYnV0dG9uc1tpXSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYXhlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB0aGlzLl9heGVzW2ldID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiBidXR0b24gaXMgcHJlc3NlZFxyXG4gICAgICogQHBhcmFtIGJ1dHRvbiAgICAgVGhlIGJ1dHRvbiB0byBxdWVyeVxyXG4gICAgICogQHBhcmFtIHRocmVzaG9sZCAgVGhlIHRocmVzaG9sZCBvdmVyIHdoaWNoIHRoZSBidXR0b24gaXMgY29uc2lkZXJlZCB0byBiZSBwcmVzc2VkXHJcbiAgICAgKi9cclxuICAgIGlzQnV0dG9uUHJlc3NlZChidXR0b24sIHRocmVzaG9sZCA9IDEpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9uc1tidXR0b25dID49IHRocmVzaG9sZDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZ2l2ZW4gYnV0dG9uIHZhbHVlIGJldHdlZW4gMCBhbmQgMVxyXG4gICAgICovXHJcbiAgICBnZXRCdXR0b24oYnV0dG9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbnNbYnV0dG9uXTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgZ2l2ZW4gYXhpcyB2YWx1ZSBiZXR3ZWVuIC0xIGFuZCAxLiBWYWx1ZXMgYmVsb3dcclxuICAgICAqIFtbTWluQXhpc01vdmVUaHJlc2hvbGRdXSBhcmUgY29uc2lkZXJlZCAwLlxyXG4gICAgICovXHJcbiAgICBnZXRBeGVzKGF4ZXMpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2F4ZXNbYXhlc107XHJcbiAgICAgICAgaWYgKE1hdGguYWJzKHZhbHVlKSA8IEdhbWVwYWRzLk1pbkF4aXNNb3ZlVGhyZXNob2xkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHVwZGF0ZUJ1dHRvbihidXR0b25JbmRleCwgdmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9idXR0b25zW2J1dHRvbkluZGV4XSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlQXhlcyhheGVzSW5kZXgsIHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fYXhlc1theGVzSW5kZXhdID0gdmFsdWU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIEdhbWVwYWQgQnV0dG9ucyBlbnVtZXJhdGlvblxyXG4gKi9cclxudmFyIEJ1dHRvbnM7XHJcbihmdW5jdGlvbiAoQnV0dG9ucykge1xyXG4gICAgLyoqXHJcbiAgICAgKiBGYWNlIDEgYnV0dG9uIChlLmcuIEEpXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2UxXCJdID0gMF0gPSBcIkZhY2UxXCI7XHJcbiAgICAvKipcclxuICAgICAqIEZhY2UgMiBidXR0b24gKGUuZy4gQilcclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiRmFjZTJcIl0gPSAxXSA9IFwiRmFjZTJcIjtcclxuICAgIC8qKlxyXG4gICAgICogRmFjZSAzIGJ1dHRvbiAoZS5nLiBYKVxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJGYWNlM1wiXSA9IDJdID0gXCJGYWNlM1wiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBGYWNlIDQgYnV0dG9uIChlLmcuIFkpXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkZhY2U0XCJdID0gM10gPSBcIkZhY2U0XCI7XHJcbiAgICAvKipcclxuICAgICAqIExlZnQgYnVtcGVyIGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJMZWZ0QnVtcGVyXCJdID0gNF0gPSBcIkxlZnRCdW1wZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogUmlnaHQgYnVtcGVyIGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodEJ1bXBlclwiXSA9IDVdID0gXCJSaWdodEJ1bXBlclwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMZWZ0IHRyaWdnZXIgYnV0dG9uXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkxlZnRUcmlnZ2VyXCJdID0gNl0gPSBcIkxlZnRUcmlnZ2VyXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJpZ2h0IHRyaWdnZXIgYnV0dG9uXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIlJpZ2h0VHJpZ2dlclwiXSA9IDddID0gXCJSaWdodFRyaWdnZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogU2VsZWN0IGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJTZWxlY3RcIl0gPSA4XSA9IFwiU2VsZWN0XCI7XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0IGJ1dHRvblxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJTdGFydFwiXSA9IDldID0gXCJTdGFydFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBMZWZ0IGFuYWxvZyBzdGljayBwcmVzcyAoZS5nLiBMMylcclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiTGVmdFN0aWNrXCJdID0gMTBdID0gXCJMZWZ0U3RpY2tcIjtcclxuICAgIC8qKlxyXG4gICAgICogUmlnaHQgYW5hbG9nIHN0aWNrIHByZXNzIChlLmcuIFIzKVxyXG4gICAgICovXHJcbiAgICBCdXR0b25zW0J1dHRvbnNbXCJSaWdodFN0aWNrXCJdID0gMTFdID0gXCJSaWdodFN0aWNrXCI7XHJcbiAgICAvKipcclxuICAgICAqIEQtcGFkIHVwXHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWRVcFwiXSA9IDEyXSA9IFwiRHBhZFVwXCI7XHJcbiAgICAvKipcclxuICAgICAqIEQtcGFkIGRvd25cclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZERvd25cIl0gPSAxM10gPSBcIkRwYWREb3duXCI7XHJcbiAgICAvKipcclxuICAgICAqIEQtcGFkIGxlZnRcclxuICAgICAqL1xyXG4gICAgQnV0dG9uc1tCdXR0b25zW1wiRHBhZExlZnRcIl0gPSAxNF0gPSBcIkRwYWRMZWZ0XCI7XHJcbiAgICAvKipcclxuICAgICAqIEQtcGFkIHJpZ2h0XHJcbiAgICAgKi9cclxuICAgIEJ1dHRvbnNbQnV0dG9uc1tcIkRwYWRSaWdodFwiXSA9IDE1XSA9IFwiRHBhZFJpZ2h0XCI7XHJcbn0pKEJ1dHRvbnMgfHwgKEJ1dHRvbnMgPSB7fSkpO1xyXG4vKipcclxuICogR2FtZXBhZCBBeGVzIGVudW1lcmF0aW9uXHJcbiAqL1xyXG52YXIgQXhlcztcclxuKGZ1bmN0aW9uIChBeGVzKSB7XHJcbiAgICAvKipcclxuICAgICAqIExlZnQgYW5hbG9ndWUgc3RpY2sgWCBkaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgQXhlc1tBeGVzW1wiTGVmdFN0aWNrWFwiXSA9IDBdID0gXCJMZWZ0U3RpY2tYXCI7XHJcbiAgICAvKipcclxuICAgICAqIExlZnQgYW5hbG9ndWUgc3RpY2sgWSBkaXJlY3Rpb25cclxuICAgICAqL1xyXG4gICAgQXhlc1tBeGVzW1wiTGVmdFN0aWNrWVwiXSA9IDFdID0gXCJMZWZ0U3RpY2tZXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJpZ2h0IGFuYWxvZ3VlIHN0aWNrIFggZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIEF4ZXNbQXhlc1tcIlJpZ2h0U3RpY2tYXCJdID0gMl0gPSBcIlJpZ2h0U3RpY2tYXCI7XHJcbiAgICAvKipcclxuICAgICAqIFJpZ2h0IGFuYWxvZ3VlIHN0aWNrIFkgZGlyZWN0aW9uXHJcbiAgICAgKi9cclxuICAgIEF4ZXNbQXhlc1tcIlJpZ2h0U3RpY2tZXCJdID0gM10gPSBcIlJpZ2h0U3RpY2tZXCI7XHJcbn0pKEF4ZXMgfHwgKEF4ZXMgPSB7fSkpO1xyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvQnJvd3Nlci50c1xuY2xhc3MgQnJvd3NlckNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihuYXRpdmVDb21wb25lbnQpIHtcclxuICAgICAgICB0aGlzLm5hdGl2ZUNvbXBvbmVudCA9IG5hdGl2ZUNvbXBvbmVudDtcclxuICAgICAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9uYXRpdmVIYW5kbGVycyA9IHt9O1xyXG4gICAgfVxyXG4gICAgb24oZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX25hdGl2ZUhhbmRsZXJzW2V2ZW50TmFtZV0pIHtcclxuICAgICAgICAgICAgdGhpcy5vZmYoZXZlbnROYW1lLCB0aGlzLl9uYXRpdmVIYW5kbGVyc1tldmVudE5hbWVdKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fbmF0aXZlSGFuZGxlcnNbZXZlbnROYW1lXSA9IHRoaXMuX2RlY29yYXRlKGhhbmRsZXIpO1xyXG4gICAgICAgIHRoaXMubmF0aXZlQ29tcG9uZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCB0aGlzLl9uYXRpdmVIYW5kbGVyc1tldmVudE5hbWVdKTtcclxuICAgIH1cclxuICAgIG9mZihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBpZiAoIWhhbmRsZXIpIHtcclxuICAgICAgICAgICAgaGFuZGxlciA9IHRoaXMuX25hdGl2ZUhhbmRsZXJzW2V2ZW50TmFtZV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubmF0aXZlQ29tcG9uZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcclxuICAgICAgICB0aGlzLl9uYXRpdmVIYW5kbGVyc1tldmVudE5hbWVdID0gbnVsbDtcclxuICAgIH1cclxuICAgIF9kZWNvcmF0ZShoYW5kbGVyKSB7XHJcbiAgICAgICAgcmV0dXJuIChldnQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wYXVzZWQpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXZ0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwYXVzZSgpIHtcclxuICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgY2xlYXIoKSB7XHJcbiAgICAgICAgZm9yIChjb25zdCBldmVudCBpbiB0aGlzLl9uYXRpdmVIYW5kbGVycykge1xyXG4gICAgICAgICAgICB0aGlzLm9mZihldmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmNsYXNzIEJyb3dzZXJFdmVudHMge1xyXG4gICAgY29uc3RydWN0b3IoX3dpbmRvd0dsb2JhbCwgX2RvY3VtZW50R2xvYmFsKSB7XHJcbiAgICAgICAgdGhpcy5fd2luZG93R2xvYmFsID0gX3dpbmRvd0dsb2JhbDtcclxuICAgICAgICB0aGlzLl9kb2N1bWVudEdsb2JhbCA9IF9kb2N1bWVudEdsb2JhbDtcclxuICAgICAgICB0aGlzLl93aW5kb3dDb21wb25lbnQgPSBuZXcgQnJvd3NlckNvbXBvbmVudCh0aGlzLl93aW5kb3dHbG9iYWwpO1xyXG4gICAgICAgIHRoaXMuX2RvY3VtZW50Q29tcG9uZW50ID0gbmV3IEJyb3dzZXJDb21wb25lbnQodGhpcy5fZG9jdW1lbnRHbG9iYWwpO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpbmRvdygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fd2luZG93Q29tcG9uZW50O1xyXG4gICAgfVxyXG4gICAgZ2V0IGRvY3VtZW50KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9kb2N1bWVudENvbXBvbmVudDtcclxuICAgIH1cclxuICAgIHBhdXNlKCkge1xyXG4gICAgICAgIHRoaXMud2luZG93LnBhdXNlKCk7XHJcbiAgICAgICAgdGhpcy5kb2N1bWVudC5wYXVzZSgpO1xyXG4gICAgfVxyXG4gICAgcmVzdW1lKCkge1xyXG4gICAgICAgIHRoaXMud2luZG93LnJlc3VtZSgpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnQucmVzdW1lKCk7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLndpbmRvdy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuZG9jdW1lbnQuY2xlYXIoKTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0NvbnRleHQvRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXMudHNcblxyXG5cclxuXHJcblxyXG5jbGFzcyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhc0RlYnVnIHtcclxuICAgIGNvbnN0cnVjdG9yKF9leCkge1xyXG4gICAgICAgIHRoaXMuX2V4ID0gX2V4O1xyXG4gICAgICAgIHRoaXMuX2RlYnVnVGV4dCA9IG5ldyBEZWJ1Z1RleHQoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhdyBhIGRlYnVnIHJlY3RhbmdsZSB0byB0aGUgY29udGV4dFxyXG4gICAgICogQHBhcmFtIHhcclxuICAgICAqIEBwYXJhbSB5XHJcbiAgICAgKiBAcGFyYW0gd2lkdGhcclxuICAgICAqIEBwYXJhbSBoZWlnaHRcclxuICAgICAqL1xyXG4gICAgZHJhd1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LnNhdmUoKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LnN0cm9rZVJlY3QodGhpcy5fZXguc25hcFRvUGl4ZWwgPyB+fnggOiB4LCB0aGlzLl9leC5zbmFwVG9QaXhlbCA/IH5+eSA6IHksIHRoaXMuX2V4LnNuYXBUb1BpeGVsID8gfn53aWR0aCA6IHdpZHRoLCB0aGlzLl9leC5zbmFwVG9QaXhlbCA/IH5+aGVpZ2h0IDogaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgICBkcmF3TGluZShzdGFydCwgZW5kLCBsaW5lT3B0aW9ucyA9IHsgY29sb3I6IENvbG9yLkJsYWNrIH0pIHtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguc3Ryb2tlU3R5bGUgPSBsaW5lT3B0aW9ucy5jb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4Lm1vdmVUbyh0aGlzLl9leC5zbmFwVG9QaXhlbCA/IH5+c3RhcnQueCA6IHN0YXJ0LngsIHRoaXMuX2V4LnNuYXBUb1BpeGVsID8gfn5zdGFydC55IDogc3RhcnQueSk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHgubGluZVRvKHRoaXMuX2V4LnNuYXBUb1BpeGVsID8gfn5lbmQueCA6IGVuZC54LCB0aGlzLl9leC5zbmFwVG9QaXhlbCA/IH5+ZW5kLnkgOiBlbmQueSk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHgubGluZVdpZHRoID0gMjtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5zdHJva2UoKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgICBkcmF3UG9pbnQocG9pbnQsIHBvaW50T3B0aW9ucyA9IHsgY29sb3I6IENvbG9yLkJsYWNrLCBzaXplOiA1IH0pIHtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguYmVnaW5QYXRoKCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguZmlsbFN0eWxlID0gcG9pbnRPcHRpb25zLmNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5fZXguX19jdHguYXJjKHRoaXMuX2V4LnNuYXBUb1BpeGVsID8gfn5wb2ludC54IDogcG9pbnQueCwgdGhpcy5fZXguc25hcFRvUGl4ZWwgPyB+fnBvaW50LnkgOiBwb2ludC55LCBwb2ludE9wdGlvbnMuc2l6ZSwgMCwgTWF0aC5QSSAqIDIpO1xyXG4gICAgICAgIHRoaXMuX2V4Ll9fY3R4LmZpbGwoKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLl9leC5fX2N0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgICBkcmF3VGV4dCh0ZXh0LCBwb3MpIHtcclxuICAgICAgICB0aGlzLl9kZWJ1Z1RleHQud3JpdGUodGhpcy5fZXgsIHRleHQsIHBvcyk7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXMge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZENvbG9yID0gQ29sb3IuRXhjYWxpYnVyQmx1ZTtcclxuICAgICAgICB0aGlzLl9zdGF0ZSA9IG5ldyBTdGF0ZVN0YWNrKCk7XHJcbiAgICAgICAgdGhpcy5zbmFwVG9QaXhlbCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IG5ldyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhc0RlYnVnKHRoaXMpO1xyXG4gICAgICAgIGNvbnN0IHsgY2FudmFzRWxlbWVudCwgZW5hYmxlVHJhbnNwYXJlbmN5LCBzbmFwVG9QaXhlbCwgc21vb3RoaW5nLCBiYWNrZ3JvdW5kQ29sb3IgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5fX2N0eCA9IGNhbnZhc0VsZW1lbnQuZ2V0Q29udGV4dCgnMmQnLCB7XHJcbiAgICAgICAgICAgIGFscGhhOiBlbmFibGVUcmFuc3BhcmVuY3kgIT09IG51bGwgJiYgZW5hYmxlVHJhbnNwYXJlbmN5ICE9PSB2b2lkIDAgPyBlbmFibGVUcmFuc3BhcmVuY3kgOiB0cnVlXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3IgIT09IG51bGwgJiYgYmFja2dyb3VuZENvbG9yICE9PSB2b2lkIDAgPyBiYWNrZ3JvdW5kQ29sb3IgOiB0aGlzLmJhY2tncm91bmRDb2xvcjtcclxuICAgICAgICB0aGlzLnNuYXBUb1BpeGVsID0gc25hcFRvUGl4ZWwgIT09IG51bGwgJiYgc25hcFRvUGl4ZWwgIT09IHZvaWQgMCA/IHNuYXBUb1BpeGVsIDogdGhpcy5zbmFwVG9QaXhlbDtcclxuICAgICAgICB0aGlzLnNtb290aGluZyA9IHNtb290aGluZyAhPT0gbnVsbCAmJiBzbW9vdGhpbmcgIT09IHZvaWQgMCA/IHNtb290aGluZyA6IHRoaXMuc21vb3RoaW5nO1xyXG4gICAgfVxyXG4gICAgZ2V0IHdpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fY3R4LmNhbnZhcy53aWR0aDtcclxuICAgIH1cclxuICAgIGdldCBoZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jdHguY2FudmFzLmhlaWdodDtcclxuICAgIH1cclxuICAgIGdldCBvcGFjaXR5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZS5jdXJyZW50Lm9wYWNpdHk7XHJcbiAgICB9XHJcbiAgICBzZXQgb3BhY2l0eSh2YWx1ZSkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlLmN1cnJlbnQub3BhY2l0eSA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZ2V0IHNtb290aGluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX2N0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICBzZXQgc21vb3RoaW5nKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIHJlc2V0VHJhbnNmb3JtKCkge1xyXG4gICAgICAgIHRoaXMuX19jdHgucmVzZXRUcmFuc2Zvcm0oKTtcclxuICAgIH1cclxuICAgIHVwZGF0ZVZpZXdwb3J0KCkge1xyXG4gICAgICAgIC8vIHBhc3NcclxuICAgIH1cclxuICAgIGRyYXdJbWFnZShpbWFnZSwgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQsIGR4LCBkeSwgZHdpZHRoLCBkaGVpZ2h0KSB7XHJcbiAgICAgICAgaWYgKHN3aWR0aCA9PT0gMCB8fCBzaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gemVybyBkaW1lbnNpb24gZGVzdCBleGl0IGVhcmx5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGR3aWR0aCA9PT0gMCB8fCBkaGVpZ2h0ID09PSAwKSB7XHJcbiAgICAgICAgICAgIHJldHVybjsgLy8gemVybyBkaW1lbnNpb24gZGVzdCBleGl0IGVhcmx5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGltYWdlLndpZHRoID09PSAwIHx8IGltYWdlLmhlaWdodCA9PT0gMCkge1xyXG4gICAgICAgICAgICByZXR1cm47IC8vIHplcm8gZGltZW5zaW9uIHNvdXJjZSBleGl0IGVhcmx5XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX19jdHguZ2xvYmFsQWxwaGEgPSB0aGlzLm9wYWNpdHk7XHJcbiAgICAgICAgY29uc3QgYXJncyA9IFtpbWFnZSwgc3gsIHN5LCBzd2lkdGgsIHNoZWlnaHQsIGR4LCBkeSwgZHdpZHRoLCBkaGVpZ2h0XVxyXG4gICAgICAgICAgICAuZmlsdGVyKChhKSA9PiBhICE9PSB1bmRlZmluZWQpXHJcbiAgICAgICAgICAgIC5tYXAoKGEpID0+ICh0eXBlb2YgYSA9PT0gJ251bWJlcicgJiYgdGhpcy5zbmFwVG9QaXhlbCA/IH5+YSA6IGEpKTtcclxuICAgICAgICB0aGlzLl9fY3R4LmRyYXdJbWFnZS5hcHBseSh0aGlzLl9fY3R4LCBhcmdzKTtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXdDYWxsQ291bnQrKztcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLkRyYXduSW1hZ2VzQ291bnQgPSAxO1xyXG4gICAgfVxyXG4gICAgZHJhd0xpbmUoc3RhcnQsIGVuZCwgY29sb3IsIHRoaWNrbmVzcyA9IDEpIHtcclxuICAgICAgICB0aGlzLl9fY3R4LnNhdmUoKTtcclxuICAgICAgICB0aGlzLl9fY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuX19jdHguc3Ryb2tlU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX19jdHgubW92ZVRvKHRoaXMuc25hcFRvUGl4ZWwgPyB+fnN0YXJ0LnggOiBzdGFydC54LCB0aGlzLnNuYXBUb1BpeGVsID8gfn5zdGFydC55IDogc3RhcnQueSk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5saW5lVG8odGhpcy5zbmFwVG9QaXhlbCA/IH5+ZW5kLnggOiBlbmQueCwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+ZW5kLnkgOiBlbmQueSk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5saW5lV2lkdGggPSB0aGlja25lc3M7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5zdHJva2UoKTtcclxuICAgICAgICB0aGlzLl9fY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuX19jdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gICAgZHJhd1JlY3RhbmdsZShwb3MsIHdpZHRoLCBoZWlnaHQsIGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5maWxsU3R5bGUgPSBjb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIHRoaXMuX19jdHguZmlsbFJlY3QodGhpcy5zbmFwVG9QaXhlbCA/IH5+cG9zLnggOiBwb3MueCwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+cG9zLnkgOiBwb3MueSwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+d2lkdGggOiB3aWR0aCwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+aGVpZ2h0IDogaGVpZ2h0KTtcclxuICAgICAgICB0aGlzLl9fY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIGRyYXdDaXJjbGUocG9zLCByYWRpdXMsIGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5zYXZlKCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICB0aGlzLl9fY3R4LmZpbGxTdHlsZSA9IGNvbG9yLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5hcmModGhpcy5zbmFwVG9QaXhlbCA/IH5+cG9zLnggOiBwb3MueCwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+cG9zLnkgOiBwb3MueSwgcmFkaXVzLCAwLCBNYXRoLlBJICogMik7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5maWxsKCk7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLl9fY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2F2ZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgY2FudmFzIHRvIHRoZSBzdGFjayAodHJhbnNmb3JtcyBhbmQgb3BhY2l0eSlcclxuICAgICAqL1xyXG4gICAgc2F2ZSgpIHtcclxuICAgICAgICB0aGlzLl9fY3R4LnNhdmUoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVzdG9yZSB0aGUgc3RhdGUgb2YgdGhlIGNhbnZhcyBmcm9tIHRoZSBzdGFja1xyXG4gICAgICovXHJcbiAgICByZXN0b3JlKCkge1xyXG4gICAgICAgIHRoaXMuX19jdHgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2xhdGUgdGhlIG9yaWdpbiBvZiB0aGUgY29udGV4dCBieSBhbiB4IGFuZCB5XHJcbiAgICAgKiBAcGFyYW0geFxyXG4gICAgICogQHBhcmFtIHlcclxuICAgICAqL1xyXG4gICAgdHJhbnNsYXRlKHgsIHkpIHtcclxuICAgICAgICB0aGlzLl9fY3R4LnRyYW5zbGF0ZSh0aGlzLnNuYXBUb1BpeGVsID8gfn54IDogeCwgdGhpcy5zbmFwVG9QaXhlbCA/IH5+eSA6IHkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSb3RhdGUgdGhlIGNvbnRleHQgYWJvdXQgdGhlIGN1cnJlbnQgb3JpZ2luXHJcbiAgICAgKi9cclxuICAgIHJvdGF0ZShhbmdsZSkge1xyXG4gICAgICAgIHRoaXMuX19jdHgucm90YXRlKGFuZ2xlKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2NhbGUgdGhlIGNvbnRleHQgYnkgYW4geCBhbmQgeSBmYWN0b3JcclxuICAgICAqIEBwYXJhbSB4XHJcbiAgICAgKiBAcGFyYW0geVxyXG4gICAgICovXHJcbiAgICBzY2FsZSh4LCB5KSB7XHJcbiAgICAgICAgdGhpcy5fX2N0eC5zY2FsZSh4LCB5KTtcclxuICAgIH1cclxuICAgIGNsZWFyKCkge1xyXG4gICAgICAgIC8vIENsZWFyIGZyYW1lXHJcbiAgICAgICAgdGhpcy5fX2N0eC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xyXG4gICAgICAgIHRoaXMuX19jdHguZmlsbFN0eWxlID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICB0aGlzLl9fY3R4LmZpbGxSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcclxuICAgICAgICBHcmFwaGljc0RpYWdub3N0aWNzLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZsdXNoZXMgdGhlIGJhdGNoZWQgZHJhdyBjYWxscyB0byB0aGUgc2NyZWVuXHJcbiAgICAgKi9cclxuICAgIGZsdXNoKCkge1xyXG4gICAgICAgIC8vIHBhc3NcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VuZ2luZS50c1xudmFyIEVuZ2luZV9kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuXHJcblxyXG5cclxucG9seWZpbGwoKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogRW51bSByZXByZXNlbnRpbmcgdGhlIGRpZmZlcmVudCBtb3VzZXdoZWVsIGV2ZW50IGJ1YmJsZSBwcmV2ZW50aW9uXHJcbiAqL1xyXG52YXIgU2Nyb2xsUHJldmVudGlvbk1vZGU7XHJcbihmdW5jdGlvbiAoU2Nyb2xsUHJldmVudGlvbk1vZGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogRG8gbm90IHByZXZlbnQgYW55IHBhZ2Ugc2Nyb2xsaW5nXHJcbiAgICAgKi9cclxuICAgIFNjcm9sbFByZXZlbnRpb25Nb2RlW1Njcm9sbFByZXZlbnRpb25Nb2RlW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XHJcbiAgICAvKipcclxuICAgICAqIFByZXZlbnQgcGFnZSBzY3JvbGwgaWYgbW91c2UgaXMgb3ZlciB0aGUgZ2FtZSBjYW52YXNcclxuICAgICAqL1xyXG4gICAgU2Nyb2xsUHJldmVudGlvbk1vZGVbU2Nyb2xsUHJldmVudGlvbk1vZGVbXCJDYW52YXNcIl0gPSAxXSA9IFwiQ2FudmFzXCI7XHJcbiAgICAvKipcclxuICAgICAqIFByZXZlbnQgYWxsIHBhZ2Ugc2Nyb2xsaW5nIHZpYSBtb3VzZSB3aGVlbFxyXG4gICAgICovXHJcbiAgICBTY3JvbGxQcmV2ZW50aW9uTW9kZVtTY3JvbGxQcmV2ZW50aW9uTW9kZVtcIkFsbFwiXSA9IDJdID0gXCJBbGxcIjtcclxufSkoU2Nyb2xsUHJldmVudGlvbk1vZGUgfHwgKFNjcm9sbFByZXZlbnRpb25Nb2RlID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBFeGNhbGlidXIgRW5naW5lXHJcbiAqXHJcbiAqIFRoZSBbW0VuZ2luZV1dIGlzIHRoZSBtYWluIGRyaXZlciBmb3IgYSBnYW1lLiBJdCBpcyByZXNwb25zaWJsZSBmb3JcclxuICogc3RhcnRpbmcvc3RvcHBpbmcgdGhlIGdhbWUsIG1haW50YWluaW5nIHN0YXRlLCB0cmFuc21pdHRpbmcgZXZlbnRzLFxyXG4gKiBsb2FkaW5nIHJlc291cmNlcywgYW5kIG1hbmFnaW5nIHRoZSBzY2VuZS5cclxuICovXHJcbmNsYXNzIEVuZ2luZSBleHRlbmRzIENsYXNzIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIG5ldyBnYW1lIHVzaW5nIHRoZSBnaXZlbiBbW0VuZ2luZU9wdGlvbnNdXS4gQnkgZGVmYXVsdCwgaWYgbm8gb3B0aW9ucyBhcmUgcHJvdmlkZWQsXHJcbiAgICAgKiB0aGUgZ2FtZSB3aWxsIGJlIHJlbmRlcmVkIGZ1bGwgc2NyZWVuICh0YWtpbmcgdXAgYWxsIGF2YWlsYWJsZSBicm93c2VyIHdpbmRvdyBzcGFjZSkuXHJcbiAgICAgKiBZb3UgY2FuIGN1c3RvbWl6ZSB0aGUgZ2FtZSByZW5kZXJpbmcgdGhyb3VnaCBbW0VuZ2luZU9wdGlvbnNdXS5cclxuICAgICAqXHJcbiAgICAgKiBFeGFtcGxlOlxyXG4gICAgICpcclxuICAgICAqIGBgYGpzXHJcbiAgICAgKiB2YXIgZ2FtZSA9IG5ldyBleC5FbmdpbmUoe1xyXG4gICAgICogICB3aWR0aDogMCwgLy8gdGhlIHdpZHRoIG9mIHRoZSBjYW52YXNcclxuICAgICAqICAgaGVpZ2h0OiAwLCAvLyB0aGUgaGVpZ2h0IG9mIHRoZSBjYW52YXNcclxuICAgICAqICAgZW5hYmxlQ2FudmFzVHJhbnNwYXJlbmN5OiB0cnVlLCAvLyB0aGUgdHJhbnNwYXJlbmN5U2VjdGlvbiBvZiB0aGUgY2FudmFzXHJcbiAgICAgKiAgIGNhbnZhc0VsZW1lbnRJZDogJycsIC8vIHRoZSBET00gY2FudmFzIGVsZW1lbnQgSUQsIGlmIHlvdSBhcmUgcHJvdmlkaW5nIHlvdXIgb3duXHJcbiAgICAgKiAgIGRpc3BsYXlNb2RlOiBleC5EaXNwbGF5TW9kZS5GdWxsU2NyZWVuLCAvLyB0aGUgZGlzcGxheSBtb2RlXHJcbiAgICAgKiAgIHBvaW50ZXJTY29wZTogZXguSW5wdXQuUG9pbnRlclNjb3BlLkRvY3VtZW50LCAvLyB0aGUgc2NvcGUgb2YgY2FwdHVyaW5nIHBvaW50ZXIgKG1vdXNlL3RvdWNoKSBldmVudHNcclxuICAgICAqICAgYmFja2dyb3VuZENvbG9yOiBleC5Db2xvci5mcm9tSGV4KCcjMjE4NWQwJykgLy8gYmFja2dyb3VuZCBjb2xvciBvZiB0aGUgZW5naW5lXHJcbiAgICAgKiB9KTtcclxuICAgICAqXHJcbiAgICAgKiAvLyBjYWxsIGdhbWUuc3RhcnQsIHdoaWNoIGlzIGEgUHJvbWlzZVxyXG4gICAgICogZ2FtZS5zdGFydCgpLnRoZW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICogICAvLyByZWFkeSwgc2V0LCBnbyFcclxuICAgICAqIH0pO1xyXG4gICAgICogYGBgXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuX2hhc1N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGxpc3Qgb2YgcG9zdCBwcm9jZXNzb3JzIHRvIGFwcGx5IGF0IHRoZSBlbmQgb2YgZHJhd2luZyBhIGZyYW1lIChzdWNoIGFzIFtbQ29sb3JCbGluZENvcnJlY3Rvcl1dKVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMucG9zdFByb2Nlc3NvcnMgPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb250YWlucyBhbGwgdGhlIHNjZW5lcyBjdXJyZW50bHkgcmVnaXN0ZXJlZCB3aXRoIEV4Y2FsaWJ1clxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc2NlbmVzID0ge307XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQGhpZGRlblxyXG4gICAgICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9ucyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3N1cHByZXNzUGxheUJ1dHRvbiA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIGF1ZGlvIHNob3VsZCBiZSBwYXVzZWQgd2hlbiB0aGUgZ2FtZSBpcyBubyBsb25nZXIgdmlzaWJsZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnBhdXNlQXVkaW9XaGVuSGlkZGVuID0gdHJ1ZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgZW5naW5lIHNob3VsZCBkcmF3IHdpdGggZGVidWcgaW5mb3JtYXRpb25cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9pc0RlYnVnID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5kZWJ1Z0NvbG9yID0gbmV3IENvbG9yKDI1NSwgMjU1LCAyNTUpO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldHMgdGhlIFRyYW5zcGFyZW5jeSBmb3IgdGhlIGVuZ2luZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmVuYWJsZUNhbnZhc1RyYW5zcGFyZW5jeSA9IHRydWU7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGhlIGFjdGlvbiB0byB0YWtlIHdoZW4gYSBmYXRhbCBleGNlcHRpb24gaXMgdGhyb3duXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vbkZhdGFsRXhjZXB0aW9uID0gKGUpID0+IHtcclxuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZmF0YWwoZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLl90aW1lc2NhbGUgPSAxLjA7XHJcbiAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5faXNJbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2RlZmVycmVkR29UbyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fbG9hZGluZ0NvbXBsZXRlID0gZmFsc2U7XHJcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgRW5naW5lLl9ERUZBVUxUX0VOR0lORV9PUFRJT05TKSwgb3B0aW9ucyk7XHJcbiAgICAgICAgRmxhZ3MuZnJlZXplKCk7XHJcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBicm93c2VyIGV2ZW50cyBmYWNhZGVcclxuICAgICAgICB0aGlzLmJyb3dzZXIgPSBuZXcgQnJvd3NlckV2ZW50cyh3aW5kb3csIGRvY3VtZW50KTtcclxuICAgICAgICAvLyBDaGVjayBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgY29uc3QgZGV0ZWN0b3IgPSBuZXcgRGV0ZWN0b3IoKTtcclxuICAgICAgICBpZiAoIW9wdGlvbnMuc3VwcHJlc3NNaW5pbXVtQnJvd3NlckZlYXR1cmVEZXRlY3Rpb24gJiYgISh0aGlzLl9jb21wYXRpYmxlID0gZGV0ZWN0b3IudGVzdCgpKSkge1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcbiAgICAgICAgICAgIG1lc3NhZ2UuaW5uZXJUZXh0ID0gJ1NvcnJ5LCB5b3VyIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBhbGwgdGhlIGZlYXR1cmVzIG5lZWRlZCBmb3IgRXhjYWxpYnVyJztcclxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChtZXNzYWdlKTtcclxuICAgICAgICAgICAgZGV0ZWN0b3IuZmFpbGVkVGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodGVzdCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdE1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICAgICAgICAgIHRlc3RNZXNzYWdlLmlubmVyVGV4dCA9ICdCcm93c2VyIGZlYXR1cmUgbWlzc2luZyAnICsgdGVzdDtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGVzdE1lc3NhZ2UpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2FudmFzRWxlbWVudElkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FudmFzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnBhcmVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoY2FudmFzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wYXRpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVXNlIG5hdGl2ZSBjb25zb2xlIEFQSSBmb3IgY29sb3IgZnVuXHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICBpZiAoY29uc29sZS5sb2cgJiYgIW9wdGlvbnMuc3VwcHJlc3NDb25zb2xlQm9vdE1lc3NhZ2UpIHtcclxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYCVjUG93ZXJlZCBieSBFeGNhbGlidXIuanMgKHYke0VYX1ZFUlNJT059KWAsICdiYWNrZ3JvdW5kOiAjMTc2QkFBOyBjb2xvcjogd2hpdGU7IGJvcmRlci1yYWRpdXM6IDVweDsgcGFkZGluZzogMTVweDsgZm9udC1zaXplOiAxLjVlbTsgbGluZS1oZWlnaHQ6IDgwcHg7Jyk7XHJcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdcXG5cXFxyXG4gICAgICAvfCBfX19fX19fX19fX19fX19fXFxuXFxcclxuT3w9PT18KiA+X19fX19fX19fX19fX19fXz5cXG5cXFxyXG4gICAgICBcXFxcfCcpO1xyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVmlzaXQnLCAnaHR0cDovL2V4Y2FsaWJ1cmpzLmNvbScsICdmb3IgbW9yZSBpbmZvcm1hdGlvbicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdXBwcmVzcyBwbGF5IGJ1dHRvblxyXG4gICAgICAgIGlmIChvcHRpb25zLnN1cHByZXNzUGxheUJ1dHRvbikge1xyXG4gICAgICAgICAgICB0aGlzLl9zdXBwcmVzc1BsYXlCdXR0b24gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICAvLyBJZiBkZWJ1ZyBpcyBlbmFibGVkLCBsZXQncyBsb2cgYnJvd3NlciBmZWF0dXJlcyB0byB0aGUgY29uc29sZS5cclxuICAgICAgICBpZiAodGhpcy5fbG9nZ2VyLmRlZmF1bHRMZXZlbCA9PT0gTG9nTGV2ZWwuRGVidWcpIHtcclxuICAgICAgICAgICAgZGV0ZWN0b3IubG9nQnJvd3NlckZlYXR1cmVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnQnVpbGRpbmcgZW5naW5lLi4uJyk7XHJcbiAgICAgICAgdGhpcy5jYW52YXNFbGVtZW50SWQgPSBvcHRpb25zLmNhbnZhc0VsZW1lbnRJZDtcclxuICAgICAgICBpZiAob3B0aW9ucy5jYW52YXNFbGVtZW50SWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdVc2luZyBDYW52YXMgZWxlbWVudCBzcGVjaWZpZWQ6ICcgKyBvcHRpb25zLmNhbnZhc0VsZW1lbnRJZCk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5jYW52YXNFbGVtZW50SWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdVc2luZyBDYW52YXMgZWxlbWVudCBzcGVjaWZpZWQ6Jywgb3B0aW9ucy5jYW52YXNFbGVtZW50KTtcclxuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBvcHRpb25zLmNhbnZhc0VsZW1lbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1VzaW5nIGdlbmVyYXRlZCBjYW52YXMgZWxlbWVudCcpO1xyXG4gICAgICAgICAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZGlzcGxheU1vZGUgPSAoX2EgPSBvcHRpb25zLmRpc3BsYXlNb2RlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBEaXNwbGF5TW9kZS5GaXhlZDtcclxuICAgICAgICBpZiAoKG9wdGlvbnMud2lkdGggJiYgb3B0aW9ucy5oZWlnaHQpIHx8IG9wdGlvbnMudmlld3BvcnQpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZGlzcGxheU1vZGUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgZGlzcGxheU1vZGUgPSBEaXNwbGF5TW9kZS5GaXhlZDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0VuZ2luZSB2aWV3cG9ydCBpcyBzaXplICcgKyBvcHRpb25zLndpZHRoICsgJyB4ICcgKyBvcHRpb25zLmhlaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFvcHRpb25zLmRpc3BsYXlNb2RlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnRW5naW5lIHZpZXdwb3J0IGlzIGZpdCcpO1xyXG4gICAgICAgICAgICBkaXNwbGF5TW9kZSA9IERpc3BsYXlNb2RlLkZpdFNjcmVlbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKEZsYWdzLmlzRW5hYmxlZChMZWdhY3kuQ2FudmFzKSkge1xyXG4gICAgICAgICAgICBjb25zdCBleDJkQ3R4ID0gbmV3IEV4Y2FsaWJ1ckdyYXBoaWNzQ29udGV4dDJEQ2FudmFzKHtcclxuICAgICAgICAgICAgICAgIGNhbnZhc0VsZW1lbnQ6IHRoaXMuY2FudmFzLFxyXG4gICAgICAgICAgICAgICAgZW5hYmxlVHJhbnNwYXJlbmN5OiB0aGlzLmVuYWJsZUNhbnZhc1RyYW5zcGFyZW5jeSxcclxuICAgICAgICAgICAgICAgIHNtb290aGluZzogb3B0aW9ucy5hbnRpYWxpYXNpbmcsXHJcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLFxyXG4gICAgICAgICAgICAgICAgc25hcFRvUGl4ZWw6IG9wdGlvbnMuc25hcFRvUGl4ZWxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NDb250ZXh0ID0gZXgyZEN0eDtcclxuICAgICAgICAgICAgdGhpcy5jdHggPSBleDJkQ3R4Ll9fY3R4O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgY29uc3QgZXhXZWJnbEN0eCA9IG5ldyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHRXZWJHTCh7XHJcbiAgICAgICAgICAgICAgICBjYW52YXNFbGVtZW50OiB0aGlzLmNhbnZhcyxcclxuICAgICAgICAgICAgICAgIGVuYWJsZVRyYW5zcGFyZW5jeTogdGhpcy5lbmFibGVDYW52YXNUcmFuc3BhcmVuY3ksXHJcbiAgICAgICAgICAgICAgICBzbW9vdGhpbmc6IG9wdGlvbnMuYW50aWFsaWFzaW5nLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmJhY2tncm91bmRDb2xvcixcclxuICAgICAgICAgICAgICAgIHNuYXBUb1BpeGVsOiBvcHRpb25zLnNuYXBUb1BpeGVsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dCA9IGV4V2ViZ2xDdHg7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4ID0gZXhXZWJnbEN0eC5fX2N0eDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY3JlZW4gPSBuZXcgU2NyZWVuKHtcclxuICAgICAgICAgICAgY2FudmFzOiB0aGlzLmNhbnZhcyxcclxuICAgICAgICAgICAgY29udGV4dDogdGhpcy5ncmFwaGljc0NvbnRleHQsXHJcbiAgICAgICAgICAgIGFudGlhbGlhc2luZzogKF9iID0gb3B0aW9ucy5hbnRpYWxpYXNpbmcpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUsXHJcbiAgICAgICAgICAgIGJyb3dzZXI6IHRoaXMuYnJvd3NlcixcclxuICAgICAgICAgICAgdmlld3BvcnQ6IChfYyA9IG9wdGlvbnMudmlld3BvcnQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IChvcHRpb25zLndpZHRoICYmIG9wdGlvbnMuaGVpZ2h0ID8geyB3aWR0aDogb3B0aW9ucy53aWR0aCwgaGVpZ2h0OiBvcHRpb25zLmhlaWdodCB9IDogUmVzb2x1dGlvbi5TVkdBKSxcclxuICAgICAgICAgICAgcmVzb2x1dGlvbjogb3B0aW9ucy5yZXNvbHV0aW9uLFxyXG4gICAgICAgICAgICBkaXNwbGF5TW9kZSxcclxuICAgICAgICAgICAgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb24sXHJcbiAgICAgICAgICAgIHBpeGVsUmF0aW86IG9wdGlvbnMuc3VwcHJlc3NIaURQSVNjYWxpbmcgPyAxIDogbnVsbFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChvcHRpb25zLmJhY2tncm91bmRDb2xvcikge1xyXG4gICAgICAgICAgICB0aGlzLmJhY2tncm91bmRDb2xvciA9IG9wdGlvbnMuYmFja2dyb3VuZENvbG9yLmNsb25lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW5hYmxlQ2FudmFzVHJhbnNwYXJlbmN5ID0gb3B0aW9ucy5lbmFibGVDYW52YXNUcmFuc3BhcmVuY3k7XHJcbiAgICAgICAgdGhpcy5fbG9hZGVyID0gbmV3IExvYWRlcigpO1xyXG4gICAgICAgIHRoaXMuZGVidWcgPSBuZXcgRGVidWcodGhpcyk7XHJcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZShvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnJvb3RTY2VuZSA9IHRoaXMuY3VycmVudFNjZW5lID0gbmV3IFNjZW5lKCk7XHJcbiAgICAgICAgdGhpcy5hZGRTY2VuZSgncm9vdCcsIHRoaXMucm9vdFNjZW5lKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHdpZHRoIG9mIHRoZSBnYW1lIGNhbnZhcyBpbiBwaXhlbHMgKHBoeXNpY2FsIHdpZHRoIGNvbXBvbmVudCBvZiB0aGVcclxuICAgICAqIHJlc29sdXRpb24gb2YgdGhlIGNhbnZhcyBlbGVtZW50KVxyXG4gICAgICovXHJcbiAgICBnZXQgY2FudmFzV2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmNhbnZhc1dpZHRoO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhhbGYgd2lkdGggb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscyAoaGFsZiBwaHlzaWNhbCB3aWR0aCBjb21wb25lbnQpXHJcbiAgICAgKi9cclxuICAgIGdldCBoYWxmQ2FudmFzV2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmhhbGZDYW52YXNXaWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGhlaWdodCBvZiB0aGUgZ2FtZSBjYW52YXMgaW4gcGl4ZWxzLCAocGh5c2ljYWwgaGVpZ2h0IGNvbXBvbmVudCBvZlxyXG4gICAgICogdGhlIHJlc29sdXRpb24gb2YgdGhlIGNhbnZhcyBlbGVtZW50KVxyXG4gICAgICovXHJcbiAgICBnZXQgY2FudmFzSGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5jYW52YXNIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaGFsZiBoZWlnaHQgb2YgdGhlIGdhbWUgY2FudmFzIGluIHBpeGVscyAoaGFsZiBwaHlzaWNhbCBoZWlnaHQgY29tcG9uZW50KVxyXG4gICAgICovXHJcbiAgICBnZXQgaGFsZkNhbnZhc0hlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uaGFsZkNhbnZhc0hlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIGVuZ2luZSdzIHZpc2libGUgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscyBpbmNsdWRpbmcgem9vbSBhbmQgZGV2aWNlIHBpeGVsIHJhdGlvLlxyXG4gICAgICovXHJcbiAgICBnZXQgZHJhd1dpZHRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5kcmF3V2lkdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaGFsZiB0aGUgd2lkdGggb2YgdGhlIGVuZ2luZSdzIHZpc2libGUgZHJhd2luZyBzdXJmYWNlIGluIHBpeGVscyBpbmNsdWRpbmcgem9vbSBhbmQgZGV2aWNlIHBpeGVsIHJhdGlvLlxyXG4gICAgICovXHJcbiAgICBnZXQgaGFsZkRyYXdXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uaGFsZkRyYXdXaWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgaGVpZ2h0IG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGRyYXdIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmRyYXdIZWlnaHQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgaGFsZiB0aGUgaGVpZ2h0IG9mIHRoZSBlbmdpbmUncyB2aXNpYmxlIGRyYXdpbmcgc3VyZmFjZSBpbiBwaXhlbHMgaW5jbHVkaW5nIHpvb20gYW5kIGRldmljZSBwaXhlbCByYXRpby5cclxuICAgICAqL1xyXG4gICAgZ2V0IGhhbGZEcmF3SGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5oYWxmRHJhd0hlaWdodDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGV4Y2FsaWJ1ciBkZXRlY3RzIHRoZSBjdXJyZW50IHNjcmVlbiB0byBiZSBIaURQSVxyXG4gICAgICovXHJcbiAgICBnZXQgaXNIaURwaSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uaXNIaURwaTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWNjZXNzIFtbc3RhdHNdXSB0aGF0IGhvbGRzIGZyYW1lIHN0YXRpc3RpY3MuXHJcbiAgICAgKi9cclxuICAgIGdldCBzdGF0cygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5kZWJ1Zy5zdGF0cztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVuZ2luZSBpcyBzZXQgdG8gZnVsbHNjcmVlbiBvciBub3RcclxuICAgICAqL1xyXG4gICAgZ2V0IGlzRnVsbHNjcmVlbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uaXNGdWxsU2NyZWVuO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBJbmRpY2F0ZXMgdGhlIGN1cnJlbnQgW1tEaXNwbGF5TW9kZV1dIG9mIHRoZSBlbmdpbmUuXHJcbiAgICAgKi9cclxuICAgIGdldCBkaXNwbGF5TW9kZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uZGlzcGxheU1vZGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIGNhbGN1bGF0ZWQgcGl4ZWwgcmF0aW9uIGZvciB1c2UgaW4gcmVuZGVyaW5nXHJcbiAgICAgKi9cclxuICAgIGdldCBwaXhlbFJhdGlvKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5waXhlbFJhdGlvO1xyXG4gICAgfVxyXG4gICAgZ2V0IGlzRGVidWcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGVidWc7XHJcbiAgICB9XHJcbiAgICBvbihldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vbihldmVudE5hbWUsIGhhbmRsZXIpO1xyXG4gICAgfVxyXG4gICAgb25jZShldmVudE5hbWUsIGhhbmRsZXIpIHtcclxuICAgICAgICBzdXBlci5vbmNlKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICBvZmYoZXZlbnROYW1lLCBoYW5kbGVyKSB7XHJcbiAgICAgICAgc3VwZXIub2ZmKGV2ZW50TmFtZSwgaGFuZGxlcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgYSBCb3VuZGluZ0JveCBvZiB0aGUgdG9wIGxlZnQgY29ybmVyIG9mIHRoZSBzY3JlZW5cclxuICAgICAqIGFuZCB0aGUgYm90dG9tIHJpZ2h0IGNvcm5lciBvZiB0aGUgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICBnZXRXb3JsZEJvdW5kcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zY3JlZW4uZ2V0V29ybGRCb3VuZHMoKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBlbmdpbmUgdGltZXNjYWxlIGZhY3RvciAoZGVmYXVsdCBpcyAxLjAgd2hpY2ggaXMgMToxIHRpbWUpXHJcbiAgICAgKi9cclxuICAgIGdldCB0aW1lc2NhbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RpbWVzY2FsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBlbmdpbmUgdGltZXNjYWxlIGZhY3Rvci4gVXNlZnVsIGZvciBjcmVhdGluZyBzbG93LW1vdGlvbiBlZmZlY3RzIG9yIGZhc3QtZm9yd2FyZCBlZmZlY3RzXHJcbiAgICAgKiB3aGVuIHVzaW5nIHRpbWUtYmFzZWQgbW92ZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIHNldCB0aW1lc2NhbGUodmFsdWUpIHtcclxuICAgICAgICBpZiAodmFsdWUgPD0gMCkge1xyXG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ2Fubm90IHNldCBlbmdpbmUudGltZXNjYWxlIHRvIGEgdmFsdWUgb2YgMCBvciBsZXNzIHRoYW4gMC4nKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90aW1lc2NhbGUgPSB2YWx1ZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGxheXMgYSBzcHJpdGUgYW5pbWF0aW9uIG9uIHRoZSBzY3JlZW4gYXQgdGhlIHNwZWNpZmllZCBgeGAgYW5kIGB5YFxyXG4gICAgICogKGluIGdhbWUgY29vcmRpbmF0ZXMsIG5vdCBzY3JlZW4gcGl4ZWxzKS4gVGhlc2UgYW5pbWF0aW9ucyBwbGF5XHJcbiAgICAgKiBpbmRlcGVuZGVudCBvZiBhY3RvcnMsIGFuZCB3aWxsIGJlIGNsZWFuZWQgdXAgaW50ZXJuYWxseSBhcyBzb29uXHJcbiAgICAgKiBhcyB0aGV5IGFyZSBjb21wbGV0ZS4gTm90ZSBhbmltYXRpb25zIHRoYXQgbG9vcCB3aWxsIG5ldmVyIGJlXHJcbiAgICAgKiBjbGVhbmVkIHVwLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gIEFuaW1hdGlvbiB0byBwbGF5XHJcbiAgICAgKiBAcGFyYW0geCAgICAgICAgICB4IGdhbWUgY29vcmRpbmF0ZSB0byBwbGF5IHRoZSBhbmltYXRpb25cclxuICAgICAqIEBwYXJhbSB5ICAgICAgICAgIHkgZ2FtZSBjb29yZGluYXRlIHRvIHBsYXkgdGhlIGFuaW1hdGlvblxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgcGxheUFuaW1hdGlvbihhbmltYXRpb24sIHgsIHkpIHtcclxuICAgICAgICB0aGlzLl9hbmltYXRpb25zLnB1c2gobmV3IEFuaW1hdGlvbk5vZGUoYW5pbWF0aW9uLCB4LCB5KSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFkZHMgYSBbW1RpbGVNYXBdXSB0byB0aGUgW1tjdXJyZW50U2NlbmVdXSwgb25jZSB0aGlzIGlzIGRvbmUgdGhlIFRpbGVNYXBcclxuICAgICAqIHdpbGwgYmUgZHJhd24gYW5kIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIGFkZFRpbGVNYXAodGlsZU1hcCkge1xyXG4gICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmFkZFRpbGVNYXAodGlsZU1hcCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBbW1RpbGVNYXBdXSBmcm9tIHRoZSBbW2N1cnJlbnRTY2VuZV1dLCBpdCB3aWxsIG5vIGxvbmdlciBiZSBkcmF3biBvciB1cGRhdGVkLlxyXG4gICAgICovXHJcbiAgICByZW1vdmVUaWxlTWFwKHRpbGVNYXApIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5yZW1vdmVUaWxlTWFwKHRpbGVNYXApO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgW1tUaW1lcl1dIHRvIHRoZSBbW2N1cnJlbnRTY2VuZV1dLlxyXG4gICAgICogQHBhcmFtIHRpbWVyICBUaGUgdGltZXIgdG8gYWRkIHRvIHRoZSBbW2N1cnJlbnRTY2VuZV1dLlxyXG4gICAgICovXHJcbiAgICBhZGRUaW1lcih0aW1lcikge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTY2VuZS5hZGRUaW1lcih0aW1lcik7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlbW92ZXMgYSBbW1RpbWVyXV0gZnJvbSB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAqIEBwYXJhbSB0aW1lciAgVGhlIHRpbWVyIHRvIHJlbW92ZSB0byB0aGUgW1tjdXJyZW50U2NlbmVdXS5cclxuICAgICAqL1xyXG4gICAgcmVtb3ZlVGltZXIodGltZXIpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2NlbmUucmVtb3ZlVGltZXIodGltZXIpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIGEgW1tTY2VuZV1dIHRvIHRoZSBlbmdpbmUsIHRoaW5rIG9mIHNjZW5lcyBpbiBFeGNhbGlidXIgYXMgeW91XHJcbiAgICAgKiB3b3VsZCBsZXZlbHMgb3IgbWVudXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleSAgVGhlIG5hbWUgb2YgdGhlIHNjZW5lLCBtdXN0IGJlIHVuaXF1ZVxyXG4gICAgICogQHBhcmFtIHNjZW5lIFRoZSBzY2VuZSB0byBhZGQgdG8gdGhlIGVuZ2luZVxyXG4gICAgICovXHJcbiAgICBhZGRTY2VuZShrZXksIHNjZW5lKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2NlbmVzW2tleV0pIHtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLndhcm4oJ1NjZW5lJywga2V5LCAnYWxyZWFkeSBleGlzdHMgb3ZlcndyaXRpbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5zY2VuZXNba2V5XSA9IHNjZW5lO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAaW50ZXJuYWxcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlU2NlbmUoZW50aXR5KSB7XHJcbiAgICAgICAgaWYgKGVudGl0eSBpbnN0YW5jZW9mIFNjZW5lKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBzY2VuZVxyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLnNjZW5lcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2NlbmVzLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zY2VuZXNba2V5XSA9PT0gZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lc1trZXldO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgLy8gcmVtb3ZlIHNjZW5lXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjZW5lc1tlbnRpdHldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGFkZChlbnRpdHkpIHtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICAgICAgICB0aGlzLmFkZFNjZW5lKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGVmZXJyZWRHb1RvICYmIHRoaXMuc2NlbmVzW3RoaXMuX2RlZmVycmVkR29Ub10pIHtcclxuICAgICAgICAgICAgdGhpcy5zY2VuZXNbdGhpcy5fZGVmZXJyZWRHb1RvXS5hZGQoZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLmFkZChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJlbW92ZShlbnRpdHkpIHtcclxuICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgRW50aXR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLnJlbW92ZShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW50aXR5IGluc3RhbmNlb2YgU2NlbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVTY2VuZShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGVudGl0eSA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVTY2VuZShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2hhbmdlcyB0aGUgY3VycmVudGx5IHVwZGF0aW5nIGFuZCBkcmF3aW5nIHNjZW5lIHRvIGEgZGlmZmVyZW50LFxyXG4gICAgICogbmFtZWQgc2NlbmUuIENhbGxzIHRoZSBbW1NjZW5lXV0gbGlmZWN5Y2xlIGV2ZW50cy5cclxuICAgICAqIEBwYXJhbSBrZXkgIFRoZSBrZXkgb2YgdGhlIHNjZW5lIHRvIHRyYW5zaXRpb24gdG8uXHJcbiAgICAgKi9cclxuICAgIGdvVG9TY2VuZShrZXkpIHtcclxuICAgICAgICAvLyBpZiBub3QgeWV0IGluaXRpYWxpemVkIGRlZmVyIGdvVG9TY2VuZVxyXG4gICAgICAgIGlmICghdGhpcy5pc0luaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RlZmVycmVkR29UbyA9IGtleTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5zY2VuZXNba2V5XSkge1xyXG4gICAgICAgICAgICBjb25zdCBvbGRTY2VuZSA9IHRoaXMuY3VycmVudFNjZW5lO1xyXG4gICAgICAgICAgICBjb25zdCBuZXdTY2VuZSA9IHRoaXMuc2NlbmVzW2tleV07XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnR29pbmcgdG8gc2NlbmU6Jywga2V5KTtcclxuICAgICAgICAgICAgLy8gb25seSBkZWFjdGl2YXRlIHdoZW4gaW5pdGlhbGl6ZWRcclxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFNjZW5lLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLl9kZWFjdGl2YXRlLmFwcGx5KHRoaXMuY3VycmVudFNjZW5lLCBbb2xkU2NlbmUsIG5ld1NjZW5lXSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5ldmVudERpc3BhdGNoZXIuZW1pdCgnZGVhY3RpdmF0ZScsIG5ldyBEZWFjdGl2YXRlRXZlbnQobmV3U2NlbmUsIHRoaXMuY3VycmVudFNjZW5lKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gc2V0IGN1cnJlbnQgc2NlbmUgdG8gbmV3IG9uZVxyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZSA9IG5ld1NjZW5lO1xyXG4gICAgICAgICAgICB0aGlzLnNjcmVlbi5zZXRDdXJyZW50Q2FtZXJhKG5ld1NjZW5lLmNhbWVyYSk7XHJcbiAgICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIGN1cnJlbnQgc2NlbmUgaWYgaGFzIG5vdCBiZWVuIGFscmVhZHlcclxuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuX2luaXRpYWxpemUodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNjZW5lLl9hY3RpdmF0ZS5hcHBseSh0aGlzLmN1cnJlbnRTY2VuZSwgW29sZFNjZW5lLCBuZXdTY2VuZV0pO1xyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTY2VuZS5ldmVudERpc3BhdGNoZXIuZW1pdCgnYWN0aXZhdGUnLCBuZXcgQWN0aXZhdGVFdmVudChvbGRTY2VuZSwgdGhpcy5jdXJyZW50U2NlbmUpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5lcnJvcignU2NlbmUnLCBrZXksICdkb2VzIG5vdCBleGlzdCEnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybXMgdGhlIGN1cnJlbnQgeCwgeSBmcm9tIHNjcmVlbiBjb29yZGluYXRlcyB0byB3b3JsZCBjb29yZGluYXRlc1xyXG4gICAgICogQHBhcmFtIHBvaW50ICBTY3JlZW4gY29vcmRpbmF0ZSB0byBjb252ZXJ0XHJcbiAgICAgKi9cclxuICAgIHNjcmVlblRvV29ybGRDb29yZGluYXRlcyhwb2ludCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnNjcmVlbi5zY3JlZW5Ub1dvcmxkQ29vcmRpbmF0ZXMocG9pbnQpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUcmFuc2Zvcm1zIGEgd29ybGQgY29vcmRpbmF0ZSwgdG8gYSBzY3JlZW4gY29vcmRpbmF0ZVxyXG4gICAgICogQHBhcmFtIHBvaW50ICBXb3JsZCBjb29yZGluYXRlIHRvIGNvbnZlcnRcclxuICAgICAqL1xyXG4gICAgd29ybGRUb1NjcmVlbkNvb3JkaW5hdGVzKHBvaW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLndvcmxkVG9TY3JlZW5Db29yZGluYXRlcyhwb2ludCk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluaXRpYWxpemVzIHRoZSBpbnRlcm5hbCBjYW52YXMsIHJlbmRlcmluZyBjb250ZXh0LCBkaXNwbGF5IG1vZGUsIGFuZCBuYXRpdmUgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICAgKi9cclxuICAgIF9pbml0aWFsaXplKG9wdGlvbnMpIHtcclxuICAgICAgICB0aGlzLnBhZ2VTY3JvbGxQcmV2ZW50aW9uTW9kZSA9IG9wdGlvbnMuc2Nyb2xsUHJldmVudGlvbk1vZGU7XHJcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBpbnB1dHNcclxuICAgICAgICB0aGlzLmlucHV0ID0ge1xyXG4gICAgICAgICAgICBrZXlib2FyZDogbmV3IEtleWJvYXJkKCksXHJcbiAgICAgICAgICAgIHBvaW50ZXJzOiBuZXcgUG9pbnRlcnModGhpcyksXHJcbiAgICAgICAgICAgIGdhbWVwYWRzOiBuZXcgR2FtZXBhZHMoKVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5pbnB1dC5rZXlib2FyZC5pbml0KCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5wb2ludGVycy5pbml0KG9wdGlvbnMgJiYgb3B0aW9ucy5wb2ludGVyU2NvcGUgPT09IFBvaW50ZXJTY29wZS5Eb2N1bWVudCA/IGRvY3VtZW50IDogdGhpcy5jYW52YXMpO1xyXG4gICAgICAgIHRoaXMuaW5wdXQuZ2FtZXBhZHMuaW5pdCgpO1xyXG4gICAgICAgIC8vIElzc3VlICMzODUgbWFrZSB1c2Ugb2YgdGhlIHZpc2liaWxpdHkgYXBpXHJcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvR3VpZGUvVXNlcl9leHBlcmllbmNlL1VzaW5nX3RoZV9QYWdlX1Zpc2liaWxpdHlfQVBJXHJcbiAgICAgICAgbGV0IGhpZGRlbiwgdmlzaWJpbGl0eUNoYW5nZTtcclxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50LmhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgLy8gT3BlcmEgMTIuMTAgYW5kIEZpcmVmb3ggMTggYW5kIGxhdGVyIHN1cHBvcnRcclxuICAgICAgICAgICAgaGlkZGVuID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgIHZpc2liaWxpdHlDaGFuZ2UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCdtc0hpZGRlbicgaW4gZG9jdW1lbnQpIHtcclxuICAgICAgICAgICAgaGlkZGVuID0gJ21zSGlkZGVuJztcclxuICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICdtc3Zpc2liaWxpdHljaGFuZ2UnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICgnd2Via2l0SGlkZGVuJyBpbiBkb2N1bWVudCkge1xyXG4gICAgICAgICAgICBoaWRkZW4gPSAnd2Via2l0SGlkZGVuJztcclxuICAgICAgICAgICAgdmlzaWJpbGl0eUNoYW5nZSA9ICd3ZWJraXR2aXNpYmlsaXR5Y2hhbmdlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5icm93c2VyLmRvY3VtZW50Lm9uKHZpc2liaWxpdHlDaGFuZ2UsICgpID0+IHtcclxuICAgICAgICAgICAgaWYgKGRvY3VtZW50W2hpZGRlbl0pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ2hpZGRlbicsIG5ldyBIaWRkZW5FdmVudCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ1dpbmRvdyBoaWRkZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnREaXNwYXRjaGVyLmVtaXQoJ3Zpc2libGUnLCBuZXcgVmlzaWJsZUV2ZW50KHRoaXMpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xvZ2dlci5kZWJ1ZygnV2luZG93IHZpc2libGUnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghdGhpcy5jYW52YXNFbGVtZW50SWQgJiYgIW9wdGlvbnMuY2FudmFzRWxlbWVudCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuY2FudmFzKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBvbkluaXRpYWxpemUoX2VuZ2luZSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIElmIHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciwgdGhpcyB3aWxsIHNldCB0aGUgYW50aWFsaWFzaW5nIGZsYWcgb24gdGhlXHJcbiAgICAgKiBjYW52YXMuIFNldCB0aGlzIHRvIGBmYWxzZWAgaWYgeW91IHdhbnQgYSAnamFnZ2VkJyBwaXhlbCBhcnQgbG9vayB0byB5b3VyXHJcbiAgICAgKiBpbWFnZSByZXNvdXJjZXMuXHJcbiAgICAgKiBAcGFyYW0gaXNTbW9vdGggIFNldCBzbW9vdGhpbmcgdG8gdHJ1ZSBvciBmYWxzZVxyXG4gICAgICovXHJcbiAgICBzZXRBbnRpYWxpYXNpbmcoaXNTbW9vdGgpIHtcclxuICAgICAgICB0aGlzLnNjcmVlbi5hbnRpYWxpYXNpbmcgPSBpc1Ntb290aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIHRoZSBjdXJyZW50IHNtb290aGluZyBzdGF0dXMgb2YgdGhlIGNhbnZhc1xyXG4gICAgICovXHJcbiAgICBnZXRBbnRpYWxpYXNpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuLmFudGlhbGlhc2luZztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyB3aGV0aGVyIHRoZSBhY3RvciBpcyBJbml0aWFsaXplZFxyXG4gICAgICovXHJcbiAgICBnZXQgaXNJbml0aWFsaXplZCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNJbml0aWFsaXplZDtcclxuICAgIH1cclxuICAgIF9vdmVycmlkZUluaXRpYWxpemUoZW5naW5lKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5vbkluaXRpYWxpemUoZW5naW5lKTtcclxuICAgICAgICAgICAgc3VwZXIuZW1pdCgnaW5pdGlhbGl6ZScsIG5ldyBJbml0aWFsaXplRXZlbnQoZW5naW5lLCB0aGlzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzSW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fZGVmZXJyZWRHb1RvKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmdvVG9TY2VuZSh0aGlzLl9kZWZlcnJlZEdvVG8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5nb1RvU2NlbmUoJ3Jvb3QnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgZW50aXJlIHN0YXRlIG9mIHRoZSBnYW1lXHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB1cGRhdGUuXHJcbiAgICAgKi9cclxuICAgIF91cGRhdGUoZGVsdGEpIHtcclxuICAgICAgICBpZiAodGhpcy5faXNMb2FkaW5nKSB7XHJcbiAgICAgICAgICAgIC8vIHN1c3BlbmQgdXBkYXRlcyB1bnRpbCBsb2FkaW5nIGlzIGZpbmlzaGVkXHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci51cGRhdGUodGhpcywgZGVsdGEpO1xyXG4gICAgICAgICAgICAvLyBVcGRhdGUgaW5wdXQgbGlzdGVuZXJzXHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQua2V5Ym9hcmQudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQucG9pbnRlcnMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQuZ2FtZXBhZHMudXBkYXRlKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fb3ZlcnJpZGVJbml0aWFsaXplKHRoaXMpO1xyXG4gICAgICAgIC8vIFB1Ymxpc2ggcHJldXBkYXRlIGV2ZW50c1xyXG4gICAgICAgIHRoaXMuX3ByZXVwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgLy8gcHJvY2VzcyBlbmdpbmUgbGV2ZWwgZXZlbnRzXHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUudXBkYXRlKHRoaXMsIGRlbHRhKTtcclxuICAgICAgICAvLyB1cGRhdGUgYW5pbWF0aW9uc1xyXG4gICAgICAgIC8vIFRPRE8gcmVtb3ZlXHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9ucyA9IHRoaXMuX2FuaW1hdGlvbnMuZmlsdGVyKGZ1bmN0aW9uIChhKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhYS5hbmltYXRpb24uaXNEb25lKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gVXBkYXRlIGlucHV0IGxpc3RlbmVyc1xyXG4gICAgICAgIHRoaXMuaW5wdXQua2V5Ym9hcmQudXBkYXRlKCk7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5wb2ludGVycy51cGRhdGUoKTtcclxuICAgICAgICB0aGlzLmlucHV0LmdhbWVwYWRzLnVwZGF0ZSgpO1xyXG4gICAgICAgIC8vIFB1Ymxpc2ggdXBkYXRlIGV2ZW50XHJcbiAgICAgICAgdGhpcy5fcG9zdHVwZGF0ZShkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcHJldXBkYXRlKGRlbHRhKSB7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwcmV1cGRhdGUnLCBuZXcgUHJlVXBkYXRlRXZlbnQodGhpcywgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUHJlVXBkYXRlKHRoaXMsIGRlbHRhKTtcclxuICAgIH1cclxuICAgIG9uUHJlVXBkYXRlKF9lbmdpbmUsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcG9zdHVwZGF0ZShkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdHVwZGF0ZScsIG5ldyBQb3N0VXBkYXRlRXZlbnQodGhpcywgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUG9zdFVwZGF0ZSh0aGlzLCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICBvblBvc3RVcGRhdGUoX2VuZ2luZSwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRHJhd3MgdGhlIGVudGlyZSBnYW1lXHJcbiAgICAgKiBAcGFyYW0gZGVsdGEgIE51bWJlciBvZiBtaWxsaXNlY29uZHMgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCBkcmF3LlxyXG4gICAgICovXHJcbiAgICBfZHJhdyhkZWx0YSkge1xyXG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xyXG4gICAgICAgIHRoaXMuX3ByZWRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzTG9hZGluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIuY2FudmFzLmRyYXcodGhpcy5ncmFwaGljc0NvbnRleHQsIDAsIDApO1xyXG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzQ29udGV4dC5mbHVzaCgpO1xyXG4gICAgICAgICAgICAvLyBEcmF3aW5nIG5vdGhpbmcgZWxzZSB3aGlsZSBsb2FkaW5nXHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gVE9ETyBtb3ZlIHRvIGdyYXBoaWNzIHN5c3RlbXM/XHJcbiAgICAgICAgdGhpcy5ncmFwaGljc0NvbnRleHQuYmFja2dyb3VuZENvbG9yID0gdGhpcy5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U2NlbmUuZHJhdyh0aGlzLmN0eCwgZGVsdGEpO1xyXG4gICAgICAgIC8vIHRvZG8gbmVlZHMgdG8gYmUgYSBiZXR0ZXIgd2F5IG9mIGRvaW5nIHRoaXNcclxuICAgICAgICBsZXQgYSA9IDA7XHJcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5fYW5pbWF0aW9ucy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChhOyBhIDwgbGVuOyBhKyspIHtcclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uc1thXS5hbmltYXRpb24uZHJhdyhjdHgsIHRoaXMuX2FuaW1hdGlvbnNbYV0ueCwgdGhpcy5fYW5pbWF0aW9uc1thXS55KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRHJhdyBkZWJ1ZyBpbmZvcm1hdGlvblxyXG4gICAgICAgIC8vIFRPRE8gZG9uJ3QgYWNjZXNzIGN0eCBkaXJlY3RseVxyXG4gICAgICAgIGlmICh0aGlzLmlzRGVidWcpIHtcclxuICAgICAgICAgICAgdGhpcy5jdHguZm9udCA9ICdDb25zb2xhcyc7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IHRoaXMuZGVidWdDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjb25zdCBrZXlzID0gdGhpcy5pbnB1dC5rZXlib2FyZC5nZXRLZXlzKCk7XHJcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoa2V5c1tqXS50b1N0cmluZygpICsgJyA6ICcgKyAoS2V5c1trZXlzW2pdXSA/IEtleXNba2V5c1tqXV0gOiAnTm90IE1hcHBlZCcpLCAxMDAsIDEwICogaiArIDEwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmN0eC5maWxsVGV4dCgnRlBTOicgKyB0aGlzLnN0YXRzLmN1cnJGcmFtZS5mcHMudG9GaXhlZCgyKS50b1N0cmluZygpLCAxMCwgMTApO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBQb3N0IHByb2Nlc3NpbmdcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucG9zdFByb2Nlc3NvcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgdGhpcy5wb3N0UHJvY2Vzc29yc1tpXS5wcm9jZXNzKHRoaXMuY3R4LmdldEltYWdlRGF0YSgwLCAwLCB0aGlzLmNhbnZhc1dpZHRoLCB0aGlzLmNhbnZhc0hlaWdodCksIHRoaXMuY3R4KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fcG9zdGRyYXcoY3R4LCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBpbnRlcm5hbFxyXG4gICAgICovXHJcbiAgICBfcHJlZHJhdyhfY3R4LCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncHJlZHJhdycsIG5ldyBQcmVEcmF3RXZlbnQoX2N0eCwgZGVsdGEsIHRoaXMpKTtcclxuICAgICAgICB0aGlzLm9uUHJlRHJhdyhfY3R4LCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICBvblByZURyYXcoX2N0eCwgX2RlbHRhKSB7XHJcbiAgICAgICAgLy8gT3ZlcnJpZGUgbWVcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQGludGVybmFsXHJcbiAgICAgKi9cclxuICAgIF9wb3N0ZHJhdyhfY3R4LCBkZWx0YSkge1xyXG4gICAgICAgIHRoaXMuZW1pdCgncG9zdGRyYXcnLCBuZXcgUG9zdERyYXdFdmVudChfY3R4LCBkZWx0YSwgdGhpcykpO1xyXG4gICAgICAgIHRoaXMub25Qb3N0RHJhdyhfY3R4LCBkZWx0YSk7XHJcbiAgICB9XHJcbiAgICBvblBvc3REcmF3KF9jdHgsIF9kZWx0YSkge1xyXG4gICAgICAgIC8vIE92ZXJyaWRlIG1lXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSBvciBkaXNhYmxlIEV4Y2FsaWJ1ciBkZWJ1Z2dpbmcgZnVuY3Rpb25hbGl0eS5cclxuICAgICAqIEBwYXJhbSB0b2dnbGUgYSB2YWx1ZSB0aGF0IGRlYnVnIGRyYXdpbmcgd2lsbCBiZSBjaGFuZ2VkIHRvXHJcbiAgICAgKi9cclxuICAgIHNob3dEZWJ1Zyh0b2dnbGUpIHtcclxuICAgICAgICB0aGlzLl9pc0RlYnVnID0gdG9nZ2xlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUb2dnbGUgRXhjYWxpYnVyIGRlYnVnZ2luZyBmdW5jdGlvbmFsaXR5LlxyXG4gICAgICovXHJcbiAgICB0b2dnbGVEZWJ1ZygpIHtcclxuICAgICAgICB0aGlzLl9pc0RlYnVnID0gIXRoaXMuX2lzRGVidWc7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGVidWc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdHJ1ZSB3aGVuIGxvYWRpbmcgaXMgdG90YWxseSBjb21wbGV0ZSBhbmQgdGhlIHBsYXllciBoYXMgY2xpY2tlZCBzdGFydFxyXG4gICAgICovXHJcbiAgICBnZXQgbG9hZGluZ0NvbXBsZXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9sb2FkaW5nQ29tcGxldGU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0YXJ0cyB0aGUgaW50ZXJuYWwgZ2FtZSBsb29wIGZvciBFeGNhbGlidXIgYWZ0ZXIgbG9hZGluZ1xyXG4gICAgICogYW55IHByb3ZpZGVkIGFzc2V0cy5cclxuICAgICAqIEBwYXJhbSBsb2FkZXIgIE9wdGlvbmFsIFtbTG9hZGVyXV0gdG8gdXNlIHRvIGxvYWQgcmVzb3VyY2VzLiBUaGUgZGVmYXVsdCBsb2FkZXIgaXMgW1tMb2FkZXJdXSwgb3ZlcnJpZGUgdG8gcHJvdmlkZSB5b3VyIG93blxyXG4gICAgICogY3VzdG9tIGxvYWRlci5cclxuICAgICAqL1xyXG4gICAgc3RhcnQobG9hZGVyKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jb21wYXRpYmxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCgnRXhjYWxpYnVyIGlzIGluY29tcGF0aWJsZSB3aXRoIHlvdXIgYnJvd3NlcicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgbG9hZGluZ0NvbXBsZXRlO1xyXG4gICAgICAgIC8vIFB1c2ggdGhlIGN1cnJlbnQgdXNlciBlbnRlcmVkIHJlc29sdXRpb24vdmlld3BvcnRcclxuICAgICAgICB0aGlzLnNjcmVlbi5wdXNoUmVzb2x1dGlvbkFuZFZpZXdwb3J0KCk7XHJcbiAgICAgICAgLy8gQ29uZmlndXJlIHJlc29sdXRpb24gZm9yIGxvYWRlclxyXG4gICAgICAgIHRoaXMuc2NyZWVuLnJlc29sdXRpb24gPSB0aGlzLnNjcmVlbi52aWV3cG9ydDtcclxuICAgICAgICB0aGlzLnNjcmVlbi5hcHBseVJlc29sdXRpb25BbmRWaWV3cG9ydCgpO1xyXG4gICAgICAgIHRoaXMuZ3JhcGhpY3NDb250ZXh0LnVwZGF0ZVZpZXdwb3J0KCk7XHJcbiAgICAgICAgaWYgKGxvYWRlcikge1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkZXIgPSBsb2FkZXI7XHJcbiAgICAgICAgICAgIHRoaXMuX2xvYWRlci5zdXBwcmVzc1BsYXlCdXR0b24gPSB0aGlzLl9zdXBwcmVzc1BsYXlCdXR0b24gfHwgdGhpcy5fbG9hZGVyLnN1cHByZXNzUGxheUJ1dHRvbjtcclxuICAgICAgICAgICAgdGhpcy5fbG9hZGVyLndpcmVFbmdpbmUodGhpcyk7XHJcbiAgICAgICAgICAgIGxvYWRpbmdDb21wbGV0ZSA9IHRoaXMubG9hZCh0aGlzLl9sb2FkZXIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgbG9hZGluZ0NvbXBsZXRlID0gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxvYWRpbmdDb21wbGV0ZS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5zY3JlZW4ucG9wUmVzb2x1dGlvbkFuZFZpZXdwb3J0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuc2NyZWVuLmFwcGx5UmVzb2x1dGlvbkFuZFZpZXdwb3J0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZ3JhcGhpY3NDb250ZXh0LnVwZGF0ZVZpZXdwb3J0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RhcnQnLCBuZXcgR2FtZVN0YXJ0RXZlbnQodGhpcykpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2FkaW5nQ29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICghdGhpcy5faGFzU3RhcnRlZCkge1xyXG4gICAgICAgICAgICAvLyBoYXMgc3RhcnRlZCBpcyBhIHNsaWdodCBtaXNub21lciwgaXQncyByZWFsbHkgbWFpbmxvb3Agc3RhcnRlZFxyXG4gICAgICAgICAgICB0aGlzLl9oYXNTdGFydGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdTdGFydGluZyBnYW1lLi4uJyk7XHJcbiAgICAgICAgICAgIHRoaXMuYnJvd3Nlci5yZXN1bWUoKTtcclxuICAgICAgICAgICAgRW5naW5lLmNyZWF0ZU1haW5Mb29wKHRoaXMsIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIERhdGUubm93KSgpO1xyXG4gICAgICAgICAgICB0aGlzLl9sb2dnZXIuZGVidWcoJ0dhbWUgc3RhcnRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLy8gR2FtZSBhbHJlYWR5IHN0YXJ0ZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBsb2FkaW5nQ29tcGxldGU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgY3JlYXRlTWFpbkxvb3AoZ2FtZSwgcmFmLCBub3dGbikge1xyXG4gICAgICAgIGxldCBsYXN0VGltZSA9IG5vd0ZuKCk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1haW5sb29wKCkge1xyXG4gICAgICAgICAgICBpZiAoIWdhbWUuX2hhc1N0YXJ0ZWQpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgZ2FtZS5fcmVxdWVzdElkID0gcmFmKG1haW5sb29wKTtcclxuICAgICAgICAgICAgICAgIGdhbWUuZW1pdCgncHJlZnJhbWUnLCBuZXcgUHJlRnJhbWVFdmVudChnYW1lLCBnYW1lLnN0YXRzLnByZXZGcmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0aW1lIHRvIGNhbGN1bGF0ZSB0aW1lLWVsYXBzZWRcclxuICAgICAgICAgICAgICAgIGNvbnN0IG5vdyA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgICAgICBsZXQgZWxhcHNlZCA9IE1hdGguZmxvb3Iobm93IC0gbGFzdFRpbWUpIHx8IDE7XHJcbiAgICAgICAgICAgICAgICAvLyBSZXNvbHZlcyBpc3N1ZSAjMTM4IGlmIHRoZSBnYW1lIGhhcyBiZWVuIHBhdXNlZCwgb3IgYmx1cnJlZCBmb3JcclxuICAgICAgICAgICAgICAgIC8vIG1vcmUgdGhhbiBhIDIwMCBtaWxsaXNlY29uZHMsIHJlc2V0IGVsYXBzZWQgdGltZSB0byAxLiBUaGlzIGltcHJvdmVzIHJlbGlhYmlsaXR5XHJcbiAgICAgICAgICAgICAgICAvLyBhbmQgcHJvdmlkZXMgbW9yZSBleHBlY3RlZCBiZWhhdmlvciB3aGVuIHRoZSBlbmdpbmUgY29tZXMgYmFja1xyXG4gICAgICAgICAgICAgICAgLy8gaW50byBmb2N1c1xyXG4gICAgICAgICAgICAgICAgaWYgKGVsYXBzZWQgPiAyMDApIHtcclxuICAgICAgICAgICAgICAgICAgICBlbGFwc2VkID0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZWxhcHNlZCAqIGdhbWUudGltZXNjYWxlO1xyXG4gICAgICAgICAgICAgICAgLy8gcmVzZXQgZnJhbWUgc3RhdHMgKHJldXNlIGV4aXN0aW5nIGluc3RhbmNlcylcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZyYW1lSWQgPSBnYW1lLnN0YXRzLnByZXZGcmFtZS5pZCArIDE7XHJcbiAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5yZXNldCgpO1xyXG4gICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUuaWQgPSBmcmFtZUlkO1xyXG4gICAgICAgICAgICAgICAgZ2FtZS5zdGF0cy5jdXJyRnJhbWUuZGVsdGEgPSBkZWx0YTtcclxuICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMuY3VyckZyYW1lLmZwcyA9IDEuMCAvIChkZWx0YSAvIDEwMDApO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlVXBkYXRlID0gbm93Rm4oKTtcclxuICAgICAgICAgICAgICAgIGdhbWUuX3VwZGF0ZShkZWx0YSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBhZnRlclVwZGF0ZSA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgICAgICBnYW1lLl9kcmF3KGRlbHRhKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyRHJhdyA9IG5vd0ZuKCk7XHJcbiAgICAgICAgICAgICAgICBnYW1lLnN0YXRzLmN1cnJGcmFtZS5kdXJhdGlvbi51cGRhdGUgPSBhZnRlclVwZGF0ZSAtIGJlZm9yZVVwZGF0ZTtcclxuICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMuY3VyckZyYW1lLmR1cmF0aW9uLmRyYXcgPSBhZnRlckRyYXcgLSBhZnRlclVwZGF0ZTtcclxuICAgICAgICAgICAgICAgIGxhc3RUaW1lID0gbm93O1xyXG4gICAgICAgICAgICAgICAgZ2FtZS5lbWl0KCdwb3N0ZnJhbWUnLCBuZXcgUG9zdEZyYW1lRXZlbnQoZ2FtZSwgZ2FtZS5zdGF0cy5jdXJyRnJhbWUpKTtcclxuICAgICAgICAgICAgICAgIGdhbWUuc3RhdHMucHJldkZyYW1lLnJlc2V0KGdhbWUuc3RhdHMuY3VyckZyYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKGdhbWUuX3JlcXVlc3RJZCk7XHJcbiAgICAgICAgICAgICAgICBnYW1lLnN0b3AoKTtcclxuICAgICAgICAgICAgICAgIGdhbWUub25GYXRhbEV4Y2VwdGlvbihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIEV4Y2FsaWJ1cidzIG1haW4gbG9vcCwgdXNlZnVsIGZvciBwYXVzaW5nIHRoZSBnYW1lLlxyXG4gICAgICovXHJcbiAgICBzdG9wKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9oYXNTdGFydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc3RvcCcsIG5ldyBHYW1lU3RvcEV2ZW50KHRoaXMpKTtcclxuICAgICAgICAgICAgdGhpcy5icm93c2VyLnBhdXNlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hhc1N0YXJ0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fbG9nZ2VyLmRlYnVnKCdHYW1lIHN0b3BwZWQnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIEVuZ2luZSdzIFJ1bm5pbmcgc3RhdHVzLCBVc2VmdWwgZm9yIGNoZWNraW5nIHdoZXRoZXIgZW5naW5lIGlzIHJ1bm5pbmcgb3IgcGF1c2VkLlxyXG4gICAgICovXHJcbiAgICBpc1BhdXNlZCgpIHtcclxuICAgICAgICByZXR1cm4gIXRoaXMuX2hhc1N0YXJ0ZWQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRha2VzIGEgc2NyZWVuIHNob3Qgb2YgdGhlIGN1cnJlbnQgdmlld3BvcnQgYW5kIHJldHVybnMgaXQgYXMgYW5cclxuICAgICAqIEhUTUwgSW1hZ2UgRWxlbWVudC5cclxuICAgICAqL1xyXG4gICAgc2NyZWVuc2hvdCgpIHtcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICBjb25zdCByYXcgPSB0aGlzLmNhbnZhcy50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xyXG4gICAgICAgIHJlc3VsdC5zcmMgPSByYXc7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQW5vdGhlciBvcHRpb24gYXZhaWxhYmxlIHRvIHlvdSB0byBsb2FkIHJlc291cmNlcyBpbnRvIHRoZSBnYW1lLlxyXG4gICAgICogSW1tZWRpYXRlbHkgYWZ0ZXIgY2FsbGluZyB0aGlzIHRoZSBnYW1lIHdpbGwgcGF1c2UgYW5kIHRoZSBsb2FkaW5nIHNjcmVlblxyXG4gICAgICogd2lsbCBhcHBlYXIuXHJcbiAgICAgKiBAcGFyYW0gbG9hZGVyICBTb21lIFtbTG9hZGFibGVdXSBzdWNoIGFzIGEgW1tMb2FkZXJdXSBjb2xsZWN0aW9uLCBbW1NvdW5kXV0sIG9yIFtbVGV4dHVyZV1dLlxyXG4gICAgICovXHJcbiAgICBsb2FkKGxvYWRlcikge1xyXG4gICAgICAgIGNvbnN0IGNvbXBsZXRlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gdHJ1ZTtcclxuICAgICAgICAgICAgbG9hZGVyLmxvYWQoKS50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zdXBwcmVzc1BsYXlCdXR0b24pIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVsYXkgaXMgdG8gZ2l2ZSB0aGUgbG9nbyBhIGNoYW5jZSB0byBzaG93LCBvdGhlcndpc2UgZG9uJ3QgZGVsYXlcclxuICAgICAgICAgICAgICAgICAgICB9LCA1MDApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNMb2FkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gY29tcGxldGU7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERlZmF1bHQgW1tFbmdpbmVPcHRpb25zXV1cclxuICovXHJcbkVuZ2luZS5fREVGQVVMVF9FTkdJTkVfT1BUSU9OUyA9IHtcclxuICAgIHdpZHRoOiAwLFxyXG4gICAgaGVpZ2h0OiAwLFxyXG4gICAgZW5hYmxlQ2FudmFzVHJhbnNwYXJlbmN5OiB0cnVlLFxyXG4gICAgY2FudmFzRWxlbWVudElkOiAnJyxcclxuICAgIGNhbnZhc0VsZW1lbnQ6IHVuZGVmaW5lZCxcclxuICAgIHNuYXBUb1BpeGVsOiBmYWxzZSxcclxuICAgIHBvaW50ZXJTY29wZTogUG9pbnRlclNjb3BlLkNhbnZhcyxcclxuICAgIHN1cHByZXNzQ29uc29sZUJvb3RNZXNzYWdlOiBudWxsLFxyXG4gICAgc3VwcHJlc3NNaW5pbXVtQnJvd3NlckZlYXR1cmVEZXRlY3Rpb246IG51bGwsXHJcbiAgICBzdXBwcmVzc0hpRFBJU2NhbGluZzogbnVsbCxcclxuICAgIHN1cHByZXNzUGxheUJ1dHRvbjogbnVsbCxcclxuICAgIHNjcm9sbFByZXZlbnRpb25Nb2RlOiBTY3JvbGxQcmV2ZW50aW9uTW9kZS5DYW52YXMsXHJcbiAgICBiYWNrZ3JvdW5kQ29sb3I6IENvbG9yLmZyb21IZXgoJyMyMTg1ZDAnKSAvLyBFeGNhbGlidXIgYmx1ZVxyXG59O1xyXG5FbmdpbmVfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnV2lsbCBiZSByZW1vdmVkIGluIGV4Y2FsaWJ1ciB2MC4yNi4wJywgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIEFjdG9yLmdyYXBoaWNzJyB9KVxyXG5dLCBFbmdpbmUucHJvdG90eXBlLCBcInBsYXlBbmltYXRpb25cIiwgbnVsbCk7XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQGRlcHJlY2F0ZWRcclxuICovXHJcbmxldCBBbmltYXRpb25Ob2RlID0gY2xhc3MgQW5pbWF0aW9uTm9kZSB7XHJcbiAgICBjb25zdHJ1Y3RvcihhbmltYXRpb24sIHgsIHkpIHtcclxuICAgICAgICB0aGlzLmFuaW1hdGlvbiA9IGFuaW1hdGlvbjtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICB9XHJcbn07XHJcbkFuaW1hdGlvbk5vZGUgPSBFbmdpbmVfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnV2lsbCBiZSByZW1vdmVkIGluIGV4Y2FsaWJ1ciB2MC4yNi4wJyB9KVxyXG5dLCBBbmltYXRpb25Ob2RlKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9NYXRoL0luZGV4LnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRGVidWcvaW5kZXgudHNcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vRXZlbnRzL01lZGlhRXZlbnRzLnRzXG5cclxuY2xhc3MgTWVkaWFFdmVudCBleHRlbmRzIEdhbWVFdmVudCB7XHJcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQsIF9uYW1lID0gJ01lZGlhRXZlbnQnKSB7XHJcbiAgICAgICAgc3VwZXIoKTtcclxuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcclxuICAgICAgICB0aGlzLl9uYW1lID0gX25hbWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1lZGlhIGV2ZW50IGNhbm5vdCBidWJibGVcclxuICAgICAqL1xyXG4gICAgc2V0IGJ1YmJsZXMoX3ZhbHVlKSB7XHJcbiAgICAgICAgLy8gc3R1YmJlZFxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNZWRpYSBldmVudCBjYW5ub3QgYnViYmxlXHJcbiAgICAgKi9cclxuICAgIGdldCBidWJibGVzKCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWVkaWEgZXZlbnQgY2Fubm90IGJ1YmJsZSwgc28gdGhleSBoYXZlIG5vIHBhdGhcclxuICAgICAqL1xyXG4gICAgZ2V0IF9wYXRoKCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNZWRpYSBldmVudCBjYW5ub3QgYnViYmxlLCBzbyB0aGV5IGhhdmUgbm8gcGF0aFxyXG4gICAgICovXHJcbiAgICBzZXQgX3BhdGgoX3ZhbCkge1xyXG4gICAgICAgIC8vIHN0dWJiZWRcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUHJldmVudHMgZXZlbnQgZnJvbSBidWJibGluZ1xyXG4gICAgICovXHJcbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3R1YlxyXG4gICAgICAgICAqL1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBY3Rpb24sIHRoYXQgY2FsbHMgd2hlbiBldmVudCBoYXBwZW5zXHJcbiAgICAgKi9cclxuICAgIGFjdGlvbigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdHViXHJcbiAgICAgICAgICovXHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFByb3BhZ2F0ZSBldmVudCBmdXJ0aGVyIHRocm91Z2ggZXZlbnQgcGF0aFxyXG4gICAgICovXHJcbiAgICBwcm9wYWdhdGUoKSB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU3R1YlxyXG4gICAgICAgICAqL1xyXG4gICAgfVxyXG4gICAgbGF5UGF0aChfYWN0b3IpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBTdHViXHJcbiAgICAgICAgICovXHJcbiAgICB9XHJcbn1cclxuY2xhc3MgTmF0aXZlU291bmRFdmVudCBleHRlbmRzIE1lZGlhRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCB0cmFjaykge1xyXG4gICAgICAgIHN1cGVyKHRhcmdldCwgJ05hdGl2ZVNvdW5kRXZlbnQnKTtcclxuICAgICAgICB0aGlzLnRyYWNrID0gdHJhY2s7XHJcbiAgICB9XHJcbn1cclxuY2xhc3MgTmF0aXZlU291bmRQcm9jZXNzZWRFdmVudCBleHRlbmRzIE1lZGlhRXZlbnQge1xyXG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCBfcHJvY2Vzc2VkRGF0YSkge1xyXG4gICAgICAgIHN1cGVyKHRhcmdldCwgJ05hdGl2ZVNvdW5kUHJvY2Vzc2VkRXZlbnQnKTtcclxuICAgICAgICB0aGlzLl9wcm9jZXNzZWREYXRhID0gX3Byb2Nlc3NlZERhdGE7XHJcbiAgICAgICAgdGhpcy5kYXRhID0gdGhpcy5fcHJvY2Vzc2VkRGF0YTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0dyYXBoaWNzL0ZvbnQudHNcblxyXG5cclxuXHJcblxyXG5cclxuY2xhc3MgRm9udCBleHRlbmRzIFJhc3RlciB7XHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oLCBfaiwgX2ssIF9sLCBfbTtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBGb250IHF1YWxpdHkgZGV0ZXJtaW5lcyB0aGUgc2l6ZSBvZiB0aGUgdW5kZXJseWluZyByYXN0ZXJlZCB0ZXh0LCBoaWdoZXIgcXVhbGl0eSBtZWFucyBsZXNzIGphZ2dlZCBlZGdlcy5cclxuICAgICAgICAgKiBJZiBxdWFsaXR5IGlzIHNldCB0byAxLCB0aGVuIGp1c3QgZW5vdWdoIHJhc3RlciBiaXRtYXAgaXMgZ2VuZXJhdGVkIHRvIHJlbmRlciB0aGUgdGV4dC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIFlvdSBjYW4gdGhpbmsgb2YgcXVhbGl0eSBhcyBob3cgem9vbWVkIGluIHRvIHRoZSB0ZXh0IHlvdSBjYW4gZ2V0IGJlZm9yZSBzZWVpbmcgamFnZ2VkIGVkZ2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogKERlZmF1bHQgNClcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnF1YWxpdHkgPSAyO1xyXG4gICAgICAgIHRoaXMuZmFtaWx5ID0gJ3NhbnMtc2VyaWYnO1xyXG4gICAgICAgIHRoaXMuc3R5bGUgPSBGb250U3R5bGUuTm9ybWFsO1xyXG4gICAgICAgIHRoaXMuYm9sZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMudW5pdCA9IEZvbnRVbml0LlB4O1xyXG4gICAgICAgIHRoaXMudGV4dEFsaWduID0gVGV4dEFsaWduLkxlZnQ7XHJcbiAgICAgICAgdGhpcy5iYXNlQWxpZ24gPSBCYXNlQWxpZ24uQWxwaGFiZXRpYztcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IERpcmVjdGlvbi5MZWZ0VG9SaWdodDtcclxuICAgICAgICB0aGlzLnNpemUgPSAxMDtcclxuICAgICAgICB0aGlzLnNoYWRvdyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdGV4dEJvdW5kcyA9IG5ldyBCb3VuZGluZ0JveCgpO1xyXG4gICAgICAgIHRoaXMuX3RleHRXaWR0aCA9IDA7XHJcbiAgICAgICAgdGhpcy5fdGV4dEhlaWdodCA9IDA7XHJcbiAgICAgICAgdGhpcy5mYW1pbHkgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFtaWx5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLmZhbWlseTtcclxuICAgICAgICB0aGlzLnN0eWxlID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnN0eWxlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0aGlzLnN0eWxlO1xyXG4gICAgICAgIHRoaXMuYm9sZCA9IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5ib2xkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB0aGlzLmJvbGQ7XHJcbiAgICAgICAgdGhpcy5zaXplID0gKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNpemUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHRoaXMuc2l6ZTtcclxuICAgICAgICB0aGlzLnVuaXQgPSAoX2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudW5pdCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdGhpcy51bml0O1xyXG4gICAgICAgIHRoaXMudGV4dEFsaWduID0gKF9mID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRleHRBbGlnbikgIT09IG51bGwgJiYgX2YgIT09IHZvaWQgMCA/IF9mIDogdGhpcy50ZXh0QWxpZ247XHJcbiAgICAgICAgdGhpcy5iYXNlQWxpZ24gPSAoX2cgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYmFzZUFsaWduKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB0aGlzLmJhc2VBbGlnbjtcclxuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IChfaCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kaXJlY3Rpb24pICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IHRoaXMuZGlyZWN0aW9uO1xyXG4gICAgICAgIHRoaXMucXVhbGl0eSA9IChfaiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5xdWFsaXR5KSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiB0aGlzLnF1YWxpdHk7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zaGFkb3cpIHtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cgPSB7fTtcclxuICAgICAgICAgICAgdGhpcy5zaGFkb3cuYmx1ciA9IChfayA9IG9wdGlvbnMuc2hhZG93LmJsdXIpICE9PSBudWxsICYmIF9rICE9PSB2b2lkIDAgPyBfayA6IHRoaXMuc2hhZG93LmJsdXI7XHJcbiAgICAgICAgICAgIHRoaXMuc2hhZG93Lm9mZnNldCA9IChfbCA9IG9wdGlvbnMuc2hhZG93Lm9mZnNldCkgIT09IG51bGwgJiYgX2wgIT09IHZvaWQgMCA/IF9sIDogdGhpcy5zaGFkb3cub2Zmc2V0O1xyXG4gICAgICAgICAgICB0aGlzLnNoYWRvdy5jb2xvciA9IChfbSA9IG9wdGlvbnMuc2hhZG93LmNvbG9yKSAhPT0gbnVsbCAmJiBfbSAhPT0gdm9pZCAwID8gX20gOiB0aGlzLnNoYWRvdy5jb2xvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5mbGFnRGlydHkoKTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgRm9udChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5jbG9uZUdyYXBoaWNPcHRpb25zKCkpLCB0aGlzLmNsb25lUmFzdGVyT3B0aW9ucygpKSwgeyBzaXplOiB0aGlzLnNpemUsIHVuaXQ6IHRoaXMudW5pdCwgZmFtaWx5OiB0aGlzLmZhbWlseSwgc3R5bGU6IHRoaXMuc3R5bGUsIGJvbGQ6IHRoaXMuYm9sZCwgdGV4dEFsaWduOiB0aGlzLnRleHRBbGlnbiwgYmFzZUFsaWduOiB0aGlzLmJhc2VBbGlnbiwgZGlyZWN0aW9uOiB0aGlzLmRpcmVjdGlvbiwgc2hhZG93OiB0aGlzLnNoYWRvd1xyXG4gICAgICAgICAgICAgICAgPyB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmx1cjogdGhpcy5zaGFkb3cuYmx1cixcclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuc2hhZG93Lm9mZnNldCxcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5zaGFkb3cuY29sb3JcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIDogbnVsbCB9KSk7XHJcbiAgICB9XHJcbiAgICBnZXQgZm9udFN0cmluZygpIHtcclxuICAgICAgICByZXR1cm4gYCR7dGhpcy5zdHlsZX0gJHt0aGlzLmJvbGQgPyAnYm9sZCcgOiAnJ30gJHt0aGlzLnNpemV9JHt0aGlzLnVuaXR9ICR7dGhpcy5mYW1pbHl9YDtcclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dFdpZHRoO1xyXG4gICAgfVxyXG4gICAgc2V0IHdpZHRoKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdGV4dFdpZHRoID0gdmFsdWU7XHJcbiAgICB9XHJcbiAgICBnZXQgaGVpZ2h0KCkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgbnVtTGluZXMgPSAoX2IgPSAoX2EgPSB0aGlzLl9saW5lcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dEhlaWdodCAqIG51bUxpbmVzO1xyXG4gICAgfVxyXG4gICAgc2V0IGhlaWdodCh2YWx1ZSkge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgbnVtTGluZXMgPSAoX2IgPSAoX2EgPSB0aGlzLl9saW5lcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMTtcclxuICAgICAgICB0aGlzLl90ZXh0SGVpZ2h0ID0gdmFsdWUgLyBudW1MaW5lcztcclxuICAgIH1cclxuICAgIGdldCBfcmFzdGVyV2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JpdG1hcC53aWR0aDtcclxuICAgIH1cclxuICAgIGdldCBfcmFzdGVySGVpZ2h0KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9iaXRtYXAuaGVpZ2h0O1xyXG4gICAgfVxyXG4gICAgZ2V0IF9oYWxmUmFzdGVyV2lkdGgoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5fYml0bWFwLndpZHRoIC8gMik7XHJcbiAgICB9XHJcbiAgICBnZXQgX2hhbGZSYXN0ZXJIZWlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5fYml0bWFwLmhlaWdodCAvIDIpO1xyXG4gICAgfVxyXG4gICAgZ2V0IGxvY2FsQm91bmRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0Qm91bmRzO1xyXG4gICAgfVxyXG4gICAgX2RyYXdJbWFnZShleCwgeCwgeSkge1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmFzdGVyaXplKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGV4LmRyYXdJbWFnZSh0aGlzLl9iaXRtYXAsIDAsIDAsIHRoaXMuX3Jhc3RlcldpZHRoLCB0aGlzLl9yYXN0ZXJIZWlnaHQsIHggLSB0aGlzLl9yYXN0ZXJXaWR0aCAvIHRoaXMucXVhbGl0eSAvIDIsIHkgLSB0aGlzLl9yYXN0ZXJIZWlnaHQgLyB0aGlzLnF1YWxpdHkgLyAyLCB0aGlzLl9yYXN0ZXJXaWR0aCAvIHRoaXMucXVhbGl0eSwgdGhpcy5fcmFzdGVySGVpZ2h0IC8gdGhpcy5xdWFsaXR5KTtcclxuICAgIH1cclxuICAgIF9yb3RhdGUoZXgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgLy8gVE9ETyB0aGlzIG5lZWRzIHRvIGNoYW5nZSBkZXBlbmRpbmcgb24gdGhlIGJvdW5kaW5nIGJveC4uLlxyXG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IChfYSA9IHRoaXMub3JpZ2luKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLl90ZXh0Qm91bmRzLmNlbnRlcjtcclxuICAgICAgICBleC50cmFuc2xhdGUob3JpZ2luLngsIG9yaWdpbi55KTtcclxuICAgICAgICBleC5yb3RhdGUodGhpcy5yb3RhdGlvbik7XHJcbiAgICAgICAgZXgudHJhbnNsYXRlKC1vcmlnaW4ueCwgLW9yaWdpbi55KTtcclxuICAgIH1cclxuICAgIF9mbGlwKGV4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuZmxpcEhvcml6b250YWwpIHtcclxuICAgICAgICAgICAgZXgudHJhbnNsYXRlKHRoaXMuX3RleHRCb3VuZHMud2lkdGggLyB0aGlzLnNjYWxlLngsIDApO1xyXG4gICAgICAgICAgICBleC5zY2FsZSgtMSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLmZsaXBWZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICBleC50cmFuc2xhdGUoMCwgLXRoaXMuX3RleHRCb3VuZHMuaGVpZ2h0IC8gMiAvIHRoaXMuc2NhbGUueSk7XHJcbiAgICAgICAgICAgIGV4LnNjYWxlKDEsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICB1cGRhdGVUZXh0KHRleHQpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGV4dCAhPT0gdGV4dCkge1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcclxuICAgICAgICAgICAgdGhpcy5fbGluZXMgPSB0aGlzLl90ZXh0LnNwbGl0KCdcXG4nKTtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlRGltZW5zaW9ucygpO1xyXG4gICAgICAgICAgICB0aGlzLmZsYWdEaXJ0eSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF91cGRhdGVEaW1lbnNpb25zKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl90ZXh0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Rm9udCh0aGlzLl9jdHgpO1xyXG4gICAgICAgICAgICBjb25zdCBtYXhXaWR0aExpbmUgPSB0aGlzLl9saW5lcy5yZWR1Y2UoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhLmxlbmd0aCA+IGIubGVuZ3RoID8gYSA6IGI7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjb25zdCBtZXRyaWNzID0gdGhpcy5fY3R4Lm1lYXN1cmVUZXh0KG1heFdpZHRoTGluZSk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHRXaWR0aCA9IE1hdGguYWJzKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hMZWZ0KSArIE1hdGguYWJzKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hSaWdodCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHRIZWlnaHQgPSBNYXRoLmFicyhtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50KSArIE1hdGguYWJzKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hEZXNjZW50KTtcclxuICAgICAgICAgICAgLy8gVE9ETyBsaW5laGVpZ2h0IG1ha2VzIHRoZSB0ZXh0IGJvdW5kcyB3b25reVxyXG4gICAgICAgICAgICBjb25zdCBsaW5lQWRqdXN0ZWRIZWlnaHQgPSB0aGlzLl90ZXh0SGVpZ2h0ICogdGhpcy5fbGluZXMubGVuZ3RoO1xyXG4gICAgICAgICAgICAvLyB0aGlzLl90ZXh0SGVpZ2h0ID0gbGluZUFkanVzdGVkSGVpZ2h0O1xyXG4gICAgICAgICAgICAvLyBDaGFuZ2luZyB0aGUgd2lkdGggYW5kIGhlaWdodCBjbGVhcnMgdGhlIGNvbnRleHQgcHJvcGVydGllc1xyXG4gICAgICAgICAgICAvLyBXZSBkb3VibGUgdGhlIGJpdG1hcCB3aWR0aCB0byBhY2NvdW50IGZvciBhbGlnbm1lbnRcclxuICAgICAgICAgICAgLy8gV2Ugc2NhbGUgYnkgXCJxdWFsaXR5XCIgc28gd2UgcmVuZGVyIHRleHQgd2l0aG91dCBqYWdnaWVzXHJcbiAgICAgICAgICAgIHRoaXMuX2JpdG1hcC53aWR0aCA9ICh0aGlzLl90ZXh0V2lkdGggKyB0aGlzLnBhZGRpbmcgKiAyKSAqIDIgKiB0aGlzLnF1YWxpdHk7XHJcbiAgICAgICAgICAgIHRoaXMuX2JpdG1hcC5oZWlnaHQgPSAobGluZUFkanVzdGVkSGVpZ2h0ICsgdGhpcy5wYWRkaW5nICogMikgKiAyICogdGhpcy5xdWFsaXR5O1xyXG4gICAgICAgICAgICAvLyBUaGVzZSBib3VuZHMgZXhpc3QgaW4gcmFzdGVyIGJpdG1hcCBzcGFjZSB3aGVyZSB0aGUgdG9wIGxlZnQgY29ybmVyIGlzIHRoZSBjb3JkZXIgb2YgdGhlIGJpdG1hcFxyXG4gICAgICAgICAgICBjb25zdCB4ID0gMDtcclxuICAgICAgICAgICAgY29uc3QgeSA9IDA7XHJcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbUJvdW5kcyA9IGxpbmVBZGp1c3RlZEhlaWdodCAtIE1hdGguYWJzKG1ldHJpY3MuYWN0dWFsQm91bmRpbmdCb3hBc2NlbnQpO1xyXG4gICAgICAgICAgICB0aGlzLl90ZXh0Qm91bmRzID0gbmV3IEJvdW5kaW5nQm94KHtcclxuICAgICAgICAgICAgICAgIGxlZnQ6IHggLSBNYXRoLmFicyhtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94TGVmdCkgLSB0aGlzLnBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICB0b3A6IHkgLSBNYXRoLmFicyhtZXRyaWNzLmFjdHVhbEJvdW5kaW5nQm94QXNjZW50KSAtIHRoaXMucGFkZGluZyxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogeSArIGJvdHRvbUJvdW5kcyArIHRoaXMucGFkZGluZyxcclxuICAgICAgICAgICAgICAgIHJpZ2h0OiB4ICsgTWF0aC5hYnMobWV0cmljcy5hY3R1YWxCb3VuZGluZ0JveFJpZ2h0KSArIHRoaXMucGFkZGluZ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJlRHJhdyhleCwgeCwgeSkge1xyXG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZURpbWVuc2lvbnMoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc3VwZXIuX3ByZURyYXcoZXgsIHgsIHkpO1xyXG4gICAgfVxyXG4gICAgX3Bvc3REcmF3KGV4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuc2hvd0RlYnVnKSB7XHJcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcbiAgICAgICAgICAgIGV4LmRlYnVnLmRyYXdSZWN0KC10aGlzLl9oYWxmUmFzdGVyV2lkdGgsIC10aGlzLl9oYWxmUmFzdGVySGVpZ2h0LCB0aGlzLl9yYXN0ZXJXaWR0aCwgdGhpcy5fcmFzdGVySGVpZ2h0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZXgucmVzdG9yZSgpO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5Rm9udChjdHgpIHtcclxuICAgICAgICBjdHgudHJhbnNsYXRlKHRoaXMucGFkZGluZyArIHRoaXMuX2hhbGZSYXN0ZXJXaWR0aCwgdGhpcy5wYWRkaW5nICsgdGhpcy5faGFsZlJhc3RlckhlaWdodCk7XHJcbiAgICAgICAgY3R4LnNjYWxlKHRoaXMucXVhbGl0eSwgdGhpcy5xdWFsaXR5KTtcclxuICAgICAgICBjdHgudGV4dEFsaWduID0gdGhpcy50ZXh0QWxpZ247XHJcbiAgICAgICAgY3R4LnRleHRCYXNlbGluZSA9IHRoaXMuYmFzZUFsaWduO1xyXG4gICAgICAgIGN0eC5mb250ID0gdGhpcy5mb250U3RyaW5nO1xyXG4gICAgICAgIGN0eC5kaXJlY3Rpb24gPSB0aGlzLmRpcmVjdGlvbjtcclxuICAgICAgICBpZiAodGhpcy5zaGFkb3cpIHtcclxuICAgICAgICAgICAgY3R4LnNoYWRvd0NvbG9yID0gdGhpcy5zaGFkb3cuY29sb3IudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgY3R4LnNoYWRvd0JsdXIgPSB0aGlzLnNoYWRvdy5ibHVyO1xyXG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WCA9IHRoaXMuc2hhZG93Lm9mZnNldC54O1xyXG4gICAgICAgICAgICBjdHguc2hhZG93T2Zmc2V0WSA9IHRoaXMuc2hhZG93Lm9mZnNldC55O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4ZWN1dGUoY3R4KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RleHQpIHtcclxuICAgICAgICAgICAgLy8gVGhlIHJlYXNvbiB3ZSBuZWVkIHRvIHJlLWFwcGx5IHRoZSBmb250IGlzIHNldHRpbmcgcmFzdGVyIHByb3BlcnRpZXMgKGxpa2Ugd2lkdGgvaGVpZ2h0KSBjYW4gcmVzZXQgdGhlIGNvbnRleHQgcHJvcHNcclxuICAgICAgICAgICAgdGhpcy5fYXBwbHlSYXN0ZXJQcm9wZXJpdGVzKGN0eCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2FwcGx5Rm9udChjdHgpO1xyXG4gICAgICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gdGhpcy5fdGV4dEhlaWdodDsgLy8gVE9ETyB1c2VyIHNwZWNpZmllZCBsaW5lIGhlaWdodFxyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2xpbmVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gdGhpcy5fbGluZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5maWxsVGV4dChsaW5lLCAwLCBpICogbGluZUhlaWdodCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHJva2VDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGN0eC5zdHJva2VUZXh0KGxpbmUsIDAsIGkgKiBsaW5lSGVpZ2h0KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zaG93RGVidWcpIHtcclxuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZVxyXG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuICAgICAgICAgICAgICAgIGxpbmUoY3R4LCBDb2xvci5SZWQsIC10aGlzLl9oYWxmUmFzdGVyV2lkdGgsIDAsIHRoaXMuX2hhbGZSYXN0ZXJXaWR0aCwgMCwgMik7XHJcbiAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBsaW5lXHJcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG4gICAgICAgICAgICAgICAgbGluZShjdHgsIENvbG9yLlJlZCwgMCwgLXRoaXMuX2hhbGZSYXN0ZXJIZWlnaHQsIDAsIHRoaXMuX2hhbGZSYXN0ZXJIZWlnaHQsIDIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmVuZGVyKGV4LCB0ZXh0LCB4LCB5KSB7XHJcbiAgICAgICAgdGhpcy51cGRhdGVUZXh0KHRleHQpO1xyXG4gICAgICAgIHRoaXMuZHJhdyhleCwgeCwgeSk7XHJcbiAgICB9XHJcbn1cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9HcmFwaGljcy9UZXh0LnRzXG5cclxuXHJcblxyXG5cclxuY2xhc3MgVGV4dCBleHRlbmRzIEdyYXBoaWMge1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XHJcbiAgICAgICAgdGhpcy5fdGV4dCA9ICcnO1xyXG4gICAgICAgIC8vIFRoaXMgb3JkZXIgaXMgaW1wb3J0YW50IGZvbnQsIGNvbG9yLCB0aGVuIHRleHRcclxuICAgICAgICB0aGlzLmZvbnQgPSAoX2EgPSBvcHRpb25zLmZvbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5ldyBGb250KCk7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IChfYiA9IG9wdGlvbnMuY29sb3IpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRoaXMuY29sb3I7XHJcbiAgICAgICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xyXG4gICAgfVxyXG4gICAgY2xvbmUoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0KHtcclxuICAgICAgICAgICAgdGV4dDogdGhpcy50ZXh0LnNsaWNlKCksXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGlzLmNvbG9yLmNsb25lKCksXHJcbiAgICAgICAgICAgIGZvbnQ6IHRoaXMuZm9udC5jbG9uZSgpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBnZXQgdGV4dCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dDtcclxuICAgIH1cclxuICAgIHNldCB0ZXh0KHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fdGV4dCA9IHZhbHVlO1xyXG4gICAgICAgIHRoaXMuZm9udC51cGRhdGVUZXh0KHZhbHVlKTtcclxuICAgIH1cclxuICAgIC8vIFRPRE8gU3ByaXRlRm9udCBkb2Vzbid0IHN1cHBvcnQgYSBjb2xvciB5ZXQgOihcclxuICAgIGdldCBjb2xvcigpIHtcclxuICAgICAgICBpZiAodGhpcy5mb250IGluc3RhbmNlb2YgRm9udCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb250LmNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gQ29sb3IuQmxhY2s7XHJcbiAgICB9XHJcbiAgICBzZXQgY29sb3IoY29sb3IpIHtcclxuICAgICAgICBpZiAodGhpcy5mb250IGluc3RhbmNlb2YgRm9udCkge1xyXG4gICAgICAgICAgICB0aGlzLmZvbnQuY29sb3IgPSBjb2xvcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgZm9udCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZm9udDtcclxuICAgIH1cclxuICAgIHNldCBmb250KGZvbnQpIHtcclxuICAgICAgICBpZiAoZm9udCBpbnN0YW5jZW9mIEZvbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZm9udCA9IHdhdGNoKGZvbnQsIChmb250KSA9PiBmb250LmZsYWdEaXJ0eSgpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2ZvbnQgPSBmb250O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCB3aWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb250LndpZHRoO1xyXG4gICAgfVxyXG4gICAgZ2V0IGhlaWdodCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb250LmhlaWdodDtcclxuICAgIH1cclxuICAgIGdldCBsb2NhbEJvdW5kcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb250LmxvY2FsQm91bmRzO1xyXG4gICAgfVxyXG4gICAgX3JvdGF0ZShfZXgpIHtcclxuICAgICAgICAvLyBOb25lIHRoaXMgaXMgZGVsZWdhdGVkIHRvIGZvbnRcclxuICAgICAgICAvLyBUaGlzIG92ZXJyaWRlIGVyYXNlcyB0aGUgZGVmYXVsdCBiZWhhdmlvclxyXG4gICAgfVxyXG4gICAgX2ZsaXAoX2V4KSB7XHJcbiAgICAgICAgLy8gTm9uZSB0aGlzIGlzIGRlbGVnYXRlZCB0byBmb250XHJcbiAgICAgICAgLy8gVGhpcyBvdmVycmlkZSBlcmFzZXMgdGhlIGRlZmF1bHQgYmVoYXZpb3JcclxuICAgIH1cclxuICAgIF9kcmF3SW1hZ2UoZXgsIHgsIHkpIHtcclxuICAgICAgICBpZiAodGhpcy5mb250IGluc3RhbmNlb2YgRm9udCkge1xyXG4gICAgICAgICAgICB0aGlzLmZvbnQuY29sb3IgPSB0aGlzLmNvbG9yO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmZvbnQuZmxpcEhvcml6b250YWwgPSB0aGlzLmZsaXBIb3Jpem9udGFsO1xyXG4gICAgICAgIHRoaXMuZm9udC5mbGlwVmVydGljYWwgPSB0aGlzLmZsaXBWZXJ0aWNhbDtcclxuICAgICAgICB0aGlzLmZvbnQuc2NhbGUgPSB0aGlzLnNjYWxlO1xyXG4gICAgICAgIHRoaXMuZm9udC5yb3RhdGlvbiA9IHRoaXMucm90YXRpb247XHJcbiAgICAgICAgdGhpcy5mb250Lm9yaWdpbiA9IHRoaXMub3JpZ2luO1xyXG4gICAgICAgIHRoaXMuZm9udC5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xyXG4gICAgICAgIHRoaXMuZm9udC5yZW5kZXIoZXgsIHRoaXMuX3RleHQsIHgsIHkpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vTGFiZWwudHNcbnZhciBMYWJlbF9kZWNvcmF0ZSA9ICh1bmRlZmluZWQgJiYgdW5kZWZpbmVkLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8qKlxyXG4gKiBMYWJlbHMgYXJlIHRoZSB3YXkgdG8gZHJhdyBzbWFsbCBhbW91bnRzIG9mIHRleHQgdG8gdGhlIHNjcmVlbi4gVGhleSBhcmVcclxuICogYWN0b3JzIGFuZCBpbmhlcml0IGFsbCBvZiB0aGUgYmVuZWZpdHMgYW5kIGNhcGFiaWxpdGllcy5cclxuICovXHJcbmNsYXNzIExhYmVsX0xhYmVsIGV4dGVuZHMgQWN0b3Ige1xyXG4gICAgLyoqXHJcbiAgICAgKiBCdWlsZCBhIG5ldyBsYWJlbFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgICAqL1xyXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuZm9udCA9IG5ldyBGb250KCk7XHJcbiAgICAgICAgdGhpcy5fdGV4dCA9IG5ldyBUZXh0KHsgdGV4dDogJycsIGZvbnQ6IHRoaXMuZm9udCB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBHZXRzIG9yIHNldHMgdGhlIGxldHRlciBzcGFjaW5nIG9uIGEgTGFiZWwuIE9ubHkgc3VwcG9ydGVkIHdpdGggU3ByaXRlIEZvbnRzLlxyXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW1Nwcml0ZUZvbnQuc3BhY2luZ11dXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5sZXR0ZXJTcGFjaW5nID0gMDsgLy9weFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBbW1Nwcml0ZUZvbnRdXSB3aWxsIGJlIGNhc2Utc2Vuc2l0aXZlIHdoZW4gbWF0Y2hpbmcgY2hhcmFjdGVycy5cclxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgR3JhcGhpY3MuU3ByaXRlRm9udC5jYXNlSW5zZW5zaXR2ZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY2FzZUluc2Vuc2l0aXZlID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCB7IHRleHQsIHBvcywgeCwgeSwgc3ByaXRlRm9udCwgZm9udCwgY29sb3IgfSA9IG9wdGlvbnM7XHJcbiAgICAgICAgdGhpcy5wb3MgPSBwb3MgIT09IG51bGwgJiYgcG9zICE9PSB2b2lkIDAgPyBwb3MgOiAoeCAmJiB5ID8gdmVjKHgsIHkpIDogdGhpcy5wb3MpO1xyXG4gICAgICAgIHRoaXMudGV4dCA9IHRleHQgIT09IG51bGwgJiYgdGV4dCAhPT0gdm9pZCAwID8gdGV4dCA6IHRoaXMudGV4dDtcclxuICAgICAgICB0aGlzLnNwcml0ZUZvbnQgPSBzcHJpdGVGb250ICE9PSBudWxsICYmIHNwcml0ZUZvbnQgIT09IHZvaWQgMCA/IHNwcml0ZUZvbnQgOiB0aGlzLnNwcml0ZUZvbnQ7XHJcbiAgICAgICAgdGhpcy5mb250ID0gZm9udCAhPT0gbnVsbCAmJiBmb250ICE9PSB2b2lkIDAgPyBmb250IDogdGhpcy5mb250O1xyXG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvciAhPT0gbnVsbCAmJiBjb2xvciAhPT0gdm9pZCAwID8gY29sb3IgOiB0aGlzLmNvbG9yO1xyXG4gICAgICAgIGNvbnN0IGdmeCA9IHRoaXMuZ2V0KEdyYXBoaWNzQ29tcG9uZW50KTtcclxuICAgICAgICBnZnguYW5jaG9yID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgZ2Z4LnVzZSh0aGlzLl90ZXh0KTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIHRleHQgdG8gZHJhdy5cclxuICAgICAqL1xyXG4gICAgZ2V0IHRleHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQudGV4dDtcclxuICAgIH1cclxuICAgIHNldCB0ZXh0KHRleHQpIHtcclxuICAgICAgICB0aGlzLl90ZXh0LnRleHQgPSB0ZXh0O1xyXG4gICAgfVxyXG4gICAgZ2V0IGNvbG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl90ZXh0LmNvbG9yO1xyXG4gICAgfVxyXG4gICAgc2V0IGNvbG9yKGNvbG9yKSB7XHJcbiAgICAgICAgdGhpcy5fdGV4dC5jb2xvciA9IGNvbG9yO1xyXG4gICAgfVxyXG4gICAgZ2V0IG9wYWNpdHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQub3BhY2l0eTtcclxuICAgIH1cclxuICAgIHNldCBvcGFjaXR5KG9wYWNpdHkpIHtcclxuICAgICAgICB0aGlzLl90ZXh0Lm9wYWNpdHkgPSBvcGFjaXR5O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIG9yIGdldHMgdGhlIGJvbGQgcHJvcGVydHkgb2YgdGhlIGxhYmVsJ3MgdGV4dCwgYnkgZGVmYXVsdCBpdCdzIGZhbHNlXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tGb250LmJvbGR8TGFiZWwuZm9udC5ib2xkXV1cclxuICAgICAqL1xyXG4gICAgZ2V0IGJvbGQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udC5ib2xkO1xyXG4gICAgfVxyXG4gICAgc2V0IGJvbGQoaXNCb2xkKSB7XHJcbiAgICAgICAgdGhpcy5mb250LmJvbGQgPSBpc0JvbGQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBDU1MgZm9udCBmYW1pbHkgc3RyaW5nIChlLmcuIGBzYW5zLXNlcmlmYCwgYERyb2lkIFNhbnMgUHJvYCkuIFdlYiBmb250c1xyXG4gICAgICogYXJlIHN1cHBvcnRlZCwgc2FtZSBhcyBpbiBDU1MuXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tGb250LmZhbWlseXxMYWJlbC5mb250LmZhbWlseV1dXHJcbiAgICAgKi9cclxuICAgIGdldCBmb250RmFtaWx5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvbnQuZmFtaWx5O1xyXG4gICAgfVxyXG4gICAgc2V0IGZvbnRGYW1pbHkoZmFtaWx5KSB7XHJcbiAgICAgICAgdGhpcy5mb250LmZhbWlseSA9IGZhbWlseTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZvbnQgc2l6ZSBpbiB0aGUgc2VsZWN0ZWQgdW5pdHMsIGRlZmF1bHQgaXMgMTAgKGRlZmF1bHQgdW5pdHMgaXMgcGl4ZWwpXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tGb250LnNpemV8TGFiZWwuZm9udC5zaXplXV1cclxuICAgICAqL1xyXG4gICAgZ2V0IGZvbnRTaXplKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvbnQuc2l6ZTtcclxuICAgIH1cclxuICAgIHNldCBmb250U2l6ZShzaXplSW5Vbml0KSB7XHJcbiAgICAgICAgdGhpcy5mb250LnNpemUgPSBzaXplSW5Vbml0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgZm9udCBzdHlsZSBmb3IgdGhpcyBsYWJlbCwgdGhlIGRlZmF1bHQgaXMgW1tGb250U3R5bGUuTm9ybWFsXV1cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW0ZvbnQuc3R5bGV8TGFiZWwuZm9udC5zdHlsZV1dXHJcbiAgICAgKi9cclxuICAgIGdldCBmb250U3R5bGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udC5zdHlsZTtcclxuICAgIH1cclxuICAgIHNldCBmb250U3R5bGUoc3R5bGUpIHtcclxuICAgICAgICB0aGlzLmZvbnQuc3R5bGUgPSBzdHlsZTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGNzcyB1bml0cyBmb3IgYSBmb250IHNpemUgc3VjaCBhcyBweCwgcHQsIGVtIChTcHJpdGVGb250IG9ubHkgc3VwcG9ydCBweCksIGJ5IGRlZmF1bHQgaXMgJ3B4JztcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW0ZvbnQudW5pdHxMYWJlbC5mb250LnVuaXRdXVxyXG4gICAgICovXHJcbiAgICBnZXQgZm9udFVuaXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9udC51bml0O1xyXG4gICAgfVxyXG4gICAgc2V0IGZvbnRVbml0KHVuaXQpIHtcclxuICAgICAgICB0aGlzLmZvbnQudW5pdCA9IHVuaXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgaG9yaXpvbnRhbCB0ZXh0IGFsaWdubWVudCBwcm9wZXJ0eSBmb3IgdGhlIGxhYmVsLlxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIFtbRm9udC50ZXh0QWxpZ258TGFiZWwuZm9udC50ZXh0QWxpZ25dXVxyXG4gICAgICovXHJcbiAgICBnZXQgdGV4dEFsaWduKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmZvbnQudGV4dEFsaWduO1xyXG4gICAgfVxyXG4gICAgc2V0IHRleHRBbGlnbihhbGlnbikge1xyXG4gICAgICAgIHRoaXMuZm9udC50ZXh0QWxpZ24gPSBhbGlnbjtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBiYXNlbGluZSBhbGlnbm1lbnQgcHJvcGVydHkgZm9yIHRoZSBsYWJlbC5cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW0ZvbnQuYmFzZUFsaWdufExhYmVsLmZvbnQuYmFzZUFsaWduXV1cclxuICAgICAqL1xyXG4gICAgZ2V0IGJhc2VBbGlnbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5mb250LmJhc2VBbGlnbjtcclxuICAgIH1cclxuICAgIHNldCBiYXNlQWxpZ24oYWxpZ24pIHtcclxuICAgICAgICB0aGlzLmZvbnQuYmFzZUFsaWduID0gYWxpZ247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBbW0xlZ2FjeURyYXdpbmcuU3ByaXRlRm9udF1dIHRvIHVzZSwgaWYgYW55LiBPdmVycmlkZXMgW1tmb250RmFtaWx5XV0gaWYgcHJlc2VudC5cclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW1Nwcml0ZUZvbnRdXVxyXG4gICAgICovXHJcbiAgICBnZXQgc3ByaXRlRm9udCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGVnYWN5U3ByaXRlRm9udDtcclxuICAgIH1cclxuICAgIHNldCBzcHJpdGVGb250KHNmKSB7XHJcbiAgICAgICAgaWYgKHNmKSB7XHJcbiAgICAgICAgICAgIGlmIChzZiBpbnN0YW5jZW9mIFNwcml0ZUZvbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2xlZ2FjeVNwcml0ZUZvbnQgPSBzZjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3Nwcml0ZUZvbnQgPSBTcHJpdGVGb250X1Nwcml0ZUZvbnQuZnJvbUxlZ2FjeVNwcml0ZUZvbnQoc2YpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dC5mb250ID0gdGhpcy5fc3ByaXRlRm9udDtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9zcHJpdGVGb250ID0gc2Y7XHJcbiAgICAgICAgICAgIHRoaXMuX3RleHQuZm9udCA9IHRoaXMuX3Nwcml0ZUZvbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemUoZW5naW5lKSB7XHJcbiAgICAgICAgc3VwZXIuX2luaXRpYWxpemUoZW5naW5lKTtcclxuICAgICAgICB0aGlzLl9ncmFwaGljc0NvbnRleHQgPSBlbmdpbmUuZ3JhcGhpY3NDb250ZXh0O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgdGV4dCBpbiB0aGUgbGFiZWwgKGluIHBpeGVscyk7XHJcbiAgICAgKi9cclxuICAgIGdldFRleHRXaWR0aCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdGV4dC53aWR0aDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogU2V0cyB0aGUgdGV4dCBzaGFkb3cgZm9yIHNwcml0ZSBmb250c1xyXG4gICAgICogQHBhcmFtIG9mZnNldFggICAgICBUaGUgeCBvZmZzZXQgaW4gcGl4ZWxzIHRvIHBsYWNlIHRoZSBzaGFkb3dcclxuICAgICAqIEBwYXJhbSBvZmZzZXRZICAgICAgVGhlIHkgb2Zmc2V0IGluIHBpeGVscyB0byBwbGFjZSB0aGUgc2hhZG93XHJcbiAgICAgKiBAcGFyYW0gc2hhZG93Q29sb3IgIFRoZSBjb2xvciBvZiB0aGUgdGV4dCBzaGFkb3dcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW0ZvbnQuc2hhZG93fExhYmVsLmZvbnQuc2hhZG93XV1cclxuICAgICAqL1xyXG4gICAgc2V0VGV4dFNoYWRvdyhvZmZzZXRYLCBvZmZzZXRZLCBzaGFkb3dDb2xvcikge1xyXG4gICAgICAgIHRoaXMuZm9udC5zaGFkb3cgPSB7IG9mZnNldDogdmVjKG9mZnNldFgsIG9mZnNldFkpLCBibHVyOiAyLCBjb2xvcjogc2hhZG93Q29sb3IgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVG9nZ2xlcyB0ZXh0IHNoYWRvd3Mgb24gb3Igb2ZmLCBvbmx5IGFwcGxpZXMgd2hlbiB1c2luZyBzcHJpdGUgZm9udHNcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBbW0ZvbnQuc2hhZG93fExhYmVsLmZvbnQuc2hhZG93XV1cclxuICAgICAqL1xyXG4gICAgdXNlVGV4dFNoYWRvdyhvbikge1xyXG4gICAgICAgIGlmICh0aGlzLnNwcml0ZUZvbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5zcHJpdGVGb250LnVzZVRleHRTaGFkb3cob24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjdXJyZW50IHRleHQgc2hhZG93XHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgW1tGb250LnNoYWRvd3xMYWJlbC5mb250LnNoYWRvd11dXHJcbiAgICAgKi9cclxuICAgIGNsZWFyVGV4dFNoYWRvdygpIHtcclxuICAgICAgICB0aGlzLmZvbnQuc2hhZG93ID0gbnVsbDtcclxuICAgIH1cclxuICAgIGRyYXcoX2N0eCwgX2RlbHRhKSB7XHJcbiAgICAgICAgY29uc3QgZXhjdHggPSB0aGlzLl9ncmFwaGljc0NvbnRleHQ7XHJcbiAgICAgICAgdGhpcy5fdGV4dC5kcmF3KGV4Y3R4LCAwLCAwKTtcclxuICAgIH1cclxufVxyXG5MYWJlbF9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0xhYmVsLmJvbGQgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBMYWJlbC5mb250LmJvbGQnXHJcbiAgICB9KVxyXG5dLCBMYWJlbF9MYWJlbC5wcm90b3R5cGUsIFwiYm9sZFwiLCBudWxsKTtcclxuTGFiZWxfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdMYWJlbC5mb250RmFtaWx5IHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgTGFiZWwuZm9udC5mYW1pbHknXHJcbiAgICB9KVxyXG5dLCBMYWJlbF9MYWJlbC5wcm90b3R5cGUsIFwiZm9udEZhbWlseVwiLCBudWxsKTtcclxuTGFiZWxfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdMYWJlbC5mb250U2l6ZSB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIExhYmVsLmZvbnQuc2l6ZSdcclxuICAgIH0pXHJcbl0sIExhYmVsX0xhYmVsLnByb3RvdHlwZSwgXCJmb250U2l6ZVwiLCBudWxsKTtcclxuTGFiZWxfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdMYWJlbC5mb250U3R5bGUgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBMYWJsZS5mb250LnN0eWxlJ1xyXG4gICAgfSlcclxuXSwgTGFiZWxfTGFiZWwucHJvdG90eXBlLCBcImZvbnRTdHlsZVwiLCBudWxsKTtcclxuTGFiZWxfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdMYWJlbC5mb250VW5pdCB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIExhYmVsLmZvbnQudW5pdCdcclxuICAgIH0pXHJcbl0sIExhYmVsX0xhYmVsLnByb3RvdHlwZSwgXCJmb250VW5pdFwiLCBudWxsKTtcclxuTGFiZWxfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdMYWJlbC50ZXh0QWxpZ24gd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBMYWJlbC5mb250LnRleHRBbGlnbidcclxuICAgIH0pXHJcbl0sIExhYmVsX0xhYmVsLnByb3RvdHlwZSwgXCJ0ZXh0QWxpZ25cIiwgbnVsbCk7XHJcbkxhYmVsX2RlY29yYXRlKFtcclxuICAgIG9ic29sZXRlKHtcclxuICAgICAgICBtZXNzYWdlOiAnTGFiZWwuYmFzZUFsaWduIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgTGFiZWwuZm9udC5iYXNlQWxpZ24nXHJcbiAgICB9KVxyXG5dLCBMYWJlbF9MYWJlbC5wcm90b3R5cGUsIFwiYmFzZUFsaWduXCIsIG51bGwpO1xyXG5MYWJlbF9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSgpXHJcbl0sIExhYmVsX0xhYmVsLnByb3RvdHlwZSwgXCJzcHJpdGVGb250XCIsIG51bGwpO1xyXG5MYWJlbF9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0xhYmVsLnNldFRleHRTaGFkb3cgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBMYWJlbC5mb250LnNoYWRvdydcclxuICAgIH0pXHJcbl0sIExhYmVsX0xhYmVsLnByb3RvdHlwZSwgXCJzZXRUZXh0U2hhZG93XCIsIG51bGwpO1xyXG5MYWJlbF9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0xhYmVsLnVzZVRleHRTaGFkb3cgd2lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAnLFxyXG4gICAgICAgIGFsdGVybmF0ZU1ldGhvZDogJ1VzZSBMYWJlbC5mb250LnNoYWRvdydcclxuICAgIH0pXHJcbl0sIExhYmVsX0xhYmVsLnByb3RvdHlwZSwgXCJ1c2VUZXh0U2hhZG93XCIsIG51bGwpO1xyXG5MYWJlbF9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ0xhYmVsLmNsZWFyVGV4dFNoYWRvdyB3aWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMCcsXHJcbiAgICAgICAgYWx0ZXJuYXRlTWV0aG9kOiAnVXNlIExhYmVsLmZvbnQuc2hhZG93J1xyXG4gICAgfSlcclxuXSwgTGFiZWxfTGFiZWwucHJvdG90eXBlLCBcImNsZWFyVGV4dFNoYWRvd1wiLCBudWxsKTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9BY3Rpb25zL0luZGV4LnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0NvbGxpc2lvbi9Hcm91cC9Db2xsaXNpb25Hcm91cE1hbmFnZXIudHNcblxyXG4vKipcclxuICogU3RhdGljIGNsYXNzIGZvciBtYW5hZ2luZyBjb2xsaXNpb24gZ3JvdXBzIGluIGV4Y2FsaWJ1ciwgdGhlcmUgaXMgYSBtYXhpbXVtIG9mIDMyIGNvbGxpc2lvbiBncm91cHMgcG9zc2libGUgaW4gZXhjYWxpYnVyXHJcbiAqL1xyXG5jbGFzcyBDb2xsaXNpb25Hcm91cE1hbmFnZXIge1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYSBuZXcgbmFtZWQgY29sbGlzaW9uIGdyb3VwIHVwIHRvIGEgbWF4IG9mIDMyLlxyXG4gICAgICogQHBhcmFtIG5hbWUgTmFtZSBmb3IgdGhlIGNvbGxpc2lvbiBncm91cFxyXG4gICAgICogQHBhcmFtIG1hc2sgT3B0aW9uYWxseSBwcm92aWRlIHlvdXIgb3duIDMyLWJpdCBtYXNrLCBpZiBub25lIGlzIHByb3ZpZGUgdGhlIG1hbmFnZXIgd2lsbCBnZW5lcmF0ZSBvbmVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIGNyZWF0ZShuYW1lLCBtYXNrKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX0NVUlJFTlRfR1JPVVAgPiB0aGlzLl9NQVhfR1JPVVBTKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGhhdmUgbW9yZSB0aGFuICR7dGhpcy5fTUFYX0dST1VQU30gY29sbGlzaW9uIGdyb3Vwc2ApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fR1JPVVBTLmdldChuYW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvbGxpc2lvbiBncm91cCAke25hbWV9IGFscmVhZHkgZXhpc3RzYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGdyb3VwID0gbmV3IENvbGxpc2lvbkdyb3VwKG5hbWUsIHRoaXMuX0NVUlJFTlRfQklULCBtYXNrICE9PSB1bmRlZmluZWQgPyBtYXNrIDogfnRoaXMuX0NVUlJFTlRfQklUKTtcclxuICAgICAgICB0aGlzLl9DVVJSRU5UX0JJVCA9ICh0aGlzLl9DVVJSRU5UX0JJVCA8PCAxKSB8IDA7XHJcbiAgICAgICAgdGhpcy5fQ1VSUkVOVF9HUk9VUCsrO1xyXG4gICAgICAgIHRoaXMuX0dST1VQUy5zZXQobmFtZSwgZ3JvdXApO1xyXG4gICAgICAgIHJldHVybiBncm91cDtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCBjb2xsaXNpb24gZ3JvdXBzIGN1cnJlbnRseSB0cmFja2VkIGJ5IGV4Y2FsaWJ1clxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ2V0IGdyb3VwcygpIHtcclxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9HUk9VUFMudmFsdWVzKCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYSBjb2xsaXNpb24gZ3JvdXAgYnkgaXQncyBuYW1lXHJcbiAgICAgKiBAcGFyYW0gbmFtZVxyXG4gICAgICovXHJcbiAgICBzdGF0aWMgZ3JvdXBCeU5hbWUobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9HUk9VUFMuZ2V0KG5hbWUpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIG1hbmFnZXJzIGludGVybmFsIGdyb3VwIG1hbmFnZW1lbnQgc3RhdGVcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlc2V0KCkge1xyXG4gICAgICAgIHRoaXMuX0dST1VQUyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLl9DVVJSRU5UX0JJVCA9IHRoaXMuX1NUQVJUSU5HX0JJVDtcclxuICAgICAgICB0aGlzLl9DVVJSRU5UX0dST1VQID0gMTtcclxuICAgIH1cclxufVxyXG4vLyB1c2luZyBiaXRtYXNraW5nIHRoZSBtYXhpbXVtIG51bWJlciBvZiBncm91cHMgaXMgMzIsIGJlY2F1c2UgdGhhdCBpcyB0aGUgaGlnaGVzdCAzMmJpdCBpbnRlZ2VyIHRoYXQgSlMgY2FuIHByZXNlbnQuXHJcbkNvbGxpc2lvbkdyb3VwTWFuYWdlci5fU1RBUlRJTkdfQklUID0gMGIxIHwgMDtcclxuQ29sbGlzaW9uR3JvdXBNYW5hZ2VyLl9NQVhfR1JPVVBTID0gMzI7XHJcbkNvbGxpc2lvbkdyb3VwTWFuYWdlci5fQ1VSUkVOVF9HUk9VUCA9IDE7XHJcbkNvbGxpc2lvbkdyb3VwTWFuYWdlci5fQ1VSUkVOVF9CSVQgPSBDb2xsaXNpb25Hcm91cE1hbmFnZXIuX1NUQVJUSU5HX0JJVDtcclxuQ29sbGlzaW9uR3JvdXBNYW5hZ2VyLl9HUk9VUFMgPSBuZXcgTWFwKCk7XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vQ29sbGlzaW9uL0luZGV4LnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9EcmF3aW5nL1BvbHlnb24udHNcbnZhciBQb2x5Z29uX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG5cclxuXHJcbi8qKlxyXG4gKiBDcmVhdGVzIGEgY2xvc2VkIHBvbHlnb24gZHJhd2luZyBnaXZlbiBhIGxpc3Qgb2YgW1tWZWN0b3JdXXMuXHJcbiAqXHJcbiAqIEBkZXByZWNhdGVkIFVzZSBbW1BvbHlnb25dXVxyXG4gKiBAd2FybmluZyBVc2Ugc3BhcmluZ2x5IGFzIFBvbHlnb25zIGFyZSBwZXJmb3JtYW5jZSBpbnRlbnNpdmVcclxuICovXHJcbmxldCBQb2x5Z29uID0gY2xhc3MgUG9seWdvbiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwb2ludHMgIFRoZSB2ZWN0b3JzIHRvIHVzZSB0byBidWlsZCB0aGUgcG9seWdvbiBpbiBvcmRlclxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3Rvcihwb2ludHMpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUaGUgd2lkdGggb2YgdGhlIGxpbmVzIG9mIHRoZSBwb2x5Z29uXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5saW5lV2lkdGggPSA1O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwb2x5Z29uIGlzIGZpbGxlZCBvciBub3QuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5maWxsZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBbXTtcclxuICAgICAgICB0aGlzLmFuY2hvciA9IFZlY3Rvci5aZXJvO1xyXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gVmVjdG9yLlplcm87XHJcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IDA7XHJcbiAgICAgICAgdGhpcy5zY2FsZSA9IFZlY3Rvci5PbmU7XHJcbiAgICAgICAgdGhpcy5vcGFjaXR5ID0gMTtcclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICAgICAgY29uc3QgbWluWCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKHByZXYsIGN1cnIueCk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgY29uc3QgbWF4WCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHByZXYsIGN1cnIueCk7XHJcbiAgICAgICAgfSwgMCk7XHJcbiAgICAgICAgdGhpcy5kcmF3V2lkdGggPSBtYXhYIC0gbWluWDtcclxuICAgICAgICBjb25zdCBtaW5ZID0gdGhpcy5fcG9pbnRzLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5taW4ocHJldiwgY3Vyci55KTtcclxuICAgICAgICB9LCAwKTtcclxuICAgICAgICBjb25zdCBtYXhZID0gdGhpcy5fcG9pbnRzLnJlZHVjZSgocHJldiwgY3VycikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gTWF0aC5tYXgocHJldiwgY3Vyci55KTtcclxuICAgICAgICB9LCAwKTtcclxuICAgICAgICB0aGlzLmRyYXdIZWlnaHQgPSBtYXhZIC0gbWluWTtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuZHJhd0hlaWdodDtcclxuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5kcmF3V2lkdGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEBub3RpbXBsZW1lbnRlZCBFZmZlY3RzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIGBQb2x5Z29uYFxyXG4gICAgICovXHJcbiAgICBhZGRFZmZlY3QoKSB7XHJcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBvbiBwb2x5Z29uc1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBAbm90aW1wbGVtZW50ZWQgRWZmZWN0cyBhcmUgbm90IHN1cHBvcnRlZCBvbiBgUG9seWdvbmBcclxuICAgICAqL1xyXG4gICAgcmVtb3ZlRWZmZWN0KCkge1xyXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgb24gcG9seWdvbnNcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQG5vdGltcGxlbWVudGVkIEVmZmVjdHMgYXJlIG5vdCBzdXBwb3J0ZWQgb24gYFBvbHlnb25gXHJcbiAgICAgKi9cclxuICAgIGNsZWFyRWZmZWN0cygpIHtcclxuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIG9uIHBvbHlnb25zXHJcbiAgICB9XHJcbiAgICByZXNldCgpIHtcclxuICAgICAgICAvL3Bhc3NcclxuICAgIH1cclxuICAgIGRyYXcoY3R4T3JPcHRpb25zLCB4LCB5KSB7XHJcbiAgICAgICAgaWYgKGN0eE9yT3B0aW9ucyBpbnN0YW5jZW9mIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCkge1xyXG4gICAgICAgICAgICB0aGlzLl9kcmF3V2l0aE9wdGlvbnMoeyBjdHg6IGN0eE9yT3B0aW9ucywgeCwgeSB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2RyYXdXaXRoT3B0aW9ucyhjdHhPck9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9kcmF3V2l0aE9wdGlvbnMob3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9qO1xyXG4gICAgICAgIGNvbnN0IHsgY3R4LCB4LCB5LCByb3RhdGlvbiwgZHJhd1dpZHRoLCBkcmF3SGVpZ2h0LCBhbmNob3IsIG9mZnNldCwgb3BhY2l0eSwgZmxpcEhvcml6b250YWwsIGZsaXBWZXJ0aWNhbCB9ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyByb3RhdGlvbjogKF9hID0gb3B0aW9ucy5yb3RhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5yb3RhdGlvbiwgZHJhd1dpZHRoOiAoX2IgPSBvcHRpb25zLmRyYXdXaWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5kcmF3V2lkdGgsIGRyYXdIZWlnaHQ6IChfYyA9IG9wdGlvbnMuZHJhd0hlaWdodCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogdGhpcy5kcmF3SGVpZ2h0LCBmbGlwSG9yaXpvbnRhbDogKF9kID0gb3B0aW9ucy5mbGlwSG9yaXpvbnRhbCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogdGhpcy5mbGlwSG9yaXpvbnRhbCwgZmxpcFZlcnRpY2FsOiAoX2UgPSBvcHRpb25zLmZsaXBWZXJ0aWNhbCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogdGhpcy5mbGlwVmVydGljYWwsIGFuY2hvcjogKF9mID0gb3B0aW9ucy5hbmNob3IpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IHRoaXMuYW5jaG9yLCBvZmZzZXQ6IChfZyA9IG9wdGlvbnMub2Zmc2V0KSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB0aGlzLm9mZnNldCwgb3BhY2l0eTogKChfaCA9IG9wdGlvbnMub3BhY2l0eSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogMSkgKiAoKF9qID0gdGhpcy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfaiAhPT0gdm9pZCAwID8gX2ogOiAxKSB9KTtcclxuICAgICAgICBjb25zdCB4cG9pbnQgPSBkcmF3V2lkdGggKiBhbmNob3IueCArIG9mZnNldC54ICsgeDtcclxuICAgICAgICBjb25zdCB5cG9pbnQgPSBkcmF3SGVpZ2h0ICogYW5jaG9yLnkgKyBvZmZzZXQueSArIHk7XHJcbiAgICAgICAgY3R4LnNhdmUoKTtcclxuICAgICAgICBjdHgudHJhbnNsYXRlKHhwb2ludCwgeXBvaW50KTtcclxuICAgICAgICBjdHguc2NhbGUodGhpcy5zY2FsZS54LCB0aGlzLnNjYWxlLnkpO1xyXG4gICAgICAgIGN0eC5yb3RhdGUocm90YXRpb24pO1xyXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBjdHgubGluZVdpZHRoID0gdGhpcy5saW5lV2lkdGg7XHJcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBzdXBwbGllZCBwb2ludHMgYW5kIGNvbnN0cnVjdCBhICdwb2x5Z29uJ1xyXG4gICAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSB0aGlzLl9wb2ludHNbMF07XHJcbiAgICAgICAgY3R4Lm1vdmVUbyhmaXJzdFBvaW50LngsIGZpcnN0UG9pbnQueSk7XHJcbiAgICAgICAgbGV0IGkgPSAwO1xyXG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMuX3BvaW50cy5sZW5ndGg7XHJcbiAgICAgICAgZm9yIChpOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLl9wb2ludHNbaV0ueCwgdGhpcy5fcG9pbnRzW2ldLnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XHJcbiAgICAgICAgaWYgKHRoaXMuZmlsbGVkKSB7XHJcbiAgICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSB0aGlzLmZpbGxDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgICAgICBjdHguZmlsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLmxpbmVDb2xvci50b1N0cmluZygpO1xyXG4gICAgICAgIGlmIChmbGlwSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICBjdHgudHJhbnNsYXRlKGRyYXdXaWR0aCwgMCk7XHJcbiAgICAgICAgICAgIGN0eC5zY2FsZSgtMSwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmbGlwVmVydGljYWwpIHtcclxuICAgICAgICAgICAgY3R4LnRyYW5zbGF0ZSgwLCBkcmF3SGVpZ2h0KTtcclxuICAgICAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgb2xkQWxwaGEgPSBjdHguZ2xvYmFsQWxwaGE7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcclxuICAgICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgICAgY3R4Lmdsb2JhbEFscGhhID0gb2xkQWxwaGE7XHJcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcclxuICAgIH1cclxufTtcclxuUG9seWdvbiA9IFBvbHlnb25fZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoe1xyXG4gICAgICAgIG1lc3NhZ2U6ICdQb2x5Z29uIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgR3JhcGhpY3MuUG9seWdvbidcclxuICAgIH0pXHJcbl0sIFBvbHlnb24pO1xyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9EcmF3aW5nL0luZGV4LnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0ludGVyZmFjZXMvQXVkaW9JbXBsZW1lbnRhdGlvbi50c1xuY2xhc3MgRXhSZXNwb25zZSB7XHJcbn1cclxuRXhSZXNwb25zZS50eXBlID0ge1xyXG4gICAgYW55OiAnJyxcclxuICAgIGJsb2I6ICdibG9iJyxcclxuICAgIGpzb246ICdqc29uJyxcclxuICAgIHRleHQ6ICd0ZXh0JyxcclxuICAgIGRvY3VtZW50OiAnZG9jdW1lbnQnLFxyXG4gICAgYXJyYXlidWZmZXI6ICdhcnJheWJ1ZmZlcidcclxufTtcclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnRlcmZhY2VzL0xpZmVjeWNsZUV2ZW50cy50c1xuLyoqXHJcbiAqIFR5cGUgZ3VhcmQgY2hlY2tpbmcgZm9yIGludGVybmFsIGluaXRpYWxpemUgbWV0aG9kXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAcGFyYW0gYVxyXG4gKi9cclxuZnVuY3Rpb24gaGFzX2luaXRpYWxpemUoYSkge1xyXG4gICAgcmV0dXJuICEhYS5faW5pdGlhbGl6ZTtcclxufVxyXG4vKipcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGhhc09uSW5pdGlhbGl6ZShhKSB7XHJcbiAgICByZXR1cm4gISFhLm9uSW5pdGlhbGl6ZTtcclxufVxyXG4vKipcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGhhc19wcmV1cGRhdGUoYSkge1xyXG4gICAgcmV0dXJuICEhYS5fcHJldXBkYXRlO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzT25QcmVVcGRhdGUoYSkge1xyXG4gICAgcmV0dXJuICEhYS5vblByZVVwZGF0ZTtcclxufVxyXG4vKipcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGhhc19wb3N0dXBkYXRlKGEpIHtcclxuICAgIHJldHVybiAhIWEub25Qb3N0VXBkYXRlO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzT25Qb3N0VXBkYXRlKGEpIHtcclxuICAgIHJldHVybiAhIWEub25Qb3N0VXBkYXRlO1xyXG59XHJcbi8qKlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gaGFzUHJlRHJhdyhhKSB7XHJcbiAgICByZXR1cm4gISFhLm9uUHJlRHJhdztcclxufVxyXG4vKipcclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGhhc1Bvc3REcmF3KGEpIHtcclxuICAgIHJldHVybiAhIWEub25Qb3N0RHJhdztcclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0ludGVyZmFjZXMvSW5kZXgudHNcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUG9zdFByb2Nlc3NpbmcvSW5kZXgudHNcblxyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9SZXNvdXJjZXMvU291bmQvV2ViQXVkaW9JbnN0YW5jZS50c1xuXHJcblxyXG4vKipcclxuICogSW50ZXJuYWwgY2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViIEF1ZGlvIEF1ZGlvQnVmZmVyU291cmNlTm9kZSBpbnN0YW5jZVxyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfQXVkaW9fQVBJXHJcbiAqL1xyXG5jbGFzcyBXZWJBdWRpb0luc3RhbmNlIHtcclxuICAgIGNvbnN0cnVjdG9yKF9zcmMpIHtcclxuICAgICAgICB0aGlzLl9zcmMgPSBfc3JjO1xyXG4gICAgICAgIHRoaXMuX3ZvbHVtZSA9IDE7XHJcbiAgICAgICAgdGhpcy5fZHVyYXRpb24gPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2lzUGF1c2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fYXVkaW9Db250ZXh0ID0gQXVkaW9Db250ZXh0RmFjdG9yeS5jcmVhdGUoKTtcclxuICAgICAgICB0aGlzLl92b2x1bWVOb2RlID0gdGhpcy5fYXVkaW9Db250ZXh0LmNyZWF0ZUdhaW4oKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDdXJyZW50IHBsYXliYWNrIG9mZnNldCAoaW4gc2Vjb25kcylcclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gMDtcclxuICAgICAgICB0aGlzLl9jcmVhdGVOZXdCdWZmZXJTb3VyY2UoKTtcclxuICAgIH1cclxuICAgIHNldCBsb29wKHZhbHVlKSB7XHJcbiAgICAgICAgdGhpcy5fbG9vcCA9IHZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLl9pbnN0YW5jZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5sb29wID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRoaXMuX3dpcmVVcE9uRW5kZWQoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgbG9vcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9vcDtcclxuICAgIH1cclxuICAgIHNldCB2b2x1bWUodmFsdWUpIHtcclxuICAgICAgICB2YWx1ZSA9IGNsYW1wKHZhbHVlLCAwLCAxLjApO1xyXG4gICAgICAgIHRoaXMuX3ZvbHVtZSA9IHZhbHVlO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1BsYXlpbmcgJiYgdGhpcy5fdm9sdW1lTm9kZS5nYWluLnNldFRhcmdldEF0VGltZSkge1xyXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQXVkaW9QYXJhbS9zZXRUYXJnZXRBdFRpbWVcclxuICAgICAgICAgICAgLy8gQWZ0ZXIgZWFjaCAuMSBzZWNvbmRzIHRpbWVzdGVwLCB0aGUgdGFyZ2V0IHZhbHVlIHdpbGwgfjYzLjIlIGNsb3NlciB0byB0aGUgdGFyZ2V0IHZhbHVlLlxyXG4gICAgICAgICAgICAvLyBUaGlzIGV4cG9uZW50aWFsIHJhbXAgcHJvdmlkZXMgYSBtb3JlIHBsZWFzYW50IHRyYW5zaXRpb24gaW4gZ2FpblxyXG4gICAgICAgICAgICB0aGlzLl92b2x1bWVOb2RlLmdhaW4uc2V0VGFyZ2V0QXRUaW1lKHZhbHVlLCB0aGlzLl9hdWRpb0NvbnRleHQuY3VycmVudFRpbWUsIDAuMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl92b2x1bWVOb2RlLmdhaW4udmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBnZXQgdm9sdW1lKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl92b2x1bWU7XHJcbiAgICB9XHJcbiAgICBzZXQgZHVyYXRpb24odmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IHZhbHVlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBEdXJhdGlvbiBvZiB0aGUgc291bmQsIGluIHNlY29uZHMuXHJcbiAgICAgKi9cclxuICAgIGdldCBkdXJhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZHVyYXRpb247XHJcbiAgICB9XHJcbiAgICBnZXQgX3BsYXliYWNrUmF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgPyAxIC8gKHRoaXMuX2luc3RhbmNlLnBsYXliYWNrUmF0ZS52YWx1ZSB8fCAxLjApIDogbnVsbDtcclxuICAgIH1cclxuICAgIGlzUGxheWluZygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5faXNQbGF5aW5nO1xyXG4gICAgfVxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxyXG4gICAgcGxheShwbGF5U3RhcnRlZCA9ICgpID0+IHsgfSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZXN1bWVQbGF5QmFjaygpO1xyXG4gICAgICAgICAgICBwbGF5U3RhcnRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX2lzUGxheWluZykge1xyXG4gICAgICAgICAgICB0aGlzLl9zdGFydFBsYXlCYWNrKCk7XHJcbiAgICAgICAgICAgIHBsYXlTdGFydGVkKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9wbGF5aW5nUHJvbWlzZTtcclxuICAgIH1cclxuICAgIHBhdXNlKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlLnN0b3AoMCk7XHJcbiAgICAgICAgLy8gUGxheWJhY2sgcmF0ZSB3aWxsIGJlIGEgc2NhbGUgZmFjdG9yIG9mIGhvdyBmYXN0L3Nsb3cgdGhlIGF1ZGlvIGlzIGJlaW5nIHBsYXllZFxyXG4gICAgICAgIC8vIGRlZmF1bHQgaXMgMS4wXHJcbiAgICAgICAgLy8gd2UgbmVlZCB0byBpbnZlcnQgaXQgdG8gZ2V0IHRoZSB0aW1lIHNjYWxlXHJcbiAgICAgICAgdGhpcy5fc2V0UGF1c2VPZmZzZXQoKTtcclxuICAgIH1cclxuICAgIHN0b3AoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc1BsYXlpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlLnN0b3AoMCk7XHJcbiAgICAgICAgLy8gaGFuZGxlciB3aWxsIG5vdCBiZSB3aXJlZCB1cCBpZiB3ZSB3ZXJlIGxvb3BpbmdcclxuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlLm9uZW5kZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5faGFuZGxlT25FbmRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9zdGFydFBsYXlCYWNrKCkge1xyXG4gICAgICAgIHRoaXMuX2lzUGxheWluZyA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9wbGF5aW5nUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3BsYXlpbmdSZXNvbHZlID0gcmVzb2x2ZTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoIXRoaXMuX2luc3RhbmNlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU5ld0J1ZmZlclNvdXJjZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9yZW1lbWJlclN0YXJ0VGltZSgpO1xyXG4gICAgICAgIHRoaXMuX3ZvbHVtZU5vZGUuY29ubmVjdCh0aGlzLl9hdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlLnN0YXJ0KDAsIDApO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRPZmZzZXQgPSAwO1xyXG4gICAgICAgIHRoaXMuX3dpcmVVcE9uRW5kZWQoKTtcclxuICAgIH1cclxuICAgIF9yZXN1bWVQbGF5QmFjaygpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNQYXVzZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSB0cnVlO1xyXG4gICAgICAgIC8vIGEgYnVmZmVyIHNvdXJjZSBjYW4gb25seSBiZSBzdGFydGVkIG9uY2VcclxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIGRpc3Bvc2Ugb2YgdGhlIHByZXZpb3VzIGluc3RhbmNlIGJlZm9yZVxyXG4gICAgICAgIC8vIFwicmVzdW1pbmdcIiB0aGUgbmV4dCBvbmVcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5vbmVuZGVkID0gbnVsbDsgLy8gZGlzcG9zZSBvZiBhbnkgcHJldmlvdXMgZXZlbnQgaGFuZGxlclxyXG4gICAgICAgIHRoaXMuX2NyZWF0ZU5ld0J1ZmZlclNvdXJjZSgpO1xyXG4gICAgICAgIGNvbnN0IGR1cmF0aW9uID0gdGhpcy5fcGxheWJhY2tSYXRlICogdGhpcy5fc3JjLmR1cmF0aW9uO1xyXG4gICAgICAgIGNvbnN0IHJlc3RhcnRUaW1lID0gdGhpcy5fY3VycmVudE9mZnNldCAlIGR1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuX3JlbWVtYmVyU3RhcnRUaW1lKHJlc3RhcnRUaW1lICogLTEwMDApO1xyXG4gICAgICAgIHRoaXMuX2luc3RhbmNlLnN0YXJ0KDAsIHJlc3RhcnRUaW1lKTtcclxuICAgICAgICB0aGlzLl93aXJlVXBPbkVuZGVkKCk7XHJcbiAgICB9XHJcbiAgICBfd2lyZVVwT25FbmRlZCgpIHtcclxuICAgICAgICBpZiAoIXRoaXMubG9vcCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pbnN0YW5jZS5vbmVuZGVkID0gKCkgPT4gdGhpcy5faGFuZGxlT25FbmRlZCgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9oYW5kbGVPbkVuZGVkKCkge1xyXG4gICAgICAgIC8vIHBhdXNpbmcgY2FsbHMgc3RvcCgwKSB3aGljaCB0cmlnZ2VycyBvbmVuZGVkIGV2ZW50XHJcbiAgICAgICAgLy8gc28gd2UgZG9uJ3QgXCJyZXNvbHZlXCIgeWV0ICh3aGVuIHdlIHJlc3VtZSB3ZSdsbCB0cnkgYWdhaW4pXHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgdGhpcy5fcGxheWluZ1Jlc29sdmUodHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3JlbWVtYmVyU3RhcnRUaW1lKGFtZW5kKSB7XHJcbiAgICAgICAgdGhpcy5fc3RhcnRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyAoYW1lbmQgfCAwKTtcclxuICAgIH1cclxuICAgIF9zZXRQYXVzZU9mZnNldCgpIHtcclxuICAgICAgICB0aGlzLl9jdXJyZW50T2Zmc2V0ID0gKChuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHRoaXMuX3N0YXJ0VGltZSkgKiB0aGlzLl9wbGF5YmFja1JhdGUpIC8gMTAwMDsgLy8gaW4gc2Vjb25kc1xyXG4gICAgfVxyXG4gICAgX2NyZWF0ZU5ld0J1ZmZlclNvdXJjZSgpIHtcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IHRoaXMuX2F1ZGlvQ29udGV4dC5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5idWZmZXIgPSB0aGlzLl9zcmM7XHJcbiAgICAgICAgdGhpcy5faW5zdGFuY2UubG9vcCA9IHRoaXMubG9vcDtcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5wbGF5YmFja1JhdGUuc2V0VmFsdWVBdFRpbWUoMS4wLCAwKTtcclxuICAgICAgICB0aGlzLl9pbnN0YW5jZS5jb25uZWN0KHRoaXMuX3ZvbHVtZU5vZGUpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vVXRpbC9Tb3VuZC50c1xuXHJcbi8qKlxyXG4gKiBXaGV0aGVyIG9yIG5vdCB0aGUgYnJvd3NlciBjYW4gcGxheSB0aGlzIGZpbGUgYXMgSFRNTDUgQXVkaW9cclxuICovXHJcbmZ1bmN0aW9uIGNhblBsYXlGaWxlKGZpbGUpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgYSA9IG5ldyBBdWRpbygpO1xyXG4gICAgICAgIGNvbnN0IGZpbGV0eXBlID0gLy4qXFwuKFtBLVphLXowLTldKykkLztcclxuICAgICAgICBjb25zdCB0eXBlID0gZmlsZS5tYXRjaChmaWxldHlwZSlbMV07XHJcbiAgICAgICAgaWYgKGEuY2FuUGxheVR5cGUoJ2F1ZGlvLycgKyB0eXBlKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0Nhbm5vdCBkZXRlcm1pbmUgYXVkaW8gc3VwcG9ydCwgYXNzdW1pbmcgbm8gc3VwcG9ydCBmb3IgdGhlIEF1ZGlvIFRhZycsIGUpO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1Jlc291cmNlcy9Tb3VuZC9Tb3VuZC50c1xudmFyIFNvdW5kX2F3YWl0ZXIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLyoqXHJcbiAqIFRoZSBbW1NvdW5kXV0gb2JqZWN0IGFsbG93cyBnYW1lcyBidWlsdCBpbiBFeGNhbGlidXIgdG8gbG9hZCBhdWRpb1xyXG4gKiBjb21wb25lbnRzLCBmcm9tIHNvdW5kdHJhY2tzIHRvIHNvdW5kIGVmZmVjdHMuIFtbU291bmRdXSBpcyBhbiBbW0xvYWRhYmxlXV1cclxuICogd2hpY2ggbWVhbnMgaXQgY2FuIGJlIHBhc3NlZCB0byBhIFtbTG9hZGVyXV0gdG8gcHJlLWxvYWQgYmVmb3JlIGEgZ2FtZSBvciBsZXZlbC5cclxuICovXHJcbmNsYXNzIFNvdW5kIGV4dGVuZHMgQ2xhc3Mge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcGF0aHMgQSBsaXN0IG9mIGF1ZGlvIHNvdXJjZXMgKGNsaXAud2F2LCBjbGlwLm1wMywgY2xpcC5vZ2cpIGZvciB0aGlzIGF1ZGlvIGNsaXAuIFRoaXMgaXMgZG9uZSBmb3IgYnJvd3NlciBjb21wYXRpYmlsaXR5LlxyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvciguLi5wYXRocykge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBMb2dnZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fdm9sdW1lID0gMTtcclxuICAgICAgICB0aGlzLl9kdXJhdGlvbiA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLl9pc1N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3RyYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbiA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2F1ZGlvQ29udGV4dCA9IEF1ZGlvQ29udGV4dEZhY3RvcnkuY3JlYXRlKCk7XHJcbiAgICAgICAgdGhpcy5fcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2UoJycsIEV4UmVzcG9uc2UudHlwZS5hcnJheWJ1ZmZlcik7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQ2hyb21lIDogTVAzLCBXQVYsIE9nZ1xyXG4gICAgICAgICAqIEZpcmVmb3ggOiBXQVYsIE9nZyxcclxuICAgICAgICAgKiBJRSA6IE1QMywgV0FWIGNvbWluZyBzb29uXHJcbiAgICAgICAgICogU2FmYXJpIE1QMywgV0FWLCBPZ2dcclxuICAgICAgICAgKi9cclxuICAgICAgICBmb3IgKGNvbnN0IHBhdGggb2YgcGF0aHMpIHtcclxuICAgICAgICAgICAgaWYgKGNhblBsYXlGaWxlKHBhdGgpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCF0aGlzLnBhdGgpIHtcclxuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybignVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgYW55IG9mIHRoZSBhdWRpbyBmaWxlcyBzcGVjaWZpZWQ6JywgcGF0aHMuam9pbignLCAnKSk7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0F0dGVtcHRpbmcgdG8gdXNlJywgcGF0aHNbMF0pO1xyXG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXRoc1swXTsgLy8gc2VsZWN0IHRoZSBmaXJzdCBzcGVjaWZpZWRcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBjbGlwIHNob3VsZCBsb29wIHdoZW4gY29tcGxldGVcclxuICAgICAqIEBwYXJhbSB2YWx1ZSAgU2V0IHRoZSBsb29waW5nIGZsYWdcclxuICAgICAqL1xyXG4gICAgc2V0IGxvb3AodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl9sb29wID0gdmFsdWU7XHJcbiAgICAgICAgZm9yIChjb25zdCB0cmFjayBvZiB0aGlzLl90cmFja3MpIHtcclxuICAgICAgICAgICAgdHJhY2subG9vcCA9IHRoaXMuX2xvb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTZXQgbG9vcCBmb3IgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCwgJ3RvJywgdGhpcy5fbG9vcCk7XHJcbiAgICB9XHJcbiAgICBnZXQgbG9vcCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbG9vcDtcclxuICAgIH1cclxuICAgIHNldCB2b2x1bWUodmFsdWUpIHtcclxuICAgICAgICB0aGlzLl92b2x1bWUgPSB2YWx1ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHRoaXMuX3RyYWNrcykge1xyXG4gICAgICAgICAgICB0cmFjay52b2x1bWUgPSB0aGlzLl92b2x1bWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW1pdCgndm9sdW1lY2hhbmdlJywgbmV3IE5hdGl2ZVNvdW5kRXZlbnQodGhpcykpO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTZXQgbG9vcCBmb3IgYWxsIGluc3RhbmNlcyBvZiBzb3VuZCcsIHRoaXMucGF0aCwgJ3RvJywgdGhpcy5fdm9sdW1lKTtcclxuICAgIH1cclxuICAgIGdldCB2b2x1bWUoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZvbHVtZTtcclxuICAgIH1cclxuICAgIGdldCBkdXJhdGlvbigpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZHVyYXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhcnJheSBvZiBDdXJyZW50IEF1ZGlvSW5zdGFuY2VzIHBsYXlpbmcgb3IgYmVpbmcgcGF1c2VkXHJcbiAgICAgKi9cclxuICAgIGdldCBpbnN0YW5jZXMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrcztcclxuICAgIH1cclxuICAgIGdldCBwYXRoKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvdXJjZS5wYXRoO1xyXG4gICAgfVxyXG4gICAgc2V0IHBhdGgodmFsKSB7XHJcbiAgICAgICAgdGhpcy5fcmVzb3VyY2UucGF0aCA9IHZhbDtcclxuICAgIH1cclxuICAgIGlzTG9hZGVkKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuZGF0YTtcclxuICAgIH1cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFNvdW5kX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY29uc3QgYXJyYXlidWZmZXIgPSB5aWVsZCB0aGlzLl9yZXNvdXJjZS5sb2FkKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGF1ZGlvYnVmZmVyID0geWllbGQgdGhpcy5kZWNvZGVBdWRpbyhhcnJheWJ1ZmZlci5zbGljZSgwKSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2R1cmF0aW9uID0gdHlwZW9mIGF1ZGlvYnVmZmVyID09PSAnb2JqZWN0JyA/IGF1ZGlvYnVmZmVyLmR1cmF0aW9uIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3Byb2Nlc3NlZCcsIG5ldyBOYXRpdmVTb3VuZFByb2Nlc3NlZEV2ZW50KHRoaXMsIGF1ZGlvYnVmZmVyKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEgPSBhdWRpb2J1ZmZlcjtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGRlY29kZUF1ZGlvKGRhdGEpIHtcclxuICAgICAgICByZXR1cm4gU291bmRfYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLl9hdWRpb0NvbnRleHQuZGVjb2RlQXVkaW9EYXRhKGRhdGEuc2xpY2UoMCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcignVW5hYmxlIHRvIGRlY29kZSAnICtcclxuICAgICAgICAgICAgICAgICAgICAnIHRoaXMgYnJvd3NlciBtYXkgbm90IGZ1bGx5IHN1cHBvcnQgdGhpcyBmb3JtYXQsIG9yIHRoZSBmaWxlIG1heSBiZSBjb3JydXB0LCAnICtcclxuICAgICAgICAgICAgICAgICAgICAnaWYgdGhpcyBpcyBhbiBtcDMgdHJ5IHJlbW92aW5nIGlkMyB0YWdzIGFuZCBhbGJ1bSBhcnQgZnJvbSB0aGUgZmlsZS4nKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBQcm9taXNlLnJlamVjdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICB3aXJlRW5naW5lKGVuZ2luZSkge1xyXG4gICAgICAgIGlmIChlbmdpbmUpIHtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lID0gZW5naW5lO1xyXG4gICAgICAgICAgICB0aGlzLl9lbmdpbmUub24oJ2hpZGRlbicsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChlbmdpbmUucGF1c2VBdWRpb1doZW5IaWRkZW4gJiYgdGhpcy5pc1BsYXlpbmcoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dhc1BsYXlpbmdPbkhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy5fZW5naW5lLm9uKCd2aXNpYmxlJywgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuZ2luZS5wYXVzZUF1ZGlvV2hlbkhpZGRlbiAmJiB0aGlzLl93YXNQbGF5aW5nT25IaWRkZW4pIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl93YXNQbGF5aW5nT25IaWRkZW4gPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5vbignc3RhcnQnLCAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1N0b3BwZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VuZ2luZS5vbignc3RvcCcsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faXNTdG9wcGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGhvdyBtYW55IGluc3RhbmNlcyBvZiB0aGUgc291bmQgYXJlIGN1cnJlbnRseSBwbGF5aW5nXHJcbiAgICAgKi9cclxuICAgIGluc3RhbmNlQ291bnQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrcy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdoZXRoZXIgb3Igbm90IHRoZSBzb3VuZCBpcyBwbGF5aW5nIHJpZ2h0IG5vd1xyXG4gICAgICovXHJcbiAgICBpc1BsYXlpbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrcy5zb21lKCh0KSA9PiB0LmlzUGxheWluZygpKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUGxheSB0aGUgc291bmQsIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgc291bmQgaXMgZG9uZSBwbGF5aW5nXHJcbiAgICAgKiBBbiBvcHRpb25hbCB2b2x1bWUgYXJndW1lbnQgY2FuIGJlIHBhc3NlZCBpbiB0byBwbGF5IHRoZSBzb3VuZC4gTWF4IHZvbHVtZSBpcyAxLjBcclxuICAgICAqL1xyXG4gICAgcGxheSh2b2x1bWUpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNMb2FkZWQoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmxvZ2dlci53YXJuKCdDYW5ub3Qgc3RhcnQgcGxheWluZy4gUmVzb3VyY2UnLCB0aGlzLnBhdGgsICdpcyBub3QgbG9hZGVkIHlldCcpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5faXNTdG9wcGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyLndhcm4oJ0Nhbm5vdCBzdGFydCBwbGF5aW5nLiBFbmdpbmUgaXMgaW4gYSBzdG9wcGVkIHN0YXRlLicpO1xyXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy52b2x1bWUgPSB2b2x1bWUgfHwgdGhpcy52b2x1bWU7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXN1bWVQbGF5YmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXJ0UGxheWJhY2soKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFN0b3AgdGhlIHNvdW5kLCBhbmQgZG8gbm90IHJld2luZFxyXG4gICAgICovXHJcbiAgICBwYXVzZSgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaXNQbGF5aW5nKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHRoaXMuX3RyYWNrcykge1xyXG4gICAgICAgICAgICB0cmFjay5wYXVzZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lbWl0KCdwYXVzZScsIG5ldyBOYXRpdmVTb3VuZEV2ZW50KHRoaXMpKTtcclxuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnUGF1c2VkIGFsbCBpbnN0YW5jZXMgb2Ygc291bmQnLCB0aGlzLnBhdGgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdG9wIHRoZSBzb3VuZCBpZiBpdCBpcyBjdXJyZW50bHkgcGxheWluZyBhbmQgcmV3aW5kIHRoZSB0cmFjay4gSWYgdGhlIHNvdW5kIGlzIG5vdCBwbGF5aW5nLCByZXdpbmRzIHRoZSB0cmFjay5cclxuICAgICAqL1xyXG4gICAgc3RvcCgpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IHRyYWNrIG9mIHRoaXMuX3RyYWNrcykge1xyXG4gICAgICAgICAgICB0cmFjay5zdG9wKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuZW1pdCgnc3RvcCcsIG5ldyBOYXRpdmVTb3VuZEV2ZW50KHRoaXMpKTtcclxuICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX3RyYWNrcy5sZW5ndGggPSAwO1xyXG4gICAgICAgIHRoaXMubG9nZ2VyLmRlYnVnKCdTdG9wcGVkIGFsbCBpbnN0YW5jZXMgb2Ygc291bmQnLCB0aGlzLnBhdGgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgSWQgb2YgcHJvdmlkZWQgQXVkaW9JbnN0YW5jZSBpbiBjdXJyZW50IHRyYWNrTGlzdFxyXG4gICAgICogQHBhcmFtIHRyYWNrIFtbQXVkaW9dXSB3aGljaCBJZCBpcyB0byBiZSBnaXZlblxyXG4gICAgICovXHJcbiAgICBnZXRUcmFja0lkKHRyYWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrcy5pbmRleE9mKHRyYWNrKTtcclxuICAgIH1cclxuICAgIF9yZXN1bWVQbGF5YmFjaygpIHtcclxuICAgICAgICByZXR1cm4gU291bmRfYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2lzUGF1c2VkKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bWVkID0gW107XHJcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgd2UgcmVzdW1lICpjdXJyZW50KiB0cmFja3MgKGlmIHBhdXNlZClcclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdHJhY2sgb2YgdGhpcy5fdHJhY2tzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzdW1lZC5wdXNoKHRyYWNrLnBsYXkoKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZXN1bWUnLCBuZXcgTmF0aXZlU291bmRFdmVudCh0aGlzKSk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZygnUmVzdW1pbmcgcGF1c2VkIGluc3RhbmNlcyBmb3Igc291bmQnLCB0aGlzLnBhdGgsIHRoaXMuX3RyYWNrcyk7XHJcbiAgICAgICAgICAgICAgICAvLyByZXNvbHZlIHdoZW4gcmVzdW1lZCB0cmFja3MgYXJlIGRvbmVcclxuICAgICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHJlc3VtZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgcGxheWJhY2ssIHJldHVybnMgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiBwbGF5YmFjayBpcyBjb21wbGV0ZVxyXG4gICAgICovXHJcbiAgICBfc3RhcnRQbGF5YmFjaygpIHtcclxuICAgICAgICByZXR1cm4gU291bmRfYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcclxuICAgICAgICAgICAgY29uc3QgdHJhY2sgPSB5aWVsZCB0aGlzLl9nZXRUcmFja0luc3RhbmNlKHRoaXMuZGF0YSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNvbXBsZXRlID0geWllbGQgdHJhY2sucGxheSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3BsYXliYWNrc3RhcnQnLCBuZXcgTmF0aXZlU291bmRFdmVudCh0aGlzLCB0cmFjaykpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZXIuZGVidWcoJ1BsYXlpbmcgbmV3IGluc3RhbmNlIGZvciBzb3VuZCcsIHRoaXMucGF0aCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAvLyB3aGVuIGRvbmUsIHJlbW92ZSB0cmFja1xyXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3BsYXliYWNrZW5kJywgbmV3IE5hdGl2ZVNvdW5kRXZlbnQodGhpcywgdHJhY2spKTtcclxuICAgICAgICAgICAgdGhpcy5fdHJhY2tzLnNwbGljZSh0aGlzLmdldFRyYWNrSWQodHJhY2spLCAxKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbXBsZXRlO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2dldFRyYWNrSW5zdGFuY2UoZGF0YSkge1xyXG4gICAgICAgIGNvbnN0IG5ld1RyYWNrID0gbmV3IFdlYkF1ZGlvSW5zdGFuY2UoZGF0YSk7XHJcbiAgICAgICAgbmV3VHJhY2subG9vcCA9IHRoaXMubG9vcDtcclxuICAgICAgICBuZXdUcmFjay52b2x1bWUgPSB0aGlzLnZvbHVtZTtcclxuICAgICAgICBuZXdUcmFjay5kdXJhdGlvbiA9IHRoaXMuZHVyYXRpb247XHJcbiAgICAgICAgdGhpcy5fdHJhY2tzLnB1c2gobmV3VHJhY2spO1xyXG4gICAgICAgIHJldHVybiBuZXdUcmFjaztcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1Jlc291cmNlcy9Tb3VuZC9JbmRleC50c1xuXHJcblxyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9SZXNvdXJjZXMvR2lmLnRzXG52YXIgR2lmX2F3YWl0ZXIgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vKipcclxuICogVGhlIFtbVGV4dHVyZV1dIG9iamVjdCBhbGxvd3MgZ2FtZXMgYnVpbHQgaW4gRXhjYWxpYnVyIHRvIGxvYWQgaW1hZ2UgcmVzb3VyY2VzLlxyXG4gKiBbW1RleHR1cmVdXSBpcyBhbiBbW0xvYWRhYmxlXV0gd2hpY2ggbWVhbnMgaXQgY2FuIGJlIHBhc3NlZCB0byBhIFtbTG9hZGVyXV1cclxuICogdG8gcHJlLWxvYWQgYmVmb3JlIHN0YXJ0aW5nIGEgbGV2ZWwgb3IgZ2FtZS5cclxuICovXHJcbmNsYXNzIEdpZiB7XHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSBwYXRoICAgICAgIFBhdGggdG8gdGhlIGltYWdlIHJlc291cmNlXHJcbiAgICAgKiBAcGFyYW0gY29sb3IgICAgICBPcHRpb25hbGx5IHNldCB0aGUgY29sb3IgdG8gdHJlYXQgYXMgdHJhbnNwYXJlbnQgdGhlIGdpZiwgYnkgZGVmYXVsdCBbW0NvbG9yLk1hZ2VudGFdXVxyXG4gICAgICogQHBhcmFtIGJ1c3RDYWNoZSAgT3B0aW9uYWxseSBsb2FkIHRleHR1cmUgd2l0aCBjYWNoZSBidXN0aW5nXHJcbiAgICAgKi9cclxuICAgIGNvbnN0cnVjdG9yKHBhdGgsIGNvbG9yID0gQ29sb3IuTWFnZW50YSwgYnVzdENhY2hlID0gdHJ1ZSkge1xyXG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XHJcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xyXG4gICAgICAgIHRoaXMuYnVzdENhY2hlID0gYnVzdENhY2hlO1xyXG4gICAgICAgIHRoaXMuX3N0cmVhbSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fZ2lmID0gbnVsbDtcclxuICAgICAgICB0aGlzLl90ZXh0dXJlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbiA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fdHJhbnNwYXJlbnRDb2xvciA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcmVzb3VyY2UgPSBuZXcgUmVzb3VyY2UocGF0aCwgJ2FycmF5YnVmZmVyJywgYnVzdENhY2hlKTtcclxuICAgICAgICB0aGlzLl90cmFuc3BhcmVudENvbG9yID0gY29sb3I7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEJlZ2lucyBsb2FkaW5nIHRoZSB0ZXh0dXJlIGFuZCByZXR1cm5zIGEgcHJvbWlzZSB0byBiZSByZXNvbHZlZCBvbiBjb21wbGV0aW9uXHJcbiAgICAgKi9cclxuICAgIGxvYWQoKSB7XHJcbiAgICAgICAgcmV0dXJuIEdpZl9hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xyXG4gICAgICAgICAgICBjb25zdCBhcnJheWJ1ZmZlciA9IHlpZWxkIHRoaXMuX3Jlc291cmNlLmxvYWQoKTtcclxuICAgICAgICAgICAgdGhpcy5fc3RyZWFtID0gbmV3IFN0cmVhbShhcnJheWJ1ZmZlcik7XHJcbiAgICAgICAgICAgIHRoaXMuX2dpZiA9IG5ldyBQYXJzZUdpZih0aGlzLl9zdHJlYW0sIHRoaXMuX3RyYW5zcGFyZW50Q29sb3IpO1xyXG4gICAgICAgICAgICBjb25zdCBpbWFnZXMgPSB0aGlzLl9naWYuaW1hZ2VzLm1hcChpID0+IG5ldyBJbWFnZVNvdXJjZShpLnNyYywgZmFsc2UpKTtcclxuICAgICAgICAgICAgLy8gTG9hZCBhbGwgdGV4dHVyZXNcclxuICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoaW1hZ2VzLm1hcCh0ID0+IHQubG9hZCgpKSk7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEgPSB0aGlzLl90ZXh0dXJlcyA9IGltYWdlcztcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlzTG9hZGVkKCkge1xyXG4gICAgICAgIHJldHVybiAhIXRoaXMuZGF0YTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJuIGEgZnJhbWUgb2YgdGhlIGdpZiBhcyBhIGxlZ2FjeSBzcHJpdGUgYnkgaW5kZXhcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIHRvTGVnYWN5U3ByaXRlKGlkID0gMCkge1xyXG4gICAgICAgIHJldHVybiBTcHJpdGUudG9MZWdhY3lTcHJpdGUodGhpcy50b1Nwcml0ZShpZCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGdpZiBhcyBhIGxlZ2FjeSBzcHJpdGVzaGVldFxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIHRvTGVnYWN5U3ByaXRlU2hlZXQoKSB7XHJcbiAgICAgICAgcmV0dXJuIFNwcml0ZVNoZWV0LnRvTGVnYWN5U3ByaXRlU2hlZXQodGhpcy50b1Nwcml0ZVNoZWV0KCkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGdpZiBhcyBhIGxlZ2FjeSBhbmltYXRpb25cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKiBAcGFyYW0gc3BlZWRcclxuICAgICAqL1xyXG4gICAgdG9MZWdhY3lBbmltYXRpb24oZW5naW5lLCBzcGVlZCkge1xyXG4gICAgICAgIHJldHVybiBBbmltYXRpb24udG9MZWdhY3lBbmltYXRpb24oZW5naW5lLCB0aGlzLnRvQW5pbWF0aW9uKHNwZWVkKSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhIGZyYW1lIG9mIHRoZSBnaWYgYXMgYSBzcHJpdGUgYnkgaWRcclxuICAgICAqIEBwYXJhbSBpZFxyXG4gICAgICovXHJcbiAgICB0b1Nwcml0ZShpZCA9IDApIHtcclxuICAgICAgICBjb25zdCBzcHJpdGUgPSB0aGlzLl90ZXh0dXJlc1tpZF0udG9TcHJpdGUoKTtcclxuICAgICAgICByZXR1cm4gc3ByaXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm4gdGhlIGdpZiBhcyBhIHNwcml0ZXNoZWV0XHJcbiAgICAgKi9cclxuICAgIHRvU3ByaXRlU2hlZXQoKSB7XHJcbiAgICAgICAgY29uc3Qgc3ByaXRlcyA9IHRoaXMuX3RleHR1cmVzLm1hcCgoaW1hZ2UpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGltYWdlLnRvU3ByaXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBTcHJpdGVTaGVldCh7IHNwcml0ZXMgfSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFRyYW5zZm9ybSB0aGUgR0lGIGludG8gYW4gYW5pbWF0aW9uIHdpdGggZHVyYXRpb24gcGVyIGZyYW1lXHJcbiAgICAgKi9cclxuICAgIHRvQW5pbWF0aW9uKGR1cmF0aW9uUGVyRnJhbWVNcykge1xyXG4gICAgICAgIGNvbnN0IHNwcml0ZVNoZWV0ID0gdGhpcy50b1Nwcml0ZVNoZWV0KCk7XHJcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gc3ByaXRlU2hlZXQuc3ByaXRlcy5sZW5ndGg7XHJcbiAgICAgICAgdGhpcy5fYW5pbWF0aW9uID0gQW5pbWF0aW9uLmZyb21TcHJpdGVTaGVldChzcHJpdGVTaGVldCwgcmFuZ2UoMCwgbGVuZ3RoKSwgZHVyYXRpb25QZXJGcmFtZU1zKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5fYW5pbWF0aW9uO1xyXG4gICAgfVxyXG4gICAgZ2V0IHJlYWRDaGVja0J5dGVzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9naWYuY2hlY2tCeXRlcztcclxuICAgIH1cclxufVxyXG5jb25zdCBiaXRzVG9OdW0gPSAoYmEpID0+IHtcclxuICAgIHJldHVybiBiYS5yZWR1Y2UoZnVuY3Rpb24gKHMsIG4pIHtcclxuICAgICAgICByZXR1cm4gcyAqIDIgKyBuO1xyXG4gICAgfSwgMCk7XHJcbn07XHJcbmNvbnN0IGJ5dGVUb0JpdEFyciA9IChiaXRlKSA9PiB7XHJcbiAgICBjb25zdCBhID0gW107XHJcbiAgICBmb3IgKGxldCBpID0gNzsgaSA+PSAwOyBpLS0pIHtcclxuICAgICAgICBhLnB1c2goISEoYml0ZSAmICgxIDw8IGkpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYTtcclxufTtcclxuY2xhc3MgU3RyZWFtIHtcclxuICAgIGNvbnN0cnVjdG9yKGRhdGFBcnJheSkge1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5sZW4gPSAwO1xyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSAwO1xyXG4gICAgICAgIHRoaXMucmVhZEJ5dGUgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc2l0aW9uID49IHRoaXMuZGF0YS5ieXRlTGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byByZWFkIHBhc3QgZW5kIG9mIHN0cmVhbS4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhW3RoaXMucG9zaXRpb24rK107XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnJlYWRCeXRlcyA9IChuKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gW107XHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKHRoaXMucmVhZEJ5dGUoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZWFkID0gKG4pID0+IHtcclxuICAgICAgICAgICAgbGV0IHMgPSAnJztcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLnJlYWRCeXRlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBzO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5yZWFkVW5zaWduZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIExpdHRsZS1lbmRpYW4uXHJcbiAgICAgICAgICAgIGNvbnN0IGEgPSB0aGlzLnJlYWRCeXRlcygyKTtcclxuICAgICAgICAgICAgcmV0dXJuIChhWzFdIDw8IDgpICsgYVswXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50OEFycmF5KGRhdGFBcnJheSk7XHJcbiAgICAgICAgdGhpcy5sZW4gPSB0aGlzLmRhdGEuYnl0ZUxlbmd0aDtcclxuICAgICAgICBpZiAodGhpcy5sZW4gPT09IDApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhIGxvYWRlZCBmcm9tIGZpbGUnKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuY29uc3QgbHp3RGVjb2RlID0gZnVuY3Rpb24gKG1pbkNvZGVTaXplLCBkYXRhKSB7XHJcbiAgICAvLyBUT0RPOiBOb3cgdGhhdCB0aGUgR0lGIHBhcnNlciBpcyBhIGJpdCBkaWZmZXJlbnQsIG1heWJlIHRoaXMgc2hvdWxkIGdldCBhbiBhcnJheSBvZiBieXRlcyBpbnN0ZWFkIG9mIGEgU3RyaW5nP1xyXG4gICAgbGV0IHBvcyA9IDA7IC8vIE1heWJlIHRoaXMgc3RyZWFtaW5nIHRoaW5nIHNob3VsZCBiZSBtZXJnZWQgd2l0aCB0aGUgU3RyZWFtP1xyXG4gICAgY29uc3QgcmVhZENvZGUgPSBmdW5jdGlvbiAoc2l6ZSkge1xyXG4gICAgICAgIGxldCBjb2RlID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZGF0YS5jaGFyQ29kZUF0KHBvcyA+PiAzKSAmICgxIDw8IChwb3MgJiA3KSkpIHtcclxuICAgICAgICAgICAgICAgIGNvZGUgfD0gMSA8PCBpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHBvcysrO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY29kZTtcclxuICAgIH07XHJcbiAgICBjb25zdCBvdXRwdXQgPSBbXTtcclxuICAgIGNvbnN0IGNsZWFyQ29kZSA9IDEgPDwgbWluQ29kZVNpemU7XHJcbiAgICBjb25zdCBlb2lDb2RlID0gY2xlYXJDb2RlICsgMTtcclxuICAgIGxldCBjb2RlU2l6ZSA9IG1pbkNvZGVTaXplICsgMTtcclxuICAgIGxldCBkaWN0ID0gW107XHJcbiAgICBjb25zdCBjbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBkaWN0ID0gW107XHJcbiAgICAgICAgY29kZVNpemUgPSBtaW5Db2RlU2l6ZSArIDE7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGVhckNvZGU7IGkrKykge1xyXG4gICAgICAgICAgICBkaWN0W2ldID0gW2ldO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkaWN0W2NsZWFyQ29kZV0gPSBbXTtcclxuICAgICAgICBkaWN0W2VvaUNvZGVdID0gbnVsbDtcclxuICAgIH07XHJcbiAgICBsZXQgY29kZTtcclxuICAgIGxldCBsYXN0O1xyXG4gICAgd2hpbGUgKHRydWUpIHtcclxuICAgICAgICBsYXN0ID0gY29kZTtcclxuICAgICAgICBjb2RlID0gcmVhZENvZGUoY29kZVNpemUpO1xyXG4gICAgICAgIGlmIChjb2RlID09PSBjbGVhckNvZGUpIHtcclxuICAgICAgICAgICAgY2xlYXIoKTtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChjb2RlID09PSBlb2lDb2RlKSB7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29kZSA8IGRpY3QubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGlmIChsYXN0ICE9PSBjbGVhckNvZGUpIHtcclxuICAgICAgICAgICAgICAgIGRpY3QucHVzaChkaWN0W2xhc3RdLmNvbmNhdChkaWN0W2NvZGVdWzBdKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChjb2RlICE9PSBkaWN0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIExaVyBjb2RlLicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpY3QucHVzaChkaWN0W2xhc3RdLmNvbmNhdChkaWN0W2xhc3RdWzBdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG91dHB1dC5wdXNoLmFwcGx5KG91dHB1dCwgZGljdFtjb2RlXSk7XHJcbiAgICAgICAgaWYgKGRpY3QubGVuZ3RoID09PSAxIDw8IGNvZGVTaXplICYmIGNvZGVTaXplIDwgMTIpIHtcclxuICAgICAgICAgICAgLy8gSWYgd2UncmUgYXQgdGhlIGxhc3QgY29kZSBhbmQgY29kZVNpemUgaXMgMTIsIHRoZSBuZXh0IGNvZGUgd2lsbCBiZSBhIGNsZWFyQ29kZSwgYW5kIGl0J2xsIGJlIDEyIGJpdHMgbG9uZy5cclxuICAgICAgICAgICAgY29kZVNpemUrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBJIGRvbid0IGtub3cgaWYgdGhpcyBpcyB0ZWNobmljYWxseSBhbiBlcnJvciwgYnV0IHNvbWUgR0lGcyBkbyBpdC5cclxuICAgIC8vaWYgKE1hdGguY2VpbChwb3MgLyA4KSAhPT0gZGF0YS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignRXh0cmFuZW91cyBMWlcgYnl0ZXMuJyk7XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59O1xyXG4vLyBUaGUgYWN0dWFsIHBhcnNpbmc7IHJldHVybnMgYW4gb2JqZWN0IHdpdGggcHJvcGVydGllcy5cclxuY2xhc3MgUGFyc2VHaWYge1xyXG4gICAgY29uc3RydWN0b3Ioc3RyZWFtLCBjb2xvciA9IENvbG9yLk1hZ2VudGEpIHtcclxuICAgICAgICB0aGlzLl9zdCA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faGFuZGxlciA9IHt9O1xyXG4gICAgICAgIHRoaXMuX3RyYW5zcGFyZW50Q29sb3IgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuZnJhbWVzID0gW107XHJcbiAgICAgICAgdGhpcy5pbWFnZXMgPSBbXTtcclxuICAgICAgICB0aGlzLmdsb2JhbENvbG9yVGFibGUgPSBbXTtcclxuICAgICAgICB0aGlzLmNoZWNrQnl0ZXMgPSBbXTtcclxuICAgICAgICAvLyBMWlcgKEdJRi1zcGVjaWZpYylcclxuICAgICAgICB0aGlzLnBhcnNlQ29sb3JUYWJsZSA9IChlbnRyaWVzKSA9PiB7XHJcbiAgICAgICAgICAgIC8vIEVhY2ggZW50cnkgaXMgMyBieXRlcywgZm9yIFJHQi5cclxuICAgICAgICAgICAgY29uc3QgY3QgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbnRyaWVzOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJnYiA9IHRoaXMuX3N0LnJlYWRCeXRlcygzKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJnYmEgPSAnIycgK1xyXG4gICAgICAgICAgICAgICAgICAgIHJnYlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKCh4KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhleCA9IHgudG9TdHJpbmcoMTYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCA9PT0gMSA/ICcwJyArIGhleCA6IGhleDtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignJyk7XHJcbiAgICAgICAgICAgICAgICBjdC5wdXNoKHJnYmEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBjdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucmVhZFN1YkJsb2NrcyA9ICgpID0+IHtcclxuICAgICAgICAgICAgbGV0IHNpemUsIGRhdGE7XHJcbiAgICAgICAgICAgIGRhdGEgPSAnJztcclxuICAgICAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMuX3N0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICBkYXRhICs9IHRoaXMuX3N0LnJlYWQoc2l6ZSk7XHJcbiAgICAgICAgICAgIH0gd2hpbGUgKHNpemUgIT09IDApO1xyXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucGFyc2VIZWFkZXIgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhkciA9IHtcclxuICAgICAgICAgICAgICAgIHNpZzogbnVsbCxcclxuICAgICAgICAgICAgICAgIHZlcjogbnVsbCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBudWxsLFxyXG4gICAgICAgICAgICAgICAgY29sb3JSZXM6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBnbG9iYWxDb2xvclRhYmxlU2l6ZTogbnVsbCxcclxuICAgICAgICAgICAgICAgIGdjdEZsYWc6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBzb3J0ZWQ6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBnbG9iYWxDb2xvclRhYmxlOiBbXSxcclxuICAgICAgICAgICAgICAgIGJnQ29sb3I6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBwaXhlbEFzcGVjdFJhdGlvOiBudWxsIC8vIGlmIG5vdCAwLCBhc3BlY3RSYXRpbyA9IChwaXhlbEFzcGVjdFJhdGlvICsgMTUpIC8gNjRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaGRyLnNpZyA9IHRoaXMuX3N0LnJlYWQoMyk7XHJcbiAgICAgICAgICAgIGhkci52ZXIgPSB0aGlzLl9zdC5yZWFkKDMpO1xyXG4gICAgICAgICAgICBpZiAoaGRyLnNpZyAhPT0gJ0dJRicpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgR0lGIGZpbGUuJyk7IC8vIFhYWDogVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgaGFuZGxlZCBtb3JlIG5pY2VseS5cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBoZHIud2lkdGggPSB0aGlzLl9zdC5yZWFkVW5zaWduZWQoKTtcclxuICAgICAgICAgICAgaGRyLmhlaWdodCA9IHRoaXMuX3N0LnJlYWRVbnNpZ25lZCgpO1xyXG4gICAgICAgICAgICBjb25zdCBiaXRzID0gYnl0ZVRvQml0QXJyKHRoaXMuX3N0LnJlYWRCeXRlKCkpO1xyXG4gICAgICAgICAgICBoZHIuZ2N0RmxhZyA9IGJpdHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgaGRyLmNvbG9yUmVzID0gYml0c1RvTnVtKGJpdHMuc3BsaWNlKDAsIDMpKTtcclxuICAgICAgICAgICAgaGRyLnNvcnRlZCA9IGJpdHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgaGRyLmdsb2JhbENvbG9yVGFibGVTaXplID0gYml0c1RvTnVtKGJpdHMuc3BsaWNlKDAsIDMpKTtcclxuICAgICAgICAgICAgaGRyLmJnQ29sb3IgPSB0aGlzLl9zdC5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICBoZHIucGl4ZWxBc3BlY3RSYXRpbyA9IHRoaXMuX3N0LnJlYWRCeXRlKCk7IC8vIGlmIG5vdCAwLCBhc3BlY3RSYXRpbyA9IChwaXhlbEFzcGVjdFJhdGlvICsgMTUpIC8gNjRcclxuICAgICAgICAgICAgaWYgKGhkci5nY3RGbGFnKSB7XHJcbiAgICAgICAgICAgICAgICBoZHIuZ2xvYmFsQ29sb3JUYWJsZSA9IHRoaXMucGFyc2VDb2xvclRhYmxlKDEgPDwgKGhkci5nbG9iYWxDb2xvclRhYmxlU2l6ZSArIDEpKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsQ29sb3JUYWJsZSA9IGhkci5nbG9iYWxDb2xvclRhYmxlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyLmhkciAmJiB0aGlzLl9oYW5kbGVyLmhkcihoZHIpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9oYW5kbGVyLmhkcik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucGFyc2VFeHQgPSAoYmxvY2spID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VHQ0V4dCA9IChibG9jaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5fc3QucmVhZEJ5dGUoKSk7IC8vIEFsd2F5cyA0XHJcbiAgICAgICAgICAgICAgICBjb25zdCBiaXRzID0gYnl0ZVRvQml0QXJyKHRoaXMuX3N0LnJlYWRCeXRlKCkpO1xyXG4gICAgICAgICAgICAgICAgYmxvY2sucmVzZXJ2ZWQgPSBiaXRzLnNwbGljZSgwLCAzKTsgLy8gUmVzZXJ2ZWQ7IHNob3VsZCBiZSAwMDAuXHJcbiAgICAgICAgICAgICAgICBibG9jay5kaXNwb3NhbE1ldGhvZCA9IGJpdHNUb051bShiaXRzLnNwbGljZSgwLCAzKSk7XHJcbiAgICAgICAgICAgICAgICBibG9jay51c2VySW5wdXQgPSBiaXRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBibG9jay50cmFuc3BhcmVuY3lHaXZlbiA9IGJpdHMuc2hpZnQoKTtcclxuICAgICAgICAgICAgICAgIGJsb2NrLmRlbGF5VGltZSA9IHRoaXMuX3N0LnJlYWRVbnNpZ25lZCgpO1xyXG4gICAgICAgICAgICAgICAgYmxvY2sudHJhbnNwYXJlbmN5SW5kZXggPSB0aGlzLl9zdC5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICAgICAgYmxvY2sudGVybWluYXRvciA9IHRoaXMuX3N0LnJlYWRCeXRlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlci5nY2UgJiYgdGhpcy5faGFuZGxlci5nY2UoYmxvY2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5faGFuZGxlci5nY2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZUNvbUV4dCA9IChibG9jaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgYmxvY2suY29tbWVudCA9IHRoaXMucmVhZFN1YkJsb2NrcygpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXIuY29tICYmIHRoaXMuX2hhbmRsZXIuY29tKGJsb2NrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX2hhbmRsZXIuY29tKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgcGFyc2VQVEV4dCA9IChibG9jaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5fc3QucmVhZEJ5dGUoKSk7IC8vIEFsd2F5cyAxMlxyXG4gICAgICAgICAgICAgICAgYmxvY2sucHRIZWFkZXIgPSB0aGlzLl9zdC5yZWFkQnl0ZXMoMTIpO1xyXG4gICAgICAgICAgICAgICAgYmxvY2sucHREYXRhID0gdGhpcy5yZWFkU3ViQmxvY2tzKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlci5wdGUgJiYgdGhpcy5faGFuZGxlci5wdGUoYmxvY2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5faGFuZGxlci5wdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZUFwcEV4dCA9IChibG9jaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VOZXRzY2FwZUV4dCA9IChibG9jaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX3N0LnJlYWRCeXRlKCkpOyAvLyBBbHdheXMgM1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnVua25vd24gPSB0aGlzLl9zdC5yZWFkQnl0ZSgpOyAvLyBROiBBbHdheXMgMT8gV2hhdCBpcyB0aGlzP1xyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLml0ZXJhdGlvbnMgPSB0aGlzLl9zdC5yZWFkVW5zaWduZWQoKTtcclxuICAgICAgICAgICAgICAgICAgICBibG9jay50ZXJtaW5hdG9yID0gdGhpcy5fc3QucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faGFuZGxlci5hcHAgJiYgdGhpcy5faGFuZGxlci5hcHAuTkVUU0NBUEUgJiYgdGhpcy5faGFuZGxlci5hcHAuTkVUU0NBUEUoYmxvY2spKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX2hhbmRsZXIuYXBwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VVbmtub3duQXBwRXh0ID0gKGJsb2NrKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suYXBwRGF0YSA9IHRoaXMucmVhZFN1YkJsb2NrcygpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBUaGlzIHdvbid0IHdvcmsgaWYgYSBoYW5kbGVyIHdhbnRzIHRvIG1hdGNoIG9uIGFueSBpZGVudGlmaWVyLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyLmFwcCAmJiB0aGlzLl9oYW5kbGVyLmFwcFtibG9jay5pZGVudGlmaWVyXSAmJiB0aGlzLl9oYW5kbGVyLmFwcFtibG9jay5pZGVudGlmaWVyXShibG9jaykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0J5dGVzLnB1c2godGhpcy5faGFuZGxlci5hcHBbYmxvY2suaWRlbnRpZmllcl0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9zdC5yZWFkQnl0ZSgpKTsgLy8gQWx3YXlzIDExXHJcbiAgICAgICAgICAgICAgICBibG9jay5pZGVudGlmaWVyID0gdGhpcy5fc3QucmVhZCg4KTtcclxuICAgICAgICAgICAgICAgIGJsb2NrLmF1dGhDb2RlID0gdGhpcy5fc3QucmVhZCgzKTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoYmxvY2suaWRlbnRpZmllcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ05FVFNDQVBFJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VOZXRzY2FwZUV4dChibG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlVW5rbm93bkFwcEV4dChibG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBwYXJzZVVua25vd25FeHQgPSAoYmxvY2spID0+IHtcclxuICAgICAgICAgICAgICAgIGJsb2NrLmRhdGEgPSB0aGlzLnJlYWRTdWJCbG9ja3MoKTtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyLnVua25vd24gJiYgdGhpcy5faGFuZGxlci51bmtub3duKGJsb2NrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tCeXRlcy5wdXNoKHRoaXMuX2hhbmRsZXIudW5rbm93bik7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGJsb2NrLmxhYmVsID0gdGhpcy5fc3QucmVhZEJ5dGUoKTtcclxuICAgICAgICAgICAgc3dpdGNoIChibG9jay5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweGY5OlxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmV4dFR5cGUgPSAnZ2NlJztcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZUdDRXh0KGJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMHhmZTpcclxuICAgICAgICAgICAgICAgICAgICBibG9jay5leHRUeXBlID0gJ2NvbSc7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VDb21FeHQoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAweDAxOlxyXG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmV4dFR5cGUgPSAncHRlJztcclxuICAgICAgICAgICAgICAgICAgICBwYXJzZVBURXh0KGJsb2NrKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgMHhmZjpcclxuICAgICAgICAgICAgICAgICAgICBibG9jay5leHRUeXBlID0gJ2FwcCc7XHJcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VBcHBFeHQoYmxvY2spO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBibG9jay5leHRUeXBlID0gJ3Vua25vd24nO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlVW5rbm93bkV4dChibG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucGFyc2VJbWcgPSAoaW1nKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRlaW50ZXJsYWNlID0gKHBpeGVscywgd2lkdGgpID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIE9mIGNvdXJzZSB0aGlzIGRlZmVhdHMgdGhlIHB1cnBvc2Ugb2YgaW50ZXJsYWNpbmcuIEFuZCBpdCdzICpwcm9iYWJseSpcclxuICAgICAgICAgICAgICAgIC8vIHRoZSBsZWFzdCBlZmZpY2llbnQgd2F5IGl0J3MgZXZlciBiZWVuIGltcGxlbWVudGVkLiBCdXQgbmV2ZXJ0aGVsZXNzLi4uXHJcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdQaXhlbHMgPSBuZXcgQXJyYXkocGl4ZWxzLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByb3dzID0gcGl4ZWxzLmxlbmd0aCAvIHdpZHRoO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY3BSb3cgPSAodG9Sb3csIGZyb21Sb3cpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tUGl4ZWxzID0gcGl4ZWxzLnNsaWNlKGZyb21Sb3cgKiB3aWR0aCwgKGZyb21Sb3cgKyAxKSAqIHdpZHRoKTtcclxuICAgICAgICAgICAgICAgICAgICBuZXdQaXhlbHMuc3BsaWNlLmFwcGx5KG5ld1BpeGVscywgW3RvUm93ICogd2lkdGgsIHdpZHRoXS5jb25jYXQoZnJvbVBpeGVscykpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldHMgPSBbMCwgNCwgMiwgMV07XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwcyA9IFs4LCA4LCA0LCAyXTtcclxuICAgICAgICAgICAgICAgIGxldCBmcm9tUm93ID0gMDtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHBhc3MgPSAwOyBwYXNzIDwgNDsgcGFzcysrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdG9Sb3cgPSBvZmZzZXRzW3Bhc3NdOyB0b1JvdyA8IHJvd3M7IHRvUm93ICs9IHN0ZXBzW3Bhc3NdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNwUm93KHRvUm93LCBmcm9tUm93KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbVJvdysrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXdQaXhlbHM7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGltZy5sZWZ0UG9zID0gdGhpcy5fc3QucmVhZFVuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgIGltZy50b3BQb3MgPSB0aGlzLl9zdC5yZWFkVW5zaWduZWQoKTtcclxuICAgICAgICAgICAgaW1nLndpZHRoID0gdGhpcy5fc3QucmVhZFVuc2lnbmVkKCk7XHJcbiAgICAgICAgICAgIGltZy5oZWlnaHQgPSB0aGlzLl9zdC5yZWFkVW5zaWduZWQoKTtcclxuICAgICAgICAgICAgY29uc3QgYml0cyA9IGJ5dGVUb0JpdEFycih0aGlzLl9zdC5yZWFkQnl0ZSgpKTtcclxuICAgICAgICAgICAgaW1nLmxjdEZsYWcgPSBiaXRzLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgIGltZy5pbnRlcmxhY2VkID0gYml0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpbWcuc29ydGVkID0gYml0cy5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpbWcucmVzZXJ2ZWQgPSBiaXRzLnNwbGljZSgwLCAyKTtcclxuICAgICAgICAgICAgaW1nLmxjdFNpemUgPSBiaXRzVG9OdW0oYml0cy5zcGxpY2UoMCwgMykpO1xyXG4gICAgICAgICAgICBpZiAoaW1nLmxjdEZsYWcpIHtcclxuICAgICAgICAgICAgICAgIGltZy5sY3QgPSB0aGlzLnBhcnNlQ29sb3JUYWJsZSgxIDw8IChpbWcubGN0U2l6ZSArIDEpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpbWcubHp3TWluQ29kZVNpemUgPSB0aGlzLl9zdC5yZWFkQnl0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBsendEYXRhID0gdGhpcy5yZWFkU3ViQmxvY2tzKCk7XHJcbiAgICAgICAgICAgIGltZy5waXhlbHMgPSBsendEZWNvZGUoaW1nLmx6d01pbkNvZGVTaXplLCBsendEYXRhKTtcclxuICAgICAgICAgICAgaWYgKGltZy5pbnRlcmxhY2VkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBNb3ZlXHJcbiAgICAgICAgICAgICAgICBpbWcucGl4ZWxzID0gZGVpbnRlcmxhY2UoaW1nLnBpeGVscywgaW1nLndpZHRoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmZyYW1lcy5wdXNoKGltZyk7XHJcbiAgICAgICAgICAgIHRoaXMuYXJyYXlUb0ltYWdlKGltZyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9oYW5kbGVyLmltZyAmJiB0aGlzLl9oYW5kbGVyLmltZyhpbWcpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9oYW5kbGVyKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5wYXJzZUJsb2NrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBibG9jayA9IHtcclxuICAgICAgICAgICAgICAgIHNlbnRpbmVsOiB0aGlzLl9zdC5yZWFkQnl0ZSgpLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJydcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgYmxvY2tDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShibG9jay5zZW50aW5lbCk7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoYmxvY2tDaGFyKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICchJzpcclxuICAgICAgICAgICAgICAgICAgICBibG9jay50eXBlID0gJ2V4dCc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUV4dChibG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICcsJzpcclxuICAgICAgICAgICAgICAgICAgICBibG9jay50eXBlID0gJ2ltZyc7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZUltZyhibG9jayk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlICc7JzpcclxuICAgICAgICAgICAgICAgICAgICBibG9jay50eXBlID0gJ2VvZic7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXIuZW9mICYmIHRoaXMuX2hhbmRsZXIuZW9mKGJsb2NrKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQnl0ZXMucHVzaCh0aGlzLl9oYW5kbGVyLmVvZik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gYmxvY2s6IDB4JyArIGJsb2NrLnNlbnRpbmVsLnRvU3RyaW5nKDE2KSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJsb2NrLnR5cGUgIT09ICdlb2YnKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlQmxvY2soKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hcnJheVRvSW1hZ2UgPSAoZnJhbWUpID0+IHtcclxuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcclxuICAgICAgICAgICAgY29uc3QgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gICAgICAgICAgICBjLmlkID0gY291bnQudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgYy53aWR0aCA9IGZyYW1lLndpZHRoO1xyXG4gICAgICAgICAgICBjLmhlaWdodCA9IGZyYW1lLmhlaWdodDtcclxuICAgICAgICAgICAgY291bnQrKztcclxuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IGMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICAgICAgICAgICAgY29uc3QgcGl4U2l6ZSA9IDE7XHJcbiAgICAgICAgICAgIGxldCB5ID0gMDtcclxuICAgICAgICAgICAgbGV0IHggPSAwO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZyYW1lLnBpeGVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHggJSBmcmFtZS53aWR0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHkrKztcclxuICAgICAgICAgICAgICAgICAgICB4ID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmdsb2JhbENvbG9yVGFibGVbZnJhbWUucGl4ZWxzW2ldXSA9PT0gdGhpcy5fdHJhbnNwYXJlbnRDb2xvci50b0hleCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBgcmdiYSgwLCAwLCAwLCAwKWA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuZ2xvYmFsQ29sb3JUYWJsZVtmcmFtZS5waXhlbHNbaV1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdCh4LCB5LCBwaXhTaXplLCBwaXhTaXplKTtcclxuICAgICAgICAgICAgICAgIHgrKztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgICAgICAgICAgaW1nLnNyYyA9IGMudG9EYXRhVVJMKCk7XHJcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2goaW1nKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMuX3N0ID0gc3RyZWFtO1xyXG4gICAgICAgIHRoaXMuX2hhbmRsZXIgPSB7fTtcclxuICAgICAgICB0aGlzLl90cmFuc3BhcmVudENvbG9yID0gY29sb3I7XHJcbiAgICAgICAgdGhpcy5wYXJzZUhlYWRlcigpO1xyXG4gICAgICAgIHRoaXMucGFyc2VCbG9jaygpO1xyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vUmVzb3VyY2VzL0luZGV4LnRzXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL0VudGl0eUNvbXBvbmVudFN5c3RlbS9pbmRleC50c1xuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvUG9seWdvbi50c1xuXHJcblxyXG4vKipcclxuICogQSBwb2x5Z29uIFtbR3JhcGhpY11dIGZvciBkcmF3aW5nIGFyYml0cmFyeSBwb2x5Z29ucyB0byB0aGUgW1tFeGNhbGlidXJHcmFwaGljc0NvbnRleHRdXVxyXG4gKi9cclxuY2xhc3MgUG9seWdvbl9Qb2x5Z29uIGV4dGVuZHMgUmFzdGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zKTtcclxuICAgICAgICB0aGlzLnBvaW50cyA9IG9wdGlvbnMucG9pbnRzO1xyXG4gICAgICAgIHRoaXMucmFzdGVyaXplKCk7XHJcbiAgICB9XHJcbiAgICBnZXQgcG9pbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wb2ludHM7XHJcbiAgICB9XHJcbiAgICBzZXQgcG9pbnRzKHBvaW50cykge1xyXG4gICAgICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cztcclxuICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pblBvaW50O1xyXG4gICAgICAgIHRoaXMud2lkdGggPSB0aGlzLl9wb2ludHMucmVkdWNlKChtYXgsIHApID0+IE1hdGgubWF4KHAueCwgbWF4KSwgMCkgLSBtaW4ueDtcclxuICAgICAgICB0aGlzLmhlaWdodCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoKG1heCwgcCkgPT4gTWF0aC5tYXgocC55LCBtYXgpLCAwKSAtIG1pbi55O1xyXG4gICAgICAgIHRoaXMuZmxhZ0RpcnR5KCk7XHJcbiAgICB9XHJcbiAgICBnZXQgbWluUG9pbnQoKSB7XHJcbiAgICAgICAgY29uc3QgbWluWCA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoKG1pbiwgcCkgPT4gTWF0aC5taW4ocC54LCBtaW4pLCBJbmZpbml0eSk7XHJcbiAgICAgICAgY29uc3QgbWluWSA9IHRoaXMuX3BvaW50cy5yZWR1Y2UoKG1pbiwgcCkgPT4gTWF0aC5taW4ocC55LCBtaW4pLCBJbmZpbml0eSk7XHJcbiAgICAgICAgcmV0dXJuIHZlYyhtaW5YLCBtaW5ZKTtcclxuICAgIH1cclxuICAgIGNsb25lKCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgUG9seWdvbl9Qb2x5Z29uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IHBvaW50czogdGhpcy5wb2ludHMubWFwKChwKSA9PiBwLmNsb25lKCkpIH0sIHRoaXMuY2xvbmVHcmFwaGljT3B0aW9ucygpKSwgdGhpcy5jbG9uZVJhc3Rlck9wdGlvbnMoKSkpO1xyXG4gICAgfVxyXG4gICAgZXhlY3V0ZShjdHgpIHtcclxuICAgICAgICBpZiAodGhpcy5wb2ludHMgJiYgdGhpcy5wb2ludHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBzdXBwbGllZCBwb2ludHMgYW5kIGNvbnN0cnVjdCBhICdwb2x5Z29uJ1xyXG4gICAgICAgICAgICBjb25zdCBtaW4gPSB0aGlzLm1pblBvaW50Lm5lZ2F0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdFBvaW50ID0gdGhpcy5wb2ludHNbMF0uYWRkKG1pbik7XHJcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oZmlyc3RQb2ludC54LCBmaXJzdFBvaW50LnkpO1xyXG4gICAgICAgICAgICB0aGlzLnBvaW50cy5mb3JFYWNoKChwb2ludCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY3R4LmxpbmVUbyhwb2ludC54ICsgbWluLngsIHBvaW50LnkgKyBtaW4ueSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjdHgubGluZVRvKGZpcnN0UG9pbnQueCwgZmlyc3RQb2ludC55KTtcclxuICAgICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5jb2xvcikge1xyXG4gICAgICAgICAgICAgICAgY3R4LmZpbGwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodGhpcy5zdHJva2VDb2xvcikge1xyXG4gICAgICAgICAgICAgICAgY3R4LnN0cm9rZSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vR3JhcGhpY3MvaW5kZXgudHNcbi8vIEdyYXBoaWNzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbi8vIEdyYXBoaWNzIEVDU1xyXG5cclxuXHJcbi8vIFJhc3RlciBncmFwaGljc1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9JbnB1dC9JbmRleC50c1xuLyoqXHJcbiAqIEBtb2R1bGVcclxuICogUHJvdmlkZXMgc3VwcG9ydCBmb3IgbWljZSwga2V5Ym9hcmRzLCBhbmQgY29udHJvbGxlcnMuXHJcbiAqL1xyXG4vKipcclxuICogQHR5cGVkb2NcclxuICovXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1RyYWl0cy9JbmRleC50c1xuLyoqXHJcbiAqIEBtb2R1bGVcclxuICovXHJcblxyXG5cclxuXG47Ly8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9VdGlsL0luZGV4LnRzXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1V0aWwvU29ydGVkTGlzdC50c1xudmFyIFNvcnRlZExpc3RfZGVjb3JhdGUgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn07XHJcblxyXG4vKipcclxuICogQSBzb3J0ZWQgbGlzdCBpbXBsZW1lbnRhdGlvbi4gTk9URTogdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3Qgc2VsZi1iYWxhbmNpbmdcclxuICogQGRlcHJlY2F0ZWQgV0lsbCBiZSByZW1vdmVkIGluIHYwLjI2LjAgVXNlIGJ1aWx0IGluIEpTIGFycmF5LnNvcnRcclxuICovXHJcbmxldCBTb3J0ZWRMaXN0ID0gY2xhc3MgU29ydGVkTGlzdCB7XHJcbiAgICBjb25zdHJ1Y3RvcihnZXRDb21wYXJhYmxlKSB7XHJcbiAgICAgICAgdGhpcy5fZ2V0Q29tcGFyYWJsZSA9IGdldENvbXBhcmFibGU7XHJcbiAgICB9XHJcbiAgICBmaW5kKGVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZmluZCh0aGlzLl9yb290LCBlbGVtZW50KTtcclxuICAgIH1cclxuICAgIF9maW5kKG5vZGUsIGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZShlbGVtZW50KSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICBpZiAobm9kZS5nZXREYXRhKCkuaW5kZXhPZihlbGVtZW50KSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLl9nZXRDb21wYXJhYmxlKGVsZW1lbnQpIDwgbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZChub2RlLmdldExlZnQoKSwgZWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZmluZChub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8vIHJldHVybnMgdGhlIGFycmF5IG9mIGVsZW1lbnRzIGF0IGEgc3BlY2lmaWMga2V5IHZhbHVlXHJcbiAgICBnZXQoa2V5KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldCh0aGlzLl9yb290LCBrZXkpO1xyXG4gICAgfVxyXG4gICAgX2dldChub2RlLCBrZXkpIHtcclxuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldERhdGEoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoa2V5IDwgbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KG5vZGUuZ2V0TGVmdCgpLCBrZXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldChub2RlLmdldFJpZ2h0KCksIGtleSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgYWRkKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAodGhpcy5fcm9vdCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Jvb3QgPSBuZXcgQmluYXJ5VHJlZU5vZGUodGhpcy5fZ2V0Q29tcGFyYWJsZShlbGVtZW50KSwgW2VsZW1lbnRdLCBudWxsLCBudWxsKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KHRoaXMuX3Jvb3QsIGVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIF9pbnNlcnQobm9kZSwgZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChub2RlICE9IG51bGwpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2dldENvbXBhcmFibGUoZWxlbWVudCkgPT09IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldERhdGEoKS5pbmRleE9mKGVsZW1lbnQpID4gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHRoZSBlbGVtZW50IHdlJ3JlIHRyeWluZyB0byBpbnNlcnQgYWxyZWFkeSBleGlzdHNcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZ2V0RGF0YSgpLnB1c2goZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZShlbGVtZW50KSA8IG5vZGUuZ2V0S2V5KCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChub2RlLmdldExlZnQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRMZWZ0KG5ldyBCaW5hcnlUcmVlTm9kZSh0aGlzLl9nZXRDb21wYXJhYmxlKGVsZW1lbnQpLCBbZWxlbWVudF0sIG51bGwsIG51bGwpKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnNlcnQobm9kZS5nZXRMZWZ0KCksIGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0UmlnaHQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRSaWdodChuZXcgQmluYXJ5VHJlZU5vZGUodGhpcy5fZ2V0Q29tcGFyYWJsZShlbGVtZW50KSwgW2VsZW1lbnRdLCBudWxsLCBudWxsKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zZXJ0KG5vZGUuZ2V0UmlnaHQoKSwgZWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQnlDb21wYXJhYmxlKGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLl9yb290ID0gdGhpcy5fcmVtb3ZlKHRoaXMuX3Jvb3QsIGVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgX3JlbW92ZShub2RlLCBlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKG5vZGUgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZ2V0Q29tcGFyYWJsZShlbGVtZW50KSA9PT0gbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICBjb25zdCBlbGVtZW50SW5kZXggPSBub2RlLmdldERhdGEoKS5pbmRleE9mKGVsZW1lbnQpO1xyXG4gICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBjb250YWlucyB0aGUgZWxlbWVudCwgcmVtb3ZlIHRoZSBlbGVtZW50XHJcbiAgICAgICAgICAgIGlmIChlbGVtZW50SW5kZXggPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgbm9kZS5nZXREYXRhKCkuc3BsaWNlKGVsZW1lbnRJbmRleCwgMSk7XHJcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIHJlbW92ZWQgdGhlIGxhc3QgZWxlbWVudCBhdCB0aGlzIG5vZGUsIHJlbW92ZSB0aGUgbm9kZVxyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0RGF0YSgpLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGEgbGVhZlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmdldExlZnQoKSA9PSBudWxsICYmIG5vZGUuZ2V0UmlnaHQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChub2RlLmdldExlZnQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldFJpZ2h0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuZ2V0UmlnaHQoKSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldExlZnQoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgbm9kZSBoYXMgMiBjaGlsZHJlblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXAgPSB0aGlzLl9maW5kTWluTm9kZShub2RlLmdldFJpZ2h0KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0S2V5KHRlbXAuZ2V0S2V5KCkpO1xyXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2V0RGF0YSh0ZW1wLmdldERhdGEoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRSaWdodCh0aGlzLl9jbGVhbnVwKG5vZGUuZ2V0UmlnaHQoKSwgdGVtcCkpOyAvL1wiY2xlYW51cCBub2Rlc1wiIChtb3ZlIHRoZW0gdXAgcmVjdXJzaXZlbHkpXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHByZXZlbnRzIHRoZSBub2RlIGZyb20gYmVpbmcgcmVtb3ZlZCBzaW5jZSBpdCBzdGlsbCBjb250YWlucyBlbGVtZW50c1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2dldENvbXBhcmFibGUoZWxlbWVudCkgPCBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgIG5vZGUuc2V0TGVmdCh0aGlzLl9yZW1vdmUobm9kZS5nZXRMZWZ0KCksIGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBub2RlLnNldFJpZ2h0KHRoaXMuX3JlbW92ZShub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gY2FsbGVkIG9uY2Ugd2UgaGF2ZSBzdWNjZXNzZnVsbHkgcmVtb3ZlZCB0aGUgZWxlbWVudCB3ZSB3YW50ZWQsIHJlY3Vyc2l2ZWx5IGNvcnJlY3RzIHRoZSBwYXJ0IG9mIHRoZSB0cmVlIGJlbG93IHRoZSByZW1vdmVkIG5vZGVcclxuICAgIF9jbGVhbnVwKG5vZGUsIGVsZW1lbnQpIHtcclxuICAgICAgICBjb25zdCBjb21wYXJhYmxlID0gZWxlbWVudC5nZXRLZXkoKTtcclxuICAgICAgICBpZiAobm9kZSA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjb21wYXJhYmxlID09PSBub2RlLmdldEtleSgpKSB7XHJcbiAgICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGEgbGVhZlxyXG4gICAgICAgICAgICBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCAmJiBub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5nZXRMZWZ0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0UmlnaHQoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLmdldFJpZ2h0KCkgPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0TGVmdCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIGlmIG5vZGUgaGFzIDIgY2hpbGRyZW5cclxuICAgICAgICAgICAgY29uc3QgdGVtcCA9IHRoaXMuX2ZpbmRNaW5Ob2RlKG5vZGUuZ2V0UmlnaHQoKSk7XHJcbiAgICAgICAgICAgIG5vZGUuc2V0S2V5KHRlbXAuZ2V0S2V5KCkpO1xyXG4gICAgICAgICAgICBub2RlLnNldERhdGEodGVtcC5nZXREYXRhKCkpO1xyXG4gICAgICAgICAgICBub2RlLnNldFJpZ2h0KHRoaXMuX2NsZWFudXAobm9kZS5nZXRSaWdodCgpLCB0ZW1wKSk7XHJcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChlbGVtZW50LmdldEtleSgpIDwgbm9kZS5nZXRLZXkoKSkge1xyXG4gICAgICAgICAgICBub2RlLnNldExlZnQodGhpcy5fY2xlYW51cChub2RlLmdldExlZnQoKSwgZWxlbWVudCkpO1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5vZGUuc2V0UmlnaHQodGhpcy5fY2xlYW51cChub2RlLmdldFJpZ2h0KCksIGVsZW1lbnQpKTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2ZpbmRNaW5Ob2RlKG5vZGUpIHtcclxuICAgICAgICBsZXQgY3VycmVudCA9IG5vZGU7XHJcbiAgICAgICAgd2hpbGUgKGN1cnJlbnQuZ2V0TGVmdCgpICE9IG51bGwpIHtcclxuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQuZ2V0TGVmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VycmVudDtcclxuICAgIH1cclxuICAgIGxpc3QoKSB7XHJcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheSgpO1xyXG4gICAgICAgIHRoaXMuX2xpc3QodGhpcy5fcm9vdCwgcmVzdWx0cyk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XHJcbiAgICB9XHJcbiAgICBfbGlzdCh0cmVlTm9kZSwgcmVzdWx0cykge1xyXG4gICAgICAgIGlmICh0cmVlTm9kZSAhPSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3QodHJlZU5vZGUuZ2V0TGVmdCgpLCByZXN1bHRzKTtcclxuICAgICAgICAgICAgdHJlZU5vZGUuZ2V0RGF0YSgpLmZvckVhY2goKGVsZW1lbnQpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2xpc3QodHJlZU5vZGUuZ2V0UmlnaHQoKSwgcmVzdWx0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59O1xyXG5Tb3J0ZWRMaXN0ID0gU29ydGVkTGlzdF9kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7IG1lc3NhZ2U6ICdXaWxsIGJlIHJlbW92ZWQgaW4gZXhjYWxpYnVyIHYwLjI2LjAnLCBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgYnVpbHQgaW4gSlMgYXJyYXkuc29ydCcgfSlcclxuXSwgU29ydGVkTGlzdCk7XHJcblxyXG4vKipcclxuICogQSB0cmVlIG5vZGUgcGFydCBvZiBbW1NvcnRlZExpc3RdXVxyXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxubGV0IEJpbmFyeVRyZWVOb2RlID0gY2xhc3MgQmluYXJ5VHJlZU5vZGUge1xyXG4gICAgY29uc3RydWN0b3Ioa2V5LCBkYXRhLCBsZWZ0LCByaWdodCkge1xyXG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcclxuICAgICAgICB0aGlzLl9kYXRhID0gZGF0YTtcclxuICAgICAgICB0aGlzLl9sZWZ0ID0gbGVmdDtcclxuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xyXG4gICAgfVxyXG4gICAgZ2V0S2V5KCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9rZXk7XHJcbiAgICB9XHJcbiAgICBzZXRLZXkoa2V5KSB7XHJcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xyXG4gICAgfVxyXG4gICAgZ2V0RGF0YSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YTtcclxuICAgIH1cclxuICAgIHNldERhdGEoZGF0YSkge1xyXG4gICAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xyXG4gICAgfVxyXG4gICAgZ2V0TGVmdCgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fbGVmdDtcclxuICAgIH1cclxuICAgIHNldExlZnQobGVmdCkge1xyXG4gICAgICAgIHRoaXMuX2xlZnQgPSBsZWZ0O1xyXG4gICAgfVxyXG4gICAgZ2V0UmlnaHQoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JpZ2h0O1xyXG4gICAgfVxyXG4gICAgc2V0UmlnaHQocmlnaHQpIHtcclxuICAgICAgICB0aGlzLl9yaWdodCA9IHJpZ2h0O1xyXG4gICAgfVxyXG59O1xyXG5CaW5hcnlUcmVlTm9kZSA9IFNvcnRlZExpc3RfZGVjb3JhdGUoW1xyXG4gICAgb2Jzb2xldGUoeyBtZXNzYWdlOiAnV2lsbCBiZSByZW1vdmVkIGluIGV4Y2FsaWJ1ciB2MC4yNi4wJyB9KVxyXG5dLCBCaW5hcnlUcmVlTm9kZSk7XHJcblxyXG4vKipcclxuICogTW9jayBlbGVtZW50IGZvciB0ZXN0aW5nXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxuY2xhc3MgTW9ja2VkRWxlbWVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihrZXkpIHtcclxuICAgICAgICB0aGlzLl9rZXkgPSAwO1xyXG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcclxuICAgIH1cclxuICAgIGdldFRoZUtleSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5O1xyXG4gICAgfVxyXG4gICAgc2V0S2V5KGtleSkge1xyXG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcclxuICAgIH1cclxufVxyXG5cbjsvLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL1Byb21pc2VzLnRzXG4vLyBQcm9taXNlcy9BKyBTcGVjIGh0dHA6Ly9wcm9taXNlcy1hcGx1cy5naXRodWIuaW8vcHJvbWlzZXMtc3BlYy9cclxudmFyIFByb21pc2VzX2RlY29yYXRlID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59O1xyXG52YXIgUHJvbWlzZV8xO1xyXG5cclxuLyoqXHJcbiAqIFZhbGlkIHN0YXRlcyBmb3IgYSBwcm9taXNlIHRvIGJlIGluXHJcbiAqIEBkZXByZWNhdGVkIFdpbGwgYmUgcmVtb3ZlZCBpbiB2MC4yNi4wXHJcbiAqL1xyXG52YXIgUHJvbWlzZVN0YXRlO1xyXG4oZnVuY3Rpb24gKFByb21pc2VTdGF0ZSkge1xyXG4gICAgUHJvbWlzZVN0YXRlW1Byb21pc2VTdGF0ZVtcIlJlc29sdmVkXCJdID0gMF0gPSBcIlJlc29sdmVkXCI7XHJcbiAgICBQcm9taXNlU3RhdGVbUHJvbWlzZVN0YXRlW1wiUmVqZWN0ZWRcIl0gPSAxXSA9IFwiUmVqZWN0ZWRcIjtcclxuICAgIFByb21pc2VTdGF0ZVtQcm9taXNlU3RhdGVbXCJQZW5kaW5nXCJdID0gMl0gPSBcIlBlbmRpbmdcIjtcclxufSkoUHJvbWlzZVN0YXRlIHx8IChQcm9taXNlU3RhdGUgPSB7fSkpO1xyXG4vKipcclxuICogUHJvbWlzZXMgYXJlIHVzZWQgdG8gZG8gYXN5bmNocm9ub3VzIHdvcmsgYW5kIHRoZXkgYXJlIHVzZWZ1bCBmb3JcclxuICogY3JlYXRpbmcgYSBjaGFpbiBvZiBhY3Rpb25zLiBJbiBFeGNhbGlidXIgdGhleSBhcmUgdXNlZCBmb3IgbG9hZGluZyxcclxuICogc291bmRzLCBhbmltYXRpb24sIGFjdGlvbnMsIGFuZCBtb3JlLlxyXG4gKiBAZGVwcmVjYXRlZCBXaWxsIGJlIHJlbW92ZWQgaW4gdjAuMjYuMFxyXG4gKi9cclxubGV0IFByb21pc2VzX1Byb21pc2UgPSBQcm9taXNlXzEgPSBjbGFzcyBQcm9taXNlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuX3N0YXRlID0gUHJvbWlzZVN0YXRlLlBlbmRpbmc7XHJcbiAgICAgICAgdGhpcy5fc3VjY2Vzc0NhbGxiYWNrcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3JlamVjdENhbGxiYWNrID0gKCkgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuZCByZXNvbHZlIGEgUHJvbWlzZSB3aXRoIGFuIG9wdGlvbmFsIHZhbHVlXHJcbiAgICAgKiBAcGFyYW0gdmFsdWUgIEFuIG9wdGlvbmFsIHZhbHVlIHRvIHdyYXAgaW4gYSByZXNvbHZlZCBwcm9taXNlXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYnJvd3NlciBuYXRpdmUgcHJvbWlzZXNcclxuICAgICAqL1xyXG4gICAgc3RhdGljIHJlc29sdmUodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2VfMSgpLnJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgIHJldHVybiBwcm9taXNlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgYW5kIHJlamVjdCBhIFByb21pc2Ugd2l0aCBhbiBvcHRpb25hbCB2YWx1ZVxyXG4gICAgICogQHBhcmFtIHZhbHVlICBBbiBvcHRpb25hbCB2YWx1ZSB0byB3cmFwIGluIGEgcmVqZWN0ZWQgcHJvbWlzZVxyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGJyb3dzZXIgbmF0aXZlIHByb21pc2VzXHJcbiAgICAgKi9cclxuICAgIHN0YXRpYyByZWplY3QodmFsdWUpIHtcclxuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2VfMSgpLnJlamVjdCh2YWx1ZSk7XHJcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgam9pbigpIHtcclxuICAgICAgICBsZXQgcHJvbWlzZXMgPSBbXTtcclxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgIUFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgcHJvbWlzZXNbX2kgLSAwXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSAmJiBBcnJheS5pc0FycmF5KGFyZ3VtZW50c1swXSkpIHtcclxuICAgICAgICAgICAgcHJvbWlzZXMgPSBhcmd1bWVudHNbMF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGpvaW5lZFByb21pc2UgPSBuZXcgUHJvbWlzZV8xKCk7XHJcbiAgICAgICAgaWYgKCFwcm9taXNlcyB8fCAhcHJvbWlzZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBqb2luZWRQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgdG90YWwgPSBwcm9taXNlcy5sZW5ndGg7XHJcbiAgICAgICAgbGV0IHN1Y2Nlc3NlcyA9IDA7XHJcbiAgICAgICAgbGV0IHJlamVjdHMgPSAwO1xyXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xyXG4gICAgICAgIHByb21pc2VzLmZvckVhY2goKHApID0+IHtcclxuICAgICAgICAgICAgcC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICAgIHN1Y2Nlc3NlcyArPSAxO1xyXG4gICAgICAgICAgICAgICAgaWYgKHN1Y2Nlc3NlcyA9PT0gdG90YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlc29sdmUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN1Y2Nlc3NlcyArIHJlamVjdHMgKyBlcnJvcnMubGVuZ3RoID09PSB0b3RhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZFByb21pc2UucmVqZWN0KGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHJlamVjdHMgKz0gMTtcclxuICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzZXMgKyByZWplY3RzICsgZXJyb3JzLmxlbmd0aCA9PT0gdG90YWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBqb2luZWRQcm9taXNlLnJlamVjdChlcnJvcnMpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KS5lcnJvcigoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCArIHN1Y2Nlc3NlcyArIHJlamVjdHMgPT09IHRvdGFsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgam9pbmVkUHJvbWlzZS5yZWplY3QoZXJyb3JzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGpvaW5lZFByb21pc2U7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENoYWluIHN1Y2Nlc3MgYW5kIHJlamVjdCBjYWxsYmFja3MgYWZ0ZXIgdGhlIHByb21pc2UgaXMgcmVzb2x2ZWRcclxuICAgICAqIEBwYXJhbSBzdWNjZXNzQ2FsbGJhY2sgIENhbGwgb24gcmVzb2x1dGlvbiBvZiBwcm9taXNlXHJcbiAgICAgKiBAcGFyYW0gcmVqZWN0Q2FsbGJhY2sgICBDYWxsIG9uIHJlamVjdGlvbiBvZiBwcm9taXNlXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYnJvd3NlciBuYXRpdmUgcHJvbWlzZXNcclxuICAgICAqL1xyXG4gICAgdGhlbihzdWNjZXNzQ2FsbGJhY2ssIHJlamVjdENhbGxiYWNrKSB7XHJcbiAgICAgICAgaWYgKHN1Y2Nlc3NDYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLl9zdWNjZXNzQ2FsbGJhY2tzLnB1c2goc3VjY2Vzc0NhbGxiYWNrKTtcclxuICAgICAgICAgICAgLy8gSWYgdGhlIHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCBjYWxsIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlKCkgPT09IFByb21pc2VTdGF0ZS5SZXNvbHZlZCkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2suY2FsbCh0aGlzLCB0aGlzLl92YWx1ZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWplY3RDYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjayA9IHJlamVjdENhbGxiYWNrO1xyXG4gICAgICAgICAgICAvLyBJZiB0aGUgcHJvbWlzZSBpcyBhbHJlYWR5IHJlamVjdGVkIGNhbGwgaW1tZWRpYXRlbHlcclxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA9PT0gUHJvbWlzZVN0YXRlLlJlamVjdGVkKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdENhbGxiYWNrLmNhbGwodGhpcywgdGhpcy5fdmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcihlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWRkIGFuIGVycm9yIGNhbGxiYWNrIHRvIHRoZSBwcm9taXNlXHJcbiAgICAgKiBAcGFyYW0gZXJyb3JDYWxsYmFjayAgQ2FsbCBpZiB0aGVyZSB3YXMgYW4gZXJyb3IgaW4gYSBjYWxsYmFja1xyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGJyb3dzZXIgbmF0aXZlIHByb21pc2VzXHJcbiAgICAgKi9cclxuICAgIGVycm9yKGVycm9yQ2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xyXG4gICAgICAgICAgICB0aGlzLl9lcnJvckNhbGxiYWNrID0gZXJyb3JDYWxsYmFjaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmUgdGhlIHByb21pc2UgYW5kIHBhc3MgYW4gb3B0aW9uIHZhbHVlIHRvIHRoZSBzdWNjZXNzIGNhbGxiYWNrc1xyXG4gICAgICogQHBhcmFtIHZhbHVlICBWYWx1ZSB0byBwYXNzIHRvIHRoZSBzdWNjZXNzIGNhbGxiYWNrc1xyXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGJyb3dzZXIgbmF0aXZlIHByb21pc2VzXHJcbiAgICAgKi9cclxuICAgIHJlc29sdmUodmFsdWUpIHtcclxuICAgICAgICBpZiAodGhpcy5fc3RhdGUgPT09IFByb21pc2VTdGF0ZS5QZW5kaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGF0ZSA9IFByb21pc2VTdGF0ZS5SZXNvbHZlZDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3N1Y2Nlc3NDYWxsYmFja3MuZm9yRWFjaCgoY2IpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVFcnJvcihlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVzb2x2ZSBhIHByb21pc2UgdGhhdCBpcyBub3QgaW4gYSBwZW5kaW5nIHN0YXRlIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogUmVqZWN0IHRoZSBwcm9taXNlIGFuZCBwYXNzIGFuIG9wdGlvbiB2YWx1ZSB0byB0aGUgcmVqZWN0IGNhbGxiYWNrc1xyXG4gICAgICogQHBhcmFtIHZhbHVlICBWYWx1ZSB0byBwYXNzIHRvIHRoZSByZWplY3QgY2FsbGJhY2tzXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYnJvd3NlciBuYXRpdmUgcHJvbWlzZXNcclxuICAgICAqL1xyXG4gICAgcmVqZWN0KHZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBQcm9taXNlU3RhdGUuUGVuZGluZykge1xyXG4gICAgICAgICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBQcm9taXNlU3RhdGUuUmVqZWN0ZWQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWplY3RDYWxsYmFjay5jYWxsKHRoaXMsIHRoaXMuX3ZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3IoZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlamVjdCBhIHByb21pc2UgdGhhdCBpcyBub3QgaW4gYSBwZW5kaW5nIHN0YXRlIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogSW5zcGVjdCB0aGUgY3VycmVudCBzdGF0ZSBvZiBhIHByb21pc2VcclxuICAgICAqIEBkZXByZWNhdGVkIFVzZSBicm93c2VyIG5hdGl2ZSBwcm9taXNlc1xyXG4gICAgICovXHJcbiAgICBzdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlRXJyb3IoZSkge1xyXG4gICAgICAgIGlmICh0aGlzLl9lcnJvckNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Vycm9yQ2FsbGJhY2suY2FsbCh0aGlzLCBlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIHJldGhyb3cgZXJyb3JcclxuICAgICAgICAgICAgdGhyb3cgZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn07XHJcblByb21pc2VzX1Byb21pc2UgPSBQcm9taXNlXzEgPSBQcm9taXNlc19kZWNvcmF0ZShbXHJcbiAgICBvYnNvbGV0ZSh7XHJcbiAgICAgICAgbWVzc2FnZTogJ2V4LlByb21pc2VzIGFyZSBiZWluZyByZXBsYWNlZCBieSBuYXRpdmUgYnJvd3NlciBwcm9taXNlcyBpbiB2MC4yNi4wJyxcclxuICAgICAgICBhbHRlcm5hdGVNZXRob2Q6ICdVc2UgYnJvd3NlciBuYXRpdmUgcHJvbWlzZXMnXHJcbiAgICB9KVxyXG5dLCBQcm9taXNlc19Qcm9taXNlKTtcclxuXHJcblxuOy8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vaW5kZXgudHNcbi8qKlxyXG4gKiBUaGUgY3VycmVudCBFeGNhbGlidXIgdmVyc2lvbiBzdHJpbmdcclxuICogQGRlc2NyaXB0aW9uIGBwcm9jZXNzLmVudi5fX0VYX1ZFUlNJT05gIGdldHMgcmVwbGFjZWQgYnkgV2VicGFjayBvbiBidWlsZFxyXG4gKi9cclxuY29uc3QgRVhfVkVSU0lPTiA9IFwiMC4yNS4xXCI7XHJcblxyXG5wb2x5ZmlsbCgpO1xyXG4vLyBUaGlzIGZpbGUgaXMgdXNlZCBhcyB0aGUgYnVuZGxlIGVudHJ5IHBvaW50IGFuZCBleHBvcnRzIGV2ZXJ5dGhpbmdcclxuLy8gdGhhdCB3aWxsIGJlIGV4cG9zZWQgYXMgdGhlIGBleGAgZ2xvYmFsIHZhcmlhYmxlLlxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuLy8gZXguTGVnYWN5RHJhd2luZyBuYW1lc3BhY2VcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyBleC5FdmVudHMgbmFtZXNwYWNlXHJcblxyXG5cclxuLy8gZXguSW5wdXQgbmFtZXNwYWNlXHJcblxyXG5cclxuLy8gZXguVHJhaXRzIG5hbWVzcGFjZVxyXG5cclxuXHJcbi8vIGV4LlV0aWwgbmFtZXNwYWNlc1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG4vLyBleC5EZXByZWNhdGVkXHJcblxyXG4vLyBpbXBvcnQgKiBhcyBkZXByZWNhdGVkIGZyb20gJy4vRGVwcmVjYXRlZCc7XHJcbi8vIGV4cG9ydCB7IGRlcHJlY2F0ZWQgYXMgRGVwcmVjYXRlZCB9O1xyXG4vLyBleHBvcnQgKiBmcm9tICcuL0RlcHJlY2F0ZWQnO1xyXG5cbn0pKCk7XG5cbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWN0aW9uQ29udGV4dCA9IF9fd2VicGFja19leHBvcnRzX18uZlduO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BY3Rpb25RdWV1ZSA9IF9fd2VicGFja19leHBvcnRzX18uSWE4O1xudmFyIF9fd2VicGFja19leHBvcnRzX19BY3Rpb25zQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5oTEk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0FjdGlvbnNTeXN0ZW0gPSBfX3dlYnBhY2tfZXhwb3J0c19fLnl5djtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQWN0aXZhdGVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18udFg1O1xudmFyIF9fd2VicGFja19leHBvcnRzX19BY3RvciA9IF9fd2VicGFja19leHBvcnRzX18udnRYO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BZGRlZENvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18ucjdLO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BZGRlZEVudGl0eSA9IF9fd2VicGFja19leHBvcnRzX18ubENoO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BbmltYXRpb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLmZ3RjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQW5pbWF0aW9uRGlyZWN0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5zY2U7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0FuaW1hdGlvblN0cmF0ZWd5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5fYzc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0FyY2FkZVNvbHZlciA9IF9fd2VicGFja19leHBvcnRzX18uS1VzO1xudmFyIF9fd2VicGFja19leHBvcnRzX19BdWRpb0NvbnRleHRGYWN0b3J5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5BanA7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0F4aXMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlJEaDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQmFzZUFsaWduID0gX193ZWJwYWNrX2V4cG9ydHNfXy5fSDk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0JpbmFyeVRyZWVOb2RlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5VbGY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0JsaW5rID0gX193ZWJwYWNrX2V4cG9ydHNfXy5teHM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0JvZHlDb21wb25lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk9tRDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQm91bmRpbmdCb3ggPSBfX3dlYnBhY2tfZXhwb3J0c19fLmtCZjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQnJvYWRwaGFzZVN0cmF0ZWd5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5DNEY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Jyb3dzZXJDb21wb25lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk5RdDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQnJvd3NlckV2ZW50cyA9IF9fd2VicGFja19leHBvcnRzX18uSmpOO1xudmFyIF9fd2VicGFja19leHBvcnRzX19DYW1lcmEgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlYxcztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ2FudmFzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Yejc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NlbGwgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmJMZDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ2lyY2xlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5DZGM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NpcmNsZUNvbGxpZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5GS247XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NsYXNzID0gX193ZWJwYWNrX2V4cG9ydHNfXy53VFc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Nsb3Nlc3RMaW5lID0gX193ZWJwYWNrX2V4cG9ydHNfXy5hYjI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Nsb3Nlc3RMaW5lSnVtcFRhYmxlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5HZlo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ZTVM7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpZGVyQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5veXY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvbkNvbnRhY3QgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmFVYjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uRW5kRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlNkRDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uR3JvdXAgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkpVdjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uR3JvdXBNYW5hZ2VyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5qRWo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvbkp1bXBUYWJsZSA9IF9fd2VicGFja19leHBvcnRzX18uVEZxO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25Qb3N0U29sdmVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uSERVO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25QcmVTb2x2ZUV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SX3k7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSA9IF9fd2VicGFja19leHBvcnRzX18ueWROO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25Tb2x2ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLl9OMjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uU3RhcnRFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18udDUwO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25TeXN0ZW0gPSBfX3dlYnBhY2tfZXhwb3J0c19fLnMkJDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uVHlwZSA9IF9fd2VicGFja19leHBvcnRzX18udjJHO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xvciA9IF9fd2VicGFja19leHBvcnRzX18uSWxrO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xvckJsaW5kQ29ycmVjdG9yID0gX193ZWJwYWNrX2V4cG9ydHNfXy5IXzk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbG9yQmxpbmRGbGFncyA9IF9fd2VicGFja19leHBvcnRzX18uczlpO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db2xvckJsaW5kbmVzcyA9IF9fd2VicGFja19leHBvcnRzX18ua3NsO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db21wb25lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLndBMjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29tcG9zaXRlQ29sbGlkZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlJfcDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fQ29uZmlndXJhYmxlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5JUSQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbnNvbGVBcHBlbmRlciA9IF9fd2VicGFja19leHBvcnRzX18uSTVGO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db250YWN0Q29uc3RyYWludFBvaW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5YOCQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0NvbnRhY3RFbmRFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uRlI2O1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db250YWN0U3RhcnRFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uVThvO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Db29yZFBsYW5lID0gX193ZWJwYWNrX2V4cG9ydHNfXy5rYkc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0N1bGxpbmdCb3ggPSBfX3dlYnBhY2tfZXhwb3J0c19fLm9lSjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGVhY3RpdmF0ZUV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5pU187XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RlYnVnID0gX193ZWJwYWNrX2V4cG9ydHNfXy5jR0c7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RlYnVnU3lzdGVtID0gX193ZWJwYWNrX2V4cG9ydHNfXy5za2I7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RlYnVnVGV4dCA9IF9fd2VicGFja19leHBvcnRzX18uU0xVO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EZWdyZWVPZkZyZWVkb20gPSBfX3dlYnBhY2tfZXhwb3J0c19fLlJkSjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGV0ZWN0b3IgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmdVNztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRGllID0gX193ZWJwYWNrX2V4cG9ydHNfXy5MU2s7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0RpcmVjdGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uTm1wO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EaXNwbGF5TW9kZSA9IF9fd2VicGFja19leHBvcnRzX18uZDFZO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EeW5hbWljVHJlZSA9IF9fd2VicGFja19leHBvcnRzX18ueHJMO1xudmFyIF9fd2VicGFja19leHBvcnRzX19EeW5hbWljVHJlZUNvbGxpc2lvblByb2Nlc3NvciA9IF9fd2VicGFja19leHBvcnRzX18uc1JXO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FWF9WRVJTSU9OID0gX193ZWJwYWNrX2V4cG9ydHNfXy5jbVY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0Vhc2VUbyA9IF9fd2VicGFja19leHBvcnRzX18uTjBRO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FYXNpbmdGdW5jdGlvbnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnE4YjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRWRnZUNvbGxpZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy55bkI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0VsYXN0aWNUb0FjdG9yU3RyYXRlZ3kgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmpUOTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRW1pdHRlclR5cGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLndBejtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRW5naW5lID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ENFY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0VudGVyVHJpZ2dlckV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ONkg7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0VudGVyVmlld1BvcnRFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uVzFBO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FbnRpdHkgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkpIVztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRW50aXR5TWFuYWdlciA9IF9fd2VicGFja19leHBvcnRzX18udjJLO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FdmVudERpc3BhdGNoZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnBCZjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRXZlbnRUeXBlcyA9IF9fd2VicGFja19leHBvcnRzX18uR01sO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FdmVudHMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnpXMjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRXhSZXNwb25zZSA9IF9fd2VicGFja19leHBvcnRzX18uQjBLO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FeGNhbGlidXJHcmFwaGljc0NvbnRleHQyRENhbnZhcyA9IF9fd2VicGFja19leHBvcnRzX18uTnY3O1xudmFyIF9fd2VicGFja19leHBvcnRzX19FeGNhbGlidXJHcmFwaGljc0NvbnRleHRXZWJHTCA9IF9fd2VicGFja19leHBvcnRzX18uQ19wO1xudmFyIF9fd2VicGFja19leHBvcnRzX19FeGl0VHJpZ2dlckV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5NVUE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0V4aXRWaWV3UG9ydEV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy54cVU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0V4cGVyaW1lbnRzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5wZUc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ZhZGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnBUcDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRmxhZ3MgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnZVSztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRm9sbG93ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5qOWw7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ZvbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlp4dztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fRm9udFN0eWxlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5IZHg7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ZvbnRVbml0ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5aJGQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ZyYW1lU3RhdHMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm8kNztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZUV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5abSQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dhbWVTdGFydEV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy4kUUg7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dhbWVTdG9wRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmk3ODtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZXBhZEF4aXNFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uaDZ1O1xudmFyIF9fd2VicGFja19leHBvcnRzX19HYW1lcGFkQnV0dG9uRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmh0cztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZXBhZENvbm5lY3RFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uajg4O1xudmFyIF9fd2VicGFja19leHBvcnRzX19HYW1lcGFkRGlzY29ubmVjdEV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5WTUU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dpZiA9IF9fd2VicGFja19leHBvcnRzX18ubnQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dsb2JhbENvb3JkaW5hdGVzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Va3I7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dyYXBoaWMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnpzdTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpY3NDb21wb25lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm9BNjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpY3NHcm91cCA9IF9fd2VicGFja19leHBvcnRzX18uVFZoO1xudmFyIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc0xheWVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Ud1o7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dyYXBoaWNzTGF5ZXJzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5HVFQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0dyYXBoaWNzU3lzdGVtID0gX193ZWJwYWNrX2V4cG9ydHNfXy54eGo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0hpZGRlbkV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5YZEs7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0ltYWdlU291cmNlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5jWG87XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0luaXRpYWxpemVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uRG01O1xudmFyIF9fd2VicGFja19leHBvcnRzX19JbnB1dCA9IF9fd2VicGFja19leHBvcnRzX18uSUlCO1xudmFyIF9fd2VicGFja19leHBvcnRzX19JbnRlZ3JhdG9yID0gX193ZWJwYWNrX2V4cG9ydHNfXy56STA7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0tpbGxFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uU0taO1xudmFyIF9fd2VicGFja19leHBvcnRzX19MYWJlbCA9IF9fd2VicGFja19leHBvcnRzX18uX19KO1xudmFyIF9fd2VicGFja19leHBvcnRzX19MZWdhY3kgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkR2cjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTGVnYWN5RHJhd2luZyA9IF9fd2VicGFja19leHBvcnRzX18uVGY5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19MaW1pdENhbWVyYUJvdW5kc1N0cmF0ZWd5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SSSQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0xpbmUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLngxMjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTG9hZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5hTnc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0xvY2tDYW1lcmFUb0FjdG9yQXhpc1N0cmF0ZWd5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy54d247XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX0xvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3kgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmROSztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTG9nTGV2ZWwgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmluaTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTG9nZ2VyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ZZEg7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX01hdHJpeCA9IF9fd2VicGFja19leHBvcnRzX18ueTNHO1xudmFyIF9fd2VicGFja19leHBvcnRzX19NYXRyaXhMb2NhdGlvbnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmw1NztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTWVkaWFFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18ueG4wO1xudmFyIF9fd2VicGFja19leHBvcnRzX19NZWV0ID0gX193ZWJwYWNrX2V4cG9ydHNfXy50MlY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX01vY2tlZEVsZW1lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlp5UztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTW90aW9uQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy51eEI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX01vdGlvblN5c3RlbSA9IF9fd2VicGFja19leHBvcnRzX18uY3BkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Nb3ZlQnkgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmZpeTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTW92ZVRvID0gX193ZWJwYWNrX2V4cG9ydHNfXy4kWFo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX05hdGl2ZVNvdW5kRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnVxSztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fTmF0aXZlU291bmRQcm9jZXNzZWRFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uU1RFO1xudmFyIF9fd2VicGFja19leHBvcnRzX19PYnNlcnZhYmxlID0gX193ZWJwYWNrX2V4cG9ydHNfXy55JHo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BhaXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnNPcTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGFyc2VHaWYgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlNxcztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGFydGljbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmhwWjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGFydGljbGVFbWl0dGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Wb2w7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BoeXNpY3MgPSBfX3dlYnBhY2tfZXhwb3J0c19fLndJWjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUGh5c2ljc1N0YXRzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5jQmk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1BvbHlnb24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLm1ncTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUG9seWdvbkNvbGxpZGVyID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ZVkE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Bvb2wgPSBfX3dlYnBhY2tfZXhwb3J0c19fLktncDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUG9zdENvbGxpc2lvbkV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ISCQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Bvc3REZWJ1Z0RyYXdFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uTV9kO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qb3N0RHJhd0V2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5yZ2g7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Bvc3RGcmFtZUV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SYTY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Bvc3RLaWxsRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLktoUjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUG9zdFVwZGF0ZUV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5CUzU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1ByZUNvbGxpc2lvbkV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy54aHo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1ByZURlYnVnRHJhd0V2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy54T3E7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1ByZURyYXdFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uYTlqO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QcmVGcmFtZUV2ZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5iSGs7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1ByZUtpbGxFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uQ2dLO1xudmFyIF9fd2VicGFja19leHBvcnRzX19QcmVVcGRhdGVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uY3VZO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Qcm9qZWN0aW9uID0gX193ZWJwYWNrX2V4cG9ydHNfXy5rdkU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Byb21pc2UgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkpEYjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUHJvbWlzZVN0YXRlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5DYmk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1F1ZXJ5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5BRV87XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1F1ZXJ5TWFuYWdlciA9IF9fd2VicGFja19leHBvcnRzX18uY3RPO1xudmFyIF9fd2VicGFja19leHBvcnRzX19SYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5PTEg7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1JhbmRvbSA9IF9fd2VicGFja19leHBvcnRzX18ua2t5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19SYXN0ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLm5TRjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmF5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy56SG47XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1JlYWxpc3RpY1NvbHZlciA9IF9fd2VicGFja19leHBvcnRzX18uend4O1xudmFyIF9fd2VicGFja19leHBvcnRzX19SZWN0YW5nbGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkFlSjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmVtb3ZlZENvbXBvbmVudCA9IF9fd2VicGFja19leHBvcnRzX18uaEx6O1xudmFyIF9fd2VicGFja19leHBvcnRzX19SZW1vdmVkRW50aXR5ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5EOWc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1JlcGVhdCA9IF9fd2VicGFja19leHBvcnRzX18ud0E7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1JlcGVhdEZvcmV2ZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmpocjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fUmVzb2x1dGlvbiA9IF9fd2VicGFja19leHBvcnRzX18uR1ZzO1xudmFyIF9fd2VicGFja19leHBvcnRzX19SZXNvdXJjZSA9IF9fd2VicGFja19leHBvcnRzX18uX3pPO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Sb3RhdGVCeSA9IF9fd2VicGFja19leHBvcnRzX18udzYkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Sb3RhdGVUbyA9IF9fd2VicGFja19leHBvcnRzX18ubWhWO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Sb3RhdGlvblR5cGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk1PRDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU2NhbGVCeSA9IF9fd2VicGFja19leHBvcnRzX18ua3dkO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TY2FsZVRvID0gX193ZWJwYWNrX2V4cG9ydHNfXy5MbXI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NjZW5lID0gX193ZWJwYWNrX2V4cG9ydHNfXy54c1M7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NjcmVlbiA9IF9fd2VicGFja19leHBvcnRzX18ubExyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TY3JlZW5BcHBlbmRlciA9IF9fd2VicGFja19leHBvcnRzX18uWiRyO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TY3JlZW5FbGVtZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5JWGI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Njcm9sbFByZXZlbnRpb25Nb2RlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5TTWo7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NoYXBlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ibkY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1NpZGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk1GQTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU29ydGVkTGlzdCA9IF9fd2VicGFja19leHBvcnRzX18uJFhDO1xudmFyIF9fd2VicGFja19leHBvcnRzX19Tb3VuZCA9IF9fd2VicGFja19leHBvcnRzX18uJHVVO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TcHJpdGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmp5aTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3ByaXRlRm9udCA9IF9fd2VicGFja19leHBvcnRzX18uRTAzO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TcHJpdGVTaGVldCA9IF9fd2VicGFja19leHBvcnRzX18uVjZxO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TdHJhdGVneUNvbnRhaW5lciA9IF9fd2VicGFja19leHBvcnRzX18ublZvO1xudmFyIF9fd2VicGFja19leHBvcnRzX19TdHJlYW0gPSBfX3dlYnBhY2tfZXhwb3J0c19fLkY2TjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3Vic2NyaWJlRXZlbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmFkMztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3lzdGVtID0gX193ZWJwYWNrX2V4cG9ydHNfXy54UDc7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1N5c3RlbU1hbmFnZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk9kcTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fU3lzdGVtVHlwZSA9IF9fd2VicGFja19leHBvcnRzX18uWmlmO1xudmFyIF9fd2VicGFja19leHBvcnRzX19UYWdDb21wb25lbnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlpHSjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVGV4dCA9IF9fd2VicGFja19leHBvcnRzX18ueHZUO1xudmFyIF9fd2VicGFja19leHBvcnRzX19UZXh0QWxpZ24gPSBfX3dlYnBhY2tfZXhwb3J0c19fLlBITTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVGlsZU1hcCA9IF9fd2VicGFja19leHBvcnRzX18uS3dPO1xudmFyIF9fd2VicGFja19leHBvcnRzX19UaW1lciA9IF9fd2VicGFja19leHBvcnRzX18uQjd5O1xudmFyIF9fd2VicGFja19leHBvcnRzX19UcmFpdHMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlNGcDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVHJhbnNmb3JtQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Vdm47XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1RyZWVOb2RlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5PRlQ7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1RyaWdnZXIgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnh6TjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fVW5zdWJzY3JpYmVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uSDZqO1xudmFyIF9fd2VicGFja19leHBvcnRzX19VdGlsID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ack47XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1ZlY3RvciA9IF9fd2VicGFja19leHBvcnRzX18uT1dzO1xudmFyIF9fd2VicGFja19leHBvcnRzX19WZWN0b3JWaWV3ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5kRjk7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1Zpc2libGVFdmVudCA9IF9fd2VicGFja19leHBvcnRzX18uVkhvO1xudmFyIF9fd2VicGFja19leHBvcnRzX19XZWJBdWRpb0luc3RhbmNlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SJEU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX1dvcmxkID0gX193ZWJwYWNrX2V4cG9ydHNfXy5xM0k7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2Nhbm9uaWNhbGl6ZUFuZ2xlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5QYWI7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2NsYW1wID0gX193ZWJwYWNrX2V4cG9ydHNfXy51WjU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2NyZWF0ZUlkID0gX193ZWJwYWNrX2V4cG9ydHNfXy5NY0s7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc0dyYXBoaWNzVGljayA9IF9fd2VicGFja19leHBvcnRzX18uazBiO1xudmFyIF9fd2VicGFja19leHBvcnRzX19oYXNPbkluaXRpYWxpemUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmhuVDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faGFzT25Qb3N0VXBkYXRlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5SU0o7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc09uUHJlVXBkYXRlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5Na3U7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc1Bvc3REcmF3ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5oOTA7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2hhc1ByZURyYXcgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnJtcztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faGFzX2luaXRpYWxpemUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLkVyUDtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faGFzX3Bvc3R1cGRhdGUgPSBfX3dlYnBhY2tfZXhwb3J0c19fLmFWZztcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faGFzX3ByZXVwZGF0ZSA9IF9fd2VicGFja19leHBvcnRzX18ubFBjO1xudmFyIF9fd2VicGFja19leHBvcnRzX19pc0FkZGVkQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5aOEU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX2lzQWRkZWRTeXN0ZW1FbnRpdHkgPSBfX3dlYnBhY2tfZXhwb3J0c19fLk5OQTtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faXNSZW1vdmVTeXN0ZW1FbnRpdHkgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnlGbjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19faXNSZW1vdmVkQ29tcG9uZW50ID0gX193ZWJwYWNrX2V4cG9ydHNfXy5sTnY7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX21heE1lc3NhZ2VzID0gX193ZWJwYWNrX2V4cG9ydHNfXy5NWlE7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX29ic29sZXRlID0gX193ZWJwYWNrX2V4cG9ydHNfXy5GVU07XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX3JhbmRvbUluUmFuZ2UgPSBfX3dlYnBhY2tfZXhwb3J0c19fLnZkZjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fcmFuZG9tSW50SW5SYW5nZSA9IF9fd2VicGFja19leHBvcnRzX18uaWFMO1xudmFyIF9fd2VicGFja19leHBvcnRzX19yYW5nZSA9IF9fd2VicGFja19leHBvcnRzX18udzZIO1xudmFyIF9fd2VicGFja19leHBvcnRzX19yZXNldE9ic29sZXRlQ291bnRlciA9IF9fd2VicGFja19leHBvcnRzX18uUTRjO1xudmFyIF9fd2VicGFja19leHBvcnRzX190b0RlZ3JlZXMgPSBfX3dlYnBhY2tfZXhwb3J0c19fLlV4YjtcbnZhciBfX3dlYnBhY2tfZXhwb3J0c19fdG9SYWRpYW5zID0gX193ZWJwYWNrX2V4cG9ydHNfXy5ZcjU7XG52YXIgX193ZWJwYWNrX2V4cG9ydHNfX3ZlYyA9IF9fd2VicGFja19leHBvcnRzX18uQmh3O1xuZXhwb3J0IHsgX193ZWJwYWNrX2V4cG9ydHNfX0FjdGlvbkNvbnRleHQgYXMgQWN0aW9uQ29udGV4dCwgX193ZWJwYWNrX2V4cG9ydHNfX0FjdGlvblF1ZXVlIGFzIEFjdGlvblF1ZXVlLCBfX3dlYnBhY2tfZXhwb3J0c19fQWN0aW9uc0NvbXBvbmVudCBhcyBBY3Rpb25zQ29tcG9uZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQWN0aW9uc1N5c3RlbSBhcyBBY3Rpb25zU3lzdGVtLCBfX3dlYnBhY2tfZXhwb3J0c19fQWN0aXZhdGVFdmVudCBhcyBBY3RpdmF0ZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQWN0b3IgYXMgQWN0b3IsIF9fd2VicGFja19leHBvcnRzX19BZGRlZENvbXBvbmVudCBhcyBBZGRlZENvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0FkZGVkRW50aXR5IGFzIEFkZGVkRW50aXR5LCBfX3dlYnBhY2tfZXhwb3J0c19fQW5pbWF0aW9uIGFzIEFuaW1hdGlvbiwgX193ZWJwYWNrX2V4cG9ydHNfX0FuaW1hdGlvbkRpcmVjdGlvbiBhcyBBbmltYXRpb25EaXJlY3Rpb24sIF9fd2VicGFja19leHBvcnRzX19BbmltYXRpb25TdHJhdGVneSBhcyBBbmltYXRpb25TdHJhdGVneSwgX193ZWJwYWNrX2V4cG9ydHNfX0FyY2FkZVNvbHZlciBhcyBBcmNhZGVTb2x2ZXIsIF9fd2VicGFja19leHBvcnRzX19BdWRpb0NvbnRleHRGYWN0b3J5IGFzIEF1ZGlvQ29udGV4dEZhY3RvcnksIF9fd2VicGFja19leHBvcnRzX19BeGlzIGFzIEF4aXMsIF9fd2VicGFja19leHBvcnRzX19CYXNlQWxpZ24gYXMgQmFzZUFsaWduLCBfX3dlYnBhY2tfZXhwb3J0c19fQmluYXJ5VHJlZU5vZGUgYXMgQmluYXJ5VHJlZU5vZGUsIF9fd2VicGFja19leHBvcnRzX19CbGluayBhcyBCbGluaywgX193ZWJwYWNrX2V4cG9ydHNfX0JvZHlDb21wb25lbnQgYXMgQm9keUNvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0JvdW5kaW5nQm94IGFzIEJvdW5kaW5nQm94LCBfX3dlYnBhY2tfZXhwb3J0c19fQnJvYWRwaGFzZVN0cmF0ZWd5IGFzIEJyb2FkcGhhc2VTdHJhdGVneSwgX193ZWJwYWNrX2V4cG9ydHNfX0Jyb3dzZXJDb21wb25lbnQgYXMgQnJvd3NlckNvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0Jyb3dzZXJFdmVudHMgYXMgQnJvd3NlckV2ZW50cywgX193ZWJwYWNrX2V4cG9ydHNfX0NhbWVyYSBhcyBDYW1lcmEsIF9fd2VicGFja19leHBvcnRzX19DYW52YXMgYXMgQ2FudmFzLCBfX3dlYnBhY2tfZXhwb3J0c19fQ2VsbCBhcyBDZWxsLCBfX3dlYnBhY2tfZXhwb3J0c19fQ2lyY2xlIGFzIENpcmNsZSwgX193ZWJwYWNrX2V4cG9ydHNfX0NpcmNsZUNvbGxpZGVyIGFzIENpcmNsZUNvbGxpZGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fQ2xhc3MgYXMgQ2xhc3MsIF9fd2VicGFja19leHBvcnRzX19DbG9zZXN0TGluZSBhcyBDbG9zZXN0TGluZSwgX193ZWJwYWNrX2V4cG9ydHNfX0Nsb3Nlc3RMaW5lSnVtcFRhYmxlIGFzIENsb3Nlc3RMaW5lSnVtcFRhYmxlLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlkZXIgYXMgQ29sbGlkZXIsIF9fd2VicGFja19leHBvcnRzX19Db2xsaWRlckNvbXBvbmVudCBhcyBDb2xsaWRlckNvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvbkNvbnRhY3QgYXMgQ29sbGlzaW9uQ29udGFjdCwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvbkVuZEV2ZW50IGFzIENvbGxpc2lvbkVuZEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uR3JvdXAgYXMgQ29sbGlzaW9uR3JvdXAsIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25Hcm91cE1hbmFnZXIgYXMgQ29sbGlzaW9uR3JvdXBNYW5hZ2VyLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uSnVtcFRhYmxlIGFzIENvbGxpc2lvbkp1bXBUYWJsZSwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblBvc3RTb2x2ZUV2ZW50IGFzIENvbGxpc2lvblBvc3RTb2x2ZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uUHJlU29sdmVFdmVudCBhcyBDb2xsaXNpb25QcmVTb2x2ZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uUmVzb2x1dGlvblN0cmF0ZWd5IGFzIENvbGxpc2lvblJlc29sdXRpb25TdHJhdGVneSwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbGxpc2lvblNvbHZlciBhcyBDb2xsaXNpb25Tb2x2ZXIsIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25TdGFydEV2ZW50IGFzIENvbGxpc2lvblN0YXJ0RXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Db2xsaXNpb25TeXN0ZW0gYXMgQ29sbGlzaW9uU3lzdGVtLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sbGlzaW9uVHlwZSBhcyBDb2xsaXNpb25UeXBlLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3IgYXMgQ29sb3IsIF9fd2VicGFja19leHBvcnRzX19Db2xvckJsaW5kQ29ycmVjdG9yIGFzIENvbG9yQmxpbmRDb3JyZWN0b3IsIF9fd2VicGFja19leHBvcnRzX19Db2xvckJsaW5kRmxhZ3MgYXMgQ29sb3JCbGluZEZsYWdzLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29sb3JCbGluZG5lc3MgYXMgQ29sb3JCbGluZG5lc3MsIF9fd2VicGFja19leHBvcnRzX19Db21wb25lbnQgYXMgQ29tcG9uZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fQ29tcG9zaXRlQ29sbGlkZXIgYXMgQ29tcG9zaXRlQ29sbGlkZXIsIF9fd2VicGFja19leHBvcnRzX19Db25maWd1cmFibGUgYXMgQ29uZmlndXJhYmxlLCBfX3dlYnBhY2tfZXhwb3J0c19fQ29uc29sZUFwcGVuZGVyIGFzIENvbnNvbGVBcHBlbmRlciwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbnRhY3RDb25zdHJhaW50UG9pbnQgYXMgQ29udGFjdENvbnN0cmFpbnRQb2ludCwgX193ZWJwYWNrX2V4cG9ydHNfX0NvbnRhY3RFbmRFdmVudCBhcyBDb250YWN0RW5kRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Db250YWN0U3RhcnRFdmVudCBhcyBDb250YWN0U3RhcnRFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0Nvb3JkUGxhbmUgYXMgQ29vcmRQbGFuZSwgX193ZWJwYWNrX2V4cG9ydHNfX0N1bGxpbmdCb3ggYXMgQ3VsbGluZ0JveCwgX193ZWJwYWNrX2V4cG9ydHNfX0RlYWN0aXZhdGVFdmVudCBhcyBEZWFjdGl2YXRlRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19EZWJ1ZyBhcyBEZWJ1ZywgX193ZWJwYWNrX2V4cG9ydHNfX0RlYnVnU3lzdGVtIGFzIERlYnVnU3lzdGVtLCBfX3dlYnBhY2tfZXhwb3J0c19fRGVidWdUZXh0IGFzIERlYnVnVGV4dCwgX193ZWJwYWNrX2V4cG9ydHNfX0RlZ3JlZU9mRnJlZWRvbSBhcyBEZWdyZWVPZkZyZWVkb20sIF9fd2VicGFja19leHBvcnRzX19EZXRlY3RvciBhcyBEZXRlY3RvciwgX193ZWJwYWNrX2V4cG9ydHNfX0RpZSBhcyBEaWUsIF9fd2VicGFja19leHBvcnRzX19EaXJlY3Rpb24gYXMgRGlyZWN0aW9uLCBfX3dlYnBhY2tfZXhwb3J0c19fRGlzcGxheU1vZGUgYXMgRGlzcGxheU1vZGUsIF9fd2VicGFja19leHBvcnRzX19EeW5hbWljVHJlZSBhcyBEeW5hbWljVHJlZSwgX193ZWJwYWNrX2V4cG9ydHNfX0R5bmFtaWNUcmVlQ29sbGlzaW9uUHJvY2Vzc29yIGFzIER5bmFtaWNUcmVlQ29sbGlzaW9uUHJvY2Vzc29yLCBfX3dlYnBhY2tfZXhwb3J0c19fRVhfVkVSU0lPTiBhcyBFWF9WRVJTSU9OLCBfX3dlYnBhY2tfZXhwb3J0c19fRWFzZVRvIGFzIEVhc2VUbywgX193ZWJwYWNrX2V4cG9ydHNfX0Vhc2luZ0Z1bmN0aW9ucyBhcyBFYXNpbmdGdW5jdGlvbnMsIF9fd2VicGFja19leHBvcnRzX19FZGdlQ29sbGlkZXIgYXMgRWRnZUNvbGxpZGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fRWxhc3RpY1RvQWN0b3JTdHJhdGVneSBhcyBFbGFzdGljVG9BY3RvclN0cmF0ZWd5LCBfX3dlYnBhY2tfZXhwb3J0c19fRW1pdHRlclR5cGUgYXMgRW1pdHRlclR5cGUsIF9fd2VicGFja19leHBvcnRzX19FbmdpbmUgYXMgRW5naW5lLCBfX3dlYnBhY2tfZXhwb3J0c19fRW50ZXJUcmlnZ2VyRXZlbnQgYXMgRW50ZXJUcmlnZ2VyRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19FbnRlclZpZXdQb3J0RXZlbnQgYXMgRW50ZXJWaWV3UG9ydEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fRW50aXR5IGFzIEVudGl0eSwgX193ZWJwYWNrX2V4cG9ydHNfX0VudGl0eU1hbmFnZXIgYXMgRW50aXR5TWFuYWdlciwgX193ZWJwYWNrX2V4cG9ydHNfX0V2ZW50RGlzcGF0Y2hlciBhcyBFdmVudERpc3BhdGNoZXIsIF9fd2VicGFja19leHBvcnRzX19FdmVudFR5cGVzIGFzIEV2ZW50VHlwZXMsIF9fd2VicGFja19leHBvcnRzX19FdmVudHMgYXMgRXZlbnRzLCBfX3dlYnBhY2tfZXhwb3J0c19fRXhSZXNwb25zZSBhcyBFeFJlc3BvbnNlLCBfX3dlYnBhY2tfZXhwb3J0c19fRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXMgYXMgRXhjYWxpYnVyR3JhcGhpY3NDb250ZXh0MkRDYW52YXMsIF9fd2VicGFja19leHBvcnRzX19FeGNhbGlidXJHcmFwaGljc0NvbnRleHRXZWJHTCBhcyBFeGNhbGlidXJHcmFwaGljc0NvbnRleHRXZWJHTCwgX193ZWJwYWNrX2V4cG9ydHNfX0V4aXRUcmlnZ2VyRXZlbnQgYXMgRXhpdFRyaWdnZXJFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX0V4aXRWaWV3UG9ydEV2ZW50IGFzIEV4aXRWaWV3UG9ydEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fRXhwZXJpbWVudHMgYXMgRXhwZXJpbWVudHMsIF9fd2VicGFja19leHBvcnRzX19GYWRlIGFzIEZhZGUsIF9fd2VicGFja19leHBvcnRzX19GbGFncyBhcyBGbGFncywgX193ZWJwYWNrX2V4cG9ydHNfX0ZvbGxvdyBhcyBGb2xsb3csIF9fd2VicGFja19leHBvcnRzX19Gb250IGFzIEZvbnQsIF9fd2VicGFja19leHBvcnRzX19Gb250U3R5bGUgYXMgRm9udFN0eWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fRm9udFVuaXQgYXMgRm9udFVuaXQsIF9fd2VicGFja19leHBvcnRzX19GcmFtZVN0YXRzIGFzIEZyYW1lU3RhdHMsIF9fd2VicGFja19leHBvcnRzX19HYW1lRXZlbnQgYXMgR2FtZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZVN0YXJ0RXZlbnQgYXMgR2FtZVN0YXJ0RXZlbnQsIF9fd2VicGFja19leHBvcnRzX19HYW1lU3RvcEV2ZW50IGFzIEdhbWVTdG9wRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19HYW1lcGFkQXhpc0V2ZW50IGFzIEdhbWVwYWRBeGlzRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19HYW1lcGFkQnV0dG9uRXZlbnQgYXMgR2FtZXBhZEJ1dHRvbkV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZXBhZENvbm5lY3RFdmVudCBhcyBHYW1lcGFkQ29ubmVjdEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR2FtZXBhZERpc2Nvbm5lY3RFdmVudCBhcyBHYW1lcGFkRGlzY29ubmVjdEV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fR2lmIGFzIEdpZiwgX193ZWJwYWNrX2V4cG9ydHNfX0dsb2JhbENvb3JkaW5hdGVzIGFzIEdsb2JhbENvb3JkaW5hdGVzLCBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpYyBhcyBHcmFwaGljLCBfX3dlYnBhY2tfZXhwb3J0c19fR3JhcGhpY3NDb21wb25lbnQgYXMgR3JhcGhpY3NDb21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc0dyb3VwIGFzIEdyYXBoaWNzR3JvdXAsIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc0xheWVyIGFzIEdyYXBoaWNzTGF5ZXIsIF9fd2VicGFja19leHBvcnRzX19HcmFwaGljc0xheWVycyBhcyBHcmFwaGljc0xheWVycywgX193ZWJwYWNrX2V4cG9ydHNfX0dyYXBoaWNzU3lzdGVtIGFzIEdyYXBoaWNzU3lzdGVtLCBfX3dlYnBhY2tfZXhwb3J0c19fSGlkZGVuRXZlbnQgYXMgSGlkZGVuRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19JbWFnZVNvdXJjZSBhcyBJbWFnZVNvdXJjZSwgX193ZWJwYWNrX2V4cG9ydHNfX0luaXRpYWxpemVFdmVudCBhcyBJbml0aWFsaXplRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19JbnB1dCBhcyBJbnB1dCwgX193ZWJwYWNrX2V4cG9ydHNfX0ludGVncmF0b3IgYXMgSW50ZWdyYXRvciwgX193ZWJwYWNrX2V4cG9ydHNfX0tpbGxFdmVudCBhcyBLaWxsRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19MYWJlbCBhcyBMYWJlbCwgX193ZWJwYWNrX2V4cG9ydHNfX0xlZ2FjeSBhcyBMZWdhY3ksIF9fd2VicGFja19leHBvcnRzX19MZWdhY3lEcmF3aW5nIGFzIExlZ2FjeURyYXdpbmcsIF9fd2VicGFja19leHBvcnRzX19MaW1pdENhbWVyYUJvdW5kc1N0cmF0ZWd5IGFzIExpbWl0Q2FtZXJhQm91bmRzU3RyYXRlZ3ksIF9fd2VicGFja19leHBvcnRzX19MaW5lIGFzIExpbmUsIF9fd2VicGFja19leHBvcnRzX19Mb2FkZXIgYXMgTG9hZGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3kgYXMgTG9ja0NhbWVyYVRvQWN0b3JBeGlzU3RyYXRlZ3ksIF9fd2VicGFja19leHBvcnRzX19Mb2NrQ2FtZXJhVG9BY3RvclN0cmF0ZWd5IGFzIExvY2tDYW1lcmFUb0FjdG9yU3RyYXRlZ3ksIF9fd2VicGFja19leHBvcnRzX19Mb2dMZXZlbCBhcyBMb2dMZXZlbCwgX193ZWJwYWNrX2V4cG9ydHNfX0xvZ2dlciBhcyBMb2dnZXIsIF9fd2VicGFja19leHBvcnRzX19NYXRyaXggYXMgTWF0cml4LCBfX3dlYnBhY2tfZXhwb3J0c19fTWF0cml4TG9jYXRpb25zIGFzIE1hdHJpeExvY2F0aW9ucywgX193ZWJwYWNrX2V4cG9ydHNfX01lZGlhRXZlbnQgYXMgTWVkaWFFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX01lZXQgYXMgTWVldCwgX193ZWJwYWNrX2V4cG9ydHNfX01vY2tlZEVsZW1lbnQgYXMgTW9ja2VkRWxlbWVudCwgX193ZWJwYWNrX2V4cG9ydHNfX01vdGlvbkNvbXBvbmVudCBhcyBNb3Rpb25Db21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19Nb3Rpb25TeXN0ZW0gYXMgTW90aW9uU3lzdGVtLCBfX3dlYnBhY2tfZXhwb3J0c19fTW92ZUJ5IGFzIE1vdmVCeSwgX193ZWJwYWNrX2V4cG9ydHNfX01vdmVUbyBhcyBNb3ZlVG8sIF9fd2VicGFja19leHBvcnRzX19OYXRpdmVTb3VuZEV2ZW50IGFzIE5hdGl2ZVNvdW5kRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19OYXRpdmVTb3VuZFByb2Nlc3NlZEV2ZW50IGFzIE5hdGl2ZVNvdW5kUHJvY2Vzc2VkRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19PYnNlcnZhYmxlIGFzIE9ic2VydmFibGUsIF9fd2VicGFja19leHBvcnRzX19QYWlyIGFzIFBhaXIsIF9fd2VicGFja19leHBvcnRzX19QYXJzZUdpZiBhcyBQYXJzZUdpZiwgX193ZWJwYWNrX2V4cG9ydHNfX1BhcnRpY2xlIGFzIFBhcnRpY2xlLCBfX3dlYnBhY2tfZXhwb3J0c19fUGFydGljbGVFbWl0dGVyIGFzIFBhcnRpY2xlRW1pdHRlciwgX193ZWJwYWNrX2V4cG9ydHNfX1BoeXNpY3MgYXMgUGh5c2ljcywgX193ZWJwYWNrX2V4cG9ydHNfX1BoeXNpY3NTdGF0cyBhcyBQaHlzaWNzU3RhdHMsIF9fd2VicGFja19leHBvcnRzX19Qb2x5Z29uIGFzIFBvbHlnb24sIF9fd2VicGFja19leHBvcnRzX19Qb2x5Z29uQ29sbGlkZXIgYXMgUG9seWdvbkNvbGxpZGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fUG9vbCBhcyBQb29sLCBfX3dlYnBhY2tfZXhwb3J0c19fUG9zdENvbGxpc2lvbkV2ZW50IGFzIFBvc3RDb2xsaXNpb25FdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1Bvc3REZWJ1Z0RyYXdFdmVudCBhcyBQb3N0RGVidWdEcmF3RXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Qb3N0RHJhd0V2ZW50IGFzIFBvc3REcmF3RXZlbnQsIF9fd2VicGFja19leHBvcnRzX19Qb3N0RnJhbWVFdmVudCBhcyBQb3N0RnJhbWVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1Bvc3RLaWxsRXZlbnQgYXMgUG9zdEtpbGxFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1Bvc3RVcGRhdGVFdmVudCBhcyBQb3N0VXBkYXRlRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19QcmVDb2xsaXNpb25FdmVudCBhcyBQcmVDb2xsaXNpb25FdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1ByZURlYnVnRHJhd0V2ZW50IGFzIFByZURlYnVnRHJhd0V2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fUHJlRHJhd0V2ZW50IGFzIFByZURyYXdFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1ByZUZyYW1lRXZlbnQgYXMgUHJlRnJhbWVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1ByZUtpbGxFdmVudCBhcyBQcmVLaWxsRXZlbnQsIF9fd2VicGFja19leHBvcnRzX19QcmVVcGRhdGVFdmVudCBhcyBQcmVVcGRhdGVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1Byb2plY3Rpb24gYXMgUHJvamVjdGlvbiwgX193ZWJwYWNrX2V4cG9ydHNfX1Byb21pc2UgYXMgUHJvbWlzZSwgX193ZWJwYWNrX2V4cG9ydHNfX1Byb21pc2VTdGF0ZSBhcyBQcm9taXNlU3RhdGUsIF9fd2VicGFja19leHBvcnRzX19RdWVyeSBhcyBRdWVyeSwgX193ZWJwYWNrX2V4cG9ydHNfX1F1ZXJ5TWFuYWdlciBhcyBRdWVyeU1hbmFnZXIsIF9fd2VicGFja19leHBvcnRzX19SYWRpdXNBcm91bmRBY3RvclN0cmF0ZWd5IGFzIFJhZGl1c0Fyb3VuZEFjdG9yU3RyYXRlZ3ksIF9fd2VicGFja19leHBvcnRzX19SYW5kb20gYXMgUmFuZG9tLCBfX3dlYnBhY2tfZXhwb3J0c19fUmFzdGVyIGFzIFJhc3RlciwgX193ZWJwYWNrX2V4cG9ydHNfX1JheSBhcyBSYXksIF9fd2VicGFja19leHBvcnRzX19SZWFsaXN0aWNTb2x2ZXIgYXMgUmVhbGlzdGljU29sdmVyLCBfX3dlYnBhY2tfZXhwb3J0c19fUmVjdGFuZ2xlIGFzIFJlY3RhbmdsZSwgX193ZWJwYWNrX2V4cG9ydHNfX1JlbW92ZWRDb21wb25lbnQgYXMgUmVtb3ZlZENvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1JlbW92ZWRFbnRpdHkgYXMgUmVtb3ZlZEVudGl0eSwgX193ZWJwYWNrX2V4cG9ydHNfX1JlcGVhdCBhcyBSZXBlYXQsIF9fd2VicGFja19leHBvcnRzX19SZXBlYXRGb3JldmVyIGFzIFJlcGVhdEZvcmV2ZXIsIF9fd2VicGFja19leHBvcnRzX19SZXNvbHV0aW9uIGFzIFJlc29sdXRpb24sIF9fd2VicGFja19leHBvcnRzX19SZXNvdXJjZSBhcyBSZXNvdXJjZSwgX193ZWJwYWNrX2V4cG9ydHNfX1JvdGF0ZUJ5IGFzIFJvdGF0ZUJ5LCBfX3dlYnBhY2tfZXhwb3J0c19fUm90YXRlVG8gYXMgUm90YXRlVG8sIF9fd2VicGFja19leHBvcnRzX19Sb3RhdGlvblR5cGUgYXMgUm90YXRpb25UeXBlLCBfX3dlYnBhY2tfZXhwb3J0c19fU2NhbGVCeSBhcyBTY2FsZUJ5LCBfX3dlYnBhY2tfZXhwb3J0c19fU2NhbGVUbyBhcyBTY2FsZVRvLCBfX3dlYnBhY2tfZXhwb3J0c19fU2NlbmUgYXMgU2NlbmUsIF9fd2VicGFja19leHBvcnRzX19TY3JlZW4gYXMgU2NyZWVuLCBfX3dlYnBhY2tfZXhwb3J0c19fU2NyZWVuQXBwZW5kZXIgYXMgU2NyZWVuQXBwZW5kZXIsIF9fd2VicGFja19leHBvcnRzX19TY3JlZW5FbGVtZW50IGFzIFNjcmVlbkVsZW1lbnQsIF9fd2VicGFja19leHBvcnRzX19TY3JvbGxQcmV2ZW50aW9uTW9kZSBhcyBTY3JvbGxQcmV2ZW50aW9uTW9kZSwgX193ZWJwYWNrX2V4cG9ydHNfX1NoYXBlIGFzIFNoYXBlLCBfX3dlYnBhY2tfZXhwb3J0c19fU2lkZSBhcyBTaWRlLCBfX3dlYnBhY2tfZXhwb3J0c19fU29ydGVkTGlzdCBhcyBTb3J0ZWRMaXN0LCBfX3dlYnBhY2tfZXhwb3J0c19fU291bmQgYXMgU291bmQsIF9fd2VicGFja19leHBvcnRzX19TcHJpdGUgYXMgU3ByaXRlLCBfX3dlYnBhY2tfZXhwb3J0c19fU3ByaXRlRm9udCBhcyBTcHJpdGVGb250LCBfX3dlYnBhY2tfZXhwb3J0c19fU3ByaXRlU2hlZXQgYXMgU3ByaXRlU2hlZXQsIF9fd2VicGFja19leHBvcnRzX19TdHJhdGVneUNvbnRhaW5lciBhcyBTdHJhdGVneUNvbnRhaW5lciwgX193ZWJwYWNrX2V4cG9ydHNfX1N0cmVhbSBhcyBTdHJlYW0sIF9fd2VicGFja19leHBvcnRzX19TdWJzY3JpYmVFdmVudCBhcyBTdWJzY3JpYmVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1N5c3RlbSBhcyBTeXN0ZW0sIF9fd2VicGFja19leHBvcnRzX19TeXN0ZW1NYW5hZ2VyIGFzIFN5c3RlbU1hbmFnZXIsIF9fd2VicGFja19leHBvcnRzX19TeXN0ZW1UeXBlIGFzIFN5c3RlbVR5cGUsIF9fd2VicGFja19leHBvcnRzX19UYWdDb21wb25lbnQgYXMgVGFnQ29tcG9uZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fVGV4dCBhcyBUZXh0LCBfX3dlYnBhY2tfZXhwb3J0c19fVGV4dEFsaWduIGFzIFRleHRBbGlnbiwgX193ZWJwYWNrX2V4cG9ydHNfX1RpbGVNYXAgYXMgVGlsZU1hcCwgX193ZWJwYWNrX2V4cG9ydHNfX1RpbWVyIGFzIFRpbWVyLCBfX3dlYnBhY2tfZXhwb3J0c19fVHJhaXRzIGFzIFRyYWl0cywgX193ZWJwYWNrX2V4cG9ydHNfX1RyYW5zZm9ybUNvbXBvbmVudCBhcyBUcmFuc2Zvcm1Db21wb25lbnQsIF9fd2VicGFja19leHBvcnRzX19UcmVlTm9kZSBhcyBUcmVlTm9kZSwgX193ZWJwYWNrX2V4cG9ydHNfX1RyaWdnZXIgYXMgVHJpZ2dlciwgX193ZWJwYWNrX2V4cG9ydHNfX1Vuc3Vic2NyaWJlRXZlbnQgYXMgVW5zdWJzY3JpYmVFdmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX1V0aWwgYXMgVXRpbCwgX193ZWJwYWNrX2V4cG9ydHNfX1ZlY3RvciBhcyBWZWN0b3IsIF9fd2VicGFja19leHBvcnRzX19WZWN0b3JWaWV3IGFzIFZlY3RvclZpZXcsIF9fd2VicGFja19leHBvcnRzX19WaXNpYmxlRXZlbnQgYXMgVmlzaWJsZUV2ZW50LCBfX3dlYnBhY2tfZXhwb3J0c19fV2ViQXVkaW9JbnN0YW5jZSBhcyBXZWJBdWRpb0luc3RhbmNlLCBfX3dlYnBhY2tfZXhwb3J0c19fV29ybGQgYXMgV29ybGQsIF9fd2VicGFja19leHBvcnRzX19jYW5vbmljYWxpemVBbmdsZSBhcyBjYW5vbmljYWxpemVBbmdsZSwgX193ZWJwYWNrX2V4cG9ydHNfX2NsYW1wIGFzIGNsYW1wLCBfX3dlYnBhY2tfZXhwb3J0c19fY3JlYXRlSWQgYXMgY3JlYXRlSWQsIF9fd2VicGFja19leHBvcnRzX19oYXNHcmFwaGljc1RpY2sgYXMgaGFzR3JhcGhpY3NUaWNrLCBfX3dlYnBhY2tfZXhwb3J0c19faGFzT25Jbml0aWFsaXplIGFzIGhhc09uSW5pdGlhbGl6ZSwgX193ZWJwYWNrX2V4cG9ydHNfX2hhc09uUG9zdFVwZGF0ZSBhcyBoYXNPblBvc3RVcGRhdGUsIF9fd2VicGFja19leHBvcnRzX19oYXNPblByZVVwZGF0ZSBhcyBoYXNPblByZVVwZGF0ZSwgX193ZWJwYWNrX2V4cG9ydHNfX2hhc1Bvc3REcmF3IGFzIGhhc1Bvc3REcmF3LCBfX3dlYnBhY2tfZXhwb3J0c19faGFzUHJlRHJhdyBhcyBoYXNQcmVEcmF3LCBfX3dlYnBhY2tfZXhwb3J0c19faGFzX2luaXRpYWxpemUgYXMgaGFzX2luaXRpYWxpemUsIF9fd2VicGFja19leHBvcnRzX19oYXNfcG9zdHVwZGF0ZSBhcyBoYXNfcG9zdHVwZGF0ZSwgX193ZWJwYWNrX2V4cG9ydHNfX2hhc19wcmV1cGRhdGUgYXMgaGFzX3ByZXVwZGF0ZSwgX193ZWJwYWNrX2V4cG9ydHNfX2lzQWRkZWRDb21wb25lbnQgYXMgaXNBZGRlZENvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX2lzQWRkZWRTeXN0ZW1FbnRpdHkgYXMgaXNBZGRlZFN5c3RlbUVudGl0eSwgX193ZWJwYWNrX2V4cG9ydHNfX2lzUmVtb3ZlU3lzdGVtRW50aXR5IGFzIGlzUmVtb3ZlU3lzdGVtRW50aXR5LCBfX3dlYnBhY2tfZXhwb3J0c19faXNSZW1vdmVkQ29tcG9uZW50IGFzIGlzUmVtb3ZlZENvbXBvbmVudCwgX193ZWJwYWNrX2V4cG9ydHNfX21heE1lc3NhZ2VzIGFzIG1heE1lc3NhZ2VzLCBfX3dlYnBhY2tfZXhwb3J0c19fb2Jzb2xldGUgYXMgb2Jzb2xldGUsIF9fd2VicGFja19leHBvcnRzX19yYW5kb21JblJhbmdlIGFzIHJhbmRvbUluUmFuZ2UsIF9fd2VicGFja19leHBvcnRzX19yYW5kb21JbnRJblJhbmdlIGFzIHJhbmRvbUludEluUmFuZ2UsIF9fd2VicGFja19leHBvcnRzX19yYW5nZSBhcyByYW5nZSwgX193ZWJwYWNrX2V4cG9ydHNfX3Jlc2V0T2Jzb2xldGVDb3VudGVyIGFzIHJlc2V0T2Jzb2xldGVDb3VudGVyLCBfX3dlYnBhY2tfZXhwb3J0c19fdG9EZWdyZWVzIGFzIHRvRGVncmVlcywgX193ZWJwYWNrX2V4cG9ydHNfX3RvUmFkaWFucyBhcyB0b1JhZGlhbnMsIF9fd2VicGFja19leHBvcnRzX192ZWMgYXMgdmVjIH07XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4Y2FsaWJ1ci5qcy5tYXAiLCJpbXBvcnQgeyBBY3RvciwgRW5naW5lIH0gZnJvbSBcImV4Y2FsaWJ1clwiO1xuaW1wb3J0IHsgU3ByaXRlU2hlZXRzIH0gZnJvbSBcIi4uL3Jlc291cmNlc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQbGF5ZXIgZXh0ZW5kcyBBY3RvciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHsgeDogNjQsIHk6IDY0LCB3aWR0aDogNjQsIGhlaWdodDogMzIgfSk7XG4gIH1cblxuICBwdWJsaWMgb25Jbml0aWFsaXplKF9lbmdpbmU6IEVuZ2luZSkge1xuICAgIHRoaXMuZ3JhcGhpY3MudXNlKFNwcml0ZVNoZWV0cy5wbGF5ZXJfaWRsZS5zcHJpdGVzWzBdKTtcbiAgfVxuXG4gIHB1YmxpYyBvblBvc3RVcGRhdGUoX2VuZ2luZTogRW5naW5lLCBfZGVsdGE6IG51bWJlcikge31cbn1cbiIsImltcG9ydCB7IEltYWdlU291cmNlLCBMb2FkZXIsIFNwcml0ZVNoZWV0IH0gZnJvbSBcImV4Y2FsaWJ1clwiO1xuaW1wb3J0IHBsYXllcklkbGVGaWxlIGZyb20gXCIuLi9hc3NldHMvaW1hZ2VzL3BsYXllcl9pZGxlLnBuZ1wiO1xuXG5jb25zdCBJbWFnZXM6IHsgW2tleTogc3RyaW5nXTogSW1hZ2VTb3VyY2UgfSA9IHtcbiAgcGxheWVySWRsZTogbmV3IEltYWdlU291cmNlKHBsYXllcklkbGVGaWxlKSxcbn07XG5cbmNvbnN0IFNwcml0ZVNoZWV0czogeyBba2V5OiBzdHJpbmddOiBTcHJpdGVTaGVldCB9ID0ge1xuICBwbGF5ZXJfaWRsZTogU3ByaXRlU2hlZXQuZnJvbUltYWdlU291cmNlKHtcbiAgICBpbWFnZTogSW1hZ2VzLnBsYXllcklkbGUsXG4gICAgZ3JpZDoge1xuICAgICAgY29sdW1uczogMSxcbiAgICAgIHJvd3M6IDEsXG4gICAgICBzcHJpdGVXaWR0aDogNjQsXG4gICAgICBzcHJpdGVIZWlnaHQ6IDMyLFxuICAgIH0sXG4gIH0pLFxufTtcblxuY29uc3QgbG9hZGVyID0gbmV3IExvYWRlcigpO1xuZm9yIChjb25zdCBpbWFnZSBpbiBJbWFnZXMpIHtcbiAgbG9hZGVyLmFkZFJlc291cmNlKEltYWdlc1tpbWFnZV0pO1xufVxuXG5leHBvcnQgeyBsb2FkZXIsIFNwcml0ZVNoZWV0cyB9O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY1xuXHRpZiAoIXNjcmlwdFVybCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0aWYoc2NyaXB0cy5sZW5ndGgpIHNjcmlwdFVybCA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5zcmNcblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmw7IiwiaW1wb3J0IHsgRW5naW5lIH0gZnJvbSBcImV4Y2FsaWJ1clwiO1xuaW1wb3J0IFBsYXllciBmcm9tIFwiLi9hY3RvcnMvcGxheWVyXCI7XG5pbXBvcnQgeyBsb2FkZXIgfSBmcm9tIFwiLi9yZXNvdXJjZXNcIjtcblxuY29uc3QgZ2FtZSA9IG5ldyBFbmdpbmUoe1xuICB3aWR0aDogODAwLFxuICBoZWlnaHQ6IDYwMCxcbn0pO1xuXG5nYW1lLnN0YXJ0KGxvYWRlcik7XG5cbmNvbnN0IHBsYXllciA9IG5ldyBQbGF5ZXIoKTtcbmdhbWUuYWRkKHBsYXllcik7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=